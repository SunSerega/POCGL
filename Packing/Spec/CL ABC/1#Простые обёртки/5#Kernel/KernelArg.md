


Методы, запускающие `Kernel` принимают специальные аргументы типа `KernelArg`, которые передаются в OpenCL-C код.\
Экземпляр `KernelArg` может быть создан из нескольких типов значений, а точнее:
```
## uses OpenCLABC;

var k: Kernel;
var val1 := 3;
var val2 := 5;
var a: array of byte;

k.Exec1(1,
  // Передавать можно:
  
  // Области памяти
  new CLArray<byte>(1),
  new MemorySegment(1),
  // Очереди возвращающие область памяти
  HFQ(()->new MemorySegment(1)),
  // В том числе CLArrayCCQ и т.п.
  CLArray&<byte>.Create(1).NewQueue,
  
  // И указатель на размерное значение
  // (в kernel попадёт само значение, не указатель)
  @val2,
  // Так нельзя, потому что val1 была захвачена лямбдой из HFQ
//  @val1,
  // Расширенный набор параметров для передачи адреса
  KernelArg.FromData(new System.IntPtr(@val2), new System.UIntPtr(sizeof(integer))),
  
  // Размерное значение
  val1,
  HFQ(()->val1),
  
  // Массив размерных значений
  //TODO Пока не работает из за #2552
//  a,
//  HFQ(()->a)
  //TODO Можно пока явно использовать KernelArg.FromArray
  KernelArg.FromArray(a),
  KernelArg.FromArrayCQ(HFQ(()->a))
  
);
```
Обратите внимание, `KernelArg` из указателя на `val2` будет немного эффективнее
чем `KernelArg` из самого значения `val2`. Но эту возможность стоит использовать
только как тонкую оптимизацию, потому что много чего может пойти не так.
Если передавать `@val2` в качестве `KernelArg` - надо знать все тонкости.

---

Если `@x` передали вкачестве `KernelArg`:

1. `x` не может быть глобальной переменной или полем класса:
   ```
   uses OpenCLABC;
   
   type
     t1 = class
       val1 := 1; // Не подходит, потому что поле класса
       static val2 := 2; // И статичных полей это тоже касается
     end;
     
   var
     val3 := 3; // Глобальные переменные - тоже статические поля
     k: Kernel; // k не важно где объявлена
     
   procedure p1;
   // Теоретически подходит, но вообще это плохой стиль кода
   var val4 := 4;
   begin
     
     // А val5 однозначно подходит, потому что объявлена не только в той же
     // подпрограмме, но и прямо перед использованием в k.Exec*
     var val5 := 5;
     
     k.Exec1(1,
       
       // Это единственные 2 переменные, которые можно передавать адресом
       @val4,
       @val5
       
     );
     
   end;
   
   begin end.
   ```

2. `x` не должно быть захвачего лямбдой.\
   Хотя указатель на `x` уже можно захватывать:
   ```
   uses OpenCLABC;
   
   begin
     var k: Kernel;
     var val1 := 3;
     
     // На val1 всё ещё накладываются все ограничени,
     // когда val1_ptr использована в качестве KernelArg
     // Но к самой val1_ptr эти ограничения не применяются
     var val1_ptr := @val1;
     
     k.Exec1(1,
       
       val1,
       HFQ(()->val1_ptr^), // захватили переменную val1_ptr, а не val1
       
       // val1 нигде не захвачена, поэтому теперь так можно
       @val1,
       val1_ptr // то же самое
       
     );
     
   end.
   ```

3. Выходить из подпрограммы, где объявили `x` нельзя, пока `.Exec` не закончит выполнятся.
   Это так же значит, что возвращать очередь, содержащую `KernelArg` из `@x` обычно нельзя.\
   Но это можно обойти, если объявлять переменную в другой подпрограмме:
   ```
   uses OpenCLABC;
   
   var k: Kernel; // Вообще лучше передавать параметром в p2
   
   function p2(var val: integer): CommandQueueBase;
   begin
     
     Result := k.NewQueue.AddExec1(1,
       
       @val
       
     );
     
   end;
   
   procedure p1;
   begin
     var val: integer;
     
     var q := p2(val);
     // Опять же, q не должна продолжать выпоняться
     // после выхода из p1, потому что тут объявлена val
     Context.Default.SyncInvoke(q);
     
   end;
   
   begin
     p1;
   end.
   ```
   Тут `val` объявлена в `p1`. При этом `val` в `p2` является синонимом `val` из `p1`,
   потому что объявлена `var`-параметром - передачей по ссылке.\
   Если передать без `var` перед параметром - `val` из `p2` будет копией,
   а значит перестанет существовать после выхода из `p2`.

Обратите внимание: Компилятор не заставит вас следовать описанным тут ограничениям.
И показанные на этой странице коды могут работать не смотря на эти ограничения,
потому что саму область памяти, на которую ссылается `KernelArg` в нём, никто никогда не уничтожает.

Но в то же время эту же область памяти может использовать под другие данные, таким образом
заменяя значение которое вы пытались передать в GPU на мусорные данные.

Это плохо в первую очередь потому, что на перезапись этих данных может повлиять совершенно не связанная
часть кода, или различие архитектур компьтеров, таким образом усложняя поиск источника ошибки.

Поэтому, ещё раз, используйте передачу адреса в качестве `KernelArg` только как тонкую оптимизацию и только когда понимаете что делаете.


