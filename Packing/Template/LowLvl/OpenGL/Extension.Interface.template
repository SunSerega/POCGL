  
  
  
  ///
  glMultisample3DFX = static class
    public const _ExtStr = 'GL_3DFX_multisample';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTbuffer3DFX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_3DFX_tbuffer';
    
    private TbufferMask3DFX_adr := GetProcAddress('glTbufferMask3DFX');
    private ntv_TbufferMask3DFX_1 := GetProcOrNil&<procedure(mask: UInt32)>(TbufferMask3DFX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TbufferMask3DFX(mask: UInt32) :=
      ntv_TbufferMask3DFX_1(mask);
    
  end;
  
  ///
  glTextureCompressionFXT13DFX = static class
    public const _ExtStr = 'GL_3DFX_texture_compression_FXT1';
  end;
  
  ///
  glBlendMinmaxFactorAMD = static class
    public const _ExtStr = 'GL_AMD_blend_minmax_factor';
  end;
  
  ///
  glConservativeDepthAMD = static class
    public const _ExtStr = 'GL_AMD_conservative_depth';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDebugOutputAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_AMD_debug_output';
    
    private DebugMessageEnableAMD_adr := GetProcAddress('glDebugMessageEnableAMD');
    private ntv_DebugMessageEnableAMD_1 := GetProcOrNil&<procedure(category: DummyEnum; severity: glDebugSeverity; count: Int32; var ids: UInt32; enabled: glBool8)>(DebugMessageEnableAMD_adr);
    private ntv_DebugMessageEnableAMD_2 := GetProcOrNil&<procedure(category: DummyEnum; severity: glDebugSeverity; count: Int32; ids: IntPtr; enabled: glBool8)>(DebugMessageEnableAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageEnableAMD(category: DummyEnum; severity: glDebugSeverity; count: Int32; ids: array of UInt32; enabled: glBool8);
    type PUInt32 = ^UInt32;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_DebugMessageEnableAMD_1(category, severity, count, ids[0], enabled) else
        ntv_DebugMessageEnableAMD_1(category, severity, count, PUInt32(nil)^, enabled);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageEnableAMD(category: DummyEnum; severity: glDebugSeverity; count: Int32; var ids: UInt32; enabled: glBool8) :=
      ntv_DebugMessageEnableAMD_1(category, severity, count, ids, enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageEnableAMD(category: DummyEnum; severity: glDebugSeverity; count: Int32; ids: IntPtr; enabled: glBool8) :=
      ntv_DebugMessageEnableAMD_2(category, severity, count, ids, enabled);
    
    private DebugMessageInsertAMD_adr := GetProcAddress('glDebugMessageInsertAMD');
    private ntv_DebugMessageInsertAMD_1 := GetProcOrNil&<procedure(category: DummyEnum; severity: glDebugSeverity; id: UInt32; length: Int32; buf: IntPtr)>(DebugMessageInsertAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsertAMD(category: DummyEnum; severity: glDebugSeverity; id: UInt32; length: Int32; buf: string);
    begin
      var buf_str_ptr := Marshal.StringToHGlobalAnsi(buf);
      try
        ntv_DebugMessageInsertAMD_1(category, severity, id, length, buf_str_ptr);
      finally
        Marshal.FreeHGlobal(buf_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsertAMD(category: DummyEnum; severity: glDebugSeverity; id: UInt32; length: Int32; buf: IntPtr) :=
      ntv_DebugMessageInsertAMD_1(category, severity, id, length, buf);
    
    private DebugMessageCallbackAMD_adr := GetProcAddress('glDebugMessageCallbackAMD');
    private ntv_DebugMessageCallbackAMD_1 := GetProcOrNil&<procedure(callback: glDebugProcAMD; userParam: IntPtr)>(DebugMessageCallbackAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageCallbackAMD(callback: glDebugProcAMD; userParam: IntPtr) :=
      ntv_DebugMessageCallbackAMD_1(callback, userParam);
    
    private GetDebugMessageLogAMD_adr := GetProcAddress('glGetDebugMessageLogAMD');
    private ntv_GetDebugMessageLogAMD_1 := GetProcOrNil&<function(count: UInt32; bufSize: Int32; var categories: glDebugCategory; var severities: glDebugSeverity; var ids: UInt32; var lengths: Int32; message: IntPtr): UInt32>(GetDebugMessageLogAMD_adr);
    private ntv_GetDebugMessageLogAMD_2 := GetProcOrNil&<function(count: UInt32; bufSize: Int32; categories: IntPtr; severities: IntPtr; ids: IntPtr; lengths: IntPtr; message: IntPtr): UInt32>(GetDebugMessageLogAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogAMD(count: UInt32; bufSize: Int32; var categories: glDebugCategory; var severities: glDebugSeverity; var ids: UInt32; var lengths: Int32; message: IntPtr): UInt32 :=
      ntv_GetDebugMessageLogAMD_1(count, bufSize, categories, severities, ids, lengths, message);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogAMD(count: UInt32; bufSize: Int32; categories: IntPtr; severities: IntPtr; ids: IntPtr; lengths: IntPtr; message: IntPtr): UInt32 :=
      ntv_GetDebugMessageLogAMD_2(count, bufSize, categories, severities, ids, lengths, message);
    
  end;
  
  ///
  glDepthClampSeparateAMD = static class
    public const _ExtStr = 'GL_AMD_depth_clamp_separate';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDrawBuffersBlendAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_AMD_draw_buffers_blend';
    
    private BlendFuncIndexedAMD_adr := GetProcAddress('glBlendFuncIndexedAMD');
    private ntv_BlendFuncIndexedAMD_1 := GetProcOrNil&<procedure(buf: UInt32; src: DummyEnum; dst: DummyEnum)>(BlendFuncIndexedAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncIndexedAMD(buf: UInt32; src: DummyEnum; dst: DummyEnum) :=
      ntv_BlendFuncIndexedAMD_1(buf, src, dst);
    
    private BlendFuncSeparateIndexedAMD_adr := GetProcAddress('glBlendFuncSeparateIndexedAMD');
    private ntv_BlendFuncSeparateIndexedAMD_1 := GetProcOrNil&<procedure(buf: UInt32; srcRGB: glBlendingFactor; dstRGB: glBlendingFactor; srcAlpha: glBlendingFactor; dstAlpha: glBlendingFactor)>(BlendFuncSeparateIndexedAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparateIndexedAMD(buf: UInt32; srcRGB: glBlendingFactor; dstRGB: glBlendingFactor; srcAlpha: glBlendingFactor; dstAlpha: glBlendingFactor) :=
      ntv_BlendFuncSeparateIndexedAMD_1(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    
    private BlendEquationIndexedAMD_adr := GetProcAddress('glBlendEquationIndexedAMD');
    private ntv_BlendEquationIndexedAMD_1 := GetProcOrNil&<procedure(buf: UInt32; mode: glBlendEquationMode)>(BlendEquationIndexedAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationIndexedAMD(buf: UInt32; mode: glBlendEquationMode) :=
      ntv_BlendEquationIndexedAMD_1(buf, mode);
    
    private BlendEquationSeparateIndexedAMD_adr := GetProcAddress('glBlendEquationSeparateIndexedAMD');
    private ntv_BlendEquationSeparateIndexedAMD_1 := GetProcOrNil&<procedure(buf: UInt32; modeRGB: glBlendEquationMode; modeAlpha: glBlendEquationMode)>(BlendEquationSeparateIndexedAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparateIndexedAMD(buf: UInt32; modeRGB: glBlendEquationMode; modeAlpha: glBlendEquationMode) :=
      ntv_BlendEquationSeparateIndexedAMD_1(buf, modeRGB, modeAlpha);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFramebufferMultisampleAdvancedAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_AMD_framebuffer_multisample_advanced';
    
    private RenderbufferStorageMultisampleAdvancedAMD_adr := GetProcAddress('glRenderbufferStorageMultisampleAdvancedAMD');
    private ntv_RenderbufferStorageMultisampleAdvancedAMD_1 := GetProcOrNil&<procedure(target: glRenderbufferTarget; samples: Int32; storageSamples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32)>(RenderbufferStorageMultisampleAdvancedAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisampleAdvancedAMD(target: glRenderbufferTarget; samples: Int32; storageSamples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32) :=
      ntv_RenderbufferStorageMultisampleAdvancedAMD_1(target, samples, storageSamples, internalformat, width, height);
    
    private NamedRenderbufferStorageMultisampleAdvancedAMD_adr := GetProcAddress('glNamedRenderbufferStorageMultisampleAdvancedAMD');
    private ntv_NamedRenderbufferStorageMultisampleAdvancedAMD_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; samples: Int32; storageSamples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32)>(NamedRenderbufferStorageMultisampleAdvancedAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageMultisampleAdvancedAMD(renderbuffer: gl_renderbuffer; samples: Int32; storageSamples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32) :=
      ntv_NamedRenderbufferStorageMultisampleAdvancedAMD_1(renderbuffer, samples, storageSamples, internalformat, width, height);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFramebufferSamplePositionsAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_AMD_framebuffer_sample_positions';
    
    private FramebufferSamplePositionsfvAMD_adr := GetProcAddress('glFramebufferSamplePositionsfvAMD');
    private ntv_FramebufferSamplePositionsfvAMD_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; numsamples: UInt32; pixelindex: UInt32; var values: single)>(FramebufferSamplePositionsfvAMD_adr);
    private ntv_FramebufferSamplePositionsfvAMD_2 := GetProcOrNil&<procedure(target: glFramebufferTarget; numsamples: UInt32; pixelindex: UInt32; values: IntPtr)>(FramebufferSamplePositionsfvAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSamplePositionsfvAMD(target: glFramebufferTarget; numsamples: UInt32; pixelindex: UInt32; values: array of single);
    type PSingle = ^single;
    begin
      if (values<>nil) and (values.Length<>0) then
        ntv_FramebufferSamplePositionsfvAMD_1(target, numsamples, pixelindex, values[0]) else
        ntv_FramebufferSamplePositionsfvAMD_1(target, numsamples, pixelindex, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSamplePositionsfvAMD(target: glFramebufferTarget; numsamples: UInt32; pixelindex: UInt32; var values: single) :=
      ntv_FramebufferSamplePositionsfvAMD_1(target, numsamples, pixelindex, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSamplePositionsfvAMD(target: glFramebufferTarget; numsamples: UInt32; pixelindex: UInt32; values: IntPtr) :=
      ntv_FramebufferSamplePositionsfvAMD_2(target, numsamples, pixelindex, values);
    
    private NamedFramebufferSamplePositionsfvAMD_adr := GetProcAddress('glNamedFramebufferSamplePositionsfvAMD');
    private ntv_NamedFramebufferSamplePositionsfvAMD_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numsamples: UInt32; pixelindex: UInt32; var values: single)>(NamedFramebufferSamplePositionsfvAMD_adr);
    private ntv_NamedFramebufferSamplePositionsfvAMD_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numsamples: UInt32; pixelindex: UInt32; values: IntPtr)>(NamedFramebufferSamplePositionsfvAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSamplePositionsfvAMD(framebuffer: gl_framebuffer; numsamples: UInt32; pixelindex: UInt32; values: array of single);
    type PSingle = ^single;
    begin
      if (values<>nil) and (values.Length<>0) then
        ntv_NamedFramebufferSamplePositionsfvAMD_1(framebuffer, numsamples, pixelindex, values[0]) else
        ntv_NamedFramebufferSamplePositionsfvAMD_1(framebuffer, numsamples, pixelindex, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSamplePositionsfvAMD(framebuffer: gl_framebuffer; numsamples: UInt32; pixelindex: UInt32; var values: single) :=
      ntv_NamedFramebufferSamplePositionsfvAMD_1(framebuffer, numsamples, pixelindex, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSamplePositionsfvAMD(framebuffer: gl_framebuffer; numsamples: UInt32; pixelindex: UInt32; values: IntPtr) :=
      ntv_NamedFramebufferSamplePositionsfvAMD_2(framebuffer, numsamples, pixelindex, values);
    
    private GetFramebufferParameterfvAMD_adr := GetProcAddress('glGetFramebufferParameterfvAMD');
    private ntv_GetFramebufferParameterfvAMD_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; pname: glFramebufferAttachmentParameterName; numsamples: UInt32; pixelindex: UInt32; size: Int32; var values: single)>(GetFramebufferParameterfvAMD_adr);
    private ntv_GetFramebufferParameterfvAMD_2 := GetProcOrNil&<procedure(target: glFramebufferTarget; pname: glFramebufferAttachmentParameterName; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: IntPtr)>(GetFramebufferParameterfvAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterfvAMD(target: glFramebufferTarget; pname: glFramebufferAttachmentParameterName; numsamples: UInt32; pixelindex: UInt32; size: Int32; var values: single) :=
      ntv_GetFramebufferParameterfvAMD_1(target, pname, numsamples, pixelindex, size, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterfvAMD(target: glFramebufferTarget; pname: glFramebufferAttachmentParameterName; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: IntPtr) :=
      ntv_GetFramebufferParameterfvAMD_2(target, pname, numsamples, pixelindex, size, values);
    
    private GetNamedFramebufferParameterfvAMD_adr := GetProcAddress('glGetNamedFramebufferParameterfvAMD');
    private ntv_GetNamedFramebufferParameterfvAMD_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; var values: single)>(GetNamedFramebufferParameterfvAMD_adr);
    private ntv_GetNamedFramebufferParameterfvAMD_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: IntPtr)>(GetNamedFramebufferParameterfvAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameterfvAMD(framebuffer: gl_framebuffer; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; var values: single) :=
      ntv_GetNamedFramebufferParameterfvAMD_1(framebuffer, pname, numsamples, pixelindex, size, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameterfvAMD(framebuffer: gl_framebuffer; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: IntPtr) :=
      ntv_GetNamedFramebufferParameterfvAMD_2(framebuffer, pname, numsamples, pixelindex, size, values);
    
  end;
  
  ///
  glGcnShaderAMD = static class
    public const _ExtStr = 'GL_AMD_gcn_shader';
  end;
  
  ///
  glGpuShaderHalfFloatAMD = static class
    public const _ExtStr = 'GL_AMD_gpu_shader_half_float';
  end;
  
  ///
  glGpuShaderInt16AMD = static class
    public const _ExtStr = 'GL_AMD_gpu_shader_int16';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glGpuShaderInt64AMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_AMD_gpu_shader_int64';
    
    private Uniform1i64NV_adr := GetProcAddress('glUniform1i64NV');
    private ntv_Uniform1i64NV_1 := GetProcOrNil&<procedure(location: Int32; x: Int64)>(Uniform1i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64NV(location: Int32; x: Int64) :=
      ntv_Uniform1i64NV_1(location, x);
    
    private Uniform2i64NV_adr := GetProcAddress('glUniform2i64NV');
    private ntv_Uniform2i64NV_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64)>(Uniform2i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64NV(location: Int32; x: Int64; y: Int64) :=
      ntv_Uniform2i64NV_1(location, x, y);
    
    private Uniform3i64NV_adr := GetProcAddress('glUniform3i64NV');
    private ntv_Uniform3i64NV_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64)>(Uniform3i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64NV(location: Int32; x: Int64; y: Int64; z: Int64) :=
      ntv_Uniform3i64NV_1(location, x, y, z);
    
    private Uniform4i64NV_adr := GetProcAddress('glUniform4i64NV');
    private ntv_Uniform4i64NV_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>(Uniform4i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64NV(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) :=
      ntv_Uniform4i64NV_1(location, x, y, z, w);
    
    private Uniform1i64vNV_adr := GetProcAddress('glUniform1i64vNV');
    private ntv_Uniform1i64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(Uniform1i64vNV_adr);
    private ntv_Uniform1i64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform1i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vNV(location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform1i64vNV_1(location, count, value[0]) else
        ntv_Uniform1i64vNV_1(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vNV(location: Int32; count: Int32; var value: Int64) :=
      ntv_Uniform1i64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform1i64vNV_2(location, count, value);
    
    private Uniform2i64vNV_adr := GetProcAddress('glUniform2i64vNV');
    private ntv_Uniform2i64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(Uniform2i64vNV_adr);
    private ntv_Uniform2i64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2i64)>(Uniform2i64vNV_adr);
    private ntv_Uniform2i64vNV_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform2i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vNV(location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform2i64vNV_1(location, count, value[0]) else
        ntv_Uniform2i64vNV_1(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vNV(location: Int32; count: Int32; var value: Vec2i64) :=
      ntv_Uniform2i64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vNV(location: Int32; count: Int32; var value: Int64) :=
      ntv_Uniform2i64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform2i64vNV_3(location, count, value);
    
    private Uniform3i64vNV_adr := GetProcAddress('glUniform3i64vNV');
    private ntv_Uniform3i64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(Uniform3i64vNV_adr);
    private ntv_Uniform3i64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3i64)>(Uniform3i64vNV_adr);
    private ntv_Uniform3i64vNV_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform3i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vNV(location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform3i64vNV_1(location, count, value[0]) else
        ntv_Uniform3i64vNV_1(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vNV(location: Int32; count: Int32; var value: Vec3i64) :=
      ntv_Uniform3i64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vNV(location: Int32; count: Int32; var value: Int64) :=
      ntv_Uniform3i64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform3i64vNV_3(location, count, value);
    
    private Uniform4i64vNV_adr := GetProcAddress('glUniform4i64vNV');
    private ntv_Uniform4i64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(Uniform4i64vNV_adr);
    private ntv_Uniform4i64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4i64)>(Uniform4i64vNV_adr);
    private ntv_Uniform4i64vNV_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform4i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vNV(location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform4i64vNV_1(location, count, value[0]) else
        ntv_Uniform4i64vNV_1(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vNV(location: Int32; count: Int32; var value: Vec4i64) :=
      ntv_Uniform4i64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vNV(location: Int32; count: Int32; var value: Int64) :=
      ntv_Uniform4i64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform4i64vNV_3(location, count, value);
    
    private Uniform1ui64NV_adr := GetProcAddress('glUniform1ui64NV');
    private ntv_Uniform1ui64NV_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64)>(Uniform1ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64NV(location: Int32; x: UInt64) :=
      ntv_Uniform1ui64NV_1(location, x);
    
    private Uniform2ui64NV_adr := GetProcAddress('glUniform2ui64NV');
    private ntv_Uniform2ui64NV_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64)>(Uniform2ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64NV(location: Int32; x: UInt64; y: UInt64) :=
      ntv_Uniform2ui64NV_1(location, x, y);
    
    private Uniform3ui64NV_adr := GetProcAddress('glUniform3ui64NV');
    private ntv_Uniform3ui64NV_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64)>(Uniform3ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64NV(location: Int32; x: UInt64; y: UInt64; z: UInt64) :=
      ntv_Uniform3ui64NV_1(location, x, y, z);
    
    private Uniform4ui64NV_adr := GetProcAddress('glUniform4ui64NV');
    private ntv_Uniform4ui64NV_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>(Uniform4ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64NV(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) :=
      ntv_Uniform4ui64NV_1(location, x, y, z, w);
    
    private Uniform1ui64vNV_adr := GetProcAddress('glUniform1ui64vNV');
    private ntv_Uniform1ui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(Uniform1ui64vNV_adr);
    private ntv_Uniform1ui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform1ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform1ui64vNV_1(location, count, value[0]) else
        ntv_Uniform1ui64vNV_1(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vNV(location: Int32; count: Int32; var value: UInt64) :=
      ntv_Uniform1ui64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform1ui64vNV_2(location, count, value);
    
    private Uniform2ui64vNV_adr := GetProcAddress('glUniform2ui64vNV');
    private ntv_Uniform2ui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(Uniform2ui64vNV_adr);
    private ntv_Uniform2ui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2ui64)>(Uniform2ui64vNV_adr);
    private ntv_Uniform2ui64vNV_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform2ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform2ui64vNV_1(location, count, value[0]) else
        ntv_Uniform2ui64vNV_1(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vNV(location: Int32; count: Int32; var value: Vec2ui64) :=
      ntv_Uniform2ui64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vNV(location: Int32; count: Int32; var value: UInt64) :=
      ntv_Uniform2ui64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform2ui64vNV_3(location, count, value);
    
    private Uniform3ui64vNV_adr := GetProcAddress('glUniform3ui64vNV');
    private ntv_Uniform3ui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(Uniform3ui64vNV_adr);
    private ntv_Uniform3ui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3ui64)>(Uniform3ui64vNV_adr);
    private ntv_Uniform3ui64vNV_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform3ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform3ui64vNV_1(location, count, value[0]) else
        ntv_Uniform3ui64vNV_1(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vNV(location: Int32; count: Int32; var value: Vec3ui64) :=
      ntv_Uniform3ui64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vNV(location: Int32; count: Int32; var value: UInt64) :=
      ntv_Uniform3ui64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform3ui64vNV_3(location, count, value);
    
    private Uniform4ui64vNV_adr := GetProcAddress('glUniform4ui64vNV');
    private ntv_Uniform4ui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(Uniform4ui64vNV_adr);
    private ntv_Uniform4ui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4ui64)>(Uniform4ui64vNV_adr);
    private ntv_Uniform4ui64vNV_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform4ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform4ui64vNV_1(location, count, value[0]) else
        ntv_Uniform4ui64vNV_1(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vNV(location: Int32; count: Int32; var value: Vec4ui64) :=
      ntv_Uniform4ui64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vNV(location: Int32; count: Int32; var value: UInt64) :=
      ntv_Uniform4ui64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform4ui64vNV_3(location, count, value);
    
    private GetUniformi64vNV_adr := GetProcAddress('glGetUniformi64vNV');
    private ntv_GetUniformi64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: Int64)>(GetUniformi64vNV_adr);
    private ntv_GetUniformi64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(GetUniformi64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vNV(&program: gl_program; location: Int32; var &params: Int64) :=
      ntv_GetUniformi64vNV_1(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vNV(&program: gl_program; location: Int32; &params: IntPtr) :=
      ntv_GetUniformi64vNV_2(&program, location, &params);
    
    private GetUniformui64vNV_adr := GetProcAddress('glGetUniformui64vNV');
    private ntv_GetUniformui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: UInt64)>(GetUniformui64vNV_adr);
    private ntv_GetUniformui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(GetUniformui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vNV(&program: gl_program; location: Int32; var &params: UInt64) :=
      ntv_GetUniformui64vNV_1(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vNV(&program: gl_program; location: Int32; &params: IntPtr) :=
      ntv_GetUniformui64vNV_2(&program, location, &params);
    
    private ProgramUniform1i64NV_adr := GetProcAddress('glProgramUniform1i64NV');
    private ntv_ProgramUniform1i64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64)>(ProgramUniform1i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64NV(&program: gl_program; location: Int32; x: Int64) :=
      ntv_ProgramUniform1i64NV_1(&program, location, x);
    
    private ProgramUniform2i64NV_adr := GetProcAddress('glProgramUniform2i64NV');
    private ntv_ProgramUniform2i64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64)>(ProgramUniform2i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64NV(&program: gl_program; location: Int32; x: Int64; y: Int64) :=
      ntv_ProgramUniform2i64NV_1(&program, location, x, y);
    
    private ProgramUniform3i64NV_adr := GetProcAddress('glProgramUniform3i64NV');
    private ntv_ProgramUniform3i64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64)>(ProgramUniform3i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64NV(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64) :=
      ntv_ProgramUniform3i64NV_1(&program, location, x, y, z);
    
    private ProgramUniform4i64NV_adr := GetProcAddress('glProgramUniform4i64NV');
    private ntv_ProgramUniform4i64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>(ProgramUniform4i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64NV(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) :=
      ntv_ProgramUniform4i64NV_1(&program, location, x, y, z, w);
    
    private ProgramUniform1i64vNV_adr := GetProcAddress('glProgramUniform1i64vNV');
    private ntv_ProgramUniform1i64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(ProgramUniform1i64vNV_adr);
    private ntv_ProgramUniform1i64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vNV(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1i64vNV_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1i64vNV_1(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
      ntv_ProgramUniform1i64vNV_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1i64vNV_2(&program, location, count, value);
    
    private ProgramUniform2i64vNV_adr := GetProcAddress('glProgramUniform2i64vNV');
    private ntv_ProgramUniform2i64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(ProgramUniform2i64vNV_adr);
    private ntv_ProgramUniform2i64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2i64)>(ProgramUniform2i64vNV_adr);
    private ntv_ProgramUniform2i64vNV_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vNV(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2i64vNV_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2i64vNV_1(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Vec2i64) :=
      ntv_ProgramUniform2i64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
      ntv_ProgramUniform2i64vNV_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2i64vNV_3(&program, location, count, value);
    
    private ProgramUniform3i64vNV_adr := GetProcAddress('glProgramUniform3i64vNV');
    private ntv_ProgramUniform3i64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(ProgramUniform3i64vNV_adr);
    private ntv_ProgramUniform3i64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3i64)>(ProgramUniform3i64vNV_adr);
    private ntv_ProgramUniform3i64vNV_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vNV(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3i64vNV_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3i64vNV_1(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Vec3i64) :=
      ntv_ProgramUniform3i64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
      ntv_ProgramUniform3i64vNV_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3i64vNV_3(&program, location, count, value);
    
    private ProgramUniform4i64vNV_adr := GetProcAddress('glProgramUniform4i64vNV');
    private ntv_ProgramUniform4i64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(ProgramUniform4i64vNV_adr);
    private ntv_ProgramUniform4i64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4i64)>(ProgramUniform4i64vNV_adr);
    private ntv_ProgramUniform4i64vNV_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vNV(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4i64vNV_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4i64vNV_1(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Vec4i64) :=
      ntv_ProgramUniform4i64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
      ntv_ProgramUniform4i64vNV_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4i64vNV_3(&program, location, count, value);
    
    private ProgramUniform1ui64NV_adr := GetProcAddress('glProgramUniform1ui64NV');
    private ntv_ProgramUniform1ui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64)>(ProgramUniform1ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64NV(&program: gl_program; location: Int32; x: UInt64) :=
      ntv_ProgramUniform1ui64NV_1(&program, location, x);
    
    private ProgramUniform2ui64NV_adr := GetProcAddress('glProgramUniform2ui64NV');
    private ntv_ProgramUniform2ui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64)>(ProgramUniform2ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64NV(&program: gl_program; location: Int32; x: UInt64; y: UInt64) :=
      ntv_ProgramUniform2ui64NV_1(&program, location, x, y);
    
    private ProgramUniform3ui64NV_adr := GetProcAddress('glProgramUniform3ui64NV');
    private ntv_ProgramUniform3ui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64)>(ProgramUniform3ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64NV(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64) :=
      ntv_ProgramUniform3ui64NV_1(&program, location, x, y, z);
    
    private ProgramUniform4ui64NV_adr := GetProcAddress('glProgramUniform4ui64NV');
    private ntv_ProgramUniform4ui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>(ProgramUniform4ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64NV(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) :=
      ntv_ProgramUniform4ui64NV_1(&program, location, x, y, z, w);
    
    private ProgramUniform1ui64vNV_adr := GetProcAddress('glProgramUniform1ui64vNV');
    private ntv_ProgramUniform1ui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(ProgramUniform1ui64vNV_adr);
    private ntv_ProgramUniform1ui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1ui64vNV_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1ui64vNV_1(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
      ntv_ProgramUniform1ui64vNV_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1ui64vNV_2(&program, location, count, value);
    
    private ProgramUniform2ui64vNV_adr := GetProcAddress('glProgramUniform2ui64vNV');
    private ntv_ProgramUniform2ui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(ProgramUniform2ui64vNV_adr);
    private ntv_ProgramUniform2ui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2ui64)>(ProgramUniform2ui64vNV_adr);
    private ntv_ProgramUniform2ui64vNV_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2ui64vNV_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2ui64vNV_1(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: Vec2ui64) :=
      ntv_ProgramUniform2ui64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
      ntv_ProgramUniform2ui64vNV_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2ui64vNV_3(&program, location, count, value);
    
    private ProgramUniform3ui64vNV_adr := GetProcAddress('glProgramUniform3ui64vNV');
    private ntv_ProgramUniform3ui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(ProgramUniform3ui64vNV_adr);
    private ntv_ProgramUniform3ui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3ui64)>(ProgramUniform3ui64vNV_adr);
    private ntv_ProgramUniform3ui64vNV_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3ui64vNV_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3ui64vNV_1(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: Vec3ui64) :=
      ntv_ProgramUniform3ui64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
      ntv_ProgramUniform3ui64vNV_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3ui64vNV_3(&program, location, count, value);
    
    private ProgramUniform4ui64vNV_adr := GetProcAddress('glProgramUniform4ui64vNV');
    private ntv_ProgramUniform4ui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(ProgramUniform4ui64vNV_adr);
    private ntv_ProgramUniform4ui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4ui64)>(ProgramUniform4ui64vNV_adr);
    private ntv_ProgramUniform4ui64vNV_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4ui64vNV_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4ui64vNV_1(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: Vec4ui64) :=
      ntv_ProgramUniform4ui64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
      ntv_ProgramUniform4ui64vNV_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4ui64vNV_3(&program, location, count, value);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glInterleavedElementsAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_AMD_interleaved_elements';
    
    private VertexAttribParameteriAMD_adr := GetProcAddress('glVertexAttribParameteriAMD');
    private ntv_VertexAttribParameteriAMD_1 := GetProcOrNil&<procedure(index: UInt32; pname: DummyEnum; param: Int32)>(VertexAttribParameteriAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribParameteriAMD(index: UInt32; pname: DummyEnum; param: Int32) :=
      ntv_VertexAttribParameteriAMD_1(index, pname, param);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMultiDrawIndirectAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_AMD_multi_draw_indirect';
    
    private MultiDrawArraysIndirectAMD_adr := GetProcAddress('glMultiDrawArraysIndirectAMD');
    private ntv_MultiDrawArraysIndirectAMD_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; indirect: IntPtr; primcount: Int32; stride: Int32)>(MultiDrawArraysIndirectAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectAMD(mode: glPrimitiveType; indirect: IntPtr; primcount: Int32; stride: Int32) :=
      ntv_MultiDrawArraysIndirectAMD_1(mode, indirect, primcount, stride);
    
    private MultiDrawElementsIndirectAMD_adr := GetProcAddress('glMultiDrawElementsIndirectAMD');
    private ntv_MultiDrawElementsIndirectAMD_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr; primcount: Int32; stride: Int32)>(MultiDrawElementsIndirectAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectAMD(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr; primcount: Int32; stride: Int32) :=
      ntv_MultiDrawElementsIndirectAMD_1(mode, &type, indirect, primcount, stride);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glNameGenDeleteAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_AMD_name_gen_delete';
    
    private GenNamesAMD_adr := GetProcAddress('glGenNamesAMD');
    private ntv_GenNamesAMD_1 := GetProcOrNil&<procedure(identifier: DummyEnum; num: UInt32; var names: UInt32)>(GenNamesAMD_adr);
    private ntv_GenNamesAMD_2 := GetProcOrNil&<procedure(identifier: DummyEnum; num: UInt32; names: IntPtr)>(GenNamesAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenNamesAMD(identifier: DummyEnum; num: UInt32; names: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (names<>nil) and (names.Length<>0) then
        ntv_GenNamesAMD_1(identifier, num, names[0]) else
        ntv_GenNamesAMD_1(identifier, num, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenNamesAMD(identifier: DummyEnum; num: UInt32; var names: UInt32) :=
      ntv_GenNamesAMD_1(identifier, num, names);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenNamesAMD(identifier: DummyEnum; num: UInt32; names: IntPtr) :=
      ntv_GenNamesAMD_2(identifier, num, names);
    
    private DeleteNamesAMD_adr := GetProcAddress('glDeleteNamesAMD');
    private ntv_DeleteNamesAMD_1 := GetProcOrNil&<procedure(identifier: DummyEnum; num: UInt32; var names: UInt32)>(DeleteNamesAMD_adr);
    private ntv_DeleteNamesAMD_2 := GetProcOrNil&<procedure(identifier: DummyEnum; num: UInt32; names: IntPtr)>(DeleteNamesAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamesAMD(identifier: DummyEnum; num: UInt32; names: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (names<>nil) and (names.Length<>0) then
        ntv_DeleteNamesAMD_1(identifier, num, names[0]) else
        ntv_DeleteNamesAMD_1(identifier, num, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamesAMD(identifier: DummyEnum; num: UInt32; var names: UInt32) :=
      ntv_DeleteNamesAMD_1(identifier, num, names);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamesAMD(identifier: DummyEnum; num: UInt32; names: IntPtr) :=
      ntv_DeleteNamesAMD_2(identifier, num, names);
    
    private IsNameAMD_adr := GetProcAddress('glIsNameAMD');
    private ntv_IsNameAMD_1 := GetProcOrNil&<function(identifier: DummyEnum; name: UInt32): glBool8>(IsNameAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsNameAMD(identifier: DummyEnum; name: UInt32): glBool8 :=
      ntv_IsNameAMD_1(identifier, name);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glOcclusionQueryEventAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_AMD_occlusion_query_event';
    
    private QueryObjectParameteruiAMD_adr := GetProcAddress('glQueryObjectParameteruiAMD');
    private ntv_QueryObjectParameteruiAMD_1 := GetProcOrNil&<procedure(target: glQueryTarget; id: gl_query; pname: DummyEnum; param: glOcclusionQueryEventMask)>(QueryObjectParameteruiAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryObjectParameteruiAMD(target: glQueryTarget; id: gl_query; pname: DummyEnum; param: glOcclusionQueryEventMask) :=
      ntv_QueryObjectParameteruiAMD_1(target, id, pname, param);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPerformanceMonitorAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_AMD_performance_monitor';
    
    private GetPerfMonitorGroupsAMD_adr := GetProcAddress('glGetPerfMonitorGroupsAMD');
    private ntv_GetPerfMonitorGroupsAMD_1 := GetProcOrNil&<procedure(var numGroups: Int32; groupsSize: Int32; var groups: UInt32)>(GetPerfMonitorGroupsAMD_adr);
    private ntv_GetPerfMonitorGroupsAMD_2 := GetProcOrNil&<procedure(var numGroups: Int32; groupsSize: Int32; groups: IntPtr)>(GetPerfMonitorGroupsAMD_adr);
    private ntv_GetPerfMonitorGroupsAMD_3 := GetProcOrNil&<procedure(numGroups: IntPtr; groupsSize: Int32; var groups: UInt32)>(GetPerfMonitorGroupsAMD_adr);
    private ntv_GetPerfMonitorGroupsAMD_4 := GetProcOrNil&<procedure(numGroups: IntPtr; groupsSize: Int32; groups: IntPtr)>(GetPerfMonitorGroupsAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(var numGroups: Int32; groupsSize: Int32; var groups: UInt32) :=
      ntv_GetPerfMonitorGroupsAMD_1(numGroups, groupsSize, groups);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(var numGroups: Int32; groupsSize: Int32; groups: IntPtr) :=
      ntv_GetPerfMonitorGroupsAMD_2(numGroups, groupsSize, groups);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(numGroups: IntPtr; groupsSize: Int32; var groups: UInt32) :=
      ntv_GetPerfMonitorGroupsAMD_3(numGroups, groupsSize, groups);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(numGroups: IntPtr; groupsSize: Int32; groups: IntPtr) :=
      ntv_GetPerfMonitorGroupsAMD_4(numGroups, groupsSize, groups);
    
    private GetPerfMonitorCountersAMD_adr := GetProcAddress('glGetPerfMonitorCountersAMD');
    private ntv_GetPerfMonitorCountersAMD_1 := GetProcOrNil&<procedure(group: UInt32; var numCounters: Int32; var maxActiveCounters: Int32; counterSize: Int32; var counters: UInt32)>(GetPerfMonitorCountersAMD_adr);
    private ntv_GetPerfMonitorCountersAMD_2 := GetProcOrNil&<procedure(group: UInt32; var numCounters: Int32; var maxActiveCounters: Int32; counterSize: Int32; counters: IntPtr)>(GetPerfMonitorCountersAMD_adr);
    private ntv_GetPerfMonitorCountersAMD_3 := GetProcOrNil&<procedure(group: UInt32; var numCounters: Int32; maxActiveCounters: IntPtr; counterSize: Int32; var counters: UInt32)>(GetPerfMonitorCountersAMD_adr);
    private ntv_GetPerfMonitorCountersAMD_4 := GetProcOrNil&<procedure(group: UInt32; var numCounters: Int32; maxActiveCounters: IntPtr; counterSize: Int32; counters: IntPtr)>(GetPerfMonitorCountersAMD_adr);
    private ntv_GetPerfMonitorCountersAMD_5 := GetProcOrNil&<procedure(group: UInt32; numCounters: IntPtr; var maxActiveCounters: Int32; counterSize: Int32; var counters: UInt32)>(GetPerfMonitorCountersAMD_adr);
    private ntv_GetPerfMonitorCountersAMD_6 := GetProcOrNil&<procedure(group: UInt32; numCounters: IntPtr; var maxActiveCounters: Int32; counterSize: Int32; counters: IntPtr)>(GetPerfMonitorCountersAMD_adr);
    private ntv_GetPerfMonitorCountersAMD_7 := GetProcOrNil&<procedure(group: UInt32; numCounters: IntPtr; maxActiveCounters: IntPtr; counterSize: Int32; var counters: UInt32)>(GetPerfMonitorCountersAMD_adr);
    private ntv_GetPerfMonitorCountersAMD_8 := GetProcOrNil&<procedure(group: UInt32; numCounters: IntPtr; maxActiveCounters: IntPtr; counterSize: Int32; counters: IntPtr)>(GetPerfMonitorCountersAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; var maxActiveCounters: Int32; counterSize: Int32; var counters: UInt32) :=
      ntv_GetPerfMonitorCountersAMD_1(group, numCounters, maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; var maxActiveCounters: Int32; counterSize: Int32; counters: IntPtr) :=
      ntv_GetPerfMonitorCountersAMD_2(group, numCounters, maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; maxActiveCounters: IntPtr; counterSize: Int32; var counters: UInt32) :=
      ntv_GetPerfMonitorCountersAMD_3(group, numCounters, maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; maxActiveCounters: IntPtr; counterSize: Int32; counters: IntPtr) :=
      ntv_GetPerfMonitorCountersAMD_4(group, numCounters, maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: IntPtr; var maxActiveCounters: Int32; counterSize: Int32; var counters: UInt32) :=
      ntv_GetPerfMonitorCountersAMD_5(group, numCounters, maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: IntPtr; var maxActiveCounters: Int32; counterSize: Int32; counters: IntPtr) :=
      ntv_GetPerfMonitorCountersAMD_6(group, numCounters, maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: IntPtr; maxActiveCounters: IntPtr; counterSize: Int32; var counters: UInt32) :=
      ntv_GetPerfMonitorCountersAMD_7(group, numCounters, maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: IntPtr; maxActiveCounters: IntPtr; counterSize: Int32; counters: IntPtr) :=
      ntv_GetPerfMonitorCountersAMD_8(group, numCounters, maxActiveCounters, counterSize, counters);
    
    private GetPerfMonitorGroupStringAMD_adr := GetProcAddress('glGetPerfMonitorGroupStringAMD');
    private ntv_GetPerfMonitorGroupStringAMD_1 := GetProcOrNil&<procedure(group: UInt32; bufSize: Int32; var length: Int32; groupString: IntPtr)>(GetPerfMonitorGroupStringAMD_adr);
    private ntv_GetPerfMonitorGroupStringAMD_2 := GetProcOrNil&<procedure(group: UInt32; bufSize: Int32; length: IntPtr; groupString: IntPtr)>(GetPerfMonitorGroupStringAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupStringAMD(group: UInt32; bufSize: Int32; var length: Int32; groupString: IntPtr) :=
      ntv_GetPerfMonitorGroupStringAMD_1(group, bufSize, length, groupString);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupStringAMD(group: UInt32; bufSize: Int32; length: IntPtr; groupString: IntPtr) :=
      ntv_GetPerfMonitorGroupStringAMD_2(group, bufSize, length, groupString);
    
    private GetPerfMonitorCounterStringAMD_adr := GetProcAddress('glGetPerfMonitorCounterStringAMD');
    private ntv_GetPerfMonitorCounterStringAMD_1 := GetProcOrNil&<procedure(group: UInt32; counter: UInt32; bufSize: Int32; var length: Int32; counterString: IntPtr)>(GetPerfMonitorCounterStringAMD_adr);
    private ntv_GetPerfMonitorCounterStringAMD_2 := GetProcOrNil&<procedure(group: UInt32; counter: UInt32; bufSize: Int32; length: IntPtr; counterString: IntPtr)>(GetPerfMonitorCounterStringAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterStringAMD(group: UInt32; counter: UInt32; bufSize: Int32; var length: Int32; counterString: IntPtr) :=
      ntv_GetPerfMonitorCounterStringAMD_1(group, counter, bufSize, length, counterString);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterStringAMD(group: UInt32; counter: UInt32; bufSize: Int32; length: IntPtr; counterString: IntPtr) :=
      ntv_GetPerfMonitorCounterStringAMD_2(group, counter, bufSize, length, counterString);
    
    private GetPerfMonitorCounterInfoAMD_adr := GetProcAddress('glGetPerfMonitorCounterInfoAMD');
    private ntv_GetPerfMonitorCounterInfoAMD_1 := GetProcOrNil&<procedure(group: UInt32; counter: UInt32; pname: DummyEnum; data: IntPtr)>(GetPerfMonitorCounterInfoAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterInfoAMD(group: UInt32; counter: UInt32; pname: DummyEnum; data: IntPtr) :=
      ntv_GetPerfMonitorCounterInfoAMD_1(group, counter, pname, data);
    
    private GenPerfMonitorsAMD_adr := GetProcAddress('glGenPerfMonitorsAMD');
    private ntv_GenPerfMonitorsAMD_1 := GetProcOrNil&<procedure(n: Int32; var monitors: UInt32)>(GenPerfMonitorsAMD_adr);
    private ntv_GenPerfMonitorsAMD_2 := GetProcOrNil&<procedure(n: Int32; monitors: IntPtr)>(GenPerfMonitorsAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenPerfMonitorsAMD(n: Int32; monitors: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (monitors<>nil) and (monitors.Length<>0) then
        ntv_GenPerfMonitorsAMD_1(n, monitors[0]) else
        ntv_GenPerfMonitorsAMD_1(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenPerfMonitorsAMD(n: Int32; var monitors: UInt32) :=
      ntv_GenPerfMonitorsAMD_1(n, monitors);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenPerfMonitorsAMD(n: Int32; monitors: IntPtr) :=
      ntv_GenPerfMonitorsAMD_2(n, monitors);
    
    private DeletePerfMonitorsAMD_adr := GetProcAddress('glDeletePerfMonitorsAMD');
    private ntv_DeletePerfMonitorsAMD_1 := GetProcOrNil&<procedure(n: Int32; var monitors: UInt32)>(DeletePerfMonitorsAMD_adr);
    private ntv_DeletePerfMonitorsAMD_2 := GetProcOrNil&<procedure(n: Int32; monitors: IntPtr)>(DeletePerfMonitorsAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePerfMonitorsAMD(n: Int32; monitors: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (monitors<>nil) and (monitors.Length<>0) then
        ntv_DeletePerfMonitorsAMD_1(n, monitors[0]) else
        ntv_DeletePerfMonitorsAMD_1(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePerfMonitorsAMD(n: Int32; var monitors: UInt32) :=
      ntv_DeletePerfMonitorsAMD_1(n, monitors);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePerfMonitorsAMD(n: Int32; monitors: IntPtr) :=
      ntv_DeletePerfMonitorsAMD_2(n, monitors);
    
    private SelectPerfMonitorCountersAMD_adr := GetProcAddress('glSelectPerfMonitorCountersAMD');
    private ntv_SelectPerfMonitorCountersAMD_1 := GetProcOrNil&<procedure(monitor: UInt32; enable: glBool8; group: UInt32; numCounters: Int32; var counterList: UInt32)>(SelectPerfMonitorCountersAMD_adr);
    private ntv_SelectPerfMonitorCountersAMD_2 := GetProcOrNil&<procedure(monitor: UInt32; enable: glBool8; group: UInt32; numCounters: Int32; counterList: IntPtr)>(SelectPerfMonitorCountersAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectPerfMonitorCountersAMD(monitor: UInt32; enable: glBool8; group: UInt32; numCounters: Int32; counterList: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (counterList<>nil) and (counterList.Length<>0) then
        ntv_SelectPerfMonitorCountersAMD_1(monitor, enable, group, numCounters, counterList[0]) else
        ntv_SelectPerfMonitorCountersAMD_1(monitor, enable, group, numCounters, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectPerfMonitorCountersAMD(monitor: UInt32; enable: glBool8; group: UInt32; numCounters: Int32; var counterList: UInt32) :=
      ntv_SelectPerfMonitorCountersAMD_1(monitor, enable, group, numCounters, counterList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectPerfMonitorCountersAMD(monitor: UInt32; enable: glBool8; group: UInt32; numCounters: Int32; counterList: IntPtr) :=
      ntv_SelectPerfMonitorCountersAMD_2(monitor, enable, group, numCounters, counterList);
    
    private BeginPerfMonitorAMD_adr := GetProcAddress('glBeginPerfMonitorAMD');
    private ntv_BeginPerfMonitorAMD_1 := GetProcOrNil&<procedure(monitor: UInt32)>(BeginPerfMonitorAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginPerfMonitorAMD(monitor: UInt32) :=
      ntv_BeginPerfMonitorAMD_1(monitor);
    
    private EndPerfMonitorAMD_adr := GetProcAddress('glEndPerfMonitorAMD');
    private ntv_EndPerfMonitorAMD_1 := GetProcOrNil&<procedure(monitor: UInt32)>(EndPerfMonitorAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndPerfMonitorAMD(monitor: UInt32) :=
      ntv_EndPerfMonitorAMD_1(monitor);
    
    private GetPerfMonitorCounterDataAMD_adr := GetProcAddress('glGetPerfMonitorCounterDataAMD');
    private ntv_GetPerfMonitorCounterDataAMD_1 := GetProcOrNil&<procedure(monitor: UInt32; pname: DummyEnum; dataSize: Int32; var data: UInt32; var bytesWritten: Int32)>(GetPerfMonitorCounterDataAMD_adr);
    private ntv_GetPerfMonitorCounterDataAMD_2 := GetProcOrNil&<procedure(monitor: UInt32; pname: DummyEnum; dataSize: Int32; var data: UInt32; bytesWritten: IntPtr)>(GetPerfMonitorCounterDataAMD_adr);
    private ntv_GetPerfMonitorCounterDataAMD_3 := GetProcOrNil&<procedure(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: IntPtr; var bytesWritten: Int32)>(GetPerfMonitorCounterDataAMD_adr);
    private ntv_GetPerfMonitorCounterDataAMD_4 := GetProcOrNil&<procedure(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: IntPtr; bytesWritten: IntPtr)>(GetPerfMonitorCounterDataAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; var data: UInt32; var bytesWritten: Int32) :=
      ntv_GetPerfMonitorCounterDataAMD_1(monitor, pname, dataSize, data, bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; var data: UInt32; bytesWritten: IntPtr) :=
      ntv_GetPerfMonitorCounterDataAMD_2(monitor, pname, dataSize, data, bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: IntPtr; var bytesWritten: Int32) :=
      ntv_GetPerfMonitorCounterDataAMD_3(monitor, pname, dataSize, data, bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: IntPtr; bytesWritten: IntPtr) :=
      ntv_GetPerfMonitorCounterDataAMD_4(monitor, pname, dataSize, data, bytesWritten);
    
  end;
  
  ///
  glPinnedMemoryAMD = static class
    public const _ExtStr = 'GL_AMD_pinned_memory';
  end;
  
  ///
  glQueryBufferObjectAMD = static class
    public const _ExtStr = 'GL_AMD_query_buffer_object';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSamplePositionsAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_AMD_sample_positions';
    
    private SetMultisamplefvAMD_adr := GetProcAddress('glSetMultisamplefvAMD');
    private ntv_SetMultisamplefvAMD_1 := GetProcOrNil&<procedure(pname: DummyEnum; index: UInt32; var val: single)>(SetMultisamplefvAMD_adr);
    private ntv_SetMultisamplefvAMD_2 := GetProcOrNil&<procedure(pname: DummyEnum; index: UInt32; val: IntPtr)>(SetMultisamplefvAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetMultisamplefvAMD(pname: DummyEnum; index: UInt32; val: array of single);
    type PSingle = ^single;
    begin
      if (val<>nil) and (val.Length<>0) then
        ntv_SetMultisamplefvAMD_1(pname, index, val[0]) else
        ntv_SetMultisamplefvAMD_1(pname, index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetMultisamplefvAMD(pname: DummyEnum; index: UInt32; var val: single) :=
      ntv_SetMultisamplefvAMD_1(pname, index, val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetMultisamplefvAMD(pname: DummyEnum; index: UInt32; val: IntPtr) :=
      ntv_SetMultisamplefvAMD_2(pname, index, val);
    
  end;
  
  ///
  glSeamlessCubemapPerTextureAMD = static class
    public const _ExtStr = 'GL_AMD_seamless_cubemap_per_texture';
  end;
  
  ///
  glShaderAtomicCounterOpsAMD = static class
    public const _ExtStr = 'GL_AMD_shader_atomic_counter_ops';
  end;
  
  ///
  glShaderBallotAMD = static class
    public const _ExtStr = 'GL_AMD_shader_ballot';
  end;
  
  ///
  glShaderExplicitVertexParameterAMD = static class
    public const _ExtStr = 'GL_AMD_shader_explicit_vertex_parameter';
  end;
  
  ///
  glShaderGpuShaderHalfFloatFetchAMD = static class
    public const _ExtStr = 'GL_AMD_shader_gpu_shader_half_float_fetch';
  end;
  
  ///
  glShaderImageLoadStoreLodAMD = static class
    public const _ExtStr = 'GL_AMD_shader_image_load_store_lod';
  end;
  
  ///
  glShaderStencilExportAMD = static class
    public const _ExtStr = 'GL_AMD_shader_stencil_export';
  end;
  
  ///
  glShaderTrinaryMinmaxAMD = static class
    public const _ExtStr = 'GL_AMD_shader_trinary_minmax';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSparseTextureAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_AMD_sparse_texture';
    
    private TexStorageSparseAMD_adr := GetProcAddress('glTexStorageSparseAMD');
    private ntv_TexStorageSparseAMD_1 := GetProcOrNil&<procedure(target: glTextureTarget; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: glTextureStorageMask)>(TexStorageSparseAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageSparseAMD(target: glTextureTarget; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: glTextureStorageMask) :=
      ntv_TexStorageSparseAMD_1(target, internalFormat, width, height, depth, layers, flags);
    
    private TextureStorageSparseAMD_adr := GetProcAddress('glTextureStorageSparseAMD');
    private ntv_TextureStorageSparseAMD_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: glTextureStorageMask)>(TextureStorageSparseAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageSparseAMD(texture: gl_texture; target: glTextureTarget; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: glTextureStorageMask) :=
      ntv_TextureStorageSparseAMD_1(texture, target, internalFormat, width, height, depth, layers, flags);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glStencilOperationExtendedAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_AMD_stencil_operation_extended';
    
    private StencilOpValueAMD_adr := GetProcAddress('glStencilOpValueAMD');
    private ntv_StencilOpValueAMD_1 := GetProcOrNil&<procedure(face: glTriangleFace; value: UInt32)>(StencilOpValueAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilOpValueAMD(face: glTriangleFace; value: UInt32) :=
      ntv_StencilOpValueAMD_1(face, value);
    
  end;
  
  ///
  glTextureGatherBiasLodAMD = static class
    public const _ExtStr = 'GL_AMD_texture_gather_bias_lod';
  end;
  
  ///
  glTextureTexture4AMD = static class
    public const _ExtStr = 'GL_AMD_texture_texture4';
  end;
  
  ///
  glTransformFeedback3LinesTrianglesAMD = static class
    public const _ExtStr = 'GL_AMD_transform_feedback3_lines_triangles';
  end;
  
  ///
  glTransformFeedback4AMD = static class
    public const _ExtStr = 'GL_AMD_transform_feedback4';
  end;
  
  ///
  glVertexShaderLayerAMD = static class
    public const _ExtStr = 'GL_AMD_vertex_shader_layer';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexShaderTessellatorAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_AMD_vertex_shader_tessellator';
    
    private TessellationFactorAMD_adr := GetProcAddress('glTessellationFactorAMD');
    private ntv_TessellationFactorAMD_1 := GetProcOrNil&<procedure(factor: single)>(TessellationFactorAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TessellationFactorAMD(factor: single) :=
      ntv_TessellationFactorAMD_1(factor);
    
    private TessellationModeAMD_adr := GetProcAddress('glTessellationModeAMD');
    private ntv_TessellationModeAMD_1 := GetProcOrNil&<procedure(mode: DummyEnum)>(TessellationModeAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TessellationModeAMD(mode: DummyEnum) :=
      ntv_TessellationModeAMD_1(mode);
    
  end;
  
  ///
  glVertexShaderViewportIndexAMD = static class
    public const _ExtStr = 'GL_AMD_vertex_shader_viewport_index';
  end;
  
  ///
  glAuxDepthStencilAPPLE = static class
    public const _ExtStr = 'GL_APPLE_aux_depth_stencil';
  end;
  
  ///
  glClientStorageAPPLE = static class
    public const _ExtStr = 'GL_APPLE_client_storage';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glElementArrayAPPLE = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_APPLE_element_array';
    
    private ElementPointerAPPLE_adr := GetProcAddress('glElementPointerAPPLE');
    private ntv_ElementPointerAPPLE_1 := GetProcOrNil&<procedure(&type: glElementPointerType; pointer: IntPtr)>(ElementPointerAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ElementPointerAPPLE(&type: glElementPointerType; pointer: IntPtr) :=
      ntv_ElementPointerAPPLE_1(&type, pointer);
    
    private DrawElementArrayAPPLE_adr := GetProcAddress('glDrawElementArrayAPPLE');
    private ntv_DrawElementArrayAPPLE_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; first: Int32; count: Int32)>(DrawElementArrayAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementArrayAPPLE(mode: glPrimitiveType; first: Int32; count: Int32) :=
      ntv_DrawElementArrayAPPLE_1(mode, first, count);
    
    private DrawRangeElementArrayAPPLE_adr := GetProcAddress('glDrawRangeElementArrayAPPLE');
    private ntv_DrawRangeElementArrayAPPLE_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; start: UInt32; &end: UInt32; first: Int32; count: Int32)>(DrawRangeElementArrayAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementArrayAPPLE(mode: glPrimitiveType; start: UInt32; &end: UInt32; first: Int32; count: Int32) :=
      ntv_DrawRangeElementArrayAPPLE_1(mode, start, &end, first, count);
    
    private MultiDrawElementArrayAPPLE_adr := GetProcAddress('glMultiDrawElementArrayAPPLE');
    private ntv_MultiDrawElementArrayAPPLE_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; var first: Int32; var count: Int32; primcount: Int32)>(MultiDrawElementArrayAPPLE_adr);
    private ntv_MultiDrawElementArrayAPPLE_2 := GetProcOrNil&<procedure(mode: glPrimitiveType; var first: Int32; count: IntPtr; primcount: Int32)>(MultiDrawElementArrayAPPLE_adr);
    private ntv_MultiDrawElementArrayAPPLE_3 := GetProcOrNil&<procedure(mode: glPrimitiveType; first: IntPtr; var count: Int32; primcount: Int32)>(MultiDrawElementArrayAPPLE_adr);
    private ntv_MultiDrawElementArrayAPPLE_4 := GetProcOrNil&<procedure(mode: glPrimitiveType; first: IntPtr; count: IntPtr; primcount: Int32)>(MultiDrawElementArrayAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: glPrimitiveType; first: array of Int32; count: array of Int32; primcount: Int32);
    type PInt32 = ^Int32;
    begin
      if (first<>nil) and (first.Length<>0) then
        if (count<>nil) and (count.Length<>0) then
          ntv_MultiDrawElementArrayAPPLE_1(mode, first[0], count[0], primcount) else
          ntv_MultiDrawElementArrayAPPLE_1(mode, first[0], PInt32(nil)^, primcount) else
        if (count<>nil) and (count.Length<>0) then
          ntv_MultiDrawElementArrayAPPLE_1(mode, PInt32(nil)^, count[0], primcount) else
          ntv_MultiDrawElementArrayAPPLE_1(mode, PInt32(nil)^, PInt32(nil)^, primcount);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: glPrimitiveType; var first: Int32; var count: Int32; primcount: Int32) :=
      ntv_MultiDrawElementArrayAPPLE_1(mode, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: glPrimitiveType; var first: Int32; count: IntPtr; primcount: Int32) :=
      ntv_MultiDrawElementArrayAPPLE_2(mode, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: glPrimitiveType; first: IntPtr; var count: Int32; primcount: Int32) :=
      ntv_MultiDrawElementArrayAPPLE_3(mode, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: glPrimitiveType; first: IntPtr; count: IntPtr; primcount: Int32) :=
      ntv_MultiDrawElementArrayAPPLE_4(mode, first, count, primcount);
    
    private MultiDrawRangeElementArrayAPPLE_adr := GetProcAddress('glMultiDrawRangeElementArrayAPPLE');
    private ntv_MultiDrawRangeElementArrayAPPLE_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; start: UInt32; &end: UInt32; var first: Int32; var count: Int32; primcount: Int32)>(MultiDrawRangeElementArrayAPPLE_adr);
    private ntv_MultiDrawRangeElementArrayAPPLE_2 := GetProcOrNil&<procedure(mode: glPrimitiveType; start: UInt32; &end: UInt32; var first: Int32; count: IntPtr; primcount: Int32)>(MultiDrawRangeElementArrayAPPLE_adr);
    private ntv_MultiDrawRangeElementArrayAPPLE_3 := GetProcOrNil&<procedure(mode: glPrimitiveType; start: UInt32; &end: UInt32; first: IntPtr; var count: Int32; primcount: Int32)>(MultiDrawRangeElementArrayAPPLE_adr);
    private ntv_MultiDrawRangeElementArrayAPPLE_4 := GetProcOrNil&<procedure(mode: glPrimitiveType; start: UInt32; &end: UInt32; first: IntPtr; count: IntPtr; primcount: Int32)>(MultiDrawRangeElementArrayAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: glPrimitiveType; start: UInt32; &end: UInt32; first: array of Int32; count: array of Int32; primcount: Int32);
    type PInt32 = ^Int32;
    begin
      if (first<>nil) and (first.Length<>0) then
        if (count<>nil) and (count.Length<>0) then
          ntv_MultiDrawRangeElementArrayAPPLE_1(mode, start, &end, first[0], count[0], primcount) else
          ntv_MultiDrawRangeElementArrayAPPLE_1(mode, start, &end, first[0], PInt32(nil)^, primcount) else
        if (count<>nil) and (count.Length<>0) then
          ntv_MultiDrawRangeElementArrayAPPLE_1(mode, start, &end, PInt32(nil)^, count[0], primcount) else
          ntv_MultiDrawRangeElementArrayAPPLE_1(mode, start, &end, PInt32(nil)^, PInt32(nil)^, primcount);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: glPrimitiveType; start: UInt32; &end: UInt32; var first: Int32; var count: Int32; primcount: Int32) :=
      ntv_MultiDrawRangeElementArrayAPPLE_1(mode, start, &end, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: glPrimitiveType; start: UInt32; &end: UInt32; var first: Int32; count: IntPtr; primcount: Int32) :=
      ntv_MultiDrawRangeElementArrayAPPLE_2(mode, start, &end, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: glPrimitiveType; start: UInt32; &end: UInt32; first: IntPtr; var count: Int32; primcount: Int32) :=
      ntv_MultiDrawRangeElementArrayAPPLE_3(mode, start, &end, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: glPrimitiveType; start: UInt32; &end: UInt32; first: IntPtr; count: IntPtr; primcount: Int32) :=
      ntv_MultiDrawRangeElementArrayAPPLE_4(mode, start, &end, first, count, primcount);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFenceAPPLE = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_APPLE_fence';
    
    private GenFencesAPPLE_adr := GetProcAddress('glGenFencesAPPLE');
    private ntv_GenFencesAPPLE_1 := GetProcOrNil&<procedure(n: Int32; var fences: UInt32)>(GenFencesAPPLE_adr);
    private ntv_GenFencesAPPLE_2 := GetProcOrNil&<procedure(n: Int32; fences: IntPtr)>(GenFencesAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesAPPLE(n: Int32; fences: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (fences<>nil) and (fences.Length<>0) then
        ntv_GenFencesAPPLE_1(n, fences[0]) else
        ntv_GenFencesAPPLE_1(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesAPPLE(n: Int32; var fences: UInt32) :=
      ntv_GenFencesAPPLE_1(n, fences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesAPPLE(n: Int32; fences: IntPtr) :=
      ntv_GenFencesAPPLE_2(n, fences);
    
    private DeleteFencesAPPLE_adr := GetProcAddress('glDeleteFencesAPPLE');
    private ntv_DeleteFencesAPPLE_1 := GetProcOrNil&<procedure(n: Int32; var fences: UInt32)>(DeleteFencesAPPLE_adr);
    private ntv_DeleteFencesAPPLE_2 := GetProcOrNil&<procedure(n: Int32; fences: IntPtr)>(DeleteFencesAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesAPPLE(n: Int32; fences: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (fences<>nil) and (fences.Length<>0) then
        ntv_DeleteFencesAPPLE_1(n, fences[0]) else
        ntv_DeleteFencesAPPLE_1(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesAPPLE(n: Int32; var fences: UInt32) :=
      ntv_DeleteFencesAPPLE_1(n, fences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesAPPLE(n: Int32; fences: IntPtr) :=
      ntv_DeleteFencesAPPLE_2(n, fences);
    
    private SetFenceAPPLE_adr := GetProcAddress('glSetFenceAPPLE');
    private ntv_SetFenceAPPLE_1 := GetProcOrNil&<procedure(fence: UInt32)>(SetFenceAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFenceAPPLE(fence: UInt32) :=
      ntv_SetFenceAPPLE_1(fence);
    
    private IsFenceAPPLE_adr := GetProcAddress('glIsFenceAPPLE');
    private ntv_IsFenceAPPLE_1 := GetProcOrNil&<function(fence: UInt32): glBool8>(IsFenceAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsFenceAPPLE(fence: UInt32): glBool8 :=
      ntv_IsFenceAPPLE_1(fence);
    
    private TestFenceAPPLE_adr := GetProcAddress('glTestFenceAPPLE');
    private ntv_TestFenceAPPLE_1 := GetProcOrNil&<function(fence: UInt32): glBool8>(TestFenceAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function TestFenceAPPLE(fence: UInt32): glBool8 :=
      ntv_TestFenceAPPLE_1(fence);
    
    private FinishFenceAPPLE_adr := GetProcAddress('glFinishFenceAPPLE');
    private ntv_FinishFenceAPPLE_1 := GetProcOrNil&<procedure(fence: UInt32)>(FinishFenceAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinishFenceAPPLE(fence: UInt32) :=
      ntv_FinishFenceAPPLE_1(fence);
    
    private TestObjectAPPLE_adr := GetProcAddress('glTestObjectAPPLE');
    private ntv_TestObjectAPPLE_1 := GetProcOrNil&<function(object: glObjectType; name: UInt32): glBool8>(TestObjectAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function TestObjectAPPLE(object: glObjectType; name: UInt32): glBool8 :=
      ntv_TestObjectAPPLE_1(object, name);
    
    private FinishObjectAPPLE_adr := GetProcAddress('glFinishObjectAPPLE');
    private ntv_FinishObjectAPPLE_1 := GetProcOrNil&<procedure(object: glObjectType; name: Int32)>(FinishObjectAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinishObjectAPPLE(object: glObjectType; name: Int32) :=
      ntv_FinishObjectAPPLE_1(object, name);
    
  end;
  
  ///
  glFloatPixelsAPPLE = static class
    public const _ExtStr = 'GL_APPLE_float_pixels';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFlushBufferRangeAPPLE = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_APPLE_flush_buffer_range';
    
    private BufferParameteriAPPLE_adr := GetProcAddress('glBufferParameteriAPPLE');
    private ntv_BufferParameteriAPPLE_1 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: Int32)>(BufferParameteriAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferParameteriAPPLE(target: DummyEnum; pname: DummyEnum; param: Int32) :=
      ntv_BufferParameteriAPPLE_1(target, pname, param);
    
    private FlushMappedBufferRangeAPPLE_adr := GetProcAddress('glFlushMappedBufferRangeAPPLE');
    private ntv_FlushMappedBufferRangeAPPLE_1 := GetProcOrNil&<procedure(target: glBufferTarget; offset: IntPtr; size: UIntPtr)>(FlushMappedBufferRangeAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushMappedBufferRangeAPPLE(target: glBufferTarget; offset: IntPtr; size: UIntPtr) :=
      ntv_FlushMappedBufferRangeAPPLE_1(target, offset, size);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glObjectPurgeableAPPLE = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_APPLE_object_purgeable';
    
    private ObjectPurgeableAPPLE_adr := GetProcAddress('glObjectPurgeableAPPLE');
    private ntv_ObjectPurgeableAPPLE_1 := GetProcOrNil&<function(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum>(ObjectPurgeableAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ObjectPurgeableAPPLE(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum :=
      ntv_ObjectPurgeableAPPLE_1(objectType, name, option);
    
    private ObjectUnpurgeableAPPLE_adr := GetProcAddress('glObjectUnpurgeableAPPLE');
    private ntv_ObjectUnpurgeableAPPLE_1 := GetProcOrNil&<function(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum>(ObjectUnpurgeableAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ObjectUnpurgeableAPPLE(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum :=
      ntv_ObjectUnpurgeableAPPLE_1(objectType, name, option);
    
    private GetObjectParameterivAPPLE_adr := GetProcAddress('glGetObjectParameterivAPPLE');
    private ntv_GetObjectParameterivAPPLE_1 := GetProcOrNil&<procedure(objectType: DummyEnum; name: UInt32; pname: DummyEnum; var &params: Int32)>(GetObjectParameterivAPPLE_adr);
    private ntv_GetObjectParameterivAPPLE_2 := GetProcOrNil&<procedure(objectType: DummyEnum; name: UInt32; pname: DummyEnum; &params: IntPtr)>(GetObjectParameterivAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterivAPPLE(objectType: DummyEnum; name: UInt32; pname: DummyEnum; var &params: Int32) :=
      ntv_GetObjectParameterivAPPLE_1(objectType, name, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterivAPPLE(objectType: DummyEnum; name: UInt32; pname: DummyEnum; &params: IntPtr) :=
      ntv_GetObjectParameterivAPPLE_2(objectType, name, pname, &params);
    
  end;
  
  ///
  glRgb422APPLE = static class
    public const _ExtStr = 'GL_APPLE_rgb_422';
  end;
  
  ///
  glRowBytesAPPLE = static class
    public const _ExtStr = 'GL_APPLE_row_bytes';
  end;
  
  ///
  glSpecularVectorAPPLE = static class
    public const _ExtStr = 'GL_APPLE_specular_vector';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureRangeAPPLE = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_APPLE_texture_range';
    
    private TextureRangeAPPLE_adr := GetProcAddress('glTextureRangeAPPLE');
    private ntv_TextureRangeAPPLE_1 := GetProcOrNil&<procedure(target: DummyEnum; length: Int32; pointer: IntPtr)>(TextureRangeAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureRangeAPPLE(target: DummyEnum; length: Int32; pointer: IntPtr) :=
      ntv_TextureRangeAPPLE_1(target, length, pointer);
    
    private GetTexParameterPointervAPPLE_adr := GetProcAddress('glGetTexParameterPointervAPPLE');
    private ntv_GetTexParameterPointervAPPLE_1 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; var &params: IntPtr)>(GetTexParameterPointervAPPLE_adr);
    private ntv_GetTexParameterPointervAPPLE_2 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetTexParameterPointervAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterPointervAPPLE(target: DummyEnum; pname: DummyEnum; var &params: IntPtr) :=
      ntv_GetTexParameterPointervAPPLE_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterPointervAPPLE(target: DummyEnum; pname: DummyEnum; &params: pointer) :=
      ntv_GetTexParameterPointervAPPLE_2(target, pname, &params);
    
  end;
  
  ///
  glTransformHintAPPLE = static class
    public const _ExtStr = 'GL_APPLE_transform_hint';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexArrayObjectAPPLE = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_APPLE_vertex_array_object';
    
    private BindVertexArrayAPPLE_adr := GetProcAddress('glBindVertexArrayAPPLE');
    private ntv_BindVertexArrayAPPLE_1 := GetProcOrNil&<procedure(&array: gl_vertex_array)>(BindVertexArrayAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexArrayAPPLE(&array: gl_vertex_array) :=
      ntv_BindVertexArrayAPPLE_1(&array);
    
    private DeleteVertexArraysAPPLE_adr := GetProcAddress('glDeleteVertexArraysAPPLE');
    private ntv_DeleteVertexArraysAPPLE_1 := GetProcOrNil&<procedure(n: Int32; var arrays: gl_vertex_array)>(DeleteVertexArraysAPPLE_adr);
    private ntv_DeleteVertexArraysAPPLE_2 := GetProcOrNil&<procedure(n: Int32; arrays: IntPtr)>(DeleteVertexArraysAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArraysAPPLE(n: Int32; arrays: array of gl_vertex_array);
    type PGl_vertex_array = ^gl_vertex_array;
    begin
      if (arrays<>nil) and (arrays.Length<>0) then
        ntv_DeleteVertexArraysAPPLE_1(n, arrays[0]) else
        ntv_DeleteVertexArraysAPPLE_1(n, PGl_vertex_array(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArraysAPPLE(n: Int32; var arrays: gl_vertex_array) :=
      ntv_DeleteVertexArraysAPPLE_1(n, arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArraysAPPLE(n: Int32; arrays: IntPtr) :=
      ntv_DeleteVertexArraysAPPLE_2(n, arrays);
    
    private GenVertexArraysAPPLE_adr := GetProcAddress('glGenVertexArraysAPPLE');
    private ntv_GenVertexArraysAPPLE_1 := GetProcOrNil&<procedure(n: Int32; var arrays: gl_vertex_array)>(GenVertexArraysAPPLE_adr);
    private ntv_GenVertexArraysAPPLE_2 := GetProcOrNil&<procedure(n: Int32; arrays: IntPtr)>(GenVertexArraysAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArraysAPPLE(n: Int32; arrays: array of gl_vertex_array);
    type PGl_vertex_array = ^gl_vertex_array;
    begin
      if (arrays<>nil) and (arrays.Length<>0) then
        ntv_GenVertexArraysAPPLE_1(n, arrays[0]) else
        ntv_GenVertexArraysAPPLE_1(n, PGl_vertex_array(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArraysAPPLE(n: Int32; var arrays: gl_vertex_array) :=
      ntv_GenVertexArraysAPPLE_1(n, arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArraysAPPLE(n: Int32; arrays: IntPtr) :=
      ntv_GenVertexArraysAPPLE_2(n, arrays);
    
    private IsVertexArrayAPPLE_adr := GetProcAddress('glIsVertexArrayAPPLE');
    private ntv_IsVertexArrayAPPLE_1 := GetProcOrNil&<function(&array: gl_vertex_array): glBool8>(IsVertexArrayAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsVertexArrayAPPLE(&array: gl_vertex_array): glBool8 :=
      ntv_IsVertexArrayAPPLE_1(&array);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexArrayRangeAPPLE = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_APPLE_vertex_array_range';
    
    private VertexArrayRangeAPPLE_adr := GetProcAddress('glVertexArrayRangeAPPLE');
    private ntv_VertexArrayRangeAPPLE_1 := GetProcOrNil&<procedure(length: Int32; pointer: IntPtr)>(VertexArrayRangeAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayRangeAPPLE(length: Int32; pointer: IntPtr) :=
      ntv_VertexArrayRangeAPPLE_1(length, pointer);
    
    private FlushVertexArrayRangeAPPLE_adr := GetProcAddress('glFlushVertexArrayRangeAPPLE');
    private ntv_FlushVertexArrayRangeAPPLE_1 := GetProcOrNil&<procedure(length: Int32; pointer: IntPtr)>(FlushVertexArrayRangeAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushVertexArrayRangeAPPLE(length: Int32; pointer: IntPtr) :=
      ntv_FlushVertexArrayRangeAPPLE_1(length, pointer);
    
    private VertexArrayParameteriAPPLE_adr := GetProcAddress('glVertexArrayParameteriAPPLE');
    private ntv_VertexArrayParameteriAPPLE_1 := GetProcOrNil&<procedure(pname: glVertexArrayParameterName; param: Int32)>(VertexArrayParameteriAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayParameteriAPPLE(pname: glVertexArrayParameterName; param: Int32) :=
      ntv_VertexArrayParameteriAPPLE_1(pname, param);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexProgramEvaluatorsAPPLE = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_APPLE_vertex_program_evaluators';
    
    private EnableVertexAttribAPPLE_adr := GetProcAddress('glEnableVertexAttribAPPLE');
    private ntv_EnableVertexAttribAPPLE_1 := GetProcOrNil&<procedure(index: UInt32; pname: DummyEnum)>(EnableVertexAttribAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexAttribAPPLE(index: UInt32; pname: DummyEnum) :=
      ntv_EnableVertexAttribAPPLE_1(index, pname);
    
    private DisableVertexAttribAPPLE_adr := GetProcAddress('glDisableVertexAttribAPPLE');
    private ntv_DisableVertexAttribAPPLE_1 := GetProcOrNil&<procedure(index: UInt32; pname: DummyEnum)>(DisableVertexAttribAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexAttribAPPLE(index: UInt32; pname: DummyEnum) :=
      ntv_DisableVertexAttribAPPLE_1(index, pname);
    
    private IsVertexAttribEnabledAPPLE_adr := GetProcAddress('glIsVertexAttribEnabledAPPLE');
    private ntv_IsVertexAttribEnabledAPPLE_1 := GetProcOrNil&<function(index: UInt32; pname: DummyEnum): glBool8>(IsVertexAttribEnabledAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsVertexAttribEnabledAPPLE(index: UInt32; pname: DummyEnum): glBool8 :=
      ntv_IsVertexAttribEnabledAPPLE_1(index, pname);
    
    private MapVertexAttrib1dAPPLE_adr := GetProcAddress('glMapVertexAttrib1dAPPLE');
    private ntv_MapVertexAttrib1dAPPLE_1 := GetProcOrNil&<procedure(index: UInt32; size: UInt32; u1: double; u2: double; stride: Int32; order: Int32; var points: double)>(MapVertexAttrib1dAPPLE_adr);
    private ntv_MapVertexAttrib1dAPPLE_2 := GetProcOrNil&<procedure(index: UInt32; size: UInt32; u1: double; u2: double; stride: Int32; order: Int32; points: IntPtr)>(MapVertexAttrib1dAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; stride: Int32; order: Int32; points: array of double);
    type PDouble = ^double;
    begin
      if (points<>nil) and (points.Length<>0) then
        ntv_MapVertexAttrib1dAPPLE_1(index, size, u1, u2, stride, order, points[0]) else
        ntv_MapVertexAttrib1dAPPLE_1(index, size, u1, u2, stride, order, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; stride: Int32; order: Int32; var points: double) :=
      ntv_MapVertexAttrib1dAPPLE_1(index, size, u1, u2, stride, order, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; stride: Int32; order: Int32; points: IntPtr) :=
      ntv_MapVertexAttrib1dAPPLE_2(index, size, u1, u2, stride, order, points);
    
    private MapVertexAttrib1fAPPLE_adr := GetProcAddress('glMapVertexAttrib1fAPPLE');
    private ntv_MapVertexAttrib1fAPPLE_1 := GetProcOrNil&<procedure(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; var points: single)>(MapVertexAttrib1fAPPLE_adr);
    private ntv_MapVertexAttrib1fAPPLE_2 := GetProcOrNil&<procedure(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; points: IntPtr)>(MapVertexAttrib1fAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; points: array of single);
    type PSingle = ^single;
    begin
      if (points<>nil) and (points.Length<>0) then
        ntv_MapVertexAttrib1fAPPLE_1(index, size, u1, u2, stride, order, points[0]) else
        ntv_MapVertexAttrib1fAPPLE_1(index, size, u1, u2, stride, order, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; var points: single) :=
      ntv_MapVertexAttrib1fAPPLE_1(index, size, u1, u2, stride, order, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; points: IntPtr) :=
      ntv_MapVertexAttrib1fAPPLE_2(index, size, u1, u2, stride, order, points);
    
    private MapVertexAttrib2dAPPLE_adr := GetProcAddress('glMapVertexAttrib2dAPPLE');
    private ntv_MapVertexAttrib2dAPPLE_1 := GetProcOrNil&<procedure(index: UInt32; size: UInt32; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; var points: double)>(MapVertexAttrib2dAPPLE_adr);
    private ntv_MapVertexAttrib2dAPPLE_2 := GetProcOrNil&<procedure(index: UInt32; size: UInt32; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; points: IntPtr)>(MapVertexAttrib2dAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; points: array of double);
    type PDouble = ^double;
    begin
      if (points<>nil) and (points.Length<>0) then
        ntv_MapVertexAttrib2dAPPLE_1(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points[0]) else
        ntv_MapVertexAttrib2dAPPLE_1(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; var points: double) :=
      ntv_MapVertexAttrib2dAPPLE_1(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; points: IntPtr) :=
      ntv_MapVertexAttrib2dAPPLE_2(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
    private MapVertexAttrib2fAPPLE_adr := GetProcAddress('glMapVertexAttrib2fAPPLE');
    private ntv_MapVertexAttrib2fAPPLE_1 := GetProcOrNil&<procedure(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; var points: single)>(MapVertexAttrib2fAPPLE_adr);
    private ntv_MapVertexAttrib2fAPPLE_2 := GetProcOrNil&<procedure(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: IntPtr)>(MapVertexAttrib2fAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: array of single);
    type PSingle = ^single;
    begin
      if (points<>nil) and (points.Length<>0) then
        ntv_MapVertexAttrib2fAPPLE_1(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points[0]) else
        ntv_MapVertexAttrib2fAPPLE_1(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; var points: single) :=
      ntv_MapVertexAttrib2fAPPLE_1(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: IntPtr) :=
      ntv_MapVertexAttrib2fAPPLE_2(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
  end;
  
  ///
  glYcbcr422APPLE = static class
    public const _ExtStr = 'GL_APPLE_ycbcr_422';
  end;
  
  ///
  glArraysOfArraysARB = static class
    public const _ExtStr = 'GL_ARB_arrays_of_arrays';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glBaseInstanceARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_base_instance';
    
    private DrawArraysInstancedBaseInstance_adr := GetProcAddress('glDrawArraysInstancedBaseInstance');
    private ntv_DrawArraysInstancedBaseInstance_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; first: Int32; count: Int32; instancecount: Int32; baseinstance: UInt32)>(DrawArraysInstancedBaseInstance_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysInstancedBaseInstance(mode: glPrimitiveType; first: Int32; count: Int32; instancecount: Int32; baseinstance: UInt32) :=
      ntv_DrawArraysInstancedBaseInstance_1(mode, first, count, instancecount, baseinstance);
    
    private DrawElementsInstancedBaseInstance_adr := GetProcAddress('glDrawElementsInstancedBaseInstance');
    private ntv_DrawElementsInstancedBaseInstance_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; instancecount: Int32; baseinstance: UInt32)>(DrawElementsInstancedBaseInstance_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseInstance(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; instancecount: Int32; baseinstance: UInt32) :=
      ntv_DrawElementsInstancedBaseInstance_1(mode, count, &type, indices, instancecount, baseinstance);
    
    private DrawElementsInstancedBaseVertexBaseInstance_adr := GetProcAddress('glDrawElementsInstancedBaseVertexBaseInstance');
    private ntv_DrawElementsInstancedBaseVertexBaseInstance_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; instancecount: Int32; basevertex: Int32; baseinstance: UInt32)>(DrawElementsInstancedBaseVertexBaseInstance_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertexBaseInstance(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; instancecount: Int32; basevertex: Int32; baseinstance: UInt32) :=
      ntv_DrawElementsInstancedBaseVertexBaseInstance_1(mode, count, &type, indices, instancecount, basevertex, baseinstance);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glBindlessTextureARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_bindless_texture';
    
    private GetTextureHandleARB_adr := GetProcAddress('glGetTextureHandleARB');
    private ntv_GetTextureHandleARB_1 := GetProcOrNil&<function(texture: gl_texture): UInt64>(GetTextureHandleARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTextureHandleARB(texture: gl_texture): UInt64 :=
      ntv_GetTextureHandleARB_1(texture);
    
    private GetTextureSamplerHandleARB_adr := GetProcAddress('glGetTextureSamplerHandleARB');
    private ntv_GetTextureSamplerHandleARB_1 := GetProcOrNil&<function(texture: gl_texture; sampler: gl_sampler): UInt64>(GetTextureSamplerHandleARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTextureSamplerHandleARB(texture: gl_texture; sampler: gl_sampler): UInt64 :=
      ntv_GetTextureSamplerHandleARB_1(texture, sampler);
    
    private MakeTextureHandleResidentARB_adr := GetProcAddress('glMakeTextureHandleResidentARB');
    private ntv_MakeTextureHandleResidentARB_1 := GetProcOrNil&<procedure(handle: UInt64)>(MakeTextureHandleResidentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeTextureHandleResidentARB(handle: UInt64) :=
      ntv_MakeTextureHandleResidentARB_1(handle);
    
    private MakeTextureHandleNonResidentARB_adr := GetProcAddress('glMakeTextureHandleNonResidentARB');
    private ntv_MakeTextureHandleNonResidentARB_1 := GetProcOrNil&<procedure(handle: UInt64)>(MakeTextureHandleNonResidentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeTextureHandleNonResidentARB(handle: UInt64) :=
      ntv_MakeTextureHandleNonResidentARB_1(handle);
    
    private GetImageHandleARB_adr := GetProcAddress('glGetImageHandleARB');
    private ntv_GetImageHandleARB_1 := GetProcOrNil&<function(texture: gl_texture; level: Int32; layered: glBool8; layer: Int32; format: glPixelFormat): UInt64>(GetImageHandleARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageHandleARB(texture: gl_texture; level: Int32; layered: glBool8; layer: Int32; format: glPixelFormat): UInt64 :=
      ntv_GetImageHandleARB_1(texture, level, layered, layer, format);
    
    private MakeImageHandleResidentARB_adr := GetProcAddress('glMakeImageHandleResidentARB');
    private ntv_MakeImageHandleResidentARB_1 := GetProcOrNil&<procedure(handle: UInt64; access: DummyEnum)>(MakeImageHandleResidentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeImageHandleResidentARB(handle: UInt64; access: DummyEnum) :=
      ntv_MakeImageHandleResidentARB_1(handle, access);
    
    private MakeImageHandleNonResidentARB_adr := GetProcAddress('glMakeImageHandleNonResidentARB');
    private ntv_MakeImageHandleNonResidentARB_1 := GetProcOrNil&<procedure(handle: UInt64)>(MakeImageHandleNonResidentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeImageHandleNonResidentARB(handle: UInt64) :=
      ntv_MakeImageHandleNonResidentARB_1(handle);
    
    private UniformHandleui64ARB_adr := GetProcAddress('glUniformHandleui64ARB');
    private ntv_UniformHandleui64ARB_1 := GetProcOrNil&<procedure(location: Int32; value: UInt64)>(UniformHandleui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64ARB(location: Int32; value: UInt64) :=
      ntv_UniformHandleui64ARB_1(location, value);
    
    private UniformHandleui64vARB_adr := GetProcAddress('glUniformHandleui64vARB');
    private ntv_UniformHandleui64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(UniformHandleui64vARB_adr);
    private ntv_UniformHandleui64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(UniformHandleui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vARB(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformHandleui64vARB_1(location, count, value[0]) else
        ntv_UniformHandleui64vARB_1(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vARB(location: Int32; count: Int32; var value: UInt64) :=
      ntv_UniformHandleui64vARB_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vARB(location: Int32; count: Int32; value: IntPtr) :=
      ntv_UniformHandleui64vARB_2(location, count, value);
    
    private ProgramUniformHandleui64ARB_adr := GetProcAddress('glProgramUniformHandleui64ARB');
    private ntv_ProgramUniformHandleui64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; value: UInt64)>(ProgramUniformHandleui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64ARB(&program: gl_program; location: Int32; value: UInt64) :=
      ntv_ProgramUniformHandleui64ARB_1(&program, location, value);
    
    private ProgramUniformHandleui64vARB_adr := GetProcAddress('glProgramUniformHandleui64vARB');
    private ntv_ProgramUniformHandleui64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var values: UInt64)>(ProgramUniformHandleui64vARB_adr);
    private ntv_ProgramUniformHandleui64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; values: IntPtr)>(ProgramUniformHandleui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vARB(&program: gl_program; location: Int32; count: Int32; values: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (values<>nil) and (values.Length<>0) then
        ntv_ProgramUniformHandleui64vARB_1(&program, location, count, values[0]) else
        ntv_ProgramUniformHandleui64vARB_1(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vARB(&program: gl_program; location: Int32; count: Int32; var values: UInt64) :=
      ntv_ProgramUniformHandleui64vARB_1(&program, location, count, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vARB(&program: gl_program; location: Int32; count: Int32; values: IntPtr) :=
      ntv_ProgramUniformHandleui64vARB_2(&program, location, count, values);
    
    private IsTextureHandleResidentARB_adr := GetProcAddress('glIsTextureHandleResidentARB');
    private ntv_IsTextureHandleResidentARB_1 := GetProcOrNil&<function(handle: UInt64): glBool8>(IsTextureHandleResidentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTextureHandleResidentARB(handle: UInt64): glBool8 :=
      ntv_IsTextureHandleResidentARB_1(handle);
    
    private IsImageHandleResidentARB_adr := GetProcAddress('glIsImageHandleResidentARB');
    private ntv_IsImageHandleResidentARB_1 := GetProcOrNil&<function(handle: UInt64): glBool8>(IsImageHandleResidentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsImageHandleResidentARB(handle: UInt64): glBool8 :=
      ntv_IsImageHandleResidentARB_1(handle);
    
    private VertexAttribL1ui64ARB_adr := GetProcAddress('glVertexAttribL1ui64ARB');
    private ntv_VertexAttribL1ui64ARB_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt64)>(VertexAttribL1ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64ARB(index: UInt32; x: UInt64) :=
      ntv_VertexAttribL1ui64ARB_1(index, x);
    
    private VertexAttribL1ui64vARB_adr := GetProcAddress('glVertexAttribL1ui64vARB');
    private ntv_VertexAttribL1ui64vARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt64)>(VertexAttribL1ui64vARB_adr);
    private ntv_VertexAttribL1ui64vARB_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL1ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vARB(index: UInt32; v: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL1ui64vARB_1(index, v[0]) else
        ntv_VertexAttribL1ui64vARB_1(index, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vARB(index: UInt32; var v: UInt64) :=
      ntv_VertexAttribL1ui64vARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL1ui64vARB_2(index, v);
    
    private GetVertexAttribLui64vARB_adr := GetProcAddress('glGetVertexAttribLui64vARB');
    private ntv_GetVertexAttribLui64vARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; var &params: UInt64)>(GetVertexAttribLui64vARB_adr);
    private ntv_GetVertexAttribLui64vARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr)>(GetVertexAttribLui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLui64vARB(index: UInt32; pname: glVertexAttribEnum; var &params: UInt64) :=
      ntv_GetVertexAttribLui64vARB_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLui64vARB(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr) :=
      ntv_GetVertexAttribLui64vARB_2(index, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glBlendFuncExtendedARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_blend_func_extended';
    
    private BindFragDataLocationIndexed_adr := GetProcAddress('glBindFragDataLocationIndexed');
    private ntv_BindFragDataLocationIndexed_1 := GetProcOrNil&<procedure(&program: gl_program; colorNumber: UInt32; index: UInt32; name: IntPtr)>(BindFragDataLocationIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationIndexed(&program: gl_program; colorNumber: UInt32; index: UInt32; name: string);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_BindFragDataLocationIndexed_1(&program, colorNumber, index, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationIndexed(&program: gl_program; colorNumber: UInt32; index: UInt32; name: IntPtr) :=
      ntv_BindFragDataLocationIndexed_1(&program, colorNumber, index, name);
    
    private GetFragDataIndex_adr := GetProcAddress('glGetFragDataIndex');
    private ntv_GetFragDataIndex_1 := GetProcOrNil&<function(&program: gl_program; name: IntPtr): Int32>(GetFragDataIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataIndex(&program: gl_program; name: string): Int32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetFragDataIndex_1(&program, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataIndex(&program: gl_program; name: IntPtr): Int32 :=
      ntv_GetFragDataIndex_1(&program, name);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glBufferStorageARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_buffer_storage';
    
    private BufferStorage_adr := GetProcAddress('glBufferStorage');
    private ntv_BufferStorage_1 := GetProcOrNil&<procedure(target: glBufferStorageTarget; size: UIntPtr; var data: Byte; flags: glBufferStorageMask)>(BufferStorage_adr);
    private ntv_BufferStorage_2 := GetProcOrNil&<procedure(target: glBufferStorageTarget; size: UIntPtr; data: IntPtr; flags: glBufferStorageMask)>(BufferStorage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorage<T>(target: glBufferStorageTarget; size: UIntPtr; data: array of T; flags: glBufferStorageMask); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        BufferStorage(target, size, data[0], flags) else
        BufferStorage(target, size, PT(nil)^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorage<T>(target: glBufferStorageTarget; size: UIntPtr; var data: T; flags: glBufferStorageMask); where T: record;
    begin
      ntv_BufferStorage_1(target, size, PByte(pointer(@data))^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorage(target: glBufferStorageTarget; size: UIntPtr; data: IntPtr; flags: glBufferStorageMask) :=
      ntv_BufferStorage_2(target, size, data, flags);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glClEventARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_cl_event';
    
    private CreateSyncFromCLeventARB_adr := GetProcAddress('glCreateSyncFromCLeventARB');
    private ntv_CreateSyncFromCLeventARB_1 := GetProcOrNil&<function(var context: IntPtr; var &event: IntPtr; flags: DummyFlags): gl_sync>(CreateSyncFromCLeventARB_adr);
    private ntv_CreateSyncFromCLeventARB_2 := GetProcOrNil&<function(var context: IntPtr; &event: pointer; flags: DummyFlags): gl_sync>(CreateSyncFromCLeventARB_adr);
    private ntv_CreateSyncFromCLeventARB_3 := GetProcOrNil&<function(context: pointer; var &event: IntPtr; flags: DummyFlags): gl_sync>(CreateSyncFromCLeventARB_adr);
    private ntv_CreateSyncFromCLeventARB_4 := GetProcOrNil&<function(context: pointer; &event: pointer; flags: DummyFlags): gl_sync>(CreateSyncFromCLeventARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: array of IntPtr; &event: array of IntPtr; flags: DummyFlags): gl_sync;
    type PIntPtr = ^IntPtr;
    begin
      Result := if (context<>nil) and (context.Length<>0) then
        if (&event<>nil) and (&event.Length<>0) then
          ntv_CreateSyncFromCLeventARB_1(context[0], &event[0], flags) else
          ntv_CreateSyncFromCLeventARB_1(context[0], PIntPtr(nil)^, flags) else
        if (&event<>nil) and (&event.Length<>0) then
          ntv_CreateSyncFromCLeventARB_1(PIntPtr(nil)^, &event[0], flags) else
          ntv_CreateSyncFromCLeventARB_1(PIntPtr(nil)^, PIntPtr(nil)^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(var context: IntPtr; var &event: IntPtr; flags: DummyFlags): gl_sync :=
      ntv_CreateSyncFromCLeventARB_1(context, &event, flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(var context: IntPtr; &event: pointer; flags: DummyFlags): gl_sync :=
      ntv_CreateSyncFromCLeventARB_2(context, &event, flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: pointer; var &event: IntPtr; flags: DummyFlags): gl_sync :=
      ntv_CreateSyncFromCLeventARB_3(context, &event, flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: pointer; &event: pointer; flags: DummyFlags): gl_sync :=
      ntv_CreateSyncFromCLeventARB_4(context, &event, flags);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glClearBufferObjectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_clear_buffer_object';
    
    private ClearBufferData_adr := GetProcAddress('glClearBufferData');
    private ntv_ClearBufferData_1 := GetProcOrNil&<procedure(target: glBufferStorageTarget; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; var data: Byte)>(ClearBufferData_adr);
    private ntv_ClearBufferData_2 := GetProcOrNil&<procedure(target: glBufferStorageTarget; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; data: IntPtr)>(ClearBufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferData<T>(target: glBufferStorageTarget; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearBufferData(target, internalformat, format, &type, data[0]) else
        ClearBufferData(target, internalformat, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferData<T>(target: glBufferStorageTarget; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; var data: T); where T: record;
    begin
      ntv_ClearBufferData_1(target, internalformat, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferData(target: glBufferStorageTarget; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; data: IntPtr) :=
      ntv_ClearBufferData_2(target, internalformat, format, &type, data);
    
    private ClearBufferSubData_adr := GetProcAddress('glClearBufferSubData');
    private ntv_ClearBufferSubData_1 := GetProcOrNil&<procedure(target: glBufferTarget; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; var data: Byte)>(ClearBufferSubData_adr);
    private ntv_ClearBufferSubData_2 := GetProcOrNil&<procedure(target: glBufferTarget; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; data: IntPtr)>(ClearBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferSubData<T>(target: glBufferTarget; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearBufferSubData(target, internalformat, offset, size, format, &type, data[0]) else
        ClearBufferSubData(target, internalformat, offset, size, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferSubData<T>(target: glBufferTarget; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; var data: T); where T: record;
    begin
      ntv_ClearBufferSubData_1(target, internalformat, offset, size, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferSubData(target: glBufferTarget; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; data: IntPtr) :=
      ntv_ClearBufferSubData_2(target, internalformat, offset, size, format, &type, data);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glClearTextureARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_clear_texture';
    
    private ClearTexImage_adr := GetProcAddress('glClearTexImage');
    private ntv_ClearTexImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; format: glPixelFormat; &type: glPixelType; data: IntPtr)>(ClearTexImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexImage(texture: gl_texture; level: Int32; format: glPixelFormat; &type: glPixelType; data: IntPtr) :=
      ntv_ClearTexImage_1(texture, level, format, &type, data);
    
    private ClearTexSubImage_adr := GetProcAddress('glClearTexSubImage');
    private ntv_ClearTexSubImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; data: IntPtr)>(ClearTexSubImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexSubImage(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; data: IntPtr) :=
      ntv_ClearTexSubImage_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, data);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glClipControlARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_clip_control';
    
    private ClipControl_adr := GetProcAddress('glClipControl');
    private ntv_ClipControl_1 := GetProcOrNil&<procedure(origin: glClipControlOrigin; depth: glClipControlDepth)>(ClipControl_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipControl(origin: glClipControlOrigin; depth: glClipControlDepth) :=
      ntv_ClipControl_1(origin, depth);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glColorBufferFloatARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_color_buffer_float';
    
    private ClampColorARB_adr := GetProcAddress('glClampColorARB');
    private ntv_ClampColorARB_1 := GetProcOrNil&<procedure(target: glClampColorTarget; clamp: glClampColorMode)>(ClampColorARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClampColorARB(target: glClampColorTarget; clamp: glClampColorMode) :=
      ntv_ClampColorARB_1(target, clamp);
    
  end;
  
  ///
  glCompatibilityARB = static class
    public const _ExtStr = 'GL_ARB_compatibility';
  end;
  
  ///
  glCompressedTexturePixelStorageARB = static class
    public const _ExtStr = 'GL_ARB_compressed_texture_pixel_storage';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glComputeShaderARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_compute_shader';
    
    private DispatchCompute_adr := GetProcAddress('glDispatchCompute');
    private ntv_DispatchCompute_1 := GetProcOrNil&<procedure(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32)>(DispatchCompute_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DispatchCompute(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32) :=
      ntv_DispatchCompute_1(num_groups_x, num_groups_y, num_groups_z);
    
    private DispatchComputeIndirect_adr := GetProcAddress('glDispatchComputeIndirect');
    private ntv_DispatchComputeIndirect_1 := GetProcOrNil&<procedure(indirect: IntPtr)>(DispatchComputeIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DispatchComputeIndirect(indirect: IntPtr) :=
      ntv_DispatchComputeIndirect_1(indirect);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glComputeVariableGroupSizeARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_compute_variable_group_size';
    
    private DispatchComputeGroupSizeARB_adr := GetProcAddress('glDispatchComputeGroupSizeARB');
    private ntv_DispatchComputeGroupSizeARB_1 := GetProcOrNil&<procedure(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32; group_size_x: UInt32; group_size_y: UInt32; group_size_z: UInt32)>(DispatchComputeGroupSizeARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DispatchComputeGroupSizeARB(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32; group_size_x: UInt32; group_size_y: UInt32; group_size_z: UInt32) :=
      ntv_DispatchComputeGroupSizeARB_1(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
    
  end;
  
  ///
  glConditionalRenderInvertedARB = static class
    public const _ExtStr = 'GL_ARB_conditional_render_inverted';
  end;
  
  ///
  glConservativeDepthARB = static class
    public const _ExtStr = 'GL_ARB_conservative_depth';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glCopyBufferARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_copy_buffer';
    
    private CopyBufferSubData_adr := GetProcAddress('glCopyBufferSubData');
    private ntv_CopyBufferSubData_1 := GetProcOrNil&<procedure(readTarget: glCopyBufferSubDataTarget; writeTarget: glCopyBufferSubDataTarget; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(CopyBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyBufferSubData(readTarget: glCopyBufferSubDataTarget; writeTarget: glCopyBufferSubDataTarget; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) :=
      ntv_CopyBufferSubData_1(readTarget, writeTarget, readOffset, writeOffset, size);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glCopyImageARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_copy_image';
    
    private CopyImageSubData_adr := GetProcAddress('glCopyImageSubData');
    private ntv_CopyImageSubData_1 := GetProcOrNil&<procedure(srcName: UInt32; srcTarget: glCopyImageSubDataTarget; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: glCopyImageSubDataTarget; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32)>(CopyImageSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyImageSubData(srcName: UInt32; srcTarget: glCopyImageSubDataTarget; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: glCopyImageSubDataTarget; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32) :=
      ntv_CopyImageSubData_1(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    
  end;
  
  ///
  glCullDistanceARB = static class
    public const _ExtStr = 'GL_ARB_cull_distance';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDebugOutputARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_debug_output';
    
    private DebugMessageControlARB_adr := GetProcAddress('glDebugMessageControlARB');
    private ntv_DebugMessageControlARB_1 := GetProcOrNil&<procedure(source: glDebugSource; &type: glDebugType; severity: glDebugSeverity; count: Int32; var ids: UInt32; enabled: glBool8)>(DebugMessageControlARB_adr);
    private ntv_DebugMessageControlARB_2 := GetProcOrNil&<procedure(source: glDebugSource; &type: glDebugType; severity: glDebugSeverity; count: Int32; ids: IntPtr; enabled: glBool8)>(DebugMessageControlARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControlARB(source: glDebugSource; &type: glDebugType; severity: glDebugSeverity; count: Int32; ids: array of UInt32; enabled: glBool8);
    type PUInt32 = ^UInt32;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_DebugMessageControlARB_1(source, &type, severity, count, ids[0], enabled) else
        ntv_DebugMessageControlARB_1(source, &type, severity, count, PUInt32(nil)^, enabled);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControlARB(source: glDebugSource; &type: glDebugType; severity: glDebugSeverity; count: Int32; var ids: UInt32; enabled: glBool8) :=
      ntv_DebugMessageControlARB_1(source, &type, severity, count, ids, enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControlARB(source: glDebugSource; &type: glDebugType; severity: glDebugSeverity; count: Int32; ids: IntPtr; enabled: glBool8) :=
      ntv_DebugMessageControlARB_2(source, &type, severity, count, ids, enabled);
    
    private DebugMessageInsertARB_adr := GetProcAddress('glDebugMessageInsertARB');
    private ntv_DebugMessageInsertARB_1 := GetProcOrNil&<procedure(source: glDebugSource; &type: glDebugType; id: UInt32; severity: glDebugSeverity; length: Int32; buf: IntPtr)>(DebugMessageInsertARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsertARB(source: glDebugSource; &type: glDebugType; id: UInt32; severity: glDebugSeverity; length: Int32; buf: string);
    begin
      var buf_str_ptr := Marshal.StringToHGlobalAnsi(buf);
      try
        ntv_DebugMessageInsertARB_1(source, &type, id, severity, length, buf_str_ptr);
      finally
        Marshal.FreeHGlobal(buf_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsertARB(source: glDebugSource; &type: glDebugType; id: UInt32; severity: glDebugSeverity; length: Int32; buf: IntPtr) :=
      ntv_DebugMessageInsertARB_1(source, &type, id, severity, length, buf);
    
    private DebugMessageCallbackARB_adr := GetProcAddress('glDebugMessageCallbackARB');
    private ntv_DebugMessageCallbackARB_1 := GetProcOrNil&<procedure(callback: glDebugProcARB; userParam: IntPtr)>(DebugMessageCallbackARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageCallbackARB(callback: glDebugProcARB; userParam: IntPtr) :=
      ntv_DebugMessageCallbackARB_1(callback, userParam);
    
    private GetDebugMessageLogARB_adr := GetProcAddress('glGetDebugMessageLogARB');
    private ntv_GetDebugMessageLogARB_1 := GetProcOrNil&<function(count: UInt32; bufSize: Int32; var sources: glDebugSource; var types: glDebugType; var ids: UInt32; var severities: glDebugSeverity; var lengths: Int32; messageLog: IntPtr): UInt32>(GetDebugMessageLogARB_adr);
    private ntv_GetDebugMessageLogARB_2 := GetProcOrNil&<function(count: UInt32; bufSize: Int32; sources: IntPtr; types: IntPtr; ids: IntPtr; severities: IntPtr; lengths: IntPtr; messageLog: IntPtr): UInt32>(GetDebugMessageLogARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogARB(count: UInt32; bufSize: Int32; var sources: glDebugSource; var types: glDebugType; var ids: UInt32; var severities: glDebugSeverity; var lengths: Int32; messageLog: IntPtr): UInt32 :=
      ntv_GetDebugMessageLogARB_1(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogARB(count: UInt32; bufSize: Int32; sources: IntPtr; types: IntPtr; ids: IntPtr; severities: IntPtr; lengths: IntPtr; messageLog: IntPtr): UInt32 :=
      ntv_GetDebugMessageLogARB_2(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    
  end;
  
  ///
  glDepthBufferFloatARB = static class
    public const _ExtStr = 'GL_ARB_depth_buffer_float';
  end;
  
  ///
  glDepthClampARB = static class
    public const _ExtStr = 'GL_ARB_depth_clamp';
  end;
  
  ///
  glDepthTextureARB = static class
    public const _ExtStr = 'GL_ARB_depth_texture';
  end;
  
  ///
  glDerivativeControlARB = static class
    public const _ExtStr = 'GL_ARB_derivative_control';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDirectStateAccessARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_direct_state_access';
    
    private CreateTransformFeedbacks_adr := GetProcAddress('glCreateTransformFeedbacks');
    private ntv_CreateTransformFeedbacks_1 := GetProcOrNil&<procedure(n: Int32; var ids: gl_transform_feedback)>(CreateTransformFeedbacks_adr);
    private ntv_CreateTransformFeedbacks_2 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(CreateTransformFeedbacks_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTransformFeedbacks(n: Int32; ids: array of gl_transform_feedback);
    type PGl_transform_feedback = ^gl_transform_feedback;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_CreateTransformFeedbacks_1(n, ids[0]) else
        ntv_CreateTransformFeedbacks_1(n, PGl_transform_feedback(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTransformFeedbacks(n: Int32; var ids: gl_transform_feedback) :=
      ntv_CreateTransformFeedbacks_1(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTransformFeedbacks(n: Int32; ids: IntPtr) :=
      ntv_CreateTransformFeedbacks_2(n, ids);
    
    private TransformFeedbackBufferBase_adr := GetProcAddress('glTransformFeedbackBufferBase');
    private ntv_TransformFeedbackBufferBase_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; index: UInt32; buffer: gl_buffer)>(TransformFeedbackBufferBase_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackBufferBase(xfb: gl_transform_feedback; index: UInt32; buffer: gl_buffer) :=
      ntv_TransformFeedbackBufferBase_1(xfb, index, buffer);
    
    private TransformFeedbackBufferRange_adr := GetProcAddress('glTransformFeedbackBufferRange');
    private ntv_TransformFeedbackBufferRange_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(TransformFeedbackBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackBufferRange(xfb: gl_transform_feedback; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
      ntv_TransformFeedbackBufferRange_1(xfb, index, buffer, offset, size);
    
    private GetTransformFeedbackiv_adr := GetProcAddress('glGetTransformFeedbackiv');
    private ntv_GetTransformFeedbackiv_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; var param: Int32)>(GetTransformFeedbackiv_adr);
    private ntv_GetTransformFeedbackiv_2 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; param: IntPtr)>(GetTransformFeedbackiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackiv(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; var param: Int32) :=
      ntv_GetTransformFeedbackiv_1(xfb, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackiv(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; param: IntPtr) :=
      ntv_GetTransformFeedbackiv_2(xfb, pname, param);
    
    private GetTransformFeedbacki_v_adr := GetProcAddress('glGetTransformFeedbacki_v');
    private ntv_GetTransformFeedbacki_v_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; index: UInt32; var param: Int32)>(GetTransformFeedbacki_v_adr);
    private ntv_GetTransformFeedbacki_v_2 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; index: UInt32; param: IntPtr)>(GetTransformFeedbacki_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki_v(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; index: UInt32; var param: Int32) :=
      ntv_GetTransformFeedbacki_v_1(xfb, pname, index, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki_v(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; index: UInt32; param: IntPtr) :=
      ntv_GetTransformFeedbacki_v_2(xfb, pname, index, param);
    
    private GetTransformFeedbacki64_v_adr := GetProcAddress('glGetTransformFeedbacki64_v');
    private ntv_GetTransformFeedbacki64_v_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; index: UInt32; var param: Int64)>(GetTransformFeedbacki64_v_adr);
    private ntv_GetTransformFeedbacki64_v_2 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; index: UInt32; param: IntPtr)>(GetTransformFeedbacki64_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki64_v(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; index: UInt32; var param: Int64) :=
      ntv_GetTransformFeedbacki64_v_1(xfb, pname, index, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki64_v(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; index: UInt32; param: IntPtr) :=
      ntv_GetTransformFeedbacki64_v_2(xfb, pname, index, param);
    
    private CreateBuffers_adr := GetProcAddress('glCreateBuffers');
    private ntv_CreateBuffers_1 := GetProcOrNil&<procedure(n: Int32; var buffers: gl_buffer)>(CreateBuffers_adr);
    private ntv_CreateBuffers_2 := GetProcOrNil&<procedure(n: Int32; buffers: IntPtr)>(CreateBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateBuffers(n: Int32; buffers: array of gl_buffer);
    type PGl_buffer = ^gl_buffer;
    begin
      if (buffers<>nil) and (buffers.Length<>0) then
        ntv_CreateBuffers_1(n, buffers[0]) else
        ntv_CreateBuffers_1(n, PGl_buffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateBuffers(n: Int32; var buffers: gl_buffer) :=
      ntv_CreateBuffers_1(n, buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateBuffers(n: Int32; buffers: IntPtr) :=
      ntv_CreateBuffers_2(n, buffers);
    
    private NamedBufferStorage_adr := GetProcAddress('glNamedBufferStorage');
    private ntv_NamedBufferStorage_1 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; var data: Byte; flags: glBufferStorageMask)>(NamedBufferStorage_adr);
    private ntv_NamedBufferStorage_2 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; data: IntPtr; flags: glBufferStorageMask)>(NamedBufferStorage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorage<T>(buffer: gl_buffer; size: UIntPtr; data: array of T; flags: glBufferStorageMask); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferStorage(buffer, size, data[0], flags) else
        NamedBufferStorage(buffer, size, PT(nil)^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorage<T>(buffer: gl_buffer; size: UIntPtr; var data: T; flags: glBufferStorageMask); where T: record;
    begin
      ntv_NamedBufferStorage_1(buffer, size, PByte(pointer(@data))^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorage(buffer: gl_buffer; size: UIntPtr; data: IntPtr; flags: glBufferStorageMask) :=
      ntv_NamedBufferStorage_2(buffer, size, data, flags);
    
    private NamedBufferData_adr := GetProcAddress('glNamedBufferData');
    private ntv_NamedBufferData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; var data: Byte; usage: glVertexBufferObjectUsage)>(NamedBufferData_adr);
    private ntv_NamedBufferData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; data: IntPtr; usage: glVertexBufferObjectUsage)>(NamedBufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferData<T>(buffer: gl_buffer; size: UIntPtr; data: array of T; usage: glVertexBufferObjectUsage); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferData(buffer, size, data[0], usage) else
        NamedBufferData(buffer, size, PT(nil)^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferData<T>(buffer: gl_buffer; size: UIntPtr; var data: T; usage: glVertexBufferObjectUsage); where T: record;
    begin
      ntv_NamedBufferData_1(buffer, size, PByte(pointer(@data))^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferData(buffer: gl_buffer; size: UIntPtr; data: IntPtr; usage: glVertexBufferObjectUsage) :=
      ntv_NamedBufferData_2(buffer, size, data, usage);
    
    private NamedBufferSubData_adr := GetProcAddress('glNamedBufferSubData');
    private ntv_NamedBufferSubData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: Byte)>(NamedBufferSubData_adr);
    private ntv_NamedBufferSubData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: IntPtr)>(NamedBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubData<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferSubData(buffer, offset, size, data[0]) else
        NamedBufferSubData(buffer, offset, size, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubData<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      ntv_NamedBufferSubData_1(buffer, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubData(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: IntPtr) :=
      ntv_NamedBufferSubData_2(buffer, offset, size, data);
    
    private CopyNamedBufferSubData_adr := GetProcAddress('glCopyNamedBufferSubData');
    private ntv_CopyNamedBufferSubData_1 := GetProcOrNil&<procedure(readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(CopyNamedBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyNamedBufferSubData(readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) :=
      ntv_CopyNamedBufferSubData_1(readBuffer, writeBuffer, readOffset, writeOffset, size);
    
    private ClearNamedBufferData_adr := GetProcAddress('glClearNamedBufferData');
    private ntv_ClearNamedBufferData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; var data: Byte)>(ClearNamedBufferData_adr);
    private ntv_ClearNamedBufferData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; data: IntPtr)>(ClearNamedBufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferData<T>(buffer: gl_buffer; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearNamedBufferData(buffer, internalformat, format, &type, data[0]) else
        ClearNamedBufferData(buffer, internalformat, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferData<T>(buffer: gl_buffer; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; var data: T); where T: record;
    begin
      ntv_ClearNamedBufferData_1(buffer, internalformat, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferData(buffer: gl_buffer; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; data: IntPtr) :=
      ntv_ClearNamedBufferData_2(buffer, internalformat, format, &type, data);
    
    private ClearNamedBufferSubData_adr := GetProcAddress('glClearNamedBufferSubData');
    private ntv_ClearNamedBufferSubData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; var data: Byte)>(ClearNamedBufferSubData_adr);
    private ntv_ClearNamedBufferSubData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; data: IntPtr)>(ClearNamedBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubData<T>(buffer: gl_buffer; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearNamedBufferSubData(buffer, internalformat, offset, size, format, &type, data[0]) else
        ClearNamedBufferSubData(buffer, internalformat, offset, size, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubData<T>(buffer: gl_buffer; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; var data: T); where T: record;
    begin
      ntv_ClearNamedBufferSubData_1(buffer, internalformat, offset, size, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubData(buffer: gl_buffer; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; data: IntPtr) :=
      ntv_ClearNamedBufferSubData_2(buffer, internalformat, offset, size, format, &type, data);
    
    private MapNamedBuffer_adr := GetProcAddress('glMapNamedBuffer');
    private ntv_MapNamedBuffer_1 := GetProcOrNil&<function(buffer: gl_buffer; access: glBufferAccess): IntPtr>(MapNamedBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapNamedBuffer(buffer: gl_buffer; access: glBufferAccess): IntPtr :=
      ntv_MapNamedBuffer_1(buffer, access);
    
    private MapNamedBufferRange_adr := GetProcAddress('glMapNamedBufferRange');
    private ntv_MapNamedBufferRange_1 := GetProcOrNil&<function(buffer: gl_buffer; offset: IntPtr; length: UIntPtr; access: glMapBufferAccessMask): IntPtr>(MapNamedBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapNamedBufferRange(buffer: gl_buffer; offset: IntPtr; length: UIntPtr; access: glMapBufferAccessMask): IntPtr :=
      ntv_MapNamedBufferRange_1(buffer, offset, length, access);
    
    private UnmapNamedBuffer_adr := GetProcAddress('glUnmapNamedBuffer');
    private ntv_UnmapNamedBuffer_1 := GetProcOrNil&<function(buffer: gl_buffer): glBool8>(UnmapNamedBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UnmapNamedBuffer(buffer: gl_buffer): glBool8 :=
      ntv_UnmapNamedBuffer_1(buffer);
    
    private FlushMappedNamedBufferRange_adr := GetProcAddress('glFlushMappedNamedBufferRange');
    private ntv_FlushMappedNamedBufferRange_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; length: UIntPtr)>(FlushMappedNamedBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushMappedNamedBufferRange(buffer: gl_buffer; offset: IntPtr; length: UIntPtr) :=
      ntv_FlushMappedNamedBufferRange_1(buffer, offset, length);
    
    private GetNamedBufferParameteriv_adr := GetProcAddress('glGetNamedBufferParameteriv');
    private ntv_GetNamedBufferParameteriv_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPName; var &params: Int32)>(GetNamedBufferParameteriv_adr);
    private ntv_GetNamedBufferParameteriv_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPName; &params: IntPtr)>(GetNamedBufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteriv(buffer: gl_buffer; pname: glBufferPName; var &params: Int32) :=
      ntv_GetNamedBufferParameteriv_1(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteriv(buffer: gl_buffer; pname: glBufferPName; &params: IntPtr) :=
      ntv_GetNamedBufferParameteriv_2(buffer, pname, &params);
    
    private GetNamedBufferParameteri64v_adr := GetProcAddress('glGetNamedBufferParameteri64v');
    private ntv_GetNamedBufferParameteri64v_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPName; var &params: Int64)>(GetNamedBufferParameteri64v_adr);
    private ntv_GetNamedBufferParameteri64v_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPName; &params: IntPtr)>(GetNamedBufferParameteri64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteri64v(buffer: gl_buffer; pname: glBufferPName; var &params: Int64) :=
      ntv_GetNamedBufferParameteri64v_1(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteri64v(buffer: gl_buffer; pname: glBufferPName; &params: IntPtr) :=
      ntv_GetNamedBufferParameteri64v_2(buffer, pname, &params);
    
    private GetNamedBufferPointerv_adr := GetProcAddress('glGetNamedBufferPointerv');
    private ntv_GetNamedBufferPointerv_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPointerName; var &params: IntPtr)>(GetNamedBufferPointerv_adr);
    private ntv_GetNamedBufferPointerv_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPointerName; &params: pointer)>(GetNamedBufferPointerv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointerv(buffer: gl_buffer; pname: glBufferPointerName; var &params: IntPtr) :=
      ntv_GetNamedBufferPointerv_1(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointerv(buffer: gl_buffer; pname: glBufferPointerName; &params: pointer) :=
      ntv_GetNamedBufferPointerv_2(buffer, pname, &params);
    
    private GetNamedBufferSubData_adr := GetProcAddress('glGetNamedBufferSubData');
    private ntv_GetNamedBufferSubData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: Byte)>(GetNamedBufferSubData_adr);
    private ntv_GetNamedBufferSubData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer)>(GetNamedBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubData<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        GetNamedBufferSubData(buffer, offset, size, data[0]) else
        GetNamedBufferSubData(buffer, offset, size, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubData<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      ntv_GetNamedBufferSubData_1(buffer, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubData(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer) :=
      ntv_GetNamedBufferSubData_2(buffer, offset, size, data);
    
    private CreateFramebuffers_adr := GetProcAddress('glCreateFramebuffers');
    private ntv_CreateFramebuffers_1 := GetProcOrNil&<procedure(n: Int32; var framebuffers: gl_framebuffer)>(CreateFramebuffers_adr);
    private ntv_CreateFramebuffers_2 := GetProcOrNil&<procedure(n: Int32; framebuffers: IntPtr)>(CreateFramebuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateFramebuffers(n: Int32; framebuffers: array of gl_framebuffer);
    type PGl_framebuffer = ^gl_framebuffer;
    begin
      if (framebuffers<>nil) and (framebuffers.Length<>0) then
        ntv_CreateFramebuffers_1(n, framebuffers[0]) else
        ntv_CreateFramebuffers_1(n, PGl_framebuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateFramebuffers(n: Int32; var framebuffers: gl_framebuffer) :=
      ntv_CreateFramebuffers_1(n, framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateFramebuffers(n: Int32; framebuffers: IntPtr) :=
      ntv_CreateFramebuffers_2(n, framebuffers);
    
    private NamedFramebufferRenderbuffer_adr := GetProcAddress('glNamedFramebufferRenderbuffer');
    private ntv_NamedFramebufferRenderbuffer_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; renderbuffertarget: glRenderbufferTarget; renderbuffer: gl_renderbuffer)>(NamedFramebufferRenderbuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferRenderbuffer(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; renderbuffertarget: glRenderbufferTarget; renderbuffer: gl_renderbuffer) :=
      ntv_NamedFramebufferRenderbuffer_1(framebuffer, attachment, renderbuffertarget, renderbuffer);
    
    private NamedFramebufferParameteri_adr := GetProcAddress('glNamedFramebufferParameteri');
    private ntv_NamedFramebufferParameteri_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: glFramebufferParameterName; param: Int32)>(NamedFramebufferParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferParameteri(framebuffer: gl_framebuffer; pname: glFramebufferParameterName; param: Int32) :=
      ntv_NamedFramebufferParameteri_1(framebuffer, pname, param);
    
    private NamedFramebufferTexture_adr := GetProcAddress('glNamedFramebufferTexture');
    private ntv_NamedFramebufferTexture_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32)>(NamedFramebufferTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTexture(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32) :=
      ntv_NamedFramebufferTexture_1(framebuffer, attachment, texture, level);
    
    private NamedFramebufferTextureLayer_adr := GetProcAddress('glNamedFramebufferTextureLayer');
    private ntv_NamedFramebufferTextureLayer_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32)>(NamedFramebufferTextureLayer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTextureLayer(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32) :=
      ntv_NamedFramebufferTextureLayer_1(framebuffer, attachment, texture, level, layer);
    
    private NamedFramebufferDrawBuffer_adr := GetProcAddress('glNamedFramebufferDrawBuffer');
    private ntv_NamedFramebufferDrawBuffer_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buf: glColorBuffer)>(NamedFramebufferDrawBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffer(framebuffer: gl_framebuffer; buf: glColorBuffer) :=
      ntv_NamedFramebufferDrawBuffer_1(framebuffer, buf);
    
    private NamedFramebufferDrawBuffers_adr := GetProcAddress('glNamedFramebufferDrawBuffers');
    private ntv_NamedFramebufferDrawBuffers_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; n: Int32; var bufs: glColorBuffer)>(NamedFramebufferDrawBuffers_adr);
    private ntv_NamedFramebufferDrawBuffers_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; n: Int32; bufs: IntPtr)>(NamedFramebufferDrawBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffers(framebuffer: gl_framebuffer; n: Int32; bufs: array of glColorBuffer);
    type PGlColorBuffer = ^glColorBuffer;
    begin
      if (bufs<>nil) and (bufs.Length<>0) then
        ntv_NamedFramebufferDrawBuffers_1(framebuffer, n, bufs[0]) else
        ntv_NamedFramebufferDrawBuffers_1(framebuffer, n, PGlColorBuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffers(framebuffer: gl_framebuffer; n: Int32; var bufs: glColorBuffer) :=
      ntv_NamedFramebufferDrawBuffers_1(framebuffer, n, bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffers(framebuffer: gl_framebuffer; n: Int32; bufs: IntPtr) :=
      ntv_NamedFramebufferDrawBuffers_2(framebuffer, n, bufs);
    
    private NamedFramebufferReadBuffer_adr := GetProcAddress('glNamedFramebufferReadBuffer');
    private ntv_NamedFramebufferReadBuffer_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; src: glColorBuffer)>(NamedFramebufferReadBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferReadBuffer(framebuffer: gl_framebuffer; src: glColorBuffer) :=
      ntv_NamedFramebufferReadBuffer_1(framebuffer, src);
    
    private InvalidateNamedFramebufferData_adr := GetProcAddress('glInvalidateNamedFramebufferData');
    private ntv_InvalidateNamedFramebufferData_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numAttachments: Int32; var attachments: glFramebufferAttachment)>(InvalidateNamedFramebufferData_adr);
    private ntv_InvalidateNamedFramebufferData_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: IntPtr)>(InvalidateNamedFramebufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferData(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: array of glFramebufferAttachment);
    type PGlFramebufferAttachment = ^glFramebufferAttachment;
    begin
      if (attachments<>nil) and (attachments.Length<>0) then
        ntv_InvalidateNamedFramebufferData_1(framebuffer, numAttachments, attachments[0]) else
        ntv_InvalidateNamedFramebufferData_1(framebuffer, numAttachments, PGlFramebufferAttachment(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferData(framebuffer: gl_framebuffer; numAttachments: Int32; var attachments: glFramebufferAttachment) :=
      ntv_InvalidateNamedFramebufferData_1(framebuffer, numAttachments, attachments);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferData(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: IntPtr) :=
      ntv_InvalidateNamedFramebufferData_2(framebuffer, numAttachments, attachments);
    
    private InvalidateNamedFramebufferSubData_adr := GetProcAddress('glInvalidateNamedFramebufferSubData');
    private ntv_InvalidateNamedFramebufferSubData_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numAttachments: Int32; var attachments: glFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32)>(InvalidateNamedFramebufferSubData_adr);
    private ntv_InvalidateNamedFramebufferSubData_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32)>(InvalidateNamedFramebufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferSubData(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: array of glFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32);
    type PGlFramebufferAttachment = ^glFramebufferAttachment;
    begin
      if (attachments<>nil) and (attachments.Length<>0) then
        ntv_InvalidateNamedFramebufferSubData_1(framebuffer, numAttachments, attachments[0], x, y, width, height) else
        ntv_InvalidateNamedFramebufferSubData_1(framebuffer, numAttachments, PGlFramebufferAttachment(nil)^, x, y, width, height);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferSubData(framebuffer: gl_framebuffer; numAttachments: Int32; var attachments: glFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_InvalidateNamedFramebufferSubData_1(framebuffer, numAttachments, attachments, x, y, width, height);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferSubData(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_InvalidateNamedFramebufferSubData_2(framebuffer, numAttachments, attachments, x, y, width, height);
    
    private ClearNamedFramebufferiv_adr := GetProcAddress('glClearNamedFramebufferiv');
    private ntv_ClearNamedFramebufferiv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; var value: Int32)>(ClearNamedFramebufferiv_adr);
    private ntv_ClearNamedFramebufferiv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: IntPtr)>(ClearNamedFramebufferiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferiv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ClearNamedFramebufferiv_1(framebuffer, buffer, drawbuffer, value[0]) else
        ntv_ClearNamedFramebufferiv_1(framebuffer, buffer, drawbuffer, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferiv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; var value: Int32) :=
      ntv_ClearNamedFramebufferiv_1(framebuffer, buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferiv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: IntPtr) :=
      ntv_ClearNamedFramebufferiv_2(framebuffer, buffer, drawbuffer, value);
    
    private ClearNamedFramebufferuiv_adr := GetProcAddress('glClearNamedFramebufferuiv');
    private ntv_ClearNamedFramebufferuiv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; var value: UInt32)>(ClearNamedFramebufferuiv_adr);
    private ntv_ClearNamedFramebufferuiv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: IntPtr)>(ClearNamedFramebufferuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferuiv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ClearNamedFramebufferuiv_1(framebuffer, buffer, drawbuffer, value[0]) else
        ntv_ClearNamedFramebufferuiv_1(framebuffer, buffer, drawbuffer, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferuiv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; var value: UInt32) :=
      ntv_ClearNamedFramebufferuiv_1(framebuffer, buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferuiv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: IntPtr) :=
      ntv_ClearNamedFramebufferuiv_2(framebuffer, buffer, drawbuffer, value);
    
    private ClearNamedFramebufferfv_adr := GetProcAddress('glClearNamedFramebufferfv');
    private ntv_ClearNamedFramebufferfv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; var value: single)>(ClearNamedFramebufferfv_adr);
    private ntv_ClearNamedFramebufferfv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: IntPtr)>(ClearNamedFramebufferfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ClearNamedFramebufferfv_1(framebuffer, buffer, drawbuffer, value[0]) else
        ntv_ClearNamedFramebufferfv_1(framebuffer, buffer, drawbuffer, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; var value: single) :=
      ntv_ClearNamedFramebufferfv_1(framebuffer, buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: IntPtr) :=
      ntv_ClearNamedFramebufferfv_2(framebuffer, buffer, drawbuffer, value);
    
    private ClearNamedFramebufferfi_adr := GetProcAddress('glClearNamedFramebufferfi');
    private ntv_ClearNamedFramebufferfi_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; depth: single; stencil: Int32)>(ClearNamedFramebufferfi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfi(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; depth: single; stencil: Int32) :=
      ntv_ClearNamedFramebufferfi_1(framebuffer, buffer, drawbuffer, depth, stencil);
    
    private BlitNamedFramebuffer_adr := GetProcAddress('glBlitNamedFramebuffer');
    private ntv_BlitNamedFramebuffer_1 := GetProcOrNil&<procedure(readFramebuffer: gl_framebuffer; drawFramebuffer: gl_framebuffer; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: glClearBufferMask; filter: glBlitFramebufferFilter)>(BlitNamedFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitNamedFramebuffer(readFramebuffer: gl_framebuffer; drawFramebuffer: gl_framebuffer; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: glClearBufferMask; filter: glBlitFramebufferFilter) :=
      ntv_BlitNamedFramebuffer_1(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    private CheckNamedFramebufferStatus_adr := GetProcAddress('glCheckNamedFramebufferStatus');
    private ntv_CheckNamedFramebufferStatus_1 := GetProcOrNil&<function(framebuffer: gl_framebuffer; target: glFramebufferTarget): glFramebufferStatus>(CheckNamedFramebufferStatus_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CheckNamedFramebufferStatus(framebuffer: gl_framebuffer; target: glFramebufferTarget): glFramebufferStatus :=
      ntv_CheckNamedFramebufferStatus_1(framebuffer, target);
    
    private GetNamedFramebufferParameteriv_adr := GetProcAddress('glGetNamedFramebufferParameteriv');
    private ntv_GetNamedFramebufferParameteriv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: glGetFramebufferParameter; var param: Int32)>(GetNamedFramebufferParameteriv_adr);
    private ntv_GetNamedFramebufferParameteriv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: glGetFramebufferParameter; param: IntPtr)>(GetNamedFramebufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameteriv(framebuffer: gl_framebuffer; pname: glGetFramebufferParameter; var param: Int32) :=
      ntv_GetNamedFramebufferParameteriv_1(framebuffer, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameteriv(framebuffer: gl_framebuffer; pname: glGetFramebufferParameter; param: IntPtr) :=
      ntv_GetNamedFramebufferParameteriv_2(framebuffer, pname, param);
    
    private GetNamedFramebufferAttachmentParameteriv_adr := GetProcAddress('glGetNamedFramebufferAttachmentParameteriv');
    private ntv_GetNamedFramebufferAttachmentParameteriv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; var &params: Int32)>(GetNamedFramebufferAttachmentParameteriv_adr);
    private ntv_GetNamedFramebufferAttachmentParameteriv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; &params: IntPtr)>(GetNamedFramebufferAttachmentParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; var &params: Int32) :=
      ntv_GetNamedFramebufferAttachmentParameteriv_1(framebuffer, attachment, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; &params: IntPtr) :=
      ntv_GetNamedFramebufferAttachmentParameteriv_2(framebuffer, attachment, pname, &params);
    
    private CreateRenderbuffers_adr := GetProcAddress('glCreateRenderbuffers');
    private ntv_CreateRenderbuffers_1 := GetProcOrNil&<procedure(n: Int32; var renderbuffers: gl_renderbuffer)>(CreateRenderbuffers_adr);
    private ntv_CreateRenderbuffers_2 := GetProcOrNil&<procedure(n: Int32; renderbuffers: IntPtr)>(CreateRenderbuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateRenderbuffers(n: Int32; renderbuffers: array of gl_renderbuffer);
    type PGl_renderbuffer = ^gl_renderbuffer;
    begin
      if (renderbuffers<>nil) and (renderbuffers.Length<>0) then
        ntv_CreateRenderbuffers_1(n, renderbuffers[0]) else
        ntv_CreateRenderbuffers_1(n, PGl_renderbuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateRenderbuffers(n: Int32; var renderbuffers: gl_renderbuffer) :=
      ntv_CreateRenderbuffers_1(n, renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateRenderbuffers(n: Int32; renderbuffers: IntPtr) :=
      ntv_CreateRenderbuffers_2(n, renderbuffers);
    
    private NamedRenderbufferStorage_adr := GetProcAddress('glNamedRenderbufferStorage');
    private ntv_NamedRenderbufferStorage_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; internalformat: glInternalFormat; width: Int32; height: Int32)>(NamedRenderbufferStorage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorage(renderbuffer: gl_renderbuffer; internalformat: glInternalFormat; width: Int32; height: Int32) :=
      ntv_NamedRenderbufferStorage_1(renderbuffer, internalformat, width, height);
    
    private NamedRenderbufferStorageMultisample_adr := GetProcAddress('glNamedRenderbufferStorageMultisample');
    private ntv_NamedRenderbufferStorageMultisample_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32)>(NamedRenderbufferStorageMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageMultisample(renderbuffer: gl_renderbuffer; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32) :=
      ntv_NamedRenderbufferStorageMultisample_1(renderbuffer, samples, internalformat, width, height);
    
    private GetNamedRenderbufferParameteriv_adr := GetProcAddress('glGetNamedRenderbufferParameteriv');
    private ntv_GetNamedRenderbufferParameteriv_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; pname: glRenderbufferParameterName; var &params: Int32)>(GetNamedRenderbufferParameteriv_adr);
    private ntv_GetNamedRenderbufferParameteriv_2 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; pname: glRenderbufferParameterName; &params: IntPtr)>(GetNamedRenderbufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameteriv(renderbuffer: gl_renderbuffer; pname: glRenderbufferParameterName; var &params: Int32) :=
      ntv_GetNamedRenderbufferParameteriv_1(renderbuffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameteriv(renderbuffer: gl_renderbuffer; pname: glRenderbufferParameterName; &params: IntPtr) :=
      ntv_GetNamedRenderbufferParameteriv_2(renderbuffer, pname, &params);
    
    private CreateTextures_adr := GetProcAddress('glCreateTextures');
    private ntv_CreateTextures_1 := GetProcOrNil&<procedure(target: glTextureTarget; n: Int32; var textures: gl_texture)>(CreateTextures_adr);
    private ntv_CreateTextures_2 := GetProcOrNil&<procedure(target: glTextureTarget; n: Int32; textures: IntPtr)>(CreateTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTextures(target: glTextureTarget; n: Int32; textures: array of gl_texture);
    type PGl_texture = ^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        ntv_CreateTextures_1(target, n, textures[0]) else
        ntv_CreateTextures_1(target, n, PGl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTextures(target: glTextureTarget; n: Int32; var textures: gl_texture) :=
      ntv_CreateTextures_1(target, n, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTextures(target: glTextureTarget; n: Int32; textures: IntPtr) :=
      ntv_CreateTextures_2(target, n, textures);
    
    private TextureBuffer_adr := GetProcAddress('glTextureBuffer');
    private ntv_TextureBuffer_1 := GetProcOrNil&<procedure(texture: gl_texture; internalformat: glSizedInternalFormat; buffer: gl_buffer)>(TextureBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBuffer(texture: gl_texture; internalformat: glSizedInternalFormat; buffer: gl_buffer) :=
      ntv_TextureBuffer_1(texture, internalformat, buffer);
    
    private TextureBufferRange_adr := GetProcAddress('glTextureBufferRange');
    private ntv_TextureBufferRange_1 := GetProcOrNil&<procedure(texture: gl_texture; internalformat: glSizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(TextureBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBufferRange(texture: gl_texture; internalformat: glSizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
      ntv_TextureBufferRange_1(texture, internalformat, buffer, offset, size);
    
    private TextureStorage1D_adr := GetProcAddress('glTextureStorage1D');
    private ntv_TextureStorage1D_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalformat: glSizedInternalFormat; width: Int32)>(TextureStorage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage1D(texture: gl_texture; levels: Int32; internalformat: glSizedInternalFormat; width: Int32) :=
      ntv_TextureStorage1D_1(texture, levels, internalformat, width);
    
    private TextureStorage2D_adr := GetProcAddress('glTextureStorage2D');
    private ntv_TextureStorage2D_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32)>(TextureStorage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2D(texture: gl_texture; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32) :=
      ntv_TextureStorage2D_1(texture, levels, internalformat, width, height);
    
    private TextureStorage3D_adr := GetProcAddress('glTextureStorage3D');
    private ntv_TextureStorage3D_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32)>(TextureStorage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3D(texture: gl_texture; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32) :=
      ntv_TextureStorage3D_1(texture, levels, internalformat, width, height, depth);
    
    private TextureStorage2DMultisample_adr := GetProcAddress('glTextureStorage2DMultisample');
    private ntv_TextureStorage2DMultisample_1 := GetProcOrNil&<procedure(texture: gl_texture; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: glBool8)>(TextureStorage2DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2DMultisample(texture: gl_texture; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: glBool8) :=
      ntv_TextureStorage2DMultisample_1(texture, samples, internalformat, width, height, fixedsamplelocations);
    
    private TextureStorage3DMultisample_adr := GetProcAddress('glTextureStorage3DMultisample');
    private ntv_TextureStorage3DMultisample_1 := GetProcOrNil&<procedure(texture: gl_texture; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: glBool8)>(TextureStorage3DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3DMultisample(texture: gl_texture; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: glBool8) :=
      ntv_TextureStorage3DMultisample_1(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
    
    private TextureSubImage1D_adr := GetProcAddress('glTextureSubImage1D');
    private ntv_TextureSubImage1D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; width: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TextureSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage1D(texture: gl_texture; level: Int32; xoffset: Int32; width: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TextureSubImage1D_1(texture, level, xoffset, width, format, &type, pixels);
    
    private TextureSubImage2D_adr := GetProcAddress('glTextureSubImage2D');
    private ntv_TextureSubImage2D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TextureSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage2D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TextureSubImage2D_1(texture, level, xoffset, yoffset, width, height, format, &type, pixels);
    
    private TextureSubImage3D_adr := GetProcAddress('glTextureSubImage3D');
    private ntv_TextureSubImage3D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TextureSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage3D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TextureSubImage3D_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
    private CompressedTextureSubImage1D_adr := GetProcAddress('glCompressedTextureSubImage1D');
    private ntv_CompressedTextureSubImage1D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; width: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr)>(CompressedTextureSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage1D(texture: gl_texture; level: Int32; xoffset: Int32; width: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTextureSubImage1D_1(texture, level, xoffset, width, format, imageSize, data);
    
    private CompressedTextureSubImage2D_adr := GetProcAddress('glCompressedTextureSubImage2D');
    private ntv_CompressedTextureSubImage2D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr)>(CompressedTextureSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage2D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTextureSubImage2D_1(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
    
    private CompressedTextureSubImage3D_adr := GetProcAddress('glCompressedTextureSubImage3D');
    private ntv_CompressedTextureSubImage3D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr)>(CompressedTextureSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage3D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTextureSubImage3D_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    
    private CopyTextureSubImage1D_adr := GetProcAddress('glCopyTextureSubImage1D');
    private ntv_CopyTextureSubImage1D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32)>(CopyTextureSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage1D(texture: gl_texture; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) :=
      ntv_CopyTextureSubImage1D_1(texture, level, xoffset, x, y, width);
    
    private CopyTextureSubImage2D_adr := GetProcAddress('glCopyTextureSubImage2D');
    private ntv_CopyTextureSubImage2D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(CopyTextureSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage2D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_CopyTextureSubImage2D_1(texture, level, xoffset, yoffset, x, y, width, height);
    
    private CopyTextureSubImage3D_adr := GetProcAddress('glCopyTextureSubImage3D');
    private ntv_CopyTextureSubImage3D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(CopyTextureSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage3D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_CopyTextureSubImage3D_1(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
    
    private TextureParameterf_adr := GetProcAddress('glTextureParameterf');
    private ntv_TextureParameterf_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: single)>(TextureParameterf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterf(texture: gl_texture; pname: glTextureParameterName; param: single) :=
      ntv_TextureParameterf_1(texture, pname, param);
    
    private TextureParameterfv_adr := GetProcAddress('glTextureParameterfv');
    private ntv_TextureParameterfv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; var param: single)>(TextureParameterfv_adr);
    private ntv_TextureParameterfv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: IntPtr)>(TextureParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfv(texture: gl_texture; pname: glTextureParameterName; param: array of single);
    type PSingle = ^single;
    begin
      if (param<>nil) and (param.Length<>0) then
        ntv_TextureParameterfv_1(texture, pname, param[0]) else
        ntv_TextureParameterfv_1(texture, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfv(texture: gl_texture; pname: glTextureParameterName; var param: single) :=
      ntv_TextureParameterfv_1(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfv(texture: gl_texture; pname: glTextureParameterName; param: IntPtr) :=
      ntv_TextureParameterfv_2(texture, pname, param);
    
    private TextureParameteri_adr := GetProcAddress('glTextureParameteri');
    private ntv_TextureParameteri_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glConvolutionBorderMode)>(TextureParameteri_adr);
    private ntv_TextureParameteri_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glDepthStencilTextureMode)>(TextureParameteri_adr);
    private ntv_TextureParameteri_3 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glFoveationConfigBit)>(TextureParameteri_adr);
    private ntv_TextureParameteri_4 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glMapTextureFormat)>(TextureParameteri_adr);
    private ntv_TextureParameteri_5 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glTextureCompareMode)>(TextureParameteri_adr);
    private ntv_TextureParameteri_6 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glTextureMagFilter)>(TextureParameteri_adr);
    private ntv_TextureParameteri_7 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glTextureMinFilter)>(TextureParameteri_adr);
    private ntv_TextureParameteri_8 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glTextureSwizzle)>(TextureParameteri_adr);
    private ntv_TextureParameteri_9 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glTextureWrapMode)>(TextureParameteri_adr);
    private ntv_TextureParameteri_10 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: Int32)>(TextureParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glConvolutionBorderMode) :=
      ntv_TextureParameteri_1(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glDepthStencilTextureMode) :=
      ntv_TextureParameteri_2(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glFoveationConfigBit) :=
      ntv_TextureParameteri_3(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glMapTextureFormat) :=
      ntv_TextureParameteri_4(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glTextureCompareMode) :=
      ntv_TextureParameteri_5(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glTextureMagFilter) :=
      ntv_TextureParameteri_6(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glTextureMinFilter) :=
      ntv_TextureParameteri_7(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glTextureSwizzle) :=
      ntv_TextureParameteri_8(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glTextureWrapMode) :=
      ntv_TextureParameteri_9(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: Int32) :=
      ntv_TextureParameteri_10(texture, pname, param);
    
    private TextureParameterIiv_adr := GetProcAddress('glTextureParameterIiv');
    private ntv_TextureParameterIiv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; var &params: Int32)>(TextureParameterIiv_adr);
    private ntv_TextureParameterIiv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; &params: IntPtr)>(TextureParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIiv(texture: gl_texture; pname: glTextureParameterName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TextureParameterIiv_1(texture, pname, &params[0]) else
        ntv_TextureParameterIiv_1(texture, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIiv(texture: gl_texture; pname: glTextureParameterName; var &params: Int32) :=
      ntv_TextureParameterIiv_1(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIiv(texture: gl_texture; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_TextureParameterIiv_2(texture, pname, &params);
    
    private TextureParameterIuiv_adr := GetProcAddress('glTextureParameterIuiv');
    private ntv_TextureParameterIuiv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; var &params: UInt32)>(TextureParameterIuiv_adr);
    private ntv_TextureParameterIuiv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; &params: IntPtr)>(TextureParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: gl_texture; pname: glTextureParameterName; &params: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TextureParameterIuiv_1(texture, pname, &params[0]) else
        ntv_TextureParameterIuiv_1(texture, pname, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: gl_texture; pname: glTextureParameterName; var &params: UInt32) :=
      ntv_TextureParameterIuiv_1(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: gl_texture; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_TextureParameterIuiv_2(texture, pname, &params);
    
    private TextureParameteriv_adr := GetProcAddress('glTextureParameteriv');
    private ntv_TextureParameteriv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; var param: Int32)>(TextureParameteriv_adr);
    private ntv_TextureParameteriv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: IntPtr)>(TextureParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: gl_texture; pname: glTextureParameterName; param: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (param<>nil) and (param.Length<>0) then
        ntv_TextureParameteriv_1(texture, pname, param[0]) else
        ntv_TextureParameteriv_1(texture, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: gl_texture; pname: glTextureParameterName; var param: Int32) :=
      ntv_TextureParameteriv_1(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: gl_texture; pname: glTextureParameterName; param: IntPtr) :=
      ntv_TextureParameteriv_2(texture, pname, param);
    
    private GenerateTextureMipmap_adr := GetProcAddress('glGenerateTextureMipmap');
    private ntv_GenerateTextureMipmap_1 := GetProcOrNil&<procedure(texture: gl_texture)>(GenerateTextureMipmap_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateTextureMipmap(texture: gl_texture) :=
      ntv_GenerateTextureMipmap_1(texture);
    
    private BindTextureUnit_adr := GetProcAddress('glBindTextureUnit');
    private ntv_BindTextureUnit_1 := GetProcOrNil&<procedure(&unit: UInt32; texture: gl_texture)>(BindTextureUnit_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextureUnit(&unit: UInt32; texture: gl_texture) :=
      ntv_BindTextureUnit_1(&unit, texture);
    
    private GetTextureImage_adr := GetProcAddress('glGetTextureImage');
    private ntv_GetTextureImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; pixels: IntPtr)>(GetTextureImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureImage(texture: gl_texture; level: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; pixels: IntPtr) :=
      ntv_GetTextureImage_1(texture, level, format, &type, bufSize, pixels);
    
    private GetCompressedTextureImage_adr := GetProcAddress('glGetCompressedTextureImage');
    private ntv_GetCompressedTextureImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; bufSize: Int32; pixels: IntPtr)>(GetCompressedTextureImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureImage(texture: gl_texture; level: Int32; bufSize: Int32; pixels: IntPtr) :=
      ntv_GetCompressedTextureImage_1(texture, level, bufSize, pixels);
    
    private GetTextureLevelParameterfv_adr := GetProcAddress('glGetTextureLevelParameterfv');
    private ntv_GetTextureLevelParameterfv_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; pname: glGetTextureParameter; var &params: single)>(GetTextureLevelParameterfv_adr);
    private ntv_GetTextureLevelParameterfv_2 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureLevelParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterfv(texture: gl_texture; level: Int32; pname: glGetTextureParameter; var &params: single) :=
      ntv_GetTextureLevelParameterfv_1(texture, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterfv(texture: gl_texture; level: Int32; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureLevelParameterfv_2(texture, level, pname, &params);
    
    private GetTextureLevelParameteriv_adr := GetProcAddress('glGetTextureLevelParameteriv');
    private ntv_GetTextureLevelParameteriv_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; pname: glGetTextureParameter; var &params: Int32)>(GetTextureLevelParameteriv_adr);
    private ntv_GetTextureLevelParameteriv_2 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureLevelParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameteriv(texture: gl_texture; level: Int32; pname: glGetTextureParameter; var &params: Int32) :=
      ntv_GetTextureLevelParameteriv_1(texture, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameteriv(texture: gl_texture; level: Int32; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureLevelParameteriv_2(texture, level, pname, &params);
    
    private GetTextureParameterfv_adr := GetProcAddress('glGetTextureParameterfv');
    private ntv_GetTextureParameterfv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glGetTextureParameter; var &params: single)>(GetTextureParameterfv_adr);
    private ntv_GetTextureParameterfv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterfv(texture: gl_texture; pname: glGetTextureParameter; var &params: single) :=
      ntv_GetTextureParameterfv_1(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterfv(texture: gl_texture; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureParameterfv_2(texture, pname, &params);
    
    private GetTextureParameterIiv_adr := GetProcAddress('glGetTextureParameterIiv');
    private ntv_GetTextureParameterIiv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glGetTextureParameter; var &params: Int32)>(GetTextureParameterIiv_adr);
    private ntv_GetTextureParameterIiv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIiv(texture: gl_texture; pname: glGetTextureParameter; var &params: Int32) :=
      ntv_GetTextureParameterIiv_1(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIiv(texture: gl_texture; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureParameterIiv_2(texture, pname, &params);
    
    private GetTextureParameterIuiv_adr := GetProcAddress('glGetTextureParameterIuiv');
    private ntv_GetTextureParameterIuiv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glGetTextureParameter; var &params: UInt32)>(GetTextureParameterIuiv_adr);
    private ntv_GetTextureParameterIuiv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuiv(texture: gl_texture; pname: glGetTextureParameter; var &params: UInt32) :=
      ntv_GetTextureParameterIuiv_1(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuiv(texture: gl_texture; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureParameterIuiv_2(texture, pname, &params);
    
    private GetTextureParameteriv_adr := GetProcAddress('glGetTextureParameteriv');
    private ntv_GetTextureParameteriv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glGetTextureParameter; var &params: Int32)>(GetTextureParameteriv_adr);
    private ntv_GetTextureParameteriv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameteriv(texture: gl_texture; pname: glGetTextureParameter; var &params: Int32) :=
      ntv_GetTextureParameteriv_1(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameteriv(texture: gl_texture; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureParameteriv_2(texture, pname, &params);
    
    private CreateVertexArrays_adr := GetProcAddress('glCreateVertexArrays');
    private ntv_CreateVertexArrays_1 := GetProcOrNil&<procedure(n: Int32; var arrays: gl_vertex_array)>(CreateVertexArrays_adr);
    private ntv_CreateVertexArrays_2 := GetProcOrNil&<procedure(n: Int32; arrays: IntPtr)>(CreateVertexArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateVertexArrays(n: Int32; arrays: array of gl_vertex_array);
    type PGl_vertex_array = ^gl_vertex_array;
    begin
      if (arrays<>nil) and (arrays.Length<>0) then
        ntv_CreateVertexArrays_1(n, arrays[0]) else
        ntv_CreateVertexArrays_1(n, PGl_vertex_array(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateVertexArrays(n: Int32; var arrays: gl_vertex_array) :=
      ntv_CreateVertexArrays_1(n, arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateVertexArrays(n: Int32; arrays: IntPtr) :=
      ntv_CreateVertexArrays_2(n, arrays);
    
    private DisableVertexArrayAttrib_adr := GetProcAddress('glDisableVertexArrayAttrib');
    private ntv_DisableVertexArrayAttrib_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32)>(DisableVertexArrayAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexArrayAttrib(vaobj: gl_vertex_array; index: UInt32) :=
      ntv_DisableVertexArrayAttrib_1(vaobj, index);
    
    private EnableVertexArrayAttrib_adr := GetProcAddress('glEnableVertexArrayAttrib');
    private ntv_EnableVertexArrayAttrib_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32)>(EnableVertexArrayAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexArrayAttrib(vaobj: gl_vertex_array; index: UInt32) :=
      ntv_EnableVertexArrayAttrib_1(vaobj, index);
    
    private VertexArrayElementBuffer_adr := GetProcAddress('glVertexArrayElementBuffer');
    private ntv_VertexArrayElementBuffer_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer)>(VertexArrayElementBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayElementBuffer(vaobj: gl_vertex_array; buffer: gl_buffer) :=
      ntv_VertexArrayElementBuffer_1(vaobj, buffer);
    
    private VertexArrayVertexBuffer_adr := GetProcAddress('glVertexArrayVertexBuffer');
    private ntv_VertexArrayVertexBuffer_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32)>(VertexArrayVertexBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffer(vaobj: gl_vertex_array; bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32) :=
      ntv_VertexArrayVertexBuffer_1(vaobj, bindingindex, buffer, offset, stride);
    
    private VertexArrayVertexBuffers_adr := GetProcAddress('glVertexArrayVertexBuffers');
    private ntv_VertexArrayVertexBuffers_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var strides: Int32)>(VertexArrayVertexBuffers_adr);
    private ntv_VertexArrayVertexBuffers_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; strides: IntPtr)>(VertexArrayVertexBuffers_adr);
    private ntv_VertexArrayVertexBuffers_3 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var strides: Int32)>(VertexArrayVertexBuffers_adr);
    private ntv_VertexArrayVertexBuffers_4 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; strides: IntPtr)>(VertexArrayVertexBuffers_adr);
    private ntv_VertexArrayVertexBuffers_5 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var strides: Int32)>(VertexArrayVertexBuffers_adr);
    private ntv_VertexArrayVertexBuffers_6 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; strides: IntPtr)>(VertexArrayVertexBuffers_adr);
    private ntv_VertexArrayVertexBuffers_7 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var strides: Int32)>(VertexArrayVertexBuffers_adr);
    private ntv_VertexArrayVertexBuffers_8 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; strides: IntPtr)>(VertexArrayVertexBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: array of gl_buffer; offsets: array of IntPtr; strides: array of Int32);
    type PGl_buffer = ^gl_buffer;
    type PIntPtr = ^IntPtr;
    type PInt32 = ^Int32;
    begin
      if (strides<>nil) and (strides.Length<>0) then
        if (buffers<>nil) and (buffers.Length<>0) then
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_VertexArrayVertexBuffers_1(vaobj, first, count, buffers[0], offsets[0], strides[0]) else
            ntv_VertexArrayVertexBuffers_1(vaobj, first, count, buffers[0], PIntPtr(nil)^, strides[0]) else
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_VertexArrayVertexBuffers_1(vaobj, first, count, PGl_buffer(nil)^, offsets[0], strides[0]) else
            ntv_VertexArrayVertexBuffers_1(vaobj, first, count, PGl_buffer(nil)^, PIntPtr(nil)^, strides[0]) else
        if (buffers<>nil) and (buffers.Length<>0) then
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_VertexArrayVertexBuffers_1(vaobj, first, count, buffers[0], offsets[0], PInt32(nil)^) else
            ntv_VertexArrayVertexBuffers_1(vaobj, first, count, buffers[0], PIntPtr(nil)^, PInt32(nil)^) else
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_VertexArrayVertexBuffers_1(vaobj, first, count, PGl_buffer(nil)^, offsets[0], PInt32(nil)^) else
            ntv_VertexArrayVertexBuffers_1(vaobj, first, count, PGl_buffer(nil)^, PIntPtr(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var strides: Int32) :=
      ntv_VertexArrayVertexBuffers_1(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; strides: IntPtr) :=
      ntv_VertexArrayVertexBuffers_2(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var strides: Int32) :=
      ntv_VertexArrayVertexBuffers_3(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; strides: IntPtr) :=
      ntv_VertexArrayVertexBuffers_4(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var strides: Int32) :=
      ntv_VertexArrayVertexBuffers_5(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; strides: IntPtr) :=
      ntv_VertexArrayVertexBuffers_6(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var strides: Int32) :=
      ntv_VertexArrayVertexBuffers_7(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; strides: IntPtr) :=
      ntv_VertexArrayVertexBuffers_8(vaobj, first, count, buffers, offsets, strides);
    
    private VertexArrayAttribBinding_adr := GetProcAddress('glVertexArrayAttribBinding');
    private ntv_VertexArrayAttribBinding_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; bindingindex: UInt32)>(VertexArrayAttribBinding_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribBinding(vaobj: gl_vertex_array; attribindex: UInt32; bindingindex: UInt32) :=
      ntv_VertexArrayAttribBinding_1(vaobj, attribindex, bindingindex);
    
    private VertexArrayAttribFormat_adr := GetProcAddress('glVertexArrayAttribFormat');
    private ntv_VertexArrayAttribFormat_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribType; normalized: glBool8; relativeoffset: UInt32)>(VertexArrayAttribFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribFormat(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribType; normalized: glBool8; relativeoffset: UInt32) :=
      ntv_VertexArrayAttribFormat_1(vaobj, attribindex, size, &type, normalized, relativeoffset);
    
    private VertexArrayAttribIFormat_adr := GetProcAddress('glVertexArrayAttribIFormat');
    private ntv_VertexArrayAttribIFormat_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribIType; relativeoffset: UInt32)>(VertexArrayAttribIFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribIFormat(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribIType; relativeoffset: UInt32) :=
      ntv_VertexArrayAttribIFormat_1(vaobj, attribindex, size, &type, relativeoffset);
    
    private VertexArrayAttribLFormat_adr := GetProcAddress('glVertexArrayAttribLFormat');
    private ntv_VertexArrayAttribLFormat_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribLType; relativeoffset: UInt32)>(VertexArrayAttribLFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribLFormat(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribLType; relativeoffset: UInt32) :=
      ntv_VertexArrayAttribLFormat_1(vaobj, attribindex, size, &type, relativeoffset);
    
    private VertexArrayBindingDivisor_adr := GetProcAddress('glVertexArrayBindingDivisor');
    private ntv_VertexArrayBindingDivisor_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; bindingindex: UInt32; divisor: UInt32)>(VertexArrayBindingDivisor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayBindingDivisor(vaobj: gl_vertex_array; bindingindex: UInt32; divisor: UInt32) :=
      ntv_VertexArrayBindingDivisor_1(vaobj, bindingindex, divisor);
    
    private GetVertexArrayiv_adr := GetProcAddress('glGetVertexArrayiv');
    private ntv_GetVertexArrayiv_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; pname: glVertexArrayPName; var param: Int32)>(GetVertexArrayiv_adr);
    private ntv_GetVertexArrayiv_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; pname: glVertexArrayPName; param: IntPtr)>(GetVertexArrayiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayiv(vaobj: gl_vertex_array; pname: glVertexArrayPName; var param: Int32) :=
      ntv_GetVertexArrayiv_1(vaobj, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayiv(vaobj: gl_vertex_array; pname: glVertexArrayPName; param: IntPtr) :=
      ntv_GetVertexArrayiv_2(vaobj, pname, param);
    
    private GetVertexArrayIndexediv_adr := GetProcAddress('glGetVertexArrayIndexediv');
    private ntv_GetVertexArrayIndexediv_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; var param: Int32)>(GetVertexArrayIndexediv_adr);
    private ntv_GetVertexArrayIndexediv_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; param: IntPtr)>(GetVertexArrayIndexediv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexediv(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; var param: Int32) :=
      ntv_GetVertexArrayIndexediv_1(vaobj, index, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexediv(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; param: IntPtr) :=
      ntv_GetVertexArrayIndexediv_2(vaobj, index, pname, param);
    
    private GetVertexArrayIndexed64iv_adr := GetProcAddress('glGetVertexArrayIndexed64iv');
    private ntv_GetVertexArrayIndexed64iv_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; var param: Int64)>(GetVertexArrayIndexed64iv_adr);
    private ntv_GetVertexArrayIndexed64iv_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; param: IntPtr)>(GetVertexArrayIndexed64iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexed64iv(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; var param: Int64) :=
      ntv_GetVertexArrayIndexed64iv_1(vaobj, index, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexed64iv(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; param: IntPtr) :=
      ntv_GetVertexArrayIndexed64iv_2(vaobj, index, pname, param);
    
    private CreateSamplers_adr := GetProcAddress('glCreateSamplers');
    private ntv_CreateSamplers_1 := GetProcOrNil&<procedure(n: Int32; var samplers: gl_sampler)>(CreateSamplers_adr);
    private ntv_CreateSamplers_2 := GetProcOrNil&<procedure(n: Int32; samplers: IntPtr)>(CreateSamplers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSamplers(n: Int32; samplers: array of gl_sampler);
    type PGl_sampler = ^gl_sampler;
    begin
      if (samplers<>nil) and (samplers.Length<>0) then
        ntv_CreateSamplers_1(n, samplers[0]) else
        ntv_CreateSamplers_1(n, PGl_sampler(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSamplers(n: Int32; var samplers: gl_sampler) :=
      ntv_CreateSamplers_1(n, samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSamplers(n: Int32; samplers: IntPtr) :=
      ntv_CreateSamplers_2(n, samplers);
    
    private CreateProgramPipelines_adr := GetProcAddress('glCreateProgramPipelines');
    private ntv_CreateProgramPipelines_1 := GetProcOrNil&<procedure(n: Int32; var pipelines: gl_program_pipeline)>(CreateProgramPipelines_adr);
    private ntv_CreateProgramPipelines_2 := GetProcOrNil&<procedure(n: Int32; pipelines: IntPtr)>(CreateProgramPipelines_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateProgramPipelines(n: Int32; pipelines: array of gl_program_pipeline);
    type PGl_program_pipeline = ^gl_program_pipeline;
    begin
      if (pipelines<>nil) and (pipelines.Length<>0) then
        ntv_CreateProgramPipelines_1(n, pipelines[0]) else
        ntv_CreateProgramPipelines_1(n, PGl_program_pipeline(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateProgramPipelines(n: Int32; var pipelines: gl_program_pipeline) :=
      ntv_CreateProgramPipelines_1(n, pipelines);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateProgramPipelines(n: Int32; pipelines: IntPtr) :=
      ntv_CreateProgramPipelines_2(n, pipelines);
    
    private CreateQueries_adr := GetProcAddress('glCreateQueries');
    private ntv_CreateQueries_1 := GetProcOrNil&<procedure(target: glQueryTarget; n: Int32; var ids: gl_query)>(CreateQueries_adr);
    private ntv_CreateQueries_2 := GetProcOrNil&<procedure(target: glQueryTarget; n: Int32; ids: IntPtr)>(CreateQueries_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateQueries(target: glQueryTarget; n: Int32; ids: array of gl_query);
    type PGl_query = ^gl_query;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_CreateQueries_1(target, n, ids[0]) else
        ntv_CreateQueries_1(target, n, PGl_query(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateQueries(target: glQueryTarget; n: Int32; var ids: gl_query) :=
      ntv_CreateQueries_1(target, n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateQueries(target: glQueryTarget; n: Int32; ids: IntPtr) :=
      ntv_CreateQueries_2(target, n, ids);
    
    private GetQueryBufferObjecti64v_adr := GetProcAddress('glGetQueryBufferObjecti64v');
    private ntv_GetQueryBufferObjecti64v_1 := GetProcOrNil&<procedure(id: gl_query; buffer: gl_buffer; pname: glQueryObjectParameterName; offset: IntPtr)>(GetQueryBufferObjecti64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjecti64v(id: gl_query; buffer: gl_buffer; pname: glQueryObjectParameterName; offset: IntPtr) :=
      ntv_GetQueryBufferObjecti64v_1(id, buffer, pname, offset);
    
    private GetQueryBufferObjectiv_adr := GetProcAddress('glGetQueryBufferObjectiv');
    private ntv_GetQueryBufferObjectiv_1 := GetProcOrNil&<procedure(id: gl_query; buffer: gl_buffer; pname: glQueryObjectParameterName; offset: IntPtr)>(GetQueryBufferObjectiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjectiv(id: gl_query; buffer: gl_buffer; pname: glQueryObjectParameterName; offset: IntPtr) :=
      ntv_GetQueryBufferObjectiv_1(id, buffer, pname, offset);
    
    private GetQueryBufferObjectui64v_adr := GetProcAddress('glGetQueryBufferObjectui64v');
    private ntv_GetQueryBufferObjectui64v_1 := GetProcOrNil&<procedure(id: gl_query; buffer: gl_buffer; pname: glQueryObjectParameterName; offset: IntPtr)>(GetQueryBufferObjectui64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjectui64v(id: gl_query; buffer: gl_buffer; pname: glQueryObjectParameterName; offset: IntPtr) :=
      ntv_GetQueryBufferObjectui64v_1(id, buffer, pname, offset);
    
    private GetQueryBufferObjectuiv_adr := GetProcAddress('glGetQueryBufferObjectuiv');
    private ntv_GetQueryBufferObjectuiv_1 := GetProcOrNil&<procedure(id: gl_query; buffer: gl_buffer; pname: glQueryObjectParameterName; offset: IntPtr)>(GetQueryBufferObjectuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjectuiv(id: gl_query; buffer: gl_buffer; pname: glQueryObjectParameterName; offset: IntPtr) :=
      ntv_GetQueryBufferObjectuiv_1(id, buffer, pname, offset);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDrawBuffersARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_draw_buffers';
    
    private DrawBuffersARB_adr := GetProcAddress('glDrawBuffersARB');
    private ntv_DrawBuffersARB_1 := GetProcOrNil&<procedure(n: Int32; var bufs: glDrawBufferMode)>(DrawBuffersARB_adr);
    private ntv_DrawBuffersARB_2 := GetProcOrNil&<procedure(n: Int32; bufs: IntPtr)>(DrawBuffersARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersARB(n: Int32; bufs: array of glDrawBufferMode);
    type PGlDrawBufferMode = ^glDrawBufferMode;
    begin
      if (bufs<>nil) and (bufs.Length<>0) then
        ntv_DrawBuffersARB_1(n, bufs[0]) else
        ntv_DrawBuffersARB_1(n, PGlDrawBufferMode(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersARB(n: Int32; var bufs: glDrawBufferMode) :=
      ntv_DrawBuffersARB_1(n, bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersARB(n: Int32; bufs: IntPtr) :=
      ntv_DrawBuffersARB_2(n, bufs);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDrawBuffersBlendARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_draw_buffers_blend';
    
    private BlendEquationiARB_adr := GetProcAddress('glBlendEquationiARB');
    private ntv_BlendEquationiARB_1 := GetProcOrNil&<procedure(buf: UInt32; mode: glBlendEquationMode)>(BlendEquationiARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationiARB(buf: UInt32; mode: glBlendEquationMode) :=
      ntv_BlendEquationiARB_1(buf, mode);
    
    private BlendEquationSeparateiARB_adr := GetProcAddress('glBlendEquationSeparateiARB');
    private ntv_BlendEquationSeparateiARB_1 := GetProcOrNil&<procedure(buf: UInt32; modeRGB: glBlendEquationMode; modeAlpha: glBlendEquationMode)>(BlendEquationSeparateiARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparateiARB(buf: UInt32; modeRGB: glBlendEquationMode; modeAlpha: glBlendEquationMode) :=
      ntv_BlendEquationSeparateiARB_1(buf, modeRGB, modeAlpha);
    
    private BlendFunciARB_adr := GetProcAddress('glBlendFunciARB');
    private ntv_BlendFunciARB_1 := GetProcOrNil&<procedure(buf: UInt32; src: glBlendingFactor; dst: glBlendingFactor)>(BlendFunciARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFunciARB(buf: UInt32; src: glBlendingFactor; dst: glBlendingFactor) :=
      ntv_BlendFunciARB_1(buf, src, dst);
    
    private BlendFuncSeparateiARB_adr := GetProcAddress('glBlendFuncSeparateiARB');
    private ntv_BlendFuncSeparateiARB_1 := GetProcOrNil&<procedure(buf: UInt32; srcRGB: glBlendingFactor; dstRGB: glBlendingFactor; srcAlpha: glBlendingFactor; dstAlpha: glBlendingFactor)>(BlendFuncSeparateiARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparateiARB(buf: UInt32; srcRGB: glBlendingFactor; dstRGB: glBlendingFactor; srcAlpha: glBlendingFactor; dstAlpha: glBlendingFactor) :=
      ntv_BlendFuncSeparateiARB_1(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDrawElementsBaseVertexARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_draw_elements_base_vertex';
    
    private DrawElementsBaseVertex_adr := GetProcAddress('glDrawElementsBaseVertex');
    private ntv_DrawElementsBaseVertex_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; basevertex: Int32)>(DrawElementsBaseVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsBaseVertex(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; basevertex: Int32) :=
      ntv_DrawElementsBaseVertex_1(mode, count, &type, indices, basevertex);
    
    private DrawRangeElementsBaseVertex_adr := GetProcAddress('glDrawRangeElementsBaseVertex');
    private ntv_DrawRangeElementsBaseVertex_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: glDrawElementsType; indices: IntPtr; basevertex: Int32)>(DrawRangeElementsBaseVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementsBaseVertex(mode: glPrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: glDrawElementsType; indices: IntPtr; basevertex: Int32) :=
      ntv_DrawRangeElementsBaseVertex_1(mode, start, &end, count, &type, indices, basevertex);
    
    private DrawElementsInstancedBaseVertex_adr := GetProcAddress('glDrawElementsInstancedBaseVertex');
    private ntv_DrawElementsInstancedBaseVertex_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; instancecount: Int32; basevertex: Int32)>(DrawElementsInstancedBaseVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertex(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; instancecount: Int32; basevertex: Int32) :=
      ntv_DrawElementsInstancedBaseVertex_1(mode, count, &type, indices, instancecount, basevertex);
    
    private MultiDrawElementsBaseVertex_adr := GetProcAddress('glMultiDrawElementsBaseVertex');
    private ntv_MultiDrawElementsBaseVertex_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32)>(MultiDrawElementsBaseVertex_adr);
    private ntv_MultiDrawElementsBaseVertex_2 := GetProcOrNil&<procedure(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32; basevertex: IntPtr)>(MultiDrawElementsBaseVertex_adr);
    private ntv_MultiDrawElementsBaseVertex_3 := GetProcOrNil&<procedure(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; indices: pointer; drawcount: Int32; var basevertex: Int32)>(MultiDrawElementsBaseVertex_adr);
    private ntv_MultiDrawElementsBaseVertex_4 := GetProcOrNil&<procedure(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; indices: pointer; drawcount: Int32; basevertex: IntPtr)>(MultiDrawElementsBaseVertex_adr);
    private ntv_MultiDrawElementsBaseVertex_5 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32)>(MultiDrawElementsBaseVertex_adr);
    private ntv_MultiDrawElementsBaseVertex_6 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32; basevertex: IntPtr)>(MultiDrawElementsBaseVertex_adr);
    private ntv_MultiDrawElementsBaseVertex_7 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; indices: pointer; drawcount: Int32; var basevertex: Int32)>(MultiDrawElementsBaseVertex_adr);
    private ntv_MultiDrawElementsBaseVertex_8 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; indices: pointer; drawcount: Int32; basevertex: IntPtr)>(MultiDrawElementsBaseVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; count: array of Int32; &type: glDrawElementsType; indices: array of IntPtr; drawcount: Int32; basevertex: array of Int32);
    type PInt32 = ^Int32;
    type PIntPtr = ^IntPtr;
    begin
      if (basevertex<>nil) and (basevertex.Length<>0) then
        if (count<>nil) and (count.Length<>0) then
          if (indices<>nil) and (indices.Length<>0) then
            ntv_MultiDrawElementsBaseVertex_1(mode, count[0], &type, indices[0], drawcount, basevertex[0]) else
            ntv_MultiDrawElementsBaseVertex_1(mode, count[0], &type, PIntPtr(nil)^, drawcount, basevertex[0]) else
          if (indices<>nil) and (indices.Length<>0) then
            ntv_MultiDrawElementsBaseVertex_1(mode, PInt32(nil)^, &type, indices[0], drawcount, basevertex[0]) else
            ntv_MultiDrawElementsBaseVertex_1(mode, PInt32(nil)^, &type, PIntPtr(nil)^, drawcount, basevertex[0]) else
        if (count<>nil) and (count.Length<>0) then
          if (indices<>nil) and (indices.Length<>0) then
            ntv_MultiDrawElementsBaseVertex_1(mode, count[0], &type, indices[0], drawcount, PInt32(nil)^) else
            ntv_MultiDrawElementsBaseVertex_1(mode, count[0], &type, PIntPtr(nil)^, drawcount, PInt32(nil)^) else
          if (indices<>nil) and (indices.Length<>0) then
            ntv_MultiDrawElementsBaseVertex_1(mode, PInt32(nil)^, &type, indices[0], drawcount, PInt32(nil)^) else
            ntv_MultiDrawElementsBaseVertex_1(mode, PInt32(nil)^, &type, PIntPtr(nil)^, drawcount, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32) :=
      ntv_MultiDrawElementsBaseVertex_1(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32; basevertex: IntPtr) :=
      ntv_MultiDrawElementsBaseVertex_2(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; indices: pointer; drawcount: Int32; var basevertex: Int32) :=
      ntv_MultiDrawElementsBaseVertex_3(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; indices: pointer; drawcount: Int32; basevertex: IntPtr) :=
      ntv_MultiDrawElementsBaseVertex_4(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32) :=
      ntv_MultiDrawElementsBaseVertex_5(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32; basevertex: IntPtr) :=
      ntv_MultiDrawElementsBaseVertex_6(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; indices: pointer; drawcount: Int32; var basevertex: Int32) :=
      ntv_MultiDrawElementsBaseVertex_7(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; indices: pointer; drawcount: Int32; basevertex: IntPtr) :=
      ntv_MultiDrawElementsBaseVertex_8(mode, count, &type, indices, drawcount, basevertex);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDrawIndirectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_draw_indirect';
    
    private DrawArraysIndirect_adr := GetProcAddress('glDrawArraysIndirect');
    private ntv_DrawArraysIndirect_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; indirect: IntPtr)>(DrawArraysIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysIndirect(mode: glPrimitiveType; indirect: IntPtr) :=
      ntv_DrawArraysIndirect_1(mode, indirect);
    
    private DrawElementsIndirect_adr := GetProcAddress('glDrawElementsIndirect');
    private ntv_DrawElementsIndirect_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr)>(DrawElementsIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsIndirect(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr) :=
      ntv_DrawElementsIndirect_1(mode, &type, indirect);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDrawInstancedARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_draw_instanced';
    
    private DrawArraysInstancedARB_adr := GetProcAddress('glDrawArraysInstancedARB');
    private ntv_DrawArraysInstancedARB_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; first: Int32; count: Int32; primcount: Int32)>(DrawArraysInstancedARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysInstancedARB(mode: glPrimitiveType; first: Int32; count: Int32; primcount: Int32) :=
      ntv_DrawArraysInstancedARB_1(mode, first, count, primcount);
    
    private DrawElementsInstancedARB_adr := GetProcAddress('glDrawElementsInstancedARB');
    private ntv_DrawElementsInstancedARB_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; primcount: Int32)>(DrawElementsInstancedARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedARB(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; primcount: Int32) :=
      ntv_DrawElementsInstancedARB_1(mode, count, &type, indices, primcount);
    
  end;
  
  ///
  glEnhancedLayoutsARB = static class
    public const _ExtStr = 'GL_ARB_enhanced_layouts';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glES2CompatibilityARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_ES2_compatibility';
    
    private ReleaseShaderCompiler_adr := GetProcAddress('glReleaseShaderCompiler');
    private ntv_ReleaseShaderCompiler_1 := GetProcOrNil&<procedure>(ReleaseShaderCompiler_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReleaseShaderCompiler :=
      ntv_ReleaseShaderCompiler_1;
    
    private ShaderBinary_adr := GetProcAddress('glShaderBinary');
    private ntv_ShaderBinary_1 := GetProcOrNil&<procedure(count: Int32; var shaders: gl_shader; binaryFormat: glShaderBinaryFormat; binary: IntPtr; length: Int32)>(ShaderBinary_adr);
    private ntv_ShaderBinary_2 := GetProcOrNil&<procedure(count: Int32; shaders: IntPtr; binaryFormat: glShaderBinaryFormat; binary: IntPtr; length: Int32)>(ShaderBinary_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; shaders: array of gl_shader; binaryFormat: glShaderBinaryFormat; binary: IntPtr; length: Int32);
    type PGl_shader = ^gl_shader;
    begin
      if (shaders<>nil) and (shaders.Length<>0) then
        ntv_ShaderBinary_1(count, shaders[0], binaryFormat, binary, length) else
        ntv_ShaderBinary_1(count, PGl_shader(nil)^, binaryFormat, binary, length);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; var shaders: gl_shader; binaryFormat: glShaderBinaryFormat; binary: IntPtr; length: Int32) :=
      ntv_ShaderBinary_1(count, shaders, binaryFormat, binary, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; shaders: IntPtr; binaryFormat: glShaderBinaryFormat; binary: IntPtr; length: Int32) :=
      ntv_ShaderBinary_2(count, shaders, binaryFormat, binary, length);
    
    private GetShaderPrecisionFormat_adr := GetProcAddress('glGetShaderPrecisionFormat');
    private ntv_GetShaderPrecisionFormat_1 := GetProcOrNil&<procedure(shadertype: glShaderType; precisiontype: glPrecisionType; var range: Int32; var precision: Int32)>(GetShaderPrecisionFormat_adr);
    private ntv_GetShaderPrecisionFormat_2 := GetProcOrNil&<procedure(shadertype: glShaderType; precisiontype: glPrecisionType; var range: Int32; precision: IntPtr)>(GetShaderPrecisionFormat_adr);
    private ntv_GetShaderPrecisionFormat_3 := GetProcOrNil&<procedure(shadertype: glShaderType; precisiontype: glPrecisionType; range: IntPtr; var precision: Int32)>(GetShaderPrecisionFormat_adr);
    private ntv_GetShaderPrecisionFormat_4 := GetProcOrNil&<procedure(shadertype: glShaderType; precisiontype: glPrecisionType; range: IntPtr; precision: IntPtr)>(GetShaderPrecisionFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(shadertype: glShaderType; precisiontype: glPrecisionType; var range: Int32; var precision: Int32) :=
      ntv_GetShaderPrecisionFormat_1(shadertype, precisiontype, range, precision);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(shadertype: glShaderType; precisiontype: glPrecisionType; var range: Int32; precision: IntPtr) :=
      ntv_GetShaderPrecisionFormat_2(shadertype, precisiontype, range, precision);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(shadertype: glShaderType; precisiontype: glPrecisionType; range: IntPtr; var precision: Int32) :=
      ntv_GetShaderPrecisionFormat_3(shadertype, precisiontype, range, precision);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(shadertype: glShaderType; precisiontype: glPrecisionType; range: IntPtr; precision: IntPtr) :=
      ntv_GetShaderPrecisionFormat_4(shadertype, precisiontype, range, precision);
    
    private DepthRangef_adr := GetProcAddress('glDepthRangef');
    private ntv_DepthRangef_1 := GetProcOrNil&<procedure(n: single; f: single)>(DepthRangef_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangef(n: single; f: single) :=
      ntv_DepthRangef_1(n, f);
    
    private ClearDepthf_adr := GetProcAddress('glClearDepthf');
    private ntv_ClearDepthf_1 := GetProcOrNil&<procedure(d: single)>(ClearDepthf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepthf(d: single) :=
      ntv_ClearDepthf_1(d);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glES31CompatibilityARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_ES3_1_compatibility';
    
    private MemoryBarrierByRegion_adr := GetProcAddress('glMemoryBarrierByRegion');
    private ntv_MemoryBarrierByRegion_1 := GetProcOrNil&<procedure(barriers: glMemoryBarrierMask)>(MemoryBarrierByRegion_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryBarrierByRegion(barriers: glMemoryBarrierMask) :=
      ntv_MemoryBarrierByRegion_1(barriers);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glES32CompatibilityARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_ES3_2_compatibility';
    
    private PrimitiveBoundingBoxARB_adr := GetProcAddress('glPrimitiveBoundingBoxARB');
    private ntv_PrimitiveBoundingBoxARB_1 := GetProcOrNil&<procedure(minX: single; minY: single; minZ: single; minW: single; maxX: single; maxY: single; maxZ: single; maxW: single)>(PrimitiveBoundingBoxARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrimitiveBoundingBoxARB(minX: single; minY: single; minZ: single; minW: single; maxX: single; maxY: single; maxZ: single; maxW: single) :=
      ntv_PrimitiveBoundingBoxARB_1(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
    
  end;
  
  ///
  glES3CompatibilityARB = static class
    public const _ExtStr = 'GL_ARB_ES3_compatibility';
  end;
  
  ///
  glExplicitAttribLocationARB = static class
    public const _ExtStr = 'GL_ARB_explicit_attrib_location';
  end;
  
  ///
  glExplicitUniformLocationARB = static class
    public const _ExtStr = 'GL_ARB_explicit_uniform_location';
  end;
  
  ///
  glFragmentCoordConventionsARB = static class
    public const _ExtStr = 'GL_ARB_fragment_coord_conventions';
  end;
  
  ///
  glFragmentLayerViewportARB = static class
    public const _ExtStr = 'GL_ARB_fragment_layer_viewport';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFragmentProgramARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_fragment_program';
    
    private ProgramStringARB_adr := GetProcAddress('glProgramStringARB');
    private ntv_ProgramStringARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; format: glProgramFormat; len: Int32; string: IntPtr)>(ProgramStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramStringARB(target: glProgramTarget; format: glProgramFormat; len: Int32; string: string);
    begin
      var string_str_ptr := Marshal.StringToHGlobalAnsi(string);
      try
        ntv_ProgramStringARB_1(target, format, len, string_str_ptr);
      finally
        Marshal.FreeHGlobal(string_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramStringARB(target: glProgramTarget; format: glProgramFormat; len: Int32; string: IntPtr) :=
      ntv_ProgramStringARB_1(target, format, len, string);
    
    private BindProgramARB_adr := GetProcAddress('glBindProgramARB');
    private ntv_BindProgramARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; &program: gl_program)>(BindProgramARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindProgramARB(target: glProgramTarget; &program: gl_program) :=
      ntv_BindProgramARB_1(target, &program);
    
    private DeleteProgramsARB_adr := GetProcAddress('glDeleteProgramsARB');
    private ntv_DeleteProgramsARB_1 := GetProcOrNil&<procedure(n: Int32; var programs: gl_program)>(DeleteProgramsARB_adr);
    private ntv_DeleteProgramsARB_2 := GetProcOrNil&<procedure(n: Int32; programs: IntPtr)>(DeleteProgramsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; programs: array of gl_program);
    type PGl_program = ^gl_program;
    begin
      if (programs<>nil) and (programs.Length<>0) then
        ntv_DeleteProgramsARB_1(n, programs[0]) else
        ntv_DeleteProgramsARB_1(n, PGl_program(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; var programs: gl_program) :=
      ntv_DeleteProgramsARB_1(n, programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; programs: IntPtr) :=
      ntv_DeleteProgramsARB_2(n, programs);
    
    private GenProgramsARB_adr := GetProcAddress('glGenProgramsARB');
    private ntv_GenProgramsARB_1 := GetProcOrNil&<procedure(n: Int32; var programs: gl_program)>(GenProgramsARB_adr);
    private ntv_GenProgramsARB_2 := GetProcOrNil&<procedure(n: Int32; programs: IntPtr)>(GenProgramsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; programs: array of gl_program);
    type PGl_program = ^gl_program;
    begin
      if (programs<>nil) and (programs.Length<>0) then
        ntv_GenProgramsARB_1(n, programs[0]) else
        ntv_GenProgramsARB_1(n, PGl_program(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; var programs: gl_program) :=
      ntv_GenProgramsARB_1(n, programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; programs: IntPtr) :=
      ntv_GenProgramsARB_2(n, programs);
    
    private ProgramEnvParameter4dARB_adr := GetProcAddress('glProgramEnvParameter4dARB');
    private ntv_ProgramEnvParameter4dARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; x: double; y: double; z: double; w: double)>(ProgramEnvParameter4dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dARB(target: glProgramTarget; index: UInt32; x: double; y: double; z: double; w: double) :=
      ntv_ProgramEnvParameter4dARB_1(target, index, x, y, z, w);
    
    private ProgramEnvParameter4dvARB_adr := GetProcAddress('glProgramEnvParameter4dvARB');
    private ntv_ProgramEnvParameter4dvARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: double)>(ProgramEnvParameter4dvARB_adr);
    private ntv_ProgramEnvParameter4dvARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: Vec4d)>(ProgramEnvParameter4dvARB_adr);
    private ntv_ProgramEnvParameter4dvARB_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(ProgramEnvParameter4dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: glProgramTarget; index: UInt32; &params: array of double);
    type PDouble = ^double;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramEnvParameter4dvARB_1(target, index, &params[0]) else
        ntv_ProgramEnvParameter4dvARB_1(target, index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: glProgramTarget; index: UInt32; var &params: Vec4d) :=
      ntv_ProgramEnvParameter4dvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: glProgramTarget; index: UInt32; var &params: double) :=
      ntv_ProgramEnvParameter4dvARB_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_ProgramEnvParameter4dvARB_3(target, index, &params);
    
    private ProgramEnvParameter4fARB_adr := GetProcAddress('glProgramEnvParameter4fARB');
    private ntv_ProgramEnvParameter4fARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; x: single; y: single; z: single; w: single)>(ProgramEnvParameter4fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fARB(target: glProgramTarget; index: UInt32; x: single; y: single; z: single; w: single) :=
      ntv_ProgramEnvParameter4fARB_1(target, index, x, y, z, w);
    
    private ProgramEnvParameter4fvARB_adr := GetProcAddress('glProgramEnvParameter4fvARB');
    private ntv_ProgramEnvParameter4fvARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: single)>(ProgramEnvParameter4fvARB_adr);
    private ntv_ProgramEnvParameter4fvARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: Vec4f)>(ProgramEnvParameter4fvARB_adr);
    private ntv_ProgramEnvParameter4fvARB_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(ProgramEnvParameter4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: glProgramTarget; index: UInt32; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramEnvParameter4fvARB_1(target, index, &params[0]) else
        ntv_ProgramEnvParameter4fvARB_1(target, index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: glProgramTarget; index: UInt32; var &params: Vec4f) :=
      ntv_ProgramEnvParameter4fvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: glProgramTarget; index: UInt32; var &params: single) :=
      ntv_ProgramEnvParameter4fvARB_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_ProgramEnvParameter4fvARB_3(target, index, &params);
    
    private ProgramLocalParameter4dARB_adr := GetProcAddress('glProgramLocalParameter4dARB');
    private ntv_ProgramLocalParameter4dARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; x: double; y: double; z: double; w: double)>(ProgramLocalParameter4dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dARB(target: glProgramTarget; index: UInt32; x: double; y: double; z: double; w: double) :=
      ntv_ProgramLocalParameter4dARB_1(target, index, x, y, z, w);
    
    private ProgramLocalParameter4dvARB_adr := GetProcAddress('glProgramLocalParameter4dvARB');
    private ntv_ProgramLocalParameter4dvARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: double)>(ProgramLocalParameter4dvARB_adr);
    private ntv_ProgramLocalParameter4dvARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: Vec4d)>(ProgramLocalParameter4dvARB_adr);
    private ntv_ProgramLocalParameter4dvARB_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(ProgramLocalParameter4dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: glProgramTarget; index: UInt32; &params: array of double);
    type PDouble = ^double;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramLocalParameter4dvARB_1(target, index, &params[0]) else
        ntv_ProgramLocalParameter4dvARB_1(target, index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: glProgramTarget; index: UInt32; var &params: Vec4d) :=
      ntv_ProgramLocalParameter4dvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: glProgramTarget; index: UInt32; var &params: double) :=
      ntv_ProgramLocalParameter4dvARB_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_ProgramLocalParameter4dvARB_3(target, index, &params);
    
    private ProgramLocalParameter4fARB_adr := GetProcAddress('glProgramLocalParameter4fARB');
    private ntv_ProgramLocalParameter4fARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; x: single; y: single; z: single; w: single)>(ProgramLocalParameter4fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fARB(target: glProgramTarget; index: UInt32; x: single; y: single; z: single; w: single) :=
      ntv_ProgramLocalParameter4fARB_1(target, index, x, y, z, w);
    
    private ProgramLocalParameter4fvARB_adr := GetProcAddress('glProgramLocalParameter4fvARB');
    private ntv_ProgramLocalParameter4fvARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: single)>(ProgramLocalParameter4fvARB_adr);
    private ntv_ProgramLocalParameter4fvARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: Vec4f)>(ProgramLocalParameter4fvARB_adr);
    private ntv_ProgramLocalParameter4fvARB_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(ProgramLocalParameter4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: glProgramTarget; index: UInt32; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramLocalParameter4fvARB_1(target, index, &params[0]) else
        ntv_ProgramLocalParameter4fvARB_1(target, index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: glProgramTarget; index: UInt32; var &params: Vec4f) :=
      ntv_ProgramLocalParameter4fvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: glProgramTarget; index: UInt32; var &params: single) :=
      ntv_ProgramLocalParameter4fvARB_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_ProgramLocalParameter4fvARB_3(target, index, &params);
    
    private GetProgramEnvParameterdvARB_adr := GetProcAddress('glGetProgramEnvParameterdvARB');
    private ntv_GetProgramEnvParameterdvARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: double)>(GetProgramEnvParameterdvARB_adr);
    private ntv_GetProgramEnvParameterdvARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(GetProgramEnvParameterdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterdvARB(target: glProgramTarget; index: UInt32; var &params: double) :=
      ntv_GetProgramEnvParameterdvARB_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterdvARB(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_GetProgramEnvParameterdvARB_2(target, index, &params);
    
    private GetProgramEnvParameterfvARB_adr := GetProcAddress('glGetProgramEnvParameterfvARB');
    private ntv_GetProgramEnvParameterfvARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: single)>(GetProgramEnvParameterfvARB_adr);
    private ntv_GetProgramEnvParameterfvARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(GetProgramEnvParameterfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterfvARB(target: glProgramTarget; index: UInt32; var &params: single) :=
      ntv_GetProgramEnvParameterfvARB_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterfvARB(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_GetProgramEnvParameterfvARB_2(target, index, &params);
    
    private GetProgramLocalParameterdvARB_adr := GetProcAddress('glGetProgramLocalParameterdvARB');
    private ntv_GetProgramLocalParameterdvARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: double)>(GetProgramLocalParameterdvARB_adr);
    private ntv_GetProgramLocalParameterdvARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(GetProgramLocalParameterdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterdvARB(target: glProgramTarget; index: UInt32; var &params: double) :=
      ntv_GetProgramLocalParameterdvARB_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterdvARB(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_GetProgramLocalParameterdvARB_2(target, index, &params);
    
    private GetProgramLocalParameterfvARB_adr := GetProcAddress('glGetProgramLocalParameterfvARB');
    private ntv_GetProgramLocalParameterfvARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: single)>(GetProgramLocalParameterfvARB_adr);
    private ntv_GetProgramLocalParameterfvARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(GetProgramLocalParameterfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterfvARB(target: glProgramTarget; index: UInt32; var &params: single) :=
      ntv_GetProgramLocalParameterfvARB_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterfvARB(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_GetProgramLocalParameterfvARB_2(target, index, &params);
    
    private GetProgramivARB_adr := GetProcAddress('glGetProgramivARB');
    private ntv_GetProgramivARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; pname: glProgramProperty; var &params: Int32)>(GetProgramivARB_adr);
    private ntv_GetProgramivARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; pname: glProgramProperty; &params: IntPtr)>(GetProgramivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivARB(target: glProgramTarget; pname: glProgramProperty; var &params: Int32) :=
      ntv_GetProgramivARB_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivARB(target: glProgramTarget; pname: glProgramProperty; &params: IntPtr) :=
      ntv_GetProgramivARB_2(target, pname, &params);
    
    private GetProgramStringARB_adr := GetProcAddress('glGetProgramStringARB');
    private ntv_GetProgramStringARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; pname: glProgramStringProperty; string: IntPtr)>(GetProgramStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStringARB(target: glProgramTarget; pname: glProgramStringProperty; string: IntPtr) :=
      ntv_GetProgramStringARB_1(target, pname, string);
    
    private IsProgramARB_adr := GetProcAddress('glIsProgramARB');
    private ntv_IsProgramARB_1 := GetProcOrNil&<function(&program: gl_program): glBool8>(IsProgramARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsProgramARB(&program: gl_program): glBool8 :=
      ntv_IsProgramARB_1(&program);
    
  end;
  
  ///
  glFragmentProgramShadowARB = static class
    public const _ExtStr = 'GL_ARB_fragment_program_shadow';
  end;
  
  ///
  glFragmentShaderARB = static class
    public const _ExtStr = 'GL_ARB_fragment_shader';
  end;
  
  ///
  glFragmentShaderInterlockARB = static class
    public const _ExtStr = 'GL_ARB_fragment_shader_interlock';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFramebufferNoAttachmentsARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_framebuffer_no_attachments';
    
    private FramebufferParameteri_adr := GetProcAddress('glFramebufferParameteri');
    private ntv_FramebufferParameteri_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; pname: glFramebufferParameterName; param: Int32)>(FramebufferParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferParameteri(target: glFramebufferTarget; pname: glFramebufferParameterName; param: Int32) :=
      ntv_FramebufferParameteri_1(target, pname, param);
    
    private GetFramebufferParameteriv_adr := GetProcAddress('glGetFramebufferParameteriv');
    private ntv_GetFramebufferParameteriv_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; pname: glFramebufferAttachmentParameterName; var &params: Int32)>(GetFramebufferParameteriv_adr);
    private ntv_GetFramebufferParameteriv_2 := GetProcOrNil&<procedure(target: glFramebufferTarget; pname: glFramebufferAttachmentParameterName; &params: IntPtr)>(GetFramebufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameteriv(target: glFramebufferTarget; pname: glFramebufferAttachmentParameterName; var &params: Int32) :=
      ntv_GetFramebufferParameteriv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameteriv(target: glFramebufferTarget; pname: glFramebufferAttachmentParameterName; &params: IntPtr) :=
      ntv_GetFramebufferParameteriv_2(target, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFramebufferObjectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_framebuffer_object';
    
    private IsRenderbuffer_adr := GetProcAddress('glIsRenderbuffer');
    private ntv_IsRenderbuffer_1 := GetProcOrNil&<function(renderbuffer: gl_renderbuffer): glBool8>(IsRenderbuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsRenderbuffer(renderbuffer: gl_renderbuffer): glBool8 :=
      ntv_IsRenderbuffer_1(renderbuffer);
    
    private BindRenderbuffer_adr := GetProcAddress('glBindRenderbuffer');
    private ntv_BindRenderbuffer_1 := GetProcOrNil&<procedure(target: glRenderbufferTarget; renderbuffer: gl_renderbuffer)>(BindRenderbuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindRenderbuffer(target: glRenderbufferTarget; renderbuffer: gl_renderbuffer) :=
      ntv_BindRenderbuffer_1(target, renderbuffer);
    
    private DeleteRenderbuffers_adr := GetProcAddress('glDeleteRenderbuffers');
    private ntv_DeleteRenderbuffers_1 := GetProcOrNil&<procedure(n: Int32; var renderbuffers: gl_renderbuffer)>(DeleteRenderbuffers_adr);
    private ntv_DeleteRenderbuffers_2 := GetProcOrNil&<procedure(n: Int32; renderbuffers: IntPtr)>(DeleteRenderbuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffers(n: Int32; renderbuffers: array of gl_renderbuffer);
    type PGl_renderbuffer = ^gl_renderbuffer;
    begin
      if (renderbuffers<>nil) and (renderbuffers.Length<>0) then
        ntv_DeleteRenderbuffers_1(n, renderbuffers[0]) else
        ntv_DeleteRenderbuffers_1(n, PGl_renderbuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffers(n: Int32; var renderbuffers: gl_renderbuffer) :=
      ntv_DeleteRenderbuffers_1(n, renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffers(n: Int32; renderbuffers: IntPtr) :=
      ntv_DeleteRenderbuffers_2(n, renderbuffers);
    
    private GenRenderbuffers_adr := GetProcAddress('glGenRenderbuffers');
    private ntv_GenRenderbuffers_1 := GetProcOrNil&<procedure(n: Int32; var renderbuffers: gl_renderbuffer)>(GenRenderbuffers_adr);
    private ntv_GenRenderbuffers_2 := GetProcOrNil&<procedure(n: Int32; renderbuffers: IntPtr)>(GenRenderbuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffers(n: Int32; renderbuffers: array of gl_renderbuffer);
    type PGl_renderbuffer = ^gl_renderbuffer;
    begin
      if (renderbuffers<>nil) and (renderbuffers.Length<>0) then
        ntv_GenRenderbuffers_1(n, renderbuffers[0]) else
        ntv_GenRenderbuffers_1(n, PGl_renderbuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffers(n: Int32; var renderbuffers: gl_renderbuffer) :=
      ntv_GenRenderbuffers_1(n, renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffers(n: Int32; renderbuffers: IntPtr) :=
      ntv_GenRenderbuffers_2(n, renderbuffers);
    
    private RenderbufferStorage_adr := GetProcAddress('glRenderbufferStorage');
    private ntv_RenderbufferStorage_1 := GetProcOrNil&<procedure(target: glRenderbufferTarget; internalformat: glInternalFormat; width: Int32; height: Int32)>(RenderbufferStorage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorage(target: glRenderbufferTarget; internalformat: glInternalFormat; width: Int32; height: Int32) :=
      ntv_RenderbufferStorage_1(target, internalformat, width, height);
    
    private GetRenderbufferParameteriv_adr := GetProcAddress('glGetRenderbufferParameteriv');
    private ntv_GetRenderbufferParameteriv_1 := GetProcOrNil&<procedure(target: glRenderbufferTarget; pname: glRenderbufferParameterName; var &params: Int32)>(GetRenderbufferParameteriv_adr);
    private ntv_GetRenderbufferParameteriv_2 := GetProcOrNil&<procedure(target: glRenderbufferTarget; pname: glRenderbufferParameterName; &params: IntPtr)>(GetRenderbufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameteriv(target: glRenderbufferTarget; pname: glRenderbufferParameterName; var &params: Int32) :=
      ntv_GetRenderbufferParameteriv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameteriv(target: glRenderbufferTarget; pname: glRenderbufferParameterName; &params: IntPtr) :=
      ntv_GetRenderbufferParameteriv_2(target, pname, &params);
    
    private IsFramebuffer_adr := GetProcAddress('glIsFramebuffer');
    private ntv_IsFramebuffer_1 := GetProcOrNil&<function(framebuffer: gl_framebuffer): glBool8>(IsFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsFramebuffer(framebuffer: gl_framebuffer): glBool8 :=
      ntv_IsFramebuffer_1(framebuffer);
    
    private BindFramebuffer_adr := GetProcAddress('glBindFramebuffer');
    private ntv_BindFramebuffer_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; framebuffer: gl_framebuffer)>(BindFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFramebuffer(target: glFramebufferTarget; framebuffer: gl_framebuffer) :=
      ntv_BindFramebuffer_1(target, framebuffer);
    
    private DeleteFramebuffers_adr := GetProcAddress('glDeleteFramebuffers');
    private ntv_DeleteFramebuffers_1 := GetProcOrNil&<procedure(n: Int32; var framebuffers: gl_framebuffer)>(DeleteFramebuffers_adr);
    private ntv_DeleteFramebuffers_2 := GetProcOrNil&<procedure(n: Int32; framebuffers: IntPtr)>(DeleteFramebuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffers(n: Int32; framebuffers: array of gl_framebuffer);
    type PGl_framebuffer = ^gl_framebuffer;
    begin
      if (framebuffers<>nil) and (framebuffers.Length<>0) then
        ntv_DeleteFramebuffers_1(n, framebuffers[0]) else
        ntv_DeleteFramebuffers_1(n, PGl_framebuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffers(n: Int32; var framebuffers: gl_framebuffer) :=
      ntv_DeleteFramebuffers_1(n, framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffers(n: Int32; framebuffers: IntPtr) :=
      ntv_DeleteFramebuffers_2(n, framebuffers);
    
    private GenFramebuffers_adr := GetProcAddress('glGenFramebuffers');
    private ntv_GenFramebuffers_1 := GetProcOrNil&<procedure(n: Int32; var framebuffers: gl_framebuffer)>(GenFramebuffers_adr);
    private ntv_GenFramebuffers_2 := GetProcOrNil&<procedure(n: Int32; framebuffers: IntPtr)>(GenFramebuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffers(n: Int32; framebuffers: array of gl_framebuffer);
    type PGl_framebuffer = ^gl_framebuffer;
    begin
      if (framebuffers<>nil) and (framebuffers.Length<>0) then
        ntv_GenFramebuffers_1(n, framebuffers[0]) else
        ntv_GenFramebuffers_1(n, PGl_framebuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffers(n: Int32; var framebuffers: gl_framebuffer) :=
      ntv_GenFramebuffers_1(n, framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffers(n: Int32; framebuffers: IntPtr) :=
      ntv_GenFramebuffers_2(n, framebuffers);
    
    private CheckFramebufferStatus_adr := GetProcAddress('glCheckFramebufferStatus');
    private ntv_CheckFramebufferStatus_1 := GetProcOrNil&<function(target: glFramebufferTarget): glFramebufferStatus>(CheckFramebufferStatus_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CheckFramebufferStatus(target: glFramebufferTarget): glFramebufferStatus :=
      ntv_CheckFramebufferStatus_1(target);
    
    private FramebufferTexture1D_adr := GetProcAddress('glFramebufferTexture1D');
    private ntv_FramebufferTexture1D_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32)>(FramebufferTexture1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture1D(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32) :=
      ntv_FramebufferTexture1D_1(target, attachment, textarget, texture, level);
    
    private FramebufferTexture2D_adr := GetProcAddress('glFramebufferTexture2D');
    private ntv_FramebufferTexture2D_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32)>(FramebufferTexture2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture2D(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32) :=
      ntv_FramebufferTexture2D_1(target, attachment, textarget, texture, level);
    
    private FramebufferTexture3D_adr := GetProcAddress('glFramebufferTexture3D');
    private ntv_FramebufferTexture3D_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32; zoffset: Int32)>(FramebufferTexture3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture3D(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32; zoffset: Int32) :=
      ntv_FramebufferTexture3D_1(target, attachment, textarget, texture, level, zoffset);
    
    private FramebufferRenderbuffer_adr := GetProcAddress('glFramebufferRenderbuffer');
    private ntv_FramebufferRenderbuffer_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; renderbuffertarget: glRenderbufferTarget; renderbuffer: gl_renderbuffer)>(FramebufferRenderbuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferRenderbuffer(target: glFramebufferTarget; attachment: glFramebufferAttachment; renderbuffertarget: glRenderbufferTarget; renderbuffer: gl_renderbuffer) :=
      ntv_FramebufferRenderbuffer_1(target, attachment, renderbuffertarget, renderbuffer);
    
    private GetFramebufferAttachmentParameteriv_adr := GetProcAddress('glGetFramebufferAttachmentParameteriv');
    private ntv_GetFramebufferAttachmentParameteriv_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; var &params: Int32)>(GetFramebufferAttachmentParameteriv_adr);
    private ntv_GetFramebufferAttachmentParameteriv_2 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; &params: IntPtr)>(GetFramebufferAttachmentParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameteriv(target: glFramebufferTarget; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; var &params: Int32) :=
      ntv_GetFramebufferAttachmentParameteriv_1(target, attachment, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameteriv(target: glFramebufferTarget; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; &params: IntPtr) :=
      ntv_GetFramebufferAttachmentParameteriv_2(target, attachment, pname, &params);
    
    private GenerateMipmap_adr := GetProcAddress('glGenerateMipmap');
    private ntv_GenerateMipmap_1 := GetProcOrNil&<procedure(target: glTextureTarget)>(GenerateMipmap_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateMipmap(target: glTextureTarget) :=
      ntv_GenerateMipmap_1(target);
    
    private BlitFramebuffer_adr := GetProcAddress('glBlitFramebuffer');
    private ntv_BlitFramebuffer_1 := GetProcOrNil&<procedure(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: glClearBufferMask; filter: glBlitFramebufferFilter)>(BlitFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitFramebuffer(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: glClearBufferMask; filter: glBlitFramebufferFilter) :=
      ntv_BlitFramebuffer_1(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    private RenderbufferStorageMultisample_adr := GetProcAddress('glRenderbufferStorageMultisample');
    private ntv_RenderbufferStorageMultisample_1 := GetProcOrNil&<procedure(target: glRenderbufferTarget; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32)>(RenderbufferStorageMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisample(target: glRenderbufferTarget; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32) :=
      ntv_RenderbufferStorageMultisample_1(target, samples, internalformat, width, height);
    
    private FramebufferTextureLayer_adr := GetProcAddress('glFramebufferTextureLayer');
    private ntv_FramebufferTextureLayer_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32)>(FramebufferTextureLayer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureLayer(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32) :=
      ntv_FramebufferTextureLayer_1(target, attachment, texture, level, layer);
    
  end;
  
  ///
  glFramebufferSRGBARB = static class
    public const _ExtStr = 'GL_ARB_framebuffer_sRGB';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glGeometryShader4ARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_geometry_shader4';
    
    private ProgramParameteriARB_adr := GetProcAddress('glProgramParameteriARB');
    private ntv_ProgramParameteriARB_1 := GetProcOrNil&<procedure(&program: gl_program; pname: glProgramParameterPName; value: Int32)>(ProgramParameteriARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameteriARB(&program: gl_program; pname: glProgramParameterPName; value: Int32) :=
      ntv_ProgramParameteriARB_1(&program, pname, value);
    
    private FramebufferTextureARB_adr := GetProcAddress('glFramebufferTextureARB');
    private ntv_FramebufferTextureARB_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32)>(FramebufferTextureARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureARB(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32) :=
      ntv_FramebufferTextureARB_1(target, attachment, texture, level);
    
    private FramebufferTextureLayerARB_adr := GetProcAddress('glFramebufferTextureLayerARB');
    private ntv_FramebufferTextureLayerARB_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32)>(FramebufferTextureLayerARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureLayerARB(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32) :=
      ntv_FramebufferTextureLayerARB_1(target, attachment, texture, level, layer);
    
    private FramebufferTextureFaceARB_adr := GetProcAddress('glFramebufferTextureFaceARB');
    private ntv_FramebufferTextureFaceARB_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; face: glTextureTarget)>(FramebufferTextureFaceARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureFaceARB(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; face: glTextureTarget) :=
      ntv_FramebufferTextureFaceARB_1(target, attachment, texture, level, face);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glGetProgramBinaryARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_get_program_binary';
    
    private GetProgramBinary_adr := GetProcAddress('glGetProgramBinary');
    private ntv_GetProgramBinary_1 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; var length: Int32; var binaryFormat: DummyEnum; binary: IntPtr)>(GetProgramBinary_adr);
    private ntv_GetProgramBinary_2 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; var length: Int32; binaryFormat: IntPtr; binary: IntPtr)>(GetProgramBinary_adr);
    private ntv_GetProgramBinary_3 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; length: IntPtr; var binaryFormat: DummyEnum; binary: IntPtr)>(GetProgramBinary_adr);
    private ntv_GetProgramBinary_4 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; length: IntPtr; binaryFormat: IntPtr; binary: IntPtr)>(GetProgramBinary_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: gl_program; bufSize: Int32; var length: Int32; var binaryFormat: DummyEnum; binary: IntPtr) :=
      ntv_GetProgramBinary_1(&program, bufSize, length, binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: gl_program; bufSize: Int32; var length: Int32; binaryFormat: IntPtr; binary: IntPtr) :=
      ntv_GetProgramBinary_2(&program, bufSize, length, binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: gl_program; bufSize: Int32; length: IntPtr; var binaryFormat: DummyEnum; binary: IntPtr) :=
      ntv_GetProgramBinary_3(&program, bufSize, length, binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: gl_program; bufSize: Int32; length: IntPtr; binaryFormat: IntPtr; binary: IntPtr) :=
      ntv_GetProgramBinary_4(&program, bufSize, length, binaryFormat, binary);
    
    private ProgramBinary_adr := GetProcAddress('glProgramBinary');
    private ntv_ProgramBinary_1 := GetProcOrNil&<procedure(&program: gl_program; binaryFormat: DummyEnum; binary: IntPtr; length: Int32)>(ProgramBinary_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBinary(&program: gl_program; binaryFormat: DummyEnum; binary: IntPtr; length: Int32) :=
      ntv_ProgramBinary_1(&program, binaryFormat, binary, length);
    
    private ProgramParameteri_adr := GetProcAddress('glProgramParameteri');
    private ntv_ProgramParameteri_1 := GetProcOrNil&<procedure(&program: gl_program; pname: glProgramParameterPName; value: Int32)>(ProgramParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameteri(&program: gl_program; pname: glProgramParameterPName; value: Int32) :=
      ntv_ProgramParameteri_1(&program, pname, value);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glGetTextureSubImageARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_get_texture_sub_image';
    
    private GetTextureSubImage_adr := GetProcAddress('glGetTextureSubImage');
    private ntv_GetTextureSubImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; pixels: IntPtr)>(GetTextureSubImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureSubImage(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; pixels: IntPtr) :=
      ntv_GetTextureSubImage_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, bufSize, pixels);
    
    private GetCompressedTextureSubImage_adr := GetProcAddress('glGetCompressedTextureSubImage');
    private ntv_GetCompressedTextureSubImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; bufSize: Int32; pixels: IntPtr)>(GetCompressedTextureSubImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureSubImage(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; bufSize: Int32; pixels: IntPtr) :=
      ntv_GetCompressedTextureSubImage_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glGlSpirvARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_gl_spirv';
    
    private SpecializeShaderARB_adr := GetProcAddress('glSpecializeShaderARB');
    private ntv_SpecializeShaderARB_1 := GetProcOrNil&<procedure(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: UInt32)>(SpecializeShaderARB_adr);
    private ntv_SpecializeShaderARB_2 := GetProcOrNil&<procedure(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; pConstantValue: IntPtr)>(SpecializeShaderARB_adr);
    private ntv_SpecializeShaderARB_3 := GetProcOrNil&<procedure(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; var pConstantValue: UInt32)>(SpecializeShaderARB_adr);
    private ntv_SpecializeShaderARB_4 := GetProcOrNil&<procedure(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; pConstantValue: IntPtr)>(SpecializeShaderARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (pConstantValue<>nil) and (pConstantValue.Length<>0) then
        if (pConstantIndex<>nil) and (pConstantIndex.Length<>0) then
          SpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], pConstantValue[0]) else
          SpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, PUInt32(nil)^, pConstantValue[0]) else
        if (pConstantIndex<>nil) and (pConstantIndex.Length<>0) then
          SpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], PUInt32(nil)^) else
          SpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, PUInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (pConstantValue<>nil) and (pConstantValue.Length<>0) then
        if (pConstantIndex<>nil) and (pConstantIndex.Length<>0) then
          ntv_SpecializeShaderARB_1(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], pConstantValue[0]) else
          ntv_SpecializeShaderARB_1(shader, pEntryPoint, numSpecializationConstants, PUInt32(nil)^, pConstantValue[0]) else
        if (pConstantIndex<>nil) and (pConstantIndex.Length<>0) then
          ntv_SpecializeShaderARB_1(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], PUInt32(nil)^) else
          ntv_SpecializeShaderARB_1(shader, pEntryPoint, numSpecializationConstants, PUInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: UInt32);
    begin
      var pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
      try
        ntv_SpecializeShaderARB_1(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex, pConstantValue);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; pConstantValue: IntPtr);
    begin
      var pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
      try
        ntv_SpecializeShaderARB_2(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex, pConstantValue);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; var pConstantValue: UInt32);
    begin
      var pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
      try
        ntv_SpecializeShaderARB_3(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex, pConstantValue);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; pConstantValue: IntPtr);
    begin
      var pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
      try
        ntv_SpecializeShaderARB_4(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex, pConstantValue);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: UInt32) :=
      ntv_SpecializeShaderARB_1(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; pConstantValue: IntPtr) :=
      ntv_SpecializeShaderARB_2(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; var pConstantValue: UInt32) :=
      ntv_SpecializeShaderARB_3(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; pConstantValue: IntPtr) :=
      ntv_SpecializeShaderARB_4(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glGpuShaderFp64ARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_gpu_shader_fp64';
    
    private Uniform1d_adr := GetProcAddress('glUniform1d');
    private ntv_Uniform1d_1 := GetProcOrNil&<procedure(location: Int32; x: double)>(Uniform1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1d(location: Int32; x: double) :=
      ntv_Uniform1d_1(location, x);
    
    private Uniform2d_adr := GetProcAddress('glUniform2d');
    private ntv_Uniform2d_1 := GetProcOrNil&<procedure(location: Int32; x: double; y: double)>(Uniform2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2d(location: Int32; x: double; y: double) :=
      ntv_Uniform2d_1(location, x, y);
    
    private Uniform3d_adr := GetProcAddress('glUniform3d');
    private ntv_Uniform3d_1 := GetProcOrNil&<procedure(location: Int32; x: double; y: double; z: double)>(Uniform3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3d(location: Int32; x: double; y: double; z: double) :=
      ntv_Uniform3d_1(location, x, y, z);
    
    private Uniform4d_adr := GetProcAddress('glUniform4d');
    private ntv_Uniform4d_1 := GetProcOrNil&<procedure(location: Int32; x: double; y: double; z: double; w: double)>(Uniform4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4d(location: Int32; x: double; y: double; z: double; w: double) :=
      ntv_Uniform4d_1(location, x, y, z, w);
    
    private Uniform1dv_adr := GetProcAddress('glUniform1dv');
    private ntv_Uniform1dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: double)>(Uniform1dv_adr);
    private ntv_Uniform1dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform1dv_1(location, count, value[0]) else
        ntv_Uniform1dv_1(location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; var value: double) :=
      ntv_Uniform1dv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform1dv_2(location, count, value);
    
    private Uniform2dv_adr := GetProcAddress('glUniform2dv');
    private ntv_Uniform2dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: double)>(Uniform2dv_adr);
    private ntv_Uniform2dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2d)>(Uniform2dv_adr);
    private ntv_Uniform2dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform2dv_1(location, count, value[0]) else
        ntv_Uniform2dv_1(location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; var value: Vec2d) :=
      ntv_Uniform2dv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; var value: double) :=
      ntv_Uniform2dv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform2dv_3(location, count, value);
    
    private Uniform3dv_adr := GetProcAddress('glUniform3dv');
    private ntv_Uniform3dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: double)>(Uniform3dv_adr);
    private ntv_Uniform3dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3d)>(Uniform3dv_adr);
    private ntv_Uniform3dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform3dv_1(location, count, value[0]) else
        ntv_Uniform3dv_1(location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; var value: Vec3d) :=
      ntv_Uniform3dv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; var value: double) :=
      ntv_Uniform3dv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform3dv_3(location, count, value);
    
    private Uniform4dv_adr := GetProcAddress('glUniform4dv');
    private ntv_Uniform4dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: double)>(Uniform4dv_adr);
    private ntv_Uniform4dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4d)>(Uniform4dv_adr);
    private ntv_Uniform4dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform4dv_1(location, count, value[0]) else
        ntv_Uniform4dv_1(location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; var value: Vec4d) :=
      ntv_Uniform4dv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; var value: double) :=
      ntv_Uniform4dv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform4dv_3(location, count, value);
    
    private UniformMatrix2dv_adr := GetProcAddress('glUniformMatrix2dv');
    private ntv_UniformMatrix2dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix2dv_adr);
    private ntv_UniformMatrix2dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2d)>(UniformMatrix2dv_adr);
    private ntv_UniformMatrix2dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix2dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix2dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2d) :=
      ntv_UniformMatrix2dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix2dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix2dv_3(location, count, transpose, value);
    
    private UniformMatrix3dv_adr := GetProcAddress('glUniformMatrix3dv');
    private ntv_UniformMatrix3dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix3dv_adr);
    private ntv_UniformMatrix3dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3d)>(UniformMatrix3dv_adr);
    private ntv_UniformMatrix3dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix3dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix3dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3d) :=
      ntv_UniformMatrix3dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix3dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix3dv_3(location, count, transpose, value);
    
    private UniformMatrix4dv_adr := GetProcAddress('glUniformMatrix4dv');
    private ntv_UniformMatrix4dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix4dv_adr);
    private ntv_UniformMatrix4dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4d)>(UniformMatrix4dv_adr);
    private ntv_UniformMatrix4dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix4dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix4dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4d) :=
      ntv_UniformMatrix4dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix4dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix4dv_3(location, count, transpose, value);
    
    private UniformMatrix2x3dv_adr := GetProcAddress('glUniformMatrix2x3dv');
    private ntv_UniformMatrix2x3dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix2x3dv_adr);
    private ntv_UniformMatrix2x3dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3d)>(UniformMatrix2x3dv_adr);
    private ntv_UniformMatrix2x3dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix2x3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix2x3dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix2x3dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3d) :=
      ntv_UniformMatrix2x3dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix2x3dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix2x3dv_3(location, count, transpose, value);
    
    private UniformMatrix2x4dv_adr := GetProcAddress('glUniformMatrix2x4dv');
    private ntv_UniformMatrix2x4dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix2x4dv_adr);
    private ntv_UniformMatrix2x4dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4d)>(UniformMatrix2x4dv_adr);
    private ntv_UniformMatrix2x4dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix2x4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix2x4dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix2x4dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4d) :=
      ntv_UniformMatrix2x4dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix2x4dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix2x4dv_3(location, count, transpose, value);
    
    private UniformMatrix3x2dv_adr := GetProcAddress('glUniformMatrix3x2dv');
    private ntv_UniformMatrix3x2dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix3x2dv_adr);
    private ntv_UniformMatrix3x2dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2d)>(UniformMatrix3x2dv_adr);
    private ntv_UniformMatrix3x2dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix3x2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix3x2dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix3x2dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2d) :=
      ntv_UniformMatrix3x2dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix3x2dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix3x2dv_3(location, count, transpose, value);
    
    private UniformMatrix3x4dv_adr := GetProcAddress('glUniformMatrix3x4dv');
    private ntv_UniformMatrix3x4dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix3x4dv_adr);
    private ntv_UniformMatrix3x4dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4d)>(UniformMatrix3x4dv_adr);
    private ntv_UniformMatrix3x4dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix3x4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix3x4dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix3x4dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4d) :=
      ntv_UniformMatrix3x4dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix3x4dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix3x4dv_3(location, count, transpose, value);
    
    private UniformMatrix4x2dv_adr := GetProcAddress('glUniformMatrix4x2dv');
    private ntv_UniformMatrix4x2dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix4x2dv_adr);
    private ntv_UniformMatrix4x2dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2d)>(UniformMatrix4x2dv_adr);
    private ntv_UniformMatrix4x2dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix4x2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix4x2dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix4x2dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2d) :=
      ntv_UniformMatrix4x2dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix4x2dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix4x2dv_3(location, count, transpose, value);
    
    private UniformMatrix4x3dv_adr := GetProcAddress('glUniformMatrix4x3dv');
    private ntv_UniformMatrix4x3dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix4x3dv_adr);
    private ntv_UniformMatrix4x3dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3d)>(UniformMatrix4x3dv_adr);
    private ntv_UniformMatrix4x3dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix4x3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix4x3dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix4x3dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3d) :=
      ntv_UniformMatrix4x3dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix4x3dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix4x3dv_3(location, count, transpose, value);
    
    private GetUniformdv_adr := GetProcAddress('glGetUniformdv');
    private ntv_GetUniformdv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: double)>(GetUniformdv_adr);
    private ntv_GetUniformdv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(GetUniformdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformdv(&program: gl_program; location: Int32; var &params: double) :=
      ntv_GetUniformdv_1(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformdv(&program: gl_program; location: Int32; &params: IntPtr) :=
      ntv_GetUniformdv_2(&program, location, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glGpuShaderInt64ARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_gpu_shader_int64';
    
    private Uniform1i64ARB_adr := GetProcAddress('glUniform1i64ARB');
    private ntv_Uniform1i64ARB_1 := GetProcOrNil&<procedure(location: Int32; x: Int64)>(Uniform1i64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64ARB(location: Int32; x: Int64) :=
      ntv_Uniform1i64ARB_1(location, x);
    
    private Uniform2i64ARB_adr := GetProcAddress('glUniform2i64ARB');
    private ntv_Uniform2i64ARB_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64)>(Uniform2i64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64ARB(location: Int32; x: Int64; y: Int64) :=
      ntv_Uniform2i64ARB_1(location, x, y);
    
    private Uniform3i64ARB_adr := GetProcAddress('glUniform3i64ARB');
    private ntv_Uniform3i64ARB_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64)>(Uniform3i64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64ARB(location: Int32; x: Int64; y: Int64; z: Int64) :=
      ntv_Uniform3i64ARB_1(location, x, y, z);
    
    private Uniform4i64ARB_adr := GetProcAddress('glUniform4i64ARB');
    private ntv_Uniform4i64ARB_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>(Uniform4i64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64ARB(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) :=
      ntv_Uniform4i64ARB_1(location, x, y, z, w);
    
    private Uniform1i64vARB_adr := GetProcAddress('glUniform1i64vARB');
    private ntv_Uniform1i64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(Uniform1i64vARB_adr);
    private ntv_Uniform1i64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform1i64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vARB(location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform1i64vARB_1(location, count, value[0]) else
        ntv_Uniform1i64vARB_1(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vARB(location: Int32; count: Int32; var value: Int64) :=
      ntv_Uniform1i64vARB_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vARB(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform1i64vARB_2(location, count, value);
    
    private Uniform2i64vARB_adr := GetProcAddress('glUniform2i64vARB');
    private ntv_Uniform2i64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(Uniform2i64vARB_adr);
    private ntv_Uniform2i64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2i64)>(Uniform2i64vARB_adr);
    private ntv_Uniform2i64vARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform2i64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vARB(location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform2i64vARB_1(location, count, value[0]) else
        ntv_Uniform2i64vARB_1(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vARB(location: Int32; count: Int32; var value: Vec2i64) :=
      ntv_Uniform2i64vARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vARB(location: Int32; count: Int32; var value: Int64) :=
      ntv_Uniform2i64vARB_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vARB(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform2i64vARB_3(location, count, value);
    
    private Uniform3i64vARB_adr := GetProcAddress('glUniform3i64vARB');
    private ntv_Uniform3i64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(Uniform3i64vARB_adr);
    private ntv_Uniform3i64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3i64)>(Uniform3i64vARB_adr);
    private ntv_Uniform3i64vARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform3i64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vARB(location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform3i64vARB_1(location, count, value[0]) else
        ntv_Uniform3i64vARB_1(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vARB(location: Int32; count: Int32; var value: Vec3i64) :=
      ntv_Uniform3i64vARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vARB(location: Int32; count: Int32; var value: Int64) :=
      ntv_Uniform3i64vARB_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vARB(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform3i64vARB_3(location, count, value);
    
    private Uniform4i64vARB_adr := GetProcAddress('glUniform4i64vARB');
    private ntv_Uniform4i64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(Uniform4i64vARB_adr);
    private ntv_Uniform4i64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4i64)>(Uniform4i64vARB_adr);
    private ntv_Uniform4i64vARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform4i64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vARB(location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform4i64vARB_1(location, count, value[0]) else
        ntv_Uniform4i64vARB_1(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vARB(location: Int32; count: Int32; var value: Vec4i64) :=
      ntv_Uniform4i64vARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vARB(location: Int32; count: Int32; var value: Int64) :=
      ntv_Uniform4i64vARB_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vARB(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform4i64vARB_3(location, count, value);
    
    private Uniform1ui64ARB_adr := GetProcAddress('glUniform1ui64ARB');
    private ntv_Uniform1ui64ARB_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64)>(Uniform1ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64ARB(location: Int32; x: UInt64) :=
      ntv_Uniform1ui64ARB_1(location, x);
    
    private Uniform2ui64ARB_adr := GetProcAddress('glUniform2ui64ARB');
    private ntv_Uniform2ui64ARB_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64)>(Uniform2ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64ARB(location: Int32; x: UInt64; y: UInt64) :=
      ntv_Uniform2ui64ARB_1(location, x, y);
    
    private Uniform3ui64ARB_adr := GetProcAddress('glUniform3ui64ARB');
    private ntv_Uniform3ui64ARB_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64)>(Uniform3ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64ARB(location: Int32; x: UInt64; y: UInt64; z: UInt64) :=
      ntv_Uniform3ui64ARB_1(location, x, y, z);
    
    private Uniform4ui64ARB_adr := GetProcAddress('glUniform4ui64ARB');
    private ntv_Uniform4ui64ARB_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>(Uniform4ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64ARB(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) :=
      ntv_Uniform4ui64ARB_1(location, x, y, z, w);
    
    private Uniform1ui64vARB_adr := GetProcAddress('glUniform1ui64vARB');
    private ntv_Uniform1ui64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(Uniform1ui64vARB_adr);
    private ntv_Uniform1ui64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform1ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vARB(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform1ui64vARB_1(location, count, value[0]) else
        ntv_Uniform1ui64vARB_1(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vARB(location: Int32; count: Int32; var value: UInt64) :=
      ntv_Uniform1ui64vARB_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vARB(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform1ui64vARB_2(location, count, value);
    
    private Uniform2ui64vARB_adr := GetProcAddress('glUniform2ui64vARB');
    private ntv_Uniform2ui64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(Uniform2ui64vARB_adr);
    private ntv_Uniform2ui64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2ui64)>(Uniform2ui64vARB_adr);
    private ntv_Uniform2ui64vARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform2ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vARB(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform2ui64vARB_1(location, count, value[0]) else
        ntv_Uniform2ui64vARB_1(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vARB(location: Int32; count: Int32; var value: Vec2ui64) :=
      ntv_Uniform2ui64vARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vARB(location: Int32; count: Int32; var value: UInt64) :=
      ntv_Uniform2ui64vARB_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vARB(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform2ui64vARB_3(location, count, value);
    
    private Uniform3ui64vARB_adr := GetProcAddress('glUniform3ui64vARB');
    private ntv_Uniform3ui64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(Uniform3ui64vARB_adr);
    private ntv_Uniform3ui64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3ui64)>(Uniform3ui64vARB_adr);
    private ntv_Uniform3ui64vARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform3ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vARB(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform3ui64vARB_1(location, count, value[0]) else
        ntv_Uniform3ui64vARB_1(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vARB(location: Int32; count: Int32; var value: Vec3ui64) :=
      ntv_Uniform3ui64vARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vARB(location: Int32; count: Int32; var value: UInt64) :=
      ntv_Uniform3ui64vARB_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vARB(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform3ui64vARB_3(location, count, value);
    
    private Uniform4ui64vARB_adr := GetProcAddress('glUniform4ui64vARB');
    private ntv_Uniform4ui64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(Uniform4ui64vARB_adr);
    private ntv_Uniform4ui64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4ui64)>(Uniform4ui64vARB_adr);
    private ntv_Uniform4ui64vARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform4ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vARB(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform4ui64vARB_1(location, count, value[0]) else
        ntv_Uniform4ui64vARB_1(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vARB(location: Int32; count: Int32; var value: Vec4ui64) :=
      ntv_Uniform4ui64vARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vARB(location: Int32; count: Int32; var value: UInt64) :=
      ntv_Uniform4ui64vARB_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vARB(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform4ui64vARB_3(location, count, value);
    
    private GetUniformi64vARB_adr := GetProcAddress('glGetUniformi64vARB');
    private ntv_GetUniformi64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: Int64)>(GetUniformi64vARB_adr);
    private ntv_GetUniformi64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(GetUniformi64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vARB(&program: gl_program; location: Int32; var &params: Int64) :=
      ntv_GetUniformi64vARB_1(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vARB(&program: gl_program; location: Int32; &params: IntPtr) :=
      ntv_GetUniformi64vARB_2(&program, location, &params);
    
    private GetUniformui64vARB_adr := GetProcAddress('glGetUniformui64vARB');
    private ntv_GetUniformui64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: UInt64)>(GetUniformui64vARB_adr);
    private ntv_GetUniformui64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(GetUniformui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vARB(&program: gl_program; location: Int32; var &params: UInt64) :=
      ntv_GetUniformui64vARB_1(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vARB(&program: gl_program; location: Int32; &params: IntPtr) :=
      ntv_GetUniformui64vARB_2(&program, location, &params);
    
    private GetnUniformi64vARB_adr := GetProcAddress('glGetnUniformi64vARB');
    private ntv_GetnUniformi64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: Int64)>(GetnUniformi64vARB_adr);
    private ntv_GetnUniformi64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(GetnUniformi64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformi64vARB(&program: gl_program; location: Int32; bufSize: Int32; var &params: Int64) :=
      ntv_GetnUniformi64vARB_1(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformi64vARB(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
      ntv_GetnUniformi64vARB_2(&program, location, bufSize, &params);
    
    private GetnUniformui64vARB_adr := GetProcAddress('glGetnUniformui64vARB');
    private ntv_GetnUniformui64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: UInt64)>(GetnUniformui64vARB_adr);
    private ntv_GetnUniformui64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(GetnUniformui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformui64vARB(&program: gl_program; location: Int32; bufSize: Int32; var &params: UInt64) :=
      ntv_GetnUniformui64vARB_1(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformui64vARB(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
      ntv_GetnUniformui64vARB_2(&program, location, bufSize, &params);
    
    private ProgramUniform1i64ARB_adr := GetProcAddress('glProgramUniform1i64ARB');
    private ntv_ProgramUniform1i64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64)>(ProgramUniform1i64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64ARB(&program: gl_program; location: Int32; x: Int64) :=
      ntv_ProgramUniform1i64ARB_1(&program, location, x);
    
    private ProgramUniform2i64ARB_adr := GetProcAddress('glProgramUniform2i64ARB');
    private ntv_ProgramUniform2i64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64)>(ProgramUniform2i64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64ARB(&program: gl_program; location: Int32; x: Int64; y: Int64) :=
      ntv_ProgramUniform2i64ARB_1(&program, location, x, y);
    
    private ProgramUniform3i64ARB_adr := GetProcAddress('glProgramUniform3i64ARB');
    private ntv_ProgramUniform3i64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64)>(ProgramUniform3i64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64ARB(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64) :=
      ntv_ProgramUniform3i64ARB_1(&program, location, x, y, z);
    
    private ProgramUniform4i64ARB_adr := GetProcAddress('glProgramUniform4i64ARB');
    private ntv_ProgramUniform4i64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>(ProgramUniform4i64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64ARB(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) :=
      ntv_ProgramUniform4i64ARB_1(&program, location, x, y, z, w);
    
    private ProgramUniform1i64vARB_adr := GetProcAddress('glProgramUniform1i64vARB');
    private ntv_ProgramUniform1i64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(ProgramUniform1i64vARB_adr);
    private ntv_ProgramUniform1i64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1i64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vARB(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1i64vARB_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1i64vARB_1(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vARB(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
      ntv_ProgramUniform1i64vARB_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vARB(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1i64vARB_2(&program, location, count, value);
    
    private ProgramUniform2i64vARB_adr := GetProcAddress('glProgramUniform2i64vARB');
    private ntv_ProgramUniform2i64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(ProgramUniform2i64vARB_adr);
    private ntv_ProgramUniform2i64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2i64)>(ProgramUniform2i64vARB_adr);
    private ntv_ProgramUniform2i64vARB_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2i64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vARB(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2i64vARB_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2i64vARB_1(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vARB(&program: gl_program; location: Int32; count: Int32; var value: Vec2i64) :=
      ntv_ProgramUniform2i64vARB_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vARB(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
      ntv_ProgramUniform2i64vARB_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vARB(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2i64vARB_3(&program, location, count, value);
    
    private ProgramUniform3i64vARB_adr := GetProcAddress('glProgramUniform3i64vARB');
    private ntv_ProgramUniform3i64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(ProgramUniform3i64vARB_adr);
    private ntv_ProgramUniform3i64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3i64)>(ProgramUniform3i64vARB_adr);
    private ntv_ProgramUniform3i64vARB_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3i64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vARB(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3i64vARB_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3i64vARB_1(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vARB(&program: gl_program; location: Int32; count: Int32; var value: Vec3i64) :=
      ntv_ProgramUniform3i64vARB_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vARB(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
      ntv_ProgramUniform3i64vARB_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vARB(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3i64vARB_3(&program, location, count, value);
    
    private ProgramUniform4i64vARB_adr := GetProcAddress('glProgramUniform4i64vARB');
    private ntv_ProgramUniform4i64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(ProgramUniform4i64vARB_adr);
    private ntv_ProgramUniform4i64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4i64)>(ProgramUniform4i64vARB_adr);
    private ntv_ProgramUniform4i64vARB_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4i64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vARB(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4i64vARB_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4i64vARB_1(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vARB(&program: gl_program; location: Int32; count: Int32; var value: Vec4i64) :=
      ntv_ProgramUniform4i64vARB_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vARB(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
      ntv_ProgramUniform4i64vARB_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vARB(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4i64vARB_3(&program, location, count, value);
    
    private ProgramUniform1ui64ARB_adr := GetProcAddress('glProgramUniform1ui64ARB');
    private ntv_ProgramUniform1ui64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64)>(ProgramUniform1ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64ARB(&program: gl_program; location: Int32; x: UInt64) :=
      ntv_ProgramUniform1ui64ARB_1(&program, location, x);
    
    private ProgramUniform2ui64ARB_adr := GetProcAddress('glProgramUniform2ui64ARB');
    private ntv_ProgramUniform2ui64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64)>(ProgramUniform2ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64ARB(&program: gl_program; location: Int32; x: UInt64; y: UInt64) :=
      ntv_ProgramUniform2ui64ARB_1(&program, location, x, y);
    
    private ProgramUniform3ui64ARB_adr := GetProcAddress('glProgramUniform3ui64ARB');
    private ntv_ProgramUniform3ui64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64)>(ProgramUniform3ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64ARB(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64) :=
      ntv_ProgramUniform3ui64ARB_1(&program, location, x, y, z);
    
    private ProgramUniform4ui64ARB_adr := GetProcAddress('glProgramUniform4ui64ARB');
    private ntv_ProgramUniform4ui64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>(ProgramUniform4ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64ARB(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) :=
      ntv_ProgramUniform4ui64ARB_1(&program, location, x, y, z, w);
    
    private ProgramUniform1ui64vARB_adr := GetProcAddress('glProgramUniform1ui64vARB');
    private ntv_ProgramUniform1ui64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(ProgramUniform1ui64vARB_adr);
    private ntv_ProgramUniform1ui64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vARB(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1ui64vARB_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1ui64vARB_1(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vARB(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
      ntv_ProgramUniform1ui64vARB_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vARB(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1ui64vARB_2(&program, location, count, value);
    
    private ProgramUniform2ui64vARB_adr := GetProcAddress('glProgramUniform2ui64vARB');
    private ntv_ProgramUniform2ui64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(ProgramUniform2ui64vARB_adr);
    private ntv_ProgramUniform2ui64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2ui64)>(ProgramUniform2ui64vARB_adr);
    private ntv_ProgramUniform2ui64vARB_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vARB(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2ui64vARB_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2ui64vARB_1(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vARB(&program: gl_program; location: Int32; count: Int32; var value: Vec2ui64) :=
      ntv_ProgramUniform2ui64vARB_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vARB(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
      ntv_ProgramUniform2ui64vARB_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vARB(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2ui64vARB_3(&program, location, count, value);
    
    private ProgramUniform3ui64vARB_adr := GetProcAddress('glProgramUniform3ui64vARB');
    private ntv_ProgramUniform3ui64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(ProgramUniform3ui64vARB_adr);
    private ntv_ProgramUniform3ui64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3ui64)>(ProgramUniform3ui64vARB_adr);
    private ntv_ProgramUniform3ui64vARB_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vARB(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3ui64vARB_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3ui64vARB_1(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vARB(&program: gl_program; location: Int32; count: Int32; var value: Vec3ui64) :=
      ntv_ProgramUniform3ui64vARB_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vARB(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
      ntv_ProgramUniform3ui64vARB_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vARB(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3ui64vARB_3(&program, location, count, value);
    
    private ProgramUniform4ui64vARB_adr := GetProcAddress('glProgramUniform4ui64vARB');
    private ntv_ProgramUniform4ui64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(ProgramUniform4ui64vARB_adr);
    private ntv_ProgramUniform4ui64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4ui64)>(ProgramUniform4ui64vARB_adr);
    private ntv_ProgramUniform4ui64vARB_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vARB(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4ui64vARB_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4ui64vARB_1(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vARB(&program: gl_program; location: Int32; count: Int32; var value: Vec4ui64) :=
      ntv_ProgramUniform4ui64vARB_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vARB(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
      ntv_ProgramUniform4ui64vARB_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vARB(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4ui64vARB_3(&program, location, count, value);
    
  end;
  
  ///
  glGpuShader5ARB = static class
    public const _ExtStr = 'GL_ARB_gpu_shader5';
  end;
  
  ///
  glHalfFloatPixelARB = static class
    public const _ExtStr = 'GL_ARB_half_float_pixel';
  end;
  
  ///
  glHalfFloatVertexARB = static class
    public const _ExtStr = 'GL_ARB_half_float_vertex';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glImagingARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_imaging';
    
    private BlendColor_adr := GetProcAddress('glBlendColor');
    private ntv_BlendColor_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single; alpha: single)>(BlendColor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendColor(red: single; green: single; blue: single; alpha: single) :=
      ntv_BlendColor_1(red, green, blue, alpha);
    
    private BlendEquation_adr := GetProcAddress('glBlendEquation');
    private ntv_BlendEquation_1 := GetProcOrNil&<procedure(mode: glBlendEquationMode)>(BlendEquation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquation(mode: glBlendEquationMode) :=
      ntv_BlendEquation_1(mode);
    
    private ColorTable_adr := GetProcAddress('glColorTable');
    private ntv_ColorTable_1 := GetProcOrNil&<procedure(target: glColorTableTarget; internalformat: glInternalFormat; width: Int32; format: glPixelFormat; &type: glPixelType; table: IntPtr)>(ColorTable_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTable(target: glColorTableTarget; internalformat: glInternalFormat; width: Int32; format: glPixelFormat; &type: glPixelType; table: IntPtr) :=
      ntv_ColorTable_1(target, internalformat, width, format, &type, table);
    
    private ColorTableParameterfv_adr := GetProcAddress('glColorTableParameterfv');
    private ntv_ColorTableParameterfv_1 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: single)>(ColorTableParameterfv_adr);
    private ntv_ColorTableParameterfv_2 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Vec4f)>(ColorTableParameterfv_adr);
    private ntv_ColorTableParameterfv_3 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr)>(ColorTableParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfv(target: glColorTableTarget; pname: glColorTableParameterPName; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ColorTableParameterfv_1(target, pname, &params[0]) else
        ntv_ColorTableParameterfv_1(target, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfv(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Vec4f) :=
      ntv_ColorTableParameterfv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfv(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: single) :=
      ntv_ColorTableParameterfv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfv(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr) :=
      ntv_ColorTableParameterfv_3(target, pname, &params);
    
    private ColorTableParameteriv_adr := GetProcAddress('glColorTableParameteriv');
    private ntv_ColorTableParameteriv_1 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Int32)>(ColorTableParameteriv_adr);
    private ntv_ColorTableParameteriv_2 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Vec4i)>(ColorTableParameteriv_adr);
    private ntv_ColorTableParameteriv_3 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr)>(ColorTableParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameteriv(target: glColorTableTarget; pname: glColorTableParameterPName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ColorTableParameteriv_1(target, pname, &params[0]) else
        ntv_ColorTableParameteriv_1(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameteriv(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Vec4i) :=
      ntv_ColorTableParameteriv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameteriv(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Int32) :=
      ntv_ColorTableParameteriv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameteriv(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr) :=
      ntv_ColorTableParameteriv_3(target, pname, &params);
    
    private CopyColorTable_adr := GetProcAddress('glCopyColorTable');
    private ntv_CopyColorTable_1 := GetProcOrNil&<procedure(target: glColorTableTarget; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32)>(CopyColorTable_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyColorTable(target: glColorTableTarget; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32) :=
      ntv_CopyColorTable_1(target, internalformat, x, y, width);
    
    private GetColorTable_adr := GetProcAddress('glGetColorTable');
    private ntv_GetColorTable_1 := GetProcOrNil&<procedure(target: glColorTableTarget; format: glPixelFormat; &type: glPixelType; table: IntPtr)>(GetColorTable_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTable(target: glColorTableTarget; format: glPixelFormat; &type: glPixelType; table: IntPtr) :=
      ntv_GetColorTable_1(target, format, &type, table);
    
    private GetColorTableParameterfv_adr := GetProcAddress('glGetColorTableParameterfv');
    private ntv_GetColorTableParameterfv_1 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: single)>(GetColorTableParameterfv_adr);
    private ntv_GetColorTableParameterfv_2 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr)>(GetColorTableParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfv(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: single) :=
      ntv_GetColorTableParameterfv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfv(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr) :=
      ntv_GetColorTableParameterfv_2(target, pname, &params);
    
    private GetColorTableParameteriv_adr := GetProcAddress('glGetColorTableParameteriv');
    private ntv_GetColorTableParameteriv_1 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Int32)>(GetColorTableParameteriv_adr);
    private ntv_GetColorTableParameteriv_2 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr)>(GetColorTableParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameteriv(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Int32) :=
      ntv_GetColorTableParameteriv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameteriv(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr) :=
      ntv_GetColorTableParameteriv_2(target, pname, &params);
    
    private ColorSubTable_adr := GetProcAddress('glColorSubTable');
    private ntv_ColorSubTable_1 := GetProcOrNil&<procedure(target: glColorTableTarget; start: Int32; count: Int32; format: glPixelFormat; &type: glPixelType; data: IntPtr)>(ColorSubTable_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorSubTable(target: glColorTableTarget; start: Int32; count: Int32; format: glPixelFormat; &type: glPixelType; data: IntPtr) :=
      ntv_ColorSubTable_1(target, start, count, format, &type, data);
    
    private CopyColorSubTable_adr := GetProcAddress('glCopyColorSubTable');
    private ntv_CopyColorSubTable_1 := GetProcOrNil&<procedure(target: glColorTableTarget; start: Int32; x: Int32; y: Int32; width: Int32)>(CopyColorSubTable_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyColorSubTable(target: glColorTableTarget; start: Int32; x: Int32; y: Int32; width: Int32) :=
      ntv_CopyColorSubTable_1(target, start, x, y, width);
    
    private ConvolutionFilter1D_adr := GetProcAddress('glConvolutionFilter1D');
    private ntv_ConvolutionFilter1D_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; internalformat: glInternalFormat; width: Int32; format: glPixelFormat; &type: glPixelType; image: IntPtr)>(ConvolutionFilter1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionFilter1D(target: glConvolutionTarget; internalformat: glInternalFormat; width: Int32; format: glPixelFormat; &type: glPixelType; image: IntPtr) :=
      ntv_ConvolutionFilter1D_1(target, internalformat, width, format, &type, image);
    
    private ConvolutionFilter2D_adr := GetProcAddress('glConvolutionFilter2D');
    private ntv_ConvolutionFilter2D_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; internalformat: glInternalFormat; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; image: IntPtr)>(ConvolutionFilter2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionFilter2D(target: glConvolutionTarget; internalformat: glInternalFormat; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; image: IntPtr) :=
      ntv_ConvolutionFilter2D_1(target, internalformat, width, height, format, &type, image);
    
    private ConvolutionParameterf_adr := GetProcAddress('glConvolutionParameterf');
    private ntv_ConvolutionParameterf_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; &params: single)>(ConvolutionParameterf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterf(target: glConvolutionTarget; pname: glConvolutionParameter; &params: single) :=
      ntv_ConvolutionParameterf_1(target, pname, &params);
    
    private ConvolutionParameterfv_adr := GetProcAddress('glConvolutionParameterfv');
    private ntv_ConvolutionParameterfv_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: single)>(ConvolutionParameterfv_adr);
    private ntv_ConvolutionParameterfv_2 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr)>(ConvolutionParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfv(target: glConvolutionTarget; pname: glConvolutionParameter; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ConvolutionParameterfv_1(target, pname, &params[0]) else
        ntv_ConvolutionParameterfv_1(target, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfv(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: single) :=
      ntv_ConvolutionParameterfv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfv(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr) :=
      ntv_ConvolutionParameterfv_2(target, pname, &params);
    
    private ConvolutionParameteri_adr := GetProcAddress('glConvolutionParameteri');
    private ntv_ConvolutionParameteri_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; &params: Int32)>(ConvolutionParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteri(target: glConvolutionTarget; pname: glConvolutionParameter; &params: Int32) :=
      ntv_ConvolutionParameteri_1(target, pname, &params);
    
    private ConvolutionParameteriv_adr := GetProcAddress('glConvolutionParameteriv');
    private ntv_ConvolutionParameteriv_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: Int32)>(ConvolutionParameteriv_adr);
    private ntv_ConvolutionParameteriv_2 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr)>(ConvolutionParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteriv(target: glConvolutionTarget; pname: glConvolutionParameter; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ConvolutionParameteriv_1(target, pname, &params[0]) else
        ntv_ConvolutionParameteriv_1(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteriv(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: Int32) :=
      ntv_ConvolutionParameteriv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteriv(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr) :=
      ntv_ConvolutionParameteriv_2(target, pname, &params);
    
    private CopyConvolutionFilter1D_adr := GetProcAddress('glCopyConvolutionFilter1D');
    private ntv_CopyConvolutionFilter1D_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32)>(CopyConvolutionFilter1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyConvolutionFilter1D(target: glConvolutionTarget; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32) :=
      ntv_CopyConvolutionFilter1D_1(target, internalformat, x, y, width);
    
    private CopyConvolutionFilter2D_adr := GetProcAddress('glCopyConvolutionFilter2D');
    private ntv_CopyConvolutionFilter2D_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; height: Int32)>(CopyConvolutionFilter2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyConvolutionFilter2D(target: glConvolutionTarget; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_CopyConvolutionFilter2D_1(target, internalformat, x, y, width, height);
    
    private GetConvolutionFilter_adr := GetProcAddress('glGetConvolutionFilter');
    private ntv_GetConvolutionFilter_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; format: glPixelFormat; &type: glPixelType; image: IntPtr)>(GetConvolutionFilter_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionFilter(target: glConvolutionTarget; format: glPixelFormat; &type: glPixelType; image: IntPtr) :=
      ntv_GetConvolutionFilter_1(target, format, &type, image);
    
    private GetConvolutionParameterfv_adr := GetProcAddress('glGetConvolutionParameterfv');
    private ntv_GetConvolutionParameterfv_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: single)>(GetConvolutionParameterfv_adr);
    private ntv_GetConvolutionParameterfv_2 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr)>(GetConvolutionParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterfv(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: single) :=
      ntv_GetConvolutionParameterfv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterfv(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr) :=
      ntv_GetConvolutionParameterfv_2(target, pname, &params);
    
    private GetConvolutionParameteriv_adr := GetProcAddress('glGetConvolutionParameteriv');
    private ntv_GetConvolutionParameteriv_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: Int32)>(GetConvolutionParameteriv_adr);
    private ntv_GetConvolutionParameteriv_2 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr)>(GetConvolutionParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameteriv(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: Int32) :=
      ntv_GetConvolutionParameteriv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameteriv(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr) :=
      ntv_GetConvolutionParameteriv_2(target, pname, &params);
    
    private GetSeparableFilter_adr := GetProcAddress('glGetSeparableFilter');
    private ntv_GetSeparableFilter_1 := GetProcOrNil&<procedure(target: glSeparableTarget; format: glPixelFormat; &type: glPixelType; row: IntPtr; column: IntPtr; span: IntPtr)>(GetSeparableFilter_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSeparableFilter(target: glSeparableTarget; format: glPixelFormat; &type: glPixelType; row: IntPtr; column: IntPtr; span: IntPtr) :=
      ntv_GetSeparableFilter_1(target, format, &type, row, column, span);
    
    private SeparableFilter2D_adr := GetProcAddress('glSeparableFilter2D');
    private ntv_SeparableFilter2D_1 := GetProcOrNil&<procedure(target: glSeparableTarget; internalformat: glInternalFormat; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; row: IntPtr; column: IntPtr)>(SeparableFilter2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SeparableFilter2D(target: glSeparableTarget; internalformat: glInternalFormat; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; row: IntPtr; column: IntPtr) :=
      ntv_SeparableFilter2D_1(target, internalformat, width, height, format, &type, row, column);
    
    private GetHistogram_adr := GetProcAddress('glGetHistogram');
    private ntv_GetHistogram_1 := GetProcOrNil&<procedure(target: glHistogramTarget; reset: glBool8; format: glPixelFormat; &type: glPixelType; values: IntPtr)>(GetHistogram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogram(target: glHistogramTarget; reset: glBool8; format: glPixelFormat; &type: glPixelType; values: IntPtr) :=
      ntv_GetHistogram_1(target, reset, format, &type, values);
    
    private GetHistogramParameterfv_adr := GetProcAddress('glGetHistogramParameterfv');
    private ntv_GetHistogramParameterfv_1 := GetProcOrNil&<procedure(target: glHistogramTarget; pname: glGetHistogramParameterPName; var &params: single)>(GetHistogramParameterfv_adr);
    private ntv_GetHistogramParameterfv_2 := GetProcOrNil&<procedure(target: glHistogramTarget; pname: glGetHistogramParameterPName; &params: IntPtr)>(GetHistogramParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterfv(target: glHistogramTarget; pname: glGetHistogramParameterPName; var &params: single) :=
      ntv_GetHistogramParameterfv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterfv(target: glHistogramTarget; pname: glGetHistogramParameterPName; &params: IntPtr) :=
      ntv_GetHistogramParameterfv_2(target, pname, &params);
    
    private GetHistogramParameteriv_adr := GetProcAddress('glGetHistogramParameteriv');
    private ntv_GetHistogramParameteriv_1 := GetProcOrNil&<procedure(target: glHistogramTarget; pname: glGetHistogramParameterPName; var &params: Int32)>(GetHistogramParameteriv_adr);
    private ntv_GetHistogramParameteriv_2 := GetProcOrNil&<procedure(target: glHistogramTarget; pname: glGetHistogramParameterPName; &params: IntPtr)>(GetHistogramParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameteriv(target: glHistogramTarget; pname: glGetHistogramParameterPName; var &params: Int32) :=
      ntv_GetHistogramParameteriv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameteriv(target: glHistogramTarget; pname: glGetHistogramParameterPName; &params: IntPtr) :=
      ntv_GetHistogramParameteriv_2(target, pname, &params);
    
    private GetMinmax_adr := GetProcAddress('glGetMinmax');
    private ntv_GetMinmax_1 := GetProcOrNil&<procedure(target: glMinmaxTarget; reset: glBool8; format: glPixelFormat; &type: glPixelType; values: IntPtr)>(GetMinmax_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmax(target: glMinmaxTarget; reset: glBool8; format: glPixelFormat; &type: glPixelType; values: IntPtr) :=
      ntv_GetMinmax_1(target, reset, format, &type, values);
    
    private GetMinmaxParameterfv_adr := GetProcAddress('glGetMinmaxParameterfv');
    private ntv_GetMinmaxParameterfv_1 := GetProcOrNil&<procedure(target: glMinmaxTarget; pname: glGetMinmaxParameterPName; var &params: single)>(GetMinmaxParameterfv_adr);
    private ntv_GetMinmaxParameterfv_2 := GetProcOrNil&<procedure(target: glMinmaxTarget; pname: glGetMinmaxParameterPName; &params: IntPtr)>(GetMinmaxParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterfv(target: glMinmaxTarget; pname: glGetMinmaxParameterPName; var &params: single) :=
      ntv_GetMinmaxParameterfv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterfv(target: glMinmaxTarget; pname: glGetMinmaxParameterPName; &params: IntPtr) :=
      ntv_GetMinmaxParameterfv_2(target, pname, &params);
    
    private GetMinmaxParameteriv_adr := GetProcAddress('glGetMinmaxParameteriv');
    private ntv_GetMinmaxParameteriv_1 := GetProcOrNil&<procedure(target: glMinmaxTarget; pname: glGetMinmaxParameterPName; var &params: Int32)>(GetMinmaxParameteriv_adr);
    private ntv_GetMinmaxParameteriv_2 := GetProcOrNil&<procedure(target: glMinmaxTarget; pname: glGetMinmaxParameterPName; &params: IntPtr)>(GetMinmaxParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameteriv(target: glMinmaxTarget; pname: glGetMinmaxParameterPName; var &params: Int32) :=
      ntv_GetMinmaxParameteriv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameteriv(target: glMinmaxTarget; pname: glGetMinmaxParameterPName; &params: IntPtr) :=
      ntv_GetMinmaxParameteriv_2(target, pname, &params);
    
    private Histogram_adr := GetProcAddress('glHistogram');
    private ntv_Histogram_1 := GetProcOrNil&<procedure(target: glHistogramTarget; width: Int32; internalformat: glInternalFormat; sink: glBool8)>(Histogram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Histogram(target: glHistogramTarget; width: Int32; internalformat: glInternalFormat; sink: glBool8) :=
      ntv_Histogram_1(target, width, internalformat, sink);
    
    private Minmax_adr := GetProcAddress('glMinmax');
    private ntv_Minmax_1 := GetProcOrNil&<procedure(target: glMinmaxTarget; internalformat: glInternalFormat; sink: glBool8)>(Minmax_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Minmax(target: glMinmaxTarget; internalformat: glInternalFormat; sink: glBool8) :=
      ntv_Minmax_1(target, internalformat, sink);
    
    private ResetHistogram_adr := GetProcAddress('glResetHistogram');
    private ntv_ResetHistogram_1 := GetProcOrNil&<procedure(target: glHistogramTarget)>(ResetHistogram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetHistogram(target: glHistogramTarget) :=
      ntv_ResetHistogram_1(target);
    
    private ResetMinmax_adr := GetProcAddress('glResetMinmax');
    private ntv_ResetMinmax_1 := GetProcOrNil&<procedure(target: glMinmaxTarget)>(ResetMinmax_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetMinmax(target: glMinmaxTarget) :=
      ntv_ResetMinmax_1(target);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glIndirectParametersARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_indirect_parameters';
    
    private MultiDrawArraysIndirectCountARB_adr := GetProcAddress('glMultiDrawArraysIndirectCountARB');
    private ntv_MultiDrawArraysIndirectCountARB_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32)>(MultiDrawArraysIndirectCountARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectCountARB(mode: glPrimitiveType; indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) :=
      ntv_MultiDrawArraysIndirectCountARB_1(mode, indirect, drawcount, maxdrawcount, stride);
    
    private MultiDrawElementsIndirectCountARB_adr := GetProcAddress('glMultiDrawElementsIndirectCountARB');
    private ntv_MultiDrawElementsIndirectCountARB_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32)>(MultiDrawElementsIndirectCountARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectCountARB(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) :=
      ntv_MultiDrawElementsIndirectCountARB_1(mode, &type, indirect, drawcount, maxdrawcount, stride);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glInstancedArraysARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_instanced_arrays';
    
    private VertexAttribDivisorARB_adr := GetProcAddress('glVertexAttribDivisorARB');
    private ntv_VertexAttribDivisorARB_1 := GetProcOrNil&<procedure(index: UInt32; divisor: UInt32)>(VertexAttribDivisorARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribDivisorARB(index: UInt32; divisor: UInt32) :=
      ntv_VertexAttribDivisorARB_1(index, divisor);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glInternalformatQueryARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_internalformat_query';
    
    private GetInternalformativ_adr := GetProcAddress('glGetInternalformativ');
    private ntv_GetInternalformativ_1 := GetProcOrNil&<procedure(target: glTextureTarget; internalformat: glInternalFormat; pname: glInternalFormatPName; count: Int32; var &params: Int32)>(GetInternalformativ_adr);
    private ntv_GetInternalformativ_2 := GetProcOrNil&<procedure(target: glTextureTarget; internalformat: glInternalFormat; pname: glInternalFormatPName; count: Int32; &params: IntPtr)>(GetInternalformativ_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformativ(target: glTextureTarget; internalformat: glInternalFormat; pname: glInternalFormatPName; count: Int32; var &params: Int32) :=
      ntv_GetInternalformativ_1(target, internalformat, pname, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformativ(target: glTextureTarget; internalformat: glInternalFormat; pname: glInternalFormatPName; count: Int32; &params: IntPtr) :=
      ntv_GetInternalformativ_2(target, internalformat, pname, count, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glInternalformatQuery2ARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_internalformat_query2';
    
    private GetInternalformati64v_adr := GetProcAddress('glGetInternalformati64v');
    private ntv_GetInternalformati64v_1 := GetProcOrNil&<procedure(target: glTextureTarget; internalformat: glInternalFormat; pname: glInternalFormatPName; count: Int32; var &params: Int64)>(GetInternalformati64v_adr);
    private ntv_GetInternalformati64v_2 := GetProcOrNil&<procedure(target: glTextureTarget; internalformat: glInternalFormat; pname: glInternalFormatPName; count: Int32; &params: IntPtr)>(GetInternalformati64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformati64v(target: glTextureTarget; internalformat: glInternalFormat; pname: glInternalFormatPName; count: Int32; var &params: Int64) :=
      ntv_GetInternalformati64v_1(target, internalformat, pname, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformati64v(target: glTextureTarget; internalformat: glInternalFormat; pname: glInternalFormatPName; count: Int32; &params: IntPtr) :=
      ntv_GetInternalformati64v_2(target, internalformat, pname, count, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glInvalidateSubdataARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_invalidate_subdata';
    
    private InvalidateTexSubImage_adr := GetProcAddress('glInvalidateTexSubImage');
    private ntv_InvalidateTexSubImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32)>(InvalidateTexSubImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateTexSubImage(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32) :=
      ntv_InvalidateTexSubImage_1(texture, level, xoffset, yoffset, zoffset, width, height, depth);
    
    private InvalidateTexImage_adr := GetProcAddress('glInvalidateTexImage');
    private ntv_InvalidateTexImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32)>(InvalidateTexImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateTexImage(texture: gl_texture; level: Int32) :=
      ntv_InvalidateTexImage_1(texture, level);
    
    private InvalidateBufferSubData_adr := GetProcAddress('glInvalidateBufferSubData');
    private ntv_InvalidateBufferSubData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; length: UIntPtr)>(InvalidateBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateBufferSubData(buffer: gl_buffer; offset: IntPtr; length: UIntPtr) :=
      ntv_InvalidateBufferSubData_1(buffer, offset, length);
    
    private InvalidateBufferData_adr := GetProcAddress('glInvalidateBufferData');
    private ntv_InvalidateBufferData_1 := GetProcOrNil&<procedure(buffer: gl_buffer)>(InvalidateBufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateBufferData(buffer: gl_buffer) :=
      ntv_InvalidateBufferData_1(buffer);
    
    private InvalidateFramebuffer_adr := GetProcAddress('glInvalidateFramebuffer');
    private ntv_InvalidateFramebuffer_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; numAttachments: Int32; var attachments: glInvalidateFramebufferAttachment)>(InvalidateFramebuffer_adr);
    private ntv_InvalidateFramebuffer_2 := GetProcOrNil&<procedure(target: glFramebufferTarget; numAttachments: Int32; attachments: IntPtr)>(InvalidateFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateFramebuffer(target: glFramebufferTarget; numAttachments: Int32; attachments: array of glInvalidateFramebufferAttachment);
    type PGlInvalidateFramebufferAttachment = ^glInvalidateFramebufferAttachment;
    begin
      if (attachments<>nil) and (attachments.Length<>0) then
        ntv_InvalidateFramebuffer_1(target, numAttachments, attachments[0]) else
        ntv_InvalidateFramebuffer_1(target, numAttachments, PGlInvalidateFramebufferAttachment(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateFramebuffer(target: glFramebufferTarget; numAttachments: Int32; var attachments: glInvalidateFramebufferAttachment) :=
      ntv_InvalidateFramebuffer_1(target, numAttachments, attachments);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateFramebuffer(target: glFramebufferTarget; numAttachments: Int32; attachments: IntPtr) :=
      ntv_InvalidateFramebuffer_2(target, numAttachments, attachments);
    
    private InvalidateSubFramebuffer_adr := GetProcAddress('glInvalidateSubFramebuffer');
    private ntv_InvalidateSubFramebuffer_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; numAttachments: Int32; var attachments: glInvalidateFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32)>(InvalidateSubFramebuffer_adr);
    private ntv_InvalidateSubFramebuffer_2 := GetProcOrNil&<procedure(target: glFramebufferTarget; numAttachments: Int32; attachments: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32)>(InvalidateSubFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateSubFramebuffer(target: glFramebufferTarget; numAttachments: Int32; attachments: array of glInvalidateFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32);
    type PGlInvalidateFramebufferAttachment = ^glInvalidateFramebufferAttachment;
    begin
      if (attachments<>nil) and (attachments.Length<>0) then
        ntv_InvalidateSubFramebuffer_1(target, numAttachments, attachments[0], x, y, width, height) else
        ntv_InvalidateSubFramebuffer_1(target, numAttachments, PGlInvalidateFramebufferAttachment(nil)^, x, y, width, height);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateSubFramebuffer(target: glFramebufferTarget; numAttachments: Int32; var attachments: glInvalidateFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_InvalidateSubFramebuffer_1(target, numAttachments, attachments, x, y, width, height);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateSubFramebuffer(target: glFramebufferTarget; numAttachments: Int32; attachments: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_InvalidateSubFramebuffer_2(target, numAttachments, attachments, x, y, width, height);
    
  end;
  
  ///
  glMapBufferAlignmentARB = static class
    public const _ExtStr = 'GL_ARB_map_buffer_alignment';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMapBufferRangeARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_map_buffer_range';
    
    private MapBufferRange_adr := GetProcAddress('glMapBufferRange');
    private ntv_MapBufferRange_1 := GetProcOrNil&<function(target: glBufferTarget; offset: IntPtr; length: UIntPtr; access: glMapBufferAccessMask): IntPtr>(MapBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapBufferRange(target: glBufferTarget; offset: IntPtr; length: UIntPtr; access: glMapBufferAccessMask): IntPtr :=
      ntv_MapBufferRange_1(target, offset, length, access);
    
    private FlushMappedBufferRange_adr := GetProcAddress('glFlushMappedBufferRange');
    private ntv_FlushMappedBufferRange_1 := GetProcOrNil&<procedure(target: glBufferTarget; offset: IntPtr; length: UIntPtr)>(FlushMappedBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushMappedBufferRange(target: glBufferTarget; offset: IntPtr; length: UIntPtr) :=
      ntv_FlushMappedBufferRange_1(target, offset, length);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMatrixPaletteARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_matrix_palette';
    
    private CurrentPaletteMatrixARB_adr := GetProcAddress('glCurrentPaletteMatrixARB');
    private ntv_CurrentPaletteMatrixARB_1 := GetProcOrNil&<procedure(index: Int32)>(CurrentPaletteMatrixARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CurrentPaletteMatrixARB(index: Int32) :=
      ntv_CurrentPaletteMatrixARB_1(index);
    
    private MatrixIndexubvARB_adr := GetProcAddress('glMatrixIndexubvARB');
    private ntv_MatrixIndexubvARB_1 := GetProcOrNil&<procedure(size: Int32; var indices: Byte)>(MatrixIndexubvARB_adr);
    private ntv_MatrixIndexubvARB_2 := GetProcOrNil&<procedure(size: Int32; indices: IntPtr)>(MatrixIndexubvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexubvARB(size: Int32; indices: array of Byte);
    type PByte = ^Byte;
    begin
      if (indices<>nil) and (indices.Length<>0) then
        ntv_MatrixIndexubvARB_1(size, indices[0]) else
        ntv_MatrixIndexubvARB_1(size, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexubvARB(size: Int32; var indices: Byte) :=
      ntv_MatrixIndexubvARB_1(size, indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexubvARB(size: Int32; indices: IntPtr) :=
      ntv_MatrixIndexubvARB_2(size, indices);
    
    private MatrixIndexusvARB_adr := GetProcAddress('glMatrixIndexusvARB');
    private ntv_MatrixIndexusvARB_1 := GetProcOrNil&<procedure(size: Int32; var indices: UInt16)>(MatrixIndexusvARB_adr);
    private ntv_MatrixIndexusvARB_2 := GetProcOrNil&<procedure(size: Int32; indices: IntPtr)>(MatrixIndexusvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexusvARB(size: Int32; indices: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (indices<>nil) and (indices.Length<>0) then
        ntv_MatrixIndexusvARB_1(size, indices[0]) else
        ntv_MatrixIndexusvARB_1(size, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexusvARB(size: Int32; var indices: UInt16) :=
      ntv_MatrixIndexusvARB_1(size, indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexusvARB(size: Int32; indices: IntPtr) :=
      ntv_MatrixIndexusvARB_2(size, indices);
    
    private MatrixIndexuivARB_adr := GetProcAddress('glMatrixIndexuivARB');
    private ntv_MatrixIndexuivARB_1 := GetProcOrNil&<procedure(size: Int32; var indices: UInt32)>(MatrixIndexuivARB_adr);
    private ntv_MatrixIndexuivARB_2 := GetProcOrNil&<procedure(size: Int32; indices: IntPtr)>(MatrixIndexuivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexuivARB(size: Int32; indices: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (indices<>nil) and (indices.Length<>0) then
        ntv_MatrixIndexuivARB_1(size, indices[0]) else
        ntv_MatrixIndexuivARB_1(size, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexuivARB(size: Int32; var indices: UInt32) :=
      ntv_MatrixIndexuivARB_1(size, indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexuivARB(size: Int32; indices: IntPtr) :=
      ntv_MatrixIndexuivARB_2(size, indices);
    
    private MatrixIndexPointerARB_adr := GetProcAddress('glMatrixIndexPointerARB');
    private ntv_MatrixIndexPointerARB_1 := GetProcOrNil&<procedure(size: Int32; &type: glMatrixIndexPointerType; stride: Int32; pointer: IntPtr)>(MatrixIndexPointerARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexPointerARB(size: Int32; &type: glMatrixIndexPointerType; stride: Int32; pointer: IntPtr) :=
      ntv_MatrixIndexPointerARB_1(size, &type, stride, pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMultiBindARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_multi_bind';
    
    private BindBuffersBase_adr := GetProcAddress('glBindBuffersBase');
    private ntv_BindBuffersBase_1 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer)>(BindBuffersBase_adr);
    private ntv_BindBuffersBase_2 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr)>(BindBuffersBase_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersBase(target: glBufferTarget; first: UInt32; count: Int32; buffers: array of gl_buffer);
    type PGl_buffer = ^gl_buffer;
    begin
      if (buffers<>nil) and (buffers.Length<>0) then
        ntv_BindBuffersBase_1(target, first, count, buffers[0]) else
        ntv_BindBuffersBase_1(target, first, count, PGl_buffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersBase(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer) :=
      ntv_BindBuffersBase_1(target, first, count, buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersBase(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr) :=
      ntv_BindBuffersBase_2(target, first, count, buffers);
    
    private BindBuffersRange_adr := GetProcAddress('glBindBuffersRange');
    private ntv_BindBuffersRange_1 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var sizes: UIntPtr)>(BindBuffersRange_adr);
    private ntv_BindBuffersRange_2 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; sizes: IntPtr)>(BindBuffersRange_adr);
    private ntv_BindBuffersRange_3 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var sizes: UIntPtr)>(BindBuffersRange_adr);
    private ntv_BindBuffersRange_4 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; sizes: IntPtr)>(BindBuffersRange_adr);
    private ntv_BindBuffersRange_5 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var sizes: UIntPtr)>(BindBuffersRange_adr);
    private ntv_BindBuffersRange_6 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; sizes: IntPtr)>(BindBuffersRange_adr);
    private ntv_BindBuffersRange_7 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var sizes: UIntPtr)>(BindBuffersRange_adr);
    private ntv_BindBuffersRange_8 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; sizes: IntPtr)>(BindBuffersRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; buffers: array of gl_buffer; offsets: array of IntPtr; sizes: array of UIntPtr);
    type PGl_buffer = ^gl_buffer;
    type PIntPtr = ^IntPtr;
    type PUIntPtr = ^UIntPtr;
    begin
      if (sizes<>nil) and (sizes.Length<>0) then
        if (buffers<>nil) and (buffers.Length<>0) then
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_BindBuffersRange_1(target, first, count, buffers[0], offsets[0], sizes[0]) else
            ntv_BindBuffersRange_1(target, first, count, buffers[0], PIntPtr(nil)^, sizes[0]) else
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_BindBuffersRange_1(target, first, count, PGl_buffer(nil)^, offsets[0], sizes[0]) else
            ntv_BindBuffersRange_1(target, first, count, PGl_buffer(nil)^, PIntPtr(nil)^, sizes[0]) else
        if (buffers<>nil) and (buffers.Length<>0) then
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_BindBuffersRange_1(target, first, count, buffers[0], offsets[0], PUIntPtr(nil)^) else
            ntv_BindBuffersRange_1(target, first, count, buffers[0], PIntPtr(nil)^, PUIntPtr(nil)^) else
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_BindBuffersRange_1(target, first, count, PGl_buffer(nil)^, offsets[0], PUIntPtr(nil)^) else
            ntv_BindBuffersRange_1(target, first, count, PGl_buffer(nil)^, PIntPtr(nil)^, PUIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var sizes: UIntPtr) :=
      ntv_BindBuffersRange_1(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; sizes: IntPtr) :=
      ntv_BindBuffersRange_2(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var sizes: UIntPtr) :=
      ntv_BindBuffersRange_3(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; sizes: IntPtr) :=
      ntv_BindBuffersRange_4(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var sizes: UIntPtr) :=
      ntv_BindBuffersRange_5(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; sizes: IntPtr) :=
      ntv_BindBuffersRange_6(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var sizes: UIntPtr) :=
      ntv_BindBuffersRange_7(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; sizes: IntPtr) :=
      ntv_BindBuffersRange_8(target, first, count, buffers, offsets, sizes);
    
    private BindTextures_adr := GetProcAddress('glBindTextures');
    private ntv_BindTextures_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var textures: gl_texture)>(BindTextures_adr);
    private ntv_BindTextures_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; textures: IntPtr)>(BindTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextures(first: UInt32; count: Int32; textures: array of gl_texture);
    type PGl_texture = ^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        ntv_BindTextures_1(first, count, textures[0]) else
        ntv_BindTextures_1(first, count, PGl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextures(first: UInt32; count: Int32; var textures: gl_texture) :=
      ntv_BindTextures_1(first, count, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextures(first: UInt32; count: Int32; textures: IntPtr) :=
      ntv_BindTextures_2(first, count, textures);
    
    private BindSamplers_adr := GetProcAddress('glBindSamplers');
    private ntv_BindSamplers_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var samplers: gl_sampler)>(BindSamplers_adr);
    private ntv_BindSamplers_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; samplers: IntPtr)>(BindSamplers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSamplers(first: UInt32; count: Int32; samplers: array of gl_sampler);
    type PGl_sampler = ^gl_sampler;
    begin
      if (samplers<>nil) and (samplers.Length<>0) then
        ntv_BindSamplers_1(first, count, samplers[0]) else
        ntv_BindSamplers_1(first, count, PGl_sampler(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSamplers(first: UInt32; count: Int32; var samplers: gl_sampler) :=
      ntv_BindSamplers_1(first, count, samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSamplers(first: UInt32; count: Int32; samplers: IntPtr) :=
      ntv_BindSamplers_2(first, count, samplers);
    
    private BindImageTextures_adr := GetProcAddress('glBindImageTextures');
    private ntv_BindImageTextures_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var textures: gl_texture)>(BindImageTextures_adr);
    private ntv_BindImageTextures_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; textures: IntPtr)>(BindImageTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextures(first: UInt32; count: Int32; textures: array of gl_texture);
    type PGl_texture = ^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        ntv_BindImageTextures_1(first, count, textures[0]) else
        ntv_BindImageTextures_1(first, count, PGl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextures(first: UInt32; count: Int32; var textures: gl_texture) :=
      ntv_BindImageTextures_1(first, count, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextures(first: UInt32; count: Int32; textures: IntPtr) :=
      ntv_BindImageTextures_2(first, count, textures);
    
    private BindVertexBuffers_adr := GetProcAddress('glBindVertexBuffers');
    private ntv_BindVertexBuffers_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var strides: Int32)>(BindVertexBuffers_adr);
    private ntv_BindVertexBuffers_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; strides: IntPtr)>(BindVertexBuffers_adr);
    private ntv_BindVertexBuffers_3 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var strides: Int32)>(BindVertexBuffers_adr);
    private ntv_BindVertexBuffers_4 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; strides: IntPtr)>(BindVertexBuffers_adr);
    private ntv_BindVertexBuffers_5 := GetProcOrNil&<procedure(first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var strides: Int32)>(BindVertexBuffers_adr);
    private ntv_BindVertexBuffers_6 := GetProcOrNil&<procedure(first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; strides: IntPtr)>(BindVertexBuffers_adr);
    private ntv_BindVertexBuffers_7 := GetProcOrNil&<procedure(first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var strides: Int32)>(BindVertexBuffers_adr);
    private ntv_BindVertexBuffers_8 := GetProcOrNil&<procedure(first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; strides: IntPtr)>(BindVertexBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: array of gl_buffer; offsets: array of IntPtr; strides: array of Int32);
    type PGl_buffer = ^gl_buffer;
    type PIntPtr = ^IntPtr;
    type PInt32 = ^Int32;
    begin
      if (strides<>nil) and (strides.Length<>0) then
        if (buffers<>nil) and (buffers.Length<>0) then
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_BindVertexBuffers_1(first, count, buffers[0], offsets[0], strides[0]) else
            ntv_BindVertexBuffers_1(first, count, buffers[0], PIntPtr(nil)^, strides[0]) else
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_BindVertexBuffers_1(first, count, PGl_buffer(nil)^, offsets[0], strides[0]) else
            ntv_BindVertexBuffers_1(first, count, PGl_buffer(nil)^, PIntPtr(nil)^, strides[0]) else
        if (buffers<>nil) and (buffers.Length<>0) then
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_BindVertexBuffers_1(first, count, buffers[0], offsets[0], PInt32(nil)^) else
            ntv_BindVertexBuffers_1(first, count, buffers[0], PIntPtr(nil)^, PInt32(nil)^) else
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_BindVertexBuffers_1(first, count, PGl_buffer(nil)^, offsets[0], PInt32(nil)^) else
            ntv_BindVertexBuffers_1(first, count, PGl_buffer(nil)^, PIntPtr(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var strides: Int32) :=
      ntv_BindVertexBuffers_1(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; strides: IntPtr) :=
      ntv_BindVertexBuffers_2(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var strides: Int32) :=
      ntv_BindVertexBuffers_3(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; strides: IntPtr) :=
      ntv_BindVertexBuffers_4(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var strides: Int32) :=
      ntv_BindVertexBuffers_5(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; strides: IntPtr) :=
      ntv_BindVertexBuffers_6(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var strides: Int32) :=
      ntv_BindVertexBuffers_7(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; strides: IntPtr) :=
      ntv_BindVertexBuffers_8(first, count, buffers, offsets, strides);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMultiDrawIndirectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_multi_draw_indirect';
    
    private MultiDrawArraysIndirect_adr := GetProcAddress('glMultiDrawArraysIndirect');
    private ntv_MultiDrawArraysIndirect_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; indirect: IntPtr; drawcount: Int32; stride: Int32)>(MultiDrawArraysIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirect(mode: glPrimitiveType; indirect: IntPtr; drawcount: Int32; stride: Int32) :=
      ntv_MultiDrawArraysIndirect_1(mode, indirect, drawcount, stride);
    
    private MultiDrawElementsIndirect_adr := GetProcAddress('glMultiDrawElementsIndirect');
    private ntv_MultiDrawElementsIndirect_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr; drawcount: Int32; stride: Int32)>(MultiDrawElementsIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirect(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr; drawcount: Int32; stride: Int32) :=
      ntv_MultiDrawElementsIndirect_1(mode, &type, indirect, drawcount, stride);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMultisampleARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_multisample';
    
    private SampleCoverageARB_adr := GetProcAddress('glSampleCoverageARB');
    private ntv_SampleCoverageARB_1 := GetProcOrNil&<procedure(value: single; invert: glBool8)>(SampleCoverageARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleCoverageARB(value: single; invert: glBool8) :=
      ntv_SampleCoverageARB_1(value, invert);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMultitextureARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_multitexture';
    
    private ActiveTextureARB_adr := GetProcAddress('glActiveTextureARB');
    private ntv_ActiveTextureARB_1 := GetProcOrNil&<procedure(texture: glTextureUnit)>(ActiveTextureARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveTextureARB(texture: glTextureUnit) :=
      ntv_ActiveTextureARB_1(texture);
    
    private ClientActiveTextureARB_adr := GetProcAddress('glClientActiveTextureARB');
    private ntv_ClientActiveTextureARB_1 := GetProcOrNil&<procedure(texture: glTextureUnit)>(ClientActiveTextureARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientActiveTextureARB(texture: glTextureUnit) :=
      ntv_ClientActiveTextureARB_1(texture);
    
    private MultiTexCoord1dARB_adr := GetProcAddress('glMultiTexCoord1dARB');
    private ntv_MultiTexCoord1dARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: double)>(MultiTexCoord1dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dARB(target: glTextureUnit; s: double) :=
      ntv_MultiTexCoord1dARB_1(target, s);
    
    private MultiTexCoord1dvARB_adr := GetProcAddress('glMultiTexCoord1dvARB');
    private ntv_MultiTexCoord1dvARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: double)>(MultiTexCoord1dvARB_adr);
    private ntv_MultiTexCoord1dvARB_2 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord1dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dvARB(target: glTextureUnit; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord1dvARB_1(target, v[0]) else
        ntv_MultiTexCoord1dvARB_1(target, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dvARB(target: glTextureUnit; var v: double) :=
      ntv_MultiTexCoord1dvARB_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dvARB(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord1dvARB_2(target, v);
    
    private MultiTexCoord1fARB_adr := GetProcAddress('glMultiTexCoord1fARB');
    private ntv_MultiTexCoord1fARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: single)>(MultiTexCoord1fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fARB(target: glTextureUnit; s: single) :=
      ntv_MultiTexCoord1fARB_1(target, s);
    
    private MultiTexCoord1fvARB_adr := GetProcAddress('glMultiTexCoord1fvARB');
    private ntv_MultiTexCoord1fvARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: single)>(MultiTexCoord1fvARB_adr);
    private ntv_MultiTexCoord1fvARB_2 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord1fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fvARB(target: glTextureUnit; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord1fvARB_1(target, v[0]) else
        ntv_MultiTexCoord1fvARB_1(target, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fvARB(target: glTextureUnit; var v: single) :=
      ntv_MultiTexCoord1fvARB_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fvARB(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord1fvARB_2(target, v);
    
    private MultiTexCoord1iARB_adr := GetProcAddress('glMultiTexCoord1iARB');
    private ntv_MultiTexCoord1iARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: Int32)>(MultiTexCoord1iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1iARB(target: glTextureUnit; s: Int32) :=
      ntv_MultiTexCoord1iARB_1(target, s);
    
    private MultiTexCoord1ivARB_adr := GetProcAddress('glMultiTexCoord1ivARB');
    private ntv_MultiTexCoord1ivARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Int32)>(MultiTexCoord1ivARB_adr);
    private ntv_MultiTexCoord1ivARB_2 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord1ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1ivARB(target: glTextureUnit; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord1ivARB_1(target, v[0]) else
        ntv_MultiTexCoord1ivARB_1(target, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1ivARB(target: glTextureUnit; var v: Int32) :=
      ntv_MultiTexCoord1ivARB_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1ivARB(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord1ivARB_2(target, v);
    
    private MultiTexCoord1sARB_adr := GetProcAddress('glMultiTexCoord1sARB');
    private ntv_MultiTexCoord1sARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: Int16)>(MultiTexCoord1sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1sARB(target: glTextureUnit; s: Int16) :=
      ntv_MultiTexCoord1sARB_1(target, s);
    
    private MultiTexCoord1svARB_adr := GetProcAddress('glMultiTexCoord1svARB');
    private ntv_MultiTexCoord1svARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Int16)>(MultiTexCoord1svARB_adr);
    private ntv_MultiTexCoord1svARB_2 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord1svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1svARB(target: glTextureUnit; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord1svARB_1(target, v[0]) else
        ntv_MultiTexCoord1svARB_1(target, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1svARB(target: glTextureUnit; var v: Int16) :=
      ntv_MultiTexCoord1svARB_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1svARB(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord1svARB_2(target, v);
    
    private MultiTexCoord2dARB_adr := GetProcAddress('glMultiTexCoord2dARB');
    private ntv_MultiTexCoord2dARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: double; t: double)>(MultiTexCoord2dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dARB(target: glTextureUnit; s: double; t: double) :=
      ntv_MultiTexCoord2dARB_1(target, s, t);
    
    private MultiTexCoord2dvARB_adr := GetProcAddress('glMultiTexCoord2dvARB');
    private ntv_MultiTexCoord2dvARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: double)>(MultiTexCoord2dvARB_adr);
    private ntv_MultiTexCoord2dvARB_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec2d)>(MultiTexCoord2dvARB_adr);
    private ntv_MultiTexCoord2dvARB_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord2dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dvARB(target: glTextureUnit; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord2dvARB_1(target, v[0]) else
        ntv_MultiTexCoord2dvARB_1(target, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dvARB(target: glTextureUnit; var v: Vec2d) :=
      ntv_MultiTexCoord2dvARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dvARB(target: glTextureUnit; var v: double) :=
      ntv_MultiTexCoord2dvARB_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dvARB(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord2dvARB_3(target, v);
    
    private MultiTexCoord2fARB_adr := GetProcAddress('glMultiTexCoord2fARB');
    private ntv_MultiTexCoord2fARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: single; t: single)>(MultiTexCoord2fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fARB(target: glTextureUnit; s: single; t: single) :=
      ntv_MultiTexCoord2fARB_1(target, s, t);
    
    private MultiTexCoord2fvARB_adr := GetProcAddress('glMultiTexCoord2fvARB');
    private ntv_MultiTexCoord2fvARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: single)>(MultiTexCoord2fvARB_adr);
    private ntv_MultiTexCoord2fvARB_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec2f)>(MultiTexCoord2fvARB_adr);
    private ntv_MultiTexCoord2fvARB_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord2fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fvARB(target: glTextureUnit; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord2fvARB_1(target, v[0]) else
        ntv_MultiTexCoord2fvARB_1(target, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fvARB(target: glTextureUnit; var v: Vec2f) :=
      ntv_MultiTexCoord2fvARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fvARB(target: glTextureUnit; var v: single) :=
      ntv_MultiTexCoord2fvARB_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fvARB(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord2fvARB_3(target, v);
    
    private MultiTexCoord2iARB_adr := GetProcAddress('glMultiTexCoord2iARB');
    private ntv_MultiTexCoord2iARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: Int32; t: Int32)>(MultiTexCoord2iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2iARB(target: glTextureUnit; s: Int32; t: Int32) :=
      ntv_MultiTexCoord2iARB_1(target, s, t);
    
    private MultiTexCoord2ivARB_adr := GetProcAddress('glMultiTexCoord2ivARB');
    private ntv_MultiTexCoord2ivARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Int32)>(MultiTexCoord2ivARB_adr);
    private ntv_MultiTexCoord2ivARB_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec2i)>(MultiTexCoord2ivARB_adr);
    private ntv_MultiTexCoord2ivARB_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord2ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2ivARB(target: glTextureUnit; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord2ivARB_1(target, v[0]) else
        ntv_MultiTexCoord2ivARB_1(target, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2ivARB(target: glTextureUnit; var v: Vec2i) :=
      ntv_MultiTexCoord2ivARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2ivARB(target: glTextureUnit; var v: Int32) :=
      ntv_MultiTexCoord2ivARB_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2ivARB(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord2ivARB_3(target, v);
    
    private MultiTexCoord2sARB_adr := GetProcAddress('glMultiTexCoord2sARB');
    private ntv_MultiTexCoord2sARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: Int16; t: Int16)>(MultiTexCoord2sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2sARB(target: glTextureUnit; s: Int16; t: Int16) :=
      ntv_MultiTexCoord2sARB_1(target, s, t);
    
    private MultiTexCoord2svARB_adr := GetProcAddress('glMultiTexCoord2svARB');
    private ntv_MultiTexCoord2svARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Int16)>(MultiTexCoord2svARB_adr);
    private ntv_MultiTexCoord2svARB_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec2s)>(MultiTexCoord2svARB_adr);
    private ntv_MultiTexCoord2svARB_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord2svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2svARB(target: glTextureUnit; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord2svARB_1(target, v[0]) else
        ntv_MultiTexCoord2svARB_1(target, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2svARB(target: glTextureUnit; var v: Vec2s) :=
      ntv_MultiTexCoord2svARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2svARB(target: glTextureUnit; var v: Int16) :=
      ntv_MultiTexCoord2svARB_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2svARB(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord2svARB_3(target, v);
    
    private MultiTexCoord3dARB_adr := GetProcAddress('glMultiTexCoord3dARB');
    private ntv_MultiTexCoord3dARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: double; t: double; r: double)>(MultiTexCoord3dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dARB(target: glTextureUnit; s: double; t: double; r: double) :=
      ntv_MultiTexCoord3dARB_1(target, s, t, r);
    
    private MultiTexCoord3dvARB_adr := GetProcAddress('glMultiTexCoord3dvARB');
    private ntv_MultiTexCoord3dvARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: double)>(MultiTexCoord3dvARB_adr);
    private ntv_MultiTexCoord3dvARB_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec3d)>(MultiTexCoord3dvARB_adr);
    private ntv_MultiTexCoord3dvARB_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord3dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dvARB(target: glTextureUnit; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord3dvARB_1(target, v[0]) else
        ntv_MultiTexCoord3dvARB_1(target, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dvARB(target: glTextureUnit; var v: Vec3d) :=
      ntv_MultiTexCoord3dvARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dvARB(target: glTextureUnit; var v: double) :=
      ntv_MultiTexCoord3dvARB_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dvARB(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord3dvARB_3(target, v);
    
    private MultiTexCoord3fARB_adr := GetProcAddress('glMultiTexCoord3fARB');
    private ntv_MultiTexCoord3fARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: single; t: single; r: single)>(MultiTexCoord3fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fARB(target: glTextureUnit; s: single; t: single; r: single) :=
      ntv_MultiTexCoord3fARB_1(target, s, t, r);
    
    private MultiTexCoord3fvARB_adr := GetProcAddress('glMultiTexCoord3fvARB');
    private ntv_MultiTexCoord3fvARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: single)>(MultiTexCoord3fvARB_adr);
    private ntv_MultiTexCoord3fvARB_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec3f)>(MultiTexCoord3fvARB_adr);
    private ntv_MultiTexCoord3fvARB_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord3fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fvARB(target: glTextureUnit; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord3fvARB_1(target, v[0]) else
        ntv_MultiTexCoord3fvARB_1(target, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fvARB(target: glTextureUnit; var v: Vec3f) :=
      ntv_MultiTexCoord3fvARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fvARB(target: glTextureUnit; var v: single) :=
      ntv_MultiTexCoord3fvARB_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fvARB(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord3fvARB_3(target, v);
    
    private MultiTexCoord3iARB_adr := GetProcAddress('glMultiTexCoord3iARB');
    private ntv_MultiTexCoord3iARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: Int32; t: Int32; r: Int32)>(MultiTexCoord3iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3iARB(target: glTextureUnit; s: Int32; t: Int32; r: Int32) :=
      ntv_MultiTexCoord3iARB_1(target, s, t, r);
    
    private MultiTexCoord3ivARB_adr := GetProcAddress('glMultiTexCoord3ivARB');
    private ntv_MultiTexCoord3ivARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Int32)>(MultiTexCoord3ivARB_adr);
    private ntv_MultiTexCoord3ivARB_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec3i)>(MultiTexCoord3ivARB_adr);
    private ntv_MultiTexCoord3ivARB_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord3ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3ivARB(target: glTextureUnit; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord3ivARB_1(target, v[0]) else
        ntv_MultiTexCoord3ivARB_1(target, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3ivARB(target: glTextureUnit; var v: Vec3i) :=
      ntv_MultiTexCoord3ivARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3ivARB(target: glTextureUnit; var v: Int32) :=
      ntv_MultiTexCoord3ivARB_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3ivARB(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord3ivARB_3(target, v);
    
    private MultiTexCoord3sARB_adr := GetProcAddress('glMultiTexCoord3sARB');
    private ntv_MultiTexCoord3sARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: Int16; t: Int16; r: Int16)>(MultiTexCoord3sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3sARB(target: glTextureUnit; s: Int16; t: Int16; r: Int16) :=
      ntv_MultiTexCoord3sARB_1(target, s, t, r);
    
    private MultiTexCoord3svARB_adr := GetProcAddress('glMultiTexCoord3svARB');
    private ntv_MultiTexCoord3svARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Int16)>(MultiTexCoord3svARB_adr);
    private ntv_MultiTexCoord3svARB_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec3s)>(MultiTexCoord3svARB_adr);
    private ntv_MultiTexCoord3svARB_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord3svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3svARB(target: glTextureUnit; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord3svARB_1(target, v[0]) else
        ntv_MultiTexCoord3svARB_1(target, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3svARB(target: glTextureUnit; var v: Vec3s) :=
      ntv_MultiTexCoord3svARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3svARB(target: glTextureUnit; var v: Int16) :=
      ntv_MultiTexCoord3svARB_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3svARB(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord3svARB_3(target, v);
    
    private MultiTexCoord4dARB_adr := GetProcAddress('glMultiTexCoord4dARB');
    private ntv_MultiTexCoord4dARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: double; t: double; r: double; q: double)>(MultiTexCoord4dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dARB(target: glTextureUnit; s: double; t: double; r: double; q: double) :=
      ntv_MultiTexCoord4dARB_1(target, s, t, r, q);
    
    private MultiTexCoord4dvARB_adr := GetProcAddress('glMultiTexCoord4dvARB');
    private ntv_MultiTexCoord4dvARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: double)>(MultiTexCoord4dvARB_adr);
    private ntv_MultiTexCoord4dvARB_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec4d)>(MultiTexCoord4dvARB_adr);
    private ntv_MultiTexCoord4dvARB_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord4dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dvARB(target: glTextureUnit; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord4dvARB_1(target, v[0]) else
        ntv_MultiTexCoord4dvARB_1(target, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dvARB(target: glTextureUnit; var v: Vec4d) :=
      ntv_MultiTexCoord4dvARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dvARB(target: glTextureUnit; var v: double) :=
      ntv_MultiTexCoord4dvARB_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dvARB(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord4dvARB_3(target, v);
    
    private MultiTexCoord4fARB_adr := GetProcAddress('glMultiTexCoord4fARB');
    private ntv_MultiTexCoord4fARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: single; t: single; r: single; q: single)>(MultiTexCoord4fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fARB(target: glTextureUnit; s: single; t: single; r: single; q: single) :=
      ntv_MultiTexCoord4fARB_1(target, s, t, r, q);
    
    private MultiTexCoord4fvARB_adr := GetProcAddress('glMultiTexCoord4fvARB');
    private ntv_MultiTexCoord4fvARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: single)>(MultiTexCoord4fvARB_adr);
    private ntv_MultiTexCoord4fvARB_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec4f)>(MultiTexCoord4fvARB_adr);
    private ntv_MultiTexCoord4fvARB_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fvARB(target: glTextureUnit; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord4fvARB_1(target, v[0]) else
        ntv_MultiTexCoord4fvARB_1(target, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fvARB(target: glTextureUnit; var v: Vec4f) :=
      ntv_MultiTexCoord4fvARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fvARB(target: glTextureUnit; var v: single) :=
      ntv_MultiTexCoord4fvARB_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fvARB(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord4fvARB_3(target, v);
    
    private MultiTexCoord4iARB_adr := GetProcAddress('glMultiTexCoord4iARB');
    private ntv_MultiTexCoord4iARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: Int32; t: Int32; r: Int32; q: Int32)>(MultiTexCoord4iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4iARB(target: glTextureUnit; s: Int32; t: Int32; r: Int32; q: Int32) :=
      ntv_MultiTexCoord4iARB_1(target, s, t, r, q);
    
    private MultiTexCoord4ivARB_adr := GetProcAddress('glMultiTexCoord4ivARB');
    private ntv_MultiTexCoord4ivARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Int32)>(MultiTexCoord4ivARB_adr);
    private ntv_MultiTexCoord4ivARB_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec4i)>(MultiTexCoord4ivARB_adr);
    private ntv_MultiTexCoord4ivARB_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord4ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4ivARB(target: glTextureUnit; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord4ivARB_1(target, v[0]) else
        ntv_MultiTexCoord4ivARB_1(target, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4ivARB(target: glTextureUnit; var v: Vec4i) :=
      ntv_MultiTexCoord4ivARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4ivARB(target: glTextureUnit; var v: Int32) :=
      ntv_MultiTexCoord4ivARB_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4ivARB(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord4ivARB_3(target, v);
    
    private MultiTexCoord4sARB_adr := GetProcAddress('glMultiTexCoord4sARB');
    private ntv_MultiTexCoord4sARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: Int16; t: Int16; r: Int16; q: Int16)>(MultiTexCoord4sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4sARB(target: glTextureUnit; s: Int16; t: Int16; r: Int16; q: Int16) :=
      ntv_MultiTexCoord4sARB_1(target, s, t, r, q);
    
    private MultiTexCoord4svARB_adr := GetProcAddress('glMultiTexCoord4svARB');
    private ntv_MultiTexCoord4svARB_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Int16)>(MultiTexCoord4svARB_adr);
    private ntv_MultiTexCoord4svARB_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec4s)>(MultiTexCoord4svARB_adr);
    private ntv_MultiTexCoord4svARB_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord4svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4svARB(target: glTextureUnit; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord4svARB_1(target, v[0]) else
        ntv_MultiTexCoord4svARB_1(target, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4svARB(target: glTextureUnit; var v: Vec4s) :=
      ntv_MultiTexCoord4svARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4svARB(target: glTextureUnit; var v: Int16) :=
      ntv_MultiTexCoord4svARB_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4svARB(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord4svARB_3(target, v);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glOcclusionQueryARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_occlusion_query';
    
    private GenQueriesARB_adr := GetProcAddress('glGenQueriesARB');
    private ntv_GenQueriesARB_1 := GetProcOrNil&<procedure(n: Int32; var ids: gl_query)>(GenQueriesARB_adr);
    private ntv_GenQueriesARB_2 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(GenQueriesARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueriesARB(n: Int32; ids: array of gl_query);
    type PGl_query = ^gl_query;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_GenQueriesARB_1(n, ids[0]) else
        ntv_GenQueriesARB_1(n, PGl_query(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueriesARB(n: Int32; var ids: gl_query) :=
      ntv_GenQueriesARB_1(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueriesARB(n: Int32; ids: IntPtr) :=
      ntv_GenQueriesARB_2(n, ids);
    
    private DeleteQueriesARB_adr := GetProcAddress('glDeleteQueriesARB');
    private ntv_DeleteQueriesARB_1 := GetProcOrNil&<procedure(n: Int32; var ids: gl_query)>(DeleteQueriesARB_adr);
    private ntv_DeleteQueriesARB_2 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(DeleteQueriesARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueriesARB(n: Int32; ids: array of gl_query);
    type PGl_query = ^gl_query;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_DeleteQueriesARB_1(n, ids[0]) else
        ntv_DeleteQueriesARB_1(n, PGl_query(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueriesARB(n: Int32; var ids: gl_query) :=
      ntv_DeleteQueriesARB_1(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueriesARB(n: Int32; ids: IntPtr) :=
      ntv_DeleteQueriesARB_2(n, ids);
    
    private IsQueryARB_adr := GetProcAddress('glIsQueryARB');
    private ntv_IsQueryARB_1 := GetProcOrNil&<function(id: gl_query): glBool8>(IsQueryARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsQueryARB(id: gl_query): glBool8 :=
      ntv_IsQueryARB_1(id);
    
    private BeginQueryARB_adr := GetProcAddress('glBeginQueryARB');
    private ntv_BeginQueryARB_1 := GetProcOrNil&<procedure(target: glQueryTarget; id: gl_query)>(BeginQueryARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginQueryARB(target: glQueryTarget; id: gl_query) :=
      ntv_BeginQueryARB_1(target, id);
    
    private EndQueryARB_adr := GetProcAddress('glEndQueryARB');
    private ntv_EndQueryARB_1 := GetProcOrNil&<procedure(target: glQueryTarget)>(EndQueryARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndQueryARB(target: glQueryTarget) :=
      ntv_EndQueryARB_1(target);
    
    private GetQueryivARB_adr := GetProcAddress('glGetQueryivARB');
    private ntv_GetQueryivARB_1 := GetProcOrNil&<procedure(target: glQueryTarget; pname: glQueryParameterName; var &params: Int32)>(GetQueryivARB_adr);
    private ntv_GetQueryivARB_2 := GetProcOrNil&<procedure(target: glQueryTarget; pname: glQueryParameterName; &params: IntPtr)>(GetQueryivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryivARB(target: glQueryTarget; pname: glQueryParameterName; var &params: Int32) :=
      ntv_GetQueryivARB_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryivARB(target: glQueryTarget; pname: glQueryParameterName; &params: IntPtr) :=
      ntv_GetQueryivARB_2(target, pname, &params);
    
    private GetQueryObjectivARB_adr := GetProcAddress('glGetQueryObjectivARB');
    private ntv_GetQueryObjectivARB_1 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; var &params: Int32)>(GetQueryObjectivARB_adr);
    private ntv_GetQueryObjectivARB_2 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr)>(GetQueryObjectivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectivARB(id: gl_query; pname: glQueryObjectParameterName; var &params: Int32) :=
      ntv_GetQueryObjectivARB_1(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectivARB(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr) :=
      ntv_GetQueryObjectivARB_2(id, pname, &params);
    
    private GetQueryObjectuivARB_adr := GetProcAddress('glGetQueryObjectuivARB');
    private ntv_GetQueryObjectuivARB_1 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; var &params: UInt32)>(GetQueryObjectuivARB_adr);
    private ntv_GetQueryObjectuivARB_2 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr)>(GetQueryObjectuivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectuivARB(id: gl_query; pname: glQueryObjectParameterName; var &params: UInt32) :=
      ntv_GetQueryObjectuivARB_1(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectuivARB(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr) :=
      ntv_GetQueryObjectuivARB_2(id, pname, &params);
    
  end;
  
  ///
  glOcclusionQuery2ARB = static class
    public const _ExtStr = 'GL_ARB_occlusion_query2';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glParallelShaderCompileARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_parallel_shader_compile';
    
    private MaxShaderCompilerThreadsARB_adr := GetProcAddress('glMaxShaderCompilerThreadsARB');
    private ntv_MaxShaderCompilerThreadsARB_1 := GetProcOrNil&<procedure(count: UInt32)>(MaxShaderCompilerThreadsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaxShaderCompilerThreadsARB(count: UInt32) :=
      ntv_MaxShaderCompilerThreadsARB_1(count);
    
  end;
  
  ///
  glPipelineStatisticsQueryARB = static class
    public const _ExtStr = 'GL_ARB_pipeline_statistics_query';
  end;
  
  ///
  glPixelBufferObjectARB = static class
    public const _ExtStr = 'GL_ARB_pixel_buffer_object';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPointParametersARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_point_parameters';
    
    private PointParameterfARB_adr := GetProcAddress('glPointParameterfARB');
    private ntv_PointParameterfARB_1 := GetProcOrNil&<procedure(pname: glPointParameterName; param: single)>(PointParameterfARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfARB(pname: glPointParameterName; param: single) :=
      ntv_PointParameterfARB_1(pname, param);
    
    private PointParameterfvARB_adr := GetProcAddress('glPointParameterfvARB');
    private ntv_PointParameterfvARB_1 := GetProcOrNil&<procedure(pname: glPointParameterName; var &params: single)>(PointParameterfvARB_adr);
    private ntv_PointParameterfvARB_2 := GetProcOrNil&<procedure(pname: glPointParameterName; &params: IntPtr)>(PointParameterfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvARB(pname: glPointParameterName; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_PointParameterfvARB_1(pname, &params[0]) else
        ntv_PointParameterfvARB_1(pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvARB(pname: glPointParameterName; var &params: single) :=
      ntv_PointParameterfvARB_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvARB(pname: glPointParameterName; &params: IntPtr) :=
      ntv_PointParameterfvARB_2(pname, &params);
    
  end;
  
  ///
  glPointSpriteARB = static class
    public const _ExtStr = 'GL_ARB_point_sprite';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPolygonOffsetClampARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_polygon_offset_clamp';
    
    private PolygonOffsetClamp_adr := GetProcAddress('glPolygonOffsetClamp');
    private ntv_PolygonOffsetClamp_1 := GetProcOrNil&<procedure(factor: single; units: single; clamp: single)>(PolygonOffsetClamp_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffsetClamp(factor: single; units: single; clamp: single) :=
      ntv_PolygonOffsetClamp_1(factor, units, clamp);
    
  end;
  
  ///
  glPostDepthCoverageARB = static class
    public const _ExtStr = 'GL_ARB_post_depth_coverage';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glProgramInterfaceQueryARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_program_interface_query';
    
    private GetProgramInterfaceiv_adr := GetProcAddress('glGetProgramInterfaceiv');
    private ntv_GetProgramInterfaceiv_1 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; pname: glProgramInterfacePName; var &params: Int32)>(GetProgramInterfaceiv_adr);
    private ntv_GetProgramInterfaceiv_2 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; pname: glProgramInterfacePName; &params: IntPtr)>(GetProgramInterfaceiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInterfaceiv(&program: gl_program; programInterface: glProgramInterface; pname: glProgramInterfacePName; var &params: Int32) :=
      ntv_GetProgramInterfaceiv_1(&program, programInterface, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInterfaceiv(&program: gl_program; programInterface: glProgramInterface; pname: glProgramInterfacePName; &params: IntPtr) :=
      ntv_GetProgramInterfaceiv_2(&program, programInterface, pname, &params);
    
    private GetProgramResourceIndex_adr := GetProcAddress('glGetProgramResourceIndex');
    private ntv_GetProgramResourceIndex_1 := GetProcOrNil&<function(&program: gl_program; programInterface: glProgramInterface; name: IntPtr): UInt32>(GetProgramResourceIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceIndex(&program: gl_program; programInterface: glProgramInterface; name: string): UInt32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetProgramResourceIndex_1(&program, programInterface, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceIndex(&program: gl_program; programInterface: glProgramInterface; name: IntPtr): UInt32 :=
      ntv_GetProgramResourceIndex_1(&program, programInterface, name);
    
    private GetProgramResourceName_adr := GetProcAddress('glGetProgramResourceName');
    private ntv_GetProgramResourceName_1 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr)>(GetProgramResourceName_adr);
    private ntv_GetProgramResourceName_2 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr)>(GetProgramResourceName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceName(&program: gl_program; programInterface: glProgramInterface; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr) :=
      ntv_GetProgramResourceName_1(&program, programInterface, index, bufSize, length, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceName(&program: gl_program; programInterface: glProgramInterface; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr) :=
      ntv_GetProgramResourceName_2(&program, programInterface, index, bufSize, length, name);
    
    private GetProgramResourceiv_adr := GetProcAddress('glGetProgramResourceiv');
    private ntv_GetProgramResourceiv_1 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: glProgramResourceProperty; count: Int32; var length: Int32; var &params: Int32)>(GetProgramResourceiv_adr);
    private ntv_GetProgramResourceiv_2 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: glProgramResourceProperty; count: Int32; var length: Int32; &params: IntPtr)>(GetProgramResourceiv_adr);
    private ntv_GetProgramResourceiv_3 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: glProgramResourceProperty; count: Int32; length: IntPtr; var &params: Int32)>(GetProgramResourceiv_adr);
    private ntv_GetProgramResourceiv_4 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: glProgramResourceProperty; count: Int32; length: IntPtr; &params: IntPtr)>(GetProgramResourceiv_adr);
    private ntv_GetProgramResourceiv_5 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; var &params: Int32)>(GetProgramResourceiv_adr);
    private ntv_GetProgramResourceiv_6 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; &params: IntPtr)>(GetProgramResourceiv_adr);
    private ntv_GetProgramResourceiv_7 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; var &params: Int32)>(GetProgramResourceiv_adr);
    private ntv_GetProgramResourceiv_8 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; &params: IntPtr)>(GetProgramResourceiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: array of glProgramResourceProperty; count: Int32; var length: Int32; var &params: Int32);
    type PGlProgramResourceProperty = ^glProgramResourceProperty;
    begin
      if (props<>nil) and (props.Length<>0) then
        ntv_GetProgramResourceiv_1(&program, programInterface, index, propCount, props[0], count, length, &params) else
        ntv_GetProgramResourceiv_1(&program, programInterface, index, propCount, PGlProgramResourceProperty(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: array of glProgramResourceProperty; count: Int32; var length: Int32; &params: IntPtr);
    type PGlProgramResourceProperty = ^glProgramResourceProperty;
    begin
      if (props<>nil) and (props.Length<>0) then
        ntv_GetProgramResourceiv_2(&program, programInterface, index, propCount, props[0], count, length, &params) else
        ntv_GetProgramResourceiv_2(&program, programInterface, index, propCount, PGlProgramResourceProperty(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: array of glProgramResourceProperty; count: Int32; length: IntPtr; var &params: Int32);
    type PGlProgramResourceProperty = ^glProgramResourceProperty;
    begin
      if (props<>nil) and (props.Length<>0) then
        ntv_GetProgramResourceiv_3(&program, programInterface, index, propCount, props[0], count, length, &params) else
        ntv_GetProgramResourceiv_3(&program, programInterface, index, propCount, PGlProgramResourceProperty(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: array of glProgramResourceProperty; count: Int32; length: IntPtr; &params: IntPtr);
    type PGlProgramResourceProperty = ^glProgramResourceProperty;
    begin
      if (props<>nil) and (props.Length<>0) then
        ntv_GetProgramResourceiv_4(&program, programInterface, index, propCount, props[0], count, length, &params) else
        ntv_GetProgramResourceiv_4(&program, programInterface, index, propCount, PGlProgramResourceProperty(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: glProgramResourceProperty; count: Int32; var length: Int32; var &params: Int32) :=
      ntv_GetProgramResourceiv_1(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: glProgramResourceProperty; count: Int32; var length: Int32; &params: IntPtr) :=
      ntv_GetProgramResourceiv_2(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: glProgramResourceProperty; count: Int32; length: IntPtr; var &params: Int32) :=
      ntv_GetProgramResourceiv_3(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: glProgramResourceProperty; count: Int32; length: IntPtr; &params: IntPtr) :=
      ntv_GetProgramResourceiv_4(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; var &params: Int32) :=
      ntv_GetProgramResourceiv_5(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; &params: IntPtr) :=
      ntv_GetProgramResourceiv_6(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; var &params: Int32) :=
      ntv_GetProgramResourceiv_7(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; &params: IntPtr) :=
      ntv_GetProgramResourceiv_8(&program, programInterface, index, propCount, props, count, length, &params);
    
    private GetProgramResourceLocation_adr := GetProcAddress('glGetProgramResourceLocation');
    private ntv_GetProgramResourceLocation_1 := GetProcOrNil&<function(&program: gl_program; programInterface: glProgramInterface; name: IntPtr): Int32>(GetProgramResourceLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocation(&program: gl_program; programInterface: glProgramInterface; name: string): Int32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetProgramResourceLocation_1(&program, programInterface, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocation(&program: gl_program; programInterface: glProgramInterface; name: IntPtr): Int32 :=
      ntv_GetProgramResourceLocation_1(&program, programInterface, name);
    
    private GetProgramResourceLocationIndex_adr := GetProcAddress('glGetProgramResourceLocationIndex');
    private ntv_GetProgramResourceLocationIndex_1 := GetProcOrNil&<function(&program: gl_program; programInterface: glProgramInterface; name: IntPtr): Int32>(GetProgramResourceLocationIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocationIndex(&program: gl_program; programInterface: glProgramInterface; name: string): Int32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetProgramResourceLocationIndex_1(&program, programInterface, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocationIndex(&program: gl_program; programInterface: glProgramInterface; name: IntPtr): Int32 :=
      ntv_GetProgramResourceLocationIndex_1(&program, programInterface, name);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glProvokingVertexARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_provoking_vertex';
    
    private ProvokingVertex_adr := GetProcAddress('glProvokingVertex');
    private ntv_ProvokingVertex_1 := GetProcOrNil&<procedure(mode: glVertexProvokingMode)>(ProvokingVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProvokingVertex(mode: glVertexProvokingMode) :=
      ntv_ProvokingVertex_1(mode);
    
  end;
  
  ///
  glQueryBufferObjectARB = static class
    public const _ExtStr = 'GL_ARB_query_buffer_object';
  end;
  
  ///
  glRobustBufferAccessBehaviorARB = static class
    public const _ExtStr = 'GL_ARB_robust_buffer_access_behavior';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glRobustnessARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_robustness';
    
    private GetGraphicsResetStatusARB_adr := GetProcAddress('glGetGraphicsResetStatusARB');
    private ntv_GetGraphicsResetStatusARB_1 := GetProcOrNil&<function: glGraphicsResetStatus>(GetGraphicsResetStatusARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGraphicsResetStatusARB: glGraphicsResetStatus :=
      ntv_GetGraphicsResetStatusARB_1;
    
    private GetnTexImageARB_adr := GetProcAddress('glGetnTexImageARB');
    private ntv_GetnTexImageARB_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; img: IntPtr)>(GetnTexImageARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnTexImageARB(target: glTextureTarget; level: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; img: IntPtr) :=
      ntv_GetnTexImageARB_1(target, level, format, &type, bufSize, img);
    
    private ReadnPixelsARB_adr := GetProcAddress('glReadnPixelsARB');
    private ntv_ReadnPixelsARB_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; data: IntPtr)>(ReadnPixelsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadnPixelsARB(x: Int32; y: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; data: IntPtr) :=
      ntv_ReadnPixelsARB_1(x, y, width, height, format, &type, bufSize, data);
    
    private GetnCompressedTexImageARB_adr := GetProcAddress('glGetnCompressedTexImageARB');
    private ntv_GetnCompressedTexImageARB_1 := GetProcOrNil&<procedure(target: glTextureTarget; lod: Int32; bufSize: Int32; img: IntPtr)>(GetnCompressedTexImageARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnCompressedTexImageARB(target: glTextureTarget; lod: Int32; bufSize: Int32; img: IntPtr) :=
      ntv_GetnCompressedTexImageARB_1(target, lod, bufSize, img);
    
    private GetnUniformfvARB_adr := GetProcAddress('glGetnUniformfvARB');
    private ntv_GetnUniformfvARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: single)>(GetnUniformfvARB_adr);
    private ntv_GetnUniformfvARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(GetnUniformfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfvARB(&program: gl_program; location: Int32; bufSize: Int32; var &params: single) :=
      ntv_GetnUniformfvARB_1(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfvARB(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
      ntv_GetnUniformfvARB_2(&program, location, bufSize, &params);
    
    private GetnUniformivARB_adr := GetProcAddress('glGetnUniformivARB');
    private ntv_GetnUniformivARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: Int32)>(GetnUniformivARB_adr);
    private ntv_GetnUniformivARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(GetnUniformivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformivARB(&program: gl_program; location: Int32; bufSize: Int32; var &params: Int32) :=
      ntv_GetnUniformivARB_1(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformivARB(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
      ntv_GetnUniformivARB_2(&program, location, bufSize, &params);
    
    private GetnUniformuivARB_adr := GetProcAddress('glGetnUniformuivARB');
    private ntv_GetnUniformuivARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: UInt32)>(GetnUniformuivARB_adr);
    private ntv_GetnUniformuivARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(GetnUniformuivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuivARB(&program: gl_program; location: Int32; bufSize: Int32; var &params: UInt32) :=
      ntv_GetnUniformuivARB_1(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuivARB(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
      ntv_GetnUniformuivARB_2(&program, location, bufSize, &params);
    
    private GetnUniformdvARB_adr := GetProcAddress('glGetnUniformdvARB');
    private ntv_GetnUniformdvARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: double)>(GetnUniformdvARB_adr);
    private ntv_GetnUniformdvARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(GetnUniformdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformdvARB(&program: gl_program; location: Int32; bufSize: Int32; var &params: double) :=
      ntv_GetnUniformdvARB_1(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformdvARB(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
      ntv_GetnUniformdvARB_2(&program, location, bufSize, &params);
    
    private GetnMapdvARB_adr := GetProcAddress('glGetnMapdvARB');
    private ntv_GetnMapdvARB_1 := GetProcOrNil&<procedure(target: glMapTarget; query: glMapQuery; bufSize: Int32; var v: double)>(GetnMapdvARB_adr);
    private ntv_GetnMapdvARB_2 := GetProcOrNil&<procedure(target: glMapTarget; query: glMapQuery; bufSize: Int32; v: IntPtr)>(GetnMapdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapdvARB(target: glMapTarget; query: glMapQuery; bufSize: Int32; var v: double) :=
      ntv_GetnMapdvARB_1(target, query, bufSize, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapdvARB(target: glMapTarget; query: glMapQuery; bufSize: Int32; v: IntPtr) :=
      ntv_GetnMapdvARB_2(target, query, bufSize, v);
    
    private GetnMapfvARB_adr := GetProcAddress('glGetnMapfvARB');
    private ntv_GetnMapfvARB_1 := GetProcOrNil&<procedure(target: glMapTarget; query: glMapQuery; bufSize: Int32; var v: single)>(GetnMapfvARB_adr);
    private ntv_GetnMapfvARB_2 := GetProcOrNil&<procedure(target: glMapTarget; query: glMapQuery; bufSize: Int32; v: IntPtr)>(GetnMapfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapfvARB(target: glMapTarget; query: glMapQuery; bufSize: Int32; var v: single) :=
      ntv_GetnMapfvARB_1(target, query, bufSize, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapfvARB(target: glMapTarget; query: glMapQuery; bufSize: Int32; v: IntPtr) :=
      ntv_GetnMapfvARB_2(target, query, bufSize, v);
    
    private GetnMapivARB_adr := GetProcAddress('glGetnMapivARB');
    private ntv_GetnMapivARB_1 := GetProcOrNil&<procedure(target: glMapTarget; query: glMapQuery; bufSize: Int32; var v: Int32)>(GetnMapivARB_adr);
    private ntv_GetnMapivARB_2 := GetProcOrNil&<procedure(target: glMapTarget; query: glMapQuery; bufSize: Int32; v: IntPtr)>(GetnMapivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapivARB(target: glMapTarget; query: glMapQuery; bufSize: Int32; var v: Int32) :=
      ntv_GetnMapivARB_1(target, query, bufSize, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapivARB(target: glMapTarget; query: glMapQuery; bufSize: Int32; v: IntPtr) :=
      ntv_GetnMapivARB_2(target, query, bufSize, v);
    
    private GetnPixelMapfvARB_adr := GetProcAddress('glGetnPixelMapfvARB');
    private ntv_GetnPixelMapfvARB_1 := GetProcOrNil&<procedure(map: glPixelMap; bufSize: Int32; var values: single)>(GetnPixelMapfvARB_adr);
    private ntv_GetnPixelMapfvARB_2 := GetProcOrNil&<procedure(map: glPixelMap; bufSize: Int32; values: IntPtr)>(GetnPixelMapfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapfvARB(map: glPixelMap; bufSize: Int32; var values: single) :=
      ntv_GetnPixelMapfvARB_1(map, bufSize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapfvARB(map: glPixelMap; bufSize: Int32; values: IntPtr) :=
      ntv_GetnPixelMapfvARB_2(map, bufSize, values);
    
    private GetnPixelMapuivARB_adr := GetProcAddress('glGetnPixelMapuivARB');
    private ntv_GetnPixelMapuivARB_1 := GetProcOrNil&<procedure(map: glPixelMap; bufSize: Int32; var values: UInt32)>(GetnPixelMapuivARB_adr);
    private ntv_GetnPixelMapuivARB_2 := GetProcOrNil&<procedure(map: glPixelMap; bufSize: Int32; values: IntPtr)>(GetnPixelMapuivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapuivARB(map: glPixelMap; bufSize: Int32; var values: UInt32) :=
      ntv_GetnPixelMapuivARB_1(map, bufSize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapuivARB(map: glPixelMap; bufSize: Int32; values: IntPtr) :=
      ntv_GetnPixelMapuivARB_2(map, bufSize, values);
    
    private GetnPixelMapusvARB_adr := GetProcAddress('glGetnPixelMapusvARB');
    private ntv_GetnPixelMapusvARB_1 := GetProcOrNil&<procedure(map: glPixelMap; bufSize: Int32; var values: UInt16)>(GetnPixelMapusvARB_adr);
    private ntv_GetnPixelMapusvARB_2 := GetProcOrNil&<procedure(map: glPixelMap; bufSize: Int32; values: IntPtr)>(GetnPixelMapusvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapusvARB(map: glPixelMap; bufSize: Int32; var values: UInt16) :=
      ntv_GetnPixelMapusvARB_1(map, bufSize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapusvARB(map: glPixelMap; bufSize: Int32; values: IntPtr) :=
      ntv_GetnPixelMapusvARB_2(map, bufSize, values);
    
    private GetnPolygonStippleARB_adr := GetProcAddress('glGetnPolygonStippleARB');
    private ntv_GetnPolygonStippleARB_1 := GetProcOrNil&<procedure(bufSize: Int32; var pattern: Byte)>(GetnPolygonStippleARB_adr);
    private ntv_GetnPolygonStippleARB_2 := GetProcOrNil&<procedure(bufSize: Int32; pattern: IntPtr)>(GetnPolygonStippleARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPolygonStippleARB(bufSize: Int32; var pattern: Byte) :=
      ntv_GetnPolygonStippleARB_1(bufSize, pattern);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPolygonStippleARB(bufSize: Int32; pattern: IntPtr) :=
      ntv_GetnPolygonStippleARB_2(bufSize, pattern);
    
    private GetnColorTableARB_adr := GetProcAddress('glGetnColorTableARB');
    private ntv_GetnColorTableARB_1 := GetProcOrNil&<procedure(target: glColorTableTarget; format: glPixelFormat; &type: glPixelType; bufSize: Int32; table: IntPtr)>(GetnColorTableARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnColorTableARB(target: glColorTableTarget; format: glPixelFormat; &type: glPixelType; bufSize: Int32; table: IntPtr) :=
      ntv_GetnColorTableARB_1(target, format, &type, bufSize, table);
    
    private GetnConvolutionFilterARB_adr := GetProcAddress('glGetnConvolutionFilterARB');
    private ntv_GetnConvolutionFilterARB_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; format: glPixelFormat; &type: glPixelType; bufSize: Int32; image: IntPtr)>(GetnConvolutionFilterARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnConvolutionFilterARB(target: glConvolutionTarget; format: glPixelFormat; &type: glPixelType; bufSize: Int32; image: IntPtr) :=
      ntv_GetnConvolutionFilterARB_1(target, format, &type, bufSize, image);
    
    private GetnSeparableFilterARB_adr := GetProcAddress('glGetnSeparableFilterARB');
    private ntv_GetnSeparableFilterARB_1 := GetProcOrNil&<procedure(target: glSeparableTarget; format: glPixelFormat; &type: glPixelType; rowBufSize: Int32; row: IntPtr; columnBufSize: Int32; column: IntPtr; span: IntPtr)>(GetnSeparableFilterARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnSeparableFilterARB(target: glSeparableTarget; format: glPixelFormat; &type: glPixelType; rowBufSize: Int32; row: IntPtr; columnBufSize: Int32; column: IntPtr; span: IntPtr) :=
      ntv_GetnSeparableFilterARB_1(target, format, &type, rowBufSize, row, columnBufSize, column, span);
    
    private GetnHistogramARB_adr := GetProcAddress('glGetnHistogramARB');
    private ntv_GetnHistogramARB_1 := GetProcOrNil&<procedure(target: glHistogramTarget; reset: glBool8; format: glPixelFormat; &type: glPixelType; bufSize: Int32; values: IntPtr)>(GetnHistogramARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnHistogramARB(target: glHistogramTarget; reset: glBool8; format: glPixelFormat; &type: glPixelType; bufSize: Int32; values: IntPtr) :=
      ntv_GetnHistogramARB_1(target, reset, format, &type, bufSize, values);
    
    private GetnMinmaxARB_adr := GetProcAddress('glGetnMinmaxARB');
    private ntv_GetnMinmaxARB_1 := GetProcOrNil&<procedure(target: glMinmaxTarget; reset: glBool8; format: glPixelFormat; &type: glPixelType; bufSize: Int32; values: IntPtr)>(GetnMinmaxARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMinmaxARB(target: glMinmaxTarget; reset: glBool8; format: glPixelFormat; &type: glPixelType; bufSize: Int32; values: IntPtr) :=
      ntv_GetnMinmaxARB_1(target, reset, format, &type, bufSize, values);
    
  end;
  
  ///
  glRobustnessIsolationARB = static class
    public const _ExtStr = 'GL_ARB_robustness_isolation';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSampleLocationsARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_sample_locations';
    
    private FramebufferSampleLocationsfvARB_adr := GetProcAddress('glFramebufferSampleLocationsfvARB');
    private ntv_FramebufferSampleLocationsfvARB_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; start: UInt32; count: Int32; var v: single)>(FramebufferSampleLocationsfvARB_adr);
    private ntv_FramebufferSampleLocationsfvARB_2 := GetProcOrNil&<procedure(target: glFramebufferTarget; start: UInt32; count: Int32; v: IntPtr)>(FramebufferSampleLocationsfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvARB(target: glFramebufferTarget; start: UInt32; count: Int32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_FramebufferSampleLocationsfvARB_1(target, start, count, v[0]) else
        ntv_FramebufferSampleLocationsfvARB_1(target, start, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvARB(target: glFramebufferTarget; start: UInt32; count: Int32; var v: single) :=
      ntv_FramebufferSampleLocationsfvARB_1(target, start, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvARB(target: glFramebufferTarget; start: UInt32; count: Int32; v: IntPtr) :=
      ntv_FramebufferSampleLocationsfvARB_2(target, start, count, v);
    
    private NamedFramebufferSampleLocationsfvARB_adr := GetProcAddress('glNamedFramebufferSampleLocationsfvARB');
    private ntv_NamedFramebufferSampleLocationsfvARB_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; start: UInt32; count: Int32; var v: single)>(NamedFramebufferSampleLocationsfvARB_adr);
    private ntv_NamedFramebufferSampleLocationsfvARB_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: IntPtr)>(NamedFramebufferSampleLocationsfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvARB(framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_NamedFramebufferSampleLocationsfvARB_1(framebuffer, start, count, v[0]) else
        ntv_NamedFramebufferSampleLocationsfvARB_1(framebuffer, start, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvARB(framebuffer: gl_framebuffer; start: UInt32; count: Int32; var v: single) :=
      ntv_NamedFramebufferSampleLocationsfvARB_1(framebuffer, start, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvARB(framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: IntPtr) :=
      ntv_NamedFramebufferSampleLocationsfvARB_2(framebuffer, start, count, v);
    
    private EvaluateDepthValuesARB_adr := GetProcAddress('glEvaluateDepthValuesARB');
    private ntv_EvaluateDepthValuesARB_1 := GetProcOrNil&<procedure>(EvaluateDepthValuesARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvaluateDepthValuesARB :=
      ntv_EvaluateDepthValuesARB_1;
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSampleShadingARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_sample_shading';
    
    private MinSampleShadingARB_adr := GetProcAddress('glMinSampleShadingARB');
    private ntv_MinSampleShadingARB_1 := GetProcOrNil&<procedure(value: single)>(MinSampleShadingARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MinSampleShadingARB(value: single) :=
      ntv_MinSampleShadingARB_1(value);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSamplerObjectsARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_sampler_objects';
    
    private GenSamplers_adr := GetProcAddress('glGenSamplers');
    private ntv_GenSamplers_1 := GetProcOrNil&<procedure(count: Int32; var samplers: gl_sampler)>(GenSamplers_adr);
    private ntv_GenSamplers_2 := GetProcOrNil&<procedure(count: Int32; samplers: IntPtr)>(GenSamplers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSamplers(count: Int32; samplers: array of gl_sampler);
    type PGl_sampler = ^gl_sampler;
    begin
      if (samplers<>nil) and (samplers.Length<>0) then
        ntv_GenSamplers_1(count, samplers[0]) else
        ntv_GenSamplers_1(count, PGl_sampler(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSamplers(count: Int32; var samplers: gl_sampler) :=
      ntv_GenSamplers_1(count, samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSamplers(count: Int32; samplers: IntPtr) :=
      ntv_GenSamplers_2(count, samplers);
    
    private DeleteSamplers_adr := GetProcAddress('glDeleteSamplers');
    private ntv_DeleteSamplers_1 := GetProcOrNil&<procedure(count: Int32; var samplers: gl_sampler)>(DeleteSamplers_adr);
    private ntv_DeleteSamplers_2 := GetProcOrNil&<procedure(count: Int32; samplers: IntPtr)>(DeleteSamplers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSamplers(count: Int32; samplers: array of gl_sampler);
    type PGl_sampler = ^gl_sampler;
    begin
      if (samplers<>nil) and (samplers.Length<>0) then
        ntv_DeleteSamplers_1(count, samplers[0]) else
        ntv_DeleteSamplers_1(count, PGl_sampler(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSamplers(count: Int32; var samplers: gl_sampler) :=
      ntv_DeleteSamplers_1(count, samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSamplers(count: Int32; samplers: IntPtr) :=
      ntv_DeleteSamplers_2(count, samplers);
    
    private IsSampler_adr := GetProcAddress('glIsSampler');
    private ntv_IsSampler_1 := GetProcOrNil&<function(sampler: gl_sampler): glBool8>(IsSampler_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsSampler(sampler: gl_sampler): glBool8 :=
      ntv_IsSampler_1(sampler);
    
    private BindSampler_adr := GetProcAddress('glBindSampler');
    private ntv_BindSampler_1 := GetProcOrNil&<procedure(&unit: UInt32; sampler: gl_sampler)>(BindSampler_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSampler(&unit: UInt32; sampler: gl_sampler) :=
      ntv_BindSampler_1(&unit, sampler);
    
    private SamplerParameteri_adr := GetProcAddress('glSamplerParameteri');
    private ntv_SamplerParameteri_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; param: Int32)>(SamplerParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteri(sampler: gl_sampler; pname: glSamplerParameterI; param: Int32) :=
      ntv_SamplerParameteri_1(sampler, pname, param);
    
    private SamplerParameteriv_adr := GetProcAddress('glSamplerParameteriv');
    private ntv_SamplerParameteriv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; var param: Int32)>(SamplerParameteriv_adr);
    private ntv_SamplerParameteriv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; param: IntPtr)>(SamplerParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteriv(sampler: gl_sampler; pname: glSamplerParameterI; param: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (param<>nil) and (param.Length<>0) then
        ntv_SamplerParameteriv_1(sampler, pname, param[0]) else
        ntv_SamplerParameteriv_1(sampler, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteriv(sampler: gl_sampler; pname: glSamplerParameterI; var param: Int32) :=
      ntv_SamplerParameteriv_1(sampler, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteriv(sampler: gl_sampler; pname: glSamplerParameterI; param: IntPtr) :=
      ntv_SamplerParameteriv_2(sampler, pname, param);
    
    private SamplerParameterf_adr := GetProcAddress('glSamplerParameterf');
    private ntv_SamplerParameterf_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterF; param: single)>(SamplerParameterf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterf(sampler: gl_sampler; pname: glSamplerParameterF; param: single) :=
      ntv_SamplerParameterf_1(sampler, pname, param);
    
    private SamplerParameterfv_adr := GetProcAddress('glSamplerParameterfv');
    private ntv_SamplerParameterfv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterF; var param: single)>(SamplerParameterfv_adr);
    private ntv_SamplerParameterfv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterF; param: IntPtr)>(SamplerParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterfv(sampler: gl_sampler; pname: glSamplerParameterF; param: array of single);
    type PSingle = ^single;
    begin
      if (param<>nil) and (param.Length<>0) then
        ntv_SamplerParameterfv_1(sampler, pname, param[0]) else
        ntv_SamplerParameterfv_1(sampler, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterfv(sampler: gl_sampler; pname: glSamplerParameterF; var param: single) :=
      ntv_SamplerParameterfv_1(sampler, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterfv(sampler: gl_sampler; pname: glSamplerParameterF; param: IntPtr) :=
      ntv_SamplerParameterfv_2(sampler, pname, param);
    
    private SamplerParameterIiv_adr := GetProcAddress('glSamplerParameterIiv');
    private ntv_SamplerParameterIiv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; var param: Int32)>(SamplerParameterIiv_adr);
    private ntv_SamplerParameterIiv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; param: IntPtr)>(SamplerParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIiv(sampler: gl_sampler; pname: glSamplerParameterI; param: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (param<>nil) and (param.Length<>0) then
        ntv_SamplerParameterIiv_1(sampler, pname, param[0]) else
        ntv_SamplerParameterIiv_1(sampler, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIiv(sampler: gl_sampler; pname: glSamplerParameterI; var param: Int32) :=
      ntv_SamplerParameterIiv_1(sampler, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIiv(sampler: gl_sampler; pname: glSamplerParameterI; param: IntPtr) :=
      ntv_SamplerParameterIiv_2(sampler, pname, param);
    
    private SamplerParameterIuiv_adr := GetProcAddress('glSamplerParameterIuiv');
    private ntv_SamplerParameterIuiv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; var param: UInt32)>(SamplerParameterIuiv_adr);
    private ntv_SamplerParameterIuiv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; param: IntPtr)>(SamplerParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: gl_sampler; pname: glSamplerParameterI; param: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (param<>nil) and (param.Length<>0) then
        ntv_SamplerParameterIuiv_1(sampler, pname, param[0]) else
        ntv_SamplerParameterIuiv_1(sampler, pname, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: gl_sampler; pname: glSamplerParameterI; var param: UInt32) :=
      ntv_SamplerParameterIuiv_1(sampler, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: gl_sampler; pname: glSamplerParameterI; param: IntPtr) :=
      ntv_SamplerParameterIuiv_2(sampler, pname, param);
    
    private GetSamplerParameteriv_adr := GetProcAddress('glGetSamplerParameteriv');
    private ntv_GetSamplerParameteriv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; var &params: Int32)>(GetSamplerParameteriv_adr);
    private ntv_GetSamplerParameteriv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; &params: IntPtr)>(GetSamplerParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameteriv(sampler: gl_sampler; pname: glSamplerParameterI; var &params: Int32) :=
      ntv_GetSamplerParameteriv_1(sampler, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameteriv(sampler: gl_sampler; pname: glSamplerParameterI; &params: IntPtr) :=
      ntv_GetSamplerParameteriv_2(sampler, pname, &params);
    
    private GetSamplerParameterIiv_adr := GetProcAddress('glGetSamplerParameterIiv');
    private ntv_GetSamplerParameterIiv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; var &params: Int32)>(GetSamplerParameterIiv_adr);
    private ntv_GetSamplerParameterIiv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; &params: IntPtr)>(GetSamplerParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIiv(sampler: gl_sampler; pname: glSamplerParameterI; var &params: Int32) :=
      ntv_GetSamplerParameterIiv_1(sampler, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIiv(sampler: gl_sampler; pname: glSamplerParameterI; &params: IntPtr) :=
      ntv_GetSamplerParameterIiv_2(sampler, pname, &params);
    
    private GetSamplerParameterfv_adr := GetProcAddress('glGetSamplerParameterfv');
    private ntv_GetSamplerParameterfv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterF; var &params: single)>(GetSamplerParameterfv_adr);
    private ntv_GetSamplerParameterfv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterF; &params: IntPtr)>(GetSamplerParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterfv(sampler: gl_sampler; pname: glSamplerParameterF; var &params: single) :=
      ntv_GetSamplerParameterfv_1(sampler, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterfv(sampler: gl_sampler; pname: glSamplerParameterF; &params: IntPtr) :=
      ntv_GetSamplerParameterfv_2(sampler, pname, &params);
    
    private GetSamplerParameterIuiv_adr := GetProcAddress('glGetSamplerParameterIuiv');
    private ntv_GetSamplerParameterIuiv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; var &params: UInt32)>(GetSamplerParameterIuiv_adr);
    private ntv_GetSamplerParameterIuiv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; &params: IntPtr)>(GetSamplerParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuiv(sampler: gl_sampler; pname: glSamplerParameterI; var &params: UInt32) :=
      ntv_GetSamplerParameterIuiv_1(sampler, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuiv(sampler: gl_sampler; pname: glSamplerParameterI; &params: IntPtr) :=
      ntv_GetSamplerParameterIuiv_2(sampler, pname, &params);
    
  end;
  
  ///
  glSeamlessCubeMapARB = static class
    public const _ExtStr = 'GL_ARB_seamless_cube_map';
  end;
  
  ///
  glSeamlessCubemapPerTextureARB = static class
    public const _ExtStr = 'GL_ARB_seamless_cubemap_per_texture';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSeparateShaderObjectsARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_separate_shader_objects';
    
    private UseProgramStages_adr := GetProcAddress('glUseProgramStages');
    private ntv_UseProgramStages_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; stages: glUseProgramStageMask; &program: gl_program)>(UseProgramStages_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseProgramStages(pipeline: gl_program_pipeline; stages: glUseProgramStageMask; &program: gl_program) :=
      ntv_UseProgramStages_1(pipeline, stages, &program);
    
    private ActiveShaderProgram_adr := GetProcAddress('glActiveShaderProgram');
    private ntv_ActiveShaderProgram_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; &program: gl_program)>(ActiveShaderProgram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveShaderProgram(pipeline: gl_program_pipeline; &program: gl_program) :=
      ntv_ActiveShaderProgram_1(pipeline, &program);
    
    private CreateShaderProgramv_adr := GetProcAddress('glCreateShaderProgramv');
    private ntv_CreateShaderProgramv_1 := GetProcOrNil&<function(&type: glShaderType; count: Int32; var strings: IntPtr): gl_program>(CreateShaderProgramv_adr);
    private ntv_CreateShaderProgramv_2 := GetProcOrNil&<function(&type: glShaderType; count: Int32; strings: pointer): gl_program>(CreateShaderProgramv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramv(&type: glShaderType; count: Int32; strings: array of string): gl_program;
    begin
      if (strings=nil) or (strings.Length=0) then
      begin
        Result := ntv_CreateShaderProgramv_2(&type, count, nil);
        exit;
      end;
      var strings_temp_arr: array of IntPtr;
      try
        begin
          var strings_org_el_1 := strings;
          var strings_len_1 := strings_org_el_1.Length;
          SetLength(strings_temp_arr, strings_len_1);
          var strings_tmp_el_1 := strings_temp_arr;
          for var strings_ind_1 := 0 to strings_len_1-1 do
          begin
            var strings_org_el_2 := strings_org_el_1[strings_ind_1];
            if (strings_org_el_2=nil) or (strings_org_el_2.Length=0) then continue;
            strings_tmp_el_1[strings_ind_1] := Marshal.StringToHGlobalAnsi(strings_org_el_2);
          end;
        end;
        Result := ntv_CreateShaderProgramv_1(&type, count, strings_temp_arr[0]);
      finally
         foreach var arr_el1 in strings_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramv(&type: glShaderType; count: Int32; var strings: IntPtr): gl_program :=
      ntv_CreateShaderProgramv_1(&type, count, strings);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramv(&type: glShaderType; count: Int32; strings: pointer): gl_program :=
      ntv_CreateShaderProgramv_2(&type, count, strings);
    
    private BindProgramPipeline_adr := GetProcAddress('glBindProgramPipeline');
    private ntv_BindProgramPipeline_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline)>(BindProgramPipeline_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindProgramPipeline(pipeline: gl_program_pipeline) :=
      ntv_BindProgramPipeline_1(pipeline);
    
    private DeleteProgramPipelines_adr := GetProcAddress('glDeleteProgramPipelines');
    private ntv_DeleteProgramPipelines_1 := GetProcOrNil&<procedure(n: Int32; var pipelines: gl_program_pipeline)>(DeleteProgramPipelines_adr);
    private ntv_DeleteProgramPipelines_2 := GetProcOrNil&<procedure(n: Int32; pipelines: IntPtr)>(DeleteProgramPipelines_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelines(n: Int32; pipelines: array of gl_program_pipeline);
    type PGl_program_pipeline = ^gl_program_pipeline;
    begin
      if (pipelines<>nil) and (pipelines.Length<>0) then
        ntv_DeleteProgramPipelines_1(n, pipelines[0]) else
        ntv_DeleteProgramPipelines_1(n, PGl_program_pipeline(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelines(n: Int32; var pipelines: gl_program_pipeline) :=
      ntv_DeleteProgramPipelines_1(n, pipelines);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelines(n: Int32; pipelines: IntPtr) :=
      ntv_DeleteProgramPipelines_2(n, pipelines);
    
    private GenProgramPipelines_adr := GetProcAddress('glGenProgramPipelines');
    private ntv_GenProgramPipelines_1 := GetProcOrNil&<procedure(n: Int32; var pipelines: gl_program_pipeline)>(GenProgramPipelines_adr);
    private ntv_GenProgramPipelines_2 := GetProcOrNil&<procedure(n: Int32; pipelines: IntPtr)>(GenProgramPipelines_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelines(n: Int32; pipelines: array of gl_program_pipeline);
    type PGl_program_pipeline = ^gl_program_pipeline;
    begin
      if (pipelines<>nil) and (pipelines.Length<>0) then
        ntv_GenProgramPipelines_1(n, pipelines[0]) else
        ntv_GenProgramPipelines_1(n, PGl_program_pipeline(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelines(n: Int32; var pipelines: gl_program_pipeline) :=
      ntv_GenProgramPipelines_1(n, pipelines);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelines(n: Int32; pipelines: IntPtr) :=
      ntv_GenProgramPipelines_2(n, pipelines);
    
    private IsProgramPipeline_adr := GetProcAddress('glIsProgramPipeline');
    private ntv_IsProgramPipeline_1 := GetProcOrNil&<function(pipeline: gl_program_pipeline): glBool8>(IsProgramPipeline_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsProgramPipeline(pipeline: gl_program_pipeline): glBool8 :=
      ntv_IsProgramPipeline_1(pipeline);
    
    private GetProgramPipelineiv_adr := GetProcAddress('glGetProgramPipelineiv');
    private ntv_GetProgramPipelineiv_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; pname: glPipelineParameterName; var &params: Int32)>(GetProgramPipelineiv_adr);
    private ntv_GetProgramPipelineiv_2 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; pname: glPipelineParameterName; &params: IntPtr)>(GetProgramPipelineiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineiv(pipeline: gl_program_pipeline; pname: glPipelineParameterName; var &params: Int32) :=
      ntv_GetProgramPipelineiv_1(pipeline, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineiv(pipeline: gl_program_pipeline; pname: glPipelineParameterName; &params: IntPtr) :=
      ntv_GetProgramPipelineiv_2(pipeline, pname, &params);
    
    private ProgramParameteri_adr := GetProcAddress('glProgramParameteri');
    private ntv_ProgramParameteri_1 := GetProcOrNil&<procedure(&program: gl_program; pname: glProgramParameterPName; value: Int32)>(ProgramParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameteri(&program: gl_program; pname: glProgramParameterPName; value: Int32) :=
      ntv_ProgramParameteri_1(&program, pname, value);
    
    private ProgramUniform1i_adr := GetProcAddress('glProgramUniform1i');
    private ntv_ProgramUniform1i_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32)>(ProgramUniform1i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i(&program: gl_program; location: Int32; v0: Int32) :=
      ntv_ProgramUniform1i_1(&program, location, v0);
    
    private ProgramUniform1iv_adr := GetProcAddress('glProgramUniform1iv');
    private ntv_ProgramUniform1iv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(ProgramUniform1iv_adr);
    private ntv_ProgramUniform1iv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iv(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1iv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1iv_1(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iv(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
      ntv_ProgramUniform1iv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1iv_2(&program, location, count, value);
    
    private ProgramUniform1f_adr := GetProcAddress('glProgramUniform1f');
    private ntv_ProgramUniform1f_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single)>(ProgramUniform1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1f(&program: gl_program; location: Int32; v0: single) :=
      ntv_ProgramUniform1f_1(&program, location, v0);
    
    private ProgramUniform1fv_adr := GetProcAddress('glProgramUniform1fv');
    private ntv_ProgramUniform1fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(ProgramUniform1fv_adr);
    private ntv_ProgramUniform1fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fv(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1fv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1fv_1(&program, location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fv(&program: gl_program; location: Int32; count: Int32; var value: single) :=
      ntv_ProgramUniform1fv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1fv_2(&program, location, count, value);
    
    private ProgramUniform1d_adr := GetProcAddress('glProgramUniform1d');
    private ntv_ProgramUniform1d_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: double)>(ProgramUniform1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1d(&program: gl_program; location: Int32; v0: double) :=
      ntv_ProgramUniform1d_1(&program, location, v0);
    
    private ProgramUniform1dv_adr := GetProcAddress('glProgramUniform1dv');
    private ntv_ProgramUniform1dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: double)>(ProgramUniform1dv_adr);
    private ntv_ProgramUniform1dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dv(&program: gl_program; location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1dv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1dv_1(&program, location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dv(&program: gl_program; location: Int32; count: Int32; var value: double) :=
      ntv_ProgramUniform1dv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1dv_2(&program, location, count, value);
    
    private ProgramUniform1ui_adr := GetProcAddress('glProgramUniform1ui');
    private ntv_ProgramUniform1ui_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32)>(ProgramUniform1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui(&program: gl_program; location: Int32; v0: UInt32) :=
      ntv_ProgramUniform1ui_1(&program, location, v0);
    
    private ProgramUniform1uiv_adr := GetProcAddress('glProgramUniform1uiv');
    private ntv_ProgramUniform1uiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(ProgramUniform1uiv_adr);
    private ntv_ProgramUniform1uiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiv(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1uiv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1uiv_1(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiv(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
      ntv_ProgramUniform1uiv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1uiv_2(&program, location, count, value);
    
    private ProgramUniform2i_adr := GetProcAddress('glProgramUniform2i');
    private ntv_ProgramUniform2i_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32)>(ProgramUniform2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i(&program: gl_program; location: Int32; v0: Int32; v1: Int32) :=
      ntv_ProgramUniform2i_1(&program, location, v0, v1);
    
    private ProgramUniform2iv_adr := GetProcAddress('glProgramUniform2iv');
    private ntv_ProgramUniform2iv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(ProgramUniform2iv_adr);
    private ntv_ProgramUniform2iv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2i)>(ProgramUniform2iv_adr);
    private ntv_ProgramUniform2iv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2iv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2iv_1(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: gl_program; location: Int32; count: Int32; var value: Vec2i) :=
      ntv_ProgramUniform2iv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
      ntv_ProgramUniform2iv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2iv_3(&program, location, count, value);
    
    private ProgramUniform2f_adr := GetProcAddress('glProgramUniform2f');
    private ntv_ProgramUniform2f_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single)>(ProgramUniform2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2f(&program: gl_program; location: Int32; v0: single; v1: single) :=
      ntv_ProgramUniform2f_1(&program, location, v0, v1);
    
    private ProgramUniform2fv_adr := GetProcAddress('glProgramUniform2fv');
    private ntv_ProgramUniform2fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(ProgramUniform2fv_adr);
    private ntv_ProgramUniform2fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2f)>(ProgramUniform2fv_adr);
    private ntv_ProgramUniform2fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2fv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2fv_1(&program, location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: gl_program; location: Int32; count: Int32; var value: Vec2f) :=
      ntv_ProgramUniform2fv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: gl_program; location: Int32; count: Int32; var value: single) :=
      ntv_ProgramUniform2fv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2fv_3(&program, location, count, value);
    
    private ProgramUniform2d_adr := GetProcAddress('glProgramUniform2d');
    private ntv_ProgramUniform2d_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: double; v1: double)>(ProgramUniform2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2d(&program: gl_program; location: Int32; v0: double; v1: double) :=
      ntv_ProgramUniform2d_1(&program, location, v0, v1);
    
    private ProgramUniform2dv_adr := GetProcAddress('glProgramUniform2dv');
    private ntv_ProgramUniform2dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: double)>(ProgramUniform2dv_adr);
    private ntv_ProgramUniform2dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2d)>(ProgramUniform2dv_adr);
    private ntv_ProgramUniform2dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: gl_program; location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2dv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2dv_1(&program, location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: gl_program; location: Int32; count: Int32; var value: Vec2d) :=
      ntv_ProgramUniform2dv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: gl_program; location: Int32; count: Int32; var value: double) :=
      ntv_ProgramUniform2dv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2dv_3(&program, location, count, value);
    
    private ProgramUniform2ui_adr := GetProcAddress('glProgramUniform2ui');
    private ntv_ProgramUniform2ui_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32)>(ProgramUniform2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32) :=
      ntv_ProgramUniform2ui_1(&program, location, v0, v1);
    
    private ProgramUniform2uiv_adr := GetProcAddress('glProgramUniform2uiv');
    private ntv_ProgramUniform2uiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(ProgramUniform2uiv_adr);
    private ntv_ProgramUniform2uiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2ui)>(ProgramUniform2uiv_adr);
    private ntv_ProgramUniform2uiv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2uiv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2uiv_1(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: gl_program; location: Int32; count: Int32; var value: Vec2ui) :=
      ntv_ProgramUniform2uiv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
      ntv_ProgramUniform2uiv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2uiv_3(&program, location, count, value);
    
    private ProgramUniform3i_adr := GetProcAddress('glProgramUniform3i');
    private ntv_ProgramUniform3i_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32)>(ProgramUniform3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32) :=
      ntv_ProgramUniform3i_1(&program, location, v0, v1, v2);
    
    private ProgramUniform3iv_adr := GetProcAddress('glProgramUniform3iv');
    private ntv_ProgramUniform3iv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(ProgramUniform3iv_adr);
    private ntv_ProgramUniform3iv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3i)>(ProgramUniform3iv_adr);
    private ntv_ProgramUniform3iv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3iv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3iv_1(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: gl_program; location: Int32; count: Int32; var value: Vec3i) :=
      ntv_ProgramUniform3iv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
      ntv_ProgramUniform3iv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3iv_3(&program, location, count, value);
    
    private ProgramUniform3f_adr := GetProcAddress('glProgramUniform3f');
    private ntv_ProgramUniform3f_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single; v2: single)>(ProgramUniform3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3f(&program: gl_program; location: Int32; v0: single; v1: single; v2: single) :=
      ntv_ProgramUniform3f_1(&program, location, v0, v1, v2);
    
    private ProgramUniform3fv_adr := GetProcAddress('glProgramUniform3fv');
    private ntv_ProgramUniform3fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(ProgramUniform3fv_adr);
    private ntv_ProgramUniform3fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3f)>(ProgramUniform3fv_adr);
    private ntv_ProgramUniform3fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3fv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3fv_1(&program, location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: gl_program; location: Int32; count: Int32; var value: Vec3f) :=
      ntv_ProgramUniform3fv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: gl_program; location: Int32; count: Int32; var value: single) :=
      ntv_ProgramUniform3fv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3fv_3(&program, location, count, value);
    
    private ProgramUniform3d_adr := GetProcAddress('glProgramUniform3d');
    private ntv_ProgramUniform3d_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: double; v1: double; v2: double)>(ProgramUniform3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3d(&program: gl_program; location: Int32; v0: double; v1: double; v2: double) :=
      ntv_ProgramUniform3d_1(&program, location, v0, v1, v2);
    
    private ProgramUniform3dv_adr := GetProcAddress('glProgramUniform3dv');
    private ntv_ProgramUniform3dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: double)>(ProgramUniform3dv_adr);
    private ntv_ProgramUniform3dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3d)>(ProgramUniform3dv_adr);
    private ntv_ProgramUniform3dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: gl_program; location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3dv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3dv_1(&program, location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: gl_program; location: Int32; count: Int32; var value: Vec3d) :=
      ntv_ProgramUniform3dv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: gl_program; location: Int32; count: Int32; var value: double) :=
      ntv_ProgramUniform3dv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3dv_3(&program, location, count, value);
    
    private ProgramUniform3ui_adr := GetProcAddress('glProgramUniform3ui');
    private ntv_ProgramUniform3ui_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32)>(ProgramUniform3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32) :=
      ntv_ProgramUniform3ui_1(&program, location, v0, v1, v2);
    
    private ProgramUniform3uiv_adr := GetProcAddress('glProgramUniform3uiv');
    private ntv_ProgramUniform3uiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(ProgramUniform3uiv_adr);
    private ntv_ProgramUniform3uiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3ui)>(ProgramUniform3uiv_adr);
    private ntv_ProgramUniform3uiv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3uiv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3uiv_1(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: gl_program; location: Int32; count: Int32; var value: Vec3ui) :=
      ntv_ProgramUniform3uiv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
      ntv_ProgramUniform3uiv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3uiv_3(&program, location, count, value);
    
    private ProgramUniform4i_adr := GetProcAddress('glProgramUniform4i');
    private ntv_ProgramUniform4i_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32)>(ProgramUniform4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32) :=
      ntv_ProgramUniform4i_1(&program, location, v0, v1, v2, v3);
    
    private ProgramUniform4iv_adr := GetProcAddress('glProgramUniform4iv');
    private ntv_ProgramUniform4iv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(ProgramUniform4iv_adr);
    private ntv_ProgramUniform4iv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4i)>(ProgramUniform4iv_adr);
    private ntv_ProgramUniform4iv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4iv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4iv_1(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: gl_program; location: Int32; count: Int32; var value: Vec4i) :=
      ntv_ProgramUniform4iv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
      ntv_ProgramUniform4iv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4iv_3(&program, location, count, value);
    
    private ProgramUniform4f_adr := GetProcAddress('glProgramUniform4f');
    private ntv_ProgramUniform4f_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single; v2: single; v3: single)>(ProgramUniform4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4f(&program: gl_program; location: Int32; v0: single; v1: single; v2: single; v3: single) :=
      ntv_ProgramUniform4f_1(&program, location, v0, v1, v2, v3);
    
    private ProgramUniform4fv_adr := GetProcAddress('glProgramUniform4fv');
    private ntv_ProgramUniform4fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(ProgramUniform4fv_adr);
    private ntv_ProgramUniform4fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4f)>(ProgramUniform4fv_adr);
    private ntv_ProgramUniform4fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4fv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4fv_1(&program, location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: gl_program; location: Int32; count: Int32; var value: Vec4f) :=
      ntv_ProgramUniform4fv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: gl_program; location: Int32; count: Int32; var value: single) :=
      ntv_ProgramUniform4fv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4fv_3(&program, location, count, value);
    
    private ProgramUniform4d_adr := GetProcAddress('glProgramUniform4d');
    private ntv_ProgramUniform4d_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: double; v1: double; v2: double; v3: double)>(ProgramUniform4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4d(&program: gl_program; location: Int32; v0: double; v1: double; v2: double; v3: double) :=
      ntv_ProgramUniform4d_1(&program, location, v0, v1, v2, v3);
    
    private ProgramUniform4dv_adr := GetProcAddress('glProgramUniform4dv');
    private ntv_ProgramUniform4dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: double)>(ProgramUniform4dv_adr);
    private ntv_ProgramUniform4dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4d)>(ProgramUniform4dv_adr);
    private ntv_ProgramUniform4dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: gl_program; location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4dv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4dv_1(&program, location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: gl_program; location: Int32; count: Int32; var value: Vec4d) :=
      ntv_ProgramUniform4dv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: gl_program; location: Int32; count: Int32; var value: double) :=
      ntv_ProgramUniform4dv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4dv_3(&program, location, count, value);
    
    private ProgramUniform4ui_adr := GetProcAddress('glProgramUniform4ui');
    private ntv_ProgramUniform4ui_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32)>(ProgramUniform4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32) :=
      ntv_ProgramUniform4ui_1(&program, location, v0, v1, v2, v3);
    
    private ProgramUniform4uiv_adr := GetProcAddress('glProgramUniform4uiv');
    private ntv_ProgramUniform4uiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(ProgramUniform4uiv_adr);
    private ntv_ProgramUniform4uiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4ui)>(ProgramUniform4uiv_adr);
    private ntv_ProgramUniform4uiv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4uiv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4uiv_1(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: gl_program; location: Int32; count: Int32; var value: Vec4ui) :=
      ntv_ProgramUniform4uiv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
      ntv_ProgramUniform4uiv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4uiv_3(&program, location, count, value);
    
    private ProgramUniformMatrix2fv_adr := GetProcAddress('glProgramUniformMatrix2fv');
    private ntv_ProgramUniformMatrix2fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix2fv_adr);
    private ntv_ProgramUniformMatrix2fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2f)>(ProgramUniformMatrix2fv_adr);
    private ntv_ProgramUniformMatrix2fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2f) :=
      ntv_ProgramUniformMatrix2fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix2fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2fv_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix3fv_adr := GetProcAddress('glProgramUniformMatrix3fv');
    private ntv_ProgramUniformMatrix3fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix3fv_adr);
    private ntv_ProgramUniformMatrix3fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3f)>(ProgramUniformMatrix3fv_adr);
    private ntv_ProgramUniformMatrix3fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3f) :=
      ntv_ProgramUniformMatrix3fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix3fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3fv_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix4fv_adr := GetProcAddress('glProgramUniformMatrix4fv');
    private ntv_ProgramUniformMatrix4fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix4fv_adr);
    private ntv_ProgramUniformMatrix4fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4f)>(ProgramUniformMatrix4fv_adr);
    private ntv_ProgramUniformMatrix4fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4f) :=
      ntv_ProgramUniformMatrix4fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix4fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4fv_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix2dv_adr := GetProcAddress('glProgramUniformMatrix2dv');
    private ntv_ProgramUniformMatrix2dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix2dv_adr);
    private ntv_ProgramUniformMatrix2dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2d)>(ProgramUniformMatrix2dv_adr);
    private ntv_ProgramUniformMatrix2dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2d) :=
      ntv_ProgramUniformMatrix2dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix2dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2dv_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix3dv_adr := GetProcAddress('glProgramUniformMatrix3dv');
    private ntv_ProgramUniformMatrix3dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix3dv_adr);
    private ntv_ProgramUniformMatrix3dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3d)>(ProgramUniformMatrix3dv_adr);
    private ntv_ProgramUniformMatrix3dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3d) :=
      ntv_ProgramUniformMatrix3dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix3dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3dv_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix4dv_adr := GetProcAddress('glProgramUniformMatrix4dv');
    private ntv_ProgramUniformMatrix4dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix4dv_adr);
    private ntv_ProgramUniformMatrix4dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4d)>(ProgramUniformMatrix4dv_adr);
    private ntv_ProgramUniformMatrix4dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4d) :=
      ntv_ProgramUniformMatrix4dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix4dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4dv_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix2x3fv_adr := GetProcAddress('glProgramUniformMatrix2x3fv');
    private ntv_ProgramUniformMatrix2x3fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix2x3fv_adr);
    private ntv_ProgramUniformMatrix2x3fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3f)>(ProgramUniformMatrix2x3fv_adr);
    private ntv_ProgramUniformMatrix2x3fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2x3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2x3fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2x3fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3f) :=
      ntv_ProgramUniformMatrix2x3fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix2x3fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2x3fv_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix3x2fv_adr := GetProcAddress('glProgramUniformMatrix3x2fv');
    private ntv_ProgramUniformMatrix3x2fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix3x2fv_adr);
    private ntv_ProgramUniformMatrix3x2fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2f)>(ProgramUniformMatrix3x2fv_adr);
    private ntv_ProgramUniformMatrix3x2fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3x2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3x2fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3x2fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2f) :=
      ntv_ProgramUniformMatrix3x2fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix3x2fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3x2fv_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix2x4fv_adr := GetProcAddress('glProgramUniformMatrix2x4fv');
    private ntv_ProgramUniformMatrix2x4fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix2x4fv_adr);
    private ntv_ProgramUniformMatrix2x4fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4f)>(ProgramUniformMatrix2x4fv_adr);
    private ntv_ProgramUniformMatrix2x4fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2x4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2x4fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2x4fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4f) :=
      ntv_ProgramUniformMatrix2x4fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix2x4fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2x4fv_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix4x2fv_adr := GetProcAddress('glProgramUniformMatrix4x2fv');
    private ntv_ProgramUniformMatrix4x2fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix4x2fv_adr);
    private ntv_ProgramUniformMatrix4x2fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2f)>(ProgramUniformMatrix4x2fv_adr);
    private ntv_ProgramUniformMatrix4x2fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4x2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4x2fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4x2fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2f) :=
      ntv_ProgramUniformMatrix4x2fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix4x2fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4x2fv_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix3x4fv_adr := GetProcAddress('glProgramUniformMatrix3x4fv');
    private ntv_ProgramUniformMatrix3x4fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix3x4fv_adr);
    private ntv_ProgramUniformMatrix3x4fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4f)>(ProgramUniformMatrix3x4fv_adr);
    private ntv_ProgramUniformMatrix3x4fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3x4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3x4fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3x4fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4f) :=
      ntv_ProgramUniformMatrix3x4fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix3x4fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3x4fv_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix4x3fv_adr := GetProcAddress('glProgramUniformMatrix4x3fv');
    private ntv_ProgramUniformMatrix4x3fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix4x3fv_adr);
    private ntv_ProgramUniformMatrix4x3fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3f)>(ProgramUniformMatrix4x3fv_adr);
    private ntv_ProgramUniformMatrix4x3fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4x3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4x3fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4x3fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3f) :=
      ntv_ProgramUniformMatrix4x3fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix4x3fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4x3fv_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix2x3dv_adr := GetProcAddress('glProgramUniformMatrix2x3dv');
    private ntv_ProgramUniformMatrix2x3dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix2x3dv_adr);
    private ntv_ProgramUniformMatrix2x3dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3d)>(ProgramUniformMatrix2x3dv_adr);
    private ntv_ProgramUniformMatrix2x3dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2x3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2x3dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2x3dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3d) :=
      ntv_ProgramUniformMatrix2x3dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix2x3dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2x3dv_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix3x2dv_adr := GetProcAddress('glProgramUniformMatrix3x2dv');
    private ntv_ProgramUniformMatrix3x2dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix3x2dv_adr);
    private ntv_ProgramUniformMatrix3x2dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2d)>(ProgramUniformMatrix3x2dv_adr);
    private ntv_ProgramUniformMatrix3x2dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3x2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3x2dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3x2dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2d) :=
      ntv_ProgramUniformMatrix3x2dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix3x2dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3x2dv_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix2x4dv_adr := GetProcAddress('glProgramUniformMatrix2x4dv');
    private ntv_ProgramUniformMatrix2x4dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix2x4dv_adr);
    private ntv_ProgramUniformMatrix2x4dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4d)>(ProgramUniformMatrix2x4dv_adr);
    private ntv_ProgramUniformMatrix2x4dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2x4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2x4dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2x4dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4d) :=
      ntv_ProgramUniformMatrix2x4dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix2x4dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2x4dv_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix4x2dv_adr := GetProcAddress('glProgramUniformMatrix4x2dv');
    private ntv_ProgramUniformMatrix4x2dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix4x2dv_adr);
    private ntv_ProgramUniformMatrix4x2dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2d)>(ProgramUniformMatrix4x2dv_adr);
    private ntv_ProgramUniformMatrix4x2dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4x2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4x2dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4x2dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2d) :=
      ntv_ProgramUniformMatrix4x2dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix4x2dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4x2dv_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix3x4dv_adr := GetProcAddress('glProgramUniformMatrix3x4dv');
    private ntv_ProgramUniformMatrix3x4dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix3x4dv_adr);
    private ntv_ProgramUniformMatrix3x4dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4d)>(ProgramUniformMatrix3x4dv_adr);
    private ntv_ProgramUniformMatrix3x4dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3x4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3x4dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3x4dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4d) :=
      ntv_ProgramUniformMatrix3x4dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix3x4dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3x4dv_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix4x3dv_adr := GetProcAddress('glProgramUniformMatrix4x3dv');
    private ntv_ProgramUniformMatrix4x3dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix4x3dv_adr);
    private ntv_ProgramUniformMatrix4x3dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3d)>(ProgramUniformMatrix4x3dv_adr);
    private ntv_ProgramUniformMatrix4x3dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4x3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4x3dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4x3dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3d) :=
      ntv_ProgramUniformMatrix4x3dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix4x3dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4x3dv_3(&program, location, count, transpose, value);
    
    private ValidateProgramPipeline_adr := GetProcAddress('glValidateProgramPipeline');
    private ntv_ValidateProgramPipeline_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline)>(ValidateProgramPipeline_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ValidateProgramPipeline(pipeline: gl_program_pipeline) :=
      ntv_ValidateProgramPipeline_1(pipeline);
    
    private GetProgramPipelineInfoLog_adr := GetProcAddress('glGetProgramPipelineInfoLog');
    private ntv_GetProgramPipelineInfoLog_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; bufSize: Int32; var length: Int32; infoLog: IntPtr)>(GetProgramPipelineInfoLog_adr);
    private ntv_GetProgramPipelineInfoLog_2 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; bufSize: Int32; length: IntPtr; infoLog: IntPtr)>(GetProgramPipelineInfoLog_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLog(pipeline: gl_program_pipeline; bufSize: Int32; var length: Int32; infoLog: IntPtr) :=
      ntv_GetProgramPipelineInfoLog_1(pipeline, bufSize, length, infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLog(pipeline: gl_program_pipeline; bufSize: Int32; length: IntPtr; infoLog: IntPtr) :=
      ntv_GetProgramPipelineInfoLog_2(pipeline, bufSize, length, infoLog);
    
  end;
  
  ///
  glShaderAtomicCounterOpsARB = static class
    public const _ExtStr = 'GL_ARB_shader_atomic_counter_ops';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glShaderAtomicCountersARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_shader_atomic_counters';
    
    private GetActiveAtomicCounterBufferiv_adr := GetProcAddress('glGetActiveAtomicCounterBufferiv');
    private ntv_GetActiveAtomicCounterBufferiv_1 := GetProcOrNil&<procedure(&program: gl_program; bufferIndex: UInt32; pname: glAtomicCounterBufferPName; var &params: Int32)>(GetActiveAtomicCounterBufferiv_adr);
    private ntv_GetActiveAtomicCounterBufferiv_2 := GetProcOrNil&<procedure(&program: gl_program; bufferIndex: UInt32; pname: glAtomicCounterBufferPName; &params: IntPtr)>(GetActiveAtomicCounterBufferiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAtomicCounterBufferiv(&program: gl_program; bufferIndex: UInt32; pname: glAtomicCounterBufferPName; var &params: Int32) :=
      ntv_GetActiveAtomicCounterBufferiv_1(&program, bufferIndex, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAtomicCounterBufferiv(&program: gl_program; bufferIndex: UInt32; pname: glAtomicCounterBufferPName; &params: IntPtr) :=
      ntv_GetActiveAtomicCounterBufferiv_2(&program, bufferIndex, pname, &params);
    
  end;
  
  ///
  glShaderBallotARB = static class
    public const _ExtStr = 'GL_ARB_shader_ballot';
  end;
  
  ///
  glShaderBitEncodingARB = static class
    public const _ExtStr = 'GL_ARB_shader_bit_encoding';
  end;
  
  ///
  glShaderClockARB = static class
    public const _ExtStr = 'GL_ARB_shader_clock';
  end;
  
  ///
  glShaderDrawParametersARB = static class
    public const _ExtStr = 'GL_ARB_shader_draw_parameters';
  end;
  
  ///
  glShaderGroupVoteARB = static class
    public const _ExtStr = 'GL_ARB_shader_group_vote';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glShaderImageLoadStoreARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_shader_image_load_store';
    
    private BindImageTexture_adr := GetProcAddress('glBindImageTexture');
    private ntv_BindImageTexture_1 := GetProcOrNil&<procedure(&unit: UInt32; texture: gl_texture; level: Int32; layered: glBool8; layer: Int32; access: glBufferAccess; format: glInternalFormat)>(BindImageTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTexture(&unit: UInt32; texture: gl_texture; level: Int32; layered: glBool8; layer: Int32; access: glBufferAccess; format: glInternalFormat) :=
      ntv_BindImageTexture_1(&unit, texture, level, layered, layer, access, format);
    
    private MemoryBarrier_adr := GetProcAddress('glMemoryBarrier');
    private ntv_MemoryBarrier_1 := GetProcOrNil&<procedure(barriers: glMemoryBarrierMask)>(MemoryBarrier_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryBarrier(barriers: glMemoryBarrierMask) :=
      ntv_MemoryBarrier_1(barriers);
    
  end;
  
  ///
  glShaderImageSizeARB = static class
    public const _ExtStr = 'GL_ARB_shader_image_size';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glShaderObjectsARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_shader_objects';
    
    private DeleteObjectARB_adr := GetProcAddress('glDeleteObjectARB');
    private ntv_DeleteObjectARB_1 := GetProcOrNil&<procedure(obj: gl_handle_ARB)>(DeleteObjectARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteObjectARB(obj: gl_handle_ARB) :=
      ntv_DeleteObjectARB_1(obj);
    
    private GetHandleARB_adr := GetProcAddress('glGetHandleARB');
    private ntv_GetHandleARB_1 := GetProcOrNil&<function(pname: glContainerType): gl_handle_ARB>(GetHandleARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetHandleARB(pname: glContainerType): gl_handle_ARB :=
      ntv_GetHandleARB_1(pname);
    
    private DetachObjectARB_adr := GetProcAddress('glDetachObjectARB');
    private ntv_DetachObjectARB_1 := GetProcOrNil&<procedure(containerObj: gl_handle_ARB; attachedObj: gl_handle_ARB)>(DetachObjectARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetachObjectARB(containerObj: gl_handle_ARB; attachedObj: gl_handle_ARB) :=
      ntv_DetachObjectARB_1(containerObj, attachedObj);
    
    private CreateShaderObjectARB_adr := GetProcAddress('glCreateShaderObjectARB');
    private ntv_CreateShaderObjectARB_1 := GetProcOrNil&<function(shaderType: glShaderType): gl_handle_ARB>(CreateShaderObjectARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderObjectARB(shaderType: glShaderType): gl_handle_ARB :=
      ntv_CreateShaderObjectARB_1(shaderType);
    
    private ShaderSourceARB_adr := GetProcAddress('glShaderSourceARB');
    private ntv_ShaderSourceARB_1 := GetProcOrNil&<procedure(shaderObj: gl_handle_ARB; count: Int32; var string: IntPtr; var length: Int32)>(ShaderSourceARB_adr);
    private ntv_ShaderSourceARB_2 := GetProcOrNil&<procedure(shaderObj: gl_handle_ARB; count: Int32; string: pointer; var length: Int32)>(ShaderSourceARB_adr);
    private ntv_ShaderSourceARB_3 := GetProcOrNil&<procedure(shaderObj: gl_handle_ARB; count: Int32; var string: IntPtr; length: IntPtr)>(ShaderSourceARB_adr);
    private ntv_ShaderSourceARB_4 := GetProcOrNil&<procedure(shaderObj: gl_handle_ARB; count: Int32; string: pointer; length: IntPtr)>(ShaderSourceARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: gl_handle_ARB; count: Int32; string: array of string; length: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (string=nil) or (string.Length=0) then
      begin
        if (length<>nil) and (length.Length<>0) then
          ntv_ShaderSourceARB_2(shaderObj, count, nil, length[0]) else
          ntv_ShaderSourceARB_2(shaderObj, count, nil, PInt32(nil)^);
        exit;
      end;
      var string_temp_arr: array of IntPtr;
      try
        begin
          var string_org_el_1 := string;
          var string_len_1 := string_org_el_1.Length;
          SetLength(string_temp_arr, string_len_1);
          var string_tmp_el_1 := string_temp_arr;
          for var string_ind_1 := 0 to string_len_1-1 do
          begin
            var string_org_el_2 := string_org_el_1[string_ind_1];
            if (string_org_el_2=nil) or (string_org_el_2.Length=0) then continue;
            string_tmp_el_1[string_ind_1] := Marshal.StringToHGlobalAnsi(string_org_el_2);
          end;
        end;
        if (length<>nil) and (length.Length<>0) then
          ntv_ShaderSourceARB_1(shaderObj, count, string_temp_arr[0], length[0]) else
          ntv_ShaderSourceARB_1(shaderObj, count, string_temp_arr[0], PInt32(nil)^);
      finally
         foreach var arr_el1 in string_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: gl_handle_ARB; count: Int32; var string: IntPtr; var length: Int32) :=
      ntv_ShaderSourceARB_1(shaderObj, count, string, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: gl_handle_ARB; count: Int32; var string: IntPtr; length: IntPtr) :=
      ntv_ShaderSourceARB_3(shaderObj, count, string, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: gl_handle_ARB; count: Int32; string: pointer; var length: Int32) :=
      ntv_ShaderSourceARB_2(shaderObj, count, string, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: gl_handle_ARB; count: Int32; string: pointer; length: IntPtr) :=
      ntv_ShaderSourceARB_4(shaderObj, count, string, length);
    
    private CompileShaderARB_adr := GetProcAddress('glCompileShaderARB');
    private ntv_CompileShaderARB_1 := GetProcOrNil&<procedure(shaderObj: gl_handle_ARB)>(CompileShaderARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderARB(shaderObj: gl_handle_ARB) :=
      ntv_CompileShaderARB_1(shaderObj);
    
    private CreateProgramObjectARB_adr := GetProcAddress('glCreateProgramObjectARB');
    private ntv_CreateProgramObjectARB_1 := GetProcOrNil&<function: gl_handle_ARB>(CreateProgramObjectARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateProgramObjectARB: gl_handle_ARB :=
      ntv_CreateProgramObjectARB_1;
    
    private AttachObjectARB_adr := GetProcAddress('glAttachObjectARB');
    private ntv_AttachObjectARB_1 := GetProcOrNil&<procedure(containerObj: gl_handle_ARB; obj: gl_handle_ARB)>(AttachObjectARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AttachObjectARB(containerObj: gl_handle_ARB; obj: gl_handle_ARB) :=
      ntv_AttachObjectARB_1(containerObj, obj);
    
    private LinkProgramARB_adr := GetProcAddress('glLinkProgramARB');
    private ntv_LinkProgramARB_1 := GetProcOrNil&<procedure(programObj: gl_handle_ARB)>(LinkProgramARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LinkProgramARB(programObj: gl_handle_ARB) :=
      ntv_LinkProgramARB_1(programObj);
    
    private UseProgramObjectARB_adr := GetProcAddress('glUseProgramObjectARB');
    private ntv_UseProgramObjectARB_1 := GetProcOrNil&<procedure(programObj: gl_handle_ARB)>(UseProgramObjectARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseProgramObjectARB(programObj: gl_handle_ARB) :=
      ntv_UseProgramObjectARB_1(programObj);
    
    private ValidateProgramARB_adr := GetProcAddress('glValidateProgramARB');
    private ntv_ValidateProgramARB_1 := GetProcOrNil&<procedure(programObj: gl_handle_ARB)>(ValidateProgramARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ValidateProgramARB(programObj: gl_handle_ARB) :=
      ntv_ValidateProgramARB_1(programObj);
    
    private Uniform1fARB_adr := GetProcAddress('glUniform1fARB');
    private ntv_Uniform1fARB_1 := GetProcOrNil&<procedure(location: Int32; v0: single)>(Uniform1fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fARB(location: Int32; v0: single) :=
      ntv_Uniform1fARB_1(location, v0);
    
    private Uniform2fARB_adr := GetProcAddress('glUniform2fARB');
    private ntv_Uniform2fARB_1 := GetProcOrNil&<procedure(location: Int32; v0: single; v1: single)>(Uniform2fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fARB(location: Int32; v0: single; v1: single) :=
      ntv_Uniform2fARB_1(location, v0, v1);
    
    private Uniform3fARB_adr := GetProcAddress('glUniform3fARB');
    private ntv_Uniform3fARB_1 := GetProcOrNil&<procedure(location: Int32; v0: single; v1: single; v2: single)>(Uniform3fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fARB(location: Int32; v0: single; v1: single; v2: single) :=
      ntv_Uniform3fARB_1(location, v0, v1, v2);
    
    private Uniform4fARB_adr := GetProcAddress('glUniform4fARB');
    private ntv_Uniform4fARB_1 := GetProcOrNil&<procedure(location: Int32; v0: single; v1: single; v2: single; v3: single)>(Uniform4fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fARB(location: Int32; v0: single; v1: single; v2: single; v3: single) :=
      ntv_Uniform4fARB_1(location, v0, v1, v2, v3);
    
    private Uniform1iARB_adr := GetProcAddress('glUniform1iARB');
    private ntv_Uniform1iARB_1 := GetProcOrNil&<procedure(location: Int32; v0: Int32)>(Uniform1iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1iARB(location: Int32; v0: Int32) :=
      ntv_Uniform1iARB_1(location, v0);
    
    private Uniform2iARB_adr := GetProcAddress('glUniform2iARB');
    private ntv_Uniform2iARB_1 := GetProcOrNil&<procedure(location: Int32; v0: Int32; v1: Int32)>(Uniform2iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2iARB(location: Int32; v0: Int32; v1: Int32) :=
      ntv_Uniform2iARB_1(location, v0, v1);
    
    private Uniform3iARB_adr := GetProcAddress('glUniform3iARB');
    private ntv_Uniform3iARB_1 := GetProcOrNil&<procedure(location: Int32; v0: Int32; v1: Int32; v2: Int32)>(Uniform3iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3iARB(location: Int32; v0: Int32; v1: Int32; v2: Int32) :=
      ntv_Uniform3iARB_1(location, v0, v1, v2);
    
    private Uniform4iARB_adr := GetProcAddress('glUniform4iARB');
    private ntv_Uniform4iARB_1 := GetProcOrNil&<procedure(location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32)>(Uniform4iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4iARB(location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32) :=
      ntv_Uniform4iARB_1(location, v0, v1, v2, v3);
    
    private Uniform1fvARB_adr := GetProcAddress('glUniform1fvARB');
    private ntv_Uniform1fvARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: single)>(Uniform1fvARB_adr);
    private ntv_Uniform1fvARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform1fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fvARB(location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform1fvARB_1(location, count, value[0]) else
        ntv_Uniform1fvARB_1(location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fvARB(location: Int32; count: Int32; var value: single) :=
      ntv_Uniform1fvARB_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fvARB(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform1fvARB_2(location, count, value);
    
    private Uniform2fvARB_adr := GetProcAddress('glUniform2fvARB');
    private ntv_Uniform2fvARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: single)>(Uniform2fvARB_adr);
    private ntv_Uniform2fvARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2f)>(Uniform2fvARB_adr);
    private ntv_Uniform2fvARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform2fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fvARB(location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform2fvARB_1(location, count, value[0]) else
        ntv_Uniform2fvARB_1(location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fvARB(location: Int32; count: Int32; var value: Vec2f) :=
      ntv_Uniform2fvARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fvARB(location: Int32; count: Int32; var value: single) :=
      ntv_Uniform2fvARB_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fvARB(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform2fvARB_3(location, count, value);
    
    private Uniform3fvARB_adr := GetProcAddress('glUniform3fvARB');
    private ntv_Uniform3fvARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: single)>(Uniform3fvARB_adr);
    private ntv_Uniform3fvARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3f)>(Uniform3fvARB_adr);
    private ntv_Uniform3fvARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform3fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fvARB(location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform3fvARB_1(location, count, value[0]) else
        ntv_Uniform3fvARB_1(location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fvARB(location: Int32; count: Int32; var value: Vec3f) :=
      ntv_Uniform3fvARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fvARB(location: Int32; count: Int32; var value: single) :=
      ntv_Uniform3fvARB_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fvARB(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform3fvARB_3(location, count, value);
    
    private Uniform4fvARB_adr := GetProcAddress('glUniform4fvARB');
    private ntv_Uniform4fvARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: single)>(Uniform4fvARB_adr);
    private ntv_Uniform4fvARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4f)>(Uniform4fvARB_adr);
    private ntv_Uniform4fvARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fvARB(location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform4fvARB_1(location, count, value[0]) else
        ntv_Uniform4fvARB_1(location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fvARB(location: Int32; count: Int32; var value: Vec4f) :=
      ntv_Uniform4fvARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fvARB(location: Int32; count: Int32; var value: single) :=
      ntv_Uniform4fvARB_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fvARB(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform4fvARB_3(location, count, value);
    
    private Uniform1ivARB_adr := GetProcAddress('glUniform1ivARB');
    private ntv_Uniform1ivARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int32)>(Uniform1ivARB_adr);
    private ntv_Uniform1ivARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform1ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ivARB(location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform1ivARB_1(location, count, value[0]) else
        ntv_Uniform1ivARB_1(location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ivARB(location: Int32; count: Int32; var value: Int32) :=
      ntv_Uniform1ivARB_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ivARB(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform1ivARB_2(location, count, value);
    
    private Uniform2ivARB_adr := GetProcAddress('glUniform2ivARB');
    private ntv_Uniform2ivARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int32)>(Uniform2ivARB_adr);
    private ntv_Uniform2ivARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2i)>(Uniform2ivARB_adr);
    private ntv_Uniform2ivARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform2ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ivARB(location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform2ivARB_1(location, count, value[0]) else
        ntv_Uniform2ivARB_1(location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ivARB(location: Int32; count: Int32; var value: Vec2i) :=
      ntv_Uniform2ivARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ivARB(location: Int32; count: Int32; var value: Int32) :=
      ntv_Uniform2ivARB_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ivARB(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform2ivARB_3(location, count, value);
    
    private Uniform3ivARB_adr := GetProcAddress('glUniform3ivARB');
    private ntv_Uniform3ivARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int32)>(Uniform3ivARB_adr);
    private ntv_Uniform3ivARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3i)>(Uniform3ivARB_adr);
    private ntv_Uniform3ivARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform3ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ivARB(location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform3ivARB_1(location, count, value[0]) else
        ntv_Uniform3ivARB_1(location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ivARB(location: Int32; count: Int32; var value: Vec3i) :=
      ntv_Uniform3ivARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ivARB(location: Int32; count: Int32; var value: Int32) :=
      ntv_Uniform3ivARB_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ivARB(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform3ivARB_3(location, count, value);
    
    private Uniform4ivARB_adr := GetProcAddress('glUniform4ivARB');
    private ntv_Uniform4ivARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int32)>(Uniform4ivARB_adr);
    private ntv_Uniform4ivARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4i)>(Uniform4ivARB_adr);
    private ntv_Uniform4ivARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform4ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ivARB(location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform4ivARB_1(location, count, value[0]) else
        ntv_Uniform4ivARB_1(location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ivARB(location: Int32; count: Int32; var value: Vec4i) :=
      ntv_Uniform4ivARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ivARB(location: Int32; count: Int32; var value: Int32) :=
      ntv_Uniform4ivARB_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ivARB(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform4ivARB_3(location, count, value);
    
    private UniformMatrix2fvARB_adr := GetProcAddress('glUniformMatrix2fvARB');
    private ntv_UniformMatrix2fvARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: single)>(UniformMatrix2fvARB_adr);
    private ntv_UniformMatrix2fvARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2f)>(UniformMatrix2fvARB_adr);
    private ntv_UniformMatrix2fvARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix2fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fvARB(location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix2fvARB_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix2fvARB_1(location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fvARB(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2f) :=
      ntv_UniformMatrix2fvARB_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fvARB(location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_UniformMatrix2fvARB_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fvARB(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix2fvARB_3(location, count, transpose, value);
    
    private UniformMatrix3fvARB_adr := GetProcAddress('glUniformMatrix3fvARB');
    private ntv_UniformMatrix3fvARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: single)>(UniformMatrix3fvARB_adr);
    private ntv_UniformMatrix3fvARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3f)>(UniformMatrix3fvARB_adr);
    private ntv_UniformMatrix3fvARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix3fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fvARB(location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix3fvARB_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix3fvARB_1(location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fvARB(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3f) :=
      ntv_UniformMatrix3fvARB_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fvARB(location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_UniformMatrix3fvARB_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fvARB(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix3fvARB_3(location, count, transpose, value);
    
    private UniformMatrix4fvARB_adr := GetProcAddress('glUniformMatrix4fvARB');
    private ntv_UniformMatrix4fvARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: single)>(UniformMatrix4fvARB_adr);
    private ntv_UniformMatrix4fvARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4f)>(UniformMatrix4fvARB_adr);
    private ntv_UniformMatrix4fvARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fvARB(location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix4fvARB_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix4fvARB_1(location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fvARB(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4f) :=
      ntv_UniformMatrix4fvARB_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fvARB(location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_UniformMatrix4fvARB_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fvARB(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix4fvARB_3(location, count, transpose, value);
    
    private GetObjectParameterfvARB_adr := GetProcAddress('glGetObjectParameterfvARB');
    private ntv_GetObjectParameterfvARB_1 := GetProcOrNil&<procedure(obj: gl_handle_ARB; pname: DummyEnum; var &params: single)>(GetObjectParameterfvARB_adr);
    private ntv_GetObjectParameterfvARB_2 := GetProcOrNil&<procedure(obj: gl_handle_ARB; pname: DummyEnum; &params: IntPtr)>(GetObjectParameterfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterfvARB(obj: gl_handle_ARB; pname: DummyEnum; var &params: single) :=
      ntv_GetObjectParameterfvARB_1(obj, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterfvARB(obj: gl_handle_ARB; pname: DummyEnum; &params: IntPtr) :=
      ntv_GetObjectParameterfvARB_2(obj, pname, &params);
    
    private GetObjectParameterivARB_adr := GetProcAddress('glGetObjectParameterivARB');
    private ntv_GetObjectParameterivARB_1 := GetProcOrNil&<procedure(obj: gl_handle_ARB; pname: DummyEnum; var &params: Int32)>(GetObjectParameterivARB_adr);
    private ntv_GetObjectParameterivARB_2 := GetProcOrNil&<procedure(obj: gl_handle_ARB; pname: DummyEnum; &params: IntPtr)>(GetObjectParameterivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterivARB(obj: gl_handle_ARB; pname: DummyEnum; var &params: Int32) :=
      ntv_GetObjectParameterivARB_1(obj, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterivARB(obj: gl_handle_ARB; pname: DummyEnum; &params: IntPtr) :=
      ntv_GetObjectParameterivARB_2(obj, pname, &params);
    
    private GetInfoLogARB_adr := GetProcAddress('glGetInfoLogARB');
    private ntv_GetInfoLogARB_1 := GetProcOrNil&<procedure(obj: gl_handle_ARB; maxLength: Int32; var length: Int32; infoLog: IntPtr)>(GetInfoLogARB_adr);
    private ntv_GetInfoLogARB_2 := GetProcOrNil&<procedure(obj: gl_handle_ARB; maxLength: Int32; length: IntPtr; infoLog: IntPtr)>(GetInfoLogARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: gl_handle_ARB; maxLength: Int32; var length: Int32; infoLog: IntPtr) :=
      ntv_GetInfoLogARB_1(obj, maxLength, length, infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: gl_handle_ARB; maxLength: Int32; length: IntPtr; infoLog: IntPtr) :=
      ntv_GetInfoLogARB_2(obj, maxLength, length, infoLog);
    
    private GetAttachedObjectsARB_adr := GetProcAddress('glGetAttachedObjectsARB');
    private ntv_GetAttachedObjectsARB_1 := GetProcOrNil&<procedure(containerObj: gl_handle_ARB; maxCount: Int32; var count: Int32; var obj: gl_handle_ARB)>(GetAttachedObjectsARB_adr);
    private ntv_GetAttachedObjectsARB_2 := GetProcOrNil&<procedure(containerObj: gl_handle_ARB; maxCount: Int32; var count: Int32; obj: IntPtr)>(GetAttachedObjectsARB_adr);
    private ntv_GetAttachedObjectsARB_3 := GetProcOrNil&<procedure(containerObj: gl_handle_ARB; maxCount: Int32; count: IntPtr; var obj: gl_handle_ARB)>(GetAttachedObjectsARB_adr);
    private ntv_GetAttachedObjectsARB_4 := GetProcOrNil&<procedure(containerObj: gl_handle_ARB; maxCount: Int32; count: IntPtr; obj: IntPtr)>(GetAttachedObjectsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: gl_handle_ARB; maxCount: Int32; var count: Int32; var obj: gl_handle_ARB) :=
      ntv_GetAttachedObjectsARB_1(containerObj, maxCount, count, obj);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: gl_handle_ARB; maxCount: Int32; var count: Int32; obj: IntPtr) :=
      ntv_GetAttachedObjectsARB_2(containerObj, maxCount, count, obj);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: gl_handle_ARB; maxCount: Int32; count: IntPtr; var obj: gl_handle_ARB) :=
      ntv_GetAttachedObjectsARB_3(containerObj, maxCount, count, obj);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: gl_handle_ARB; maxCount: Int32; count: IntPtr; obj: IntPtr) :=
      ntv_GetAttachedObjectsARB_4(containerObj, maxCount, count, obj);
    
    private GetUniformLocationARB_adr := GetProcAddress('glGetUniformLocationARB');
    private ntv_GetUniformLocationARB_1 := GetProcOrNil&<function(programObj: gl_handle_ARB; name: IntPtr): Int32>(GetUniformLocationARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformLocationARB(programObj: gl_handle_ARB; name: string): Int32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetUniformLocationARB_1(programObj, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformLocationARB(programObj: gl_handle_ARB; name: IntPtr): Int32 :=
      ntv_GetUniformLocationARB_1(programObj, name);
    
    private GetActiveUniformARB_adr := GetProcAddress('glGetActiveUniformARB');
    private ntv_GetActiveUniformARB_1 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; var &type: glUniformType; name: IntPtr)>(GetActiveUniformARB_adr);
    private ntv_GetActiveUniformARB_2 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr)>(GetActiveUniformARB_adr);
    private ntv_GetActiveUniformARB_3 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; size: IntPtr; var &type: glUniformType; name: IntPtr)>(GetActiveUniformARB_adr);
    private ntv_GetActiveUniformARB_4 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr)>(GetActiveUniformARB_adr);
    private ntv_GetActiveUniformARB_5 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; var size: Int32; var &type: glUniformType; name: IntPtr)>(GetActiveUniformARB_adr);
    private ntv_GetActiveUniformARB_6 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr)>(GetActiveUniformARB_adr);
    private ntv_GetActiveUniformARB_7 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; size: IntPtr; var &type: glUniformType; name: IntPtr)>(GetActiveUniformARB_adr);
    private ntv_GetActiveUniformARB_8 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr)>(GetActiveUniformARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; var &type: glUniformType; name: IntPtr) :=
      ntv_GetActiveUniformARB_1(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveUniformARB_2(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; size: IntPtr; var &type: glUniformType; name: IntPtr) :=
      ntv_GetActiveUniformARB_3(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveUniformARB_4(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; var size: Int32; var &type: glUniformType; name: IntPtr) :=
      ntv_GetActiveUniformARB_5(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveUniformARB_6(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; size: IntPtr; var &type: glUniformType; name: IntPtr) :=
      ntv_GetActiveUniformARB_7(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveUniformARB_8(programObj, index, maxLength, length, size, &type, name);
    
    private GetUniformfvARB_adr := GetProcAddress('glGetUniformfvARB');
    private ntv_GetUniformfvARB_1 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; location: Int32; var &params: single)>(GetUniformfvARB_adr);
    private ntv_GetUniformfvARB_2 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; location: Int32; &params: IntPtr)>(GetUniformfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformfvARB(programObj: gl_handle_ARB; location: Int32; var &params: single) :=
      ntv_GetUniformfvARB_1(programObj, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformfvARB(programObj: gl_handle_ARB; location: Int32; &params: IntPtr) :=
      ntv_GetUniformfvARB_2(programObj, location, &params);
    
    private GetUniformivARB_adr := GetProcAddress('glGetUniformivARB');
    private ntv_GetUniformivARB_1 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; location: Int32; var &params: Int32)>(GetUniformivARB_adr);
    private ntv_GetUniformivARB_2 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; location: Int32; &params: IntPtr)>(GetUniformivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformivARB(programObj: gl_handle_ARB; location: Int32; var &params: Int32) :=
      ntv_GetUniformivARB_1(programObj, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformivARB(programObj: gl_handle_ARB; location: Int32; &params: IntPtr) :=
      ntv_GetUniformivARB_2(programObj, location, &params);
    
    private GetShaderSourceARB_adr := GetProcAddress('glGetShaderSourceARB');
    private ntv_GetShaderSourceARB_1 := GetProcOrNil&<procedure(obj: gl_handle_ARB; maxLength: Int32; var length: Int32; source: IntPtr)>(GetShaderSourceARB_adr);
    private ntv_GetShaderSourceARB_2 := GetProcOrNil&<procedure(obj: gl_handle_ARB; maxLength: Int32; length: IntPtr; source: IntPtr)>(GetShaderSourceARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSourceARB(obj: gl_handle_ARB; maxLength: Int32; var length: Int32; source: IntPtr) :=
      ntv_GetShaderSourceARB_1(obj, maxLength, length, source);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSourceARB(obj: gl_handle_ARB; maxLength: Int32; length: IntPtr; source: IntPtr) :=
      ntv_GetShaderSourceARB_2(obj, maxLength, length, source);
    
  end;
  
  ///
  glShaderPrecisionARB = static class
    public const _ExtStr = 'GL_ARB_shader_precision';
  end;
  
  ///
  glShaderStencilExportARB = static class
    public const _ExtStr = 'GL_ARB_shader_stencil_export';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glShaderStorageBufferObjectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_shader_storage_buffer_object';
    
    private ShaderStorageBlockBinding_adr := GetProcAddress('glShaderStorageBlockBinding');
    private ntv_ShaderStorageBlockBinding_1 := GetProcOrNil&<procedure(&program: gl_program; storageBlockIndex: UInt32; storageBlockBinding: UInt32)>(ShaderStorageBlockBinding_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderStorageBlockBinding(&program: gl_program; storageBlockIndex: UInt32; storageBlockBinding: UInt32) :=
      ntv_ShaderStorageBlockBinding_1(&program, storageBlockIndex, storageBlockBinding);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glShaderSubroutineARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_shader_subroutine';
    
    private GetSubroutineUniformLocation_adr := GetProcAddress('glGetSubroutineUniformLocation');
    private ntv_GetSubroutineUniformLocation_1 := GetProcOrNil&<function(&program: gl_program; shadertype: glShaderType; name: IntPtr): Int32>(GetSubroutineUniformLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineUniformLocation(&program: gl_program; shadertype: glShaderType; name: string): Int32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetSubroutineUniformLocation_1(&program, shadertype, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineUniformLocation(&program: gl_program; shadertype: glShaderType; name: IntPtr): Int32 :=
      ntv_GetSubroutineUniformLocation_1(&program, shadertype, name);
    
    private GetSubroutineIndex_adr := GetProcAddress('glGetSubroutineIndex');
    private ntv_GetSubroutineIndex_1 := GetProcOrNil&<function(&program: gl_program; shadertype: glShaderType; name: IntPtr): UInt32>(GetSubroutineIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineIndex(&program: gl_program; shadertype: glShaderType; name: string): UInt32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetSubroutineIndex_1(&program, shadertype, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineIndex(&program: gl_program; shadertype: glShaderType; name: IntPtr): UInt32 :=
      ntv_GetSubroutineIndex_1(&program, shadertype, name);
    
    private GetActiveSubroutineUniformiv_adr := GetProcAddress('glGetActiveSubroutineUniformiv');
    private ntv_GetActiveSubroutineUniformiv_1 := GetProcOrNil&<procedure(&program: gl_program; shadertype: glShaderType; index: UInt32; pname: glSubroutineParameterName; var values: Int32)>(GetActiveSubroutineUniformiv_adr);
    private ntv_GetActiveSubroutineUniformiv_2 := GetProcOrNil&<procedure(&program: gl_program; shadertype: glShaderType; index: UInt32; pname: glSubroutineParameterName; values: IntPtr)>(GetActiveSubroutineUniformiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformiv(&program: gl_program; shadertype: glShaderType; index: UInt32; pname: glSubroutineParameterName; var values: Int32) :=
      ntv_GetActiveSubroutineUniformiv_1(&program, shadertype, index, pname, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformiv(&program: gl_program; shadertype: glShaderType; index: UInt32; pname: glSubroutineParameterName; values: IntPtr) :=
      ntv_GetActiveSubroutineUniformiv_2(&program, shadertype, index, pname, values);
    
    private GetActiveSubroutineUniformName_adr := GetProcAddress('glGetActiveSubroutineUniformName');
    private ntv_GetActiveSubroutineUniformName_1 := GetProcOrNil&<procedure(&program: gl_program; shadertype: glShaderType; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr)>(GetActiveSubroutineUniformName_adr);
    private ntv_GetActiveSubroutineUniformName_2 := GetProcOrNil&<procedure(&program: gl_program; shadertype: glShaderType; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr)>(GetActiveSubroutineUniformName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformName(&program: gl_program; shadertype: glShaderType; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr) :=
      ntv_GetActiveSubroutineUniformName_1(&program, shadertype, index, bufSize, length, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformName(&program: gl_program; shadertype: glShaderType; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr) :=
      ntv_GetActiveSubroutineUniformName_2(&program, shadertype, index, bufSize, length, name);
    
    private GetActiveSubroutineName_adr := GetProcAddress('glGetActiveSubroutineName');
    private ntv_GetActiveSubroutineName_1 := GetProcOrNil&<procedure(&program: gl_program; shadertype: glShaderType; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr)>(GetActiveSubroutineName_adr);
    private ntv_GetActiveSubroutineName_2 := GetProcOrNil&<procedure(&program: gl_program; shadertype: glShaderType; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr)>(GetActiveSubroutineName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineName(&program: gl_program; shadertype: glShaderType; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr) :=
      ntv_GetActiveSubroutineName_1(&program, shadertype, index, bufSize, length, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineName(&program: gl_program; shadertype: glShaderType; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr) :=
      ntv_GetActiveSubroutineName_2(&program, shadertype, index, bufSize, length, name);
    
    private UniformSubroutinesuiv_adr := GetProcAddress('glUniformSubroutinesuiv');
    private ntv_UniformSubroutinesuiv_1 := GetProcOrNil&<procedure(shadertype: glShaderType; count: Int32; var indices: UInt32)>(UniformSubroutinesuiv_adr);
    private ntv_UniformSubroutinesuiv_2 := GetProcOrNil&<procedure(shadertype: glShaderType; count: Int32; indices: IntPtr)>(UniformSubroutinesuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformSubroutinesuiv(shadertype: glShaderType; count: Int32; indices: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (indices<>nil) and (indices.Length<>0) then
        ntv_UniformSubroutinesuiv_1(shadertype, count, indices[0]) else
        ntv_UniformSubroutinesuiv_1(shadertype, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformSubroutinesuiv(shadertype: glShaderType; count: Int32; var indices: UInt32) :=
      ntv_UniformSubroutinesuiv_1(shadertype, count, indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformSubroutinesuiv(shadertype: glShaderType; count: Int32; indices: IntPtr) :=
      ntv_UniformSubroutinesuiv_2(shadertype, count, indices);
    
    private GetUniformSubroutineuiv_adr := GetProcAddress('glGetUniformSubroutineuiv');
    private ntv_GetUniformSubroutineuiv_1 := GetProcOrNil&<procedure(shadertype: glShaderType; location: Int32; var &params: UInt32)>(GetUniformSubroutineuiv_adr);
    private ntv_GetUniformSubroutineuiv_2 := GetProcOrNil&<procedure(shadertype: glShaderType; location: Int32; &params: IntPtr)>(GetUniformSubroutineuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformSubroutineuiv(shadertype: glShaderType; location: Int32; var &params: UInt32) :=
      ntv_GetUniformSubroutineuiv_1(shadertype, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformSubroutineuiv(shadertype: glShaderType; location: Int32; &params: IntPtr) :=
      ntv_GetUniformSubroutineuiv_2(shadertype, location, &params);
    
    private GetProgramStageiv_adr := GetProcAddress('glGetProgramStageiv');
    private ntv_GetProgramStageiv_1 := GetProcOrNil&<procedure(&program: gl_program; shadertype: glShaderType; pname: glProgramStagePName; var values: Int32)>(GetProgramStageiv_adr);
    private ntv_GetProgramStageiv_2 := GetProcOrNil&<procedure(&program: gl_program; shadertype: glShaderType; pname: glProgramStagePName; values: IntPtr)>(GetProgramStageiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStageiv(&program: gl_program; shadertype: glShaderType; pname: glProgramStagePName; var values: Int32) :=
      ntv_GetProgramStageiv_1(&program, shadertype, pname, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStageiv(&program: gl_program; shadertype: glShaderType; pname: glProgramStagePName; values: IntPtr) :=
      ntv_GetProgramStageiv_2(&program, shadertype, pname, values);
    
  end;
  
  ///
  glShaderTextureImageSamplesARB = static class
    public const _ExtStr = 'GL_ARB_shader_texture_image_samples';
  end;
  
  ///
  glShaderTextureLodARB = static class
    public const _ExtStr = 'GL_ARB_shader_texture_lod';
  end;
  
  ///
  glShaderViewportLayerArrayARB = static class
    public const _ExtStr = 'GL_ARB_shader_viewport_layer_array';
  end;
  
  ///
  glShadingLanguage100ARB = static class
    public const _ExtStr = 'GL_ARB_shading_language_100';
  end;
  
  ///
  glShadingLanguage420packARB = static class
    public const _ExtStr = 'GL_ARB_shading_language_420pack';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glShadingLanguageIncludeARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_shading_language_include';
    
    private NamedStringARB_adr := GetProcAddress('glNamedStringARB');
    private ntv_NamedStringARB_1 := GetProcOrNil&<procedure(&type: DummyEnum; namelen: Int32; name: IntPtr; stringlen: Int32; string: IntPtr)>(NamedStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedStringARB(&type: DummyEnum; namelen: Int32; name: string; stringlen: Int32; string: string);
    begin
      var string_str_ptr := Marshal.StringToHGlobalAnsi(string);
      try
        NamedStringARB(&type, namelen, name, stringlen, string_str_ptr);
      finally
        Marshal.FreeHGlobal(string_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedStringARB(&type: DummyEnum; namelen: Int32; name: string; stringlen: Int32; string: IntPtr);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_NamedStringARB_1(&type, namelen, name_str_ptr, stringlen, string);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedStringARB(&type: DummyEnum; namelen: Int32; name: IntPtr; stringlen: Int32; string: string);
    begin
      var string_str_ptr := Marshal.StringToHGlobalAnsi(string);
      try
        ntv_NamedStringARB_1(&type, namelen, name, stringlen, string_str_ptr);
      finally
        Marshal.FreeHGlobal(string_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedStringARB(&type: DummyEnum; namelen: Int32; name: IntPtr; stringlen: Int32; string: IntPtr) :=
      ntv_NamedStringARB_1(&type, namelen, name, stringlen, string);
    
    private DeleteNamedStringARB_adr := GetProcAddress('glDeleteNamedStringARB');
    private ntv_DeleteNamedStringARB_1 := GetProcOrNil&<procedure(namelen: Int32; name: IntPtr)>(DeleteNamedStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamedStringARB(namelen: Int32; name: string);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_DeleteNamedStringARB_1(namelen, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamedStringARB(namelen: Int32; name: IntPtr) :=
      ntv_DeleteNamedStringARB_1(namelen, name);
    
    private CompileShaderIncludeARB_adr := GetProcAddress('glCompileShaderIncludeARB');
    private ntv_CompileShaderIncludeARB_1 := GetProcOrNil&<procedure(shader: gl_shader; count: Int32; var path: IntPtr; var length: Int32)>(CompileShaderIncludeARB_adr);
    private ntv_CompileShaderIncludeARB_2 := GetProcOrNil&<procedure(shader: gl_shader; count: Int32; path: pointer; var length: Int32)>(CompileShaderIncludeARB_adr);
    private ntv_CompileShaderIncludeARB_3 := GetProcOrNil&<procedure(shader: gl_shader; count: Int32; var path: IntPtr; length: IntPtr)>(CompileShaderIncludeARB_adr);
    private ntv_CompileShaderIncludeARB_4 := GetProcOrNil&<procedure(shader: gl_shader; count: Int32; path: pointer; length: IntPtr)>(CompileShaderIncludeARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: gl_shader; count: Int32; path: array of string; length: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (path=nil) or (path.Length=0) then
      begin
        if (length<>nil) and (length.Length<>0) then
          ntv_CompileShaderIncludeARB_2(shader, count, nil, length[0]) else
          ntv_CompileShaderIncludeARB_2(shader, count, nil, PInt32(nil)^);
        exit;
      end;
      var path_temp_arr: array of IntPtr;
      try
        begin
          var path_org_el_1 := path;
          var path_len_1 := path_org_el_1.Length;
          SetLength(path_temp_arr, path_len_1);
          var path_tmp_el_1 := path_temp_arr;
          for var path_ind_1 := 0 to path_len_1-1 do
          begin
            var path_org_el_2 := path_org_el_1[path_ind_1];
            if (path_org_el_2=nil) or (path_org_el_2.Length=0) then continue;
            path_tmp_el_1[path_ind_1] := Marshal.StringToHGlobalAnsi(path_org_el_2);
          end;
        end;
        if (length<>nil) and (length.Length<>0) then
          ntv_CompileShaderIncludeARB_1(shader, count, path_temp_arr[0], length[0]) else
          ntv_CompileShaderIncludeARB_1(shader, count, path_temp_arr[0], PInt32(nil)^);
      finally
         foreach var arr_el1 in path_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: gl_shader; count: Int32; var path: IntPtr; var length: Int32) :=
      ntv_CompileShaderIncludeARB_1(shader, count, path, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: gl_shader; count: Int32; var path: IntPtr; length: IntPtr) :=
      ntv_CompileShaderIncludeARB_3(shader, count, path, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: gl_shader; count: Int32; path: pointer; var length: Int32) :=
      ntv_CompileShaderIncludeARB_2(shader, count, path, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: gl_shader; count: Int32; path: pointer; length: IntPtr) :=
      ntv_CompileShaderIncludeARB_4(shader, count, path, length);
    
    private IsNamedStringARB_adr := GetProcAddress('glIsNamedStringARB');
    private ntv_IsNamedStringARB_1 := GetProcOrNil&<function(namelen: Int32; name: IntPtr): glBool8>(IsNamedStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsNamedStringARB(namelen: Int32; name: string): glBool8;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_IsNamedStringARB_1(namelen, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsNamedStringARB(namelen: Int32; name: IntPtr): glBool8 :=
      ntv_IsNamedStringARB_1(namelen, name);
    
    private GetNamedStringARB_adr := GetProcAddress('glGetNamedStringARB');
    private ntv_GetNamedStringARB_1 := GetProcOrNil&<procedure(namelen: Int32; name: IntPtr; bufSize: Int32; var stringlen: Int32; string: IntPtr)>(GetNamedStringARB_adr);
    private ntv_GetNamedStringARB_2 := GetProcOrNil&<procedure(namelen: Int32; name: IntPtr; bufSize: Int32; stringlen: IntPtr; string: IntPtr)>(GetNamedStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: string; bufSize: Int32; var stringlen: Int32; string: IntPtr);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_GetNamedStringARB_1(namelen, name_str_ptr, bufSize, stringlen, string);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: string; bufSize: Int32; stringlen: IntPtr; string: IntPtr);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_GetNamedStringARB_2(namelen, name_str_ptr, bufSize, stringlen, string);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: IntPtr; bufSize: Int32; var stringlen: Int32; string: IntPtr) :=
      ntv_GetNamedStringARB_1(namelen, name, bufSize, stringlen, string);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: IntPtr; bufSize: Int32; stringlen: IntPtr; string: IntPtr) :=
      ntv_GetNamedStringARB_2(namelen, name, bufSize, stringlen, string);
    
    private GetNamedStringivARB_adr := GetProcAddress('glGetNamedStringivARB');
    private ntv_GetNamedStringivARB_1 := GetProcOrNil&<procedure(namelen: Int32; name: IntPtr; pname: DummyEnum; var &params: Int32)>(GetNamedStringivARB_adr);
    private ntv_GetNamedStringivARB_2 := GetProcOrNil&<procedure(namelen: Int32; name: IntPtr; pname: DummyEnum; &params: IntPtr)>(GetNamedStringivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: string; pname: DummyEnum; var &params: Int32);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_GetNamedStringivARB_1(namelen, name_str_ptr, pname, &params);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: string; pname: DummyEnum; &params: IntPtr);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_GetNamedStringivARB_2(namelen, name_str_ptr, pname, &params);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: IntPtr; pname: DummyEnum; var &params: Int32) :=
      ntv_GetNamedStringivARB_1(namelen, name, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: IntPtr; pname: DummyEnum; &params: IntPtr) :=
      ntv_GetNamedStringivARB_2(namelen, name, pname, &params);
    
  end;
  
  ///
  glShadingLanguagePackingARB = static class
    public const _ExtStr = 'GL_ARB_shading_language_packing';
  end;
  
  ///
  glShadowARB = static class
    public const _ExtStr = 'GL_ARB_shadow';
  end;
  
  ///
  glShadowAmbientARB = static class
    public const _ExtStr = 'GL_ARB_shadow_ambient';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSparseBufferARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_sparse_buffer';
    
    private BufferPageCommitmentARB_adr := GetProcAddress('glBufferPageCommitmentARB');
    private ntv_BufferPageCommitmentARB_1 := GetProcOrNil&<procedure(target: DummyEnum; offset: IntPtr; size: UIntPtr; commit: glBool8)>(BufferPageCommitmentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferPageCommitmentARB(target: DummyEnum; offset: IntPtr; size: UIntPtr; commit: glBool8) :=
      ntv_BufferPageCommitmentARB_1(target, offset, size, commit);
    
    private NamedBufferPageCommitmentEXT_adr := GetProcAddress('glNamedBufferPageCommitmentEXT');
    private ntv_NamedBufferPageCommitmentEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; commit: glBool8)>(NamedBufferPageCommitmentEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferPageCommitmentEXT(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; commit: glBool8) :=
      ntv_NamedBufferPageCommitmentEXT_1(buffer, offset, size, commit);
    
    private NamedBufferPageCommitmentARB_adr := GetProcAddress('glNamedBufferPageCommitmentARB');
    private ntv_NamedBufferPageCommitmentARB_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; commit: glBool8)>(NamedBufferPageCommitmentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferPageCommitmentARB(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; commit: glBool8) :=
      ntv_NamedBufferPageCommitmentARB_1(buffer, offset, size, commit);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSparseTextureARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_sparse_texture';
    
    private TexPageCommitmentARB_adr := GetProcAddress('glTexPageCommitmentARB');
    private ntv_TexPageCommitmentARB_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: glBool8)>(TexPageCommitmentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexPageCommitmentARB(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: glBool8) :=
      ntv_TexPageCommitmentARB_1(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    
  end;
  
  ///
  glSparseTextureClampARB = static class
    public const _ExtStr = 'GL_ARB_sparse_texture_clamp';
  end;
  
  ///
  glSparseTexture2ARB = static class
    public const _ExtStr = 'GL_ARB_sparse_texture2';
  end;
  
  ///
  glSpirvExtensionsARB = static class
    public const _ExtStr = 'GL_ARB_spirv_extensions';
  end;
  
  ///
  glStencilTexturingARB = static class
    public const _ExtStr = 'GL_ARB_stencil_texturing';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSyncARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_sync';
    
    private FenceSync_adr := GetProcAddress('glFenceSync');
    private ntv_FenceSync_1 := GetProcOrNil&<function(condition: glSyncCondition; flags: glSyncBehaviorFlags): gl_sync>(FenceSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function FenceSync(condition: glSyncCondition; flags: glSyncBehaviorFlags): gl_sync :=
      ntv_FenceSync_1(condition, flags);
    
    private IsSync_adr := GetProcAddress('glIsSync');
    private ntv_IsSync_1 := GetProcOrNil&<function(sync: gl_sync): glBool8>(IsSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsSync(sync: gl_sync): glBool8 :=
      ntv_IsSync_1(sync);
    
    private DeleteSync_adr := GetProcAddress('glDeleteSync');
    private ntv_DeleteSync_1 := GetProcOrNil&<procedure(sync: gl_sync)>(DeleteSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSync(sync: gl_sync) :=
      ntv_DeleteSync_1(sync);
    
    private ClientWaitSync_adr := GetProcAddress('glClientWaitSync');
    private ntv_ClientWaitSync_1 := GetProcOrNil&<function(sync: gl_sync; flags: glSyncObjectMask; timeout: UInt64): glSyncStatus>(ClientWaitSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ClientWaitSync(sync: gl_sync; flags: glSyncObjectMask; timeout: UInt64): glSyncStatus :=
      ntv_ClientWaitSync_1(sync, flags, timeout);
    
    private WaitSync_adr := GetProcAddress('glWaitSync');
    private ntv_WaitSync_1 := GetProcOrNil&<procedure(sync: gl_sync; flags: glSyncBehaviorFlags; timeout: UInt64)>(WaitSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSync(sync: gl_sync; flags: glSyncBehaviorFlags; timeout: UInt64) :=
      ntv_WaitSync_1(sync, flags, timeout);
    
    private GetInteger64v_adr := GetProcAddress('glGetInteger64v');
    private ntv_GetInteger64v_1 := GetProcOrNil&<procedure(pname: glGetPName; var data: Int64)>(GetInteger64v_adr);
    private ntv_GetInteger64v_2 := GetProcOrNil&<procedure(pname: glGetPName; data: IntPtr)>(GetInteger64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64v(pname: glGetPName; var data: Int64) :=
      ntv_GetInteger64v_1(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64v(pname: glGetPName; data: IntPtr) :=
      ntv_GetInteger64v_2(pname, data);
    
    private GetSynciv_adr := GetProcAddress('glGetSynciv');
    private ntv_GetSynciv_1 := GetProcOrNil&<procedure(sync: gl_sync; pname: glSyncParameterName; count: Int32; var length: Int32; var values: Int32)>(GetSynciv_adr);
    private ntv_GetSynciv_2 := GetProcOrNil&<procedure(sync: gl_sync; pname: glSyncParameterName; count: Int32; var length: Int32; values: IntPtr)>(GetSynciv_adr);
    private ntv_GetSynciv_3 := GetProcOrNil&<procedure(sync: gl_sync; pname: glSyncParameterName; count: Int32; length: IntPtr; var values: Int32)>(GetSynciv_adr);
    private ntv_GetSynciv_4 := GetProcOrNil&<procedure(sync: gl_sync; pname: glSyncParameterName; count: Int32; length: IntPtr; values: IntPtr)>(GetSynciv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: gl_sync; pname: glSyncParameterName; count: Int32; var length: Int32; var values: Int32) :=
      ntv_GetSynciv_1(sync, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: gl_sync; pname: glSyncParameterName; count: Int32; var length: Int32; values: IntPtr) :=
      ntv_GetSynciv_2(sync, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: gl_sync; pname: glSyncParameterName; count: Int32; length: IntPtr; var values: Int32) :=
      ntv_GetSynciv_3(sync, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: gl_sync; pname: glSyncParameterName; count: Int32; length: IntPtr; values: IntPtr) :=
      ntv_GetSynciv_4(sync, pname, count, length, values);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTessellationShaderARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_tessellation_shader';
    
    private PatchParameteri_adr := GetProcAddress('glPatchParameteri');
    private ntv_PatchParameteri_1 := GetProcOrNil&<procedure(pname: glPatchParameterName; value: Int32)>(PatchParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameteri(pname: glPatchParameterName; value: Int32) :=
      ntv_PatchParameteri_1(pname, value);
    
    private PatchParameterfv_adr := GetProcAddress('glPatchParameterfv');
    private ntv_PatchParameterfv_1 := GetProcOrNil&<procedure(pname: glPatchParameterName; var values: single)>(PatchParameterfv_adr);
    private ntv_PatchParameterfv_2 := GetProcOrNil&<procedure(pname: glPatchParameterName; values: IntPtr)>(PatchParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameterfv(pname: glPatchParameterName; values: array of single);
    type PSingle = ^single;
    begin
      if (values<>nil) and (values.Length<>0) then
        ntv_PatchParameterfv_1(pname, values[0]) else
        ntv_PatchParameterfv_1(pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameterfv(pname: glPatchParameterName; var values: single) :=
      ntv_PatchParameterfv_1(pname, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameterfv(pname: glPatchParameterName; values: IntPtr) :=
      ntv_PatchParameterfv_2(pname, values);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureBarrierARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_texture_barrier';
    
    private TextureBarrier_adr := GetProcAddress('glTextureBarrier');
    private ntv_TextureBarrier_1 := GetProcOrNil&<procedure>(TextureBarrier_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBarrier :=
      ntv_TextureBarrier_1;
    
  end;
  
  ///
  glTextureBorderClampARB = static class
    public const _ExtStr = 'GL_ARB_texture_border_clamp';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureBufferObjectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_texture_buffer_object';
    
    private TexBufferARB_adr := GetProcAddress('glTexBufferARB');
    private ntv_TexBufferARB_1 := GetProcOrNil&<procedure(target: glTextureTarget; internalformat: glSizedInternalFormat; buffer: gl_buffer)>(TexBufferARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBufferARB(target: glTextureTarget; internalformat: glSizedInternalFormat; buffer: gl_buffer) :=
      ntv_TexBufferARB_1(target, internalformat, buffer);
    
  end;
  
  ///
  glTextureBufferObjectRgb32ARB = static class
    public const _ExtStr = 'GL_ARB_texture_buffer_object_rgb32';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureBufferRangeARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_texture_buffer_range';
    
    private TexBufferRange_adr := GetProcAddress('glTexBufferRange');
    private ntv_TexBufferRange_1 := GetProcOrNil&<procedure(target: glTextureTarget; internalformat: glSizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(TexBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBufferRange(target: glTextureTarget; internalformat: glSizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
      ntv_TexBufferRange_1(target, internalformat, buffer, offset, size);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureCompressionARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_texture_compression';
    
    private CompressedTexImage3DARB_adr := GetProcAddress('glCompressedTexImage3DARB');
    private ntv_CompressedTexImage3DARB_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: IntPtr)>(CompressedTexImage3DARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage3DARB(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTexImage3DARB_1(target, level, internalformat, width, height, depth, border, imageSize, data);
    
    private CompressedTexImage2DARB_adr := GetProcAddress('glCompressedTexImage2DARB');
    private ntv_CompressedTexImage2DARB_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: IntPtr)>(CompressedTexImage2DARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage2DARB(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTexImage2DARB_1(target, level, internalformat, width, height, border, imageSize, data);
    
    private CompressedTexImage1DARB_adr := GetProcAddress('glCompressedTexImage1DARB');
    private ntv_CompressedTexImage1DARB_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; border: Int32; imageSize: Int32; data: IntPtr)>(CompressedTexImage1DARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage1DARB(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; border: Int32; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTexImage1DARB_1(target, level, internalformat, width, border, imageSize, data);
    
    private CompressedTexSubImage3DARB_adr := GetProcAddress('glCompressedTexSubImage3DARB');
    private ntv_CompressedTexSubImage3DARB_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr)>(CompressedTexSubImage3DARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage3DARB(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTexSubImage3DARB_1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    
    private CompressedTexSubImage2DARB_adr := GetProcAddress('glCompressedTexSubImage2DARB');
    private ntv_CompressedTexSubImage2DARB_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr)>(CompressedTexSubImage2DARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage2DARB(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTexSubImage2DARB_1(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    
    private CompressedTexSubImage1DARB_adr := GetProcAddress('glCompressedTexSubImage1DARB');
    private ntv_CompressedTexSubImage1DARB_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; width: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr)>(CompressedTexSubImage1DARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage1DARB(target: glTextureTarget; level: Int32; xoffset: Int32; width: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTexSubImage1DARB_1(target, level, xoffset, width, format, imageSize, data);
    
    private GetCompressedTexImageARB_adr := GetProcAddress('glGetCompressedTexImageARB');
    private ntv_GetCompressedTexImageARB_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; img: IntPtr)>(GetCompressedTexImageARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTexImageARB(target: glTextureTarget; level: Int32; img: IntPtr) :=
      ntv_GetCompressedTexImageARB_1(target, level, img);
    
  end;
  
  ///
  glTextureCompressionBptcARB = static class
    public const _ExtStr = 'GL_ARB_texture_compression_bptc';
  end;
  
  ///
  glTextureCompressionRgtcARB = static class
    public const _ExtStr = 'GL_ARB_texture_compression_rgtc';
  end;
  
  ///
  glTextureCubeMapARB = static class
    public const _ExtStr = 'GL_ARB_texture_cube_map';
  end;
  
  ///
  glTextureCubeMapArrayARB = static class
    public const _ExtStr = 'GL_ARB_texture_cube_map_array';
  end;
  
  ///
  glTextureEnvAddARB = static class
    public const _ExtStr = 'GL_ARB_texture_env_add';
  end;
  
  ///
  glTextureEnvCombineARB = static class
    public const _ExtStr = 'GL_ARB_texture_env_combine';
  end;
  
  ///
  glTextureEnvCrossbarARB = static class
    public const _ExtStr = 'GL_ARB_texture_env_crossbar';
  end;
  
  ///
  glTextureEnvDot3ARB = static class
    public const _ExtStr = 'GL_ARB_texture_env_dot3';
  end;
  
  ///
  glTextureFilterAnisotropicARB = static class
    public const _ExtStr = 'GL_ARB_texture_filter_anisotropic';
  end;
  
  ///
  glTextureFilterMinmaxARB = static class
    public const _ExtStr = 'GL_ARB_texture_filter_minmax';
  end;
  
  ///
  glTextureFloatARB = static class
    public const _ExtStr = 'GL_ARB_texture_float';
  end;
  
  ///
  glTextureGatherARB = static class
    public const _ExtStr = 'GL_ARB_texture_gather';
  end;
  
  ///
  glTextureMirrorClampToEdgeARB = static class
    public const _ExtStr = 'GL_ARB_texture_mirror_clamp_to_edge';
  end;
  
  ///
  glTextureMirroredRepeatARB = static class
    public const _ExtStr = 'GL_ARB_texture_mirrored_repeat';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureMultisampleARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_texture_multisample';
    
    private TexImage2DMultisample_adr := GetProcAddress('glTexImage2DMultisample');
    private ntv_TexImage2DMultisample_1 := GetProcOrNil&<procedure(target: glTextureTarget; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; fixedsamplelocations: glBool8)>(TexImage2DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage2DMultisample(target: glTextureTarget; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; fixedsamplelocations: glBool8) :=
      ntv_TexImage2DMultisample_1(target, samples, internalformat, width, height, fixedsamplelocations);
    
    private TexImage3DMultisample_adr := GetProcAddress('glTexImage3DMultisample');
    private ntv_TexImage3DMultisample_1 := GetProcOrNil&<procedure(target: glTextureTarget; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: glBool8)>(TexImage3DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3DMultisample(target: glTextureTarget; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: glBool8) :=
      ntv_TexImage3DMultisample_1(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    
    private GetMultisamplefv_adr := GetProcAddress('glGetMultisamplefv');
    private ntv_GetMultisamplefv_1 := GetProcOrNil&<procedure(pname: glGetMultisamplePName; index: UInt32; var val: single)>(GetMultisamplefv_adr);
    private ntv_GetMultisamplefv_2 := GetProcOrNil&<procedure(pname: glGetMultisamplePName; index: UInt32; val: IntPtr)>(GetMultisamplefv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefv(pname: glGetMultisamplePName; index: UInt32; var val: single) :=
      ntv_GetMultisamplefv_1(pname, index, val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefv(pname: glGetMultisamplePName; index: UInt32; val: IntPtr) :=
      ntv_GetMultisamplefv_2(pname, index, val);
    
    private SampleMaski_adr := GetProcAddress('glSampleMaski');
    private ntv_SampleMaski_1 := GetProcOrNil&<procedure(maskNumber: UInt32; mask: DummyFlags)>(SampleMaski_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMaski(maskNumber: UInt32; mask: DummyFlags) :=
      ntv_SampleMaski_1(maskNumber, mask);
    
  end;
  
  ///
  glTextureNonPowerOfTwoARB = static class
    public const _ExtStr = 'GL_ARB_texture_non_power_of_two';
  end;
  
  ///
  glTextureQueryLevelsARB = static class
    public const _ExtStr = 'GL_ARB_texture_query_levels';
  end;
  
  ///
  glTextureQueryLodARB = static class
    public const _ExtStr = 'GL_ARB_texture_query_lod';
  end;
  
  ///
  glTextureRectangleARB = static class
    public const _ExtStr = 'GL_ARB_texture_rectangle';
  end;
  
  ///
  glTextureRgARB = static class
    public const _ExtStr = 'GL_ARB_texture_rg';
  end;
  
  ///
  glTextureRgb10A2uiARB = static class
    public const _ExtStr = 'GL_ARB_texture_rgb10_a2ui';
  end;
  
  ///
  glTextureStencil8ARB = static class
    public const _ExtStr = 'GL_ARB_texture_stencil8';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureStorageARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_texture_storage';
    
    private TexStorage1D_adr := GetProcAddress('glTexStorage1D');
    private ntv_TexStorage1D_1 := GetProcOrNil&<procedure(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32)>(TexStorage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage1D(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32) :=
      ntv_TexStorage1D_1(target, levels, internalformat, width);
    
    private TexStorage2D_adr := GetProcAddress('glTexStorage2D');
    private ntv_TexStorage2D_1 := GetProcOrNil&<procedure(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32)>(TexStorage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage2D(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32) :=
      ntv_TexStorage2D_1(target, levels, internalformat, width, height);
    
    private TexStorage3D_adr := GetProcAddress('glTexStorage3D');
    private ntv_TexStorage3D_1 := GetProcOrNil&<procedure(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32)>(TexStorage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage3D(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32) :=
      ntv_TexStorage3D_1(target, levels, internalformat, width, height, depth);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureStorageMultisampleARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_texture_storage_multisample';
    
    private TexStorage2DMultisample_adr := GetProcAddress('glTexStorage2DMultisample');
    private ntv_TexStorage2DMultisample_1 := GetProcOrNil&<procedure(target: glTextureTarget; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: glBool8)>(TexStorage2DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage2DMultisample(target: glTextureTarget; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: glBool8) :=
      ntv_TexStorage2DMultisample_1(target, samples, internalformat, width, height, fixedsamplelocations);
    
    private TexStorage3DMultisample_adr := GetProcAddress('glTexStorage3DMultisample');
    private ntv_TexStorage3DMultisample_1 := GetProcOrNil&<procedure(target: glTextureTarget; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: glBool8)>(TexStorage3DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage3DMultisample(target: glTextureTarget; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: glBool8) :=
      ntv_TexStorage3DMultisample_1(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    
  end;
  
  ///
  glTextureSwizzleARB = static class
    public const _ExtStr = 'GL_ARB_texture_swizzle';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureViewARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_texture_view';
    
    private TextureView_adr := GetProcAddress('glTextureView');
    private ntv_TextureView_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; origtexture: gl_texture; internalformat: glSizedInternalFormat; minlevel: UInt32; numlevels: UInt32; minlayer: UInt32; numlayers: UInt32)>(TextureView_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureView(texture: gl_texture; target: glTextureTarget; origtexture: gl_texture; internalformat: glSizedInternalFormat; minlevel: UInt32; numlevels: UInt32; minlayer: UInt32; numlayers: UInt32) :=
      ntv_TextureView_1(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTimerQueryARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_timer_query';
    
    private QueryCounter_adr := GetProcAddress('glQueryCounter');
    private ntv_QueryCounter_1 := GetProcOrNil&<procedure(id: gl_query; target: glQueryCounterTarget)>(QueryCounter_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryCounter(id: gl_query; target: glQueryCounterTarget) :=
      ntv_QueryCounter_1(id, target);
    
    private GetQueryObjecti64v_adr := GetProcAddress('glGetQueryObjecti64v');
    private ntv_GetQueryObjecti64v_1 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; var &params: Int64)>(GetQueryObjecti64v_adr);
    private ntv_GetQueryObjecti64v_2 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr)>(GetQueryObjecti64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjecti64v(id: gl_query; pname: glQueryObjectParameterName; var &params: Int64) :=
      ntv_GetQueryObjecti64v_1(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjecti64v(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr) :=
      ntv_GetQueryObjecti64v_2(id, pname, &params);
    
    private GetQueryObjectui64v_adr := GetProcAddress('glGetQueryObjectui64v');
    private ntv_GetQueryObjectui64v_1 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; var &params: UInt64)>(GetQueryObjectui64v_adr);
    private ntv_GetQueryObjectui64v_2 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr)>(GetQueryObjectui64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64v(id: gl_query; pname: glQueryObjectParameterName; var &params: UInt64) :=
      ntv_GetQueryObjectui64v_1(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64v(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr) :=
      ntv_GetQueryObjectui64v_2(id, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTransformFeedbackInstancedARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_transform_feedback_instanced';
    
    private DrawTransformFeedbackInstanced_adr := GetProcAddress('glDrawTransformFeedbackInstanced');
    private ntv_DrawTransformFeedbackInstanced_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; id: gl_transform_feedback; instancecount: Int32)>(DrawTransformFeedbackInstanced_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackInstanced(mode: glPrimitiveType; id: gl_transform_feedback; instancecount: Int32) :=
      ntv_DrawTransformFeedbackInstanced_1(mode, id, instancecount);
    
    private DrawTransformFeedbackStreamInstanced_adr := GetProcAddress('glDrawTransformFeedbackStreamInstanced');
    private ntv_DrawTransformFeedbackStreamInstanced_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; id: gl_transform_feedback; stream: UInt32; instancecount: Int32)>(DrawTransformFeedbackStreamInstanced_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackStreamInstanced(mode: glPrimitiveType; id: gl_transform_feedback; stream: UInt32; instancecount: Int32) :=
      ntv_DrawTransformFeedbackStreamInstanced_1(mode, id, stream, instancecount);
    
  end;
  
  ///
  glTransformFeedbackOverflowQueryARB = static class
    public const _ExtStr = 'GL_ARB_transform_feedback_overflow_query';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTransformFeedback2ARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_transform_feedback2';
    
    private BindTransformFeedback_adr := GetProcAddress('glBindTransformFeedback');
    private ntv_BindTransformFeedback_1 := GetProcOrNil&<procedure(target: glBindTransformFeedbackTarget; id: gl_transform_feedback)>(BindTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTransformFeedback(target: glBindTransformFeedbackTarget; id: gl_transform_feedback) :=
      ntv_BindTransformFeedback_1(target, id);
    
    private DeleteTransformFeedbacks_adr := GetProcAddress('glDeleteTransformFeedbacks');
    private ntv_DeleteTransformFeedbacks_1 := GetProcOrNil&<procedure(n: Int32; var ids: gl_transform_feedback)>(DeleteTransformFeedbacks_adr);
    private ntv_DeleteTransformFeedbacks_2 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(DeleteTransformFeedbacks_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacks(n: Int32; ids: array of gl_transform_feedback);
    type PGl_transform_feedback = ^gl_transform_feedback;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_DeleteTransformFeedbacks_1(n, ids[0]) else
        ntv_DeleteTransformFeedbacks_1(n, PGl_transform_feedback(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacks(n: Int32; var ids: gl_transform_feedback) :=
      ntv_DeleteTransformFeedbacks_1(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacks(n: Int32; ids: IntPtr) :=
      ntv_DeleteTransformFeedbacks_2(n, ids);
    
    private GenTransformFeedbacks_adr := GetProcAddress('glGenTransformFeedbacks');
    private ntv_GenTransformFeedbacks_1 := GetProcOrNil&<procedure(n: Int32; var ids: gl_transform_feedback)>(GenTransformFeedbacks_adr);
    private ntv_GenTransformFeedbacks_2 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(GenTransformFeedbacks_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacks(n: Int32; ids: array of gl_transform_feedback);
    type PGl_transform_feedback = ^gl_transform_feedback;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_GenTransformFeedbacks_1(n, ids[0]) else
        ntv_GenTransformFeedbacks_1(n, PGl_transform_feedback(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacks(n: Int32; var ids: gl_transform_feedback) :=
      ntv_GenTransformFeedbacks_1(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacks(n: Int32; ids: IntPtr) :=
      ntv_GenTransformFeedbacks_2(n, ids);
    
    private IsTransformFeedback_adr := GetProcAddress('glIsTransformFeedback');
    private ntv_IsTransformFeedback_1 := GetProcOrNil&<function(id: gl_transform_feedback): glBool8>(IsTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTransformFeedback(id: gl_transform_feedback): glBool8 :=
      ntv_IsTransformFeedback_1(id);
    
    private PauseTransformFeedback_adr := GetProcAddress('glPauseTransformFeedback');
    private ntv_PauseTransformFeedback_1 := GetProcOrNil&<procedure>(PauseTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PauseTransformFeedback :=
      ntv_PauseTransformFeedback_1;
    
    private ResumeTransformFeedback_adr := GetProcAddress('glResumeTransformFeedback');
    private ntv_ResumeTransformFeedback_1 := GetProcOrNil&<procedure>(ResumeTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResumeTransformFeedback :=
      ntv_ResumeTransformFeedback_1;
    
    private DrawTransformFeedback_adr := GetProcAddress('glDrawTransformFeedback');
    private ntv_DrawTransformFeedback_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; id: gl_transform_feedback)>(DrawTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedback(mode: glPrimitiveType; id: gl_transform_feedback) :=
      ntv_DrawTransformFeedback_1(mode, id);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTransformFeedback3ARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_transform_feedback3';
    
    private DrawTransformFeedbackStream_adr := GetProcAddress('glDrawTransformFeedbackStream');
    private ntv_DrawTransformFeedbackStream_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; id: gl_transform_feedback; stream: UInt32)>(DrawTransformFeedbackStream_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackStream(mode: glPrimitiveType; id: gl_transform_feedback; stream: UInt32) :=
      ntv_DrawTransformFeedbackStream_1(mode, id, stream);
    
    private BeginQueryIndexed_adr := GetProcAddress('glBeginQueryIndexed');
    private ntv_BeginQueryIndexed_1 := GetProcOrNil&<procedure(target: glQueryTarget; index: UInt32; id: gl_query)>(BeginQueryIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginQueryIndexed(target: glQueryTarget; index: UInt32; id: gl_query) :=
      ntv_BeginQueryIndexed_1(target, index, id);
    
    private EndQueryIndexed_adr := GetProcAddress('glEndQueryIndexed');
    private ntv_EndQueryIndexed_1 := GetProcOrNil&<procedure(target: glQueryTarget; index: UInt32)>(EndQueryIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndQueryIndexed(target: glQueryTarget; index: UInt32) :=
      ntv_EndQueryIndexed_1(target, index);
    
    private GetQueryIndexediv_adr := GetProcAddress('glGetQueryIndexediv');
    private ntv_GetQueryIndexediv_1 := GetProcOrNil&<procedure(target: glQueryTarget; index: UInt32; pname: glQueryParameterName; var &params: Int32)>(GetQueryIndexediv_adr);
    private ntv_GetQueryIndexediv_2 := GetProcOrNil&<procedure(target: glQueryTarget; index: UInt32; pname: glQueryParameterName; &params: IntPtr)>(GetQueryIndexediv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryIndexediv(target: glQueryTarget; index: UInt32; pname: glQueryParameterName; var &params: Int32) :=
      ntv_GetQueryIndexediv_1(target, index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryIndexediv(target: glQueryTarget; index: UInt32; pname: glQueryParameterName; &params: IntPtr) :=
      ntv_GetQueryIndexediv_2(target, index, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTransposeMatrixARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_transpose_matrix';
    
    private LoadTransposeMatrixfARB_adr := GetProcAddress('glLoadTransposeMatrixfARB');
    private ntv_LoadTransposeMatrixfARB_1 := GetProcOrNil&<procedure(var m: single)>(LoadTransposeMatrixfARB_adr);
    private ntv_LoadTransposeMatrixfARB_2 := GetProcOrNil&<procedure(m: IntPtr)>(LoadTransposeMatrixfARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixfARB(m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_LoadTransposeMatrixfARB_1(m[0]) else
        ntv_LoadTransposeMatrixfARB_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixfARB(var m: single) :=
      ntv_LoadTransposeMatrixfARB_1(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixfARB(m: IntPtr) :=
      ntv_LoadTransposeMatrixfARB_2(m);
    
    private LoadTransposeMatrixdARB_adr := GetProcAddress('glLoadTransposeMatrixdARB');
    private ntv_LoadTransposeMatrixdARB_1 := GetProcOrNil&<procedure(var m: double)>(LoadTransposeMatrixdARB_adr);
    private ntv_LoadTransposeMatrixdARB_2 := GetProcOrNil&<procedure(m: IntPtr)>(LoadTransposeMatrixdARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixdARB(m: array of double);
    type PDouble = ^double;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_LoadTransposeMatrixdARB_1(m[0]) else
        ntv_LoadTransposeMatrixdARB_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixdARB(var m: double) :=
      ntv_LoadTransposeMatrixdARB_1(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixdARB(m: IntPtr) :=
      ntv_LoadTransposeMatrixdARB_2(m);
    
    private MultTransposeMatrixfARB_adr := GetProcAddress('glMultTransposeMatrixfARB');
    private ntv_MultTransposeMatrixfARB_1 := GetProcOrNil&<procedure(var m: single)>(MultTransposeMatrixfARB_adr);
    private ntv_MultTransposeMatrixfARB_2 := GetProcOrNil&<procedure(m: IntPtr)>(MultTransposeMatrixfARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixfARB(m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MultTransposeMatrixfARB_1(m[0]) else
        ntv_MultTransposeMatrixfARB_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixfARB(var m: single) :=
      ntv_MultTransposeMatrixfARB_1(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixfARB(m: IntPtr) :=
      ntv_MultTransposeMatrixfARB_2(m);
    
    private MultTransposeMatrixdARB_adr := GetProcAddress('glMultTransposeMatrixdARB');
    private ntv_MultTransposeMatrixdARB_1 := GetProcOrNil&<procedure(var m: double)>(MultTransposeMatrixdARB_adr);
    private ntv_MultTransposeMatrixdARB_2 := GetProcOrNil&<procedure(m: IntPtr)>(MultTransposeMatrixdARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixdARB(m: array of double);
    type PDouble = ^double;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MultTransposeMatrixdARB_1(m[0]) else
        ntv_MultTransposeMatrixdARB_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixdARB(var m: double) :=
      ntv_MultTransposeMatrixdARB_1(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixdARB(m: IntPtr) :=
      ntv_MultTransposeMatrixdARB_2(m);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glUniformBufferObjectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_uniform_buffer_object';
    
    private GetUniformIndices_adr := GetProcAddress('glGetUniformIndices');
    private ntv_GetUniformIndices_1 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; var uniformNames: IntPtr; var uniformIndices: UInt32)>(GetUniformIndices_adr);
    private ntv_GetUniformIndices_2 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; uniformNames: pointer; var uniformIndices: UInt32)>(GetUniformIndices_adr);
    private ntv_GetUniformIndices_3 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; var uniformNames: IntPtr; uniformIndices: IntPtr)>(GetUniformIndices_adr);
    private ntv_GetUniformIndices_4 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; uniformNames: pointer; uniformIndices: IntPtr)>(GetUniformIndices_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; uniformNames: array of string; var uniformIndices: UInt32);
    begin
      if (uniformNames=nil) or (uniformNames.Length=0) then
      begin
        ntv_GetUniformIndices_2(&program, uniformCount, nil, uniformIndices);
        exit;
      end;
      var uniformNames_temp_arr: array of IntPtr;
      try
        begin
          var uniformNames_org_el_1 := uniformNames;
          var uniformNames_len_1 := uniformNames_org_el_1.Length;
          SetLength(uniformNames_temp_arr, uniformNames_len_1);
          var uniformNames_tmp_el_1 := uniformNames_temp_arr;
          for var uniformNames_ind_1 := 0 to uniformNames_len_1-1 do
          begin
            var uniformNames_org_el_2 := uniformNames_org_el_1[uniformNames_ind_1];
            if (uniformNames_org_el_2=nil) or (uniformNames_org_el_2.Length=0) then continue;
            uniformNames_tmp_el_1[uniformNames_ind_1] := Marshal.StringToHGlobalAnsi(uniformNames_org_el_2);
          end;
        end;
        ntv_GetUniformIndices_1(&program, uniformCount, uniformNames_temp_arr[0], uniformIndices);
      finally
         foreach var arr_el1 in uniformNames_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; uniformNames: array of string; uniformIndices: IntPtr);
    begin
      if (uniformNames=nil) or (uniformNames.Length=0) then
      begin
        ntv_GetUniformIndices_4(&program, uniformCount, nil, uniformIndices);
        exit;
      end;
      var uniformNames_temp_arr: array of IntPtr;
      try
        begin
          var uniformNames_org_el_1 := uniformNames;
          var uniformNames_len_1 := uniformNames_org_el_1.Length;
          SetLength(uniformNames_temp_arr, uniformNames_len_1);
          var uniformNames_tmp_el_1 := uniformNames_temp_arr;
          for var uniformNames_ind_1 := 0 to uniformNames_len_1-1 do
          begin
            var uniformNames_org_el_2 := uniformNames_org_el_1[uniformNames_ind_1];
            if (uniformNames_org_el_2=nil) or (uniformNames_org_el_2.Length=0) then continue;
            uniformNames_tmp_el_1[uniformNames_ind_1] := Marshal.StringToHGlobalAnsi(uniformNames_org_el_2);
          end;
        end;
        ntv_GetUniformIndices_3(&program, uniformCount, uniformNames_temp_arr[0], uniformIndices);
      finally
         foreach var arr_el1 in uniformNames_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; var uniformNames: IntPtr; var uniformIndices: UInt32) :=
      ntv_GetUniformIndices_1(&program, uniformCount, uniformNames, uniformIndices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; var uniformNames: IntPtr; uniformIndices: IntPtr) :=
      ntv_GetUniformIndices_3(&program, uniformCount, uniformNames, uniformIndices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; uniformNames: pointer; var uniformIndices: UInt32) :=
      ntv_GetUniformIndices_2(&program, uniformCount, uniformNames, uniformIndices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; uniformNames: pointer; uniformIndices: IntPtr) :=
      ntv_GetUniformIndices_4(&program, uniformCount, uniformNames, uniformIndices);
    
    private GetActiveUniformsiv_adr := GetProcAddress('glGetActiveUniformsiv');
    private ntv_GetActiveUniformsiv_1 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; var uniformIndices: UInt32; pname: glUniformPName; var &params: Int32)>(GetActiveUniformsiv_adr);
    private ntv_GetActiveUniformsiv_2 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; uniformIndices: IntPtr; pname: glUniformPName; &params: IntPtr)>(GetActiveUniformsiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformsiv(&program: gl_program; uniformCount: Int32; uniformIndices: array of UInt32; pname: glUniformPName; &params: array of Int32);
    type PUInt32 = ^UInt32;
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        if (uniformIndices<>nil) and (uniformIndices.Length<>0) then
          ntv_GetActiveUniformsiv_1(&program, uniformCount, uniformIndices[0], pname, &params[0]) else
          ntv_GetActiveUniformsiv_1(&program, uniformCount, PUInt32(nil)^, pname, &params[0]) else
        if (uniformIndices<>nil) and (uniformIndices.Length<>0) then
          ntv_GetActiveUniformsiv_1(&program, uniformCount, uniformIndices[0], pname, PInt32(nil)^) else
          ntv_GetActiveUniformsiv_1(&program, uniformCount, PUInt32(nil)^, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformsiv(&program: gl_program; uniformCount: Int32; var uniformIndices: UInt32; pname: glUniformPName; var &params: Int32) :=
      ntv_GetActiveUniformsiv_1(&program, uniformCount, uniformIndices, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformsiv(&program: gl_program; uniformCount: Int32; uniformIndices: IntPtr; pname: glUniformPName; &params: IntPtr) :=
      ntv_GetActiveUniformsiv_2(&program, uniformCount, uniformIndices, pname, &params);
    
    private GetActiveUniformName_adr := GetProcAddress('glGetActiveUniformName');
    private ntv_GetActiveUniformName_1 := GetProcOrNil&<procedure(&program: gl_program; uniformIndex: UInt32; bufSize: Int32; var length: Int32; uniformName: IntPtr)>(GetActiveUniformName_adr);
    private ntv_GetActiveUniformName_2 := GetProcOrNil&<procedure(&program: gl_program; uniformIndex: UInt32; bufSize: Int32; length: IntPtr; uniformName: IntPtr)>(GetActiveUniformName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformName(&program: gl_program; uniformIndex: UInt32; bufSize: Int32; var length: Int32; uniformName: IntPtr) :=
      ntv_GetActiveUniformName_1(&program, uniformIndex, bufSize, length, uniformName);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformName(&program: gl_program; uniformIndex: UInt32; bufSize: Int32; length: IntPtr; uniformName: IntPtr) :=
      ntv_GetActiveUniformName_2(&program, uniformIndex, bufSize, length, uniformName);
    
    private GetUniformBlockIndex_adr := GetProcAddress('glGetUniformBlockIndex');
    private ntv_GetUniformBlockIndex_1 := GetProcOrNil&<function(&program: gl_program; uniformBlockName: IntPtr): UInt32>(GetUniformBlockIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformBlockIndex(&program: gl_program; uniformBlockName: string): UInt32;
    begin
      var uniformBlockName_str_ptr := Marshal.StringToHGlobalAnsi(uniformBlockName);
      try
        Result := ntv_GetUniformBlockIndex_1(&program, uniformBlockName_str_ptr);
      finally
        Marshal.FreeHGlobal(uniformBlockName_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformBlockIndex(&program: gl_program; uniformBlockName: IntPtr): UInt32 :=
      ntv_GetUniformBlockIndex_1(&program, uniformBlockName);
    
    private GetActiveUniformBlockiv_adr := GetProcAddress('glGetActiveUniformBlockiv');
    private ntv_GetActiveUniformBlockiv_1 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; pname: glUniformBlockPName; var &params: Int32)>(GetActiveUniformBlockiv_adr);
    private ntv_GetActiveUniformBlockiv_2 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; pname: glUniformBlockPName; &params: IntPtr)>(GetActiveUniformBlockiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockiv(&program: gl_program; uniformBlockIndex: UInt32; pname: glUniformBlockPName; var &params: Int32) :=
      ntv_GetActiveUniformBlockiv_1(&program, uniformBlockIndex, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockiv(&program: gl_program; uniformBlockIndex: UInt32; pname: glUniformBlockPName; &params: IntPtr) :=
      ntv_GetActiveUniformBlockiv_2(&program, uniformBlockIndex, pname, &params);
    
    private GetActiveUniformBlockName_adr := GetProcAddress('glGetActiveUniformBlockName');
    private ntv_GetActiveUniformBlockName_1 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; bufSize: Int32; var length: Int32; uniformBlockName: IntPtr)>(GetActiveUniformBlockName_adr);
    private ntv_GetActiveUniformBlockName_2 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; bufSize: Int32; length: IntPtr; uniformBlockName: IntPtr)>(GetActiveUniformBlockName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockName(&program: gl_program; uniformBlockIndex: UInt32; bufSize: Int32; var length: Int32; uniformBlockName: IntPtr) :=
      ntv_GetActiveUniformBlockName_1(&program, uniformBlockIndex, bufSize, length, uniformBlockName);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockName(&program: gl_program; uniformBlockIndex: UInt32; bufSize: Int32; length: IntPtr; uniformBlockName: IntPtr) :=
      ntv_GetActiveUniformBlockName_2(&program, uniformBlockIndex, bufSize, length, uniformBlockName);
    
    private UniformBlockBinding_adr := GetProcAddress('glUniformBlockBinding');
    private ntv_UniformBlockBinding_1 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; uniformBlockBinding: UInt32)>(UniformBlockBinding_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformBlockBinding(&program: gl_program; uniformBlockIndex: UInt32; uniformBlockBinding: UInt32) :=
      ntv_UniformBlockBinding_1(&program, uniformBlockIndex, uniformBlockBinding);
    
    private BindBufferRange_adr := GetProcAddress('glBindBufferRange');
    private ntv_BindBufferRange_1 := GetProcOrNil&<procedure(target: glBufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(BindBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferRange(target: glBufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
      ntv_BindBufferRange_1(target, index, buffer, offset, size);
    
    private BindBufferBase_adr := GetProcAddress('glBindBufferBase');
    private ntv_BindBufferBase_1 := GetProcOrNil&<procedure(target: glBufferTarget; index: UInt32; buffer: gl_buffer)>(BindBufferBase_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferBase(target: glBufferTarget; index: UInt32; buffer: gl_buffer) :=
      ntv_BindBufferBase_1(target, index, buffer);
    
    private GetIntegeri_v_adr := GetProcAddress('glGetIntegeri_v');
    private ntv_GetIntegeri_v_1 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; var data: Int32)>(GetIntegeri_v_adr);
    private ntv_GetIntegeri_v_2 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; data: IntPtr)>(GetIntegeri_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegeri_v(target: glGetPName; index: UInt32; var data: Int32) :=
      ntv_GetIntegeri_v_1(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegeri_v(target: glGetPName; index: UInt32; data: IntPtr) :=
      ntv_GetIntegeri_v_2(target, index, data);
    
  end;
  
  ///
  glVertexArrayBgraARB = static class
    public const _ExtStr = 'GL_ARB_vertex_array_bgra';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexArrayObjectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_vertex_array_object';
    
    private BindVertexArray_adr := GetProcAddress('glBindVertexArray');
    private ntv_BindVertexArray_1 := GetProcOrNil&<procedure(&array: gl_vertex_array)>(BindVertexArray_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexArray(&array: gl_vertex_array) :=
      ntv_BindVertexArray_1(&array);
    
    private DeleteVertexArrays_adr := GetProcAddress('glDeleteVertexArrays');
    private ntv_DeleteVertexArrays_1 := GetProcOrNil&<procedure(n: Int32; var arrays: gl_vertex_array)>(DeleteVertexArrays_adr);
    private ntv_DeleteVertexArrays_2 := GetProcOrNil&<procedure(n: Int32; arrays: IntPtr)>(DeleteVertexArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArrays(n: Int32; arrays: array of gl_vertex_array);
    type PGl_vertex_array = ^gl_vertex_array;
    begin
      if (arrays<>nil) and (arrays.Length<>0) then
        ntv_DeleteVertexArrays_1(n, arrays[0]) else
        ntv_DeleteVertexArrays_1(n, PGl_vertex_array(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArrays(n: Int32; var arrays: gl_vertex_array) :=
      ntv_DeleteVertexArrays_1(n, arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArrays(n: Int32; arrays: IntPtr) :=
      ntv_DeleteVertexArrays_2(n, arrays);
    
    private GenVertexArrays_adr := GetProcAddress('glGenVertexArrays');
    private ntv_GenVertexArrays_1 := GetProcOrNil&<procedure(n: Int32; var arrays: gl_vertex_array)>(GenVertexArrays_adr);
    private ntv_GenVertexArrays_2 := GetProcOrNil&<procedure(n: Int32; arrays: IntPtr)>(GenVertexArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArrays(n: Int32; arrays: array of gl_vertex_array);
    type PGl_vertex_array = ^gl_vertex_array;
    begin
      if (arrays<>nil) and (arrays.Length<>0) then
        ntv_GenVertexArrays_1(n, arrays[0]) else
        ntv_GenVertexArrays_1(n, PGl_vertex_array(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArrays(n: Int32; var arrays: gl_vertex_array) :=
      ntv_GenVertexArrays_1(n, arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArrays(n: Int32; arrays: IntPtr) :=
      ntv_GenVertexArrays_2(n, arrays);
    
    private IsVertexArray_adr := GetProcAddress('glIsVertexArray');
    private ntv_IsVertexArray_1 := GetProcOrNil&<function(&array: gl_vertex_array): glBool8>(IsVertexArray_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsVertexArray(&array: gl_vertex_array): glBool8 :=
      ntv_IsVertexArray_1(&array);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexAttrib64bitARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_vertex_attrib_64bit';
    
    private VertexAttribL1d_adr := GetProcAddress('glVertexAttribL1d');
    private ntv_VertexAttribL1d_1 := GetProcOrNil&<procedure(index: UInt32; x: double)>(VertexAttribL1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1d(index: UInt32; x: double) :=
      ntv_VertexAttribL1d_1(index, x);
    
    private VertexAttribL2d_adr := GetProcAddress('glVertexAttribL2d');
    private ntv_VertexAttribL2d_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double)>(VertexAttribL2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2d(index: UInt32; x: double; y: double) :=
      ntv_VertexAttribL2d_1(index, x, y);
    
    private VertexAttribL3d_adr := GetProcAddress('glVertexAttribL3d');
    private ntv_VertexAttribL3d_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double; z: double)>(VertexAttribL3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3d(index: UInt32; x: double; y: double; z: double) :=
      ntv_VertexAttribL3d_1(index, x, y, z);
    
    private VertexAttribL4d_adr := GetProcAddress('glVertexAttribL4d');
    private ntv_VertexAttribL4d_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double; z: double; w: double)>(VertexAttribL4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4d(index: UInt32; x: double; y: double; z: double; w: double) :=
      ntv_VertexAttribL4d_1(index, x, y, z, w);
    
    private VertexAttribL1dv_adr := GetProcAddress('glVertexAttribL1dv');
    private ntv_VertexAttribL1dv_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttribL1dv_adr);
    private ntv_VertexAttribL1dv_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dv(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL1dv_1(index, v[0]) else
        ntv_VertexAttribL1dv_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dv(index: UInt32; var v: double) :=
      ntv_VertexAttribL1dv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL1dv_2(index, v);
    
    private VertexAttribL2dv_adr := GetProcAddress('glVertexAttribL2dv');
    private ntv_VertexAttribL2dv_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttribL2dv_adr);
    private ntv_VertexAttribL2dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2d)>(VertexAttribL2dv_adr);
    private ntv_VertexAttribL2dv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL2dv_1(index, v[0]) else
        ntv_VertexAttribL2dv_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; var v: Vec2d) :=
      ntv_VertexAttribL2dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; var v: double) :=
      ntv_VertexAttribL2dv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL2dv_3(index, v);
    
    private VertexAttribL3dv_adr := GetProcAddress('glVertexAttribL3dv');
    private ntv_VertexAttribL3dv_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttribL3dv_adr);
    private ntv_VertexAttribL3dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3d)>(VertexAttribL3dv_adr);
    private ntv_VertexAttribL3dv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL3dv_1(index, v[0]) else
        ntv_VertexAttribL3dv_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; var v: Vec3d) :=
      ntv_VertexAttribL3dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; var v: double) :=
      ntv_VertexAttribL3dv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL3dv_3(index, v);
    
    private VertexAttribL4dv_adr := GetProcAddress('glVertexAttribL4dv');
    private ntv_VertexAttribL4dv_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttribL4dv_adr);
    private ntv_VertexAttribL4dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4d)>(VertexAttribL4dv_adr);
    private ntv_VertexAttribL4dv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL4dv_1(index, v[0]) else
        ntv_VertexAttribL4dv_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; var v: Vec4d) :=
      ntv_VertexAttribL4dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; var v: double) :=
      ntv_VertexAttribL4dv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL4dv_3(index, v);
    
    private VertexAttribLPointer_adr := GetProcAddress('glVertexAttribLPointer');
    private ntv_VertexAttribLPointer_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: glVertexAttribLType; stride: Int32; pointer: IntPtr)>(VertexAttribLPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLPointer(index: UInt32; size: Int32; &type: glVertexAttribLType; stride: Int32; pointer: IntPtr) :=
      ntv_VertexAttribLPointer_1(index, size, &type, stride, pointer);
    
    private GetVertexAttribLdv_adr := GetProcAddress('glGetVertexAttribLdv');
    private ntv_GetVertexAttribLdv_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; var &params: double)>(GetVertexAttribLdv_adr);
    private ntv_GetVertexAttribLdv_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr)>(GetVertexAttribLdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdv(index: UInt32; pname: glVertexAttribEnum; var &params: double) :=
      ntv_GetVertexAttribLdv_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdv(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr) :=
      ntv_GetVertexAttribLdv_2(index, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexAttribBindingARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_vertex_attrib_binding';
    
    private BindVertexBuffer_adr := GetProcAddress('glBindVertexBuffer');
    private ntv_BindVertexBuffer_1 := GetProcOrNil&<procedure(bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32)>(BindVertexBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffer(bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32) :=
      ntv_BindVertexBuffer_1(bindingindex, buffer, offset, stride);
    
    private VertexAttribFormat_adr := GetProcAddress('glVertexAttribFormat');
    private ntv_VertexAttribFormat_1 := GetProcOrNil&<procedure(attribindex: UInt32; size: Int32; &type: glVertexAttribType; normalized: glBool8; relativeoffset: UInt32)>(VertexAttribFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribFormat(attribindex: UInt32; size: Int32; &type: glVertexAttribType; normalized: glBool8; relativeoffset: UInt32) :=
      ntv_VertexAttribFormat_1(attribindex, size, &type, normalized, relativeoffset);
    
    private VertexAttribIFormat_adr := GetProcAddress('glVertexAttribIFormat');
    private ntv_VertexAttribIFormat_1 := GetProcOrNil&<procedure(attribindex: UInt32; size: Int32; &type: glVertexAttribIType; relativeoffset: UInt32)>(VertexAttribIFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIFormat(attribindex: UInt32; size: Int32; &type: glVertexAttribIType; relativeoffset: UInt32) :=
      ntv_VertexAttribIFormat_1(attribindex, size, &type, relativeoffset);
    
    private VertexAttribLFormat_adr := GetProcAddress('glVertexAttribLFormat');
    private ntv_VertexAttribLFormat_1 := GetProcOrNil&<procedure(attribindex: UInt32; size: Int32; &type: glVertexAttribLType; relativeoffset: UInt32)>(VertexAttribLFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLFormat(attribindex: UInt32; size: Int32; &type: glVertexAttribLType; relativeoffset: UInt32) :=
      ntv_VertexAttribLFormat_1(attribindex, size, &type, relativeoffset);
    
    private VertexAttribBinding_adr := GetProcAddress('glVertexAttribBinding');
    private ntv_VertexAttribBinding_1 := GetProcOrNil&<procedure(attribindex: UInt32; bindingindex: UInt32)>(VertexAttribBinding_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribBinding(attribindex: UInt32; bindingindex: UInt32) :=
      ntv_VertexAttribBinding_1(attribindex, bindingindex);
    
    private VertexBindingDivisor_adr := GetProcAddress('glVertexBindingDivisor');
    private ntv_VertexBindingDivisor_1 := GetProcOrNil&<procedure(bindingindex: UInt32; divisor: UInt32)>(VertexBindingDivisor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexBindingDivisor(bindingindex: UInt32; divisor: UInt32) :=
      ntv_VertexBindingDivisor_1(bindingindex, divisor);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexBlendARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_vertex_blend';
    
    private WeightbvARB_adr := GetProcAddress('glWeightbvARB');
    private ntv_WeightbvARB_1 := GetProcOrNil&<procedure(size: Int32; var weights: SByte)>(WeightbvARB_adr);
    private ntv_WeightbvARB_2 := GetProcOrNil&<procedure(size: Int32; weights: IntPtr)>(WeightbvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightbvARB(size: Int32; weights: array of SByte);
    type PSByte = ^SByte;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        ntv_WeightbvARB_1(size, weights[0]) else
        ntv_WeightbvARB_1(size, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightbvARB(size: Int32; var weights: SByte) :=
      ntv_WeightbvARB_1(size, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightbvARB(size: Int32; weights: IntPtr) :=
      ntv_WeightbvARB_2(size, weights);
    
    private WeightsvARB_adr := GetProcAddress('glWeightsvARB');
    private ntv_WeightsvARB_1 := GetProcOrNil&<procedure(size: Int32; var weights: Int16)>(WeightsvARB_adr);
    private ntv_WeightsvARB_2 := GetProcOrNil&<procedure(size: Int32; weights: IntPtr)>(WeightsvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightsvARB(size: Int32; weights: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        ntv_WeightsvARB_1(size, weights[0]) else
        ntv_WeightsvARB_1(size, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightsvARB(size: Int32; var weights: Int16) :=
      ntv_WeightsvARB_1(size, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightsvARB(size: Int32; weights: IntPtr) :=
      ntv_WeightsvARB_2(size, weights);
    
    private WeightivARB_adr := GetProcAddress('glWeightivARB');
    private ntv_WeightivARB_1 := GetProcOrNil&<procedure(size: Int32; var weights: Int32)>(WeightivARB_adr);
    private ntv_WeightivARB_2 := GetProcOrNil&<procedure(size: Int32; weights: IntPtr)>(WeightivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightivARB(size: Int32; weights: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        ntv_WeightivARB_1(size, weights[0]) else
        ntv_WeightivARB_1(size, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightivARB(size: Int32; var weights: Int32) :=
      ntv_WeightivARB_1(size, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightivARB(size: Int32; weights: IntPtr) :=
      ntv_WeightivARB_2(size, weights);
    
    private WeightfvARB_adr := GetProcAddress('glWeightfvARB');
    private ntv_WeightfvARB_1 := GetProcOrNil&<procedure(size: Int32; var weights: single)>(WeightfvARB_adr);
    private ntv_WeightfvARB_2 := GetProcOrNil&<procedure(size: Int32; weights: IntPtr)>(WeightfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightfvARB(size: Int32; weights: array of single);
    type PSingle = ^single;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        ntv_WeightfvARB_1(size, weights[0]) else
        ntv_WeightfvARB_1(size, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightfvARB(size: Int32; var weights: single) :=
      ntv_WeightfvARB_1(size, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightfvARB(size: Int32; weights: IntPtr) :=
      ntv_WeightfvARB_2(size, weights);
    
    private WeightdvARB_adr := GetProcAddress('glWeightdvARB');
    private ntv_WeightdvARB_1 := GetProcOrNil&<procedure(size: Int32; var weights: double)>(WeightdvARB_adr);
    private ntv_WeightdvARB_2 := GetProcOrNil&<procedure(size: Int32; weights: IntPtr)>(WeightdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightdvARB(size: Int32; weights: array of double);
    type PDouble = ^double;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        ntv_WeightdvARB_1(size, weights[0]) else
        ntv_WeightdvARB_1(size, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightdvARB(size: Int32; var weights: double) :=
      ntv_WeightdvARB_1(size, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightdvARB(size: Int32; weights: IntPtr) :=
      ntv_WeightdvARB_2(size, weights);
    
    private WeightubvARB_adr := GetProcAddress('glWeightubvARB');
    private ntv_WeightubvARB_1 := GetProcOrNil&<procedure(size: Int32; var weights: Byte)>(WeightubvARB_adr);
    private ntv_WeightubvARB_2 := GetProcOrNil&<procedure(size: Int32; weights: IntPtr)>(WeightubvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightubvARB(size: Int32; weights: array of Byte);
    type PByte = ^Byte;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        ntv_WeightubvARB_1(size, weights[0]) else
        ntv_WeightubvARB_1(size, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightubvARB(size: Int32; var weights: Byte) :=
      ntv_WeightubvARB_1(size, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightubvARB(size: Int32; weights: IntPtr) :=
      ntv_WeightubvARB_2(size, weights);
    
    private WeightusvARB_adr := GetProcAddress('glWeightusvARB');
    private ntv_WeightusvARB_1 := GetProcOrNil&<procedure(size: Int32; var weights: UInt16)>(WeightusvARB_adr);
    private ntv_WeightusvARB_2 := GetProcOrNil&<procedure(size: Int32; weights: IntPtr)>(WeightusvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightusvARB(size: Int32; weights: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        ntv_WeightusvARB_1(size, weights[0]) else
        ntv_WeightusvARB_1(size, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightusvARB(size: Int32; var weights: UInt16) :=
      ntv_WeightusvARB_1(size, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightusvARB(size: Int32; weights: IntPtr) :=
      ntv_WeightusvARB_2(size, weights);
    
    private WeightuivARB_adr := GetProcAddress('glWeightuivARB');
    private ntv_WeightuivARB_1 := GetProcOrNil&<procedure(size: Int32; var weights: UInt32)>(WeightuivARB_adr);
    private ntv_WeightuivARB_2 := GetProcOrNil&<procedure(size: Int32; weights: IntPtr)>(WeightuivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightuivARB(size: Int32; weights: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        ntv_WeightuivARB_1(size, weights[0]) else
        ntv_WeightuivARB_1(size, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightuivARB(size: Int32; var weights: UInt32) :=
      ntv_WeightuivARB_1(size, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightuivARB(size: Int32; weights: IntPtr) :=
      ntv_WeightuivARB_2(size, weights);
    
    private WeightPointerARB_adr := GetProcAddress('glWeightPointerARB');
    private ntv_WeightPointerARB_1 := GetProcOrNil&<procedure(size: Int32; &type: glWeightPointerType; stride: Int32; pointer: IntPtr)>(WeightPointerARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPointerARB(size: Int32; &type: glWeightPointerType; stride: Int32; pointer: IntPtr) :=
      ntv_WeightPointerARB_1(size, &type, stride, pointer);
    
    private VertexBlendARB_adr := GetProcAddress('glVertexBlendARB');
    private ntv_VertexBlendARB_1 := GetProcOrNil&<procedure(count: Int32)>(VertexBlendARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexBlendARB(count: Int32) :=
      ntv_VertexBlendARB_1(count);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexBufferObjectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_vertex_buffer_object';
    
    private BindBufferARB_adr := GetProcAddress('glBindBufferARB');
    private ntv_BindBufferARB_1 := GetProcOrNil&<procedure(target: glBufferTarget; buffer: gl_buffer)>(BindBufferARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferARB(target: glBufferTarget; buffer: gl_buffer) :=
      ntv_BindBufferARB_1(target, buffer);
    
    private DeleteBuffersARB_adr := GetProcAddress('glDeleteBuffersARB');
    private ntv_DeleteBuffersARB_1 := GetProcOrNil&<procedure(n: Int32; var buffers: gl_buffer)>(DeleteBuffersARB_adr);
    private ntv_DeleteBuffersARB_2 := GetProcOrNil&<procedure(n: Int32; buffers: IntPtr)>(DeleteBuffersARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffersARB(n: Int32; buffers: array of gl_buffer);
    type PGl_buffer = ^gl_buffer;
    begin
      if (buffers<>nil) and (buffers.Length<>0) then
        ntv_DeleteBuffersARB_1(n, buffers[0]) else
        ntv_DeleteBuffersARB_1(n, PGl_buffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffersARB(n: Int32; var buffers: gl_buffer) :=
      ntv_DeleteBuffersARB_1(n, buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffersARB(n: Int32; buffers: IntPtr) :=
      ntv_DeleteBuffersARB_2(n, buffers);
    
    private GenBuffersARB_adr := GetProcAddress('glGenBuffersARB');
    private ntv_GenBuffersARB_1 := GetProcOrNil&<procedure(n: Int32; var buffers: gl_buffer)>(GenBuffersARB_adr);
    private ntv_GenBuffersARB_2 := GetProcOrNil&<procedure(n: Int32; buffers: IntPtr)>(GenBuffersARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffersARB(n: Int32; buffers: array of gl_buffer);
    type PGl_buffer = ^gl_buffer;
    begin
      if (buffers<>nil) and (buffers.Length<>0) then
        ntv_GenBuffersARB_1(n, buffers[0]) else
        ntv_GenBuffersARB_1(n, PGl_buffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffersARB(n: Int32; var buffers: gl_buffer) :=
      ntv_GenBuffersARB_1(n, buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffersARB(n: Int32; buffers: IntPtr) :=
      ntv_GenBuffersARB_2(n, buffers);
    
    private IsBufferARB_adr := GetProcAddress('glIsBufferARB');
    private ntv_IsBufferARB_1 := GetProcOrNil&<function(buffer: gl_buffer): glBool8>(IsBufferARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsBufferARB(buffer: gl_buffer): glBool8 :=
      ntv_IsBufferARB_1(buffer);
    
    private BufferDataARB_adr := GetProcAddress('glBufferDataARB');
    private ntv_BufferDataARB_1 := GetProcOrNil&<procedure(target: glBufferTarget; size: UIntPtr; var data: Byte; usage: glBufferUsage)>(BufferDataARB_adr);
    private ntv_BufferDataARB_2 := GetProcOrNil&<procedure(target: glBufferTarget; size: UIntPtr; data: IntPtr; usage: glBufferUsage)>(BufferDataARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferDataARB<T>(target: glBufferTarget; size: UIntPtr; data: array of T; usage: glBufferUsage); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        BufferDataARB(target, size, data[0], usage) else
        BufferDataARB(target, size, PT(nil)^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferDataARB<T>(target: glBufferTarget; size: UIntPtr; var data: T; usage: glBufferUsage); where T: record;
    begin
      ntv_BufferDataARB_1(target, size, PByte(pointer(@data))^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferDataARB(target: glBufferTarget; size: UIntPtr; data: IntPtr; usage: glBufferUsage) :=
      ntv_BufferDataARB_2(target, size, data, usage);
    
    private BufferSubDataARB_adr := GetProcAddress('glBufferSubDataARB');
    private ntv_BufferSubDataARB_1 := GetProcOrNil&<procedure(target: glBufferTarget; offset: IntPtr; size: UIntPtr; var data: Byte)>(BufferSubDataARB_adr);
    private ntv_BufferSubDataARB_2 := GetProcOrNil&<procedure(target: glBufferTarget; offset: IntPtr; size: UIntPtr; data: IntPtr)>(BufferSubDataARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferSubDataARB<T>(target: glBufferTarget; offset: IntPtr; size: UIntPtr; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        BufferSubDataARB(target, offset, size, data[0]) else
        BufferSubDataARB(target, offset, size, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferSubDataARB<T>(target: glBufferTarget; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      ntv_BufferSubDataARB_1(target, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferSubDataARB(target: glBufferTarget; offset: IntPtr; size: UIntPtr; data: IntPtr) :=
      ntv_BufferSubDataARB_2(target, offset, size, data);
    
    private GetBufferSubDataARB_adr := GetProcAddress('glGetBufferSubDataARB');
    private ntv_GetBufferSubDataARB_1 := GetProcOrNil&<procedure(target: glBufferTarget; offset: IntPtr; size: UIntPtr; var data: Byte)>(GetBufferSubDataARB_adr);
    private ntv_GetBufferSubDataARB_2 := GetProcOrNil&<procedure(target: glBufferTarget; offset: IntPtr; size: UIntPtr; data: pointer)>(GetBufferSubDataARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferSubDataARB<T>(target: glBufferTarget; offset: IntPtr; size: UIntPtr; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        GetBufferSubDataARB(target, offset, size, data[0]) else
        GetBufferSubDataARB(target, offset, size, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferSubDataARB<T>(target: glBufferTarget; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      ntv_GetBufferSubDataARB_1(target, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferSubDataARB(target: glBufferTarget; offset: IntPtr; size: UIntPtr; data: pointer) :=
      ntv_GetBufferSubDataARB_2(target, offset, size, data);
    
    private MapBufferARB_adr := GetProcAddress('glMapBufferARB');
    private ntv_MapBufferARB_1 := GetProcOrNil&<function(target: glBufferTarget; access: glBufferAccess): IntPtr>(MapBufferARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapBufferARB(target: glBufferTarget; access: glBufferAccess): IntPtr :=
      ntv_MapBufferARB_1(target, access);
    
    private UnmapBufferARB_adr := GetProcAddress('glUnmapBufferARB');
    private ntv_UnmapBufferARB_1 := GetProcOrNil&<function(target: glBufferTarget): glBool8>(UnmapBufferARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UnmapBufferARB(target: glBufferTarget): glBool8 :=
      ntv_UnmapBufferARB_1(target);
    
    private GetBufferParameterivARB_adr := GetProcAddress('glGetBufferParameterivARB');
    private ntv_GetBufferParameterivARB_1 := GetProcOrNil&<procedure(target: glBufferTarget; pname: glBufferPName; var &params: Int32)>(GetBufferParameterivARB_adr);
    private ntv_GetBufferParameterivARB_2 := GetProcOrNil&<procedure(target: glBufferTarget; pname: glBufferPName; &params: IntPtr)>(GetBufferParameterivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameterivARB(target: glBufferTarget; pname: glBufferPName; var &params: Int32) :=
      ntv_GetBufferParameterivARB_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameterivARB(target: glBufferTarget; pname: glBufferPName; &params: IntPtr) :=
      ntv_GetBufferParameterivARB_2(target, pname, &params);
    
    private GetBufferPointervARB_adr := GetProcAddress('glGetBufferPointervARB');
    private ntv_GetBufferPointervARB_1 := GetProcOrNil&<procedure(target: glBufferTarget; pname: glBufferPointerName; var &params: IntPtr)>(GetBufferPointervARB_adr);
    private ntv_GetBufferPointervARB_2 := GetProcOrNil&<procedure(target: glBufferTarget; pname: glBufferPointerName; &params: pointer)>(GetBufferPointervARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferPointervARB(target: glBufferTarget; pname: glBufferPointerName; var &params: IntPtr) :=
      ntv_GetBufferPointervARB_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferPointervARB(target: glBufferTarget; pname: glBufferPointerName; &params: pointer) :=
      ntv_GetBufferPointervARB_2(target, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexProgramARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_vertex_program';
    
    private VertexAttrib1dARB_adr := GetProcAddress('glVertexAttrib1dARB');
    private ntv_VertexAttrib1dARB_1 := GetProcOrNil&<procedure(index: UInt32; x: double)>(VertexAttrib1dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dARB(index: UInt32; x: double) :=
      ntv_VertexAttrib1dARB_1(index, x);
    
    private VertexAttrib1dvARB_adr := GetProcAddress('glVertexAttrib1dvARB');
    private ntv_VertexAttrib1dvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttrib1dvARB_adr);
    private ntv_VertexAttrib1dvARB_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib1dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvARB(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib1dvARB_1(index, v[0]) else
        ntv_VertexAttrib1dvARB_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvARB(index: UInt32; var v: double) :=
      ntv_VertexAttrib1dvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib1dvARB_2(index, v);
    
    private VertexAttrib1fARB_adr := GetProcAddress('glVertexAttrib1fARB');
    private ntv_VertexAttrib1fARB_1 := GetProcOrNil&<procedure(index: UInt32; x: single)>(VertexAttrib1fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fARB(index: UInt32; x: single) :=
      ntv_VertexAttrib1fARB_1(index, x);
    
    private VertexAttrib1fvARB_adr := GetProcAddress('glVertexAttrib1fvARB');
    private ntv_VertexAttrib1fvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(VertexAttrib1fvARB_adr);
    private ntv_VertexAttrib1fvARB_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib1fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvARB(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib1fvARB_1(index, v[0]) else
        ntv_VertexAttrib1fvARB_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvARB(index: UInt32; var v: single) :=
      ntv_VertexAttrib1fvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib1fvARB_2(index, v);
    
    private VertexAttrib1sARB_adr := GetProcAddress('glVertexAttrib1sARB');
    private ntv_VertexAttrib1sARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16)>(VertexAttrib1sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sARB(index: UInt32; x: Int16) :=
      ntv_VertexAttrib1sARB_1(index, x);
    
    private VertexAttrib1svARB_adr := GetProcAddress('glVertexAttrib1svARB');
    private ntv_VertexAttrib1svARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib1svARB_adr);
    private ntv_VertexAttrib1svARB_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib1svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svARB(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib1svARB_1(index, v[0]) else
        ntv_VertexAttrib1svARB_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svARB(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib1svARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib1svARB_2(index, v);
    
    private VertexAttrib2dARB_adr := GetProcAddress('glVertexAttrib2dARB');
    private ntv_VertexAttrib2dARB_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double)>(VertexAttrib2dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dARB(index: UInt32; x: double; y: double) :=
      ntv_VertexAttrib2dARB_1(index, x, y);
    
    private VertexAttrib2dvARB_adr := GetProcAddress('glVertexAttrib2dvARB');
    private ntv_VertexAttrib2dvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttrib2dvARB_adr);
    private ntv_VertexAttrib2dvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2d)>(VertexAttrib2dvARB_adr);
    private ntv_VertexAttrib2dvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib2dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvARB(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib2dvARB_1(index, v[0]) else
        ntv_VertexAttrib2dvARB_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvARB(index: UInt32; var v: Vec2d) :=
      ntv_VertexAttrib2dvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvARB(index: UInt32; var v: double) :=
      ntv_VertexAttrib2dvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib2dvARB_3(index, v);
    
    private VertexAttrib2fARB_adr := GetProcAddress('glVertexAttrib2fARB');
    private ntv_VertexAttrib2fARB_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single)>(VertexAttrib2fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fARB(index: UInt32; x: single; y: single) :=
      ntv_VertexAttrib2fARB_1(index, x, y);
    
    private VertexAttrib2fvARB_adr := GetProcAddress('glVertexAttrib2fvARB');
    private ntv_VertexAttrib2fvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(VertexAttrib2fvARB_adr);
    private ntv_VertexAttrib2fvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2f)>(VertexAttrib2fvARB_adr);
    private ntv_VertexAttrib2fvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib2fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvARB(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib2fvARB_1(index, v[0]) else
        ntv_VertexAttrib2fvARB_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvARB(index: UInt32; var v: Vec2f) :=
      ntv_VertexAttrib2fvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvARB(index: UInt32; var v: single) :=
      ntv_VertexAttrib2fvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib2fvARB_3(index, v);
    
    private VertexAttrib2sARB_adr := GetProcAddress('glVertexAttrib2sARB');
    private ntv_VertexAttrib2sARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16)>(VertexAttrib2sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sARB(index: UInt32; x: Int16; y: Int16) :=
      ntv_VertexAttrib2sARB_1(index, x, y);
    
    private VertexAttrib2svARB_adr := GetProcAddress('glVertexAttrib2svARB');
    private ntv_VertexAttrib2svARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib2svARB_adr);
    private ntv_VertexAttrib2svARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2s)>(VertexAttrib2svARB_adr);
    private ntv_VertexAttrib2svARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib2svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svARB(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib2svARB_1(index, v[0]) else
        ntv_VertexAttrib2svARB_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svARB(index: UInt32; var v: Vec2s) :=
      ntv_VertexAttrib2svARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svARB(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib2svARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib2svARB_3(index, v);
    
    private VertexAttrib3dARB_adr := GetProcAddress('glVertexAttrib3dARB');
    private ntv_VertexAttrib3dARB_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double; z: double)>(VertexAttrib3dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dARB(index: UInt32; x: double; y: double; z: double) :=
      ntv_VertexAttrib3dARB_1(index, x, y, z);
    
    private VertexAttrib3dvARB_adr := GetProcAddress('glVertexAttrib3dvARB');
    private ntv_VertexAttrib3dvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttrib3dvARB_adr);
    private ntv_VertexAttrib3dvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3d)>(VertexAttrib3dvARB_adr);
    private ntv_VertexAttrib3dvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib3dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvARB(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib3dvARB_1(index, v[0]) else
        ntv_VertexAttrib3dvARB_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvARB(index: UInt32; var v: Vec3d) :=
      ntv_VertexAttrib3dvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvARB(index: UInt32; var v: double) :=
      ntv_VertexAttrib3dvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib3dvARB_3(index, v);
    
    private VertexAttrib3fARB_adr := GetProcAddress('glVertexAttrib3fARB');
    private ntv_VertexAttrib3fARB_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; z: single)>(VertexAttrib3fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fARB(index: UInt32; x: single; y: single; z: single) :=
      ntv_VertexAttrib3fARB_1(index, x, y, z);
    
    private VertexAttrib3fvARB_adr := GetProcAddress('glVertexAttrib3fvARB');
    private ntv_VertexAttrib3fvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(VertexAttrib3fvARB_adr);
    private ntv_VertexAttrib3fvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3f)>(VertexAttrib3fvARB_adr);
    private ntv_VertexAttrib3fvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib3fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvARB(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib3fvARB_1(index, v[0]) else
        ntv_VertexAttrib3fvARB_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvARB(index: UInt32; var v: Vec3f) :=
      ntv_VertexAttrib3fvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvARB(index: UInt32; var v: single) :=
      ntv_VertexAttrib3fvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib3fvARB_3(index, v);
    
    private VertexAttrib3sARB_adr := GetProcAddress('glVertexAttrib3sARB');
    private ntv_VertexAttrib3sARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16)>(VertexAttrib3sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sARB(index: UInt32; x: Int16; y: Int16; z: Int16) :=
      ntv_VertexAttrib3sARB_1(index, x, y, z);
    
    private VertexAttrib3svARB_adr := GetProcAddress('glVertexAttrib3svARB');
    private ntv_VertexAttrib3svARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib3svARB_adr);
    private ntv_VertexAttrib3svARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3s)>(VertexAttrib3svARB_adr);
    private ntv_VertexAttrib3svARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib3svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svARB(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib3svARB_1(index, v[0]) else
        ntv_VertexAttrib3svARB_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svARB(index: UInt32; var v: Vec3s) :=
      ntv_VertexAttrib3svARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svARB(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib3svARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib3svARB_3(index, v);
    
    private VertexAttrib4NbvARB_adr := GetProcAddress('glVertexAttrib4NbvARB');
    private ntv_VertexAttrib4NbvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(VertexAttrib4NbvARB_adr);
    private ntv_VertexAttrib4NbvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4b)>(VertexAttrib4NbvARB_adr);
    private ntv_VertexAttrib4NbvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4NbvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NbvARB(index: UInt32; v: array of SByte);
    type PSByte = ^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4NbvARB_1(index, v[0]) else
        ntv_VertexAttrib4NbvARB_1(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NbvARB(index: UInt32; var v: Vec4b) :=
      ntv_VertexAttrib4NbvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NbvARB(index: UInt32; var v: SByte) :=
      ntv_VertexAttrib4NbvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NbvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4NbvARB_3(index, v);
    
    private VertexAttrib4NivARB_adr := GetProcAddress('glVertexAttrib4NivARB');
    private ntv_VertexAttrib4NivARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttrib4NivARB_adr);
    private ntv_VertexAttrib4NivARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4i)>(VertexAttrib4NivARB_adr);
    private ntv_VertexAttrib4NivARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4NivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NivARB(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4NivARB_1(index, v[0]) else
        ntv_VertexAttrib4NivARB_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NivARB(index: UInt32; var v: Vec4i) :=
      ntv_VertexAttrib4NivARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NivARB(index: UInt32; var v: Int32) :=
      ntv_VertexAttrib4NivARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NivARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4NivARB_3(index, v);
    
    private VertexAttrib4NsvARB_adr := GetProcAddress('glVertexAttrib4NsvARB');
    private ntv_VertexAttrib4NsvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib4NsvARB_adr);
    private ntv_VertexAttrib4NsvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4s)>(VertexAttrib4NsvARB_adr);
    private ntv_VertexAttrib4NsvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4NsvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NsvARB(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4NsvARB_1(index, v[0]) else
        ntv_VertexAttrib4NsvARB_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NsvARB(index: UInt32; var v: Vec4s) :=
      ntv_VertexAttrib4NsvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NsvARB(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib4NsvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NsvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4NsvARB_3(index, v);
    
    private VertexAttrib4NubARB_adr := GetProcAddress('glVertexAttrib4NubARB');
    private ntv_VertexAttrib4NubARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte)>(VertexAttrib4NubARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubARB(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte) :=
      ntv_VertexAttrib4NubARB_1(index, x, y, z, w);
    
    private VertexAttrib4NubvARB_adr := GetProcAddress('glVertexAttrib4NubvARB');
    private ntv_VertexAttrib4NubvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(VertexAttrib4NubvARB_adr);
    private ntv_VertexAttrib4NubvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ub)>(VertexAttrib4NubvARB_adr);
    private ntv_VertexAttrib4NubvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4NubvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubvARB(index: UInt32; v: array of Byte);
    type PByte = ^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4NubvARB_1(index, v[0]) else
        ntv_VertexAttrib4NubvARB_1(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubvARB(index: UInt32; var v: Vec4ub) :=
      ntv_VertexAttrib4NubvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubvARB(index: UInt32; var v: Byte) :=
      ntv_VertexAttrib4NubvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4NubvARB_3(index, v);
    
    private VertexAttrib4NuivARB_adr := GetProcAddress('glVertexAttrib4NuivARB');
    private ntv_VertexAttrib4NuivARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttrib4NuivARB_adr);
    private ntv_VertexAttrib4NuivARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ui)>(VertexAttrib4NuivARB_adr);
    private ntv_VertexAttrib4NuivARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4NuivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NuivARB(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4NuivARB_1(index, v[0]) else
        ntv_VertexAttrib4NuivARB_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NuivARB(index: UInt32; var v: Vec4ui) :=
      ntv_VertexAttrib4NuivARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NuivARB(index: UInt32; var v: UInt32) :=
      ntv_VertexAttrib4NuivARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NuivARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4NuivARB_3(index, v);
    
    private VertexAttrib4NusvARB_adr := GetProcAddress('glVertexAttrib4NusvARB');
    private ntv_VertexAttrib4NusvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(VertexAttrib4NusvARB_adr);
    private ntv_VertexAttrib4NusvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4us)>(VertexAttrib4NusvARB_adr);
    private ntv_VertexAttrib4NusvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4NusvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NusvARB(index: UInt32; v: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4NusvARB_1(index, v[0]) else
        ntv_VertexAttrib4NusvARB_1(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NusvARB(index: UInt32; var v: Vec4us) :=
      ntv_VertexAttrib4NusvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NusvARB(index: UInt32; var v: UInt16) :=
      ntv_VertexAttrib4NusvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NusvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4NusvARB_3(index, v);
    
    private VertexAttrib4bvARB_adr := GetProcAddress('glVertexAttrib4bvARB');
    private ntv_VertexAttrib4bvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(VertexAttrib4bvARB_adr);
    private ntv_VertexAttrib4bvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4b)>(VertexAttrib4bvARB_adr);
    private ntv_VertexAttrib4bvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4bvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bvARB(index: UInt32; v: array of SByte);
    type PSByte = ^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4bvARB_1(index, v[0]) else
        ntv_VertexAttrib4bvARB_1(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bvARB(index: UInt32; var v: Vec4b) :=
      ntv_VertexAttrib4bvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bvARB(index: UInt32; var v: SByte) :=
      ntv_VertexAttrib4bvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4bvARB_3(index, v);
    
    private VertexAttrib4dARB_adr := GetProcAddress('glVertexAttrib4dARB');
    private ntv_VertexAttrib4dARB_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double; z: double; w: double)>(VertexAttrib4dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dARB(index: UInt32; x: double; y: double; z: double; w: double) :=
      ntv_VertexAttrib4dARB_1(index, x, y, z, w);
    
    private VertexAttrib4dvARB_adr := GetProcAddress('glVertexAttrib4dvARB');
    private ntv_VertexAttrib4dvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttrib4dvARB_adr);
    private ntv_VertexAttrib4dvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4d)>(VertexAttrib4dvARB_adr);
    private ntv_VertexAttrib4dvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvARB(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4dvARB_1(index, v[0]) else
        ntv_VertexAttrib4dvARB_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvARB(index: UInt32; var v: Vec4d) :=
      ntv_VertexAttrib4dvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvARB(index: UInt32; var v: double) :=
      ntv_VertexAttrib4dvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4dvARB_3(index, v);
    
    private VertexAttrib4fARB_adr := GetProcAddress('glVertexAttrib4fARB');
    private ntv_VertexAttrib4fARB_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; z: single; w: single)>(VertexAttrib4fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fARB(index: UInt32; x: single; y: single; z: single; w: single) :=
      ntv_VertexAttrib4fARB_1(index, x, y, z, w);
    
    private VertexAttrib4fvARB_adr := GetProcAddress('glVertexAttrib4fvARB');
    private ntv_VertexAttrib4fvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(VertexAttrib4fvARB_adr);
    private ntv_VertexAttrib4fvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4f)>(VertexAttrib4fvARB_adr);
    private ntv_VertexAttrib4fvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvARB(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4fvARB_1(index, v[0]) else
        ntv_VertexAttrib4fvARB_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvARB(index: UInt32; var v: Vec4f) :=
      ntv_VertexAttrib4fvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvARB(index: UInt32; var v: single) :=
      ntv_VertexAttrib4fvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4fvARB_3(index, v);
    
    private VertexAttrib4ivARB_adr := GetProcAddress('glVertexAttrib4ivARB');
    private ntv_VertexAttrib4ivARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttrib4ivARB_adr);
    private ntv_VertexAttrib4ivARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4i)>(VertexAttrib4ivARB_adr);
    private ntv_VertexAttrib4ivARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ivARB(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4ivARB_1(index, v[0]) else
        ntv_VertexAttrib4ivARB_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ivARB(index: UInt32; var v: Vec4i) :=
      ntv_VertexAttrib4ivARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ivARB(index: UInt32; var v: Int32) :=
      ntv_VertexAttrib4ivARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ivARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4ivARB_3(index, v);
    
    private VertexAttrib4sARB_adr := GetProcAddress('glVertexAttrib4sARB');
    private ntv_VertexAttrib4sARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16)>(VertexAttrib4sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sARB(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16) :=
      ntv_VertexAttrib4sARB_1(index, x, y, z, w);
    
    private VertexAttrib4svARB_adr := GetProcAddress('glVertexAttrib4svARB');
    private ntv_VertexAttrib4svARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib4svARB_adr);
    private ntv_VertexAttrib4svARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4s)>(VertexAttrib4svARB_adr);
    private ntv_VertexAttrib4svARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svARB(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4svARB_1(index, v[0]) else
        ntv_VertexAttrib4svARB_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svARB(index: UInt32; var v: Vec4s) :=
      ntv_VertexAttrib4svARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svARB(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib4svARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4svARB_3(index, v);
    
    private VertexAttrib4ubvARB_adr := GetProcAddress('glVertexAttrib4ubvARB');
    private ntv_VertexAttrib4ubvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(VertexAttrib4ubvARB_adr);
    private ntv_VertexAttrib4ubvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ub)>(VertexAttrib4ubvARB_adr);
    private ntv_VertexAttrib4ubvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4ubvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvARB(index: UInt32; v: array of Byte);
    type PByte = ^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4ubvARB_1(index, v[0]) else
        ntv_VertexAttrib4ubvARB_1(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvARB(index: UInt32; var v: Vec4ub) :=
      ntv_VertexAttrib4ubvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvARB(index: UInt32; var v: Byte) :=
      ntv_VertexAttrib4ubvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4ubvARB_3(index, v);
    
    private VertexAttrib4uivARB_adr := GetProcAddress('glVertexAttrib4uivARB');
    private ntv_VertexAttrib4uivARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttrib4uivARB_adr);
    private ntv_VertexAttrib4uivARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ui)>(VertexAttrib4uivARB_adr);
    private ntv_VertexAttrib4uivARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4uivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uivARB(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4uivARB_1(index, v[0]) else
        ntv_VertexAttrib4uivARB_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uivARB(index: UInt32; var v: Vec4ui) :=
      ntv_VertexAttrib4uivARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uivARB(index: UInt32; var v: UInt32) :=
      ntv_VertexAttrib4uivARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uivARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4uivARB_3(index, v);
    
    private VertexAttrib4usvARB_adr := GetProcAddress('glVertexAttrib4usvARB');
    private ntv_VertexAttrib4usvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(VertexAttrib4usvARB_adr);
    private ntv_VertexAttrib4usvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4us)>(VertexAttrib4usvARB_adr);
    private ntv_VertexAttrib4usvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4usvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usvARB(index: UInt32; v: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4usvARB_1(index, v[0]) else
        ntv_VertexAttrib4usvARB_1(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usvARB(index: UInt32; var v: Vec4us) :=
      ntv_VertexAttrib4usvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usvARB(index: UInt32; var v: UInt16) :=
      ntv_VertexAttrib4usvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4usvARB_3(index, v);
    
    private VertexAttribPointerARB_adr := GetProcAddress('glVertexAttribPointerARB');
    private ntv_VertexAttribPointerARB_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: glVertexAttribPointerType; normalized: glBool8; stride: Int32; pointer: IntPtr)>(VertexAttribPointerARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribPointerARB(index: UInt32; size: Int32; &type: glVertexAttribPointerType; normalized: glBool8; stride: Int32; pointer: IntPtr) :=
      ntv_VertexAttribPointerARB_1(index, size, &type, normalized, stride, pointer);
    
    private EnableVertexAttribArrayARB_adr := GetProcAddress('glEnableVertexAttribArrayARB');
    private ntv_EnableVertexAttribArrayARB_1 := GetProcOrNil&<procedure(index: UInt32)>(EnableVertexAttribArrayARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexAttribArrayARB(index: UInt32) :=
      ntv_EnableVertexAttribArrayARB_1(index);
    
    private DisableVertexAttribArrayARB_adr := GetProcAddress('glDisableVertexAttribArrayARB');
    private ntv_DisableVertexAttribArrayARB_1 := GetProcOrNil&<procedure(index: UInt32)>(DisableVertexAttribArrayARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexAttribArrayARB(index: UInt32) :=
      ntv_DisableVertexAttribArrayARB_1(index);
    
    private ProgramStringARB_adr := GetProcAddress('glProgramStringARB');
    private ntv_ProgramStringARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; format: glProgramFormat; len: Int32; string: IntPtr)>(ProgramStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramStringARB(target: glProgramTarget; format: glProgramFormat; len: Int32; string: string);
    begin
      var string_str_ptr := Marshal.StringToHGlobalAnsi(string);
      try
        ntv_ProgramStringARB_1(target, format, len, string_str_ptr);
      finally
        Marshal.FreeHGlobal(string_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramStringARB(target: glProgramTarget; format: glProgramFormat; len: Int32; string: IntPtr) :=
      ntv_ProgramStringARB_1(target, format, len, string);
    
    private BindProgramARB_adr := GetProcAddress('glBindProgramARB');
    private ntv_BindProgramARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; &program: gl_program)>(BindProgramARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindProgramARB(target: glProgramTarget; &program: gl_program) :=
      ntv_BindProgramARB_1(target, &program);
    
    private DeleteProgramsARB_adr := GetProcAddress('glDeleteProgramsARB');
    private ntv_DeleteProgramsARB_1 := GetProcOrNil&<procedure(n: Int32; var programs: gl_program)>(DeleteProgramsARB_adr);
    private ntv_DeleteProgramsARB_2 := GetProcOrNil&<procedure(n: Int32; programs: IntPtr)>(DeleteProgramsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; programs: array of gl_program);
    type PGl_program = ^gl_program;
    begin
      if (programs<>nil) and (programs.Length<>0) then
        ntv_DeleteProgramsARB_1(n, programs[0]) else
        ntv_DeleteProgramsARB_1(n, PGl_program(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; var programs: gl_program) :=
      ntv_DeleteProgramsARB_1(n, programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; programs: IntPtr) :=
      ntv_DeleteProgramsARB_2(n, programs);
    
    private GenProgramsARB_adr := GetProcAddress('glGenProgramsARB');
    private ntv_GenProgramsARB_1 := GetProcOrNil&<procedure(n: Int32; var programs: gl_program)>(GenProgramsARB_adr);
    private ntv_GenProgramsARB_2 := GetProcOrNil&<procedure(n: Int32; programs: IntPtr)>(GenProgramsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; programs: array of gl_program);
    type PGl_program = ^gl_program;
    begin
      if (programs<>nil) and (programs.Length<>0) then
        ntv_GenProgramsARB_1(n, programs[0]) else
        ntv_GenProgramsARB_1(n, PGl_program(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; var programs: gl_program) :=
      ntv_GenProgramsARB_1(n, programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; programs: IntPtr) :=
      ntv_GenProgramsARB_2(n, programs);
    
    private ProgramEnvParameter4dARB_adr := GetProcAddress('glProgramEnvParameter4dARB');
    private ntv_ProgramEnvParameter4dARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; x: double; y: double; z: double; w: double)>(ProgramEnvParameter4dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dARB(target: glProgramTarget; index: UInt32; x: double; y: double; z: double; w: double) :=
      ntv_ProgramEnvParameter4dARB_1(target, index, x, y, z, w);
    
    private ProgramEnvParameter4dvARB_adr := GetProcAddress('glProgramEnvParameter4dvARB');
    private ntv_ProgramEnvParameter4dvARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: double)>(ProgramEnvParameter4dvARB_adr);
    private ntv_ProgramEnvParameter4dvARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: Vec4d)>(ProgramEnvParameter4dvARB_adr);
    private ntv_ProgramEnvParameter4dvARB_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(ProgramEnvParameter4dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: glProgramTarget; index: UInt32; &params: array of double);
    type PDouble = ^double;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramEnvParameter4dvARB_1(target, index, &params[0]) else
        ntv_ProgramEnvParameter4dvARB_1(target, index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: glProgramTarget; index: UInt32; var &params: Vec4d) :=
      ntv_ProgramEnvParameter4dvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: glProgramTarget; index: UInt32; var &params: double) :=
      ntv_ProgramEnvParameter4dvARB_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_ProgramEnvParameter4dvARB_3(target, index, &params);
    
    private ProgramEnvParameter4fARB_adr := GetProcAddress('glProgramEnvParameter4fARB');
    private ntv_ProgramEnvParameter4fARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; x: single; y: single; z: single; w: single)>(ProgramEnvParameter4fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fARB(target: glProgramTarget; index: UInt32; x: single; y: single; z: single; w: single) :=
      ntv_ProgramEnvParameter4fARB_1(target, index, x, y, z, w);
    
    private ProgramEnvParameter4fvARB_adr := GetProcAddress('glProgramEnvParameter4fvARB');
    private ntv_ProgramEnvParameter4fvARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: single)>(ProgramEnvParameter4fvARB_adr);
    private ntv_ProgramEnvParameter4fvARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: Vec4f)>(ProgramEnvParameter4fvARB_adr);
    private ntv_ProgramEnvParameter4fvARB_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(ProgramEnvParameter4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: glProgramTarget; index: UInt32; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramEnvParameter4fvARB_1(target, index, &params[0]) else
        ntv_ProgramEnvParameter4fvARB_1(target, index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: glProgramTarget; index: UInt32; var &params: Vec4f) :=
      ntv_ProgramEnvParameter4fvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: glProgramTarget; index: UInt32; var &params: single) :=
      ntv_ProgramEnvParameter4fvARB_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_ProgramEnvParameter4fvARB_3(target, index, &params);
    
    private ProgramLocalParameter4dARB_adr := GetProcAddress('glProgramLocalParameter4dARB');
    private ntv_ProgramLocalParameter4dARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; x: double; y: double; z: double; w: double)>(ProgramLocalParameter4dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dARB(target: glProgramTarget; index: UInt32; x: double; y: double; z: double; w: double) :=
      ntv_ProgramLocalParameter4dARB_1(target, index, x, y, z, w);
    
    private ProgramLocalParameter4dvARB_adr := GetProcAddress('glProgramLocalParameter4dvARB');
    private ntv_ProgramLocalParameter4dvARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: double)>(ProgramLocalParameter4dvARB_adr);
    private ntv_ProgramLocalParameter4dvARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: Vec4d)>(ProgramLocalParameter4dvARB_adr);
    private ntv_ProgramLocalParameter4dvARB_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(ProgramLocalParameter4dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: glProgramTarget; index: UInt32; &params: array of double);
    type PDouble = ^double;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramLocalParameter4dvARB_1(target, index, &params[0]) else
        ntv_ProgramLocalParameter4dvARB_1(target, index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: glProgramTarget; index: UInt32; var &params: Vec4d) :=
      ntv_ProgramLocalParameter4dvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: glProgramTarget; index: UInt32; var &params: double) :=
      ntv_ProgramLocalParameter4dvARB_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_ProgramLocalParameter4dvARB_3(target, index, &params);
    
    private ProgramLocalParameter4fARB_adr := GetProcAddress('glProgramLocalParameter4fARB');
    private ntv_ProgramLocalParameter4fARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; x: single; y: single; z: single; w: single)>(ProgramLocalParameter4fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fARB(target: glProgramTarget; index: UInt32; x: single; y: single; z: single; w: single) :=
      ntv_ProgramLocalParameter4fARB_1(target, index, x, y, z, w);
    
    private ProgramLocalParameter4fvARB_adr := GetProcAddress('glProgramLocalParameter4fvARB');
    private ntv_ProgramLocalParameter4fvARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: single)>(ProgramLocalParameter4fvARB_adr);
    private ntv_ProgramLocalParameter4fvARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: Vec4f)>(ProgramLocalParameter4fvARB_adr);
    private ntv_ProgramLocalParameter4fvARB_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(ProgramLocalParameter4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: glProgramTarget; index: UInt32; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramLocalParameter4fvARB_1(target, index, &params[0]) else
        ntv_ProgramLocalParameter4fvARB_1(target, index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: glProgramTarget; index: UInt32; var &params: Vec4f) :=
      ntv_ProgramLocalParameter4fvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: glProgramTarget; index: UInt32; var &params: single) :=
      ntv_ProgramLocalParameter4fvARB_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_ProgramLocalParameter4fvARB_3(target, index, &params);
    
    private GetProgramEnvParameterdvARB_adr := GetProcAddress('glGetProgramEnvParameterdvARB');
    private ntv_GetProgramEnvParameterdvARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: double)>(GetProgramEnvParameterdvARB_adr);
    private ntv_GetProgramEnvParameterdvARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(GetProgramEnvParameterdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterdvARB(target: glProgramTarget; index: UInt32; var &params: double) :=
      ntv_GetProgramEnvParameterdvARB_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterdvARB(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_GetProgramEnvParameterdvARB_2(target, index, &params);
    
    private GetProgramEnvParameterfvARB_adr := GetProcAddress('glGetProgramEnvParameterfvARB');
    private ntv_GetProgramEnvParameterfvARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: single)>(GetProgramEnvParameterfvARB_adr);
    private ntv_GetProgramEnvParameterfvARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(GetProgramEnvParameterfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterfvARB(target: glProgramTarget; index: UInt32; var &params: single) :=
      ntv_GetProgramEnvParameterfvARB_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterfvARB(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_GetProgramEnvParameterfvARB_2(target, index, &params);
    
    private GetProgramLocalParameterdvARB_adr := GetProcAddress('glGetProgramLocalParameterdvARB');
    private ntv_GetProgramLocalParameterdvARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: double)>(GetProgramLocalParameterdvARB_adr);
    private ntv_GetProgramLocalParameterdvARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(GetProgramLocalParameterdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterdvARB(target: glProgramTarget; index: UInt32; var &params: double) :=
      ntv_GetProgramLocalParameterdvARB_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterdvARB(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_GetProgramLocalParameterdvARB_2(target, index, &params);
    
    private GetProgramLocalParameterfvARB_adr := GetProcAddress('glGetProgramLocalParameterfvARB');
    private ntv_GetProgramLocalParameterfvARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: single)>(GetProgramLocalParameterfvARB_adr);
    private ntv_GetProgramLocalParameterfvARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(GetProgramLocalParameterfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterfvARB(target: glProgramTarget; index: UInt32; var &params: single) :=
      ntv_GetProgramLocalParameterfvARB_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterfvARB(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_GetProgramLocalParameterfvARB_2(target, index, &params);
    
    private GetProgramivARB_adr := GetProcAddress('glGetProgramivARB');
    private ntv_GetProgramivARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; pname: glProgramProperty; var &params: Int32)>(GetProgramivARB_adr);
    private ntv_GetProgramivARB_2 := GetProcOrNil&<procedure(target: glProgramTarget; pname: glProgramProperty; &params: IntPtr)>(GetProgramivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivARB(target: glProgramTarget; pname: glProgramProperty; var &params: Int32) :=
      ntv_GetProgramivARB_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivARB(target: glProgramTarget; pname: glProgramProperty; &params: IntPtr) :=
      ntv_GetProgramivARB_2(target, pname, &params);
    
    private GetProgramStringARB_adr := GetProcAddress('glGetProgramStringARB');
    private ntv_GetProgramStringARB_1 := GetProcOrNil&<procedure(target: glProgramTarget; pname: glProgramStringProperty; string: IntPtr)>(GetProgramStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStringARB(target: glProgramTarget; pname: glProgramStringProperty; string: IntPtr) :=
      ntv_GetProgramStringARB_1(target, pname, string);
    
    private GetVertexAttribdvARB_adr := GetProcAddress('glGetVertexAttribdvARB');
    private ntv_GetVertexAttribdvARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; var &params: double)>(GetVertexAttribdvARB_adr);
    private ntv_GetVertexAttribdvARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr)>(GetVertexAttribdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvARB(index: UInt32; pname: glVertexAttribProperty; var &params: double) :=
      ntv_GetVertexAttribdvARB_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvARB(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr) :=
      ntv_GetVertexAttribdvARB_2(index, pname, &params);
    
    private GetVertexAttribfvARB_adr := GetProcAddress('glGetVertexAttribfvARB');
    private ntv_GetVertexAttribfvARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; var &params: single)>(GetVertexAttribfvARB_adr);
    private ntv_GetVertexAttribfvARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr)>(GetVertexAttribfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvARB(index: UInt32; pname: glVertexAttribProperty; var &params: single) :=
      ntv_GetVertexAttribfvARB_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvARB(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr) :=
      ntv_GetVertexAttribfvARB_2(index, pname, &params);
    
    private GetVertexAttribivARB_adr := GetProcAddress('glGetVertexAttribivARB');
    private ntv_GetVertexAttribivARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; var &params: Int32)>(GetVertexAttribivARB_adr);
    private ntv_GetVertexAttribivARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr)>(GetVertexAttribivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivARB(index: UInt32; pname: glVertexAttribProperty; var &params: Int32) :=
      ntv_GetVertexAttribivARB_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivARB(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr) :=
      ntv_GetVertexAttribivARB_2(index, pname, &params);
    
    private GetVertexAttribPointervARB_adr := GetProcAddress('glGetVertexAttribPointervARB');
    private ntv_GetVertexAttribPointervARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribPointerProperty; var pointer: IntPtr)>(GetVertexAttribPointervARB_adr);
    private ntv_GetVertexAttribPointervARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribPointerProperty; pointer: pointer)>(GetVertexAttribPointervARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervARB(index: UInt32; pname: glVertexAttribPointerProperty; var pointer: IntPtr) :=
      ntv_GetVertexAttribPointervARB_1(index, pname, pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervARB(index: UInt32; pname: glVertexAttribPointerProperty; pointer: pointer) :=
      ntv_GetVertexAttribPointervARB_2(index, pname, pointer);
    
    private IsProgramARB_adr := GetProcAddress('glIsProgramARB');
    private ntv_IsProgramARB_1 := GetProcOrNil&<function(&program: gl_program): glBool8>(IsProgramARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsProgramARB(&program: gl_program): glBool8 :=
      ntv_IsProgramARB_1(&program);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexShaderARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_vertex_shader';
    
    private VertexAttrib1fARB_adr := GetProcAddress('glVertexAttrib1fARB');
    private ntv_VertexAttrib1fARB_1 := GetProcOrNil&<procedure(index: UInt32; x: single)>(VertexAttrib1fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fARB(index: UInt32; x: single) :=
      ntv_VertexAttrib1fARB_1(index, x);
    
    private VertexAttrib1sARB_adr := GetProcAddress('glVertexAttrib1sARB');
    private ntv_VertexAttrib1sARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16)>(VertexAttrib1sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sARB(index: UInt32; x: Int16) :=
      ntv_VertexAttrib1sARB_1(index, x);
    
    private VertexAttrib1dARB_adr := GetProcAddress('glVertexAttrib1dARB');
    private ntv_VertexAttrib1dARB_1 := GetProcOrNil&<procedure(index: UInt32; x: double)>(VertexAttrib1dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dARB(index: UInt32; x: double) :=
      ntv_VertexAttrib1dARB_1(index, x);
    
    private VertexAttrib2fARB_adr := GetProcAddress('glVertexAttrib2fARB');
    private ntv_VertexAttrib2fARB_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single)>(VertexAttrib2fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fARB(index: UInt32; x: single; y: single) :=
      ntv_VertexAttrib2fARB_1(index, x, y);
    
    private VertexAttrib2sARB_adr := GetProcAddress('glVertexAttrib2sARB');
    private ntv_VertexAttrib2sARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16)>(VertexAttrib2sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sARB(index: UInt32; x: Int16; y: Int16) :=
      ntv_VertexAttrib2sARB_1(index, x, y);
    
    private VertexAttrib2dARB_adr := GetProcAddress('glVertexAttrib2dARB');
    private ntv_VertexAttrib2dARB_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double)>(VertexAttrib2dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dARB(index: UInt32; x: double; y: double) :=
      ntv_VertexAttrib2dARB_1(index, x, y);
    
    private VertexAttrib3fARB_adr := GetProcAddress('glVertexAttrib3fARB');
    private ntv_VertexAttrib3fARB_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; z: single)>(VertexAttrib3fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fARB(index: UInt32; x: single; y: single; z: single) :=
      ntv_VertexAttrib3fARB_1(index, x, y, z);
    
    private VertexAttrib3sARB_adr := GetProcAddress('glVertexAttrib3sARB');
    private ntv_VertexAttrib3sARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16)>(VertexAttrib3sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sARB(index: UInt32; x: Int16; y: Int16; z: Int16) :=
      ntv_VertexAttrib3sARB_1(index, x, y, z);
    
    private VertexAttrib3dARB_adr := GetProcAddress('glVertexAttrib3dARB');
    private ntv_VertexAttrib3dARB_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double; z: double)>(VertexAttrib3dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dARB(index: UInt32; x: double; y: double; z: double) :=
      ntv_VertexAttrib3dARB_1(index, x, y, z);
    
    private VertexAttrib4fARB_adr := GetProcAddress('glVertexAttrib4fARB');
    private ntv_VertexAttrib4fARB_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; z: single; w: single)>(VertexAttrib4fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fARB(index: UInt32; x: single; y: single; z: single; w: single) :=
      ntv_VertexAttrib4fARB_1(index, x, y, z, w);
    
    private VertexAttrib4sARB_adr := GetProcAddress('glVertexAttrib4sARB');
    private ntv_VertexAttrib4sARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16)>(VertexAttrib4sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sARB(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16) :=
      ntv_VertexAttrib4sARB_1(index, x, y, z, w);
    
    private VertexAttrib4dARB_adr := GetProcAddress('glVertexAttrib4dARB');
    private ntv_VertexAttrib4dARB_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double; z: double; w: double)>(VertexAttrib4dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dARB(index: UInt32; x: double; y: double; z: double; w: double) :=
      ntv_VertexAttrib4dARB_1(index, x, y, z, w);
    
    private VertexAttrib4NubARB_adr := GetProcAddress('glVertexAttrib4NubARB');
    private ntv_VertexAttrib4NubARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte)>(VertexAttrib4NubARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubARB(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte) :=
      ntv_VertexAttrib4NubARB_1(index, x, y, z, w);
    
    private VertexAttrib1fvARB_adr := GetProcAddress('glVertexAttrib1fvARB');
    private ntv_VertexAttrib1fvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(VertexAttrib1fvARB_adr);
    private ntv_VertexAttrib1fvARB_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib1fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvARB(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib1fvARB_1(index, v[0]) else
        ntv_VertexAttrib1fvARB_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvARB(index: UInt32; var v: single) :=
      ntv_VertexAttrib1fvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib1fvARB_2(index, v);
    
    private VertexAttrib1svARB_adr := GetProcAddress('glVertexAttrib1svARB');
    private ntv_VertexAttrib1svARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib1svARB_adr);
    private ntv_VertexAttrib1svARB_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib1svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svARB(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib1svARB_1(index, v[0]) else
        ntv_VertexAttrib1svARB_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svARB(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib1svARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib1svARB_2(index, v);
    
    private VertexAttrib1dvARB_adr := GetProcAddress('glVertexAttrib1dvARB');
    private ntv_VertexAttrib1dvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttrib1dvARB_adr);
    private ntv_VertexAttrib1dvARB_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib1dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvARB(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib1dvARB_1(index, v[0]) else
        ntv_VertexAttrib1dvARB_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvARB(index: UInt32; var v: double) :=
      ntv_VertexAttrib1dvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib1dvARB_2(index, v);
    
    private VertexAttrib2fvARB_adr := GetProcAddress('glVertexAttrib2fvARB');
    private ntv_VertexAttrib2fvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(VertexAttrib2fvARB_adr);
    private ntv_VertexAttrib2fvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2f)>(VertexAttrib2fvARB_adr);
    private ntv_VertexAttrib2fvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib2fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvARB(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib2fvARB_1(index, v[0]) else
        ntv_VertexAttrib2fvARB_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvARB(index: UInt32; var v: Vec2f) :=
      ntv_VertexAttrib2fvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvARB(index: UInt32; var v: single) :=
      ntv_VertexAttrib2fvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib2fvARB_3(index, v);
    
    private VertexAttrib2svARB_adr := GetProcAddress('glVertexAttrib2svARB');
    private ntv_VertexAttrib2svARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib2svARB_adr);
    private ntv_VertexAttrib2svARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2s)>(VertexAttrib2svARB_adr);
    private ntv_VertexAttrib2svARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib2svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svARB(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib2svARB_1(index, v[0]) else
        ntv_VertexAttrib2svARB_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svARB(index: UInt32; var v: Vec2s) :=
      ntv_VertexAttrib2svARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svARB(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib2svARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib2svARB_3(index, v);
    
    private VertexAttrib2dvARB_adr := GetProcAddress('glVertexAttrib2dvARB');
    private ntv_VertexAttrib2dvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttrib2dvARB_adr);
    private ntv_VertexAttrib2dvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2d)>(VertexAttrib2dvARB_adr);
    private ntv_VertexAttrib2dvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib2dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvARB(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib2dvARB_1(index, v[0]) else
        ntv_VertexAttrib2dvARB_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvARB(index: UInt32; var v: Vec2d) :=
      ntv_VertexAttrib2dvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvARB(index: UInt32; var v: double) :=
      ntv_VertexAttrib2dvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib2dvARB_3(index, v);
    
    private VertexAttrib3fvARB_adr := GetProcAddress('glVertexAttrib3fvARB');
    private ntv_VertexAttrib3fvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(VertexAttrib3fvARB_adr);
    private ntv_VertexAttrib3fvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3f)>(VertexAttrib3fvARB_adr);
    private ntv_VertexAttrib3fvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib3fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvARB(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib3fvARB_1(index, v[0]) else
        ntv_VertexAttrib3fvARB_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvARB(index: UInt32; var v: Vec3f) :=
      ntv_VertexAttrib3fvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvARB(index: UInt32; var v: single) :=
      ntv_VertexAttrib3fvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib3fvARB_3(index, v);
    
    private VertexAttrib3svARB_adr := GetProcAddress('glVertexAttrib3svARB');
    private ntv_VertexAttrib3svARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib3svARB_adr);
    private ntv_VertexAttrib3svARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3s)>(VertexAttrib3svARB_adr);
    private ntv_VertexAttrib3svARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib3svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svARB(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib3svARB_1(index, v[0]) else
        ntv_VertexAttrib3svARB_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svARB(index: UInt32; var v: Vec3s) :=
      ntv_VertexAttrib3svARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svARB(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib3svARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib3svARB_3(index, v);
    
    private VertexAttrib3dvARB_adr := GetProcAddress('glVertexAttrib3dvARB');
    private ntv_VertexAttrib3dvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttrib3dvARB_adr);
    private ntv_VertexAttrib3dvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3d)>(VertexAttrib3dvARB_adr);
    private ntv_VertexAttrib3dvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib3dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvARB(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib3dvARB_1(index, v[0]) else
        ntv_VertexAttrib3dvARB_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvARB(index: UInt32; var v: Vec3d) :=
      ntv_VertexAttrib3dvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvARB(index: UInt32; var v: double) :=
      ntv_VertexAttrib3dvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib3dvARB_3(index, v);
    
    private VertexAttrib4fvARB_adr := GetProcAddress('glVertexAttrib4fvARB');
    private ntv_VertexAttrib4fvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(VertexAttrib4fvARB_adr);
    private ntv_VertexAttrib4fvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4f)>(VertexAttrib4fvARB_adr);
    private ntv_VertexAttrib4fvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvARB(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4fvARB_1(index, v[0]) else
        ntv_VertexAttrib4fvARB_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvARB(index: UInt32; var v: Vec4f) :=
      ntv_VertexAttrib4fvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvARB(index: UInt32; var v: single) :=
      ntv_VertexAttrib4fvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4fvARB_3(index, v);
    
    private VertexAttrib4svARB_adr := GetProcAddress('glVertexAttrib4svARB');
    private ntv_VertexAttrib4svARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib4svARB_adr);
    private ntv_VertexAttrib4svARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4s)>(VertexAttrib4svARB_adr);
    private ntv_VertexAttrib4svARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svARB(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4svARB_1(index, v[0]) else
        ntv_VertexAttrib4svARB_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svARB(index: UInt32; var v: Vec4s) :=
      ntv_VertexAttrib4svARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svARB(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib4svARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4svARB_3(index, v);
    
    private VertexAttrib4dvARB_adr := GetProcAddress('glVertexAttrib4dvARB');
    private ntv_VertexAttrib4dvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttrib4dvARB_adr);
    private ntv_VertexAttrib4dvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4d)>(VertexAttrib4dvARB_adr);
    private ntv_VertexAttrib4dvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvARB(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4dvARB_1(index, v[0]) else
        ntv_VertexAttrib4dvARB_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvARB(index: UInt32; var v: Vec4d) :=
      ntv_VertexAttrib4dvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvARB(index: UInt32; var v: double) :=
      ntv_VertexAttrib4dvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4dvARB_3(index, v);
    
    private VertexAttrib4ivARB_adr := GetProcAddress('glVertexAttrib4ivARB');
    private ntv_VertexAttrib4ivARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttrib4ivARB_adr);
    private ntv_VertexAttrib4ivARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4i)>(VertexAttrib4ivARB_adr);
    private ntv_VertexAttrib4ivARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ivARB(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4ivARB_1(index, v[0]) else
        ntv_VertexAttrib4ivARB_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ivARB(index: UInt32; var v: Vec4i) :=
      ntv_VertexAttrib4ivARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ivARB(index: UInt32; var v: Int32) :=
      ntv_VertexAttrib4ivARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ivARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4ivARB_3(index, v);
    
    private VertexAttrib4bvARB_adr := GetProcAddress('glVertexAttrib4bvARB');
    private ntv_VertexAttrib4bvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(VertexAttrib4bvARB_adr);
    private ntv_VertexAttrib4bvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4b)>(VertexAttrib4bvARB_adr);
    private ntv_VertexAttrib4bvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4bvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bvARB(index: UInt32; v: array of SByte);
    type PSByte = ^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4bvARB_1(index, v[0]) else
        ntv_VertexAttrib4bvARB_1(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bvARB(index: UInt32; var v: Vec4b) :=
      ntv_VertexAttrib4bvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bvARB(index: UInt32; var v: SByte) :=
      ntv_VertexAttrib4bvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4bvARB_3(index, v);
    
    private VertexAttrib4ubvARB_adr := GetProcAddress('glVertexAttrib4ubvARB');
    private ntv_VertexAttrib4ubvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(VertexAttrib4ubvARB_adr);
    private ntv_VertexAttrib4ubvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ub)>(VertexAttrib4ubvARB_adr);
    private ntv_VertexAttrib4ubvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4ubvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvARB(index: UInt32; v: array of Byte);
    type PByte = ^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4ubvARB_1(index, v[0]) else
        ntv_VertexAttrib4ubvARB_1(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvARB(index: UInt32; var v: Vec4ub) :=
      ntv_VertexAttrib4ubvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvARB(index: UInt32; var v: Byte) :=
      ntv_VertexAttrib4ubvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4ubvARB_3(index, v);
    
    private VertexAttrib4usvARB_adr := GetProcAddress('glVertexAttrib4usvARB');
    private ntv_VertexAttrib4usvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(VertexAttrib4usvARB_adr);
    private ntv_VertexAttrib4usvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4us)>(VertexAttrib4usvARB_adr);
    private ntv_VertexAttrib4usvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4usvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usvARB(index: UInt32; v: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4usvARB_1(index, v[0]) else
        ntv_VertexAttrib4usvARB_1(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usvARB(index: UInt32; var v: Vec4us) :=
      ntv_VertexAttrib4usvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usvARB(index: UInt32; var v: UInt16) :=
      ntv_VertexAttrib4usvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4usvARB_3(index, v);
    
    private VertexAttrib4uivARB_adr := GetProcAddress('glVertexAttrib4uivARB');
    private ntv_VertexAttrib4uivARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttrib4uivARB_adr);
    private ntv_VertexAttrib4uivARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ui)>(VertexAttrib4uivARB_adr);
    private ntv_VertexAttrib4uivARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4uivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uivARB(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4uivARB_1(index, v[0]) else
        ntv_VertexAttrib4uivARB_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uivARB(index: UInt32; var v: Vec4ui) :=
      ntv_VertexAttrib4uivARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uivARB(index: UInt32; var v: UInt32) :=
      ntv_VertexAttrib4uivARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uivARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4uivARB_3(index, v);
    
    private VertexAttrib4NbvARB_adr := GetProcAddress('glVertexAttrib4NbvARB');
    private ntv_VertexAttrib4NbvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(VertexAttrib4NbvARB_adr);
    private ntv_VertexAttrib4NbvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4b)>(VertexAttrib4NbvARB_adr);
    private ntv_VertexAttrib4NbvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4NbvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NbvARB(index: UInt32; v: array of SByte);
    type PSByte = ^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4NbvARB_1(index, v[0]) else
        ntv_VertexAttrib4NbvARB_1(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NbvARB(index: UInt32; var v: Vec4b) :=
      ntv_VertexAttrib4NbvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NbvARB(index: UInt32; var v: SByte) :=
      ntv_VertexAttrib4NbvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NbvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4NbvARB_3(index, v);
    
    private VertexAttrib4NsvARB_adr := GetProcAddress('glVertexAttrib4NsvARB');
    private ntv_VertexAttrib4NsvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib4NsvARB_adr);
    private ntv_VertexAttrib4NsvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4s)>(VertexAttrib4NsvARB_adr);
    private ntv_VertexAttrib4NsvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4NsvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NsvARB(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4NsvARB_1(index, v[0]) else
        ntv_VertexAttrib4NsvARB_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NsvARB(index: UInt32; var v: Vec4s) :=
      ntv_VertexAttrib4NsvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NsvARB(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib4NsvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NsvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4NsvARB_3(index, v);
    
    private VertexAttrib4NivARB_adr := GetProcAddress('glVertexAttrib4NivARB');
    private ntv_VertexAttrib4NivARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttrib4NivARB_adr);
    private ntv_VertexAttrib4NivARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4i)>(VertexAttrib4NivARB_adr);
    private ntv_VertexAttrib4NivARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4NivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NivARB(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4NivARB_1(index, v[0]) else
        ntv_VertexAttrib4NivARB_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NivARB(index: UInt32; var v: Vec4i) :=
      ntv_VertexAttrib4NivARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NivARB(index: UInt32; var v: Int32) :=
      ntv_VertexAttrib4NivARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NivARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4NivARB_3(index, v);
    
    private VertexAttrib4NubvARB_adr := GetProcAddress('glVertexAttrib4NubvARB');
    private ntv_VertexAttrib4NubvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(VertexAttrib4NubvARB_adr);
    private ntv_VertexAttrib4NubvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ub)>(VertexAttrib4NubvARB_adr);
    private ntv_VertexAttrib4NubvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4NubvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubvARB(index: UInt32; v: array of Byte);
    type PByte = ^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4NubvARB_1(index, v[0]) else
        ntv_VertexAttrib4NubvARB_1(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubvARB(index: UInt32; var v: Vec4ub) :=
      ntv_VertexAttrib4NubvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubvARB(index: UInt32; var v: Byte) :=
      ntv_VertexAttrib4NubvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4NubvARB_3(index, v);
    
    private VertexAttrib4NusvARB_adr := GetProcAddress('glVertexAttrib4NusvARB');
    private ntv_VertexAttrib4NusvARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(VertexAttrib4NusvARB_adr);
    private ntv_VertexAttrib4NusvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4us)>(VertexAttrib4NusvARB_adr);
    private ntv_VertexAttrib4NusvARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4NusvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NusvARB(index: UInt32; v: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4NusvARB_1(index, v[0]) else
        ntv_VertexAttrib4NusvARB_1(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NusvARB(index: UInt32; var v: Vec4us) :=
      ntv_VertexAttrib4NusvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NusvARB(index: UInt32; var v: UInt16) :=
      ntv_VertexAttrib4NusvARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NusvARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4NusvARB_3(index, v);
    
    private VertexAttrib4NuivARB_adr := GetProcAddress('glVertexAttrib4NuivARB');
    private ntv_VertexAttrib4NuivARB_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttrib4NuivARB_adr);
    private ntv_VertexAttrib4NuivARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ui)>(VertexAttrib4NuivARB_adr);
    private ntv_VertexAttrib4NuivARB_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4NuivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NuivARB(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4NuivARB_1(index, v[0]) else
        ntv_VertexAttrib4NuivARB_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NuivARB(index: UInt32; var v: Vec4ui) :=
      ntv_VertexAttrib4NuivARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NuivARB(index: UInt32; var v: UInt32) :=
      ntv_VertexAttrib4NuivARB_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NuivARB(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4NuivARB_3(index, v);
    
    private VertexAttribPointerARB_adr := GetProcAddress('glVertexAttribPointerARB');
    private ntv_VertexAttribPointerARB_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: glVertexAttribPointerType; normalized: glBool8; stride: Int32; pointer: IntPtr)>(VertexAttribPointerARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribPointerARB(index: UInt32; size: Int32; &type: glVertexAttribPointerType; normalized: glBool8; stride: Int32; pointer: IntPtr) :=
      ntv_VertexAttribPointerARB_1(index, size, &type, normalized, stride, pointer);
    
    private EnableVertexAttribArrayARB_adr := GetProcAddress('glEnableVertexAttribArrayARB');
    private ntv_EnableVertexAttribArrayARB_1 := GetProcOrNil&<procedure(index: UInt32)>(EnableVertexAttribArrayARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexAttribArrayARB(index: UInt32) :=
      ntv_EnableVertexAttribArrayARB_1(index);
    
    private DisableVertexAttribArrayARB_adr := GetProcAddress('glDisableVertexAttribArrayARB');
    private ntv_DisableVertexAttribArrayARB_1 := GetProcOrNil&<procedure(index: UInt32)>(DisableVertexAttribArrayARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexAttribArrayARB(index: UInt32) :=
      ntv_DisableVertexAttribArrayARB_1(index);
    
    private BindAttribLocationARB_adr := GetProcAddress('glBindAttribLocationARB');
    private ntv_BindAttribLocationARB_1 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; name: IntPtr)>(BindAttribLocationARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindAttribLocationARB(programObj: gl_handle_ARB; index: UInt32; name: string);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_BindAttribLocationARB_1(programObj, index, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindAttribLocationARB(programObj: gl_handle_ARB; index: UInt32; name: IntPtr) :=
      ntv_BindAttribLocationARB_1(programObj, index, name);
    
    private GetActiveAttribARB_adr := GetProcAddress('glGetActiveAttribARB');
    private ntv_GetActiveAttribARB_1 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; var &type: glAttributeType; name: IntPtr)>(GetActiveAttribARB_adr);
    private ntv_GetActiveAttribARB_2 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr)>(GetActiveAttribARB_adr);
    private ntv_GetActiveAttribARB_3 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; size: IntPtr; var &type: glAttributeType; name: IntPtr)>(GetActiveAttribARB_adr);
    private ntv_GetActiveAttribARB_4 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr)>(GetActiveAttribARB_adr);
    private ntv_GetActiveAttribARB_5 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; var size: Int32; var &type: glAttributeType; name: IntPtr)>(GetActiveAttribARB_adr);
    private ntv_GetActiveAttribARB_6 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr)>(GetActiveAttribARB_adr);
    private ntv_GetActiveAttribARB_7 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; size: IntPtr; var &type: glAttributeType; name: IntPtr)>(GetActiveAttribARB_adr);
    private ntv_GetActiveAttribARB_8 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr)>(GetActiveAttribARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; var &type: glAttributeType; name: IntPtr) :=
      ntv_GetActiveAttribARB_1(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveAttribARB_2(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; size: IntPtr; var &type: glAttributeType; name: IntPtr) :=
      ntv_GetActiveAttribARB_3(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveAttribARB_4(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; var size: Int32; var &type: glAttributeType; name: IntPtr) :=
      ntv_GetActiveAttribARB_5(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveAttribARB_6(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; size: IntPtr; var &type: glAttributeType; name: IntPtr) :=
      ntv_GetActiveAttribARB_7(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveAttribARB_8(programObj, index, maxLength, length, size, &type, name);
    
    private GetAttribLocationARB_adr := GetProcAddress('glGetAttribLocationARB');
    private ntv_GetAttribLocationARB_1 := GetProcOrNil&<function(programObj: gl_handle_ARB; name: IntPtr): Int32>(GetAttribLocationARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAttribLocationARB(programObj: gl_handle_ARB; name: string): Int32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetAttribLocationARB_1(programObj, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAttribLocationARB(programObj: gl_handle_ARB; name: IntPtr): Int32 :=
      ntv_GetAttribLocationARB_1(programObj, name);
    
    private GetVertexAttribdvARB_adr := GetProcAddress('glGetVertexAttribdvARB');
    private ntv_GetVertexAttribdvARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; var &params: double)>(GetVertexAttribdvARB_adr);
    private ntv_GetVertexAttribdvARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr)>(GetVertexAttribdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvARB(index: UInt32; pname: glVertexAttribProperty; var &params: double) :=
      ntv_GetVertexAttribdvARB_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvARB(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr) :=
      ntv_GetVertexAttribdvARB_2(index, pname, &params);
    
    private GetVertexAttribfvARB_adr := GetProcAddress('glGetVertexAttribfvARB');
    private ntv_GetVertexAttribfvARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; var &params: single)>(GetVertexAttribfvARB_adr);
    private ntv_GetVertexAttribfvARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr)>(GetVertexAttribfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvARB(index: UInt32; pname: glVertexAttribProperty; var &params: single) :=
      ntv_GetVertexAttribfvARB_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvARB(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr) :=
      ntv_GetVertexAttribfvARB_2(index, pname, &params);
    
    private GetVertexAttribivARB_adr := GetProcAddress('glGetVertexAttribivARB');
    private ntv_GetVertexAttribivARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; var &params: Int32)>(GetVertexAttribivARB_adr);
    private ntv_GetVertexAttribivARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr)>(GetVertexAttribivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivARB(index: UInt32; pname: glVertexAttribProperty; var &params: Int32) :=
      ntv_GetVertexAttribivARB_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivARB(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr) :=
      ntv_GetVertexAttribivARB_2(index, pname, &params);
    
    private GetVertexAttribPointervARB_adr := GetProcAddress('glGetVertexAttribPointervARB');
    private ntv_GetVertexAttribPointervARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribPointerProperty; var pointer: IntPtr)>(GetVertexAttribPointervARB_adr);
    private ntv_GetVertexAttribPointervARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribPointerProperty; pointer: pointer)>(GetVertexAttribPointervARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervARB(index: UInt32; pname: glVertexAttribPointerProperty; var pointer: IntPtr) :=
      ntv_GetVertexAttribPointervARB_1(index, pname, pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervARB(index: UInt32; pname: glVertexAttribPointerProperty; pointer: pointer) :=
      ntv_GetVertexAttribPointervARB_2(index, pname, pointer);
    
  end;
  
  ///
  glVertexType10f11f11fRevARB = static class
    public const _ExtStr = 'GL_ARB_vertex_type_10f_11f_11f_rev';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexType2101010RevARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_vertex_type_2_10_10_10_rev';
    
    private VertexAttribP1ui_adr := GetProcAddress('glVertexAttribP1ui');
    private ntv_VertexAttribP1ui_1 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: UInt32)>(VertexAttribP1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1ui(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: UInt32) :=
      ntv_VertexAttribP1ui_1(index, &type, normalized, value);
    
    private VertexAttribP1uiv_adr := GetProcAddress('glVertexAttribP1uiv');
    private ntv_VertexAttribP1uiv_1 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; var value: UInt32)>(VertexAttribP1uiv_adr);
    private ntv_VertexAttribP1uiv_2 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: IntPtr)>(VertexAttribP1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_VertexAttribP1uiv_1(index, &type, normalized, value[0]) else
        ntv_VertexAttribP1uiv_1(index, &type, normalized, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; var value: UInt32) :=
      ntv_VertexAttribP1uiv_1(index, &type, normalized, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: IntPtr) :=
      ntv_VertexAttribP1uiv_2(index, &type, normalized, value);
    
    private VertexAttribP2ui_adr := GetProcAddress('glVertexAttribP2ui');
    private ntv_VertexAttribP2ui_1 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: UInt32)>(VertexAttribP2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2ui(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: UInt32) :=
      ntv_VertexAttribP2ui_1(index, &type, normalized, value);
    
    private VertexAttribP2uiv_adr := GetProcAddress('glVertexAttribP2uiv');
    private ntv_VertexAttribP2uiv_1 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; var value: UInt32)>(VertexAttribP2uiv_adr);
    private ntv_VertexAttribP2uiv_2 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: IntPtr)>(VertexAttribP2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_VertexAttribP2uiv_1(index, &type, normalized, value[0]) else
        ntv_VertexAttribP2uiv_1(index, &type, normalized, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; var value: UInt32) :=
      ntv_VertexAttribP2uiv_1(index, &type, normalized, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: IntPtr) :=
      ntv_VertexAttribP2uiv_2(index, &type, normalized, value);
    
    private VertexAttribP3ui_adr := GetProcAddress('glVertexAttribP3ui');
    private ntv_VertexAttribP3ui_1 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: UInt32)>(VertexAttribP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3ui(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: UInt32) :=
      ntv_VertexAttribP3ui_1(index, &type, normalized, value);
    
    private VertexAttribP3uiv_adr := GetProcAddress('glVertexAttribP3uiv');
    private ntv_VertexAttribP3uiv_1 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; var value: UInt32)>(VertexAttribP3uiv_adr);
    private ntv_VertexAttribP3uiv_2 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: IntPtr)>(VertexAttribP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_VertexAttribP3uiv_1(index, &type, normalized, value[0]) else
        ntv_VertexAttribP3uiv_1(index, &type, normalized, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; var value: UInt32) :=
      ntv_VertexAttribP3uiv_1(index, &type, normalized, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: IntPtr) :=
      ntv_VertexAttribP3uiv_2(index, &type, normalized, value);
    
    private VertexAttribP4ui_adr := GetProcAddress('glVertexAttribP4ui');
    private ntv_VertexAttribP4ui_1 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: UInt32)>(VertexAttribP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4ui(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: UInt32) :=
      ntv_VertexAttribP4ui_1(index, &type, normalized, value);
    
    private VertexAttribP4uiv_adr := GetProcAddress('glVertexAttribP4uiv');
    private ntv_VertexAttribP4uiv_1 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; var value: UInt32)>(VertexAttribP4uiv_adr);
    private ntv_VertexAttribP4uiv_2 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: IntPtr)>(VertexAttribP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_VertexAttribP4uiv_1(index, &type, normalized, value[0]) else
        ntv_VertexAttribP4uiv_1(index, &type, normalized, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; var value: UInt32) :=
      ntv_VertexAttribP4uiv_1(index, &type, normalized, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: IntPtr) :=
      ntv_VertexAttribP4uiv_2(index, &type, normalized, value);
    
    private VertexP2ui_adr := GetProcAddress('glVertexP2ui');
    private ntv_VertexP2ui_1 := GetProcOrNil&<procedure(&type: glVertexPointerType; value: UInt32)>(VertexP2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2ui(&type: glVertexPointerType; value: UInt32) :=
      ntv_VertexP2ui_1(&type, value);
    
    private VertexP2uiv_adr := GetProcAddress('glVertexP2uiv');
    private ntv_VertexP2uiv_1 := GetProcOrNil&<procedure(&type: glVertexPointerType; var value: UInt32)>(VertexP2uiv_adr);
    private ntv_VertexP2uiv_2 := GetProcOrNil&<procedure(&type: glVertexPointerType; value: IntPtr)>(VertexP2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: glVertexPointerType; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_VertexP2uiv_1(&type, value[0]) else
        ntv_VertexP2uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: glVertexPointerType; var value: UInt32) :=
      ntv_VertexP2uiv_1(&type, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: glVertexPointerType; value: IntPtr) :=
      ntv_VertexP2uiv_2(&type, value);
    
    private VertexP3ui_adr := GetProcAddress('glVertexP3ui');
    private ntv_VertexP3ui_1 := GetProcOrNil&<procedure(&type: glVertexPointerType; value: UInt32)>(VertexP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3ui(&type: glVertexPointerType; value: UInt32) :=
      ntv_VertexP3ui_1(&type, value);
    
    private VertexP3uiv_adr := GetProcAddress('glVertexP3uiv');
    private ntv_VertexP3uiv_1 := GetProcOrNil&<procedure(&type: glVertexPointerType; var value: UInt32)>(VertexP3uiv_adr);
    private ntv_VertexP3uiv_2 := GetProcOrNil&<procedure(&type: glVertexPointerType; value: IntPtr)>(VertexP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: glVertexPointerType; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_VertexP3uiv_1(&type, value[0]) else
        ntv_VertexP3uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: glVertexPointerType; var value: UInt32) :=
      ntv_VertexP3uiv_1(&type, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: glVertexPointerType; value: IntPtr) :=
      ntv_VertexP3uiv_2(&type, value);
    
    private VertexP4ui_adr := GetProcAddress('glVertexP4ui');
    private ntv_VertexP4ui_1 := GetProcOrNil&<procedure(&type: glVertexPointerType; value: UInt32)>(VertexP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4ui(&type: glVertexPointerType; value: UInt32) :=
      ntv_VertexP4ui_1(&type, value);
    
    private VertexP4uiv_adr := GetProcAddress('glVertexP4uiv');
    private ntv_VertexP4uiv_1 := GetProcOrNil&<procedure(&type: glVertexPointerType; var value: UInt32)>(VertexP4uiv_adr);
    private ntv_VertexP4uiv_2 := GetProcOrNil&<procedure(&type: glVertexPointerType; value: IntPtr)>(VertexP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: glVertexPointerType; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_VertexP4uiv_1(&type, value[0]) else
        ntv_VertexP4uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: glVertexPointerType; var value: UInt32) :=
      ntv_VertexP4uiv_1(&type, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: glVertexPointerType; value: IntPtr) :=
      ntv_VertexP4uiv_2(&type, value);
    
    private TexCoordP1ui_adr := GetProcAddress('glTexCoordP1ui');
    private ntv_TexCoordP1ui_1 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; coords: UInt32)>(TexCoordP1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1ui(&type: glTexCoordPointerType; coords: UInt32) :=
      ntv_TexCoordP1ui_1(&type, coords);
    
    private TexCoordP1uiv_adr := GetProcAddress('glTexCoordP1uiv');
    private ntv_TexCoordP1uiv_1 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; var coords: UInt32)>(TexCoordP1uiv_adr);
    private ntv_TexCoordP1uiv_2 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; coords: IntPtr)>(TexCoordP1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: glTexCoordPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_TexCoordP1uiv_1(&type, coords[0]) else
        ntv_TexCoordP1uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: glTexCoordPointerType; var coords: UInt32) :=
      ntv_TexCoordP1uiv_1(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: glTexCoordPointerType; coords: IntPtr) :=
      ntv_TexCoordP1uiv_2(&type, coords);
    
    private TexCoordP2ui_adr := GetProcAddress('glTexCoordP2ui');
    private ntv_TexCoordP2ui_1 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; coords: UInt32)>(TexCoordP2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2ui(&type: glTexCoordPointerType; coords: UInt32) :=
      ntv_TexCoordP2ui_1(&type, coords);
    
    private TexCoordP2uiv_adr := GetProcAddress('glTexCoordP2uiv');
    private ntv_TexCoordP2uiv_1 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; var coords: UInt32)>(TexCoordP2uiv_adr);
    private ntv_TexCoordP2uiv_2 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; coords: IntPtr)>(TexCoordP2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: glTexCoordPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_TexCoordP2uiv_1(&type, coords[0]) else
        ntv_TexCoordP2uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: glTexCoordPointerType; var coords: UInt32) :=
      ntv_TexCoordP2uiv_1(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: glTexCoordPointerType; coords: IntPtr) :=
      ntv_TexCoordP2uiv_2(&type, coords);
    
    private TexCoordP3ui_adr := GetProcAddress('glTexCoordP3ui');
    private ntv_TexCoordP3ui_1 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; coords: UInt32)>(TexCoordP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3ui(&type: glTexCoordPointerType; coords: UInt32) :=
      ntv_TexCoordP3ui_1(&type, coords);
    
    private TexCoordP3uiv_adr := GetProcAddress('glTexCoordP3uiv');
    private ntv_TexCoordP3uiv_1 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; var coords: UInt32)>(TexCoordP3uiv_adr);
    private ntv_TexCoordP3uiv_2 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; coords: IntPtr)>(TexCoordP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: glTexCoordPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_TexCoordP3uiv_1(&type, coords[0]) else
        ntv_TexCoordP3uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: glTexCoordPointerType; var coords: UInt32) :=
      ntv_TexCoordP3uiv_1(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: glTexCoordPointerType; coords: IntPtr) :=
      ntv_TexCoordP3uiv_2(&type, coords);
    
    private TexCoordP4ui_adr := GetProcAddress('glTexCoordP4ui');
    private ntv_TexCoordP4ui_1 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; coords: UInt32)>(TexCoordP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4ui(&type: glTexCoordPointerType; coords: UInt32) :=
      ntv_TexCoordP4ui_1(&type, coords);
    
    private TexCoordP4uiv_adr := GetProcAddress('glTexCoordP4uiv');
    private ntv_TexCoordP4uiv_1 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; var coords: UInt32)>(TexCoordP4uiv_adr);
    private ntv_TexCoordP4uiv_2 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; coords: IntPtr)>(TexCoordP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: glTexCoordPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_TexCoordP4uiv_1(&type, coords[0]) else
        ntv_TexCoordP4uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: glTexCoordPointerType; var coords: UInt32) :=
      ntv_TexCoordP4uiv_1(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: glTexCoordPointerType; coords: IntPtr) :=
      ntv_TexCoordP4uiv_2(&type, coords);
    
    private MultiTexCoordP1ui_adr := GetProcAddress('glMultiTexCoordP1ui');
    private ntv_MultiTexCoordP1ui_1 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; coords: UInt32)>(MultiTexCoordP1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1ui(texture: glTextureUnit; &type: glTexCoordPointerType; coords: UInt32) :=
      ntv_MultiTexCoordP1ui_1(texture, &type, coords);
    
    private MultiTexCoordP1uiv_adr := GetProcAddress('glMultiTexCoordP1uiv');
    private ntv_MultiTexCoordP1uiv_1 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; var coords: UInt32)>(MultiTexCoordP1uiv_adr);
    private ntv_MultiTexCoordP1uiv_2 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; coords: IntPtr)>(MultiTexCoordP1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: glTextureUnit; &type: glTexCoordPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_MultiTexCoordP1uiv_1(texture, &type, coords[0]) else
        ntv_MultiTexCoordP1uiv_1(texture, &type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: glTextureUnit; &type: glTexCoordPointerType; var coords: UInt32) :=
      ntv_MultiTexCoordP1uiv_1(texture, &type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: glTextureUnit; &type: glTexCoordPointerType; coords: IntPtr) :=
      ntv_MultiTexCoordP1uiv_2(texture, &type, coords);
    
    private MultiTexCoordP2ui_adr := GetProcAddress('glMultiTexCoordP2ui');
    private ntv_MultiTexCoordP2ui_1 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; coords: UInt32)>(MultiTexCoordP2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2ui(texture: glTextureUnit; &type: glTexCoordPointerType; coords: UInt32) :=
      ntv_MultiTexCoordP2ui_1(texture, &type, coords);
    
    private MultiTexCoordP2uiv_adr := GetProcAddress('glMultiTexCoordP2uiv');
    private ntv_MultiTexCoordP2uiv_1 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; var coords: UInt32)>(MultiTexCoordP2uiv_adr);
    private ntv_MultiTexCoordP2uiv_2 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; coords: IntPtr)>(MultiTexCoordP2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: glTextureUnit; &type: glTexCoordPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_MultiTexCoordP2uiv_1(texture, &type, coords[0]) else
        ntv_MultiTexCoordP2uiv_1(texture, &type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: glTextureUnit; &type: glTexCoordPointerType; var coords: UInt32) :=
      ntv_MultiTexCoordP2uiv_1(texture, &type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: glTextureUnit; &type: glTexCoordPointerType; coords: IntPtr) :=
      ntv_MultiTexCoordP2uiv_2(texture, &type, coords);
    
    private MultiTexCoordP3ui_adr := GetProcAddress('glMultiTexCoordP3ui');
    private ntv_MultiTexCoordP3ui_1 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; coords: UInt32)>(MultiTexCoordP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3ui(texture: glTextureUnit; &type: glTexCoordPointerType; coords: UInt32) :=
      ntv_MultiTexCoordP3ui_1(texture, &type, coords);
    
    private MultiTexCoordP3uiv_adr := GetProcAddress('glMultiTexCoordP3uiv');
    private ntv_MultiTexCoordP3uiv_1 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; var coords: UInt32)>(MultiTexCoordP3uiv_adr);
    private ntv_MultiTexCoordP3uiv_2 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; coords: IntPtr)>(MultiTexCoordP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: glTextureUnit; &type: glTexCoordPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_MultiTexCoordP3uiv_1(texture, &type, coords[0]) else
        ntv_MultiTexCoordP3uiv_1(texture, &type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: glTextureUnit; &type: glTexCoordPointerType; var coords: UInt32) :=
      ntv_MultiTexCoordP3uiv_1(texture, &type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: glTextureUnit; &type: glTexCoordPointerType; coords: IntPtr) :=
      ntv_MultiTexCoordP3uiv_2(texture, &type, coords);
    
    private MultiTexCoordP4ui_adr := GetProcAddress('glMultiTexCoordP4ui');
    private ntv_MultiTexCoordP4ui_1 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; coords: UInt32)>(MultiTexCoordP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4ui(texture: glTextureUnit; &type: glTexCoordPointerType; coords: UInt32) :=
      ntv_MultiTexCoordP4ui_1(texture, &type, coords);
    
    private MultiTexCoordP4uiv_adr := GetProcAddress('glMultiTexCoordP4uiv');
    private ntv_MultiTexCoordP4uiv_1 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; var coords: UInt32)>(MultiTexCoordP4uiv_adr);
    private ntv_MultiTexCoordP4uiv_2 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; coords: IntPtr)>(MultiTexCoordP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: glTextureUnit; &type: glTexCoordPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_MultiTexCoordP4uiv_1(texture, &type, coords[0]) else
        ntv_MultiTexCoordP4uiv_1(texture, &type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: glTextureUnit; &type: glTexCoordPointerType; var coords: UInt32) :=
      ntv_MultiTexCoordP4uiv_1(texture, &type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: glTextureUnit; &type: glTexCoordPointerType; coords: IntPtr) :=
      ntv_MultiTexCoordP4uiv_2(texture, &type, coords);
    
    private NormalP3ui_adr := GetProcAddress('glNormalP3ui');
    private ntv_NormalP3ui_1 := GetProcOrNil&<procedure(&type: glNormalPointerType; coords: UInt32)>(NormalP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3ui(&type: glNormalPointerType; coords: UInt32) :=
      ntv_NormalP3ui_1(&type, coords);
    
    private NormalP3uiv_adr := GetProcAddress('glNormalP3uiv');
    private ntv_NormalP3uiv_1 := GetProcOrNil&<procedure(&type: glNormalPointerType; var coords: UInt32)>(NormalP3uiv_adr);
    private ntv_NormalP3uiv_2 := GetProcOrNil&<procedure(&type: glNormalPointerType; coords: IntPtr)>(NormalP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: glNormalPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_NormalP3uiv_1(&type, coords[0]) else
        ntv_NormalP3uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: glNormalPointerType; var coords: UInt32) :=
      ntv_NormalP3uiv_1(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: glNormalPointerType; coords: IntPtr) :=
      ntv_NormalP3uiv_2(&type, coords);
    
    private ColorP3ui_adr := GetProcAddress('glColorP3ui');
    private ntv_ColorP3ui_1 := GetProcOrNil&<procedure(&type: glColorPointerType; color: UInt32)>(ColorP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3ui(&type: glColorPointerType; color: UInt32) :=
      ntv_ColorP3ui_1(&type, color);
    
    private ColorP3uiv_adr := GetProcAddress('glColorP3uiv');
    private ntv_ColorP3uiv_1 := GetProcOrNil&<procedure(&type: glColorPointerType; var color: UInt32)>(ColorP3uiv_adr);
    private ntv_ColorP3uiv_2 := GetProcOrNil&<procedure(&type: glColorPointerType; color: IntPtr)>(ColorP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: glColorPointerType; color: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (color<>nil) and (color.Length<>0) then
        ntv_ColorP3uiv_1(&type, color[0]) else
        ntv_ColorP3uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: glColorPointerType; var color: UInt32) :=
      ntv_ColorP3uiv_1(&type, color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: glColorPointerType; color: IntPtr) :=
      ntv_ColorP3uiv_2(&type, color);
    
    private ColorP4ui_adr := GetProcAddress('glColorP4ui');
    private ntv_ColorP4ui_1 := GetProcOrNil&<procedure(&type: glColorPointerType; color: UInt32)>(ColorP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4ui(&type: glColorPointerType; color: UInt32) :=
      ntv_ColorP4ui_1(&type, color);
    
    private ColorP4uiv_adr := GetProcAddress('glColorP4uiv');
    private ntv_ColorP4uiv_1 := GetProcOrNil&<procedure(&type: glColorPointerType; var color: UInt32)>(ColorP4uiv_adr);
    private ntv_ColorP4uiv_2 := GetProcOrNil&<procedure(&type: glColorPointerType; color: IntPtr)>(ColorP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: glColorPointerType; color: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (color<>nil) and (color.Length<>0) then
        ntv_ColorP4uiv_1(&type, color[0]) else
        ntv_ColorP4uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: glColorPointerType; var color: UInt32) :=
      ntv_ColorP4uiv_1(&type, color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: glColorPointerType; color: IntPtr) :=
      ntv_ColorP4uiv_2(&type, color);
    
    private SecondaryColorP3ui_adr := GetProcAddress('glSecondaryColorP3ui');
    private ntv_SecondaryColorP3ui_1 := GetProcOrNil&<procedure(&type: glColorPointerType; color: UInt32)>(SecondaryColorP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3ui(&type: glColorPointerType; color: UInt32) :=
      ntv_SecondaryColorP3ui_1(&type, color);
    
    private SecondaryColorP3uiv_adr := GetProcAddress('glSecondaryColorP3uiv');
    private ntv_SecondaryColorP3uiv_1 := GetProcOrNil&<procedure(&type: glColorPointerType; var color: UInt32)>(SecondaryColorP3uiv_adr);
    private ntv_SecondaryColorP3uiv_2 := GetProcOrNil&<procedure(&type: glColorPointerType; color: IntPtr)>(SecondaryColorP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: glColorPointerType; color: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (color<>nil) and (color.Length<>0) then
        ntv_SecondaryColorP3uiv_1(&type, color[0]) else
        ntv_SecondaryColorP3uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: glColorPointerType; var color: UInt32) :=
      ntv_SecondaryColorP3uiv_1(&type, color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: glColorPointerType; color: IntPtr) :=
      ntv_SecondaryColorP3uiv_2(&type, color);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glViewportArrayARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_viewport_array';
    
    private ViewportArrayv_adr := GetProcAddress('glViewportArrayv');
    private ntv_ViewportArrayv_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var v: single)>(ViewportArrayv_adr);
    private ntv_ViewportArrayv_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; v: IntPtr)>(ViewportArrayv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayv(first: UInt32; count: Int32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_ViewportArrayv_1(first, count, v[0]) else
        ntv_ViewportArrayv_1(first, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayv(first: UInt32; count: Int32; var v: single) :=
      ntv_ViewportArrayv_1(first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayv(first: UInt32; count: Int32; v: IntPtr) :=
      ntv_ViewportArrayv_2(first, count, v);
    
    private ViewportIndexedf_adr := GetProcAddress('glViewportIndexedf');
    private ntv_ViewportIndexedf_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; w: single; h: single)>(ViewportIndexedf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedf(index: UInt32; x: single; y: single; w: single; h: single) :=
      ntv_ViewportIndexedf_1(index, x, y, w, h);
    
    private ViewportIndexedfv_adr := GetProcAddress('glViewportIndexedfv');
    private ntv_ViewportIndexedfv_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(ViewportIndexedfv_adr);
    private ntv_ViewportIndexedfv_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(ViewportIndexedfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfv(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_ViewportIndexedfv_1(index, v[0]) else
        ntv_ViewportIndexedfv_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfv(index: UInt32; var v: single) :=
      ntv_ViewportIndexedfv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfv(index: UInt32; v: IntPtr) :=
      ntv_ViewportIndexedfv_2(index, v);
    
    private ScissorArrayv_adr := GetProcAddress('glScissorArrayv');
    private ntv_ScissorArrayv_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var v: Int32)>(ScissorArrayv_adr);
    private ntv_ScissorArrayv_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; v: IntPtr)>(ScissorArrayv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayv(first: UInt32; count: Int32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_ScissorArrayv_1(first, count, v[0]) else
        ntv_ScissorArrayv_1(first, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayv(first: UInt32; count: Int32; var v: Int32) :=
      ntv_ScissorArrayv_1(first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayv(first: UInt32; count: Int32; v: IntPtr) :=
      ntv_ScissorArrayv_2(first, count, v);
    
    private ScissorIndexed_adr := GetProcAddress('glScissorIndexed');
    private ntv_ScissorIndexed_1 := GetProcOrNil&<procedure(index: UInt32; left: Int32; bottom: Int32; width: Int32; height: Int32)>(ScissorIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexed(index: UInt32; left: Int32; bottom: Int32; width: Int32; height: Int32) :=
      ntv_ScissorIndexed_1(index, left, bottom, width, height);
    
    private ScissorIndexedv_adr := GetProcAddress('glScissorIndexedv');
    private ntv_ScissorIndexedv_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(ScissorIndexedv_adr);
    private ntv_ScissorIndexedv_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(ScissorIndexedv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedv(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_ScissorIndexedv_1(index, v[0]) else
        ntv_ScissorIndexedv_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedv(index: UInt32; var v: Int32) :=
      ntv_ScissorIndexedv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedv(index: UInt32; v: IntPtr) :=
      ntv_ScissorIndexedv_2(index, v);
    
    private DepthRangeArrayv_adr := GetProcAddress('glDepthRangeArrayv');
    private ntv_DepthRangeArrayv_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var v: double)>(DepthRangeArrayv_adr);
    private ntv_DepthRangeArrayv_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; v: IntPtr)>(DepthRangeArrayv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayv(first: UInt32; count: Int32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_DepthRangeArrayv_1(first, count, v[0]) else
        ntv_DepthRangeArrayv_1(first, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayv(first: UInt32; count: Int32; var v: double) :=
      ntv_DepthRangeArrayv_1(first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayv(first: UInt32; count: Int32; v: IntPtr) :=
      ntv_DepthRangeArrayv_2(first, count, v);
    
    private DepthRangeIndexed_adr := GetProcAddress('glDepthRangeIndexed');
    private ntv_DepthRangeIndexed_1 := GetProcOrNil&<procedure(index: UInt32; n: double; f: double)>(DepthRangeIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeIndexed(index: UInt32; n: double; f: double) :=
      ntv_DepthRangeIndexed_1(index, n, f);
    
    private GetFloati_v_adr := GetProcAddress('glGetFloati_v');
    private ntv_GetFloati_v_1 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; var data: single)>(GetFloati_v_adr);
    private ntv_GetFloati_v_2 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; data: IntPtr)>(GetFloati_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_v(target: glGetPName; index: UInt32; var data: single) :=
      ntv_GetFloati_v_1(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_v(target: glGetPName; index: UInt32; data: IntPtr) :=
      ntv_GetFloati_v_2(target, index, data);
    
    private GetDoublei_v_adr := GetProcAddress('glGetDoublei_v');
    private ntv_GetDoublei_v_1 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; var data: double)>(GetDoublei_v_adr);
    private ntv_GetDoublei_v_2 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; data: IntPtr)>(GetDoublei_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_v(target: glGetPName; index: UInt32; var data: double) :=
      ntv_GetDoublei_v_1(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_v(target: glGetPName; index: UInt32; data: IntPtr) :=
      ntv_GetDoublei_v_2(target, index, data);
    
    private DepthRangeArraydvNV_adr := GetProcAddress('glDepthRangeArraydvNV');
    private ntv_DepthRangeArraydvNV_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var v: double)>(DepthRangeArraydvNV_adr);
    private ntv_DepthRangeArraydvNV_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; v: IntPtr)>(DepthRangeArraydvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArraydvNV(first: UInt32; count: Int32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_DepthRangeArraydvNV_1(first, count, v[0]) else
        ntv_DepthRangeArraydvNV_1(first, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArraydvNV(first: UInt32; count: Int32; var v: double) :=
      ntv_DepthRangeArraydvNV_1(first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArraydvNV(first: UInt32; count: Int32; v: IntPtr) :=
      ntv_DepthRangeArraydvNV_2(first, count, v);
    
    private DepthRangeIndexeddNV_adr := GetProcAddress('glDepthRangeIndexeddNV');
    private ntv_DepthRangeIndexeddNV_1 := GetProcOrNil&<procedure(index: UInt32; n: double; f: double)>(DepthRangeIndexeddNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeIndexeddNV(index: UInt32; n: double; f: double) :=
      ntv_DepthRangeIndexeddNV_1(index, n, f);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glWindowPosARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ARB_window_pos';
    
    private WindowPos2dARB_adr := GetProcAddress('glWindowPos2dARB');
    private ntv_WindowPos2dARB_1 := GetProcOrNil&<procedure(x: double; y: double)>(WindowPos2dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dARB(x: double; y: double) :=
      ntv_WindowPos2dARB_1(x, y);
    
    private WindowPos2dvARB_adr := GetProcAddress('glWindowPos2dvARB');
    private ntv_WindowPos2dvARB_1 := GetProcOrNil&<procedure(var v: double)>(WindowPos2dvARB_adr);
    private ntv_WindowPos2dvARB_2 := GetProcOrNil&<procedure(var v: Vec2d)>(WindowPos2dvARB_adr);
    private ntv_WindowPos2dvARB_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos2dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvARB(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos2dvARB_1(v[0]) else
        ntv_WindowPos2dvARB_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvARB(var v: Vec2d) :=
      ntv_WindowPos2dvARB_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvARB(var v: double) :=
      ntv_WindowPos2dvARB_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvARB(v: IntPtr) :=
      ntv_WindowPos2dvARB_3(v);
    
    private WindowPos2fARB_adr := GetProcAddress('glWindowPos2fARB');
    private ntv_WindowPos2fARB_1 := GetProcOrNil&<procedure(x: single; y: single)>(WindowPos2fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fARB(x: single; y: single) :=
      ntv_WindowPos2fARB_1(x, y);
    
    private WindowPos2fvARB_adr := GetProcAddress('glWindowPos2fvARB');
    private ntv_WindowPos2fvARB_1 := GetProcOrNil&<procedure(var v: single)>(WindowPos2fvARB_adr);
    private ntv_WindowPos2fvARB_2 := GetProcOrNil&<procedure(var v: Vec2f)>(WindowPos2fvARB_adr);
    private ntv_WindowPos2fvARB_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos2fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvARB(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos2fvARB_1(v[0]) else
        ntv_WindowPos2fvARB_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvARB(var v: Vec2f) :=
      ntv_WindowPos2fvARB_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvARB(var v: single) :=
      ntv_WindowPos2fvARB_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvARB(v: IntPtr) :=
      ntv_WindowPos2fvARB_3(v);
    
    private WindowPos2iARB_adr := GetProcAddress('glWindowPos2iARB');
    private ntv_WindowPos2iARB_1 := GetProcOrNil&<procedure(x: Int32; y: Int32)>(WindowPos2iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iARB(x: Int32; y: Int32) :=
      ntv_WindowPos2iARB_1(x, y);
    
    private WindowPos2ivARB_adr := GetProcAddress('glWindowPos2ivARB');
    private ntv_WindowPos2ivARB_1 := GetProcOrNil&<procedure(var v: Int32)>(WindowPos2ivARB_adr);
    private ntv_WindowPos2ivARB_2 := GetProcOrNil&<procedure(var v: Vec2i)>(WindowPos2ivARB_adr);
    private ntv_WindowPos2ivARB_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos2ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivARB(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos2ivARB_1(v[0]) else
        ntv_WindowPos2ivARB_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivARB(var v: Vec2i) :=
      ntv_WindowPos2ivARB_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivARB(var v: Int32) :=
      ntv_WindowPos2ivARB_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivARB(v: IntPtr) :=
      ntv_WindowPos2ivARB_3(v);
    
    private WindowPos2sARB_adr := GetProcAddress('glWindowPos2sARB');
    private ntv_WindowPos2sARB_1 := GetProcOrNil&<procedure(x: Int16; y: Int16)>(WindowPos2sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sARB(x: Int16; y: Int16) :=
      ntv_WindowPos2sARB_1(x, y);
    
    private WindowPos2svARB_adr := GetProcAddress('glWindowPos2svARB');
    private ntv_WindowPos2svARB_1 := GetProcOrNil&<procedure(var v: Int16)>(WindowPos2svARB_adr);
    private ntv_WindowPos2svARB_2 := GetProcOrNil&<procedure(var v: Vec2s)>(WindowPos2svARB_adr);
    private ntv_WindowPos2svARB_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos2svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svARB(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos2svARB_1(v[0]) else
        ntv_WindowPos2svARB_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svARB(var v: Vec2s) :=
      ntv_WindowPos2svARB_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svARB(var v: Int16) :=
      ntv_WindowPos2svARB_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svARB(v: IntPtr) :=
      ntv_WindowPos2svARB_3(v);
    
    private WindowPos3dARB_adr := GetProcAddress('glWindowPos3dARB');
    private ntv_WindowPos3dARB_1 := GetProcOrNil&<procedure(x: double; y: double; z: double)>(WindowPos3dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dARB(x: double; y: double; z: double) :=
      ntv_WindowPos3dARB_1(x, y, z);
    
    private WindowPos3dvARB_adr := GetProcAddress('glWindowPos3dvARB');
    private ntv_WindowPos3dvARB_1 := GetProcOrNil&<procedure(var v: double)>(WindowPos3dvARB_adr);
    private ntv_WindowPos3dvARB_2 := GetProcOrNil&<procedure(var v: Vec3d)>(WindowPos3dvARB_adr);
    private ntv_WindowPos3dvARB_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos3dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvARB(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos3dvARB_1(v[0]) else
        ntv_WindowPos3dvARB_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvARB(var v: Vec3d) :=
      ntv_WindowPos3dvARB_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvARB(var v: double) :=
      ntv_WindowPos3dvARB_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvARB(v: IntPtr) :=
      ntv_WindowPos3dvARB_3(v);
    
    private WindowPos3fARB_adr := GetProcAddress('glWindowPos3fARB');
    private ntv_WindowPos3fARB_1 := GetProcOrNil&<procedure(x: single; y: single; z: single)>(WindowPos3fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fARB(x: single; y: single; z: single) :=
      ntv_WindowPos3fARB_1(x, y, z);
    
    private WindowPos3fvARB_adr := GetProcAddress('glWindowPos3fvARB');
    private ntv_WindowPos3fvARB_1 := GetProcOrNil&<procedure(var v: single)>(WindowPos3fvARB_adr);
    private ntv_WindowPos3fvARB_2 := GetProcOrNil&<procedure(var v: Vec3f)>(WindowPos3fvARB_adr);
    private ntv_WindowPos3fvARB_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos3fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvARB(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos3fvARB_1(v[0]) else
        ntv_WindowPos3fvARB_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvARB(var v: Vec3f) :=
      ntv_WindowPos3fvARB_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvARB(var v: single) :=
      ntv_WindowPos3fvARB_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvARB(v: IntPtr) :=
      ntv_WindowPos3fvARB_3(v);
    
    private WindowPos3iARB_adr := GetProcAddress('glWindowPos3iARB');
    private ntv_WindowPos3iARB_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; z: Int32)>(WindowPos3iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iARB(x: Int32; y: Int32; z: Int32) :=
      ntv_WindowPos3iARB_1(x, y, z);
    
    private WindowPos3ivARB_adr := GetProcAddress('glWindowPos3ivARB');
    private ntv_WindowPos3ivARB_1 := GetProcOrNil&<procedure(var v: Int32)>(WindowPos3ivARB_adr);
    private ntv_WindowPos3ivARB_2 := GetProcOrNil&<procedure(var v: Vec3i)>(WindowPos3ivARB_adr);
    private ntv_WindowPos3ivARB_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos3ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivARB(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos3ivARB_1(v[0]) else
        ntv_WindowPos3ivARB_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivARB(var v: Vec3i) :=
      ntv_WindowPos3ivARB_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivARB(var v: Int32) :=
      ntv_WindowPos3ivARB_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivARB(v: IntPtr) :=
      ntv_WindowPos3ivARB_3(v);
    
    private WindowPos3sARB_adr := GetProcAddress('glWindowPos3sARB');
    private ntv_WindowPos3sARB_1 := GetProcOrNil&<procedure(x: Int16; y: Int16; z: Int16)>(WindowPos3sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sARB(x: Int16; y: Int16; z: Int16) :=
      ntv_WindowPos3sARB_1(x, y, z);
    
    private WindowPos3svARB_adr := GetProcAddress('glWindowPos3svARB');
    private ntv_WindowPos3svARB_1 := GetProcOrNil&<procedure(var v: Int16)>(WindowPos3svARB_adr);
    private ntv_WindowPos3svARB_2 := GetProcOrNil&<procedure(var v: Vec3s)>(WindowPos3svARB_adr);
    private ntv_WindowPos3svARB_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos3svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svARB(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos3svARB_1(v[0]) else
        ntv_WindowPos3svARB_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svARB(var v: Vec3s) :=
      ntv_WindowPos3svARB_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svARB(var v: Int16) :=
      ntv_WindowPos3svARB_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svARB(v: IntPtr) :=
      ntv_WindowPos3svARB_3(v);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDrawBuffersATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ATI_draw_buffers';
    
    private DrawBuffersATI_adr := GetProcAddress('glDrawBuffersATI');
    private ntv_DrawBuffersATI_1 := GetProcOrNil&<procedure(n: Int32; var bufs: glDrawBufferMode)>(DrawBuffersATI_adr);
    private ntv_DrawBuffersATI_2 := GetProcOrNil&<procedure(n: Int32; bufs: IntPtr)>(DrawBuffersATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersATI(n: Int32; bufs: array of glDrawBufferMode);
    type PGlDrawBufferMode = ^glDrawBufferMode;
    begin
      if (bufs<>nil) and (bufs.Length<>0) then
        ntv_DrawBuffersATI_1(n, bufs[0]) else
        ntv_DrawBuffersATI_1(n, PGlDrawBufferMode(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersATI(n: Int32; var bufs: glDrawBufferMode) :=
      ntv_DrawBuffersATI_1(n, bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersATI(n: Int32; bufs: IntPtr) :=
      ntv_DrawBuffersATI_2(n, bufs);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glElementArrayATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ATI_element_array';
    
    private ElementPointerATI_adr := GetProcAddress('glElementPointerATI');
    private ntv_ElementPointerATI_1 := GetProcOrNil&<procedure(&type: glElementPointerType; pointer: IntPtr)>(ElementPointerATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ElementPointerATI(&type: glElementPointerType; pointer: IntPtr) :=
      ntv_ElementPointerATI_1(&type, pointer);
    
    private DrawElementArrayATI_adr := GetProcAddress('glDrawElementArrayATI');
    private ntv_DrawElementArrayATI_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: Int32)>(DrawElementArrayATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementArrayATI(mode: glPrimitiveType; count: Int32) :=
      ntv_DrawElementArrayATI_1(mode, count);
    
    private DrawRangeElementArrayATI_adr := GetProcAddress('glDrawRangeElementArrayATI');
    private ntv_DrawRangeElementArrayATI_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; start: UInt32; &end: UInt32; count: Int32)>(DrawRangeElementArrayATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementArrayATI(mode: glPrimitiveType; start: UInt32; &end: UInt32; count: Int32) :=
      ntv_DrawRangeElementArrayATI_1(mode, start, &end, count);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glEnvmapBumpmapATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ATI_envmap_bumpmap';
    
    private TexBumpParameterivATI_adr := GetProcAddress('glTexBumpParameterivATI');
    private ntv_TexBumpParameterivATI_1 := GetProcOrNil&<procedure(pname: glTexBumpParameter; var param: Int32)>(TexBumpParameterivATI_adr);
    private ntv_TexBumpParameterivATI_2 := GetProcOrNil&<procedure(pname: glTexBumpParameter; param: IntPtr)>(TexBumpParameterivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterivATI(pname: glTexBumpParameter; param: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (param<>nil) and (param.Length<>0) then
        ntv_TexBumpParameterivATI_1(pname, param[0]) else
        ntv_TexBumpParameterivATI_1(pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterivATI(pname: glTexBumpParameter; var param: Int32) :=
      ntv_TexBumpParameterivATI_1(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterivATI(pname: glTexBumpParameter; param: IntPtr) :=
      ntv_TexBumpParameterivATI_2(pname, param);
    
    private TexBumpParameterfvATI_adr := GetProcAddress('glTexBumpParameterfvATI');
    private ntv_TexBumpParameterfvATI_1 := GetProcOrNil&<procedure(pname: glTexBumpParameter; var param: single)>(TexBumpParameterfvATI_adr);
    private ntv_TexBumpParameterfvATI_2 := GetProcOrNil&<procedure(pname: glTexBumpParameter; param: IntPtr)>(TexBumpParameterfvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterfvATI(pname: glTexBumpParameter; param: array of single);
    type PSingle = ^single;
    begin
      if (param<>nil) and (param.Length<>0) then
        ntv_TexBumpParameterfvATI_1(pname, param[0]) else
        ntv_TexBumpParameterfvATI_1(pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterfvATI(pname: glTexBumpParameter; var param: single) :=
      ntv_TexBumpParameterfvATI_1(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterfvATI(pname: glTexBumpParameter; param: IntPtr) :=
      ntv_TexBumpParameterfvATI_2(pname, param);
    
    private GetTexBumpParameterivATI_adr := GetProcAddress('glGetTexBumpParameterivATI');
    private ntv_GetTexBumpParameterivATI_1 := GetProcOrNil&<procedure(pname: glGetTexBumpParameter; var param: Int32)>(GetTexBumpParameterivATI_adr);
    private ntv_GetTexBumpParameterivATI_2 := GetProcOrNil&<procedure(pname: glGetTexBumpParameter; param: IntPtr)>(GetTexBumpParameterivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterivATI(pname: glGetTexBumpParameter; var param: Int32) :=
      ntv_GetTexBumpParameterivATI_1(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterivATI(pname: glGetTexBumpParameter; param: IntPtr) :=
      ntv_GetTexBumpParameterivATI_2(pname, param);
    
    private GetTexBumpParameterfvATI_adr := GetProcAddress('glGetTexBumpParameterfvATI');
    private ntv_GetTexBumpParameterfvATI_1 := GetProcOrNil&<procedure(pname: glGetTexBumpParameter; var param: single)>(GetTexBumpParameterfvATI_adr);
    private ntv_GetTexBumpParameterfvATI_2 := GetProcOrNil&<procedure(pname: glGetTexBumpParameter; param: IntPtr)>(GetTexBumpParameterfvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterfvATI(pname: glGetTexBumpParameter; var param: single) :=
      ntv_GetTexBumpParameterfvATI_1(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterfvATI(pname: glGetTexBumpParameter; param: IntPtr) :=
      ntv_GetTexBumpParameterfvATI_2(pname, param);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFragmentShaderATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ATI_fragment_shader';
    
    private GenFragmentShadersATI_adr := GetProcAddress('glGenFragmentShadersATI');
    private ntv_GenFragmentShadersATI_1 := GetProcOrNil&<function(range: UInt32): UInt32>(GenFragmentShadersATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenFragmentShadersATI(range: UInt32): UInt32 :=
      ntv_GenFragmentShadersATI_1(range);
    
    private BindFragmentShaderATI_adr := GetProcAddress('glBindFragmentShaderATI');
    private ntv_BindFragmentShaderATI_1 := GetProcOrNil&<procedure(id: UInt32)>(BindFragmentShaderATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragmentShaderATI(id: UInt32) :=
      ntv_BindFragmentShaderATI_1(id);
    
    private DeleteFragmentShaderATI_adr := GetProcAddress('glDeleteFragmentShaderATI');
    private ntv_DeleteFragmentShaderATI_1 := GetProcOrNil&<procedure(id: UInt32)>(DeleteFragmentShaderATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFragmentShaderATI(id: UInt32) :=
      ntv_DeleteFragmentShaderATI_1(id);
    
    private BeginFragmentShaderATI_adr := GetProcAddress('glBeginFragmentShaderATI');
    private ntv_BeginFragmentShaderATI_1 := GetProcOrNil&<procedure>(BeginFragmentShaderATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginFragmentShaderATI :=
      ntv_BeginFragmentShaderATI_1;
    
    private EndFragmentShaderATI_adr := GetProcAddress('glEndFragmentShaderATI');
    private ntv_EndFragmentShaderATI_1 := GetProcOrNil&<procedure>(EndFragmentShaderATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndFragmentShaderATI :=
      ntv_EndFragmentShaderATI_1;
    
    private PassTexCoordATI_adr := GetProcAddress('glPassTexCoordATI');
    private ntv_PassTexCoordATI_1 := GetProcOrNil&<procedure(dst: glFragmentShaderReg; coord: glFragmentShaderTextureSource; swizzle: glSwizzleOp)>(PassTexCoordATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PassTexCoordATI(dst: glFragmentShaderReg; coord: glFragmentShaderTextureSource; swizzle: glSwizzleOp) :=
      ntv_PassTexCoordATI_1(dst, coord, swizzle);
    
    private SampleMapATI_adr := GetProcAddress('glSampleMapATI');
    private ntv_SampleMapATI_1 := GetProcOrNil&<procedure(dst: glFragmentShaderReg; interp: glFragmentShaderTextureSource; swizzle: glSwizzleOp)>(SampleMapATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMapATI(dst: glFragmentShaderReg; interp: glFragmentShaderTextureSource; swizzle: glSwizzleOp) :=
      ntv_SampleMapATI_1(dst, interp, swizzle);
    
    private ColorFragmentOp1ATI_adr := GetProcAddress('glColorFragmentOp1ATI');
    private ntv_ColorFragmentOp1ATI_1 := GetProcOrNil&<procedure(op: glFragmentOp1; dst: glFragmentShaderReg; dstMask: glFragmentShaderDestMask; dstMod: glFragmentShaderDestModMask; arg1: glFragmentShaderGenericSource; arg1Rep: glFragmentShaderValueRep; arg1Mod: glFragmentShaderColorModMask)>(ColorFragmentOp1ATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorFragmentOp1ATI(op: glFragmentOp1; dst: glFragmentShaderReg; dstMask: glFragmentShaderDestMask; dstMod: glFragmentShaderDestModMask; arg1: glFragmentShaderGenericSource; arg1Rep: glFragmentShaderValueRep; arg1Mod: glFragmentShaderColorModMask) :=
      ntv_ColorFragmentOp1ATI_1(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
    
    private ColorFragmentOp2ATI_adr := GetProcAddress('glColorFragmentOp2ATI');
    private ntv_ColorFragmentOp2ATI_1 := GetProcOrNil&<procedure(op: glFragmentOp2; dst: glFragmentShaderReg; dstMask: glFragmentShaderDestMask; dstMod: glFragmentShaderDestModMask; arg1: glFragmentShaderGenericSource; arg1Rep: glFragmentShaderValueRep; arg1Mod: glFragmentShaderColorModMask; arg2: glFragmentShaderGenericSource; arg2Rep: glFragmentShaderValueRep; arg2Mod: glFragmentShaderColorModMask)>(ColorFragmentOp2ATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorFragmentOp2ATI(op: glFragmentOp2; dst: glFragmentShaderReg; dstMask: glFragmentShaderDestMask; dstMod: glFragmentShaderDestModMask; arg1: glFragmentShaderGenericSource; arg1Rep: glFragmentShaderValueRep; arg1Mod: glFragmentShaderColorModMask; arg2: glFragmentShaderGenericSource; arg2Rep: glFragmentShaderValueRep; arg2Mod: glFragmentShaderColorModMask) :=
      ntv_ColorFragmentOp2ATI_1(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    
    private ColorFragmentOp3ATI_adr := GetProcAddress('glColorFragmentOp3ATI');
    private ntv_ColorFragmentOp3ATI_1 := GetProcOrNil&<procedure(op: glFragmentOp3; dst: glFragmentShaderReg; dstMask: glFragmentShaderDestMask; dstMod: glFragmentShaderDestModMask; arg1: glFragmentShaderGenericSource; arg1Rep: glFragmentShaderValueRep; arg1Mod: glFragmentShaderColorModMask; arg2: glFragmentShaderGenericSource; arg2Rep: glFragmentShaderValueRep; arg2Mod: glFragmentShaderColorModMask; arg3: glFragmentShaderGenericSource; arg3Rep: glFragmentShaderValueRep; arg3Mod: glFragmentShaderColorModMask)>(ColorFragmentOp3ATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorFragmentOp3ATI(op: glFragmentOp3; dst: glFragmentShaderReg; dstMask: glFragmentShaderDestMask; dstMod: glFragmentShaderDestModMask; arg1: glFragmentShaderGenericSource; arg1Rep: glFragmentShaderValueRep; arg1Mod: glFragmentShaderColorModMask; arg2: glFragmentShaderGenericSource; arg2Rep: glFragmentShaderValueRep; arg2Mod: glFragmentShaderColorModMask; arg3: glFragmentShaderGenericSource; arg3Rep: glFragmentShaderValueRep; arg3Mod: glFragmentShaderColorModMask) :=
      ntv_ColorFragmentOp3ATI_1(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    
    private AlphaFragmentOp1ATI_adr := GetProcAddress('glAlphaFragmentOp1ATI');
    private ntv_AlphaFragmentOp1ATI_1 := GetProcOrNil&<procedure(op: glFragmentOp1; dst: glFragmentShaderReg; dstMod: glFragmentShaderDestModMask; arg1: glFragmentShaderGenericSource; arg1Rep: glFragmentShaderValueRep; arg1Mod: glFragmentShaderColorModMask)>(AlphaFragmentOp1ATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFragmentOp1ATI(op: glFragmentOp1; dst: glFragmentShaderReg; dstMod: glFragmentShaderDestModMask; arg1: glFragmentShaderGenericSource; arg1Rep: glFragmentShaderValueRep; arg1Mod: glFragmentShaderColorModMask) :=
      ntv_AlphaFragmentOp1ATI_1(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
    
    private AlphaFragmentOp2ATI_adr := GetProcAddress('glAlphaFragmentOp2ATI');
    private ntv_AlphaFragmentOp2ATI_1 := GetProcOrNil&<procedure(op: glFragmentOp2; dst: glFragmentShaderReg; dstMod: glFragmentShaderDestModMask; arg1: glFragmentShaderGenericSource; arg1Rep: glFragmentShaderValueRep; arg1Mod: glFragmentShaderColorModMask; arg2: glFragmentShaderGenericSource; arg2Rep: glFragmentShaderValueRep; arg2Mod: glFragmentShaderColorModMask)>(AlphaFragmentOp2ATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFragmentOp2ATI(op: glFragmentOp2; dst: glFragmentShaderReg; dstMod: glFragmentShaderDestModMask; arg1: glFragmentShaderGenericSource; arg1Rep: glFragmentShaderValueRep; arg1Mod: glFragmentShaderColorModMask; arg2: glFragmentShaderGenericSource; arg2Rep: glFragmentShaderValueRep; arg2Mod: glFragmentShaderColorModMask) :=
      ntv_AlphaFragmentOp2ATI_1(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    
    private AlphaFragmentOp3ATI_adr := GetProcAddress('glAlphaFragmentOp3ATI');
    private ntv_AlphaFragmentOp3ATI_1 := GetProcOrNil&<procedure(op: glFragmentOp3; dst: glFragmentShaderReg; dstMod: glFragmentShaderDestModMask; arg1: glFragmentShaderGenericSource; arg1Rep: glFragmentShaderValueRep; arg1Mod: glFragmentShaderColorModMask; arg2: glFragmentShaderGenericSource; arg2Rep: glFragmentShaderValueRep; arg2Mod: glFragmentShaderColorModMask; arg3: glFragmentShaderGenericSource; arg3Rep: glFragmentShaderValueRep; arg3Mod: glFragmentShaderColorModMask)>(AlphaFragmentOp3ATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFragmentOp3ATI(op: glFragmentOp3; dst: glFragmentShaderReg; dstMod: glFragmentShaderDestModMask; arg1: glFragmentShaderGenericSource; arg1Rep: glFragmentShaderValueRep; arg1Mod: glFragmentShaderColorModMask; arg2: glFragmentShaderGenericSource; arg2Rep: glFragmentShaderValueRep; arg2Mod: glFragmentShaderColorModMask; arg3: glFragmentShaderGenericSource; arg3Rep: glFragmentShaderValueRep; arg3Mod: glFragmentShaderColorModMask) :=
      ntv_AlphaFragmentOp3ATI_1(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    
    private SetFragmentShaderConstantATI_adr := GetProcAddress('glSetFragmentShaderConstantATI');
    private ntv_SetFragmentShaderConstantATI_1 := GetProcOrNil&<procedure(dst: glFragmentShaderCon; var value: single)>(SetFragmentShaderConstantATI_adr);
    private ntv_SetFragmentShaderConstantATI_2 := GetProcOrNil&<procedure(dst: glFragmentShaderCon; value: IntPtr)>(SetFragmentShaderConstantATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFragmentShaderConstantATI(dst: glFragmentShaderCon; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_SetFragmentShaderConstantATI_1(dst, value[0]) else
        ntv_SetFragmentShaderConstantATI_1(dst, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFragmentShaderConstantATI(dst: glFragmentShaderCon; var value: single) :=
      ntv_SetFragmentShaderConstantATI_1(dst, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFragmentShaderConstantATI(dst: glFragmentShaderCon; value: IntPtr) :=
      ntv_SetFragmentShaderConstantATI_2(dst, value);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMapObjectBufferATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ATI_map_object_buffer';
    
    private MapObjectBufferATI_adr := GetProcAddress('glMapObjectBufferATI');
    private ntv_MapObjectBufferATI_1 := GetProcOrNil&<function(buffer: gl_buffer): IntPtr>(MapObjectBufferATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapObjectBufferATI(buffer: gl_buffer): IntPtr :=
      ntv_MapObjectBufferATI_1(buffer);
    
    private UnmapObjectBufferATI_adr := GetProcAddress('glUnmapObjectBufferATI');
    private ntv_UnmapObjectBufferATI_1 := GetProcOrNil&<procedure(buffer: gl_buffer)>(UnmapObjectBufferATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UnmapObjectBufferATI(buffer: gl_buffer) :=
      ntv_UnmapObjectBufferATI_1(buffer);
    
  end;
  
  ///
  glMeminfoATI = static class
    public const _ExtStr = 'GL_ATI_meminfo';
  end;
  
  ///
  glPixelFormatFloatATI = static class
    public const _ExtStr = 'GL_ATI_pixel_format_float';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPnTrianglesATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ATI_pn_triangles';
    
    private PNTrianglesiATI_adr := GetProcAddress('glPNTrianglesiATI');
    private ntv_PNTrianglesiATI_1 := GetProcOrNil&<procedure(pname: glPNTrianglesPName; param: Int32)>(PNTrianglesiATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PNTrianglesiATI(pname: glPNTrianglesPName; param: Int32) :=
      ntv_PNTrianglesiATI_1(pname, param);
    
    private PNTrianglesfATI_adr := GetProcAddress('glPNTrianglesfATI');
    private ntv_PNTrianglesfATI_1 := GetProcOrNil&<procedure(pname: glPNTrianglesPName; param: single)>(PNTrianglesfATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PNTrianglesfATI(pname: glPNTrianglesPName; param: single) :=
      ntv_PNTrianglesfATI_1(pname, param);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSeparateStencilATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ATI_separate_stencil';
    
    private StencilOpSeparateATI_adr := GetProcAddress('glStencilOpSeparateATI');
    private ntv_StencilOpSeparateATI_1 := GetProcOrNil&<procedure(face: glTriangleFace; sfail: glStencilOp; dpfail: glStencilOp; dppass: glStencilOp)>(StencilOpSeparateATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilOpSeparateATI(face: glTriangleFace; sfail: glStencilOp; dpfail: glStencilOp; dppass: glStencilOp) :=
      ntv_StencilOpSeparateATI_1(face, sfail, dpfail, dppass);
    
    private StencilFuncSeparateATI_adr := GetProcAddress('glStencilFuncSeparateATI');
    private ntv_StencilFuncSeparateATI_1 := GetProcOrNil&<procedure(frontfunc: glStencilFunction; backfunc: glStencilFunction; ref: Int32; mask: UInt32)>(StencilFuncSeparateATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFuncSeparateATI(frontfunc: glStencilFunction; backfunc: glStencilFunction; ref: Int32; mask: UInt32) :=
      ntv_StencilFuncSeparateATI_1(frontfunc, backfunc, ref, mask);
    
  end;
  
  ///
  glTextFragmentShaderATI = static class
    public const _ExtStr = 'GL_ATI_text_fragment_shader';
  end;
  
  ///
  glTextureEnvCombine3ATI = static class
    public const _ExtStr = 'GL_ATI_texture_env_combine3';
  end;
  
  ///
  glTextureFloatATI = static class
    public const _ExtStr = 'GL_ATI_texture_float';
  end;
  
  ///
  glTextureMirrorOnceATI = static class
    public const _ExtStr = 'GL_ATI_texture_mirror_once';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexArrayObjectATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ATI_vertex_array_object';
    
    private NewObjectBufferATI_adr := GetProcAddress('glNewObjectBufferATI');
    private ntv_NewObjectBufferATI_1 := GetProcOrNil&<function(size: Int32; pointer: IntPtr; usage: glArrayObjectUsage): UInt32>(NewObjectBufferATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function NewObjectBufferATI(size: Int32; pointer: IntPtr; usage: glArrayObjectUsage): UInt32 :=
      ntv_NewObjectBufferATI_1(size, pointer, usage);
    
    private IsObjectBufferATI_adr := GetProcAddress('glIsObjectBufferATI');
    private ntv_IsObjectBufferATI_1 := GetProcOrNil&<function(buffer: gl_buffer): glBool8>(IsObjectBufferATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsObjectBufferATI(buffer: gl_buffer): glBool8 :=
      ntv_IsObjectBufferATI_1(buffer);
    
    private UpdateObjectBufferATI_adr := GetProcAddress('glUpdateObjectBufferATI');
    private ntv_UpdateObjectBufferATI_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: UInt32; size: Int32; pointer: IntPtr; preserve: glPreserveMode)>(UpdateObjectBufferATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UpdateObjectBufferATI(buffer: gl_buffer; offset: UInt32; size: Int32; pointer: IntPtr; preserve: glPreserveMode) :=
      ntv_UpdateObjectBufferATI_1(buffer, offset, size, pointer, preserve);
    
    private GetObjectBufferfvATI_adr := GetProcAddress('glGetObjectBufferfvATI');
    private ntv_GetObjectBufferfvATI_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glArrayObjectPName; var &params: single)>(GetObjectBufferfvATI_adr);
    private ntv_GetObjectBufferfvATI_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glArrayObjectPName; &params: IntPtr)>(GetObjectBufferfvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferfvATI(buffer: gl_buffer; pname: glArrayObjectPName; var &params: single) :=
      ntv_GetObjectBufferfvATI_1(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferfvATI(buffer: gl_buffer; pname: glArrayObjectPName; &params: IntPtr) :=
      ntv_GetObjectBufferfvATI_2(buffer, pname, &params);
    
    private GetObjectBufferivATI_adr := GetProcAddress('glGetObjectBufferivATI');
    private ntv_GetObjectBufferivATI_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glArrayObjectPName; var &params: Int32)>(GetObjectBufferivATI_adr);
    private ntv_GetObjectBufferivATI_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glArrayObjectPName; &params: IntPtr)>(GetObjectBufferivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferivATI(buffer: gl_buffer; pname: glArrayObjectPName; var &params: Int32) :=
      ntv_GetObjectBufferivATI_1(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferivATI(buffer: gl_buffer; pname: glArrayObjectPName; &params: IntPtr) :=
      ntv_GetObjectBufferivATI_2(buffer, pname, &params);
    
    private FreeObjectBufferATI_adr := GetProcAddress('glFreeObjectBufferATI');
    private ntv_FreeObjectBufferATI_1 := GetProcOrNil&<procedure(buffer: gl_buffer)>(FreeObjectBufferATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FreeObjectBufferATI(buffer: gl_buffer) :=
      ntv_FreeObjectBufferATI_1(buffer);
    
    private ArrayObjectATI_adr := GetProcAddress('glArrayObjectATI');
    private ntv_ArrayObjectATI_1 := GetProcOrNil&<procedure(&array: glEnableCap; size: Int32; &type: glScalarType; stride: Int32; buffer: gl_buffer; offset: UInt32)>(ArrayObjectATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ArrayObjectATI(&array: glEnableCap; size: Int32; &type: glScalarType; stride: Int32; buffer: gl_buffer; offset: UInt32) :=
      ntv_ArrayObjectATI_1(&array, size, &type, stride, buffer, offset);
    
    private GetArrayObjectfvATI_adr := GetProcAddress('glGetArrayObjectfvATI');
    private ntv_GetArrayObjectfvATI_1 := GetProcOrNil&<procedure(&array: glEnableCap; pname: glArrayObjectPName; var &params: single)>(GetArrayObjectfvATI_adr);
    private ntv_GetArrayObjectfvATI_2 := GetProcOrNil&<procedure(&array: glEnableCap; pname: glArrayObjectPName; &params: IntPtr)>(GetArrayObjectfvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectfvATI(&array: glEnableCap; pname: glArrayObjectPName; var &params: single) :=
      ntv_GetArrayObjectfvATI_1(&array, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectfvATI(&array: glEnableCap; pname: glArrayObjectPName; &params: IntPtr) :=
      ntv_GetArrayObjectfvATI_2(&array, pname, &params);
    
    private GetArrayObjectivATI_adr := GetProcAddress('glGetArrayObjectivATI');
    private ntv_GetArrayObjectivATI_1 := GetProcOrNil&<procedure(&array: glEnableCap; pname: glArrayObjectPName; var &params: Int32)>(GetArrayObjectivATI_adr);
    private ntv_GetArrayObjectivATI_2 := GetProcOrNil&<procedure(&array: glEnableCap; pname: glArrayObjectPName; &params: IntPtr)>(GetArrayObjectivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectivATI(&array: glEnableCap; pname: glArrayObjectPName; var &params: Int32) :=
      ntv_GetArrayObjectivATI_1(&array, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectivATI(&array: glEnableCap; pname: glArrayObjectPName; &params: IntPtr) :=
      ntv_GetArrayObjectivATI_2(&array, pname, &params);
    
    private VariantArrayObjectATI_adr := GetProcAddress('glVariantArrayObjectATI');
    private ntv_VariantArrayObjectATI_1 := GetProcOrNil&<procedure(id: UInt32; &type: glScalarType; stride: Int32; buffer: gl_buffer; offset: UInt32)>(VariantArrayObjectATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantArrayObjectATI(id: UInt32; &type: glScalarType; stride: Int32; buffer: gl_buffer; offset: UInt32) :=
      ntv_VariantArrayObjectATI_1(id, &type, stride, buffer, offset);
    
    private GetVariantArrayObjectfvATI_adr := GetProcAddress('glGetVariantArrayObjectfvATI');
    private ntv_GetVariantArrayObjectfvATI_1 := GetProcOrNil&<procedure(id: UInt32; pname: glArrayObjectPName; var &params: single)>(GetVariantArrayObjectfvATI_adr);
    private ntv_GetVariantArrayObjectfvATI_2 := GetProcOrNil&<procedure(id: UInt32; pname: glArrayObjectPName; &params: IntPtr)>(GetVariantArrayObjectfvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectfvATI(id: UInt32; pname: glArrayObjectPName; var &params: single) :=
      ntv_GetVariantArrayObjectfvATI_1(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectfvATI(id: UInt32; pname: glArrayObjectPName; &params: IntPtr) :=
      ntv_GetVariantArrayObjectfvATI_2(id, pname, &params);
    
    private GetVariantArrayObjectivATI_adr := GetProcAddress('glGetVariantArrayObjectivATI');
    private ntv_GetVariantArrayObjectivATI_1 := GetProcOrNil&<procedure(id: UInt32; pname: glArrayObjectPName; var &params: Int32)>(GetVariantArrayObjectivATI_adr);
    private ntv_GetVariantArrayObjectivATI_2 := GetProcOrNil&<procedure(id: UInt32; pname: glArrayObjectPName; &params: IntPtr)>(GetVariantArrayObjectivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectivATI(id: UInt32; pname: glArrayObjectPName; var &params: Int32) :=
      ntv_GetVariantArrayObjectivATI_1(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectivATI(id: UInt32; pname: glArrayObjectPName; &params: IntPtr) :=
      ntv_GetVariantArrayObjectivATI_2(id, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexAttribArrayObjectATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ATI_vertex_attrib_array_object';
    
    private VertexAttribArrayObjectATI_adr := GetProcAddress('glVertexAttribArrayObjectATI');
    private ntv_VertexAttribArrayObjectATI_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: glVertexAttribPointerType; normalized: glBool8; stride: Int32; buffer: gl_buffer; offset: UInt32)>(VertexAttribArrayObjectATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribArrayObjectATI(index: UInt32; size: Int32; &type: glVertexAttribPointerType; normalized: glBool8; stride: Int32; buffer: gl_buffer; offset: UInt32) :=
      ntv_VertexAttribArrayObjectATI_1(index, size, &type, normalized, stride, buffer, offset);
    
    private GetVertexAttribArrayObjectfvATI_adr := GetProcAddress('glGetVertexAttribArrayObjectfvATI');
    private ntv_GetVertexAttribArrayObjectfvATI_1 := GetProcOrNil&<procedure(index: UInt32; pname: glArrayObjectPName; var &params: single)>(GetVertexAttribArrayObjectfvATI_adr);
    private ntv_GetVertexAttribArrayObjectfvATI_2 := GetProcOrNil&<procedure(index: UInt32; pname: glArrayObjectPName; &params: IntPtr)>(GetVertexAttribArrayObjectfvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectfvATI(index: UInt32; pname: glArrayObjectPName; var &params: single) :=
      ntv_GetVertexAttribArrayObjectfvATI_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectfvATI(index: UInt32; pname: glArrayObjectPName; &params: IntPtr) :=
      ntv_GetVertexAttribArrayObjectfvATI_2(index, pname, &params);
    
    private GetVertexAttribArrayObjectivATI_adr := GetProcAddress('glGetVertexAttribArrayObjectivATI');
    private ntv_GetVertexAttribArrayObjectivATI_1 := GetProcOrNil&<procedure(index: UInt32; pname: glArrayObjectPName; var &params: Int32)>(GetVertexAttribArrayObjectivATI_adr);
    private ntv_GetVertexAttribArrayObjectivATI_2 := GetProcOrNil&<procedure(index: UInt32; pname: glArrayObjectPName; &params: IntPtr)>(GetVertexAttribArrayObjectivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectivATI(index: UInt32; pname: glArrayObjectPName; var &params: Int32) :=
      ntv_GetVertexAttribArrayObjectivATI_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectivATI(index: UInt32; pname: glArrayObjectPName; &params: IntPtr) :=
      ntv_GetVertexAttribArrayObjectivATI_2(index, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexStreamsATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_ATI_vertex_streams';
    
    private VertexStream1sATI_adr := GetProcAddress('glVertexStream1sATI');
    private ntv_VertexStream1sATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; x: Int16)>(VertexStream1sATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1sATI(stream: glVertexStream; x: Int16) :=
      ntv_VertexStream1sATI_1(stream, x);
    
    private VertexStream1svATI_adr := GetProcAddress('glVertexStream1svATI');
    private ntv_VertexStream1svATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Int16)>(VertexStream1svATI_adr);
    private ntv_VertexStream1svATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(VertexStream1svATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1svATI(stream: glVertexStream; coords: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_VertexStream1svATI_1(stream, coords[0]) else
        ntv_VertexStream1svATI_1(stream, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1svATI(stream: glVertexStream; var coords: Int16) :=
      ntv_VertexStream1svATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1svATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_VertexStream1svATI_2(stream, coords);
    
    private VertexStream1iATI_adr := GetProcAddress('glVertexStream1iATI');
    private ntv_VertexStream1iATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; x: Int32)>(VertexStream1iATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1iATI(stream: glVertexStream; x: Int32) :=
      ntv_VertexStream1iATI_1(stream, x);
    
    private VertexStream1ivATI_adr := GetProcAddress('glVertexStream1ivATI');
    private ntv_VertexStream1ivATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Int32)>(VertexStream1ivATI_adr);
    private ntv_VertexStream1ivATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(VertexStream1ivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1ivATI(stream: glVertexStream; coords: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_VertexStream1ivATI_1(stream, coords[0]) else
        ntv_VertexStream1ivATI_1(stream, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1ivATI(stream: glVertexStream; var coords: Int32) :=
      ntv_VertexStream1ivATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1ivATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_VertexStream1ivATI_2(stream, coords);
    
    private VertexStream1fATI_adr := GetProcAddress('glVertexStream1fATI');
    private ntv_VertexStream1fATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; x: single)>(VertexStream1fATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1fATI(stream: glVertexStream; x: single) :=
      ntv_VertexStream1fATI_1(stream, x);
    
    private VertexStream1fvATI_adr := GetProcAddress('glVertexStream1fvATI');
    private ntv_VertexStream1fvATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: single)>(VertexStream1fvATI_adr);
    private ntv_VertexStream1fvATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(VertexStream1fvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1fvATI(stream: glVertexStream; coords: array of single);
    type PSingle = ^single;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_VertexStream1fvATI_1(stream, coords[0]) else
        ntv_VertexStream1fvATI_1(stream, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1fvATI(stream: glVertexStream; var coords: single) :=
      ntv_VertexStream1fvATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1fvATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_VertexStream1fvATI_2(stream, coords);
    
    private VertexStream1dATI_adr := GetProcAddress('glVertexStream1dATI');
    private ntv_VertexStream1dATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; x: double)>(VertexStream1dATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1dATI(stream: glVertexStream; x: double) :=
      ntv_VertexStream1dATI_1(stream, x);
    
    private VertexStream1dvATI_adr := GetProcAddress('glVertexStream1dvATI');
    private ntv_VertexStream1dvATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: double)>(VertexStream1dvATI_adr);
    private ntv_VertexStream1dvATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(VertexStream1dvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1dvATI(stream: glVertexStream; coords: array of double);
    type PDouble = ^double;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_VertexStream1dvATI_1(stream, coords[0]) else
        ntv_VertexStream1dvATI_1(stream, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1dvATI(stream: glVertexStream; var coords: double) :=
      ntv_VertexStream1dvATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1dvATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_VertexStream1dvATI_2(stream, coords);
    
    private VertexStream2sATI_adr := GetProcAddress('glVertexStream2sATI');
    private ntv_VertexStream2sATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; x: Int16; y: Int16)>(VertexStream2sATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2sATI(stream: glVertexStream; x: Int16; y: Int16) :=
      ntv_VertexStream2sATI_1(stream, x, y);
    
    private VertexStream2svATI_adr := GetProcAddress('glVertexStream2svATI');
    private ntv_VertexStream2svATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Int16)>(VertexStream2svATI_adr);
    private ntv_VertexStream2svATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Vec2s)>(VertexStream2svATI_adr);
    private ntv_VertexStream2svATI_3 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(VertexStream2svATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2svATI(stream: glVertexStream; coords: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_VertexStream2svATI_1(stream, coords[0]) else
        ntv_VertexStream2svATI_1(stream, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2svATI(stream: glVertexStream; var coords: Vec2s) :=
      ntv_VertexStream2svATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2svATI(stream: glVertexStream; var coords: Int16) :=
      ntv_VertexStream2svATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2svATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_VertexStream2svATI_3(stream, coords);
    
    private VertexStream2iATI_adr := GetProcAddress('glVertexStream2iATI');
    private ntv_VertexStream2iATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; x: Int32; y: Int32)>(VertexStream2iATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2iATI(stream: glVertexStream; x: Int32; y: Int32) :=
      ntv_VertexStream2iATI_1(stream, x, y);
    
    private VertexStream2ivATI_adr := GetProcAddress('glVertexStream2ivATI');
    private ntv_VertexStream2ivATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Int32)>(VertexStream2ivATI_adr);
    private ntv_VertexStream2ivATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Vec2i)>(VertexStream2ivATI_adr);
    private ntv_VertexStream2ivATI_3 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(VertexStream2ivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2ivATI(stream: glVertexStream; coords: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_VertexStream2ivATI_1(stream, coords[0]) else
        ntv_VertexStream2ivATI_1(stream, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2ivATI(stream: glVertexStream; var coords: Vec2i) :=
      ntv_VertexStream2ivATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2ivATI(stream: glVertexStream; var coords: Int32) :=
      ntv_VertexStream2ivATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2ivATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_VertexStream2ivATI_3(stream, coords);
    
    private VertexStream2fATI_adr := GetProcAddress('glVertexStream2fATI');
    private ntv_VertexStream2fATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; x: single; y: single)>(VertexStream2fATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2fATI(stream: glVertexStream; x: single; y: single) :=
      ntv_VertexStream2fATI_1(stream, x, y);
    
    private VertexStream2fvATI_adr := GetProcAddress('glVertexStream2fvATI');
    private ntv_VertexStream2fvATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: single)>(VertexStream2fvATI_adr);
    private ntv_VertexStream2fvATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Vec2f)>(VertexStream2fvATI_adr);
    private ntv_VertexStream2fvATI_3 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(VertexStream2fvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2fvATI(stream: glVertexStream; coords: array of single);
    type PSingle = ^single;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_VertexStream2fvATI_1(stream, coords[0]) else
        ntv_VertexStream2fvATI_1(stream, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2fvATI(stream: glVertexStream; var coords: Vec2f) :=
      ntv_VertexStream2fvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2fvATI(stream: glVertexStream; var coords: single) :=
      ntv_VertexStream2fvATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2fvATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_VertexStream2fvATI_3(stream, coords);
    
    private VertexStream2dATI_adr := GetProcAddress('glVertexStream2dATI');
    private ntv_VertexStream2dATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; x: double; y: double)>(VertexStream2dATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2dATI(stream: glVertexStream; x: double; y: double) :=
      ntv_VertexStream2dATI_1(stream, x, y);
    
    private VertexStream2dvATI_adr := GetProcAddress('glVertexStream2dvATI');
    private ntv_VertexStream2dvATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: double)>(VertexStream2dvATI_adr);
    private ntv_VertexStream2dvATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Vec2d)>(VertexStream2dvATI_adr);
    private ntv_VertexStream2dvATI_3 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(VertexStream2dvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2dvATI(stream: glVertexStream; coords: array of double);
    type PDouble = ^double;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_VertexStream2dvATI_1(stream, coords[0]) else
        ntv_VertexStream2dvATI_1(stream, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2dvATI(stream: glVertexStream; var coords: Vec2d) :=
      ntv_VertexStream2dvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2dvATI(stream: glVertexStream; var coords: double) :=
      ntv_VertexStream2dvATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2dvATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_VertexStream2dvATI_3(stream, coords);
    
    private VertexStream3sATI_adr := GetProcAddress('glVertexStream3sATI');
    private ntv_VertexStream3sATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; x: Int16; y: Int16; z: Int16)>(VertexStream3sATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3sATI(stream: glVertexStream; x: Int16; y: Int16; z: Int16) :=
      ntv_VertexStream3sATI_1(stream, x, y, z);
    
    private VertexStream3svATI_adr := GetProcAddress('glVertexStream3svATI');
    private ntv_VertexStream3svATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Int16)>(VertexStream3svATI_adr);
    private ntv_VertexStream3svATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Vec3s)>(VertexStream3svATI_adr);
    private ntv_VertexStream3svATI_3 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(VertexStream3svATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3svATI(stream: glVertexStream; coords: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_VertexStream3svATI_1(stream, coords[0]) else
        ntv_VertexStream3svATI_1(stream, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3svATI(stream: glVertexStream; var coords: Vec3s) :=
      ntv_VertexStream3svATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3svATI(stream: glVertexStream; var coords: Int16) :=
      ntv_VertexStream3svATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3svATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_VertexStream3svATI_3(stream, coords);
    
    private VertexStream3iATI_adr := GetProcAddress('glVertexStream3iATI');
    private ntv_VertexStream3iATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; x: Int32; y: Int32; z: Int32)>(VertexStream3iATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3iATI(stream: glVertexStream; x: Int32; y: Int32; z: Int32) :=
      ntv_VertexStream3iATI_1(stream, x, y, z);
    
    private VertexStream3ivATI_adr := GetProcAddress('glVertexStream3ivATI');
    private ntv_VertexStream3ivATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Int32)>(VertexStream3ivATI_adr);
    private ntv_VertexStream3ivATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Vec3i)>(VertexStream3ivATI_adr);
    private ntv_VertexStream3ivATI_3 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(VertexStream3ivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3ivATI(stream: glVertexStream; coords: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_VertexStream3ivATI_1(stream, coords[0]) else
        ntv_VertexStream3ivATI_1(stream, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3ivATI(stream: glVertexStream; var coords: Vec3i) :=
      ntv_VertexStream3ivATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3ivATI(stream: glVertexStream; var coords: Int32) :=
      ntv_VertexStream3ivATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3ivATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_VertexStream3ivATI_3(stream, coords);
    
    private VertexStream3fATI_adr := GetProcAddress('glVertexStream3fATI');
    private ntv_VertexStream3fATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; x: single; y: single; z: single)>(VertexStream3fATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3fATI(stream: glVertexStream; x: single; y: single; z: single) :=
      ntv_VertexStream3fATI_1(stream, x, y, z);
    
    private VertexStream3fvATI_adr := GetProcAddress('glVertexStream3fvATI');
    private ntv_VertexStream3fvATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: single)>(VertexStream3fvATI_adr);
    private ntv_VertexStream3fvATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Vec3f)>(VertexStream3fvATI_adr);
    private ntv_VertexStream3fvATI_3 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(VertexStream3fvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3fvATI(stream: glVertexStream; coords: array of single);
    type PSingle = ^single;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_VertexStream3fvATI_1(stream, coords[0]) else
        ntv_VertexStream3fvATI_1(stream, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3fvATI(stream: glVertexStream; var coords: Vec3f) :=
      ntv_VertexStream3fvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3fvATI(stream: glVertexStream; var coords: single) :=
      ntv_VertexStream3fvATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3fvATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_VertexStream3fvATI_3(stream, coords);
    
    private VertexStream3dATI_adr := GetProcAddress('glVertexStream3dATI');
    private ntv_VertexStream3dATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; x: double; y: double; z: double)>(VertexStream3dATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3dATI(stream: glVertexStream; x: double; y: double; z: double) :=
      ntv_VertexStream3dATI_1(stream, x, y, z);
    
    private VertexStream3dvATI_adr := GetProcAddress('glVertexStream3dvATI');
    private ntv_VertexStream3dvATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: double)>(VertexStream3dvATI_adr);
    private ntv_VertexStream3dvATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Vec3d)>(VertexStream3dvATI_adr);
    private ntv_VertexStream3dvATI_3 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(VertexStream3dvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3dvATI(stream: glVertexStream; coords: array of double);
    type PDouble = ^double;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_VertexStream3dvATI_1(stream, coords[0]) else
        ntv_VertexStream3dvATI_1(stream, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3dvATI(stream: glVertexStream; var coords: Vec3d) :=
      ntv_VertexStream3dvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3dvATI(stream: glVertexStream; var coords: double) :=
      ntv_VertexStream3dvATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3dvATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_VertexStream3dvATI_3(stream, coords);
    
    private VertexStream4sATI_adr := GetProcAddress('glVertexStream4sATI');
    private ntv_VertexStream4sATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; x: Int16; y: Int16; z: Int16; w: Int16)>(VertexStream4sATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4sATI(stream: glVertexStream; x: Int16; y: Int16; z: Int16; w: Int16) :=
      ntv_VertexStream4sATI_1(stream, x, y, z, w);
    
    private VertexStream4svATI_adr := GetProcAddress('glVertexStream4svATI');
    private ntv_VertexStream4svATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Int16)>(VertexStream4svATI_adr);
    private ntv_VertexStream4svATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Vec4s)>(VertexStream4svATI_adr);
    private ntv_VertexStream4svATI_3 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(VertexStream4svATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4svATI(stream: glVertexStream; coords: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_VertexStream4svATI_1(stream, coords[0]) else
        ntv_VertexStream4svATI_1(stream, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4svATI(stream: glVertexStream; var coords: Vec4s) :=
      ntv_VertexStream4svATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4svATI(stream: glVertexStream; var coords: Int16) :=
      ntv_VertexStream4svATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4svATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_VertexStream4svATI_3(stream, coords);
    
    private VertexStream4iATI_adr := GetProcAddress('glVertexStream4iATI');
    private ntv_VertexStream4iATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; x: Int32; y: Int32; z: Int32; w: Int32)>(VertexStream4iATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4iATI(stream: glVertexStream; x: Int32; y: Int32; z: Int32; w: Int32) :=
      ntv_VertexStream4iATI_1(stream, x, y, z, w);
    
    private VertexStream4ivATI_adr := GetProcAddress('glVertexStream4ivATI');
    private ntv_VertexStream4ivATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Int32)>(VertexStream4ivATI_adr);
    private ntv_VertexStream4ivATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Vec4i)>(VertexStream4ivATI_adr);
    private ntv_VertexStream4ivATI_3 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(VertexStream4ivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4ivATI(stream: glVertexStream; coords: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_VertexStream4ivATI_1(stream, coords[0]) else
        ntv_VertexStream4ivATI_1(stream, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4ivATI(stream: glVertexStream; var coords: Vec4i) :=
      ntv_VertexStream4ivATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4ivATI(stream: glVertexStream; var coords: Int32) :=
      ntv_VertexStream4ivATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4ivATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_VertexStream4ivATI_3(stream, coords);
    
    private VertexStream4fATI_adr := GetProcAddress('glVertexStream4fATI');
    private ntv_VertexStream4fATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; x: single; y: single; z: single; w: single)>(VertexStream4fATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4fATI(stream: glVertexStream; x: single; y: single; z: single; w: single) :=
      ntv_VertexStream4fATI_1(stream, x, y, z, w);
    
    private VertexStream4fvATI_adr := GetProcAddress('glVertexStream4fvATI');
    private ntv_VertexStream4fvATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: single)>(VertexStream4fvATI_adr);
    private ntv_VertexStream4fvATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Vec4f)>(VertexStream4fvATI_adr);
    private ntv_VertexStream4fvATI_3 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(VertexStream4fvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4fvATI(stream: glVertexStream; coords: array of single);
    type PSingle = ^single;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_VertexStream4fvATI_1(stream, coords[0]) else
        ntv_VertexStream4fvATI_1(stream, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4fvATI(stream: glVertexStream; var coords: Vec4f) :=
      ntv_VertexStream4fvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4fvATI(stream: glVertexStream; var coords: single) :=
      ntv_VertexStream4fvATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4fvATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_VertexStream4fvATI_3(stream, coords);
    
    private VertexStream4dATI_adr := GetProcAddress('glVertexStream4dATI');
    private ntv_VertexStream4dATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; x: double; y: double; z: double; w: double)>(VertexStream4dATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4dATI(stream: glVertexStream; x: double; y: double; z: double; w: double) :=
      ntv_VertexStream4dATI_1(stream, x, y, z, w);
    
    private VertexStream4dvATI_adr := GetProcAddress('glVertexStream4dvATI');
    private ntv_VertexStream4dvATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: double)>(VertexStream4dvATI_adr);
    private ntv_VertexStream4dvATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Vec4d)>(VertexStream4dvATI_adr);
    private ntv_VertexStream4dvATI_3 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(VertexStream4dvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4dvATI(stream: glVertexStream; coords: array of double);
    type PDouble = ^double;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_VertexStream4dvATI_1(stream, coords[0]) else
        ntv_VertexStream4dvATI_1(stream, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4dvATI(stream: glVertexStream; var coords: Vec4d) :=
      ntv_VertexStream4dvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4dvATI(stream: glVertexStream; var coords: double) :=
      ntv_VertexStream4dvATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4dvATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_VertexStream4dvATI_3(stream, coords);
    
    private NormalStream3bATI_adr := GetProcAddress('glNormalStream3bATI');
    private ntv_NormalStream3bATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; nx: SByte; ny: SByte; nz: SByte)>(NormalStream3bATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3bATI(stream: glVertexStream; nx: SByte; ny: SByte; nz: SByte) :=
      ntv_NormalStream3bATI_1(stream, nx, ny, nz);
    
    private NormalStream3bvATI_adr := GetProcAddress('glNormalStream3bvATI');
    private ntv_NormalStream3bvATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: SByte)>(NormalStream3bvATI_adr);
    private ntv_NormalStream3bvATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Vec3b)>(NormalStream3bvATI_adr);
    private ntv_NormalStream3bvATI_3 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(NormalStream3bvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3bvATI(stream: glVertexStream; coords: array of SByte);
    type PSByte = ^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_NormalStream3bvATI_1(stream, coords[0]) else
        ntv_NormalStream3bvATI_1(stream, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3bvATI(stream: glVertexStream; var coords: Vec3b) :=
      ntv_NormalStream3bvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3bvATI(stream: glVertexStream; var coords: SByte) :=
      ntv_NormalStream3bvATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3bvATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_NormalStream3bvATI_3(stream, coords);
    
    private NormalStream3sATI_adr := GetProcAddress('glNormalStream3sATI');
    private ntv_NormalStream3sATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; nx: Int16; ny: Int16; nz: Int16)>(NormalStream3sATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3sATI(stream: glVertexStream; nx: Int16; ny: Int16; nz: Int16) :=
      ntv_NormalStream3sATI_1(stream, nx, ny, nz);
    
    private NormalStream3svATI_adr := GetProcAddress('glNormalStream3svATI');
    private ntv_NormalStream3svATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Int16)>(NormalStream3svATI_adr);
    private ntv_NormalStream3svATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Vec3s)>(NormalStream3svATI_adr);
    private ntv_NormalStream3svATI_3 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(NormalStream3svATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3svATI(stream: glVertexStream; coords: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_NormalStream3svATI_1(stream, coords[0]) else
        ntv_NormalStream3svATI_1(stream, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3svATI(stream: glVertexStream; var coords: Vec3s) :=
      ntv_NormalStream3svATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3svATI(stream: glVertexStream; var coords: Int16) :=
      ntv_NormalStream3svATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3svATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_NormalStream3svATI_3(stream, coords);
    
    private NormalStream3iATI_adr := GetProcAddress('glNormalStream3iATI');
    private ntv_NormalStream3iATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; nx: Int32; ny: Int32; nz: Int32)>(NormalStream3iATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3iATI(stream: glVertexStream; nx: Int32; ny: Int32; nz: Int32) :=
      ntv_NormalStream3iATI_1(stream, nx, ny, nz);
    
    private NormalStream3ivATI_adr := GetProcAddress('glNormalStream3ivATI');
    private ntv_NormalStream3ivATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Int32)>(NormalStream3ivATI_adr);
    private ntv_NormalStream3ivATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Vec3i)>(NormalStream3ivATI_adr);
    private ntv_NormalStream3ivATI_3 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(NormalStream3ivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3ivATI(stream: glVertexStream; coords: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_NormalStream3ivATI_1(stream, coords[0]) else
        ntv_NormalStream3ivATI_1(stream, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3ivATI(stream: glVertexStream; var coords: Vec3i) :=
      ntv_NormalStream3ivATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3ivATI(stream: glVertexStream; var coords: Int32) :=
      ntv_NormalStream3ivATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3ivATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_NormalStream3ivATI_3(stream, coords);
    
    private NormalStream3fATI_adr := GetProcAddress('glNormalStream3fATI');
    private ntv_NormalStream3fATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; nx: single; ny: single; nz: single)>(NormalStream3fATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3fATI(stream: glVertexStream; nx: single; ny: single; nz: single) :=
      ntv_NormalStream3fATI_1(stream, nx, ny, nz);
    
    private NormalStream3fvATI_adr := GetProcAddress('glNormalStream3fvATI');
    private ntv_NormalStream3fvATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: single)>(NormalStream3fvATI_adr);
    private ntv_NormalStream3fvATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Vec3f)>(NormalStream3fvATI_adr);
    private ntv_NormalStream3fvATI_3 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(NormalStream3fvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3fvATI(stream: glVertexStream; coords: array of single);
    type PSingle = ^single;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_NormalStream3fvATI_1(stream, coords[0]) else
        ntv_NormalStream3fvATI_1(stream, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3fvATI(stream: glVertexStream; var coords: Vec3f) :=
      ntv_NormalStream3fvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3fvATI(stream: glVertexStream; var coords: single) :=
      ntv_NormalStream3fvATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3fvATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_NormalStream3fvATI_3(stream, coords);
    
    private NormalStream3dATI_adr := GetProcAddress('glNormalStream3dATI');
    private ntv_NormalStream3dATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; nx: double; ny: double; nz: double)>(NormalStream3dATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3dATI(stream: glVertexStream; nx: double; ny: double; nz: double) :=
      ntv_NormalStream3dATI_1(stream, nx, ny, nz);
    
    private NormalStream3dvATI_adr := GetProcAddress('glNormalStream3dvATI');
    private ntv_NormalStream3dvATI_1 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: double)>(NormalStream3dvATI_adr);
    private ntv_NormalStream3dvATI_2 := GetProcOrNil&<procedure(stream: glVertexStream; var coords: Vec3d)>(NormalStream3dvATI_adr);
    private ntv_NormalStream3dvATI_3 := GetProcOrNil&<procedure(stream: glVertexStream; coords: IntPtr)>(NormalStream3dvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3dvATI(stream: glVertexStream; coords: array of double);
    type PDouble = ^double;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_NormalStream3dvATI_1(stream, coords[0]) else
        ntv_NormalStream3dvATI_1(stream, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3dvATI(stream: glVertexStream; var coords: Vec3d) :=
      ntv_NormalStream3dvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3dvATI(stream: glVertexStream; var coords: double) :=
      ntv_NormalStream3dvATI_1(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3dvATI(stream: glVertexStream; coords: IntPtr) :=
      ntv_NormalStream3dvATI_3(stream, coords);
    
    private ClientActiveVertexStreamATI_adr := GetProcAddress('glClientActiveVertexStreamATI');
    private ntv_ClientActiveVertexStreamATI_1 := GetProcOrNil&<procedure(stream: glVertexStream)>(ClientActiveVertexStreamATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientActiveVertexStreamATI(stream: glVertexStream) :=
      ntv_ClientActiveVertexStreamATI_1(stream);
    
    private VertexBlendEnviATI_adr := GetProcAddress('glVertexBlendEnviATI');
    private ntv_VertexBlendEnviATI_1 := GetProcOrNil&<procedure(pname: glVertexStream; param: Int32)>(VertexBlendEnviATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexBlendEnviATI(pname: glVertexStream; param: Int32) :=
      ntv_VertexBlendEnviATI_1(pname, param);
    
    private VertexBlendEnvfATI_adr := GetProcAddress('glVertexBlendEnvfATI');
    private ntv_VertexBlendEnvfATI_1 := GetProcOrNil&<procedure(pname: glVertexStream; param: single)>(VertexBlendEnvfATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexBlendEnvfATI(pname: glVertexStream; param: single) :=
      ntv_VertexBlendEnvfATI_1(pname, param);
    
  end;
  
  ///
  gl422PixelsEXT = static class
    public const _ExtStr = 'GL_EXT_422_pixels';
  end;
  
  ///
  glAbgrEXT = static class
    public const _ExtStr = 'GL_EXT_abgr';
  end;
  
  ///
  glBgraEXT = static class
    public const _ExtStr = 'GL_EXT_bgra';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glBindableUniformEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_bindable_uniform';
    
    private UniformBufferEXT_adr := GetProcAddress('glUniformBufferEXT');
    private ntv_UniformBufferEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; buffer: gl_buffer)>(UniformBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformBufferEXT(&program: gl_program; location: Int32; buffer: gl_buffer) :=
      ntv_UniformBufferEXT_1(&program, location, buffer);
    
    private GetUniformBufferSizeEXT_adr := GetProcAddress('glGetUniformBufferSizeEXT');
    private ntv_GetUniformBufferSizeEXT_1 := GetProcOrNil&<function(&program: gl_program; location: Int32): Int32>(GetUniformBufferSizeEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformBufferSizeEXT(&program: gl_program; location: Int32): Int32 :=
      ntv_GetUniformBufferSizeEXT_1(&program, location);
    
    private GetUniformOffsetEXT_adr := GetProcAddress('glGetUniformOffsetEXT');
    private ntv_GetUniformOffsetEXT_1 := GetProcOrNil&<function(&program: gl_program; location: Int32): IntPtr>(GetUniformOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformOffsetEXT(&program: gl_program; location: Int32): IntPtr :=
      ntv_GetUniformOffsetEXT_1(&program, location);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glBlendColorEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_blend_color';
    
    private BlendColorEXT_adr := GetProcAddress('glBlendColorEXT');
    private ntv_BlendColorEXT_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single; alpha: single)>(BlendColorEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendColorEXT(red: single; green: single; blue: single; alpha: single) :=
      ntv_BlendColorEXT_1(red, green, blue, alpha);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glBlendEquationSeparateEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_blend_equation_separate';
    
    private BlendEquationSeparateEXT_adr := GetProcAddress('glBlendEquationSeparateEXT');
    private ntv_BlendEquationSeparateEXT_1 := GetProcOrNil&<procedure(modeRGB: glBlendEquationMode; modeAlpha: glBlendEquationMode)>(BlendEquationSeparateEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparateEXT(modeRGB: glBlendEquationMode; modeAlpha: glBlendEquationMode) :=
      ntv_BlendEquationSeparateEXT_1(modeRGB, modeAlpha);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glBlendFuncSeparateEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_blend_func_separate';
    
    private BlendFuncSeparateEXT_adr := GetProcAddress('glBlendFuncSeparateEXT');
    private ntv_BlendFuncSeparateEXT_1 := GetProcOrNil&<procedure(sfactorRGB: glBlendingFactor; dfactorRGB: glBlendingFactor; sfactorAlpha: glBlendingFactor; dfactorAlpha: glBlendingFactor)>(BlendFuncSeparateEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparateEXT(sfactorRGB: glBlendingFactor; dfactorRGB: glBlendingFactor; sfactorAlpha: glBlendingFactor; dfactorAlpha: glBlendingFactor) :=
      ntv_BlendFuncSeparateEXT_1(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    
  end;
  
  ///
  glBlendLogicOpEXT = static class
    public const _ExtStr = 'GL_EXT_blend_logic_op';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glBlendMinmaxEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_blend_minmax';
    
    private BlendEquationEXT_adr := GetProcAddress('glBlendEquationEXT');
    private ntv_BlendEquationEXT_1 := GetProcOrNil&<procedure(mode: glBlendEquationMode)>(BlendEquationEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationEXT(mode: glBlendEquationMode) :=
      ntv_BlendEquationEXT_1(mode);
    
  end;
  
  ///
  glBlendSubtractEXT = static class
    public const _ExtStr = 'GL_EXT_blend_subtract';
  end;
  
  ///
  glClipVolumeHintEXT = static class
    public const _ExtStr = 'GL_EXT_clip_volume_hint';
  end;
  
  ///
  glCmykaEXT = static class
    public const _ExtStr = 'GL_EXT_cmyka';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glColorSubtableEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_color_subtable';
    
    private ColorSubTableEXT_adr := GetProcAddress('glColorSubTableEXT');
    private ntv_ColorSubTableEXT_1 := GetProcOrNil&<procedure(target: glColorTableTarget; start: Int32; count: Int32; format: glPixelFormat; &type: glPixelType; data: IntPtr)>(ColorSubTableEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorSubTableEXT(target: glColorTableTarget; start: Int32; count: Int32; format: glPixelFormat; &type: glPixelType; data: IntPtr) :=
      ntv_ColorSubTableEXT_1(target, start, count, format, &type, data);
    
    private CopyColorSubTableEXT_adr := GetProcAddress('glCopyColorSubTableEXT');
    private ntv_CopyColorSubTableEXT_1 := GetProcOrNil&<procedure(target: glColorTableTarget; start: Int32; x: Int32; y: Int32; width: Int32)>(CopyColorSubTableEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyColorSubTableEXT(target: glColorTableTarget; start: Int32; x: Int32; y: Int32; width: Int32) :=
      ntv_CopyColorSubTableEXT_1(target, start, x, y, width);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glCompiledVertexArrayEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_compiled_vertex_array';
    
    private LockArraysEXT_adr := GetProcAddress('glLockArraysEXT');
    private ntv_LockArraysEXT_1 := GetProcOrNil&<procedure(first: Int32; count: Int32)>(LockArraysEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LockArraysEXT(first: Int32; count: Int32) :=
      ntv_LockArraysEXT_1(first, count);
    
    private UnlockArraysEXT_adr := GetProcAddress('glUnlockArraysEXT');
    private ntv_UnlockArraysEXT_1 := GetProcOrNil&<procedure>(UnlockArraysEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UnlockArraysEXT :=
      ntv_UnlockArraysEXT_1;
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glConvolutionEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_convolution';
    
    private ConvolutionFilter1DEXT_adr := GetProcAddress('glConvolutionFilter1DEXT');
    private ntv_ConvolutionFilter1DEXT_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; internalformat: glInternalFormat; width: Int32; format: glPixelFormat; &type: glPixelType; image: IntPtr)>(ConvolutionFilter1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionFilter1DEXT(target: glConvolutionTarget; internalformat: glInternalFormat; width: Int32; format: glPixelFormat; &type: glPixelType; image: IntPtr) :=
      ntv_ConvolutionFilter1DEXT_1(target, internalformat, width, format, &type, image);
    
    private ConvolutionFilter2DEXT_adr := GetProcAddress('glConvolutionFilter2DEXT');
    private ntv_ConvolutionFilter2DEXT_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; internalformat: glInternalFormat; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; image: IntPtr)>(ConvolutionFilter2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionFilter2DEXT(target: glConvolutionTarget; internalformat: glInternalFormat; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; image: IntPtr) :=
      ntv_ConvolutionFilter2DEXT_1(target, internalformat, width, height, format, &type, image);
    
    private ConvolutionParameterfEXT_adr := GetProcAddress('glConvolutionParameterfEXT');
    private ntv_ConvolutionParameterfEXT_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; &params: single)>(ConvolutionParameterfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfEXT(target: glConvolutionTarget; pname: glConvolutionParameter; &params: single) :=
      ntv_ConvolutionParameterfEXT_1(target, pname, &params);
    
    private ConvolutionParameterfvEXT_adr := GetProcAddress('glConvolutionParameterfvEXT');
    private ntv_ConvolutionParameterfvEXT_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: single)>(ConvolutionParameterfvEXT_adr);
    private ntv_ConvolutionParameterfvEXT_2 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr)>(ConvolutionParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfvEXT(target: glConvolutionTarget; pname: glConvolutionParameter; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ConvolutionParameterfvEXT_1(target, pname, &params[0]) else
        ntv_ConvolutionParameterfvEXT_1(target, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfvEXT(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: single) :=
      ntv_ConvolutionParameterfvEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfvEXT(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr) :=
      ntv_ConvolutionParameterfvEXT_2(target, pname, &params);
    
    private ConvolutionParameteriEXT_adr := GetProcAddress('glConvolutionParameteriEXT');
    private ntv_ConvolutionParameteriEXT_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; &params: Int32)>(ConvolutionParameteriEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteriEXT(target: glConvolutionTarget; pname: glConvolutionParameter; &params: Int32) :=
      ntv_ConvolutionParameteriEXT_1(target, pname, &params);
    
    private ConvolutionParameterivEXT_adr := GetProcAddress('glConvolutionParameterivEXT');
    private ntv_ConvolutionParameterivEXT_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: Int32)>(ConvolutionParameterivEXT_adr);
    private ntv_ConvolutionParameterivEXT_2 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr)>(ConvolutionParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterivEXT(target: glConvolutionTarget; pname: glConvolutionParameter; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ConvolutionParameterivEXT_1(target, pname, &params[0]) else
        ntv_ConvolutionParameterivEXT_1(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterivEXT(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: Int32) :=
      ntv_ConvolutionParameterivEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterivEXT(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr) :=
      ntv_ConvolutionParameterivEXT_2(target, pname, &params);
    
    private CopyConvolutionFilter1DEXT_adr := GetProcAddress('glCopyConvolutionFilter1DEXT');
    private ntv_CopyConvolutionFilter1DEXT_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32)>(CopyConvolutionFilter1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyConvolutionFilter1DEXT(target: glConvolutionTarget; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32) :=
      ntv_CopyConvolutionFilter1DEXT_1(target, internalformat, x, y, width);
    
    private CopyConvolutionFilter2DEXT_adr := GetProcAddress('glCopyConvolutionFilter2DEXT');
    private ntv_CopyConvolutionFilter2DEXT_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; height: Int32)>(CopyConvolutionFilter2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyConvolutionFilter2DEXT(target: glConvolutionTarget; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_CopyConvolutionFilter2DEXT_1(target, internalformat, x, y, width, height);
    
    private GetConvolutionFilterEXT_adr := GetProcAddress('glGetConvolutionFilterEXT');
    private ntv_GetConvolutionFilterEXT_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; format: glPixelFormat; &type: glPixelType; image: IntPtr)>(GetConvolutionFilterEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionFilterEXT(target: glConvolutionTarget; format: glPixelFormat; &type: glPixelType; image: IntPtr) :=
      ntv_GetConvolutionFilterEXT_1(target, format, &type, image);
    
    private GetConvolutionParameterfvEXT_adr := GetProcAddress('glGetConvolutionParameterfvEXT');
    private ntv_GetConvolutionParameterfvEXT_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: single)>(GetConvolutionParameterfvEXT_adr);
    private ntv_GetConvolutionParameterfvEXT_2 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr)>(GetConvolutionParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterfvEXT(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: single) :=
      ntv_GetConvolutionParameterfvEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterfvEXT(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr) :=
      ntv_GetConvolutionParameterfvEXT_2(target, pname, &params);
    
    private GetConvolutionParameterivEXT_adr := GetProcAddress('glGetConvolutionParameterivEXT');
    private ntv_GetConvolutionParameterivEXT_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: Int32)>(GetConvolutionParameterivEXT_adr);
    private ntv_GetConvolutionParameterivEXT_2 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr)>(GetConvolutionParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterivEXT(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: Int32) :=
      ntv_GetConvolutionParameterivEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterivEXT(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr) :=
      ntv_GetConvolutionParameterivEXT_2(target, pname, &params);
    
    private GetSeparableFilterEXT_adr := GetProcAddress('glGetSeparableFilterEXT');
    private ntv_GetSeparableFilterEXT_1 := GetProcOrNil&<procedure(target: glSeparableTarget; format: glPixelFormat; &type: glPixelType; row: IntPtr; column: IntPtr; span: IntPtr)>(GetSeparableFilterEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSeparableFilterEXT(target: glSeparableTarget; format: glPixelFormat; &type: glPixelType; row: IntPtr; column: IntPtr; span: IntPtr) :=
      ntv_GetSeparableFilterEXT_1(target, format, &type, row, column, span);
    
    private SeparableFilter2DEXT_adr := GetProcAddress('glSeparableFilter2DEXT');
    private ntv_SeparableFilter2DEXT_1 := GetProcOrNil&<procedure(target: glSeparableTarget; internalformat: glInternalFormat; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; row: IntPtr; column: IntPtr)>(SeparableFilter2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SeparableFilter2DEXT(target: glSeparableTarget; internalformat: glInternalFormat; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; row: IntPtr; column: IntPtr) :=
      ntv_SeparableFilter2DEXT_1(target, internalformat, width, height, format, &type, row, column);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glCoordinateFrameEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_coordinate_frame';
    
    private Tangent3bEXT_adr := GetProcAddress('glTangent3bEXT');
    private ntv_Tangent3bEXT_1 := GetProcOrNil&<procedure(tx: SByte; ty: SByte; tz: SByte)>(Tangent3bEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3bEXT(tx: SByte; ty: SByte; tz: SByte) :=
      ntv_Tangent3bEXT_1(tx, ty, tz);
    
    private Tangent3bvEXT_adr := GetProcAddress('glTangent3bvEXT');
    private ntv_Tangent3bvEXT_1 := GetProcOrNil&<procedure(var v: SByte)>(Tangent3bvEXT_adr);
    private ntv_Tangent3bvEXT_2 := GetProcOrNil&<procedure(var v: Vec3b)>(Tangent3bvEXT_adr);
    private ntv_Tangent3bvEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(Tangent3bvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3bvEXT(v: array of SByte);
    type PSByte = ^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Tangent3bvEXT_1(v[0]) else
        ntv_Tangent3bvEXT_1(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3bvEXT(var v: Vec3b) :=
      ntv_Tangent3bvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3bvEXT(var v: SByte) :=
      ntv_Tangent3bvEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3bvEXT(v: IntPtr) :=
      ntv_Tangent3bvEXT_3(v);
    
    private Tangent3dEXT_adr := GetProcAddress('glTangent3dEXT');
    private ntv_Tangent3dEXT_1 := GetProcOrNil&<procedure(tx: double; ty: double; tz: double)>(Tangent3dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3dEXT(tx: double; ty: double; tz: double) :=
      ntv_Tangent3dEXT_1(tx, ty, tz);
    
    private Tangent3dvEXT_adr := GetProcAddress('glTangent3dvEXT');
    private ntv_Tangent3dvEXT_1 := GetProcOrNil&<procedure(var v: double)>(Tangent3dvEXT_adr);
    private ntv_Tangent3dvEXT_2 := GetProcOrNil&<procedure(var v: Vec3d)>(Tangent3dvEXT_adr);
    private ntv_Tangent3dvEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(Tangent3dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3dvEXT(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Tangent3dvEXT_1(v[0]) else
        ntv_Tangent3dvEXT_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3dvEXT(var v: Vec3d) :=
      ntv_Tangent3dvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3dvEXT(var v: double) :=
      ntv_Tangent3dvEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3dvEXT(v: IntPtr) :=
      ntv_Tangent3dvEXT_3(v);
    
    private Tangent3fEXT_adr := GetProcAddress('glTangent3fEXT');
    private ntv_Tangent3fEXT_1 := GetProcOrNil&<procedure(tx: single; ty: single; tz: single)>(Tangent3fEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3fEXT(tx: single; ty: single; tz: single) :=
      ntv_Tangent3fEXT_1(tx, ty, tz);
    
    private Tangent3fvEXT_adr := GetProcAddress('glTangent3fvEXT');
    private ntv_Tangent3fvEXT_1 := GetProcOrNil&<procedure(var v: single)>(Tangent3fvEXT_adr);
    private ntv_Tangent3fvEXT_2 := GetProcOrNil&<procedure(var v: Vec3f)>(Tangent3fvEXT_adr);
    private ntv_Tangent3fvEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(Tangent3fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3fvEXT(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Tangent3fvEXT_1(v[0]) else
        ntv_Tangent3fvEXT_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3fvEXT(var v: Vec3f) :=
      ntv_Tangent3fvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3fvEXT(var v: single) :=
      ntv_Tangent3fvEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3fvEXT(v: IntPtr) :=
      ntv_Tangent3fvEXT_3(v);
    
    private Tangent3iEXT_adr := GetProcAddress('glTangent3iEXT');
    private ntv_Tangent3iEXT_1 := GetProcOrNil&<procedure(tx: Int32; ty: Int32; tz: Int32)>(Tangent3iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3iEXT(tx: Int32; ty: Int32; tz: Int32) :=
      ntv_Tangent3iEXT_1(tx, ty, tz);
    
    private Tangent3ivEXT_adr := GetProcAddress('glTangent3ivEXT');
    private ntv_Tangent3ivEXT_1 := GetProcOrNil&<procedure(var v: Int32)>(Tangent3ivEXT_adr);
    private ntv_Tangent3ivEXT_2 := GetProcOrNil&<procedure(var v: Vec3i)>(Tangent3ivEXT_adr);
    private ntv_Tangent3ivEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(Tangent3ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3ivEXT(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Tangent3ivEXT_1(v[0]) else
        ntv_Tangent3ivEXT_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3ivEXT(var v: Vec3i) :=
      ntv_Tangent3ivEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3ivEXT(var v: Int32) :=
      ntv_Tangent3ivEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3ivEXT(v: IntPtr) :=
      ntv_Tangent3ivEXT_3(v);
    
    private Tangent3sEXT_adr := GetProcAddress('glTangent3sEXT');
    private ntv_Tangent3sEXT_1 := GetProcOrNil&<procedure(tx: Int16; ty: Int16; tz: Int16)>(Tangent3sEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3sEXT(tx: Int16; ty: Int16; tz: Int16) :=
      ntv_Tangent3sEXT_1(tx, ty, tz);
    
    private Tangent3svEXT_adr := GetProcAddress('glTangent3svEXT');
    private ntv_Tangent3svEXT_1 := GetProcOrNil&<procedure(var v: Int16)>(Tangent3svEXT_adr);
    private ntv_Tangent3svEXT_2 := GetProcOrNil&<procedure(var v: Vec3s)>(Tangent3svEXT_adr);
    private ntv_Tangent3svEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(Tangent3svEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3svEXT(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Tangent3svEXT_1(v[0]) else
        ntv_Tangent3svEXT_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3svEXT(var v: Vec3s) :=
      ntv_Tangent3svEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3svEXT(var v: Int16) :=
      ntv_Tangent3svEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3svEXT(v: IntPtr) :=
      ntv_Tangent3svEXT_3(v);
    
    private Binormal3bEXT_adr := GetProcAddress('glBinormal3bEXT');
    private ntv_Binormal3bEXT_1 := GetProcOrNil&<procedure(bx: SByte; by: SByte; bz: SByte)>(Binormal3bEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3bEXT(bx: SByte; by: SByte; bz: SByte) :=
      ntv_Binormal3bEXT_1(bx, by, bz);
    
    private Binormal3bvEXT_adr := GetProcAddress('glBinormal3bvEXT');
    private ntv_Binormal3bvEXT_1 := GetProcOrNil&<procedure(var v: SByte)>(Binormal3bvEXT_adr);
    private ntv_Binormal3bvEXT_2 := GetProcOrNil&<procedure(var v: Vec3b)>(Binormal3bvEXT_adr);
    private ntv_Binormal3bvEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(Binormal3bvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3bvEXT(v: array of SByte);
    type PSByte = ^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Binormal3bvEXT_1(v[0]) else
        ntv_Binormal3bvEXT_1(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3bvEXT(var v: Vec3b) :=
      ntv_Binormal3bvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3bvEXT(var v: SByte) :=
      ntv_Binormal3bvEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3bvEXT(v: IntPtr) :=
      ntv_Binormal3bvEXT_3(v);
    
    private Binormal3dEXT_adr := GetProcAddress('glBinormal3dEXT');
    private ntv_Binormal3dEXT_1 := GetProcOrNil&<procedure(bx: double; by: double; bz: double)>(Binormal3dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3dEXT(bx: double; by: double; bz: double) :=
      ntv_Binormal3dEXT_1(bx, by, bz);
    
    private Binormal3dvEXT_adr := GetProcAddress('glBinormal3dvEXT');
    private ntv_Binormal3dvEXT_1 := GetProcOrNil&<procedure(var v: double)>(Binormal3dvEXT_adr);
    private ntv_Binormal3dvEXT_2 := GetProcOrNil&<procedure(var v: Vec3d)>(Binormal3dvEXT_adr);
    private ntv_Binormal3dvEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(Binormal3dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3dvEXT(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Binormal3dvEXT_1(v[0]) else
        ntv_Binormal3dvEXT_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3dvEXT(var v: Vec3d) :=
      ntv_Binormal3dvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3dvEXT(var v: double) :=
      ntv_Binormal3dvEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3dvEXT(v: IntPtr) :=
      ntv_Binormal3dvEXT_3(v);
    
    private Binormal3fEXT_adr := GetProcAddress('glBinormal3fEXT');
    private ntv_Binormal3fEXT_1 := GetProcOrNil&<procedure(bx: single; by: single; bz: single)>(Binormal3fEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3fEXT(bx: single; by: single; bz: single) :=
      ntv_Binormal3fEXT_1(bx, by, bz);
    
    private Binormal3fvEXT_adr := GetProcAddress('glBinormal3fvEXT');
    private ntv_Binormal3fvEXT_1 := GetProcOrNil&<procedure(var v: single)>(Binormal3fvEXT_adr);
    private ntv_Binormal3fvEXT_2 := GetProcOrNil&<procedure(var v: Vec3f)>(Binormal3fvEXT_adr);
    private ntv_Binormal3fvEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(Binormal3fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3fvEXT(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Binormal3fvEXT_1(v[0]) else
        ntv_Binormal3fvEXT_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3fvEXT(var v: Vec3f) :=
      ntv_Binormal3fvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3fvEXT(var v: single) :=
      ntv_Binormal3fvEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3fvEXT(v: IntPtr) :=
      ntv_Binormal3fvEXT_3(v);
    
    private Binormal3iEXT_adr := GetProcAddress('glBinormal3iEXT');
    private ntv_Binormal3iEXT_1 := GetProcOrNil&<procedure(bx: Int32; by: Int32; bz: Int32)>(Binormal3iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3iEXT(bx: Int32; by: Int32; bz: Int32) :=
      ntv_Binormal3iEXT_1(bx, by, bz);
    
    private Binormal3ivEXT_adr := GetProcAddress('glBinormal3ivEXT');
    private ntv_Binormal3ivEXT_1 := GetProcOrNil&<procedure(var v: Int32)>(Binormal3ivEXT_adr);
    private ntv_Binormal3ivEXT_2 := GetProcOrNil&<procedure(var v: Vec3i)>(Binormal3ivEXT_adr);
    private ntv_Binormal3ivEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(Binormal3ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3ivEXT(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Binormal3ivEXT_1(v[0]) else
        ntv_Binormal3ivEXT_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3ivEXT(var v: Vec3i) :=
      ntv_Binormal3ivEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3ivEXT(var v: Int32) :=
      ntv_Binormal3ivEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3ivEXT(v: IntPtr) :=
      ntv_Binormal3ivEXT_3(v);
    
    private Binormal3sEXT_adr := GetProcAddress('glBinormal3sEXT');
    private ntv_Binormal3sEXT_1 := GetProcOrNil&<procedure(bx: Int16; by: Int16; bz: Int16)>(Binormal3sEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3sEXT(bx: Int16; by: Int16; bz: Int16) :=
      ntv_Binormal3sEXT_1(bx, by, bz);
    
    private Binormal3svEXT_adr := GetProcAddress('glBinormal3svEXT');
    private ntv_Binormal3svEXT_1 := GetProcOrNil&<procedure(var v: Int16)>(Binormal3svEXT_adr);
    private ntv_Binormal3svEXT_2 := GetProcOrNil&<procedure(var v: Vec3s)>(Binormal3svEXT_adr);
    private ntv_Binormal3svEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(Binormal3svEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3svEXT(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Binormal3svEXT_1(v[0]) else
        ntv_Binormal3svEXT_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3svEXT(var v: Vec3s) :=
      ntv_Binormal3svEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3svEXT(var v: Int16) :=
      ntv_Binormal3svEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3svEXT(v: IntPtr) :=
      ntv_Binormal3svEXT_3(v);
    
    private TangentPointerEXT_adr := GetProcAddress('glTangentPointerEXT');
    private ntv_TangentPointerEXT_1 := GetProcOrNil&<procedure(&type: glTangentPointerType; stride: Int32; pointer: IntPtr)>(TangentPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TangentPointerEXT(&type: glTangentPointerType; stride: Int32; pointer: IntPtr) :=
      ntv_TangentPointerEXT_1(&type, stride, pointer);
    
    private BinormalPointerEXT_adr := GetProcAddress('glBinormalPointerEXT');
    private ntv_BinormalPointerEXT_1 := GetProcOrNil&<procedure(&type: glBinormalPointerType; stride: Int32; pointer: IntPtr)>(BinormalPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BinormalPointerEXT(&type: glBinormalPointerType; stride: Int32; pointer: IntPtr) :=
      ntv_BinormalPointerEXT_1(&type, stride, pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glCopyTextureEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_copy_texture';
    
    private CopyTexImage1DEXT_adr := GetProcAddress('glCopyTexImage1DEXT');
    private ntv_CopyTexImage1DEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; border: Int32)>(CopyTexImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexImage1DEXT(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; border: Int32) :=
      ntv_CopyTexImage1DEXT_1(target, level, internalformat, x, y, width, border);
    
    private CopyTexImage2DEXT_adr := GetProcAddress('glCopyTexImage2DEXT');
    private ntv_CopyTexImage2DEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32)>(CopyTexImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexImage2DEXT(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32) :=
      ntv_CopyTexImage2DEXT_1(target, level, internalformat, x, y, width, height, border);
    
    private CopyTexSubImage1DEXT_adr := GetProcAddress('glCopyTexSubImage1DEXT');
    private ntv_CopyTexSubImage1DEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32)>(CopyTexSubImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage1DEXT(target: glTextureTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) :=
      ntv_CopyTexSubImage1DEXT_1(target, level, xoffset, x, y, width);
    
    private CopyTexSubImage2DEXT_adr := GetProcAddress('glCopyTexSubImage2DEXT');
    private ntv_CopyTexSubImage2DEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(CopyTexSubImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage2DEXT(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_CopyTexSubImage2DEXT_1(target, level, xoffset, yoffset, x, y, width, height);
    
    private CopyTexSubImage3DEXT_adr := GetProcAddress('glCopyTexSubImage3DEXT');
    private ntv_CopyTexSubImage3DEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(CopyTexSubImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage3DEXT(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_CopyTexSubImage3DEXT_1(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glCullVertexEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_cull_vertex';
    
    private CullParameterdvEXT_adr := GetProcAddress('glCullParameterdvEXT');
    private ntv_CullParameterdvEXT_1 := GetProcOrNil&<procedure(pname: glCullParameter; var &params: double)>(CullParameterdvEXT_adr);
    private ntv_CullParameterdvEXT_2 := GetProcOrNil&<procedure(pname: glCullParameter; &params: IntPtr)>(CullParameterdvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterdvEXT(pname: glCullParameter; &params: array of double);
    type PDouble = ^double;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_CullParameterdvEXT_1(pname, &params[0]) else
        ntv_CullParameterdvEXT_1(pname, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterdvEXT(pname: glCullParameter; var &params: double) :=
      ntv_CullParameterdvEXT_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterdvEXT(pname: glCullParameter; &params: IntPtr) :=
      ntv_CullParameterdvEXT_2(pname, &params);
    
    private CullParameterfvEXT_adr := GetProcAddress('glCullParameterfvEXT');
    private ntv_CullParameterfvEXT_1 := GetProcOrNil&<procedure(pname: glCullParameter; var &params: single)>(CullParameterfvEXT_adr);
    private ntv_CullParameterfvEXT_2 := GetProcOrNil&<procedure(pname: glCullParameter; &params: IntPtr)>(CullParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterfvEXT(pname: glCullParameter; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_CullParameterfvEXT_1(pname, &params[0]) else
        ntv_CullParameterfvEXT_1(pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterfvEXT(pname: glCullParameter; var &params: single) :=
      ntv_CullParameterfvEXT_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterfvEXT(pname: glCullParameter; &params: IntPtr) :=
      ntv_CullParameterfvEXT_2(pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDebugLabelEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_debug_label';
    
    private LabelObjectEXT_adr := GetProcAddress('glLabelObjectEXT');
    private ntv_LabelObjectEXT_1 := GetProcOrNil&<procedure(&type: DummyEnum; object: UInt32; length: Int32; &label: IntPtr)>(LabelObjectEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LabelObjectEXT(&type: DummyEnum; object: UInt32; length: Int32; &label: string);
    begin
      var &label_str_ptr := Marshal.StringToHGlobalAnsi(&label);
      try
        ntv_LabelObjectEXT_1(&type, object, length, &label_str_ptr);
      finally
        Marshal.FreeHGlobal(&label_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LabelObjectEXT(&type: DummyEnum; object: UInt32; length: Int32; &label: IntPtr) :=
      ntv_LabelObjectEXT_1(&type, object, length, &label);
    
    private GetObjectLabelEXT_adr := GetProcAddress('glGetObjectLabelEXT');
    private ntv_GetObjectLabelEXT_1 := GetProcOrNil&<procedure(&type: DummyEnum; object: UInt32; bufSize: Int32; var length: Int32; &label: IntPtr)>(GetObjectLabelEXT_adr);
    private ntv_GetObjectLabelEXT_2 := GetProcOrNil&<procedure(&type: DummyEnum; object: UInt32; bufSize: Int32; length: IntPtr; &label: IntPtr)>(GetObjectLabelEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabelEXT(&type: DummyEnum; object: UInt32; bufSize: Int32; var length: Int32; &label: IntPtr) :=
      ntv_GetObjectLabelEXT_1(&type, object, bufSize, length, &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabelEXT(&type: DummyEnum; object: UInt32; bufSize: Int32; length: IntPtr; &label: IntPtr) :=
      ntv_GetObjectLabelEXT_2(&type, object, bufSize, length, &label);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDebugMarkerEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_debug_marker';
    
    private InsertEventMarkerEXT_adr := GetProcAddress('glInsertEventMarkerEXT');
    private ntv_InsertEventMarkerEXT_1 := GetProcOrNil&<procedure(length: Int32; marker: IntPtr)>(InsertEventMarkerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InsertEventMarkerEXT(length: Int32; marker: string);
    begin
      var marker_str_ptr := Marshal.StringToHGlobalAnsi(marker);
      try
        ntv_InsertEventMarkerEXT_1(length, marker_str_ptr);
      finally
        Marshal.FreeHGlobal(marker_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InsertEventMarkerEXT(length: Int32; marker: IntPtr) :=
      ntv_InsertEventMarkerEXT_1(length, marker);
    
    private PushGroupMarkerEXT_adr := GetProcAddress('glPushGroupMarkerEXT');
    private ntv_PushGroupMarkerEXT_1 := GetProcOrNil&<procedure(length: Int32; marker: IntPtr)>(PushGroupMarkerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushGroupMarkerEXT(length: Int32; marker: string);
    begin
      var marker_str_ptr := Marshal.StringToHGlobalAnsi(marker);
      try
        ntv_PushGroupMarkerEXT_1(length, marker_str_ptr);
      finally
        Marshal.FreeHGlobal(marker_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushGroupMarkerEXT(length: Int32; marker: IntPtr) :=
      ntv_PushGroupMarkerEXT_1(length, marker);
    
    private PopGroupMarkerEXT_adr := GetProcAddress('glPopGroupMarkerEXT');
    private ntv_PopGroupMarkerEXT_1 := GetProcOrNil&<procedure>(PopGroupMarkerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopGroupMarkerEXT :=
      ntv_PopGroupMarkerEXT_1;
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDepthBoundsTestEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_depth_bounds_test';
    
    private DepthBoundsEXT_adr := GetProcAddress('glDepthBoundsEXT');
    private ntv_DepthBoundsEXT_1 := GetProcOrNil&<procedure(zmin: double; zmax: double)>(DepthBoundsEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthBoundsEXT(zmin: double; zmax: double) :=
      ntv_DepthBoundsEXT_1(zmin, zmax);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDirectStateAccessEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_direct_state_access';
    
    private MatrixLoadfEXT_adr := GetProcAddress('glMatrixLoadfEXT');
    private ntv_MatrixLoadfEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; var m: single)>(MatrixLoadfEXT_adr);
    private ntv_MatrixLoadfEXT_2 := GetProcOrNil&<procedure(mode: glMatrixMode; m: IntPtr)>(MatrixLoadfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: glMatrixMode; m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixLoadfEXT_1(mode, m[0]) else
        ntv_MatrixLoadfEXT_1(mode, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: glMatrixMode; var m: single) :=
      ntv_MatrixLoadfEXT_1(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: glMatrixMode; m: IntPtr) :=
      ntv_MatrixLoadfEXT_2(mode, m);
    
    private MatrixLoaddEXT_adr := GetProcAddress('glMatrixLoaddEXT');
    private ntv_MatrixLoaddEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; var m: double)>(MatrixLoaddEXT_adr);
    private ntv_MatrixLoaddEXT_2 := GetProcOrNil&<procedure(mode: glMatrixMode; m: IntPtr)>(MatrixLoaddEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: glMatrixMode; m: array of double);
    type PDouble = ^double;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixLoaddEXT_1(mode, m[0]) else
        ntv_MatrixLoaddEXT_1(mode, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: glMatrixMode; var m: double) :=
      ntv_MatrixLoaddEXT_1(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: glMatrixMode; m: IntPtr) :=
      ntv_MatrixLoaddEXT_2(mode, m);
    
    private MatrixMultfEXT_adr := GetProcAddress('glMatrixMultfEXT');
    private ntv_MatrixMultfEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; var m: single)>(MatrixMultfEXT_adr);
    private ntv_MatrixMultfEXT_2 := GetProcOrNil&<procedure(mode: glMatrixMode; m: IntPtr)>(MatrixMultfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: glMatrixMode; m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixMultfEXT_1(mode, m[0]) else
        ntv_MatrixMultfEXT_1(mode, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: glMatrixMode; var m: single) :=
      ntv_MatrixMultfEXT_1(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: glMatrixMode; m: IntPtr) :=
      ntv_MatrixMultfEXT_2(mode, m);
    
    private MatrixMultdEXT_adr := GetProcAddress('glMatrixMultdEXT');
    private ntv_MatrixMultdEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; var m: double)>(MatrixMultdEXT_adr);
    private ntv_MatrixMultdEXT_2 := GetProcOrNil&<procedure(mode: glMatrixMode; m: IntPtr)>(MatrixMultdEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: glMatrixMode; m: array of double);
    type PDouble = ^double;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixMultdEXT_1(mode, m[0]) else
        ntv_MatrixMultdEXT_1(mode, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: glMatrixMode; var m: double) :=
      ntv_MatrixMultdEXT_1(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: glMatrixMode; m: IntPtr) :=
      ntv_MatrixMultdEXT_2(mode, m);
    
    private MatrixLoadIdentityEXT_adr := GetProcAddress('glMatrixLoadIdentityEXT');
    private ntv_MatrixLoadIdentityEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode)>(MatrixLoadIdentityEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadIdentityEXT(mode: glMatrixMode) :=
      ntv_MatrixLoadIdentityEXT_1(mode);
    
    private MatrixRotatefEXT_adr := GetProcAddress('glMatrixRotatefEXT');
    private ntv_MatrixRotatefEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; angle: single; x: single; y: single; z: single)>(MatrixRotatefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixRotatefEXT(mode: glMatrixMode; angle: single; x: single; y: single; z: single) :=
      ntv_MatrixRotatefEXT_1(mode, angle, x, y, z);
    
    private MatrixRotatedEXT_adr := GetProcAddress('glMatrixRotatedEXT');
    private ntv_MatrixRotatedEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; angle: double; x: double; y: double; z: double)>(MatrixRotatedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixRotatedEXT(mode: glMatrixMode; angle: double; x: double; y: double; z: double) :=
      ntv_MatrixRotatedEXT_1(mode, angle, x, y, z);
    
    private MatrixScalefEXT_adr := GetProcAddress('glMatrixScalefEXT');
    private ntv_MatrixScalefEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; x: single; y: single; z: single)>(MatrixScalefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixScalefEXT(mode: glMatrixMode; x: single; y: single; z: single) :=
      ntv_MatrixScalefEXT_1(mode, x, y, z);
    
    private MatrixScaledEXT_adr := GetProcAddress('glMatrixScaledEXT');
    private ntv_MatrixScaledEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; x: double; y: double; z: double)>(MatrixScaledEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixScaledEXT(mode: glMatrixMode; x: double; y: double; z: double) :=
      ntv_MatrixScaledEXT_1(mode, x, y, z);
    
    private MatrixTranslatefEXT_adr := GetProcAddress('glMatrixTranslatefEXT');
    private ntv_MatrixTranslatefEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; x: single; y: single; z: single)>(MatrixTranslatefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixTranslatefEXT(mode: glMatrixMode; x: single; y: single; z: single) :=
      ntv_MatrixTranslatefEXT_1(mode, x, y, z);
    
    private MatrixTranslatedEXT_adr := GetProcAddress('glMatrixTranslatedEXT');
    private ntv_MatrixTranslatedEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; x: double; y: double; z: double)>(MatrixTranslatedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixTranslatedEXT(mode: glMatrixMode; x: double; y: double; z: double) :=
      ntv_MatrixTranslatedEXT_1(mode, x, y, z);
    
    private MatrixFrustumEXT_adr := GetProcAddress('glMatrixFrustumEXT');
    private ntv_MatrixFrustumEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double)>(MatrixFrustumEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixFrustumEXT(mode: glMatrixMode; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double) :=
      ntv_MatrixFrustumEXT_1(mode, left, right, bottom, top, zNear, zFar);
    
    private MatrixOrthoEXT_adr := GetProcAddress('glMatrixOrthoEXT');
    private ntv_MatrixOrthoEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double)>(MatrixOrthoEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixOrthoEXT(mode: glMatrixMode; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double) :=
      ntv_MatrixOrthoEXT_1(mode, left, right, bottom, top, zNear, zFar);
    
    private MatrixPopEXT_adr := GetProcAddress('glMatrixPopEXT');
    private ntv_MatrixPopEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode)>(MatrixPopEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixPopEXT(mode: glMatrixMode) :=
      ntv_MatrixPopEXT_1(mode);
    
    private MatrixPushEXT_adr := GetProcAddress('glMatrixPushEXT');
    private ntv_MatrixPushEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode)>(MatrixPushEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixPushEXT(mode: glMatrixMode) :=
      ntv_MatrixPushEXT_1(mode);
    
    private ClientAttribDefaultEXT_adr := GetProcAddress('glClientAttribDefaultEXT');
    private ntv_ClientAttribDefaultEXT_1 := GetProcOrNil&<procedure(mask: glClientAttribMask)>(ClientAttribDefaultEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientAttribDefaultEXT(mask: glClientAttribMask) :=
      ntv_ClientAttribDefaultEXT_1(mask);
    
    private PushClientAttribDefaultEXT_adr := GetProcAddress('glPushClientAttribDefaultEXT');
    private ntv_PushClientAttribDefaultEXT_1 := GetProcOrNil&<procedure(mask: glClientAttribMask)>(PushClientAttribDefaultEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushClientAttribDefaultEXT(mask: glClientAttribMask) :=
      ntv_PushClientAttribDefaultEXT_1(mask);
    
    private TextureParameterfEXT_adr := GetProcAddress('glTextureParameterfEXT');
    private ntv_TextureParameterfEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: single)>(TextureParameterfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: single) :=
      ntv_TextureParameterfEXT_1(texture, target, pname, param);
    
    private TextureParameterfvEXT_adr := GetProcAddress('glTextureParameterfvEXT');
    private ntv_TextureParameterfvEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; var &params: single)>(TextureParameterfvEXT_adr);
    private ntv_TextureParameterfvEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr)>(TextureParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfvEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TextureParameterfvEXT_1(texture, target, pname, &params[0]) else
        ntv_TextureParameterfvEXT_1(texture, target, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfvEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; var &params: single) :=
      ntv_TextureParameterfvEXT_1(texture, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfvEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_TextureParameterfvEXT_2(texture, target, pname, &params);
    
    private TextureParameteriEXT_adr := GetProcAddress('glTextureParameteriEXT');
    private ntv_TextureParameteriEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glConvolutionBorderMode)>(TextureParameteriEXT_adr);
    private ntv_TextureParameteriEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glDepthStencilTextureMode)>(TextureParameteriEXT_adr);
    private ntv_TextureParameteriEXT_3 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glFoveationConfigBit)>(TextureParameteriEXT_adr);
    private ntv_TextureParameteriEXT_4 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glMapTextureFormat)>(TextureParameteriEXT_adr);
    private ntv_TextureParameteriEXT_5 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glTextureCompareMode)>(TextureParameteriEXT_adr);
    private ntv_TextureParameteriEXT_6 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glTextureMagFilter)>(TextureParameteriEXT_adr);
    private ntv_TextureParameteriEXT_7 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glTextureMinFilter)>(TextureParameteriEXT_adr);
    private ntv_TextureParameteriEXT_8 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glTextureSwizzle)>(TextureParameteriEXT_adr);
    private ntv_TextureParameteriEXT_9 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glTextureWrapMode)>(TextureParameteriEXT_adr);
    private ntv_TextureParameteriEXT_10 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: Int32)>(TextureParameteriEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glConvolutionBorderMode) :=
      ntv_TextureParameteriEXT_1(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glDepthStencilTextureMode) :=
      ntv_TextureParameteriEXT_2(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glFoveationConfigBit) :=
      ntv_TextureParameteriEXT_3(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glMapTextureFormat) :=
      ntv_TextureParameteriEXT_4(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glTextureCompareMode) :=
      ntv_TextureParameteriEXT_5(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glTextureMagFilter) :=
      ntv_TextureParameteriEXT_6(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glTextureMinFilter) :=
      ntv_TextureParameteriEXT_7(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glTextureSwizzle) :=
      ntv_TextureParameteriEXT_8(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: glTextureWrapMode) :=
      ntv_TextureParameteriEXT_9(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; param: Int32) :=
      ntv_TextureParameteriEXT_10(texture, target, pname, param);
    
    private TextureParameterivEXT_adr := GetProcAddress('glTextureParameterivEXT');
    private ntv_TextureParameterivEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; var &params: Int32)>(TextureParameterivEXT_adr);
    private ntv_TextureParameterivEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr)>(TextureParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterivEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TextureParameterivEXT_1(texture, target, pname, &params[0]) else
        ntv_TextureParameterivEXT_1(texture, target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterivEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; var &params: Int32) :=
      ntv_TextureParameterivEXT_1(texture, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterivEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_TextureParameterivEXT_2(texture, target, pname, &params);
    
    private TextureImage1DEXT_adr := GetProcAddress('glTextureImage1DEXT');
    private ntv_TextureImage1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TextureImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage1DEXT(texture: gl_texture; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TextureImage1DEXT_1(texture, target, level, internalformat, width, border, format, &type, pixels);
    
    private TextureImage2DEXT_adr := GetProcAddress('glTextureImage2DEXT');
    private ntv_TextureImage2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TextureImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage2DEXT(texture: gl_texture; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TextureImage2DEXT_1(texture, target, level, internalformat, width, height, border, format, &type, pixels);
    
    private TextureSubImage1DEXT_adr := GetProcAddress('glTextureSubImage1DEXT');
    private ntv_TextureSubImage1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; width: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TextureSubImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage1DEXT(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; width: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TextureSubImage1DEXT_1(texture, target, level, xoffset, width, format, &type, pixels);
    
    private TextureSubImage2DEXT_adr := GetProcAddress('glTextureSubImage2DEXT');
    private ntv_TextureSubImage2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TextureSubImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage2DEXT(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TextureSubImage2DEXT_1(texture, target, level, xoffset, yoffset, width, height, format, &type, pixels);
    
    private CopyTextureImage1DEXT_adr := GetProcAddress('glCopyTextureImage1DEXT');
    private ntv_CopyTextureImage1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; border: Int32)>(CopyTextureImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureImage1DEXT(texture: gl_texture; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; border: Int32) :=
      ntv_CopyTextureImage1DEXT_1(texture, target, level, internalformat, x, y, width, border);
    
    private CopyTextureImage2DEXT_adr := GetProcAddress('glCopyTextureImage2DEXT');
    private ntv_CopyTextureImage2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32)>(CopyTextureImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureImage2DEXT(texture: gl_texture; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32) :=
      ntv_CopyTextureImage2DEXT_1(texture, target, level, internalformat, x, y, width, height, border);
    
    private CopyTextureSubImage1DEXT_adr := GetProcAddress('glCopyTextureSubImage1DEXT');
    private ntv_CopyTextureSubImage1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32)>(CopyTextureSubImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage1DEXT(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) :=
      ntv_CopyTextureSubImage1DEXT_1(texture, target, level, xoffset, x, y, width);
    
    private CopyTextureSubImage2DEXT_adr := GetProcAddress('glCopyTextureSubImage2DEXT');
    private ntv_CopyTextureSubImage2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(CopyTextureSubImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage2DEXT(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_CopyTextureSubImage2DEXT_1(texture, target, level, xoffset, yoffset, x, y, width, height);
    
    private GetTextureImageEXT_adr := GetProcAddress('glGetTextureImageEXT');
    private ntv_GetTextureImageEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(GetTextureImageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureImageEXT(texture: gl_texture; target: glTextureTarget; level: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_GetTextureImageEXT_1(texture, target, level, format, &type, pixels);
    
    private GetTextureParameterfvEXT_adr := GetProcAddress('glGetTextureParameterfvEXT');
    private ntv_GetTextureParameterfvEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glGetTextureParameter; var &params: single)>(GetTextureParameterfvEXT_adr);
    private ntv_GetTextureParameterfvEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterfvEXT(texture: gl_texture; target: glTextureTarget; pname: glGetTextureParameter; var &params: single) :=
      ntv_GetTextureParameterfvEXT_1(texture, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterfvEXT(texture: gl_texture; target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureParameterfvEXT_2(texture, target, pname, &params);
    
    private GetTextureParameterivEXT_adr := GetProcAddress('glGetTextureParameterivEXT');
    private ntv_GetTextureParameterivEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glGetTextureParameter; var &params: Int32)>(GetTextureParameterivEXT_adr);
    private ntv_GetTextureParameterivEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterivEXT(texture: gl_texture; target: glTextureTarget; pname: glGetTextureParameter; var &params: Int32) :=
      ntv_GetTextureParameterivEXT_1(texture, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterivEXT(texture: gl_texture; target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureParameterivEXT_2(texture, target, pname, &params);
    
    private GetTextureLevelParameterfvEXT_adr := GetProcAddress('glGetTextureLevelParameterfvEXT');
    private ntv_GetTextureLevelParameterfvEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; pname: glGetTextureParameter; var &params: single)>(GetTextureLevelParameterfvEXT_adr);
    private ntv_GetTextureLevelParameterfvEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureLevelParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterfvEXT(texture: gl_texture; target: glTextureTarget; level: Int32; pname: glGetTextureParameter; var &params: single) :=
      ntv_GetTextureLevelParameterfvEXT_1(texture, target, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterfvEXT(texture: gl_texture; target: glTextureTarget; level: Int32; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureLevelParameterfvEXT_2(texture, target, level, pname, &params);
    
    private GetTextureLevelParameterivEXT_adr := GetProcAddress('glGetTextureLevelParameterivEXT');
    private ntv_GetTextureLevelParameterivEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; pname: glGetTextureParameter; var &params: Int32)>(GetTextureLevelParameterivEXT_adr);
    private ntv_GetTextureLevelParameterivEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureLevelParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterivEXT(texture: gl_texture; target: glTextureTarget; level: Int32; pname: glGetTextureParameter; var &params: Int32) :=
      ntv_GetTextureLevelParameterivEXT_1(texture, target, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterivEXT(texture: gl_texture; target: glTextureTarget; level: Int32; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureLevelParameterivEXT_2(texture, target, level, pname, &params);
    
    private TextureImage3DEXT_adr := GetProcAddress('glTextureImage3DEXT');
    private ntv_TextureImage3DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TextureImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage3DEXT(texture: gl_texture; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TextureImage3DEXT_1(texture, target, level, internalformat, width, height, depth, border, format, &type, pixels);
    
    private TextureSubImage3DEXT_adr := GetProcAddress('glTextureSubImage3DEXT');
    private ntv_TextureSubImage3DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TextureSubImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage3DEXT(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TextureSubImage3DEXT_1(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
    private CopyTextureSubImage3DEXT_adr := GetProcAddress('glCopyTextureSubImage3DEXT');
    private ntv_CopyTextureSubImage3DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(CopyTextureSubImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage3DEXT(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_CopyTextureSubImage3DEXT_1(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
    
    private BindMultiTextureEXT_adr := GetProcAddress('glBindMultiTextureEXT');
    private ntv_BindMultiTextureEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; texture: gl_texture)>(BindMultiTextureEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindMultiTextureEXT(texunit: glTextureUnit; target: glTextureTarget; texture: gl_texture) :=
      ntv_BindMultiTextureEXT_1(texunit, target, texture);
    
    private MultiTexCoordPointerEXT_adr := GetProcAddress('glMultiTexCoordPointerEXT');
    private ntv_MultiTexCoordPointerEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; size: Int32; &type: glTexCoordPointerType; stride: Int32; pointer: IntPtr)>(MultiTexCoordPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordPointerEXT(texunit: glTextureUnit; size: Int32; &type: glTexCoordPointerType; stride: Int32; pointer: IntPtr) :=
      ntv_MultiTexCoordPointerEXT_1(texunit, size, &type, stride, pointer);
    
    private MultiTexEnvfEXT_adr := GetProcAddress('glMultiTexEnvfEXT');
    private ntv_MultiTexEnvfEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; param: single)>(MultiTexEnvfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvfEXT(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; param: single) :=
      ntv_MultiTexEnvfEXT_1(texunit, target, pname, param);
    
    private MultiTexEnvfvEXT_adr := GetProcAddress('glMultiTexEnvfvEXT');
    private ntv_MultiTexEnvfvEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: single)>(MultiTexEnvfvEXT_adr);
    private ntv_MultiTexEnvfvEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr)>(MultiTexEnvfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvfvEXT(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_MultiTexEnvfvEXT_1(texunit, target, pname, &params[0]) else
        ntv_MultiTexEnvfvEXT_1(texunit, target, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvfvEXT(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: single) :=
      ntv_MultiTexEnvfvEXT_1(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvfvEXT(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr) :=
      ntv_MultiTexEnvfvEXT_2(texunit, target, pname, &params);
    
    private MultiTexEnviEXT_adr := GetProcAddress('glMultiTexEnviEXT');
    private ntv_MultiTexEnviEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; param: Int32)>(MultiTexEnviEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnviEXT(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; param: Int32) :=
      ntv_MultiTexEnviEXT_1(texunit, target, pname, param);
    
    private MultiTexEnvivEXT_adr := GetProcAddress('glMultiTexEnvivEXT');
    private ntv_MultiTexEnvivEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: Int32)>(MultiTexEnvivEXT_adr);
    private ntv_MultiTexEnvivEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr)>(MultiTexEnvivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvivEXT(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_MultiTexEnvivEXT_1(texunit, target, pname, &params[0]) else
        ntv_MultiTexEnvivEXT_1(texunit, target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvivEXT(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: Int32) :=
      ntv_MultiTexEnvivEXT_1(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvivEXT(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr) :=
      ntv_MultiTexEnvivEXT_2(texunit, target, pname, &params);
    
    private MultiTexGendEXT_adr := GetProcAddress('glMultiTexGendEXT');
    private ntv_MultiTexGendEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; param: double)>(MultiTexGendEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGendEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; param: double) :=
      ntv_MultiTexGendEXT_1(texunit, coord, pname, param);
    
    private MultiTexGendvEXT_adr := GetProcAddress('glMultiTexGendvEXT');
    private ntv_MultiTexGendvEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; var &params: double)>(MultiTexGendvEXT_adr);
    private ntv_MultiTexGendvEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr)>(MultiTexGendvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGendvEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; &params: array of double);
    type PDouble = ^double;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_MultiTexGendvEXT_1(texunit, coord, pname, &params[0]) else
        ntv_MultiTexGendvEXT_1(texunit, coord, pname, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGendvEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; var &params: double) :=
      ntv_MultiTexGendvEXT_1(texunit, coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGendvEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr) :=
      ntv_MultiTexGendvEXT_2(texunit, coord, pname, &params);
    
    private MultiTexGenfEXT_adr := GetProcAddress('glMultiTexGenfEXT');
    private ntv_MultiTexGenfEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; param: single)>(MultiTexGenfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenfEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; param: single) :=
      ntv_MultiTexGenfEXT_1(texunit, coord, pname, param);
    
    private MultiTexGenfvEXT_adr := GetProcAddress('glMultiTexGenfvEXT');
    private ntv_MultiTexGenfvEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; var &params: single)>(MultiTexGenfvEXT_adr);
    private ntv_MultiTexGenfvEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr)>(MultiTexGenfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenfvEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_MultiTexGenfvEXT_1(texunit, coord, pname, &params[0]) else
        ntv_MultiTexGenfvEXT_1(texunit, coord, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenfvEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; var &params: single) :=
      ntv_MultiTexGenfvEXT_1(texunit, coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenfvEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr) :=
      ntv_MultiTexGenfvEXT_2(texunit, coord, pname, &params);
    
    private MultiTexGeniEXT_adr := GetProcAddress('glMultiTexGeniEXT');
    private ntv_MultiTexGeniEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; param: Int32)>(MultiTexGeniEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGeniEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; param: Int32) :=
      ntv_MultiTexGeniEXT_1(texunit, coord, pname, param);
    
    private MultiTexGenivEXT_adr := GetProcAddress('glMultiTexGenivEXT');
    private ntv_MultiTexGenivEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; var &params: Int32)>(MultiTexGenivEXT_adr);
    private ntv_MultiTexGenivEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr)>(MultiTexGenivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenivEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_MultiTexGenivEXT_1(texunit, coord, pname, &params[0]) else
        ntv_MultiTexGenivEXT_1(texunit, coord, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenivEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; var &params: Int32) :=
      ntv_MultiTexGenivEXT_1(texunit, coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenivEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr) :=
      ntv_MultiTexGenivEXT_2(texunit, coord, pname, &params);
    
    private GetMultiTexEnvfvEXT_adr := GetProcAddress('glGetMultiTexEnvfvEXT');
    private ntv_GetMultiTexEnvfvEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: single)>(GetMultiTexEnvfvEXT_adr);
    private ntv_GetMultiTexEnvfvEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr)>(GetMultiTexEnvfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvfvEXT(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: single) :=
      ntv_GetMultiTexEnvfvEXT_1(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvfvEXT(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr) :=
      ntv_GetMultiTexEnvfvEXT_2(texunit, target, pname, &params);
    
    private GetMultiTexEnvivEXT_adr := GetProcAddress('glGetMultiTexEnvivEXT');
    private ntv_GetMultiTexEnvivEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: Int32)>(GetMultiTexEnvivEXT_adr);
    private ntv_GetMultiTexEnvivEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr)>(GetMultiTexEnvivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvivEXT(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: Int32) :=
      ntv_GetMultiTexEnvivEXT_1(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvivEXT(texunit: glTextureUnit; target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr) :=
      ntv_GetMultiTexEnvivEXT_2(texunit, target, pname, &params);
    
    private GetMultiTexGendvEXT_adr := GetProcAddress('glGetMultiTexGendvEXT');
    private ntv_GetMultiTexGendvEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; var &params: double)>(GetMultiTexGendvEXT_adr);
    private ntv_GetMultiTexGendvEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr)>(GetMultiTexGendvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGendvEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; var &params: double) :=
      ntv_GetMultiTexGendvEXT_1(texunit, coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGendvEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr) :=
      ntv_GetMultiTexGendvEXT_2(texunit, coord, pname, &params);
    
    private GetMultiTexGenfvEXT_adr := GetProcAddress('glGetMultiTexGenfvEXT');
    private ntv_GetMultiTexGenfvEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; var &params: single)>(GetMultiTexGenfvEXT_adr);
    private ntv_GetMultiTexGenfvEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr)>(GetMultiTexGenfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenfvEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; var &params: single) :=
      ntv_GetMultiTexGenfvEXT_1(texunit, coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenfvEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr) :=
      ntv_GetMultiTexGenfvEXT_2(texunit, coord, pname, &params);
    
    private GetMultiTexGenivEXT_adr := GetProcAddress('glGetMultiTexGenivEXT');
    private ntv_GetMultiTexGenivEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; var &params: Int32)>(GetMultiTexGenivEXT_adr);
    private ntv_GetMultiTexGenivEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr)>(GetMultiTexGenivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenivEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; var &params: Int32) :=
      ntv_GetMultiTexGenivEXT_1(texunit, coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenivEXT(texunit: glTextureUnit; coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr) :=
      ntv_GetMultiTexGenivEXT_2(texunit, coord, pname, &params);
    
    private MultiTexParameteriEXT_adr := GetProcAddress('glMultiTexParameteriEXT');
    private ntv_MultiTexParameteriEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; param: Int32)>(MultiTexParameteriEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameteriEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; param: Int32) :=
      ntv_MultiTexParameteriEXT_1(texunit, target, pname, param);
    
    private MultiTexParameterivEXT_adr := GetProcAddress('glMultiTexParameterivEXT');
    private ntv_MultiTexParameterivEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; var &params: Int32)>(MultiTexParameterivEXT_adr);
    private ntv_MultiTexParameterivEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr)>(MultiTexParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterivEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_MultiTexParameterivEXT_1(texunit, target, pname, &params[0]) else
        ntv_MultiTexParameterivEXT_1(texunit, target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterivEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; var &params: Int32) :=
      ntv_MultiTexParameterivEXT_1(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterivEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_MultiTexParameterivEXT_2(texunit, target, pname, &params);
    
    private MultiTexParameterfEXT_adr := GetProcAddress('glMultiTexParameterfEXT');
    private ntv_MultiTexParameterfEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; param: single)>(MultiTexParameterfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterfEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; param: single) :=
      ntv_MultiTexParameterfEXT_1(texunit, target, pname, param);
    
    private MultiTexParameterfvEXT_adr := GetProcAddress('glMultiTexParameterfvEXT');
    private ntv_MultiTexParameterfvEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; var &params: single)>(MultiTexParameterfvEXT_adr);
    private ntv_MultiTexParameterfvEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr)>(MultiTexParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterfvEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_MultiTexParameterfvEXT_1(texunit, target, pname, &params[0]) else
        ntv_MultiTexParameterfvEXT_1(texunit, target, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterfvEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; var &params: single) :=
      ntv_MultiTexParameterfvEXT_1(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterfvEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_MultiTexParameterfvEXT_2(texunit, target, pname, &params);
    
    private MultiTexImage1DEXT_adr := GetProcAddress('glMultiTexImage1DEXT');
    private ntv_MultiTexImage1DEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(MultiTexImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexImage1DEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_MultiTexImage1DEXT_1(texunit, target, level, internalformat, width, border, format, &type, pixels);
    
    private MultiTexImage2DEXT_adr := GetProcAddress('glMultiTexImage2DEXT');
    private ntv_MultiTexImage2DEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(MultiTexImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexImage2DEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_MultiTexImage2DEXT_1(texunit, target, level, internalformat, width, height, border, format, &type, pixels);
    
    private MultiTexSubImage1DEXT_adr := GetProcAddress('glMultiTexSubImage1DEXT');
    private ntv_MultiTexSubImage1DEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; width: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(MultiTexSubImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexSubImage1DEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; width: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_MultiTexSubImage1DEXT_1(texunit, target, level, xoffset, width, format, &type, pixels);
    
    private MultiTexSubImage2DEXT_adr := GetProcAddress('glMultiTexSubImage2DEXT');
    private ntv_MultiTexSubImage2DEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(MultiTexSubImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexSubImage2DEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_MultiTexSubImage2DEXT_1(texunit, target, level, xoffset, yoffset, width, height, format, &type, pixels);
    
    private CopyMultiTexImage1DEXT_adr := GetProcAddress('glCopyMultiTexImage1DEXT');
    private ntv_CopyMultiTexImage1DEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; border: Int32)>(CopyMultiTexImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexImage1DEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; border: Int32) :=
      ntv_CopyMultiTexImage1DEXT_1(texunit, target, level, internalformat, x, y, width, border);
    
    private CopyMultiTexImage2DEXT_adr := GetProcAddress('glCopyMultiTexImage2DEXT');
    private ntv_CopyMultiTexImage2DEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32)>(CopyMultiTexImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexImage2DEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32) :=
      ntv_CopyMultiTexImage2DEXT_1(texunit, target, level, internalformat, x, y, width, height, border);
    
    private CopyMultiTexSubImage1DEXT_adr := GetProcAddress('glCopyMultiTexSubImage1DEXT');
    private ntv_CopyMultiTexSubImage1DEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32)>(CopyMultiTexSubImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexSubImage1DEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) :=
      ntv_CopyMultiTexSubImage1DEXT_1(texunit, target, level, xoffset, x, y, width);
    
    private CopyMultiTexSubImage2DEXT_adr := GetProcAddress('glCopyMultiTexSubImage2DEXT');
    private ntv_CopyMultiTexSubImage2DEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(CopyMultiTexSubImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexSubImage2DEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_CopyMultiTexSubImage2DEXT_1(texunit, target, level, xoffset, yoffset, x, y, width, height);
    
    private GetMultiTexImageEXT_adr := GetProcAddress('glGetMultiTexImageEXT');
    private ntv_GetMultiTexImageEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(GetMultiTexImageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexImageEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_GetMultiTexImageEXT_1(texunit, target, level, format, &type, pixels);
    
    private GetMultiTexParameterfvEXT_adr := GetProcAddress('glGetMultiTexParameterfvEXT');
    private ntv_GetMultiTexParameterfvEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glGetTextureParameter; var &params: single)>(GetMultiTexParameterfvEXT_adr);
    private ntv_GetMultiTexParameterfvEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr)>(GetMultiTexParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterfvEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glGetTextureParameter; var &params: single) :=
      ntv_GetMultiTexParameterfvEXT_1(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterfvEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetMultiTexParameterfvEXT_2(texunit, target, pname, &params);
    
    private GetMultiTexParameterivEXT_adr := GetProcAddress('glGetMultiTexParameterivEXT');
    private ntv_GetMultiTexParameterivEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glGetTextureParameter; var &params: Int32)>(GetMultiTexParameterivEXT_adr);
    private ntv_GetMultiTexParameterivEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr)>(GetMultiTexParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterivEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glGetTextureParameter; var &params: Int32) :=
      ntv_GetMultiTexParameterivEXT_1(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterivEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetMultiTexParameterivEXT_2(texunit, target, pname, &params);
    
    private GetMultiTexLevelParameterfvEXT_adr := GetProcAddress('glGetMultiTexLevelParameterfvEXT');
    private ntv_GetMultiTexLevelParameterfvEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; pname: glGetTextureParameter; var &params: single)>(GetMultiTexLevelParameterfvEXT_adr);
    private ntv_GetMultiTexLevelParameterfvEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; pname: glGetTextureParameter; &params: IntPtr)>(GetMultiTexLevelParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterfvEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; pname: glGetTextureParameter; var &params: single) :=
      ntv_GetMultiTexLevelParameterfvEXT_1(texunit, target, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterfvEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetMultiTexLevelParameterfvEXT_2(texunit, target, level, pname, &params);
    
    private GetMultiTexLevelParameterivEXT_adr := GetProcAddress('glGetMultiTexLevelParameterivEXT');
    private ntv_GetMultiTexLevelParameterivEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; pname: glGetTextureParameter; var &params: Int32)>(GetMultiTexLevelParameterivEXT_adr);
    private ntv_GetMultiTexLevelParameterivEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; pname: glGetTextureParameter; &params: IntPtr)>(GetMultiTexLevelParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterivEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; pname: glGetTextureParameter; var &params: Int32) :=
      ntv_GetMultiTexLevelParameterivEXT_1(texunit, target, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterivEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetMultiTexLevelParameterivEXT_2(texunit, target, level, pname, &params);
    
    private MultiTexImage3DEXT_adr := GetProcAddress('glMultiTexImage3DEXT');
    private ntv_MultiTexImage3DEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(MultiTexImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexImage3DEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_MultiTexImage3DEXT_1(texunit, target, level, internalformat, width, height, depth, border, format, &type, pixels);
    
    private MultiTexSubImage3DEXT_adr := GetProcAddress('glMultiTexSubImage3DEXT');
    private ntv_MultiTexSubImage3DEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(MultiTexSubImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexSubImage3DEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_MultiTexSubImage3DEXT_1(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
    private CopyMultiTexSubImage3DEXT_adr := GetProcAddress('glCopyMultiTexSubImage3DEXT');
    private ntv_CopyMultiTexSubImage3DEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(CopyMultiTexSubImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexSubImage3DEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_CopyMultiTexSubImage3DEXT_1(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
    
    private EnableClientStateIndexedEXT_adr := GetProcAddress('glEnableClientStateIndexedEXT');
    private ntv_EnableClientStateIndexedEXT_1 := GetProcOrNil&<procedure(&array: glEnableCap; index: UInt32)>(EnableClientStateIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableClientStateIndexedEXT(&array: glEnableCap; index: UInt32) :=
      ntv_EnableClientStateIndexedEXT_1(&array, index);
    
    private DisableClientStateIndexedEXT_adr := GetProcAddress('glDisableClientStateIndexedEXT');
    private ntv_DisableClientStateIndexedEXT_1 := GetProcOrNil&<procedure(&array: glEnableCap; index: UInt32)>(DisableClientStateIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableClientStateIndexedEXT(&array: glEnableCap; index: UInt32) :=
      ntv_DisableClientStateIndexedEXT_1(&array, index);
    
    private GetFloatIndexedvEXT_adr := GetProcAddress('glGetFloatIndexedvEXT');
    private ntv_GetFloatIndexedvEXT_1 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; var data: single)>(GetFloatIndexedvEXT_adr);
    private ntv_GetFloatIndexedvEXT_2 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; data: IntPtr)>(GetFloatIndexedvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloatIndexedvEXT(target: glGetPName; index: UInt32; var data: single) :=
      ntv_GetFloatIndexedvEXT_1(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloatIndexedvEXT(target: glGetPName; index: UInt32; data: IntPtr) :=
      ntv_GetFloatIndexedvEXT_2(target, index, data);
    
    private GetDoubleIndexedvEXT_adr := GetProcAddress('glGetDoubleIndexedvEXT');
    private ntv_GetDoubleIndexedvEXT_1 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; var data: double)>(GetDoubleIndexedvEXT_adr);
    private ntv_GetDoubleIndexedvEXT_2 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; data: IntPtr)>(GetDoubleIndexedvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoubleIndexedvEXT(target: glGetPName; index: UInt32; var data: double) :=
      ntv_GetDoubleIndexedvEXT_1(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoubleIndexedvEXT(target: glGetPName; index: UInt32; data: IntPtr) :=
      ntv_GetDoubleIndexedvEXT_2(target, index, data);
    
    private GetPointerIndexedvEXT_adr := GetProcAddress('glGetPointerIndexedvEXT');
    private ntv_GetPointerIndexedvEXT_1 := GetProcOrNil&<procedure(target: DummyEnum; index: UInt32; var data: IntPtr)>(GetPointerIndexedvEXT_adr);
    private ntv_GetPointerIndexedvEXT_2 := GetProcOrNil&<procedure(target: DummyEnum; index: UInt32; data: pointer)>(GetPointerIndexedvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerIndexedvEXT(target: DummyEnum; index: UInt32; var data: IntPtr) :=
      ntv_GetPointerIndexedvEXT_1(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerIndexedvEXT(target: DummyEnum; index: UInt32; data: pointer) :=
      ntv_GetPointerIndexedvEXT_2(target, index, data);
    
    private EnableIndexedEXT_adr := GetProcAddress('glEnableIndexedEXT');
    private ntv_EnableIndexedEXT_1 := GetProcOrNil&<procedure(target: glEnableCap; index: UInt32)>(EnableIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableIndexedEXT(target: glEnableCap; index: UInt32) :=
      ntv_EnableIndexedEXT_1(target, index);
    
    private DisableIndexedEXT_adr := GetProcAddress('glDisableIndexedEXT');
    private ntv_DisableIndexedEXT_1 := GetProcOrNil&<procedure(target: glEnableCap; index: UInt32)>(DisableIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableIndexedEXT(target: glEnableCap; index: UInt32) :=
      ntv_DisableIndexedEXT_1(target, index);
    
    private IsEnabledIndexedEXT_adr := GetProcAddress('glIsEnabledIndexedEXT');
    private ntv_IsEnabledIndexedEXT_1 := GetProcOrNil&<function(target: glEnableCap; index: UInt32): glBool8>(IsEnabledIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledIndexedEXT(target: glEnableCap; index: UInt32): glBool8 :=
      ntv_IsEnabledIndexedEXT_1(target, index);
    
    private GetIntegerIndexedvEXT_adr := GetProcAddress('glGetIntegerIndexedvEXT');
    private ntv_GetIntegerIndexedvEXT_1 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; var data: Int32)>(GetIntegerIndexedvEXT_adr);
    private ntv_GetIntegerIndexedvEXT_2 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; data: IntPtr)>(GetIntegerIndexedvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerIndexedvEXT(target: glGetPName; index: UInt32; var data: Int32) :=
      ntv_GetIntegerIndexedvEXT_1(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerIndexedvEXT(target: glGetPName; index: UInt32; data: IntPtr) :=
      ntv_GetIntegerIndexedvEXT_2(target, index, data);
    
    private GetBooleanIndexedvEXT_adr := GetProcAddress('glGetBooleanIndexedvEXT');
    private ntv_GetBooleanIndexedvEXT_1 := GetProcOrNil&<procedure(target: glBufferTarget; index: UInt32; var data: glBool8)>(GetBooleanIndexedvEXT_adr);
    private ntv_GetBooleanIndexedvEXT_2 := GetProcOrNil&<procedure(target: glBufferTarget; index: UInt32; data: IntPtr)>(GetBooleanIndexedvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanIndexedvEXT(target: glBufferTarget; index: UInt32; var data: glBool8) :=
      ntv_GetBooleanIndexedvEXT_1(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanIndexedvEXT(target: glBufferTarget; index: UInt32; data: IntPtr) :=
      ntv_GetBooleanIndexedvEXT_2(target, index, data);
    
    private CompressedTextureImage3DEXT_adr := GetProcAddress('glCompressedTextureImage3DEXT');
    private ntv_CompressedTextureImage3DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: IntPtr)>(CompressedTextureImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureImage3DEXT(texture: gl_texture; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: IntPtr) :=
      ntv_CompressedTextureImage3DEXT_1(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
    
    private CompressedTextureImage2DEXT_adr := GetProcAddress('glCompressedTextureImage2DEXT');
    private ntv_CompressedTextureImage2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: IntPtr)>(CompressedTextureImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureImage2DEXT(texture: gl_texture; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: IntPtr) :=
      ntv_CompressedTextureImage2DEXT_1(texture, target, level, internalformat, width, height, border, imageSize, bits);
    
    private CompressedTextureImage1DEXT_adr := GetProcAddress('glCompressedTextureImage1DEXT');
    private ntv_CompressedTextureImage1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; border: Int32; imageSize: Int32; bits: IntPtr)>(CompressedTextureImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureImage1DEXT(texture: gl_texture; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; border: Int32; imageSize: Int32; bits: IntPtr) :=
      ntv_CompressedTextureImage1DEXT_1(texture, target, level, internalformat, width, border, imageSize, bits);
    
    private CompressedTextureSubImage3DEXT_adr := GetProcAddress('glCompressedTextureSubImage3DEXT');
    private ntv_CompressedTextureSubImage3DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glInternalFormat; imageSize: Int32; bits: IntPtr)>(CompressedTextureSubImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage3DEXT(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glInternalFormat; imageSize: Int32; bits: IntPtr) :=
      ntv_CompressedTextureSubImage3DEXT_1(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
    
    private CompressedTextureSubImage2DEXT_adr := GetProcAddress('glCompressedTextureSubImage2DEXT');
    private ntv_CompressedTextureSubImage2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glInternalFormat; imageSize: Int32; bits: IntPtr)>(CompressedTextureSubImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage2DEXT(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glInternalFormat; imageSize: Int32; bits: IntPtr) :=
      ntv_CompressedTextureSubImage2DEXT_1(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
    
    private CompressedTextureSubImage1DEXT_adr := GetProcAddress('glCompressedTextureSubImage1DEXT');
    private ntv_CompressedTextureSubImage1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; width: Int32; format: glInternalFormat; imageSize: Int32; bits: IntPtr)>(CompressedTextureSubImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage1DEXT(texture: gl_texture; target: glTextureTarget; level: Int32; xoffset: Int32; width: Int32; format: glInternalFormat; imageSize: Int32; bits: IntPtr) :=
      ntv_CompressedTextureSubImage1DEXT_1(texture, target, level, xoffset, width, format, imageSize, bits);
    
    private GetCompressedTextureImageEXT_adr := GetProcAddress('glGetCompressedTextureImageEXT');
    private ntv_GetCompressedTextureImageEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; lod: Int32; img: IntPtr)>(GetCompressedTextureImageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureImageEXT(texture: gl_texture; target: glTextureTarget; lod: Int32; img: IntPtr) :=
      ntv_GetCompressedTextureImageEXT_1(texture, target, lod, img);
    
    private CompressedMultiTexImage3DEXT_adr := GetProcAddress('glCompressedMultiTexImage3DEXT');
    private ntv_CompressedMultiTexImage3DEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: IntPtr)>(CompressedMultiTexImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexImage3DEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: IntPtr) :=
      ntv_CompressedMultiTexImage3DEXT_1(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
    
    private CompressedMultiTexImage2DEXT_adr := GetProcAddress('glCompressedMultiTexImage2DEXT');
    private ntv_CompressedMultiTexImage2DEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: IntPtr)>(CompressedMultiTexImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexImage2DEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: IntPtr) :=
      ntv_CompressedMultiTexImage2DEXT_1(texunit, target, level, internalformat, width, height, border, imageSize, bits);
    
    private CompressedMultiTexImage1DEXT_adr := GetProcAddress('glCompressedMultiTexImage1DEXT');
    private ntv_CompressedMultiTexImage1DEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; border: Int32; imageSize: Int32; bits: IntPtr)>(CompressedMultiTexImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexImage1DEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; border: Int32; imageSize: Int32; bits: IntPtr) :=
      ntv_CompressedMultiTexImage1DEXT_1(texunit, target, level, internalformat, width, border, imageSize, bits);
    
    private CompressedMultiTexSubImage3DEXT_adr := GetProcAddress('glCompressedMultiTexSubImage3DEXT');
    private ntv_CompressedMultiTexSubImage3DEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glInternalFormat; imageSize: Int32; bits: IntPtr)>(CompressedMultiTexSubImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexSubImage3DEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glInternalFormat; imageSize: Int32; bits: IntPtr) :=
      ntv_CompressedMultiTexSubImage3DEXT_1(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
    
    private CompressedMultiTexSubImage2DEXT_adr := GetProcAddress('glCompressedMultiTexSubImage2DEXT');
    private ntv_CompressedMultiTexSubImage2DEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glInternalFormat; imageSize: Int32; bits: IntPtr)>(CompressedMultiTexSubImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexSubImage2DEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glInternalFormat; imageSize: Int32; bits: IntPtr) :=
      ntv_CompressedMultiTexSubImage2DEXT_1(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
    
    private CompressedMultiTexSubImage1DEXT_adr := GetProcAddress('glCompressedMultiTexSubImage1DEXT');
    private ntv_CompressedMultiTexSubImage1DEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; width: Int32; format: glInternalFormat; imageSize: Int32; bits: IntPtr)>(CompressedMultiTexSubImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexSubImage1DEXT(texunit: glTextureUnit; target: glTextureTarget; level: Int32; xoffset: Int32; width: Int32; format: glInternalFormat; imageSize: Int32; bits: IntPtr) :=
      ntv_CompressedMultiTexSubImage1DEXT_1(texunit, target, level, xoffset, width, format, imageSize, bits);
    
    private GetCompressedMultiTexImageEXT_adr := GetProcAddress('glGetCompressedMultiTexImageEXT');
    private ntv_GetCompressedMultiTexImageEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; lod: Int32; img: IntPtr)>(GetCompressedMultiTexImageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedMultiTexImageEXT(texunit: glTextureUnit; target: glTextureTarget; lod: Int32; img: IntPtr) :=
      ntv_GetCompressedMultiTexImageEXT_1(texunit, target, lod, img);
    
    private MatrixLoadTransposefEXT_adr := GetProcAddress('glMatrixLoadTransposefEXT');
    private ntv_MatrixLoadTransposefEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; var m: single)>(MatrixLoadTransposefEXT_adr);
    private ntv_MatrixLoadTransposefEXT_2 := GetProcOrNil&<procedure(mode: glMatrixMode; m: IntPtr)>(MatrixLoadTransposefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: glMatrixMode; m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixLoadTransposefEXT_1(mode, m[0]) else
        ntv_MatrixLoadTransposefEXT_1(mode, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: glMatrixMode; var m: single) :=
      ntv_MatrixLoadTransposefEXT_1(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: glMatrixMode; m: IntPtr) :=
      ntv_MatrixLoadTransposefEXT_2(mode, m);
    
    private MatrixLoadTransposedEXT_adr := GetProcAddress('glMatrixLoadTransposedEXT');
    private ntv_MatrixLoadTransposedEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; var m: double)>(MatrixLoadTransposedEXT_adr);
    private ntv_MatrixLoadTransposedEXT_2 := GetProcOrNil&<procedure(mode: glMatrixMode; m: IntPtr)>(MatrixLoadTransposedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: glMatrixMode; m: array of double);
    type PDouble = ^double;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixLoadTransposedEXT_1(mode, m[0]) else
        ntv_MatrixLoadTransposedEXT_1(mode, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: glMatrixMode; var m: double) :=
      ntv_MatrixLoadTransposedEXT_1(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: glMatrixMode; m: IntPtr) :=
      ntv_MatrixLoadTransposedEXT_2(mode, m);
    
    private MatrixMultTransposefEXT_adr := GetProcAddress('glMatrixMultTransposefEXT');
    private ntv_MatrixMultTransposefEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; var m: single)>(MatrixMultTransposefEXT_adr);
    private ntv_MatrixMultTransposefEXT_2 := GetProcOrNil&<procedure(mode: glMatrixMode; m: IntPtr)>(MatrixMultTransposefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: glMatrixMode; m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixMultTransposefEXT_1(mode, m[0]) else
        ntv_MatrixMultTransposefEXT_1(mode, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: glMatrixMode; var m: single) :=
      ntv_MatrixMultTransposefEXT_1(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: glMatrixMode; m: IntPtr) :=
      ntv_MatrixMultTransposefEXT_2(mode, m);
    
    private MatrixMultTransposedEXT_adr := GetProcAddress('glMatrixMultTransposedEXT');
    private ntv_MatrixMultTransposedEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; var m: double)>(MatrixMultTransposedEXT_adr);
    private ntv_MatrixMultTransposedEXT_2 := GetProcOrNil&<procedure(mode: glMatrixMode; m: IntPtr)>(MatrixMultTransposedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: glMatrixMode; m: array of double);
    type PDouble = ^double;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixMultTransposedEXT_1(mode, m[0]) else
        ntv_MatrixMultTransposedEXT_1(mode, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: glMatrixMode; var m: double) :=
      ntv_MatrixMultTransposedEXT_1(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: glMatrixMode; m: IntPtr) :=
      ntv_MatrixMultTransposedEXT_2(mode, m);
    
    private NamedBufferDataEXT_adr := GetProcAddress('glNamedBufferDataEXT');
    private ntv_NamedBufferDataEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; var data: Byte; usage: glVertexBufferObjectUsage)>(NamedBufferDataEXT_adr);
    private ntv_NamedBufferDataEXT_2 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; data: IntPtr; usage: glVertexBufferObjectUsage)>(NamedBufferDataEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferDataEXT<T>(buffer: gl_buffer; size: UIntPtr; data: array of T; usage: glVertexBufferObjectUsage); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferDataEXT(buffer, size, data[0], usage) else
        NamedBufferDataEXT(buffer, size, PT(nil)^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferDataEXT<T>(buffer: gl_buffer; size: UIntPtr; var data: T; usage: glVertexBufferObjectUsage); where T: record;
    begin
      ntv_NamedBufferDataEXT_1(buffer, size, PByte(pointer(@data))^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferDataEXT(buffer: gl_buffer; size: UIntPtr; data: IntPtr; usage: glVertexBufferObjectUsage) :=
      ntv_NamedBufferDataEXT_2(buffer, size, data, usage);
    
    private NamedBufferSubDataEXT_adr := GetProcAddress('glNamedBufferSubDataEXT');
    private ntv_NamedBufferSubDataEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: Byte)>(NamedBufferSubDataEXT_adr);
    private ntv_NamedBufferSubDataEXT_2 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: IntPtr)>(NamedBufferSubDataEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubDataEXT<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferSubDataEXT(buffer, offset, size, data[0]) else
        NamedBufferSubDataEXT(buffer, offset, size, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubDataEXT<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      ntv_NamedBufferSubDataEXT_1(buffer, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubDataEXT(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: IntPtr) :=
      ntv_NamedBufferSubDataEXT_2(buffer, offset, size, data);
    
    private MapNamedBufferEXT_adr := GetProcAddress('glMapNamedBufferEXT');
    private ntv_MapNamedBufferEXT_1 := GetProcOrNil&<function(buffer: gl_buffer; access: glBufferAccess): IntPtr>(MapNamedBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapNamedBufferEXT(buffer: gl_buffer; access: glBufferAccess): IntPtr :=
      ntv_MapNamedBufferEXT_1(buffer, access);
    
    private UnmapNamedBufferEXT_adr := GetProcAddress('glUnmapNamedBufferEXT');
    private ntv_UnmapNamedBufferEXT_1 := GetProcOrNil&<function(buffer: gl_buffer): glBool8>(UnmapNamedBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UnmapNamedBufferEXT(buffer: gl_buffer): glBool8 :=
      ntv_UnmapNamedBufferEXT_1(buffer);
    
    private GetNamedBufferParameterivEXT_adr := GetProcAddress('glGetNamedBufferParameterivEXT');
    private ntv_GetNamedBufferParameterivEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPName; var &params: Int32)>(GetNamedBufferParameterivEXT_adr);
    private ntv_GetNamedBufferParameterivEXT_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPName; &params: IntPtr)>(GetNamedBufferParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameterivEXT(buffer: gl_buffer; pname: glBufferPName; var &params: Int32) :=
      ntv_GetNamedBufferParameterivEXT_1(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameterivEXT(buffer: gl_buffer; pname: glBufferPName; &params: IntPtr) :=
      ntv_GetNamedBufferParameterivEXT_2(buffer, pname, &params);
    
    private GetNamedBufferPointervEXT_adr := GetProcAddress('glGetNamedBufferPointervEXT');
    private ntv_GetNamedBufferPointervEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPointerName; var &params: IntPtr)>(GetNamedBufferPointervEXT_adr);
    private ntv_GetNamedBufferPointervEXT_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPointerName; &params: pointer)>(GetNamedBufferPointervEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointervEXT(buffer: gl_buffer; pname: glBufferPointerName; var &params: IntPtr) :=
      ntv_GetNamedBufferPointervEXT_1(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointervEXT(buffer: gl_buffer; pname: glBufferPointerName; &params: pointer) :=
      ntv_GetNamedBufferPointervEXT_2(buffer, pname, &params);
    
    private GetNamedBufferSubDataEXT_adr := GetProcAddress('glGetNamedBufferSubDataEXT');
    private ntv_GetNamedBufferSubDataEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: Byte)>(GetNamedBufferSubDataEXT_adr);
    private ntv_GetNamedBufferSubDataEXT_2 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer)>(GetNamedBufferSubDataEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubDataEXT<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        GetNamedBufferSubDataEXT(buffer, offset, size, data[0]) else
        GetNamedBufferSubDataEXT(buffer, offset, size, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubDataEXT<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      ntv_GetNamedBufferSubDataEXT_1(buffer, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubDataEXT(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer) :=
      ntv_GetNamedBufferSubDataEXT_2(buffer, offset, size, data);
    
    private ProgramUniform1fEXT_adr := GetProcAddress('glProgramUniform1fEXT');
    private ntv_ProgramUniform1fEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single)>(ProgramUniform1fEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fEXT(&program: gl_program; location: Int32; v0: single) :=
      ntv_ProgramUniform1fEXT_1(&program, location, v0);
    
    private ProgramUniform2fEXT_adr := GetProcAddress('glProgramUniform2fEXT');
    private ntv_ProgramUniform2fEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single)>(ProgramUniform2fEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fEXT(&program: gl_program; location: Int32; v0: single; v1: single) :=
      ntv_ProgramUniform2fEXT_1(&program, location, v0, v1);
    
    private ProgramUniform3fEXT_adr := GetProcAddress('glProgramUniform3fEXT');
    private ntv_ProgramUniform3fEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single; v2: single)>(ProgramUniform3fEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fEXT(&program: gl_program; location: Int32; v0: single; v1: single; v2: single) :=
      ntv_ProgramUniform3fEXT_1(&program, location, v0, v1, v2);
    
    private ProgramUniform4fEXT_adr := GetProcAddress('glProgramUniform4fEXT');
    private ntv_ProgramUniform4fEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single; v2: single; v3: single)>(ProgramUniform4fEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fEXT(&program: gl_program; location: Int32; v0: single; v1: single; v2: single; v3: single) :=
      ntv_ProgramUniform4fEXT_1(&program, location, v0, v1, v2, v3);
    
    private ProgramUniform1iEXT_adr := GetProcAddress('glProgramUniform1iEXT');
    private ntv_ProgramUniform1iEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32)>(ProgramUniform1iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iEXT(&program: gl_program; location: Int32; v0: Int32) :=
      ntv_ProgramUniform1iEXT_1(&program, location, v0);
    
    private ProgramUniform2iEXT_adr := GetProcAddress('glProgramUniform2iEXT');
    private ntv_ProgramUniform2iEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32)>(ProgramUniform2iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iEXT(&program: gl_program; location: Int32; v0: Int32; v1: Int32) :=
      ntv_ProgramUniform2iEXT_1(&program, location, v0, v1);
    
    private ProgramUniform3iEXT_adr := GetProcAddress('glProgramUniform3iEXT');
    private ntv_ProgramUniform3iEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32)>(ProgramUniform3iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iEXT(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32) :=
      ntv_ProgramUniform3iEXT_1(&program, location, v0, v1, v2);
    
    private ProgramUniform4iEXT_adr := GetProcAddress('glProgramUniform4iEXT');
    private ntv_ProgramUniform4iEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32)>(ProgramUniform4iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iEXT(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32) :=
      ntv_ProgramUniform4iEXT_1(&program, location, v0, v1, v2, v3);
    
    private ProgramUniform1fvEXT_adr := GetProcAddress('glProgramUniform1fvEXT');
    private ntv_ProgramUniform1fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(ProgramUniform1fvEXT_adr);
    private ntv_ProgramUniform1fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fvEXT(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1fvEXT_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1fvEXT_1(&program, location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fvEXT(&program: gl_program; location: Int32; count: Int32; var value: single) :=
      ntv_ProgramUniform1fvEXT_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fvEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1fvEXT_2(&program, location, count, value);
    
    private ProgramUniform2fvEXT_adr := GetProcAddress('glProgramUniform2fvEXT');
    private ntv_ProgramUniform2fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(ProgramUniform2fvEXT_adr);
    private ntv_ProgramUniform2fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2f)>(ProgramUniform2fvEXT_adr);
    private ntv_ProgramUniform2fvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fvEXT(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2fvEXT_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2fvEXT_1(&program, location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fvEXT(&program: gl_program; location: Int32; count: Int32; var value: Vec2f) :=
      ntv_ProgramUniform2fvEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fvEXT(&program: gl_program; location: Int32; count: Int32; var value: single) :=
      ntv_ProgramUniform2fvEXT_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fvEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2fvEXT_3(&program, location, count, value);
    
    private ProgramUniform3fvEXT_adr := GetProcAddress('glProgramUniform3fvEXT');
    private ntv_ProgramUniform3fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(ProgramUniform3fvEXT_adr);
    private ntv_ProgramUniform3fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3f)>(ProgramUniform3fvEXT_adr);
    private ntv_ProgramUniform3fvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fvEXT(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3fvEXT_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3fvEXT_1(&program, location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fvEXT(&program: gl_program; location: Int32; count: Int32; var value: Vec3f) :=
      ntv_ProgramUniform3fvEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fvEXT(&program: gl_program; location: Int32; count: Int32; var value: single) :=
      ntv_ProgramUniform3fvEXT_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fvEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3fvEXT_3(&program, location, count, value);
    
    private ProgramUniform4fvEXT_adr := GetProcAddress('glProgramUniform4fvEXT');
    private ntv_ProgramUniform4fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(ProgramUniform4fvEXT_adr);
    private ntv_ProgramUniform4fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4f)>(ProgramUniform4fvEXT_adr);
    private ntv_ProgramUniform4fvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fvEXT(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4fvEXT_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4fvEXT_1(&program, location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fvEXT(&program: gl_program; location: Int32; count: Int32; var value: Vec4f) :=
      ntv_ProgramUniform4fvEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fvEXT(&program: gl_program; location: Int32; count: Int32; var value: single) :=
      ntv_ProgramUniform4fvEXT_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fvEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4fvEXT_3(&program, location, count, value);
    
    private ProgramUniform1ivEXT_adr := GetProcAddress('glProgramUniform1ivEXT');
    private ntv_ProgramUniform1ivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(ProgramUniform1ivEXT_adr);
    private ntv_ProgramUniform1ivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ivEXT(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1ivEXT_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1ivEXT_1(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ivEXT(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
      ntv_ProgramUniform1ivEXT_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ivEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1ivEXT_2(&program, location, count, value);
    
    private ProgramUniform2ivEXT_adr := GetProcAddress('glProgramUniform2ivEXT');
    private ntv_ProgramUniform2ivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(ProgramUniform2ivEXT_adr);
    private ntv_ProgramUniform2ivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2i)>(ProgramUniform2ivEXT_adr);
    private ntv_ProgramUniform2ivEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ivEXT(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2ivEXT_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2ivEXT_1(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ivEXT(&program: gl_program; location: Int32; count: Int32; var value: Vec2i) :=
      ntv_ProgramUniform2ivEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ivEXT(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
      ntv_ProgramUniform2ivEXT_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ivEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2ivEXT_3(&program, location, count, value);
    
    private ProgramUniform3ivEXT_adr := GetProcAddress('glProgramUniform3ivEXT');
    private ntv_ProgramUniform3ivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(ProgramUniform3ivEXT_adr);
    private ntv_ProgramUniform3ivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3i)>(ProgramUniform3ivEXT_adr);
    private ntv_ProgramUniform3ivEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ivEXT(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3ivEXT_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3ivEXT_1(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ivEXT(&program: gl_program; location: Int32; count: Int32; var value: Vec3i) :=
      ntv_ProgramUniform3ivEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ivEXT(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
      ntv_ProgramUniform3ivEXT_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ivEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3ivEXT_3(&program, location, count, value);
    
    private ProgramUniform4ivEXT_adr := GetProcAddress('glProgramUniform4ivEXT');
    private ntv_ProgramUniform4ivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(ProgramUniform4ivEXT_adr);
    private ntv_ProgramUniform4ivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4i)>(ProgramUniform4ivEXT_adr);
    private ntv_ProgramUniform4ivEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ivEXT(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4ivEXT_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4ivEXT_1(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ivEXT(&program: gl_program; location: Int32; count: Int32; var value: Vec4i) :=
      ntv_ProgramUniform4ivEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ivEXT(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
      ntv_ProgramUniform4ivEXT_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ivEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4ivEXT_3(&program, location, count, value);
    
    private ProgramUniformMatrix2fvEXT_adr := GetProcAddress('glProgramUniformMatrix2fvEXT');
    private ntv_ProgramUniformMatrix2fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix2fvEXT_adr);
    private ntv_ProgramUniformMatrix2fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2f)>(ProgramUniformMatrix2fvEXT_adr);
    private ntv_ProgramUniformMatrix2fvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2fvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2fvEXT_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2f) :=
      ntv_ProgramUniformMatrix2fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix2fvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2fvEXT_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix3fvEXT_adr := GetProcAddress('glProgramUniformMatrix3fvEXT');
    private ntv_ProgramUniformMatrix3fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix3fvEXT_adr);
    private ntv_ProgramUniformMatrix3fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3f)>(ProgramUniformMatrix3fvEXT_adr);
    private ntv_ProgramUniformMatrix3fvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3fvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3fvEXT_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3f) :=
      ntv_ProgramUniformMatrix3fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix3fvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3fvEXT_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix4fvEXT_adr := GetProcAddress('glProgramUniformMatrix4fvEXT');
    private ntv_ProgramUniformMatrix4fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix4fvEXT_adr);
    private ntv_ProgramUniformMatrix4fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4f)>(ProgramUniformMatrix4fvEXT_adr);
    private ntv_ProgramUniformMatrix4fvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4fvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4fvEXT_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4f) :=
      ntv_ProgramUniformMatrix4fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix4fvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4fvEXT_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix2x3fvEXT_adr := GetProcAddress('glProgramUniformMatrix2x3fvEXT');
    private ntv_ProgramUniformMatrix2x3fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix2x3fvEXT_adr);
    private ntv_ProgramUniformMatrix2x3fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3f)>(ProgramUniformMatrix2x3fvEXT_adr);
    private ntv_ProgramUniformMatrix2x3fvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2x3fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2x3fvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2x3fvEXT_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3f) :=
      ntv_ProgramUniformMatrix2x3fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix2x3fvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2x3fvEXT_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix3x2fvEXT_adr := GetProcAddress('glProgramUniformMatrix3x2fvEXT');
    private ntv_ProgramUniformMatrix3x2fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix3x2fvEXT_adr);
    private ntv_ProgramUniformMatrix3x2fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2f)>(ProgramUniformMatrix3x2fvEXT_adr);
    private ntv_ProgramUniformMatrix3x2fvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3x2fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3x2fvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3x2fvEXT_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2f) :=
      ntv_ProgramUniformMatrix3x2fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix3x2fvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3x2fvEXT_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix2x4fvEXT_adr := GetProcAddress('glProgramUniformMatrix2x4fvEXT');
    private ntv_ProgramUniformMatrix2x4fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix2x4fvEXT_adr);
    private ntv_ProgramUniformMatrix2x4fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4f)>(ProgramUniformMatrix2x4fvEXT_adr);
    private ntv_ProgramUniformMatrix2x4fvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2x4fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2x4fvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2x4fvEXT_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4f) :=
      ntv_ProgramUniformMatrix2x4fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix2x4fvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2x4fvEXT_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix4x2fvEXT_adr := GetProcAddress('glProgramUniformMatrix4x2fvEXT');
    private ntv_ProgramUniformMatrix4x2fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix4x2fvEXT_adr);
    private ntv_ProgramUniformMatrix4x2fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2f)>(ProgramUniformMatrix4x2fvEXT_adr);
    private ntv_ProgramUniformMatrix4x2fvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4x2fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4x2fvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4x2fvEXT_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2f) :=
      ntv_ProgramUniformMatrix4x2fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix4x2fvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4x2fvEXT_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix3x4fvEXT_adr := GetProcAddress('glProgramUniformMatrix3x4fvEXT');
    private ntv_ProgramUniformMatrix3x4fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix3x4fvEXT_adr);
    private ntv_ProgramUniformMatrix3x4fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4f)>(ProgramUniformMatrix3x4fvEXT_adr);
    private ntv_ProgramUniformMatrix3x4fvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3x4fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3x4fvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3x4fvEXT_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4f) :=
      ntv_ProgramUniformMatrix3x4fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix3x4fvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3x4fvEXT_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix4x3fvEXT_adr := GetProcAddress('glProgramUniformMatrix4x3fvEXT');
    private ntv_ProgramUniformMatrix4x3fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix4x3fvEXT_adr);
    private ntv_ProgramUniformMatrix4x3fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3f)>(ProgramUniformMatrix4x3fvEXT_adr);
    private ntv_ProgramUniformMatrix4x3fvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4x3fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4x3fvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4x3fvEXT_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3f) :=
      ntv_ProgramUniformMatrix4x3fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix4x3fvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4x3fvEXT_3(&program, location, count, transpose, value);
    
    private TextureBufferEXT_adr := GetProcAddress('glTextureBufferEXT');
    private ntv_TextureBufferEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; internalformat: glSizedInternalFormat; buffer: gl_buffer)>(TextureBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBufferEXT(texture: gl_texture; target: glTextureTarget; internalformat: glSizedInternalFormat; buffer: gl_buffer) :=
      ntv_TextureBufferEXT_1(texture, target, internalformat, buffer);
    
    private MultiTexBufferEXT_adr := GetProcAddress('glMultiTexBufferEXT');
    private ntv_MultiTexBufferEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; internalformat: glInternalFormat; buffer: gl_buffer)>(MultiTexBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexBufferEXT(texunit: glTextureUnit; target: glTextureTarget; internalformat: glInternalFormat; buffer: gl_buffer) :=
      ntv_MultiTexBufferEXT_1(texunit, target, internalformat, buffer);
    
    private TextureParameterIivEXT_adr := GetProcAddress('glTextureParameterIivEXT');
    private ntv_TextureParameterIivEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; var &params: Int32)>(TextureParameterIivEXT_adr);
    private ntv_TextureParameterIivEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr)>(TextureParameterIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIivEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TextureParameterIivEXT_1(texture, target, pname, &params[0]) else
        ntv_TextureParameterIivEXT_1(texture, target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIivEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; var &params: Int32) :=
      ntv_TextureParameterIivEXT_1(texture, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIivEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_TextureParameterIivEXT_2(texture, target, pname, &params);
    
    private TextureParameterIuivEXT_adr := GetProcAddress('glTextureParameterIuivEXT');
    private ntv_TextureParameterIuivEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; var &params: UInt32)>(TextureParameterIuivEXT_adr);
    private ntv_TextureParameterIuivEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr)>(TextureParameterIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuivEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; &params: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TextureParameterIuivEXT_1(texture, target, pname, &params[0]) else
        ntv_TextureParameterIuivEXT_1(texture, target, pname, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuivEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; var &params: UInt32) :=
      ntv_TextureParameterIuivEXT_1(texture, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuivEXT(texture: gl_texture; target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_TextureParameterIuivEXT_2(texture, target, pname, &params);
    
    private GetTextureParameterIivEXT_adr := GetProcAddress('glGetTextureParameterIivEXT');
    private ntv_GetTextureParameterIivEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glGetTextureParameter; var &params: Int32)>(GetTextureParameterIivEXT_adr);
    private ntv_GetTextureParameterIivEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureParameterIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIivEXT(texture: gl_texture; target: glTextureTarget; pname: glGetTextureParameter; var &params: Int32) :=
      ntv_GetTextureParameterIivEXT_1(texture, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIivEXT(texture: gl_texture; target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureParameterIivEXT_2(texture, target, pname, &params);
    
    private GetTextureParameterIuivEXT_adr := GetProcAddress('glGetTextureParameterIuivEXT');
    private ntv_GetTextureParameterIuivEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glGetTextureParameter; var &params: UInt32)>(GetTextureParameterIuivEXT_adr);
    private ntv_GetTextureParameterIuivEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureParameterIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuivEXT(texture: gl_texture; target: glTextureTarget; pname: glGetTextureParameter; var &params: UInt32) :=
      ntv_GetTextureParameterIuivEXT_1(texture, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuivEXT(texture: gl_texture; target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureParameterIuivEXT_2(texture, target, pname, &params);
    
    private MultiTexParameterIivEXT_adr := GetProcAddress('glMultiTexParameterIivEXT');
    private ntv_MultiTexParameterIivEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; var &params: Int32)>(MultiTexParameterIivEXT_adr);
    private ntv_MultiTexParameterIivEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr)>(MultiTexParameterIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIivEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_MultiTexParameterIivEXT_1(texunit, target, pname, &params[0]) else
        ntv_MultiTexParameterIivEXT_1(texunit, target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIivEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; var &params: Int32) :=
      ntv_MultiTexParameterIivEXT_1(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIivEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_MultiTexParameterIivEXT_2(texunit, target, pname, &params);
    
    private MultiTexParameterIuivEXT_adr := GetProcAddress('glMultiTexParameterIuivEXT');
    private ntv_MultiTexParameterIuivEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; var &params: UInt32)>(MultiTexParameterIuivEXT_adr);
    private ntv_MultiTexParameterIuivEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr)>(MultiTexParameterIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIuivEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; &params: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_MultiTexParameterIuivEXT_1(texunit, target, pname, &params[0]) else
        ntv_MultiTexParameterIuivEXT_1(texunit, target, pname, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIuivEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; var &params: UInt32) :=
      ntv_MultiTexParameterIuivEXT_1(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIuivEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_MultiTexParameterIuivEXT_2(texunit, target, pname, &params);
    
    private GetMultiTexParameterIivEXT_adr := GetProcAddress('glGetMultiTexParameterIivEXT');
    private ntv_GetMultiTexParameterIivEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glGetTextureParameter; var &params: Int32)>(GetMultiTexParameterIivEXT_adr);
    private ntv_GetMultiTexParameterIivEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr)>(GetMultiTexParameterIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIivEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glGetTextureParameter; var &params: Int32) :=
      ntv_GetMultiTexParameterIivEXT_1(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIivEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetMultiTexParameterIivEXT_2(texunit, target, pname, &params);
    
    private GetMultiTexParameterIuivEXT_adr := GetProcAddress('glGetMultiTexParameterIuivEXT');
    private ntv_GetMultiTexParameterIuivEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glGetTextureParameter; var &params: UInt32)>(GetMultiTexParameterIuivEXT_adr);
    private ntv_GetMultiTexParameterIuivEXT_2 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr)>(GetMultiTexParameterIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIuivEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glGetTextureParameter; var &params: UInt32) :=
      ntv_GetMultiTexParameterIuivEXT_1(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIuivEXT(texunit: glTextureUnit; target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetMultiTexParameterIuivEXT_2(texunit, target, pname, &params);
    
    private ProgramUniform1uiEXT_adr := GetProcAddress('glProgramUniform1uiEXT');
    private ntv_ProgramUniform1uiEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32)>(ProgramUniform1uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiEXT(&program: gl_program; location: Int32; v0: UInt32) :=
      ntv_ProgramUniform1uiEXT_1(&program, location, v0);
    
    private ProgramUniform2uiEXT_adr := GetProcAddress('glProgramUniform2uiEXT');
    private ntv_ProgramUniform2uiEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32)>(ProgramUniform2uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiEXT(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32) :=
      ntv_ProgramUniform2uiEXT_1(&program, location, v0, v1);
    
    private ProgramUniform3uiEXT_adr := GetProcAddress('glProgramUniform3uiEXT');
    private ntv_ProgramUniform3uiEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32)>(ProgramUniform3uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiEXT(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32) :=
      ntv_ProgramUniform3uiEXT_1(&program, location, v0, v1, v2);
    
    private ProgramUniform4uiEXT_adr := GetProcAddress('glProgramUniform4uiEXT');
    private ntv_ProgramUniform4uiEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32)>(ProgramUniform4uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiEXT(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32) :=
      ntv_ProgramUniform4uiEXT_1(&program, location, v0, v1, v2, v3);
    
    private ProgramUniform1uivEXT_adr := GetProcAddress('glProgramUniform1uivEXT');
    private ntv_ProgramUniform1uivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(ProgramUniform1uivEXT_adr);
    private ntv_ProgramUniform1uivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uivEXT(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1uivEXT_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1uivEXT_1(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uivEXT(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
      ntv_ProgramUniform1uivEXT_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uivEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1uivEXT_2(&program, location, count, value);
    
    private ProgramUniform2uivEXT_adr := GetProcAddress('glProgramUniform2uivEXT');
    private ntv_ProgramUniform2uivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(ProgramUniform2uivEXT_adr);
    private ntv_ProgramUniform2uivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2ui)>(ProgramUniform2uivEXT_adr);
    private ntv_ProgramUniform2uivEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uivEXT(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2uivEXT_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2uivEXT_1(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uivEXT(&program: gl_program; location: Int32; count: Int32; var value: Vec2ui) :=
      ntv_ProgramUniform2uivEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uivEXT(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
      ntv_ProgramUniform2uivEXT_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uivEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2uivEXT_3(&program, location, count, value);
    
    private ProgramUniform3uivEXT_adr := GetProcAddress('glProgramUniform3uivEXT');
    private ntv_ProgramUniform3uivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(ProgramUniform3uivEXT_adr);
    private ntv_ProgramUniform3uivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3ui)>(ProgramUniform3uivEXT_adr);
    private ntv_ProgramUniform3uivEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uivEXT(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3uivEXT_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3uivEXT_1(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uivEXT(&program: gl_program; location: Int32; count: Int32; var value: Vec3ui) :=
      ntv_ProgramUniform3uivEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uivEXT(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
      ntv_ProgramUniform3uivEXT_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uivEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3uivEXT_3(&program, location, count, value);
    
    private ProgramUniform4uivEXT_adr := GetProcAddress('glProgramUniform4uivEXT');
    private ntv_ProgramUniform4uivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(ProgramUniform4uivEXT_adr);
    private ntv_ProgramUniform4uivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4ui)>(ProgramUniform4uivEXT_adr);
    private ntv_ProgramUniform4uivEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uivEXT(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4uivEXT_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4uivEXT_1(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uivEXT(&program: gl_program; location: Int32; count: Int32; var value: Vec4ui) :=
      ntv_ProgramUniform4uivEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uivEXT(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
      ntv_ProgramUniform4uivEXT_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uivEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4uivEXT_3(&program, location, count, value);
    
    private NamedProgramLocalParameters4fvEXT_adr := GetProcAddress('glNamedProgramLocalParameters4fvEXT');
    private ntv_NamedProgramLocalParameters4fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; var &params: single)>(NamedProgramLocalParameters4fvEXT_adr);
    private ntv_NamedProgramLocalParameters4fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4f)>(NamedProgramLocalParameters4fvEXT_adr);
    private ntv_NamedProgramLocalParameters4fvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(NamedProgramLocalParameters4fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameters4fvEXT(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_NamedProgramLocalParameters4fvEXT_1(&program, target, index, count, &params[0]) else
        ntv_NamedProgramLocalParameters4fvEXT_1(&program, target, index, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameters4fvEXT(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4f) :=
      ntv_NamedProgramLocalParameters4fvEXT_2(&program, target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameters4fvEXT(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; var &params: single) :=
      ntv_NamedProgramLocalParameters4fvEXT_1(&program, target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameters4fvEXT(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
      ntv_NamedProgramLocalParameters4fvEXT_3(&program, target, index, count, &params);
    
    private NamedProgramLocalParameterI4iEXT_adr := GetProcAddress('glNamedProgramLocalParameterI4iEXT');
    private ntv_NamedProgramLocalParameterI4iEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>(NamedProgramLocalParameterI4iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4iEXT(&program: gl_program; target: glProgramTarget; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) :=
      ntv_NamedProgramLocalParameterI4iEXT_1(&program, target, index, x, y, z, w);
    
    private NamedProgramLocalParameterI4ivEXT_adr := GetProcAddress('glNamedProgramLocalParameterI4ivEXT');
    private ntv_NamedProgramLocalParameterI4ivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: Int32)>(NamedProgramLocalParameterI4ivEXT_adr);
    private ntv_NamedProgramLocalParameterI4ivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: Vec4i)>(NamedProgramLocalParameterI4ivEXT_adr);
    private ntv_NamedProgramLocalParameterI4ivEXT_3 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; &params: IntPtr)>(NamedProgramLocalParameterI4ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4ivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_NamedProgramLocalParameterI4ivEXT_1(&program, target, index, &params[0]) else
        ntv_NamedProgramLocalParameterI4ivEXT_1(&program, target, index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4ivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: Vec4i) :=
      ntv_NamedProgramLocalParameterI4ivEXT_2(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4ivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: Int32) :=
      ntv_NamedProgramLocalParameterI4ivEXT_1(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4ivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_NamedProgramLocalParameterI4ivEXT_3(&program, target, index, &params);
    
    private NamedProgramLocalParametersI4ivEXT_adr := GetProcAddress('glNamedProgramLocalParametersI4ivEXT');
    private ntv_NamedProgramLocalParametersI4ivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; var &params: Int32)>(NamedProgramLocalParametersI4ivEXT_adr);
    private ntv_NamedProgramLocalParametersI4ivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4i)>(NamedProgramLocalParametersI4ivEXT_adr);
    private ntv_NamedProgramLocalParametersI4ivEXT_3 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(NamedProgramLocalParametersI4ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4ivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_NamedProgramLocalParametersI4ivEXT_1(&program, target, index, count, &params[0]) else
        ntv_NamedProgramLocalParametersI4ivEXT_1(&program, target, index, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4ivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4i) :=
      ntv_NamedProgramLocalParametersI4ivEXT_2(&program, target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4ivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; var &params: Int32) :=
      ntv_NamedProgramLocalParametersI4ivEXT_1(&program, target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4ivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
      ntv_NamedProgramLocalParametersI4ivEXT_3(&program, target, index, count, &params);
    
    private NamedProgramLocalParameterI4uiEXT_adr := GetProcAddress('glNamedProgramLocalParameterI4uiEXT');
    private ntv_NamedProgramLocalParameterI4uiEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>(NamedProgramLocalParameterI4uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4uiEXT(&program: gl_program; target: glProgramTarget; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) :=
      ntv_NamedProgramLocalParameterI4uiEXT_1(&program, target, index, x, y, z, w);
    
    private NamedProgramLocalParameterI4uivEXT_adr := GetProcAddress('glNamedProgramLocalParameterI4uivEXT');
    private ntv_NamedProgramLocalParameterI4uivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: UInt32)>(NamedProgramLocalParameterI4uivEXT_adr);
    private ntv_NamedProgramLocalParameterI4uivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: Vec4ui)>(NamedProgramLocalParameterI4uivEXT_adr);
    private ntv_NamedProgramLocalParameterI4uivEXT_3 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; &params: IntPtr)>(NamedProgramLocalParameterI4uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4uivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; &params: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_NamedProgramLocalParameterI4uivEXT_1(&program, target, index, &params[0]) else
        ntv_NamedProgramLocalParameterI4uivEXT_1(&program, target, index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4uivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: Vec4ui) :=
      ntv_NamedProgramLocalParameterI4uivEXT_2(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4uivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: UInt32) :=
      ntv_NamedProgramLocalParameterI4uivEXT_1(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4uivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_NamedProgramLocalParameterI4uivEXT_3(&program, target, index, &params);
    
    private NamedProgramLocalParametersI4uivEXT_adr := GetProcAddress('glNamedProgramLocalParametersI4uivEXT');
    private ntv_NamedProgramLocalParametersI4uivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; var &params: UInt32)>(NamedProgramLocalParametersI4uivEXT_adr);
    private ntv_NamedProgramLocalParametersI4uivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4ui)>(NamedProgramLocalParametersI4uivEXT_adr);
    private ntv_NamedProgramLocalParametersI4uivEXT_3 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(NamedProgramLocalParametersI4uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4uivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; &params: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_NamedProgramLocalParametersI4uivEXT_1(&program, target, index, count, &params[0]) else
        ntv_NamedProgramLocalParametersI4uivEXT_1(&program, target, index, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4uivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4ui) :=
      ntv_NamedProgramLocalParametersI4uivEXT_2(&program, target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4uivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; var &params: UInt32) :=
      ntv_NamedProgramLocalParametersI4uivEXT_1(&program, target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4uivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
      ntv_NamedProgramLocalParametersI4uivEXT_3(&program, target, index, count, &params);
    
    private GetNamedProgramLocalParameterIivEXT_adr := GetProcAddress('glGetNamedProgramLocalParameterIivEXT');
    private ntv_GetNamedProgramLocalParameterIivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: Int32)>(GetNamedProgramLocalParameterIivEXT_adr);
    private ntv_GetNamedProgramLocalParameterIivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; &params: IntPtr)>(GetNamedProgramLocalParameterIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: Int32) :=
      ntv_GetNamedProgramLocalParameterIivEXT_1(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_GetNamedProgramLocalParameterIivEXT_2(&program, target, index, &params);
    
    private GetNamedProgramLocalParameterIuivEXT_adr := GetProcAddress('glGetNamedProgramLocalParameterIuivEXT');
    private ntv_GetNamedProgramLocalParameterIuivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: UInt32)>(GetNamedProgramLocalParameterIuivEXT_adr);
    private ntv_GetNamedProgramLocalParameterIuivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; &params: IntPtr)>(GetNamedProgramLocalParameterIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIuivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: UInt32) :=
      ntv_GetNamedProgramLocalParameterIuivEXT_1(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIuivEXT(&program: gl_program; target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_GetNamedProgramLocalParameterIuivEXT_2(&program, target, index, &params);
    
    private EnableClientStateiEXT_adr := GetProcAddress('glEnableClientStateiEXT');
    private ntv_EnableClientStateiEXT_1 := GetProcOrNil&<procedure(&array: glEnableCap; index: UInt32)>(EnableClientStateiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableClientStateiEXT(&array: glEnableCap; index: UInt32) :=
      ntv_EnableClientStateiEXT_1(&array, index);
    
    private DisableClientStateiEXT_adr := GetProcAddress('glDisableClientStateiEXT');
    private ntv_DisableClientStateiEXT_1 := GetProcOrNil&<procedure(&array: glEnableCap; index: UInt32)>(DisableClientStateiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableClientStateiEXT(&array: glEnableCap; index: UInt32) :=
      ntv_DisableClientStateiEXT_1(&array, index);
    
    private GetFloati_vEXT_adr := GetProcAddress('glGetFloati_vEXT');
    private ntv_GetFloati_vEXT_1 := GetProcOrNil&<procedure(pname: glGetPName; index: UInt32; var &params: single)>(GetFloati_vEXT_adr);
    private ntv_GetFloati_vEXT_2 := GetProcOrNil&<procedure(pname: glGetPName; index: UInt32; &params: IntPtr)>(GetFloati_vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_vEXT(pname: glGetPName; index: UInt32; var &params: single) :=
      ntv_GetFloati_vEXT_1(pname, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_vEXT(pname: glGetPName; index: UInt32; &params: IntPtr) :=
      ntv_GetFloati_vEXT_2(pname, index, &params);
    
    private GetDoublei_vEXT_adr := GetProcAddress('glGetDoublei_vEXT');
    private ntv_GetDoublei_vEXT_1 := GetProcOrNil&<procedure(pname: glGetPName; index: UInt32; var &params: double)>(GetDoublei_vEXT_adr);
    private ntv_GetDoublei_vEXT_2 := GetProcOrNil&<procedure(pname: glGetPName; index: UInt32; &params: IntPtr)>(GetDoublei_vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_vEXT(pname: glGetPName; index: UInt32; var &params: double) :=
      ntv_GetDoublei_vEXT_1(pname, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_vEXT(pname: glGetPName; index: UInt32; &params: IntPtr) :=
      ntv_GetDoublei_vEXT_2(pname, index, &params);
    
    private GetPointeri_vEXT_adr := GetProcAddress('glGetPointeri_vEXT');
    private ntv_GetPointeri_vEXT_1 := GetProcOrNil&<procedure(pname: DummyEnum; index: UInt32; var &params: IntPtr)>(GetPointeri_vEXT_adr);
    private ntv_GetPointeri_vEXT_2 := GetProcOrNil&<procedure(pname: DummyEnum; index: UInt32; &params: pointer)>(GetPointeri_vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointeri_vEXT(pname: DummyEnum; index: UInt32; var &params: IntPtr) :=
      ntv_GetPointeri_vEXT_1(pname, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointeri_vEXT(pname: DummyEnum; index: UInt32; &params: pointer) :=
      ntv_GetPointeri_vEXT_2(pname, index, &params);
    
    private NamedProgramStringEXT_adr := GetProcAddress('glNamedProgramStringEXT');
    private ntv_NamedProgramStringEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; format: glProgramFormat; len: Int32; string: IntPtr)>(NamedProgramStringEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramStringEXT(&program: gl_program; target: glProgramTarget; format: glProgramFormat; len: Int32; string: IntPtr) :=
      ntv_NamedProgramStringEXT_1(&program, target, format, len, string);
    
    private NamedProgramLocalParameter4dEXT_adr := GetProcAddress('glNamedProgramLocalParameter4dEXT');
    private ntv_NamedProgramLocalParameter4dEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; x: double; y: double; z: double; w: double)>(NamedProgramLocalParameter4dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4dEXT(&program: gl_program; target: glProgramTarget; index: UInt32; x: double; y: double; z: double; w: double) :=
      ntv_NamedProgramLocalParameter4dEXT_1(&program, target, index, x, y, z, w);
    
    private NamedProgramLocalParameter4dvEXT_adr := GetProcAddress('glNamedProgramLocalParameter4dvEXT');
    private ntv_NamedProgramLocalParameter4dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: double)>(NamedProgramLocalParameter4dvEXT_adr);
    private ntv_NamedProgramLocalParameter4dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: Vec4d)>(NamedProgramLocalParameter4dvEXT_adr);
    private ntv_NamedProgramLocalParameter4dvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; &params: IntPtr)>(NamedProgramLocalParameter4dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4dvEXT(&program: gl_program; target: glProgramTarget; index: UInt32; &params: array of double);
    type PDouble = ^double;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_NamedProgramLocalParameter4dvEXT_1(&program, target, index, &params[0]) else
        ntv_NamedProgramLocalParameter4dvEXT_1(&program, target, index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4dvEXT(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: Vec4d) :=
      ntv_NamedProgramLocalParameter4dvEXT_2(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4dvEXT(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: double) :=
      ntv_NamedProgramLocalParameter4dvEXT_1(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4dvEXT(&program: gl_program; target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_NamedProgramLocalParameter4dvEXT_3(&program, target, index, &params);
    
    private NamedProgramLocalParameter4fEXT_adr := GetProcAddress('glNamedProgramLocalParameter4fEXT');
    private ntv_NamedProgramLocalParameter4fEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; x: single; y: single; z: single; w: single)>(NamedProgramLocalParameter4fEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4fEXT(&program: gl_program; target: glProgramTarget; index: UInt32; x: single; y: single; z: single; w: single) :=
      ntv_NamedProgramLocalParameter4fEXT_1(&program, target, index, x, y, z, w);
    
    private NamedProgramLocalParameter4fvEXT_adr := GetProcAddress('glNamedProgramLocalParameter4fvEXT');
    private ntv_NamedProgramLocalParameter4fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: single)>(NamedProgramLocalParameter4fvEXT_adr);
    private ntv_NamedProgramLocalParameter4fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: Vec4f)>(NamedProgramLocalParameter4fvEXT_adr);
    private ntv_NamedProgramLocalParameter4fvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; &params: IntPtr)>(NamedProgramLocalParameter4fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4fvEXT(&program: gl_program; target: glProgramTarget; index: UInt32; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_NamedProgramLocalParameter4fvEXT_1(&program, target, index, &params[0]) else
        ntv_NamedProgramLocalParameter4fvEXT_1(&program, target, index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4fvEXT(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: Vec4f) :=
      ntv_NamedProgramLocalParameter4fvEXT_2(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4fvEXT(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: single) :=
      ntv_NamedProgramLocalParameter4fvEXT_1(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4fvEXT(&program: gl_program; target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_NamedProgramLocalParameter4fvEXT_3(&program, target, index, &params);
    
    private GetNamedProgramLocalParameterdvEXT_adr := GetProcAddress('glGetNamedProgramLocalParameterdvEXT');
    private ntv_GetNamedProgramLocalParameterdvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: double)>(GetNamedProgramLocalParameterdvEXT_adr);
    private ntv_GetNamedProgramLocalParameterdvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; &params: IntPtr)>(GetNamedProgramLocalParameterdvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterdvEXT(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: double) :=
      ntv_GetNamedProgramLocalParameterdvEXT_1(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterdvEXT(&program: gl_program; target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_GetNamedProgramLocalParameterdvEXT_2(&program, target, index, &params);
    
    private GetNamedProgramLocalParameterfvEXT_adr := GetProcAddress('glGetNamedProgramLocalParameterfvEXT');
    private ntv_GetNamedProgramLocalParameterfvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: single)>(GetNamedProgramLocalParameterfvEXT_adr);
    private ntv_GetNamedProgramLocalParameterfvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; index: UInt32; &params: IntPtr)>(GetNamedProgramLocalParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterfvEXT(&program: gl_program; target: glProgramTarget; index: UInt32; var &params: single) :=
      ntv_GetNamedProgramLocalParameterfvEXT_1(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterfvEXT(&program: gl_program; target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_GetNamedProgramLocalParameterfvEXT_2(&program, target, index, &params);
    
    private GetNamedProgramivEXT_adr := GetProcAddress('glGetNamedProgramivEXT');
    private ntv_GetNamedProgramivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; pname: glProgramProperty; var &params: Int32)>(GetNamedProgramivEXT_adr);
    private ntv_GetNamedProgramivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; pname: glProgramProperty; &params: IntPtr)>(GetNamedProgramivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramivEXT(&program: gl_program; target: glProgramTarget; pname: glProgramProperty; var &params: Int32) :=
      ntv_GetNamedProgramivEXT_1(&program, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramivEXT(&program: gl_program; target: glProgramTarget; pname: glProgramProperty; &params: IntPtr) :=
      ntv_GetNamedProgramivEXT_2(&program, target, pname, &params);
    
    private GetNamedProgramStringEXT_adr := GetProcAddress('glGetNamedProgramStringEXT');
    private ntv_GetNamedProgramStringEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: glProgramTarget; pname: glProgramStringProperty; string: IntPtr)>(GetNamedProgramStringEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramStringEXT(&program: gl_program; target: glProgramTarget; pname: glProgramStringProperty; string: IntPtr) :=
      ntv_GetNamedProgramStringEXT_1(&program, target, pname, string);
    
    private NamedRenderbufferStorageEXT_adr := GetProcAddress('glNamedRenderbufferStorageEXT');
    private ntv_NamedRenderbufferStorageEXT_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; internalformat: glInternalFormat; width: Int32; height: Int32)>(NamedRenderbufferStorageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageEXT(renderbuffer: gl_renderbuffer; internalformat: glInternalFormat; width: Int32; height: Int32) :=
      ntv_NamedRenderbufferStorageEXT_1(renderbuffer, internalformat, width, height);
    
    private GetNamedRenderbufferParameterivEXT_adr := GetProcAddress('glGetNamedRenderbufferParameterivEXT');
    private ntv_GetNamedRenderbufferParameterivEXT_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; pname: glRenderbufferParameterName; var &params: Int32)>(GetNamedRenderbufferParameterivEXT_adr);
    private ntv_GetNamedRenderbufferParameterivEXT_2 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; pname: glRenderbufferParameterName; &params: IntPtr)>(GetNamedRenderbufferParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameterivEXT(renderbuffer: gl_renderbuffer; pname: glRenderbufferParameterName; var &params: Int32) :=
      ntv_GetNamedRenderbufferParameterivEXT_1(renderbuffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameterivEXT(renderbuffer: gl_renderbuffer; pname: glRenderbufferParameterName; &params: IntPtr) :=
      ntv_GetNamedRenderbufferParameterivEXT_2(renderbuffer, pname, &params);
    
    private NamedRenderbufferStorageMultisampleEXT_adr := GetProcAddress('glNamedRenderbufferStorageMultisampleEXT');
    private ntv_NamedRenderbufferStorageMultisampleEXT_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32)>(NamedRenderbufferStorageMultisampleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageMultisampleEXT(renderbuffer: gl_renderbuffer; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32) :=
      ntv_NamedRenderbufferStorageMultisampleEXT_1(renderbuffer, samples, internalformat, width, height);
    
    private NamedRenderbufferStorageMultisampleCoverageEXT_adr := GetProcAddress('glNamedRenderbufferStorageMultisampleCoverageEXT');
    private ntv_NamedRenderbufferStorageMultisampleCoverageEXT_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; coverageSamples: Int32; colorSamples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32)>(NamedRenderbufferStorageMultisampleCoverageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer: gl_renderbuffer; coverageSamples: Int32; colorSamples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32) :=
      ntv_NamedRenderbufferStorageMultisampleCoverageEXT_1(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
    
    private CheckNamedFramebufferStatusEXT_adr := GetProcAddress('glCheckNamedFramebufferStatusEXT');
    private ntv_CheckNamedFramebufferStatusEXT_1 := GetProcOrNil&<function(framebuffer: gl_framebuffer; target: glFramebufferTarget): glFramebufferStatus>(CheckNamedFramebufferStatusEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CheckNamedFramebufferStatusEXT(framebuffer: gl_framebuffer; target: glFramebufferTarget): glFramebufferStatus :=
      ntv_CheckNamedFramebufferStatusEXT_1(framebuffer, target);
    
    private NamedFramebufferTexture1DEXT_adr := GetProcAddress('glNamedFramebufferTexture1DEXT');
    private ntv_NamedFramebufferTexture1DEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32)>(NamedFramebufferTexture1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTexture1DEXT(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32) :=
      ntv_NamedFramebufferTexture1DEXT_1(framebuffer, attachment, textarget, texture, level);
    
    private NamedFramebufferTexture2DEXT_adr := GetProcAddress('glNamedFramebufferTexture2DEXT');
    private ntv_NamedFramebufferTexture2DEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32)>(NamedFramebufferTexture2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTexture2DEXT(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32) :=
      ntv_NamedFramebufferTexture2DEXT_1(framebuffer, attachment, textarget, texture, level);
    
    private NamedFramebufferTexture3DEXT_adr := GetProcAddress('glNamedFramebufferTexture3DEXT');
    private ntv_NamedFramebufferTexture3DEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32; zoffset: Int32)>(NamedFramebufferTexture3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTexture3DEXT(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32; zoffset: Int32) :=
      ntv_NamedFramebufferTexture3DEXT_1(framebuffer, attachment, textarget, texture, level, zoffset);
    
    private NamedFramebufferRenderbufferEXT_adr := GetProcAddress('glNamedFramebufferRenderbufferEXT');
    private ntv_NamedFramebufferRenderbufferEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; renderbuffertarget: glRenderbufferTarget; renderbuffer: gl_renderbuffer)>(NamedFramebufferRenderbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferRenderbufferEXT(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; renderbuffertarget: glRenderbufferTarget; renderbuffer: gl_renderbuffer) :=
      ntv_NamedFramebufferRenderbufferEXT_1(framebuffer, attachment, renderbuffertarget, renderbuffer);
    
    private GetNamedFramebufferAttachmentParameterivEXT_adr := GetProcAddress('glGetNamedFramebufferAttachmentParameterivEXT');
    private ntv_GetNamedFramebufferAttachmentParameterivEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; var &params: Int32)>(GetNamedFramebufferAttachmentParameterivEXT_adr);
    private ntv_GetNamedFramebufferAttachmentParameterivEXT_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; &params: IntPtr)>(GetNamedFramebufferAttachmentParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameterivEXT(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; var &params: Int32) :=
      ntv_GetNamedFramebufferAttachmentParameterivEXT_1(framebuffer, attachment, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameterivEXT(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; &params: IntPtr) :=
      ntv_GetNamedFramebufferAttachmentParameterivEXT_2(framebuffer, attachment, pname, &params);
    
    private GenerateTextureMipmapEXT_adr := GetProcAddress('glGenerateTextureMipmapEXT');
    private ntv_GenerateTextureMipmapEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget)>(GenerateTextureMipmapEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateTextureMipmapEXT(texture: gl_texture; target: glTextureTarget) :=
      ntv_GenerateTextureMipmapEXT_1(texture, target);
    
    private GenerateMultiTexMipmapEXT_adr := GetProcAddress('glGenerateMultiTexMipmapEXT');
    private ntv_GenerateMultiTexMipmapEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget)>(GenerateMultiTexMipmapEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateMultiTexMipmapEXT(texunit: glTextureUnit; target: glTextureTarget) :=
      ntv_GenerateMultiTexMipmapEXT_1(texunit, target);
    
    private FramebufferDrawBufferEXT_adr := GetProcAddress('glFramebufferDrawBufferEXT');
    private ntv_FramebufferDrawBufferEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; mode: glDrawBufferMode)>(FramebufferDrawBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferDrawBufferEXT(framebuffer: gl_framebuffer; mode: glDrawBufferMode) :=
      ntv_FramebufferDrawBufferEXT_1(framebuffer, mode);
    
    private FramebufferDrawBuffersEXT_adr := GetProcAddress('glFramebufferDrawBuffersEXT');
    private ntv_FramebufferDrawBuffersEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; n: Int32; var bufs: glDrawBufferMode)>(FramebufferDrawBuffersEXT_adr);
    private ntv_FramebufferDrawBuffersEXT_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; n: Int32; bufs: IntPtr)>(FramebufferDrawBuffersEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferDrawBuffersEXT(framebuffer: gl_framebuffer; n: Int32; bufs: array of glDrawBufferMode);
    type PGlDrawBufferMode = ^glDrawBufferMode;
    begin
      if (bufs<>nil) and (bufs.Length<>0) then
        ntv_FramebufferDrawBuffersEXT_1(framebuffer, n, bufs[0]) else
        ntv_FramebufferDrawBuffersEXT_1(framebuffer, n, PGlDrawBufferMode(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferDrawBuffersEXT(framebuffer: gl_framebuffer; n: Int32; var bufs: glDrawBufferMode) :=
      ntv_FramebufferDrawBuffersEXT_1(framebuffer, n, bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferDrawBuffersEXT(framebuffer: gl_framebuffer; n: Int32; bufs: IntPtr) :=
      ntv_FramebufferDrawBuffersEXT_2(framebuffer, n, bufs);
    
    private FramebufferReadBufferEXT_adr := GetProcAddress('glFramebufferReadBufferEXT');
    private ntv_FramebufferReadBufferEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; mode: glReadBufferMode)>(FramebufferReadBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferReadBufferEXT(framebuffer: gl_framebuffer; mode: glReadBufferMode) :=
      ntv_FramebufferReadBufferEXT_1(framebuffer, mode);
    
    private GetFramebufferParameterivEXT_adr := GetProcAddress('glGetFramebufferParameterivEXT');
    private ntv_GetFramebufferParameterivEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: glGetFramebufferParameter; var &params: Int32)>(GetFramebufferParameterivEXT_adr);
    private ntv_GetFramebufferParameterivEXT_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: glGetFramebufferParameter; &params: IntPtr)>(GetFramebufferParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterivEXT(framebuffer: gl_framebuffer; pname: glGetFramebufferParameter; var &params: Int32) :=
      ntv_GetFramebufferParameterivEXT_1(framebuffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterivEXT(framebuffer: gl_framebuffer; pname: glGetFramebufferParameter; &params: IntPtr) :=
      ntv_GetFramebufferParameterivEXT_2(framebuffer, pname, &params);
    
    private NamedCopyBufferSubDataEXT_adr := GetProcAddress('glNamedCopyBufferSubDataEXT');
    private ntv_NamedCopyBufferSubDataEXT_1 := GetProcOrNil&<procedure(readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(NamedCopyBufferSubDataEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedCopyBufferSubDataEXT(readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) :=
      ntv_NamedCopyBufferSubDataEXT_1(readBuffer, writeBuffer, readOffset, writeOffset, size);
    
    private NamedFramebufferTextureEXT_adr := GetProcAddress('glNamedFramebufferTextureEXT');
    private ntv_NamedFramebufferTextureEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32)>(NamedFramebufferTextureEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTextureEXT(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32) :=
      ntv_NamedFramebufferTextureEXT_1(framebuffer, attachment, texture, level);
    
    private NamedFramebufferTextureLayerEXT_adr := GetProcAddress('glNamedFramebufferTextureLayerEXT');
    private ntv_NamedFramebufferTextureLayerEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32)>(NamedFramebufferTextureLayerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTextureLayerEXT(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32) :=
      ntv_NamedFramebufferTextureLayerEXT_1(framebuffer, attachment, texture, level, layer);
    
    private NamedFramebufferTextureFaceEXT_adr := GetProcAddress('glNamedFramebufferTextureFaceEXT');
    private ntv_NamedFramebufferTextureFaceEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; face: glTextureTarget)>(NamedFramebufferTextureFaceEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTextureFaceEXT(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; face: glTextureTarget) :=
      ntv_NamedFramebufferTextureFaceEXT_1(framebuffer, attachment, texture, level, face);
    
    private TextureRenderbufferEXT_adr := GetProcAddress('glTextureRenderbufferEXT');
    private ntv_TextureRenderbufferEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; renderbuffer: gl_renderbuffer)>(TextureRenderbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureRenderbufferEXT(texture: gl_texture; target: glTextureTarget; renderbuffer: gl_renderbuffer) :=
      ntv_TextureRenderbufferEXT_1(texture, target, renderbuffer);
    
    private MultiTexRenderbufferEXT_adr := GetProcAddress('glMultiTexRenderbufferEXT');
    private ntv_MultiTexRenderbufferEXT_1 := GetProcOrNil&<procedure(texunit: glTextureUnit; target: glTextureTarget; renderbuffer: gl_renderbuffer)>(MultiTexRenderbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexRenderbufferEXT(texunit: glTextureUnit; target: glTextureTarget; renderbuffer: gl_renderbuffer) :=
      ntv_MultiTexRenderbufferEXT_1(texunit, target, renderbuffer);
    
    private VertexArrayVertexOffsetEXT_adr := GetProcAddress('glVertexArrayVertexOffsetEXT');
    private ntv_VertexArrayVertexOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; size: Int32; &type: glVertexPointerType; stride: Int32; offset: IntPtr)>(VertexArrayVertexOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; size: Int32; &type: glVertexPointerType; stride: Int32; offset: IntPtr) :=
      ntv_VertexArrayVertexOffsetEXT_1(vaobj, buffer, size, &type, stride, offset);
    
    private VertexArrayColorOffsetEXT_adr := GetProcAddress('glVertexArrayColorOffsetEXT');
    private ntv_VertexArrayColorOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; size: Int32; &type: glColorPointerType; stride: Int32; offset: IntPtr)>(VertexArrayColorOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayColorOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; size: Int32; &type: glColorPointerType; stride: Int32; offset: IntPtr) :=
      ntv_VertexArrayColorOffsetEXT_1(vaobj, buffer, size, &type, stride, offset);
    
    private VertexArrayEdgeFlagOffsetEXT_adr := GetProcAddress('glVertexArrayEdgeFlagOffsetEXT');
    private ntv_VertexArrayEdgeFlagOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; stride: Int32; offset: IntPtr)>(VertexArrayEdgeFlagOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayEdgeFlagOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; stride: Int32; offset: IntPtr) :=
      ntv_VertexArrayEdgeFlagOffsetEXT_1(vaobj, buffer, stride, offset);
    
    private VertexArrayIndexOffsetEXT_adr := GetProcAddress('glVertexArrayIndexOffsetEXT');
    private ntv_VertexArrayIndexOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; &type: glIndexPointerType; stride: Int32; offset: IntPtr)>(VertexArrayIndexOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayIndexOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; &type: glIndexPointerType; stride: Int32; offset: IntPtr) :=
      ntv_VertexArrayIndexOffsetEXT_1(vaobj, buffer, &type, stride, offset);
    
    private VertexArrayNormalOffsetEXT_adr := GetProcAddress('glVertexArrayNormalOffsetEXT');
    private ntv_VertexArrayNormalOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; &type: glNormalPointerType; stride: Int32; offset: IntPtr)>(VertexArrayNormalOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayNormalOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; &type: glNormalPointerType; stride: Int32; offset: IntPtr) :=
      ntv_VertexArrayNormalOffsetEXT_1(vaobj, buffer, &type, stride, offset);
    
    private VertexArrayTexCoordOffsetEXT_adr := GetProcAddress('glVertexArrayTexCoordOffsetEXT');
    private ntv_VertexArrayTexCoordOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; size: Int32; &type: glTexCoordPointerType; stride: Int32; offset: IntPtr)>(VertexArrayTexCoordOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayTexCoordOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; size: Int32; &type: glTexCoordPointerType; stride: Int32; offset: IntPtr) :=
      ntv_VertexArrayTexCoordOffsetEXT_1(vaobj, buffer, size, &type, stride, offset);
    
    private VertexArrayMultiTexCoordOffsetEXT_adr := GetProcAddress('glVertexArrayMultiTexCoordOffsetEXT');
    private ntv_VertexArrayMultiTexCoordOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; texunit: DummyEnum; size: Int32; &type: glTexCoordPointerType; stride: Int32; offset: IntPtr)>(VertexArrayMultiTexCoordOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayMultiTexCoordOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; texunit: DummyEnum; size: Int32; &type: glTexCoordPointerType; stride: Int32; offset: IntPtr) :=
      ntv_VertexArrayMultiTexCoordOffsetEXT_1(vaobj, buffer, texunit, size, &type, stride, offset);
    
    private VertexArrayFogCoordOffsetEXT_adr := GetProcAddress('glVertexArrayFogCoordOffsetEXT');
    private ntv_VertexArrayFogCoordOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; &type: glFogCoordinatePointerType; stride: Int32; offset: IntPtr)>(VertexArrayFogCoordOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayFogCoordOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; &type: glFogCoordinatePointerType; stride: Int32; offset: IntPtr) :=
      ntv_VertexArrayFogCoordOffsetEXT_1(vaobj, buffer, &type, stride, offset);
    
    private VertexArraySecondaryColorOffsetEXT_adr := GetProcAddress('glVertexArraySecondaryColorOffsetEXT');
    private ntv_VertexArraySecondaryColorOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; size: Int32; &type: glColorPointerType; stride: Int32; offset: IntPtr)>(VertexArraySecondaryColorOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArraySecondaryColorOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; size: Int32; &type: glColorPointerType; stride: Int32; offset: IntPtr) :=
      ntv_VertexArraySecondaryColorOffsetEXT_1(vaobj, buffer, size, &type, stride, offset);
    
    private VertexArrayVertexAttribOffsetEXT_adr := GetProcAddress('glVertexArrayVertexAttribOffsetEXT');
    private ntv_VertexArrayVertexAttribOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; index: UInt32; size: Int32; &type: glVertexAttribPointerType; normalized: glBool8; stride: Int32; offset: IntPtr)>(VertexArrayVertexAttribOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; index: UInt32; size: Int32; &type: glVertexAttribPointerType; normalized: glBool8; stride: Int32; offset: IntPtr) :=
      ntv_VertexArrayVertexAttribOffsetEXT_1(vaobj, buffer, index, size, &type, normalized, stride, offset);
    
    private VertexArrayVertexAttribIOffsetEXT_adr := GetProcAddress('glVertexArrayVertexAttribIOffsetEXT');
    private ntv_VertexArrayVertexAttribIOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; index: UInt32; size: Int32; &type: glVertexAttribType; stride: Int32; offset: IntPtr)>(VertexArrayVertexAttribIOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribIOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; index: UInt32; size: Int32; &type: glVertexAttribType; stride: Int32; offset: IntPtr) :=
      ntv_VertexArrayVertexAttribIOffsetEXT_1(vaobj, buffer, index, size, &type, stride, offset);
    
    private EnableVertexArrayEXT_adr := GetProcAddress('glEnableVertexArrayEXT');
    private ntv_EnableVertexArrayEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; &array: glEnableCap)>(EnableVertexArrayEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexArrayEXT(vaobj: gl_vertex_array; &array: glEnableCap) :=
      ntv_EnableVertexArrayEXT_1(vaobj, &array);
    
    private DisableVertexArrayEXT_adr := GetProcAddress('glDisableVertexArrayEXT');
    private ntv_DisableVertexArrayEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; &array: glEnableCap)>(DisableVertexArrayEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexArrayEXT(vaobj: gl_vertex_array; &array: glEnableCap) :=
      ntv_DisableVertexArrayEXT_1(vaobj, &array);
    
    private EnableVertexArrayAttribEXT_adr := GetProcAddress('glEnableVertexArrayAttribEXT');
    private ntv_EnableVertexArrayAttribEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32)>(EnableVertexArrayAttribEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexArrayAttribEXT(vaobj: gl_vertex_array; index: UInt32) :=
      ntv_EnableVertexArrayAttribEXT_1(vaobj, index);
    
    private DisableVertexArrayAttribEXT_adr := GetProcAddress('glDisableVertexArrayAttribEXT');
    private ntv_DisableVertexArrayAttribEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32)>(DisableVertexArrayAttribEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexArrayAttribEXT(vaobj: gl_vertex_array; index: UInt32) :=
      ntv_DisableVertexArrayAttribEXT_1(vaobj, index);
    
    private GetVertexArrayIntegervEXT_adr := GetProcAddress('glGetVertexArrayIntegervEXT');
    private ntv_GetVertexArrayIntegervEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; pname: glVertexArrayPName; var param: Int32)>(GetVertexArrayIntegervEXT_adr);
    private ntv_GetVertexArrayIntegervEXT_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; pname: glVertexArrayPName; param: IntPtr)>(GetVertexArrayIntegervEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegervEXT(vaobj: gl_vertex_array; pname: glVertexArrayPName; var param: Int32) :=
      ntv_GetVertexArrayIntegervEXT_1(vaobj, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegervEXT(vaobj: gl_vertex_array; pname: glVertexArrayPName; param: IntPtr) :=
      ntv_GetVertexArrayIntegervEXT_2(vaobj, pname, param);
    
    private GetVertexArrayPointervEXT_adr := GetProcAddress('glGetVertexArrayPointervEXT');
    private ntv_GetVertexArrayPointervEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; pname: glVertexArrayPName; var param: IntPtr)>(GetVertexArrayPointervEXT_adr);
    private ntv_GetVertexArrayPointervEXT_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; pname: glVertexArrayPName; param: pointer)>(GetVertexArrayPointervEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointervEXT(vaobj: gl_vertex_array; pname: glVertexArrayPName; var param: IntPtr) :=
      ntv_GetVertexArrayPointervEXT_1(vaobj, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointervEXT(vaobj: gl_vertex_array; pname: glVertexArrayPName; param: pointer) :=
      ntv_GetVertexArrayPointervEXT_2(vaobj, pname, param);
    
    private GetVertexArrayIntegeri_vEXT_adr := GetProcAddress('glGetVertexArrayIntegeri_vEXT');
    private ntv_GetVertexArrayIntegeri_vEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; var param: Int32)>(GetVertexArrayIntegeri_vEXT_adr);
    private ntv_GetVertexArrayIntegeri_vEXT_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; param: IntPtr)>(GetVertexArrayIntegeri_vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegeri_vEXT(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; var param: Int32) :=
      ntv_GetVertexArrayIntegeri_vEXT_1(vaobj, index, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegeri_vEXT(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; param: IntPtr) :=
      ntv_GetVertexArrayIntegeri_vEXT_2(vaobj, index, pname, param);
    
    private GetVertexArrayPointeri_vEXT_adr := GetProcAddress('glGetVertexArrayPointeri_vEXT');
    private ntv_GetVertexArrayPointeri_vEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; var param: IntPtr)>(GetVertexArrayPointeri_vEXT_adr);
    private ntv_GetVertexArrayPointeri_vEXT_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; param: pointer)>(GetVertexArrayPointeri_vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointeri_vEXT(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; var param: IntPtr) :=
      ntv_GetVertexArrayPointeri_vEXT_1(vaobj, index, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointeri_vEXT(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; param: pointer) :=
      ntv_GetVertexArrayPointeri_vEXT_2(vaobj, index, pname, param);
    
    private MapNamedBufferRangeEXT_adr := GetProcAddress('glMapNamedBufferRangeEXT');
    private ntv_MapNamedBufferRangeEXT_1 := GetProcOrNil&<function(buffer: gl_buffer; offset: IntPtr; length: UIntPtr; access: glMapBufferAccessMask): IntPtr>(MapNamedBufferRangeEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapNamedBufferRangeEXT(buffer: gl_buffer; offset: IntPtr; length: UIntPtr; access: glMapBufferAccessMask): IntPtr :=
      ntv_MapNamedBufferRangeEXT_1(buffer, offset, length, access);
    
    private FlushMappedNamedBufferRangeEXT_adr := GetProcAddress('glFlushMappedNamedBufferRangeEXT');
    private ntv_FlushMappedNamedBufferRangeEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; length: UIntPtr)>(FlushMappedNamedBufferRangeEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushMappedNamedBufferRangeEXT(buffer: gl_buffer; offset: IntPtr; length: UIntPtr) :=
      ntv_FlushMappedNamedBufferRangeEXT_1(buffer, offset, length);
    
    private NamedBufferStorageEXT_adr := GetProcAddress('glNamedBufferStorageEXT');
    private ntv_NamedBufferStorageEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; var data: Byte; flags: glBufferStorageMask)>(NamedBufferStorageEXT_adr);
    private ntv_NamedBufferStorageEXT_2 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; data: IntPtr; flags: glBufferStorageMask)>(NamedBufferStorageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorageEXT<T>(buffer: gl_buffer; size: UIntPtr; data: array of T; flags: glBufferStorageMask); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferStorageEXT(buffer, size, data[0], flags) else
        NamedBufferStorageEXT(buffer, size, PT(nil)^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorageEXT<T>(buffer: gl_buffer; size: UIntPtr; var data: T; flags: glBufferStorageMask); where T: record;
    begin
      ntv_NamedBufferStorageEXT_1(buffer, size, PByte(pointer(@data))^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorageEXT(buffer: gl_buffer; size: UIntPtr; data: IntPtr; flags: glBufferStorageMask) :=
      ntv_NamedBufferStorageEXT_2(buffer, size, data, flags);
    
    private ClearNamedBufferDataEXT_adr := GetProcAddress('glClearNamedBufferDataEXT');
    private ntv_ClearNamedBufferDataEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; var data: Byte)>(ClearNamedBufferDataEXT_adr);
    private ntv_ClearNamedBufferDataEXT_2 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; data: IntPtr)>(ClearNamedBufferDataEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferDataEXT<T>(buffer: gl_buffer; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearNamedBufferDataEXT(buffer, internalformat, format, &type, data[0]) else
        ClearNamedBufferDataEXT(buffer, internalformat, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferDataEXT<T>(buffer: gl_buffer; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; var data: T); where T: record;
    begin
      ntv_ClearNamedBufferDataEXT_1(buffer, internalformat, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferDataEXT(buffer: gl_buffer; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; data: IntPtr) :=
      ntv_ClearNamedBufferDataEXT_2(buffer, internalformat, format, &type, data);
    
    private ClearNamedBufferSubDataEXT_adr := GetProcAddress('glClearNamedBufferSubDataEXT');
    private ntv_ClearNamedBufferSubDataEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: glSizedInternalFormat; offset: UIntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; var data: Byte)>(ClearNamedBufferSubDataEXT_adr);
    private ntv_ClearNamedBufferSubDataEXT_2 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: glSizedInternalFormat; offset: UIntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; data: IntPtr)>(ClearNamedBufferSubDataEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubDataEXT<T>(buffer: gl_buffer; internalformat: glSizedInternalFormat; offset: UIntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearNamedBufferSubDataEXT(buffer, internalformat, offset, size, format, &type, data[0]) else
        ClearNamedBufferSubDataEXT(buffer, internalformat, offset, size, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubDataEXT<T>(buffer: gl_buffer; internalformat: glSizedInternalFormat; offset: UIntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; var data: T); where T: record;
    begin
      ntv_ClearNamedBufferSubDataEXT_1(buffer, internalformat, offset, size, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubDataEXT(buffer: gl_buffer; internalformat: glSizedInternalFormat; offset: UIntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; data: IntPtr) :=
      ntv_ClearNamedBufferSubDataEXT_2(buffer, internalformat, offset, size, format, &type, data);
    
    private NamedFramebufferParameteriEXT_adr := GetProcAddress('glNamedFramebufferParameteriEXT');
    private ntv_NamedFramebufferParameteriEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: glFramebufferParameterName; param: Int32)>(NamedFramebufferParameteriEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferParameteriEXT(framebuffer: gl_framebuffer; pname: glFramebufferParameterName; param: Int32) :=
      ntv_NamedFramebufferParameteriEXT_1(framebuffer, pname, param);
    
    private GetNamedFramebufferParameterivEXT_adr := GetProcAddress('glGetNamedFramebufferParameterivEXT');
    private ntv_GetNamedFramebufferParameterivEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: glGetFramebufferParameter; var &params: Int32)>(GetNamedFramebufferParameterivEXT_adr);
    private ntv_GetNamedFramebufferParameterivEXT_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: glGetFramebufferParameter; &params: IntPtr)>(GetNamedFramebufferParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameterivEXT(framebuffer: gl_framebuffer; pname: glGetFramebufferParameter; var &params: Int32) :=
      ntv_GetNamedFramebufferParameterivEXT_1(framebuffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameterivEXT(framebuffer: gl_framebuffer; pname: glGetFramebufferParameter; &params: IntPtr) :=
      ntv_GetNamedFramebufferParameterivEXT_2(framebuffer, pname, &params);
    
    private ProgramUniform1dEXT_adr := GetProcAddress('glProgramUniform1dEXT');
    private ntv_ProgramUniform1dEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: double)>(ProgramUniform1dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dEXT(&program: gl_program; location: Int32; x: double) :=
      ntv_ProgramUniform1dEXT_1(&program, location, x);
    
    private ProgramUniform2dEXT_adr := GetProcAddress('glProgramUniform2dEXT');
    private ntv_ProgramUniform2dEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: double; y: double)>(ProgramUniform2dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dEXT(&program: gl_program; location: Int32; x: double; y: double) :=
      ntv_ProgramUniform2dEXT_1(&program, location, x, y);
    
    private ProgramUniform3dEXT_adr := GetProcAddress('glProgramUniform3dEXT');
    private ntv_ProgramUniform3dEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: double; y: double; z: double)>(ProgramUniform3dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dEXT(&program: gl_program; location: Int32; x: double; y: double; z: double) :=
      ntv_ProgramUniform3dEXT_1(&program, location, x, y, z);
    
    private ProgramUniform4dEXT_adr := GetProcAddress('glProgramUniform4dEXT');
    private ntv_ProgramUniform4dEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: double; y: double; z: double; w: double)>(ProgramUniform4dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dEXT(&program: gl_program; location: Int32; x: double; y: double; z: double; w: double) :=
      ntv_ProgramUniform4dEXT_1(&program, location, x, y, z, w);
    
    private ProgramUniform1dvEXT_adr := GetProcAddress('glProgramUniform1dvEXT');
    private ntv_ProgramUniform1dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: double)>(ProgramUniform1dvEXT_adr);
    private ntv_ProgramUniform1dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dvEXT(&program: gl_program; location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1dvEXT_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1dvEXT_1(&program, location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dvEXT(&program: gl_program; location: Int32; count: Int32; var value: double) :=
      ntv_ProgramUniform1dvEXT_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dvEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1dvEXT_2(&program, location, count, value);
    
    private ProgramUniform2dvEXT_adr := GetProcAddress('glProgramUniform2dvEXT');
    private ntv_ProgramUniform2dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: double)>(ProgramUniform2dvEXT_adr);
    private ntv_ProgramUniform2dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2d)>(ProgramUniform2dvEXT_adr);
    private ntv_ProgramUniform2dvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dvEXT(&program: gl_program; location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2dvEXT_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2dvEXT_1(&program, location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dvEXT(&program: gl_program; location: Int32; count: Int32; var value: Vec2d) :=
      ntv_ProgramUniform2dvEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dvEXT(&program: gl_program; location: Int32; count: Int32; var value: double) :=
      ntv_ProgramUniform2dvEXT_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dvEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2dvEXT_3(&program, location, count, value);
    
    private ProgramUniform3dvEXT_adr := GetProcAddress('glProgramUniform3dvEXT');
    private ntv_ProgramUniform3dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: double)>(ProgramUniform3dvEXT_adr);
    private ntv_ProgramUniform3dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3d)>(ProgramUniform3dvEXT_adr);
    private ntv_ProgramUniform3dvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dvEXT(&program: gl_program; location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3dvEXT_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3dvEXT_1(&program, location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dvEXT(&program: gl_program; location: Int32; count: Int32; var value: Vec3d) :=
      ntv_ProgramUniform3dvEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dvEXT(&program: gl_program; location: Int32; count: Int32; var value: double) :=
      ntv_ProgramUniform3dvEXT_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dvEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3dvEXT_3(&program, location, count, value);
    
    private ProgramUniform4dvEXT_adr := GetProcAddress('glProgramUniform4dvEXT');
    private ntv_ProgramUniform4dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: double)>(ProgramUniform4dvEXT_adr);
    private ntv_ProgramUniform4dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4d)>(ProgramUniform4dvEXT_adr);
    private ntv_ProgramUniform4dvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dvEXT(&program: gl_program; location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4dvEXT_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4dvEXT_1(&program, location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dvEXT(&program: gl_program; location: Int32; count: Int32; var value: Vec4d) :=
      ntv_ProgramUniform4dvEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dvEXT(&program: gl_program; location: Int32; count: Int32; var value: double) :=
      ntv_ProgramUniform4dvEXT_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dvEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4dvEXT_3(&program, location, count, value);
    
    private ProgramUniformMatrix2dvEXT_adr := GetProcAddress('glProgramUniformMatrix2dvEXT');
    private ntv_ProgramUniformMatrix2dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix2dvEXT_adr);
    private ntv_ProgramUniformMatrix2dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2d)>(ProgramUniformMatrix2dvEXT_adr);
    private ntv_ProgramUniformMatrix2dvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2dvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2dvEXT_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2d) :=
      ntv_ProgramUniformMatrix2dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix2dvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2dvEXT_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix3dvEXT_adr := GetProcAddress('glProgramUniformMatrix3dvEXT');
    private ntv_ProgramUniformMatrix3dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix3dvEXT_adr);
    private ntv_ProgramUniformMatrix3dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3d)>(ProgramUniformMatrix3dvEXT_adr);
    private ntv_ProgramUniformMatrix3dvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3dvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3dvEXT_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3d) :=
      ntv_ProgramUniformMatrix3dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix3dvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3dvEXT_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix4dvEXT_adr := GetProcAddress('glProgramUniformMatrix4dvEXT');
    private ntv_ProgramUniformMatrix4dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix4dvEXT_adr);
    private ntv_ProgramUniformMatrix4dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4d)>(ProgramUniformMatrix4dvEXT_adr);
    private ntv_ProgramUniformMatrix4dvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4dvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4dvEXT_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4d) :=
      ntv_ProgramUniformMatrix4dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix4dvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4dvEXT_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix2x3dvEXT_adr := GetProcAddress('glProgramUniformMatrix2x3dvEXT');
    private ntv_ProgramUniformMatrix2x3dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix2x3dvEXT_adr);
    private ntv_ProgramUniformMatrix2x3dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3d)>(ProgramUniformMatrix2x3dvEXT_adr);
    private ntv_ProgramUniformMatrix2x3dvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2x3dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2x3dvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2x3dvEXT_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3d) :=
      ntv_ProgramUniformMatrix2x3dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix2x3dvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2x3dvEXT_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix2x4dvEXT_adr := GetProcAddress('glProgramUniformMatrix2x4dvEXT');
    private ntv_ProgramUniformMatrix2x4dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix2x4dvEXT_adr);
    private ntv_ProgramUniformMatrix2x4dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4d)>(ProgramUniformMatrix2x4dvEXT_adr);
    private ntv_ProgramUniformMatrix2x4dvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2x4dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2x4dvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2x4dvEXT_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4d) :=
      ntv_ProgramUniformMatrix2x4dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix2x4dvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2x4dvEXT_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix3x2dvEXT_adr := GetProcAddress('glProgramUniformMatrix3x2dvEXT');
    private ntv_ProgramUniformMatrix3x2dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix3x2dvEXT_adr);
    private ntv_ProgramUniformMatrix3x2dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2d)>(ProgramUniformMatrix3x2dvEXT_adr);
    private ntv_ProgramUniformMatrix3x2dvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3x2dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3x2dvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3x2dvEXT_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2d) :=
      ntv_ProgramUniformMatrix3x2dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix3x2dvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3x2dvEXT_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix3x4dvEXT_adr := GetProcAddress('glProgramUniformMatrix3x4dvEXT');
    private ntv_ProgramUniformMatrix3x4dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix3x4dvEXT_adr);
    private ntv_ProgramUniformMatrix3x4dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4d)>(ProgramUniformMatrix3x4dvEXT_adr);
    private ntv_ProgramUniformMatrix3x4dvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3x4dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3x4dvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3x4dvEXT_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4d) :=
      ntv_ProgramUniformMatrix3x4dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix3x4dvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3x4dvEXT_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix4x2dvEXT_adr := GetProcAddress('glProgramUniformMatrix4x2dvEXT');
    private ntv_ProgramUniformMatrix4x2dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix4x2dvEXT_adr);
    private ntv_ProgramUniformMatrix4x2dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2d)>(ProgramUniformMatrix4x2dvEXT_adr);
    private ntv_ProgramUniformMatrix4x2dvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4x2dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4x2dvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4x2dvEXT_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2d) :=
      ntv_ProgramUniformMatrix4x2dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix4x2dvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4x2dvEXT_3(&program, location, count, transpose, value);
    
    private ProgramUniformMatrix4x3dvEXT_adr := GetProcAddress('glProgramUniformMatrix4x3dvEXT');
    private ntv_ProgramUniformMatrix4x3dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix4x3dvEXT_adr);
    private ntv_ProgramUniformMatrix4x3dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3d)>(ProgramUniformMatrix4x3dvEXT_adr);
    private ntv_ProgramUniformMatrix4x3dvEXT_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4x3dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4x3dvEXT_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4x3dvEXT_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3d) :=
      ntv_ProgramUniformMatrix4x3dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix4x3dvEXT_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4x3dvEXT_3(&program, location, count, transpose, value);
    
    private TextureBufferRangeEXT_adr := GetProcAddress('glTextureBufferRangeEXT');
    private ntv_TextureBufferRangeEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; internalformat: glSizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(TextureBufferRangeEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBufferRangeEXT(texture: gl_texture; target: glTextureTarget; internalformat: glSizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
      ntv_TextureBufferRangeEXT_1(texture, target, internalformat, buffer, offset, size);
    
    private TextureStorage1DEXT_adr := GetProcAddress('glTextureStorage1DEXT');
    private ntv_TextureStorage1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32)>(TextureStorage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage1DEXT(texture: gl_texture; target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32) :=
      ntv_TextureStorage1DEXT_1(texture, target, levels, internalformat, width);
    
    private TextureStorage2DEXT_adr := GetProcAddress('glTextureStorage2DEXT');
    private ntv_TextureStorage2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32)>(TextureStorage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2DEXT(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32) :=
      ntv_TextureStorage2DEXT_1(texture, target, levels, internalformat, width, height);
    
    private TextureStorage3DEXT_adr := GetProcAddress('glTextureStorage3DEXT');
    private ntv_TextureStorage3DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32)>(TextureStorage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3DEXT(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32) :=
      ntv_TextureStorage3DEXT_1(texture, target, levels, internalformat, width, height, depth);
    
    private TextureStorage2DMultisampleEXT_adr := GetProcAddress('glTextureStorage2DMultisampleEXT');
    private ntv_TextureStorage2DMultisampleEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: glBool8)>(TextureStorage2DMultisampleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2DMultisampleEXT(texture: gl_texture; target: glTextureTarget; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: glBool8) :=
      ntv_TextureStorage2DMultisampleEXT_1(texture, target, samples, internalformat, width, height, fixedsamplelocations);
    
    private TextureStorage3DMultisampleEXT_adr := GetProcAddress('glTextureStorage3DMultisampleEXT');
    private ntv_TextureStorage3DMultisampleEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: DummyEnum; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: glBool8)>(TextureStorage3DMultisampleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3DMultisampleEXT(texture: gl_texture; target: DummyEnum; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: glBool8) :=
      ntv_TextureStorage3DMultisampleEXT_1(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
    
    private VertexArrayBindVertexBufferEXT_adr := GetProcAddress('glVertexArrayBindVertexBufferEXT');
    private ntv_VertexArrayBindVertexBufferEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32)>(VertexArrayBindVertexBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayBindVertexBufferEXT(vaobj: gl_vertex_array; bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32) :=
      ntv_VertexArrayBindVertexBufferEXT_1(vaobj, bindingindex, buffer, offset, stride);
    
    private VertexArrayVertexAttribFormatEXT_adr := GetProcAddress('glVertexArrayVertexAttribFormatEXT');
    private ntv_VertexArrayVertexAttribFormatEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribType; normalized: glBool8; relativeoffset: UInt32)>(VertexArrayVertexAttribFormatEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribFormatEXT(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribType; normalized: glBool8; relativeoffset: UInt32) :=
      ntv_VertexArrayVertexAttribFormatEXT_1(vaobj, attribindex, size, &type, normalized, relativeoffset);
    
    private VertexArrayVertexAttribIFormatEXT_adr := GetProcAddress('glVertexArrayVertexAttribIFormatEXT');
    private ntv_VertexArrayVertexAttribIFormatEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribIType; relativeoffset: UInt32)>(VertexArrayVertexAttribIFormatEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribIFormatEXT(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribIType; relativeoffset: UInt32) :=
      ntv_VertexArrayVertexAttribIFormatEXT_1(vaobj, attribindex, size, &type, relativeoffset);
    
    private VertexArrayVertexAttribLFormatEXT_adr := GetProcAddress('glVertexArrayVertexAttribLFormatEXT');
    private ntv_VertexArrayVertexAttribLFormatEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribLType; relativeoffset: UInt32)>(VertexArrayVertexAttribLFormatEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribLFormatEXT(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribLType; relativeoffset: UInt32) :=
      ntv_VertexArrayVertexAttribLFormatEXT_1(vaobj, attribindex, size, &type, relativeoffset);
    
    private VertexArrayVertexAttribBindingEXT_adr := GetProcAddress('glVertexArrayVertexAttribBindingEXT');
    private ntv_VertexArrayVertexAttribBindingEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; bindingindex: UInt32)>(VertexArrayVertexAttribBindingEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribBindingEXT(vaobj: gl_vertex_array; attribindex: UInt32; bindingindex: UInt32) :=
      ntv_VertexArrayVertexAttribBindingEXT_1(vaobj, attribindex, bindingindex);
    
    private VertexArrayVertexBindingDivisorEXT_adr := GetProcAddress('glVertexArrayVertexBindingDivisorEXT');
    private ntv_VertexArrayVertexBindingDivisorEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; bindingindex: UInt32; divisor: UInt32)>(VertexArrayVertexBindingDivisorEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBindingDivisorEXT(vaobj: gl_vertex_array; bindingindex: UInt32; divisor: UInt32) :=
      ntv_VertexArrayVertexBindingDivisorEXT_1(vaobj, bindingindex, divisor);
    
    private VertexArrayVertexAttribLOffsetEXT_adr := GetProcAddress('glVertexArrayVertexAttribLOffsetEXT');
    private ntv_VertexArrayVertexAttribLOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; index: UInt32; size: Int32; &type: glVertexAttribLType; stride: Int32; offset: IntPtr)>(VertexArrayVertexAttribLOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribLOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; index: UInt32; size: Int32; &type: glVertexAttribLType; stride: Int32; offset: IntPtr) :=
      ntv_VertexArrayVertexAttribLOffsetEXT_1(vaobj, buffer, index, size, &type, stride, offset);
    
    private TexturePageCommitmentEXT_adr := GetProcAddress('glTexturePageCommitmentEXT');
    private ntv_TexturePageCommitmentEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: glBool8)>(TexturePageCommitmentEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexturePageCommitmentEXT(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: glBool8) :=
      ntv_TexturePageCommitmentEXT_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    
    private VertexArrayVertexAttribDivisorEXT_adr := GetProcAddress('glVertexArrayVertexAttribDivisorEXT');
    private ntv_VertexArrayVertexAttribDivisorEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; divisor: UInt32)>(VertexArrayVertexAttribDivisorEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribDivisorEXT(vaobj: gl_vertex_array; index: UInt32; divisor: UInt32) :=
      ntv_VertexArrayVertexAttribDivisorEXT_1(vaobj, index, divisor);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDrawBuffers2EXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_draw_buffers2';
    
    private ColorMaskIndexedEXT_adr := GetProcAddress('glColorMaskIndexedEXT');
    private ntv_ColorMaskIndexedEXT_1 := GetProcOrNil&<procedure(index: UInt32; r: glBool8; g: glBool8; b: glBool8; a: glBool8)>(ColorMaskIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorMaskIndexedEXT(index: UInt32; r: glBool8; g: glBool8; b: glBool8; a: glBool8) :=
      ntv_ColorMaskIndexedEXT_1(index, r, g, b, a);
    
    private GetBooleanIndexedvEXT_adr := GetProcAddress('glGetBooleanIndexedvEXT');
    private ntv_GetBooleanIndexedvEXT_1 := GetProcOrNil&<procedure(target: glBufferTarget; index: UInt32; var data: glBool8)>(GetBooleanIndexedvEXT_adr);
    private ntv_GetBooleanIndexedvEXT_2 := GetProcOrNil&<procedure(target: glBufferTarget; index: UInt32; data: IntPtr)>(GetBooleanIndexedvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanIndexedvEXT(target: glBufferTarget; index: UInt32; var data: glBool8) :=
      ntv_GetBooleanIndexedvEXT_1(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanIndexedvEXT(target: glBufferTarget; index: UInt32; data: IntPtr) :=
      ntv_GetBooleanIndexedvEXT_2(target, index, data);
    
    private GetIntegerIndexedvEXT_adr := GetProcAddress('glGetIntegerIndexedvEXT');
    private ntv_GetIntegerIndexedvEXT_1 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; var data: Int32)>(GetIntegerIndexedvEXT_adr);
    private ntv_GetIntegerIndexedvEXT_2 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; data: IntPtr)>(GetIntegerIndexedvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerIndexedvEXT(target: glGetPName; index: UInt32; var data: Int32) :=
      ntv_GetIntegerIndexedvEXT_1(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerIndexedvEXT(target: glGetPName; index: UInt32; data: IntPtr) :=
      ntv_GetIntegerIndexedvEXT_2(target, index, data);
    
    private EnableIndexedEXT_adr := GetProcAddress('glEnableIndexedEXT');
    private ntv_EnableIndexedEXT_1 := GetProcOrNil&<procedure(target: glEnableCap; index: UInt32)>(EnableIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableIndexedEXT(target: glEnableCap; index: UInt32) :=
      ntv_EnableIndexedEXT_1(target, index);
    
    private DisableIndexedEXT_adr := GetProcAddress('glDisableIndexedEXT');
    private ntv_DisableIndexedEXT_1 := GetProcOrNil&<procedure(target: glEnableCap; index: UInt32)>(DisableIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableIndexedEXT(target: glEnableCap; index: UInt32) :=
      ntv_DisableIndexedEXT_1(target, index);
    
    private IsEnabledIndexedEXT_adr := GetProcAddress('glIsEnabledIndexedEXT');
    private ntv_IsEnabledIndexedEXT_1 := GetProcOrNil&<function(target: glEnableCap; index: UInt32): glBool8>(IsEnabledIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledIndexedEXT(target: glEnableCap; index: UInt32): glBool8 :=
      ntv_IsEnabledIndexedEXT_1(target, index);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDrawInstancedEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_draw_instanced';
    
    private DrawArraysInstancedEXT_adr := GetProcAddress('glDrawArraysInstancedEXT');
    private ntv_DrawArraysInstancedEXT_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; start: Int32; count: Int32; primcount: Int32)>(DrawArraysInstancedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysInstancedEXT(mode: glPrimitiveType; start: Int32; count: Int32; primcount: Int32) :=
      ntv_DrawArraysInstancedEXT_1(mode, start, count, primcount);
    
    private DrawElementsInstancedEXT_adr := GetProcAddress('glDrawElementsInstancedEXT');
    private ntv_DrawElementsInstancedEXT_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; primcount: Int32)>(DrawElementsInstancedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedEXT(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; primcount: Int32) :=
      ntv_DrawElementsInstancedEXT_1(mode, count, &type, indices, primcount);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDrawRangeElementsEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_draw_range_elements';
    
    private DrawRangeElementsEXT_adr := GetProcAddress('glDrawRangeElementsEXT');
    private ntv_DrawRangeElementsEXT_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: glDrawElementsType; indices: IntPtr)>(DrawRangeElementsEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementsEXT(mode: glPrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: glDrawElementsType; indices: IntPtr) :=
      ntv_DrawRangeElementsEXT_1(mode, start, &end, count, &type, indices);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glEGLImageStorageEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_EGL_image_storage';
    
    private EGLImageTargetTexStorageEXT_adr := GetProcAddress('glEGLImageTargetTexStorageEXT');
    private ntv_EGLImageTargetTexStorageEXT_1 := GetProcOrNil&<procedure(target: DummyEnum; image: gles_image; var attrib_list: Int32)>(EGLImageTargetTexStorageEXT_adr);
    private ntv_EGLImageTargetTexStorageEXT_2 := GetProcOrNil&<procedure(target: DummyEnum; image: gles_image; attrib_list: IntPtr)>(EGLImageTargetTexStorageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTexStorageEXT(target: DummyEnum; image: gles_image; attrib_list: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (attrib_list<>nil) and (attrib_list.Length<>0) then
        ntv_EGLImageTargetTexStorageEXT_1(target, image, attrib_list[0]) else
        ntv_EGLImageTargetTexStorageEXT_1(target, image, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTexStorageEXT(target: DummyEnum; image: gles_image; var attrib_list: Int32) :=
      ntv_EGLImageTargetTexStorageEXT_1(target, image, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTexStorageEXT(target: DummyEnum; image: gles_image; attrib_list: IntPtr) :=
      ntv_EGLImageTargetTexStorageEXT_2(target, image, attrib_list);
    
    private EGLImageTargetTextureStorageEXT_adr := GetProcAddress('glEGLImageTargetTextureStorageEXT');
    private ntv_EGLImageTargetTextureStorageEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; image: gles_image; var attrib_list: Int32)>(EGLImageTargetTextureStorageEXT_adr);
    private ntv_EGLImageTargetTextureStorageEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; image: gles_image; attrib_list: IntPtr)>(EGLImageTargetTextureStorageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTextureStorageEXT(texture: gl_texture; image: gles_image; attrib_list: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (attrib_list<>nil) and (attrib_list.Length<>0) then
        ntv_EGLImageTargetTextureStorageEXT_1(texture, image, attrib_list[0]) else
        ntv_EGLImageTargetTextureStorageEXT_1(texture, image, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTextureStorageEXT(texture: gl_texture; image: gles_image; var attrib_list: Int32) :=
      ntv_EGLImageTargetTextureStorageEXT_1(texture, image, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTextureStorageEXT(texture: gl_texture; image: gles_image; attrib_list: IntPtr) :=
      ntv_EGLImageTargetTextureStorageEXT_2(texture, image, attrib_list);
    
  end;
  
  ///
  glEGLSyncEXT = static class
    public const _ExtStr = 'GL_EXT_EGL_sync';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glExternalBufferEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_external_buffer';
    
    private BufferStorageExternalEXT_adr := GetProcAddress('glBufferStorageExternalEXT');
    private ntv_BufferStorageExternalEXT_1 := GetProcOrNil&<procedure(target: DummyEnum; offset: IntPtr; size: UIntPtr; clientBuffer: gles_client_buffer_EXT; flags: glBufferStorageMask)>(BufferStorageExternalEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorageExternalEXT(target: DummyEnum; offset: IntPtr; size: UIntPtr; clientBuffer: gles_client_buffer_EXT; flags: glBufferStorageMask) :=
      ntv_BufferStorageExternalEXT_1(target, offset, size, clientBuffer, flags);
    
    private NamedBufferStorageExternalEXT_adr := GetProcAddress('glNamedBufferStorageExternalEXT');
    private ntv_NamedBufferStorageExternalEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; clientBuffer: gles_client_buffer_EXT; flags: glBufferStorageMask)>(NamedBufferStorageExternalEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorageExternalEXT(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; clientBuffer: gles_client_buffer_EXT; flags: glBufferStorageMask) :=
      ntv_NamedBufferStorageExternalEXT_1(buffer, offset, size, clientBuffer, flags);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFogCoordEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_fog_coord';
    
    private FogCoordfEXT_adr := GetProcAddress('glFogCoordfEXT');
    private ntv_FogCoordfEXT_1 := GetProcOrNil&<procedure(coord: single)>(FogCoordfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfEXT(coord: single) :=
      ntv_FogCoordfEXT_1(coord);
    
    private FogCoordfvEXT_adr := GetProcAddress('glFogCoordfvEXT');
    private ntv_FogCoordfvEXT_1 := GetProcOrNil&<procedure(var coord: single)>(FogCoordfvEXT_adr);
    private ntv_FogCoordfvEXT_2 := GetProcOrNil&<procedure(coord: IntPtr)>(FogCoordfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfvEXT(coord: array of single);
    type PSingle = ^single;
    begin
      if (coord<>nil) and (coord.Length<>0) then
        ntv_FogCoordfvEXT_1(coord[0]) else
        ntv_FogCoordfvEXT_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfvEXT(var coord: single) :=
      ntv_FogCoordfvEXT_1(coord);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfvEXT(coord: IntPtr) :=
      ntv_FogCoordfvEXT_2(coord);
    
    private FogCoorddEXT_adr := GetProcAddress('glFogCoorddEXT');
    private ntv_FogCoorddEXT_1 := GetProcOrNil&<procedure(coord: double)>(FogCoorddEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddEXT(coord: double) :=
      ntv_FogCoorddEXT_1(coord);
    
    private FogCoorddvEXT_adr := GetProcAddress('glFogCoorddvEXT');
    private ntv_FogCoorddvEXT_1 := GetProcOrNil&<procedure(var coord: double)>(FogCoorddvEXT_adr);
    private ntv_FogCoorddvEXT_2 := GetProcOrNil&<procedure(coord: IntPtr)>(FogCoorddvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddvEXT(coord: array of double);
    type PDouble = ^double;
    begin
      if (coord<>nil) and (coord.Length<>0) then
        ntv_FogCoorddvEXT_1(coord[0]) else
        ntv_FogCoorddvEXT_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddvEXT(var coord: double) :=
      ntv_FogCoorddvEXT_1(coord);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddvEXT(coord: IntPtr) :=
      ntv_FogCoorddvEXT_2(coord);
    
    private FogCoordPointerEXT_adr := GetProcAddress('glFogCoordPointerEXT');
    private ntv_FogCoordPointerEXT_1 := GetProcOrNil&<procedure(&type: glFogPointerType; stride: Int32; pointer: IntPtr)>(FogCoordPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointerEXT(&type: glFogPointerType; stride: Int32; pointer: IntPtr) :=
      ntv_FogCoordPointerEXT_1(&type, stride, pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFramebufferBlitEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_framebuffer_blit';
    
    private BlitFramebufferEXT_adr := GetProcAddress('glBlitFramebufferEXT');
    private ntv_BlitFramebufferEXT_1 := GetProcOrNil&<procedure(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: glClearBufferMask; filter: glBlitFramebufferFilter)>(BlitFramebufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitFramebufferEXT(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: glClearBufferMask; filter: glBlitFramebufferFilter) :=
      ntv_BlitFramebufferEXT_1(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFramebufferBlitLayersEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_framebuffer_blit_layers';
    
    private BlitFramebufferLayersEXT_adr := GetProcAddress('glBlitFramebufferLayersEXT');
    private ntv_BlitFramebufferLayersEXT_1 := GetProcOrNil&<procedure(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: glClearBufferMask; filter: glBlitFramebufferFilter)>(BlitFramebufferLayersEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitFramebufferLayersEXT(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: glClearBufferMask; filter: glBlitFramebufferFilter) :=
      ntv_BlitFramebufferLayersEXT_1(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    private BlitFramebufferLayerEXT_adr := GetProcAddress('glBlitFramebufferLayerEXT');
    private ntv_BlitFramebufferLayerEXT_1 := GetProcOrNil&<procedure(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; srcLayer: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; dstLayer: Int32; mask: glClearBufferMask; filter: glBlitFramebufferFilter)>(BlitFramebufferLayerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitFramebufferLayerEXT(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; srcLayer: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; dstLayer: Int32; mask: glClearBufferMask; filter: glBlitFramebufferFilter) :=
      ntv_BlitFramebufferLayerEXT_1(srcX0, srcY0, srcX1, srcY1, srcLayer, dstX0, dstY0, dstX1, dstY1, dstLayer, mask, filter);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFramebufferMultisampleEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_framebuffer_multisample';
    
    private RenderbufferStorageMultisampleEXT_adr := GetProcAddress('glRenderbufferStorageMultisampleEXT');
    private ntv_RenderbufferStorageMultisampleEXT_1 := GetProcOrNil&<procedure(target: glRenderbufferTarget; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32)>(RenderbufferStorageMultisampleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisampleEXT(target: glRenderbufferTarget; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32) :=
      ntv_RenderbufferStorageMultisampleEXT_1(target, samples, internalformat, width, height);
    
  end;
  
  ///
  glFramebufferMultisampleBlitScaledEXT = static class
    public const _ExtStr = 'GL_EXT_framebuffer_multisample_blit_scaled';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFramebufferObjectEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_framebuffer_object';
    
    private IsRenderbufferEXT_adr := GetProcAddress('glIsRenderbufferEXT');
    private ntv_IsRenderbufferEXT_1 := GetProcOrNil&<function(renderbuffer: gl_renderbuffer): glBool8>(IsRenderbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsRenderbufferEXT(renderbuffer: gl_renderbuffer): glBool8 :=
      ntv_IsRenderbufferEXT_1(renderbuffer);
    
    private BindRenderbufferEXT_adr := GetProcAddress('glBindRenderbufferEXT');
    private ntv_BindRenderbufferEXT_1 := GetProcOrNil&<procedure(target: glRenderbufferTarget; renderbuffer: gl_renderbuffer)>(BindRenderbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindRenderbufferEXT(target: glRenderbufferTarget; renderbuffer: gl_renderbuffer) :=
      ntv_BindRenderbufferEXT_1(target, renderbuffer);
    
    private DeleteRenderbuffersEXT_adr := GetProcAddress('glDeleteRenderbuffersEXT');
    private ntv_DeleteRenderbuffersEXT_1 := GetProcOrNil&<procedure(n: Int32; var renderbuffers: gl_renderbuffer)>(DeleteRenderbuffersEXT_adr);
    private ntv_DeleteRenderbuffersEXT_2 := GetProcOrNil&<procedure(n: Int32; renderbuffers: IntPtr)>(DeleteRenderbuffersEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffersEXT(n: Int32; renderbuffers: array of gl_renderbuffer);
    type PGl_renderbuffer = ^gl_renderbuffer;
    begin
      if (renderbuffers<>nil) and (renderbuffers.Length<>0) then
        ntv_DeleteRenderbuffersEXT_1(n, renderbuffers[0]) else
        ntv_DeleteRenderbuffersEXT_1(n, PGl_renderbuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffersEXT(n: Int32; var renderbuffers: gl_renderbuffer) :=
      ntv_DeleteRenderbuffersEXT_1(n, renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffersEXT(n: Int32; renderbuffers: IntPtr) :=
      ntv_DeleteRenderbuffersEXT_2(n, renderbuffers);
    
    private GenRenderbuffersEXT_adr := GetProcAddress('glGenRenderbuffersEXT');
    private ntv_GenRenderbuffersEXT_1 := GetProcOrNil&<procedure(n: Int32; var renderbuffers: gl_renderbuffer)>(GenRenderbuffersEXT_adr);
    private ntv_GenRenderbuffersEXT_2 := GetProcOrNil&<procedure(n: Int32; renderbuffers: IntPtr)>(GenRenderbuffersEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffersEXT(n: Int32; renderbuffers: array of gl_renderbuffer);
    type PGl_renderbuffer = ^gl_renderbuffer;
    begin
      if (renderbuffers<>nil) and (renderbuffers.Length<>0) then
        ntv_GenRenderbuffersEXT_1(n, renderbuffers[0]) else
        ntv_GenRenderbuffersEXT_1(n, PGl_renderbuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffersEXT(n: Int32; var renderbuffers: gl_renderbuffer) :=
      ntv_GenRenderbuffersEXT_1(n, renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffersEXT(n: Int32; renderbuffers: IntPtr) :=
      ntv_GenRenderbuffersEXT_2(n, renderbuffers);
    
    private RenderbufferStorageEXT_adr := GetProcAddress('glRenderbufferStorageEXT');
    private ntv_RenderbufferStorageEXT_1 := GetProcOrNil&<procedure(target: glRenderbufferTarget; internalformat: glInternalFormat; width: Int32; height: Int32)>(RenderbufferStorageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageEXT(target: glRenderbufferTarget; internalformat: glInternalFormat; width: Int32; height: Int32) :=
      ntv_RenderbufferStorageEXT_1(target, internalformat, width, height);
    
    private GetRenderbufferParameterivEXT_adr := GetProcAddress('glGetRenderbufferParameterivEXT');
    private ntv_GetRenderbufferParameterivEXT_1 := GetProcOrNil&<procedure(target: glRenderbufferTarget; pname: glRenderbufferParameterName; var &params: Int32)>(GetRenderbufferParameterivEXT_adr);
    private ntv_GetRenderbufferParameterivEXT_2 := GetProcOrNil&<procedure(target: glRenderbufferTarget; pname: glRenderbufferParameterName; &params: IntPtr)>(GetRenderbufferParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameterivEXT(target: glRenderbufferTarget; pname: glRenderbufferParameterName; var &params: Int32) :=
      ntv_GetRenderbufferParameterivEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameterivEXT(target: glRenderbufferTarget; pname: glRenderbufferParameterName; &params: IntPtr) :=
      ntv_GetRenderbufferParameterivEXT_2(target, pname, &params);
    
    private IsFramebufferEXT_adr := GetProcAddress('glIsFramebufferEXT');
    private ntv_IsFramebufferEXT_1 := GetProcOrNil&<function(framebuffer: gl_framebuffer): glBool8>(IsFramebufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsFramebufferEXT(framebuffer: gl_framebuffer): glBool8 :=
      ntv_IsFramebufferEXT_1(framebuffer);
    
    private BindFramebufferEXT_adr := GetProcAddress('glBindFramebufferEXT');
    private ntv_BindFramebufferEXT_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; framebuffer: gl_framebuffer)>(BindFramebufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFramebufferEXT(target: glFramebufferTarget; framebuffer: gl_framebuffer) :=
      ntv_BindFramebufferEXT_1(target, framebuffer);
    
    private DeleteFramebuffersEXT_adr := GetProcAddress('glDeleteFramebuffersEXT');
    private ntv_DeleteFramebuffersEXT_1 := GetProcOrNil&<procedure(n: Int32; var framebuffers: gl_framebuffer)>(DeleteFramebuffersEXT_adr);
    private ntv_DeleteFramebuffersEXT_2 := GetProcOrNil&<procedure(n: Int32; framebuffers: IntPtr)>(DeleteFramebuffersEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffersEXT(n: Int32; framebuffers: array of gl_framebuffer);
    type PGl_framebuffer = ^gl_framebuffer;
    begin
      if (framebuffers<>nil) and (framebuffers.Length<>0) then
        ntv_DeleteFramebuffersEXT_1(n, framebuffers[0]) else
        ntv_DeleteFramebuffersEXT_1(n, PGl_framebuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffersEXT(n: Int32; var framebuffers: gl_framebuffer) :=
      ntv_DeleteFramebuffersEXT_1(n, framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffersEXT(n: Int32; framebuffers: IntPtr) :=
      ntv_DeleteFramebuffersEXT_2(n, framebuffers);
    
    private GenFramebuffersEXT_adr := GetProcAddress('glGenFramebuffersEXT');
    private ntv_GenFramebuffersEXT_1 := GetProcOrNil&<procedure(n: Int32; var framebuffers: gl_framebuffer)>(GenFramebuffersEXT_adr);
    private ntv_GenFramebuffersEXT_2 := GetProcOrNil&<procedure(n: Int32; framebuffers: IntPtr)>(GenFramebuffersEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffersEXT(n: Int32; framebuffers: array of gl_framebuffer);
    type PGl_framebuffer = ^gl_framebuffer;
    begin
      if (framebuffers<>nil) and (framebuffers.Length<>0) then
        ntv_GenFramebuffersEXT_1(n, framebuffers[0]) else
        ntv_GenFramebuffersEXT_1(n, PGl_framebuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffersEXT(n: Int32; var framebuffers: gl_framebuffer) :=
      ntv_GenFramebuffersEXT_1(n, framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffersEXT(n: Int32; framebuffers: IntPtr) :=
      ntv_GenFramebuffersEXT_2(n, framebuffers);
    
    private CheckFramebufferStatusEXT_adr := GetProcAddress('glCheckFramebufferStatusEXT');
    private ntv_CheckFramebufferStatusEXT_1 := GetProcOrNil&<function(target: glFramebufferTarget): glFramebufferStatus>(CheckFramebufferStatusEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CheckFramebufferStatusEXT(target: glFramebufferTarget): glFramebufferStatus :=
      ntv_CheckFramebufferStatusEXT_1(target);
    
    private FramebufferTexture1DEXT_adr := GetProcAddress('glFramebufferTexture1DEXT');
    private ntv_FramebufferTexture1DEXT_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32)>(FramebufferTexture1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture1DEXT(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32) :=
      ntv_FramebufferTexture1DEXT_1(target, attachment, textarget, texture, level);
    
    private FramebufferTexture2DEXT_adr := GetProcAddress('glFramebufferTexture2DEXT');
    private ntv_FramebufferTexture2DEXT_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32)>(FramebufferTexture2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture2DEXT(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32) :=
      ntv_FramebufferTexture2DEXT_1(target, attachment, textarget, texture, level);
    
    private FramebufferTexture3DEXT_adr := GetProcAddress('glFramebufferTexture3DEXT');
    private ntv_FramebufferTexture3DEXT_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32; zoffset: Int32)>(FramebufferTexture3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture3DEXT(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32; zoffset: Int32) :=
      ntv_FramebufferTexture3DEXT_1(target, attachment, textarget, texture, level, zoffset);
    
    private FramebufferRenderbufferEXT_adr := GetProcAddress('glFramebufferRenderbufferEXT');
    private ntv_FramebufferRenderbufferEXT_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; renderbuffertarget: glRenderbufferTarget; renderbuffer: gl_renderbuffer)>(FramebufferRenderbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferRenderbufferEXT(target: glFramebufferTarget; attachment: glFramebufferAttachment; renderbuffertarget: glRenderbufferTarget; renderbuffer: gl_renderbuffer) :=
      ntv_FramebufferRenderbufferEXT_1(target, attachment, renderbuffertarget, renderbuffer);
    
    private GetFramebufferAttachmentParameterivEXT_adr := GetProcAddress('glGetFramebufferAttachmentParameterivEXT');
    private ntv_GetFramebufferAttachmentParameterivEXT_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; var &params: Int32)>(GetFramebufferAttachmentParameterivEXT_adr);
    private ntv_GetFramebufferAttachmentParameterivEXT_2 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; &params: IntPtr)>(GetFramebufferAttachmentParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameterivEXT(target: glFramebufferTarget; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; var &params: Int32) :=
      ntv_GetFramebufferAttachmentParameterivEXT_1(target, attachment, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameterivEXT(target: glFramebufferTarget; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; &params: IntPtr) :=
      ntv_GetFramebufferAttachmentParameterivEXT_2(target, attachment, pname, &params);
    
    private GenerateMipmapEXT_adr := GetProcAddress('glGenerateMipmapEXT');
    private ntv_GenerateMipmapEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget)>(GenerateMipmapEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateMipmapEXT(target: glTextureTarget) :=
      ntv_GenerateMipmapEXT_1(target);
    
  end;
  
  ///
  glFramebufferSRGBEXT = static class
    public const _ExtStr = 'GL_EXT_framebuffer_sRGB';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glGeometryShader4EXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_geometry_shader4';
    
    private ProgramParameteriEXT_adr := GetProcAddress('glProgramParameteriEXT');
    private ntv_ProgramParameteriEXT_1 := GetProcOrNil&<procedure(&program: gl_program; pname: glProgramParameterPName; value: Int32)>(ProgramParameteriEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameteriEXT(&program: gl_program; pname: glProgramParameterPName; value: Int32) :=
      ntv_ProgramParameteriEXT_1(&program, pname, value);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glGpuProgramParametersEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_gpu_program_parameters';
    
    private ProgramEnvParameters4fvEXT_adr := GetProcAddress('glProgramEnvParameters4fvEXT');
    private ntv_ProgramEnvParameters4fvEXT_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; var &params: single)>(ProgramEnvParameters4fvEXT_adr);
    private ntv_ProgramEnvParameters4fvEXT_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4f)>(ProgramEnvParameters4fvEXT_adr);
    private ntv_ProgramEnvParameters4fvEXT_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(ProgramEnvParameters4fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameters4fvEXT(target: glProgramTarget; index: UInt32; count: Int32; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramEnvParameters4fvEXT_1(target, index, count, &params[0]) else
        ntv_ProgramEnvParameters4fvEXT_1(target, index, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameters4fvEXT(target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4f) :=
      ntv_ProgramEnvParameters4fvEXT_2(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameters4fvEXT(target: glProgramTarget; index: UInt32; count: Int32; var &params: single) :=
      ntv_ProgramEnvParameters4fvEXT_1(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameters4fvEXT(target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
      ntv_ProgramEnvParameters4fvEXT_3(target, index, count, &params);
    
    private ProgramLocalParameters4fvEXT_adr := GetProcAddress('glProgramLocalParameters4fvEXT');
    private ntv_ProgramLocalParameters4fvEXT_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; var &params: single)>(ProgramLocalParameters4fvEXT_adr);
    private ntv_ProgramLocalParameters4fvEXT_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4f)>(ProgramLocalParameters4fvEXT_adr);
    private ntv_ProgramLocalParameters4fvEXT_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(ProgramLocalParameters4fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameters4fvEXT(target: glProgramTarget; index: UInt32; count: Int32; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramLocalParameters4fvEXT_1(target, index, count, &params[0]) else
        ntv_ProgramLocalParameters4fvEXT_1(target, index, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameters4fvEXT(target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4f) :=
      ntv_ProgramLocalParameters4fvEXT_2(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameters4fvEXT(target: glProgramTarget; index: UInt32; count: Int32; var &params: single) :=
      ntv_ProgramLocalParameters4fvEXT_1(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameters4fvEXT(target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
      ntv_ProgramLocalParameters4fvEXT_3(target, index, count, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glGpuShader4EXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_gpu_shader4';
    
    private GetUniformuivEXT_adr := GetProcAddress('glGetUniformuivEXT');
    private ntv_GetUniformuivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: UInt32)>(GetUniformuivEXT_adr);
    private ntv_GetUniformuivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(GetUniformuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformuivEXT(&program: gl_program; location: Int32; var &params: UInt32) :=
      ntv_GetUniformuivEXT_1(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformuivEXT(&program: gl_program; location: Int32; &params: IntPtr) :=
      ntv_GetUniformuivEXT_2(&program, location, &params);
    
    private BindFragDataLocationEXT_adr := GetProcAddress('glBindFragDataLocationEXT');
    private ntv_BindFragDataLocationEXT_1 := GetProcOrNil&<procedure(&program: gl_program; color: UInt32; name: IntPtr)>(BindFragDataLocationEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationEXT(&program: gl_program; color: UInt32; name: string);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_BindFragDataLocationEXT_1(&program, color, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationEXT(&program: gl_program; color: UInt32; name: IntPtr) :=
      ntv_BindFragDataLocationEXT_1(&program, color, name);
    
    private GetFragDataLocationEXT_adr := GetProcAddress('glGetFragDataLocationEXT');
    private ntv_GetFragDataLocationEXT_1 := GetProcOrNil&<function(&program: gl_program; name: IntPtr): Int32>(GetFragDataLocationEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataLocationEXT(&program: gl_program; name: string): Int32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetFragDataLocationEXT_1(&program, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataLocationEXT(&program: gl_program; name: IntPtr): Int32 :=
      ntv_GetFragDataLocationEXT_1(&program, name);
    
    private Uniform1uiEXT_adr := GetProcAddress('glUniform1uiEXT');
    private ntv_Uniform1uiEXT_1 := GetProcOrNil&<procedure(location: Int32; v0: UInt32)>(Uniform1uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uiEXT(location: Int32; v0: UInt32) :=
      ntv_Uniform1uiEXT_1(location, v0);
    
    private Uniform2uiEXT_adr := GetProcAddress('glUniform2uiEXT');
    private ntv_Uniform2uiEXT_1 := GetProcOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32)>(Uniform2uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uiEXT(location: Int32; v0: UInt32; v1: UInt32) :=
      ntv_Uniform2uiEXT_1(location, v0, v1);
    
    private Uniform3uiEXT_adr := GetProcAddress('glUniform3uiEXT');
    private ntv_Uniform3uiEXT_1 := GetProcOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32)>(Uniform3uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uiEXT(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32) :=
      ntv_Uniform3uiEXT_1(location, v0, v1, v2);
    
    private Uniform4uiEXT_adr := GetProcAddress('glUniform4uiEXT');
    private ntv_Uniform4uiEXT_1 := GetProcOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32)>(Uniform4uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uiEXT(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32) :=
      ntv_Uniform4uiEXT_1(location, v0, v1, v2, v3);
    
    private Uniform1uivEXT_adr := GetProcAddress('glUniform1uivEXT');
    private ntv_Uniform1uivEXT_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt32)>(Uniform1uivEXT_adr);
    private ntv_Uniform1uivEXT_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform1uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uivEXT(location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform1uivEXT_1(location, count, value[0]) else
        ntv_Uniform1uivEXT_1(location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uivEXT(location: Int32; count: Int32; var value: UInt32) :=
      ntv_Uniform1uivEXT_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uivEXT(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform1uivEXT_2(location, count, value);
    
    private Uniform2uivEXT_adr := GetProcAddress('glUniform2uivEXT');
    private ntv_Uniform2uivEXT_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt32)>(Uniform2uivEXT_adr);
    private ntv_Uniform2uivEXT_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2ui)>(Uniform2uivEXT_adr);
    private ntv_Uniform2uivEXT_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform2uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uivEXT(location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform2uivEXT_1(location, count, value[0]) else
        ntv_Uniform2uivEXT_1(location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uivEXT(location: Int32; count: Int32; var value: Vec2ui) :=
      ntv_Uniform2uivEXT_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uivEXT(location: Int32; count: Int32; var value: UInt32) :=
      ntv_Uniform2uivEXT_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uivEXT(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform2uivEXT_3(location, count, value);
    
    private Uniform3uivEXT_adr := GetProcAddress('glUniform3uivEXT');
    private ntv_Uniform3uivEXT_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt32)>(Uniform3uivEXT_adr);
    private ntv_Uniform3uivEXT_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3ui)>(Uniform3uivEXT_adr);
    private ntv_Uniform3uivEXT_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform3uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uivEXT(location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform3uivEXT_1(location, count, value[0]) else
        ntv_Uniform3uivEXT_1(location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uivEXT(location: Int32; count: Int32; var value: Vec3ui) :=
      ntv_Uniform3uivEXT_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uivEXT(location: Int32; count: Int32; var value: UInt32) :=
      ntv_Uniform3uivEXT_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uivEXT(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform3uivEXT_3(location, count, value);
    
    private Uniform4uivEXT_adr := GetProcAddress('glUniform4uivEXT');
    private ntv_Uniform4uivEXT_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt32)>(Uniform4uivEXT_adr);
    private ntv_Uniform4uivEXT_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4ui)>(Uniform4uivEXT_adr);
    private ntv_Uniform4uivEXT_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform4uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uivEXT(location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform4uivEXT_1(location, count, value[0]) else
        ntv_Uniform4uivEXT_1(location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uivEXT(location: Int32; count: Int32; var value: Vec4ui) :=
      ntv_Uniform4uivEXT_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uivEXT(location: Int32; count: Int32; var value: UInt32) :=
      ntv_Uniform4uivEXT_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uivEXT(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform4uivEXT_3(location, count, value);
    
    private VertexAttribI1iEXT_adr := GetProcAddress('glVertexAttribI1iEXT');
    private ntv_VertexAttribI1iEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32)>(VertexAttribI1iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1iEXT(index: UInt32; x: Int32) :=
      ntv_VertexAttribI1iEXT_1(index, x);
    
    private VertexAttribI2iEXT_adr := GetProcAddress('glVertexAttribI2iEXT');
    private ntv_VertexAttribI2iEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32)>(VertexAttribI2iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2iEXT(index: UInt32; x: Int32; y: Int32) :=
      ntv_VertexAttribI2iEXT_1(index, x, y);
    
    private VertexAttribI3iEXT_adr := GetProcAddress('glVertexAttribI3iEXT');
    private ntv_VertexAttribI3iEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32; z: Int32)>(VertexAttribI3iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3iEXT(index: UInt32; x: Int32; y: Int32; z: Int32) :=
      ntv_VertexAttribI3iEXT_1(index, x, y, z);
    
    private VertexAttribI4iEXT_adr := GetProcAddress('glVertexAttribI4iEXT');
    private ntv_VertexAttribI4iEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>(VertexAttribI4iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4iEXT(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) :=
      ntv_VertexAttribI4iEXT_1(index, x, y, z, w);
    
    private VertexAttribI1uiEXT_adr := GetProcAddress('glVertexAttribI1uiEXT');
    private ntv_VertexAttribI1uiEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32)>(VertexAttribI1uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uiEXT(index: UInt32; x: UInt32) :=
      ntv_VertexAttribI1uiEXT_1(index, x);
    
    private VertexAttribI2uiEXT_adr := GetProcAddress('glVertexAttribI2uiEXT');
    private ntv_VertexAttribI2uiEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32)>(VertexAttribI2uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uiEXT(index: UInt32; x: UInt32; y: UInt32) :=
      ntv_VertexAttribI2uiEXT_1(index, x, y);
    
    private VertexAttribI3uiEXT_adr := GetProcAddress('glVertexAttribI3uiEXT');
    private ntv_VertexAttribI3uiEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32; z: UInt32)>(VertexAttribI3uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uiEXT(index: UInt32; x: UInt32; y: UInt32; z: UInt32) :=
      ntv_VertexAttribI3uiEXT_1(index, x, y, z);
    
    private VertexAttribI4uiEXT_adr := GetProcAddress('glVertexAttribI4uiEXT');
    private ntv_VertexAttribI4uiEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>(VertexAttribI4uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uiEXT(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) :=
      ntv_VertexAttribI4uiEXT_1(index, x, y, z, w);
    
    private VertexAttribI1ivEXT_adr := GetProcAddress('glVertexAttribI1ivEXT');
    private ntv_VertexAttribI1ivEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttribI1ivEXT_adr);
    private ntv_VertexAttribI1ivEXT_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI1ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ivEXT(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI1ivEXT_1(index, v[0]) else
        ntv_VertexAttribI1ivEXT_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ivEXT(index: UInt32; var v: Int32) :=
      ntv_VertexAttribI1ivEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ivEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI1ivEXT_2(index, v);
    
    private VertexAttribI2ivEXT_adr := GetProcAddress('glVertexAttribI2ivEXT');
    private ntv_VertexAttribI2ivEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttribI2ivEXT_adr);
    private ntv_VertexAttribI2ivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2i)>(VertexAttribI2ivEXT_adr);
    private ntv_VertexAttribI2ivEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI2ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ivEXT(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI2ivEXT_1(index, v[0]) else
        ntv_VertexAttribI2ivEXT_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ivEXT(index: UInt32; var v: Vec2i) :=
      ntv_VertexAttribI2ivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ivEXT(index: UInt32; var v: Int32) :=
      ntv_VertexAttribI2ivEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ivEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI2ivEXT_3(index, v);
    
    private VertexAttribI3ivEXT_adr := GetProcAddress('glVertexAttribI3ivEXT');
    private ntv_VertexAttribI3ivEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttribI3ivEXT_adr);
    private ntv_VertexAttribI3ivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3i)>(VertexAttribI3ivEXT_adr);
    private ntv_VertexAttribI3ivEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI3ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ivEXT(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI3ivEXT_1(index, v[0]) else
        ntv_VertexAttribI3ivEXT_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ivEXT(index: UInt32; var v: Vec3i) :=
      ntv_VertexAttribI3ivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ivEXT(index: UInt32; var v: Int32) :=
      ntv_VertexAttribI3ivEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ivEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI3ivEXT_3(index, v);
    
    private VertexAttribI4ivEXT_adr := GetProcAddress('glVertexAttribI4ivEXT');
    private ntv_VertexAttribI4ivEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttribI4ivEXT_adr);
    private ntv_VertexAttribI4ivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4i)>(VertexAttribI4ivEXT_adr);
    private ntv_VertexAttribI4ivEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ivEXT(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4ivEXT_1(index, v[0]) else
        ntv_VertexAttribI4ivEXT_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ivEXT(index: UInt32; var v: Vec4i) :=
      ntv_VertexAttribI4ivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ivEXT(index: UInt32; var v: Int32) :=
      ntv_VertexAttribI4ivEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ivEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4ivEXT_3(index, v);
    
    private VertexAttribI1uivEXT_adr := GetProcAddress('glVertexAttribI1uivEXT');
    private ntv_VertexAttribI1uivEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttribI1uivEXT_adr);
    private ntv_VertexAttribI1uivEXT_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI1uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uivEXT(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI1uivEXT_1(index, v[0]) else
        ntv_VertexAttribI1uivEXT_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uivEXT(index: UInt32; var v: UInt32) :=
      ntv_VertexAttribI1uivEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uivEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI1uivEXT_2(index, v);
    
    private VertexAttribI2uivEXT_adr := GetProcAddress('glVertexAttribI2uivEXT');
    private ntv_VertexAttribI2uivEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttribI2uivEXT_adr);
    private ntv_VertexAttribI2uivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2ui)>(VertexAttribI2uivEXT_adr);
    private ntv_VertexAttribI2uivEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI2uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uivEXT(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI2uivEXT_1(index, v[0]) else
        ntv_VertexAttribI2uivEXT_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uivEXT(index: UInt32; var v: Vec2ui) :=
      ntv_VertexAttribI2uivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uivEXT(index: UInt32; var v: UInt32) :=
      ntv_VertexAttribI2uivEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uivEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI2uivEXT_3(index, v);
    
    private VertexAttribI3uivEXT_adr := GetProcAddress('glVertexAttribI3uivEXT');
    private ntv_VertexAttribI3uivEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttribI3uivEXT_adr);
    private ntv_VertexAttribI3uivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3ui)>(VertexAttribI3uivEXT_adr);
    private ntv_VertexAttribI3uivEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI3uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uivEXT(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI3uivEXT_1(index, v[0]) else
        ntv_VertexAttribI3uivEXT_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uivEXT(index: UInt32; var v: Vec3ui) :=
      ntv_VertexAttribI3uivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uivEXT(index: UInt32; var v: UInt32) :=
      ntv_VertexAttribI3uivEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uivEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI3uivEXT_3(index, v);
    
    private VertexAttribI4uivEXT_adr := GetProcAddress('glVertexAttribI4uivEXT');
    private ntv_VertexAttribI4uivEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttribI4uivEXT_adr);
    private ntv_VertexAttribI4uivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ui)>(VertexAttribI4uivEXT_adr);
    private ntv_VertexAttribI4uivEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uivEXT(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4uivEXT_1(index, v[0]) else
        ntv_VertexAttribI4uivEXT_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uivEXT(index: UInt32; var v: Vec4ui) :=
      ntv_VertexAttribI4uivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uivEXT(index: UInt32; var v: UInt32) :=
      ntv_VertexAttribI4uivEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uivEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4uivEXT_3(index, v);
    
    private VertexAttribI4bvEXT_adr := GetProcAddress('glVertexAttribI4bvEXT');
    private ntv_VertexAttribI4bvEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(VertexAttribI4bvEXT_adr);
    private ntv_VertexAttribI4bvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4b)>(VertexAttribI4bvEXT_adr);
    private ntv_VertexAttribI4bvEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4bvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bvEXT(index: UInt32; v: array of SByte);
    type PSByte = ^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4bvEXT_1(index, v[0]) else
        ntv_VertexAttribI4bvEXT_1(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bvEXT(index: UInt32; var v: Vec4b) :=
      ntv_VertexAttribI4bvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bvEXT(index: UInt32; var v: SByte) :=
      ntv_VertexAttribI4bvEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bvEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4bvEXT_3(index, v);
    
    private VertexAttribI4svEXT_adr := GetProcAddress('glVertexAttribI4svEXT');
    private ntv_VertexAttribI4svEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttribI4svEXT_adr);
    private ntv_VertexAttribI4svEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4s)>(VertexAttribI4svEXT_adr);
    private ntv_VertexAttribI4svEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4svEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4svEXT(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4svEXT_1(index, v[0]) else
        ntv_VertexAttribI4svEXT_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4svEXT(index: UInt32; var v: Vec4s) :=
      ntv_VertexAttribI4svEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4svEXT(index: UInt32; var v: Int16) :=
      ntv_VertexAttribI4svEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4svEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4svEXT_3(index, v);
    
    private VertexAttribI4ubvEXT_adr := GetProcAddress('glVertexAttribI4ubvEXT');
    private ntv_VertexAttribI4ubvEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(VertexAttribI4ubvEXT_adr);
    private ntv_VertexAttribI4ubvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ub)>(VertexAttribI4ubvEXT_adr);
    private ntv_VertexAttribI4ubvEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4ubvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubvEXT(index: UInt32; v: array of Byte);
    type PByte = ^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4ubvEXT_1(index, v[0]) else
        ntv_VertexAttribI4ubvEXT_1(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubvEXT(index: UInt32; var v: Vec4ub) :=
      ntv_VertexAttribI4ubvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubvEXT(index: UInt32; var v: Byte) :=
      ntv_VertexAttribI4ubvEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubvEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4ubvEXT_3(index, v);
    
    private VertexAttribI4usvEXT_adr := GetProcAddress('glVertexAttribI4usvEXT');
    private ntv_VertexAttribI4usvEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(VertexAttribI4usvEXT_adr);
    private ntv_VertexAttribI4usvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4us)>(VertexAttribI4usvEXT_adr);
    private ntv_VertexAttribI4usvEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4usvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usvEXT(index: UInt32; v: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4usvEXT_1(index, v[0]) else
        ntv_VertexAttribI4usvEXT_1(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usvEXT(index: UInt32; var v: Vec4us) :=
      ntv_VertexAttribI4usvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usvEXT(index: UInt32; var v: UInt16) :=
      ntv_VertexAttribI4usvEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usvEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4usvEXT_3(index, v);
    
    private VertexAttribIPointerEXT_adr := GetProcAddress('glVertexAttribIPointerEXT');
    private ntv_VertexAttribIPointerEXT_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: glVertexAttribIType; stride: Int32; pointer: IntPtr)>(VertexAttribIPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIPointerEXT(index: UInt32; size: Int32; &type: glVertexAttribIType; stride: Int32; pointer: IntPtr) :=
      ntv_VertexAttribIPointerEXT_1(index, size, &type, stride, pointer);
    
    private GetVertexAttribIivEXT_adr := GetProcAddress('glGetVertexAttribIivEXT');
    private ntv_GetVertexAttribIivEXT_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; var &params: Int32)>(GetVertexAttribIivEXT_adr);
    private ntv_GetVertexAttribIivEXT_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr)>(GetVertexAttribIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIivEXT(index: UInt32; pname: glVertexAttribEnum; var &params: Int32) :=
      ntv_GetVertexAttribIivEXT_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIivEXT(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr) :=
      ntv_GetVertexAttribIivEXT_2(index, pname, &params);
    
    private GetVertexAttribIuivEXT_adr := GetProcAddress('glGetVertexAttribIuivEXT');
    private ntv_GetVertexAttribIuivEXT_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; var &params: UInt32)>(GetVertexAttribIuivEXT_adr);
    private ntv_GetVertexAttribIuivEXT_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr)>(GetVertexAttribIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuivEXT(index: UInt32; pname: glVertexAttribEnum; var &params: UInt32) :=
      ntv_GetVertexAttribIuivEXT_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuivEXT(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr) :=
      ntv_GetVertexAttribIuivEXT_2(index, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glHistogramEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_histogram';
    
    private GetHistogramEXT_adr := GetProcAddress('glGetHistogramEXT');
    private ntv_GetHistogramEXT_1 := GetProcOrNil&<procedure(target: glHistogramTarget; reset: glBool8; format: glPixelFormat; &type: glPixelType; values: IntPtr)>(GetHistogramEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramEXT(target: glHistogramTarget; reset: glBool8; format: glPixelFormat; &type: glPixelType; values: IntPtr) :=
      ntv_GetHistogramEXT_1(target, reset, format, &type, values);
    
    private GetHistogramParameterfvEXT_adr := GetProcAddress('glGetHistogramParameterfvEXT');
    private ntv_GetHistogramParameterfvEXT_1 := GetProcOrNil&<procedure(target: glHistogramTarget; pname: glGetHistogramParameterPName; var &params: single)>(GetHistogramParameterfvEXT_adr);
    private ntv_GetHistogramParameterfvEXT_2 := GetProcOrNil&<procedure(target: glHistogramTarget; pname: glGetHistogramParameterPName; &params: IntPtr)>(GetHistogramParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterfvEXT(target: glHistogramTarget; pname: glGetHistogramParameterPName; var &params: single) :=
      ntv_GetHistogramParameterfvEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterfvEXT(target: glHistogramTarget; pname: glGetHistogramParameterPName; &params: IntPtr) :=
      ntv_GetHistogramParameterfvEXT_2(target, pname, &params);
    
    private GetHistogramParameterivEXT_adr := GetProcAddress('glGetHistogramParameterivEXT');
    private ntv_GetHistogramParameterivEXT_1 := GetProcOrNil&<procedure(target: glHistogramTarget; pname: glGetHistogramParameterPName; var &params: Int32)>(GetHistogramParameterivEXT_adr);
    private ntv_GetHistogramParameterivEXT_2 := GetProcOrNil&<procedure(target: glHistogramTarget; pname: glGetHistogramParameterPName; &params: IntPtr)>(GetHistogramParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterivEXT(target: glHistogramTarget; pname: glGetHistogramParameterPName; var &params: Int32) :=
      ntv_GetHistogramParameterivEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterivEXT(target: glHistogramTarget; pname: glGetHistogramParameterPName; &params: IntPtr) :=
      ntv_GetHistogramParameterivEXT_2(target, pname, &params);
    
    private GetMinmaxEXT_adr := GetProcAddress('glGetMinmaxEXT');
    private ntv_GetMinmaxEXT_1 := GetProcOrNil&<procedure(target: glMinmaxTarget; reset: glBool8; format: glPixelFormat; &type: glPixelType; values: IntPtr)>(GetMinmaxEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxEXT(target: glMinmaxTarget; reset: glBool8; format: glPixelFormat; &type: glPixelType; values: IntPtr) :=
      ntv_GetMinmaxEXT_1(target, reset, format, &type, values);
    
    private GetMinmaxParameterfvEXT_adr := GetProcAddress('glGetMinmaxParameterfvEXT');
    private ntv_GetMinmaxParameterfvEXT_1 := GetProcOrNil&<procedure(target: glMinmaxTarget; pname: glGetMinmaxParameterPName; var &params: single)>(GetMinmaxParameterfvEXT_adr);
    private ntv_GetMinmaxParameterfvEXT_2 := GetProcOrNil&<procedure(target: glMinmaxTarget; pname: glGetMinmaxParameterPName; &params: IntPtr)>(GetMinmaxParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterfvEXT(target: glMinmaxTarget; pname: glGetMinmaxParameterPName; var &params: single) :=
      ntv_GetMinmaxParameterfvEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterfvEXT(target: glMinmaxTarget; pname: glGetMinmaxParameterPName; &params: IntPtr) :=
      ntv_GetMinmaxParameterfvEXT_2(target, pname, &params);
    
    private GetMinmaxParameterivEXT_adr := GetProcAddress('glGetMinmaxParameterivEXT');
    private ntv_GetMinmaxParameterivEXT_1 := GetProcOrNil&<procedure(target: glMinmaxTarget; pname: glGetMinmaxParameterPName; var &params: Int32)>(GetMinmaxParameterivEXT_adr);
    private ntv_GetMinmaxParameterivEXT_2 := GetProcOrNil&<procedure(target: glMinmaxTarget; pname: glGetMinmaxParameterPName; &params: IntPtr)>(GetMinmaxParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterivEXT(target: glMinmaxTarget; pname: glGetMinmaxParameterPName; var &params: Int32) :=
      ntv_GetMinmaxParameterivEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterivEXT(target: glMinmaxTarget; pname: glGetMinmaxParameterPName; &params: IntPtr) :=
      ntv_GetMinmaxParameterivEXT_2(target, pname, &params);
    
    private HistogramEXT_adr := GetProcAddress('glHistogramEXT');
    private ntv_HistogramEXT_1 := GetProcOrNil&<procedure(target: glHistogramTarget; width: Int32; internalformat: glInternalFormat; sink: glBool8)>(HistogramEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure HistogramEXT(target: glHistogramTarget; width: Int32; internalformat: glInternalFormat; sink: glBool8) :=
      ntv_HistogramEXT_1(target, width, internalformat, sink);
    
    private MinmaxEXT_adr := GetProcAddress('glMinmaxEXT');
    private ntv_MinmaxEXT_1 := GetProcOrNil&<procedure(target: glMinmaxTarget; internalformat: glInternalFormat; sink: glBool8)>(MinmaxEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MinmaxEXT(target: glMinmaxTarget; internalformat: glInternalFormat; sink: glBool8) :=
      ntv_MinmaxEXT_1(target, internalformat, sink);
    
    private ResetHistogramEXT_adr := GetProcAddress('glResetHistogramEXT');
    private ntv_ResetHistogramEXT_1 := GetProcOrNil&<procedure(target: glHistogramTarget)>(ResetHistogramEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetHistogramEXT(target: glHistogramTarget) :=
      ntv_ResetHistogramEXT_1(target);
    
    private ResetMinmaxEXT_adr := GetProcAddress('glResetMinmaxEXT');
    private ntv_ResetMinmaxEXT_1 := GetProcOrNil&<procedure(target: glMinmaxTarget)>(ResetMinmaxEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetMinmaxEXT(target: glMinmaxTarget) :=
      ntv_ResetMinmaxEXT_1(target);
    
  end;
  
  ///
  glIndexArrayFormatsEXT = static class
    public const _ExtStr = 'GL_EXT_index_array_formats';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glIndexFuncEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_index_func';
    
    private IndexFuncEXT_adr := GetProcAddress('glIndexFuncEXT');
    private ntv_IndexFuncEXT_1 := GetProcOrNil&<procedure(func: glIndexFunction; ref: single)>(IndexFuncEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexFuncEXT(func: glIndexFunction; ref: single) :=
      ntv_IndexFuncEXT_1(func, ref);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glIndexMaterialEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_index_material';
    
    private IndexMaterialEXT_adr := GetProcAddress('glIndexMaterialEXT');
    private ntv_IndexMaterialEXT_1 := GetProcOrNil&<procedure(face: glTriangleFace; mode: glIndexMaterialParameter)>(IndexMaterialEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexMaterialEXT(face: glTriangleFace; mode: glIndexMaterialParameter) :=
      ntv_IndexMaterialEXT_1(face, mode);
    
  end;
  
  ///
  glIndexTextureEXT = static class
    public const _ExtStr = 'GL_EXT_index_texture';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glLightTextureEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_light_texture';
    
    private ApplyTextureEXT_adr := GetProcAddress('glApplyTextureEXT');
    private ntv_ApplyTextureEXT_1 := GetProcOrNil&<procedure(mode: glLightTextureMode)>(ApplyTextureEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ApplyTextureEXT(mode: glLightTextureMode) :=
      ntv_ApplyTextureEXT_1(mode);
    
    private TextureLightEXT_adr := GetProcAddress('glTextureLightEXT');
    private ntv_TextureLightEXT_1 := GetProcOrNil&<procedure(pname: glLightTexturePName)>(TextureLightEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureLightEXT(pname: glLightTexturePName) :=
      ntv_TextureLightEXT_1(pname);
    
    private TextureMaterialEXT_adr := GetProcAddress('glTextureMaterialEXT');
    private ntv_TextureMaterialEXT_1 := GetProcOrNil&<procedure(face: glTriangleFace; mode: glMaterialParameter)>(TextureMaterialEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureMaterialEXT(face: glTriangleFace; mode: glMaterialParameter) :=
      ntv_TextureMaterialEXT_1(face, mode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMemoryObjectEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_memory_object';
    
    private GetUnsignedBytevEXT_adr := GetProcAddress('glGetUnsignedBytevEXT');
    private ntv_GetUnsignedBytevEXT_1 := GetProcOrNil&<procedure(pname: glGetPName; var data: Byte)>(GetUnsignedBytevEXT_adr);
    private ntv_GetUnsignedBytevEXT_2 := GetProcOrNil&<procedure(pname: glGetPName; data: IntPtr)>(GetUnsignedBytevEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytevEXT(pname: glGetPName; var data: Byte) :=
      ntv_GetUnsignedBytevEXT_1(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytevEXT(pname: glGetPName; data: IntPtr) :=
      ntv_GetUnsignedBytevEXT_2(pname, data);
    
    private GetUnsignedBytei_vEXT_adr := GetProcAddress('glGetUnsignedBytei_vEXT');
    private ntv_GetUnsignedBytei_vEXT_1 := GetProcOrNil&<procedure(target: DummyEnum; index: UInt32; var data: Byte)>(GetUnsignedBytei_vEXT_adr);
    private ntv_GetUnsignedBytei_vEXT_2 := GetProcOrNil&<procedure(target: DummyEnum; index: UInt32; data: IntPtr)>(GetUnsignedBytei_vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytei_vEXT(target: DummyEnum; index: UInt32; var data: Byte) :=
      ntv_GetUnsignedBytei_vEXT_1(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytei_vEXT(target: DummyEnum; index: UInt32; data: IntPtr) :=
      ntv_GetUnsignedBytei_vEXT_2(target, index, data);
    
    private DeleteMemoryObjectsEXT_adr := GetProcAddress('glDeleteMemoryObjectsEXT');
    private ntv_DeleteMemoryObjectsEXT_1 := GetProcOrNil&<procedure(n: Int32; var memoryObjects: UInt32)>(DeleteMemoryObjectsEXT_adr);
    private ntv_DeleteMemoryObjectsEXT_2 := GetProcOrNil&<procedure(n: Int32; memoryObjects: IntPtr)>(DeleteMemoryObjectsEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteMemoryObjectsEXT(n: Int32; memoryObjects: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (memoryObjects<>nil) and (memoryObjects.Length<>0) then
        ntv_DeleteMemoryObjectsEXT_1(n, memoryObjects[0]) else
        ntv_DeleteMemoryObjectsEXT_1(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteMemoryObjectsEXT(n: Int32; var memoryObjects: UInt32) :=
      ntv_DeleteMemoryObjectsEXT_1(n, memoryObjects);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteMemoryObjectsEXT(n: Int32; memoryObjects: IntPtr) :=
      ntv_DeleteMemoryObjectsEXT_2(n, memoryObjects);
    
    private IsMemoryObjectEXT_adr := GetProcAddress('glIsMemoryObjectEXT');
    private ntv_IsMemoryObjectEXT_1 := GetProcOrNil&<function(memoryObject: UInt32): glBool8>(IsMemoryObjectEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsMemoryObjectEXT(memoryObject: UInt32): glBool8 :=
      ntv_IsMemoryObjectEXT_1(memoryObject);
    
    private CreateMemoryObjectsEXT_adr := GetProcAddress('glCreateMemoryObjectsEXT');
    private ntv_CreateMemoryObjectsEXT_1 := GetProcOrNil&<procedure(n: Int32; var memoryObjects: UInt32)>(CreateMemoryObjectsEXT_adr);
    private ntv_CreateMemoryObjectsEXT_2 := GetProcOrNil&<procedure(n: Int32; memoryObjects: IntPtr)>(CreateMemoryObjectsEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateMemoryObjectsEXT(n: Int32; memoryObjects: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (memoryObjects<>nil) and (memoryObjects.Length<>0) then
        ntv_CreateMemoryObjectsEXT_1(n, memoryObjects[0]) else
        ntv_CreateMemoryObjectsEXT_1(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateMemoryObjectsEXT(n: Int32; var memoryObjects: UInt32) :=
      ntv_CreateMemoryObjectsEXT_1(n, memoryObjects);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateMemoryObjectsEXT(n: Int32; memoryObjects: IntPtr) :=
      ntv_CreateMemoryObjectsEXT_2(n, memoryObjects);
    
    private MemoryObjectParameterivEXT_adr := GetProcAddress('glMemoryObjectParameterivEXT');
    private ntv_MemoryObjectParameterivEXT_1 := GetProcOrNil&<procedure(memoryObject: UInt32; pname: glMemoryObjectParameterName; var &params: Int32)>(MemoryObjectParameterivEXT_adr);
    private ntv_MemoryObjectParameterivEXT_2 := GetProcOrNil&<procedure(memoryObject: UInt32; pname: glMemoryObjectParameterName; &params: IntPtr)>(MemoryObjectParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryObjectParameterivEXT(memoryObject: UInt32; pname: glMemoryObjectParameterName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_MemoryObjectParameterivEXT_1(memoryObject, pname, &params[0]) else
        ntv_MemoryObjectParameterivEXT_1(memoryObject, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryObjectParameterivEXT(memoryObject: UInt32; pname: glMemoryObjectParameterName; var &params: Int32) :=
      ntv_MemoryObjectParameterivEXT_1(memoryObject, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryObjectParameterivEXT(memoryObject: UInt32; pname: glMemoryObjectParameterName; &params: IntPtr) :=
      ntv_MemoryObjectParameterivEXT_2(memoryObject, pname, &params);
    
    private GetMemoryObjectParameterivEXT_adr := GetProcAddress('glGetMemoryObjectParameterivEXT');
    private ntv_GetMemoryObjectParameterivEXT_1 := GetProcOrNil&<procedure(memoryObject: UInt32; pname: glMemoryObjectParameterName; var &params: Int32)>(GetMemoryObjectParameterivEXT_adr);
    private ntv_GetMemoryObjectParameterivEXT_2 := GetProcOrNil&<procedure(memoryObject: UInt32; pname: glMemoryObjectParameterName; &params: IntPtr)>(GetMemoryObjectParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectParameterivEXT(memoryObject: UInt32; pname: glMemoryObjectParameterName; var &params: Int32) :=
      ntv_GetMemoryObjectParameterivEXT_1(memoryObject, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectParameterivEXT(memoryObject: UInt32; pname: glMemoryObjectParameterName; &params: IntPtr) :=
      ntv_GetMemoryObjectParameterivEXT_2(memoryObject, pname, &params);
    
    private TexStorageMem2DEXT_adr := GetProcAddress('glTexStorageMem2DEXT');
    private ntv_TexStorageMem2DEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; levels: Int32; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; memory: UInt32; offset: UInt64)>(TexStorageMem2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem2DEXT(target: glTextureTarget; levels: Int32; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; memory: UInt32; offset: UInt64) :=
      ntv_TexStorageMem2DEXT_1(target, levels, internalFormat, width, height, memory, offset);
    
    private TexStorageMem2DMultisampleEXT_adr := GetProcAddress('glTexStorageMem2DMultisampleEXT');
    private ntv_TexStorageMem2DMultisampleEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; samples: Int32; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; fixedSampleLocations: glBool8; memory: UInt32; offset: UInt64)>(TexStorageMem2DMultisampleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem2DMultisampleEXT(target: glTextureTarget; samples: Int32; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; fixedSampleLocations: glBool8; memory: UInt32; offset: UInt64) :=
      ntv_TexStorageMem2DMultisampleEXT_1(target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
    
    private TexStorageMem3DEXT_adr := GetProcAddress('glTexStorageMem3DEXT');
    private ntv_TexStorageMem3DEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; levels: Int32; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64)>(TexStorageMem3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem3DEXT(target: glTextureTarget; levels: Int32; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64) :=
      ntv_TexStorageMem3DEXT_1(target, levels, internalFormat, width, height, depth, memory, offset);
    
    private TexStorageMem3DMultisampleEXT_adr := GetProcAddress('glTexStorageMem3DMultisampleEXT');
    private ntv_TexStorageMem3DMultisampleEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; samples: Int32; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: glBool8; memory: UInt32; offset: UInt64)>(TexStorageMem3DMultisampleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem3DMultisampleEXT(target: glTextureTarget; samples: Int32; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: glBool8; memory: UInt32; offset: UInt64) :=
      ntv_TexStorageMem3DMultisampleEXT_1(target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
    
    private BufferStorageMemEXT_adr := GetProcAddress('glBufferStorageMemEXT');
    private ntv_BufferStorageMemEXT_1 := GetProcOrNil&<procedure(target: glBufferTarget; size: UIntPtr; memory: UInt32; offset: UInt64)>(BufferStorageMemEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorageMemEXT(target: glBufferTarget; size: UIntPtr; memory: UInt32; offset: UInt64) :=
      ntv_BufferStorageMemEXT_1(target, size, memory, offset);
    
    private TextureStorageMem2DEXT_adr := GetProcAddress('glTextureStorageMem2DEXT');
    private ntv_TextureStorageMem2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; memory: UInt32; offset: UInt64)>(TextureStorageMem2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem2DEXT(texture: gl_texture; levels: Int32; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; memory: UInt32; offset: UInt64) :=
      ntv_TextureStorageMem2DEXT_1(texture, levels, internalFormat, width, height, memory, offset);
    
    private TextureStorageMem2DMultisampleEXT_adr := GetProcAddress('glTextureStorageMem2DMultisampleEXT');
    private ntv_TextureStorageMem2DMultisampleEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; samples: Int32; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; fixedSampleLocations: glBool8; memory: UInt32; offset: UInt64)>(TextureStorageMem2DMultisampleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem2DMultisampleEXT(texture: gl_texture; samples: Int32; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; fixedSampleLocations: glBool8; memory: UInt32; offset: UInt64) :=
      ntv_TextureStorageMem2DMultisampleEXT_1(texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
    
    private TextureStorageMem3DEXT_adr := GetProcAddress('glTextureStorageMem3DEXT');
    private ntv_TextureStorageMem3DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64)>(TextureStorageMem3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem3DEXT(texture: gl_texture; levels: Int32; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64) :=
      ntv_TextureStorageMem3DEXT_1(texture, levels, internalFormat, width, height, depth, memory, offset);
    
    private TextureStorageMem3DMultisampleEXT_adr := GetProcAddress('glTextureStorageMem3DMultisampleEXT');
    private ntv_TextureStorageMem3DMultisampleEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; samples: Int32; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: glBool8; memory: UInt32; offset: UInt64)>(TextureStorageMem3DMultisampleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem3DMultisampleEXT(texture: gl_texture; samples: Int32; internalFormat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: glBool8; memory: UInt32; offset: UInt64) :=
      ntv_TextureStorageMem3DMultisampleEXT_1(texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
    
    private NamedBufferStorageMemEXT_adr := GetProcAddress('glNamedBufferStorageMemEXT');
    private ntv_NamedBufferStorageMemEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; memory: UInt32; offset: UInt64)>(NamedBufferStorageMemEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorageMemEXT(buffer: gl_buffer; size: UIntPtr; memory: UInt32; offset: UInt64) :=
      ntv_NamedBufferStorageMemEXT_1(buffer, size, memory, offset);
    
    private TexStorageMem1DEXT_adr := GetProcAddress('glTexStorageMem1DEXT');
    private ntv_TexStorageMem1DEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; levels: Int32; internalFormat: glSizedInternalFormat; width: Int32; memory: UInt32; offset: UInt64)>(TexStorageMem1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem1DEXT(target: glTextureTarget; levels: Int32; internalFormat: glSizedInternalFormat; width: Int32; memory: UInt32; offset: UInt64) :=
      ntv_TexStorageMem1DEXT_1(target, levels, internalFormat, width, memory, offset);
    
    private TextureStorageMem1DEXT_adr := GetProcAddress('glTextureStorageMem1DEXT');
    private ntv_TextureStorageMem1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalFormat: glSizedInternalFormat; width: Int32; memory: UInt32; offset: UInt64)>(TextureStorageMem1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem1DEXT(texture: gl_texture; levels: Int32; internalFormat: glSizedInternalFormat; width: Int32; memory: UInt32; offset: UInt64) :=
      ntv_TextureStorageMem1DEXT_1(texture, levels, internalFormat, width, memory, offset);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMemoryObjectFdEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_memory_object_fd';
    
    private ImportMemoryFdEXT_adr := GetProcAddress('glImportMemoryFdEXT');
    private ntv_ImportMemoryFdEXT_1 := GetProcOrNil&<procedure(memory: UInt32; size: UInt64; handleType: glExternalHandleType; fd: Int32)>(ImportMemoryFdEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportMemoryFdEXT(memory: UInt32; size: UInt64; handleType: glExternalHandleType; fd: Int32) :=
      ntv_ImportMemoryFdEXT_1(memory, size, handleType, fd);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMemoryObjectWin32EXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_memory_object_win32';
    
    private ImportMemoryWin32HandleEXT_adr := GetProcAddress('glImportMemoryWin32HandleEXT');
    private ntv_ImportMemoryWin32HandleEXT_1 := GetProcOrNil&<procedure(memory: UInt32; size: UInt64; handleType: glExternalHandleType; handle: IntPtr)>(ImportMemoryWin32HandleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportMemoryWin32HandleEXT(memory: UInt32; size: UInt64; handleType: glExternalHandleType; handle: IntPtr) :=
      ntv_ImportMemoryWin32HandleEXT_1(memory, size, handleType, handle);
    
    private ImportMemoryWin32NameEXT_adr := GetProcAddress('glImportMemoryWin32NameEXT');
    private ntv_ImportMemoryWin32NameEXT_1 := GetProcOrNil&<procedure(memory: UInt32; size: UInt64; handleType: glExternalHandleType; name: IntPtr)>(ImportMemoryWin32NameEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportMemoryWin32NameEXT(memory: UInt32; size: UInt64; handleType: glExternalHandleType; name: IntPtr) :=
      ntv_ImportMemoryWin32NameEXT_1(memory, size, handleType, name);
    
  end;
  
  ///
  glMiscAttributeEXT = static class
    public const _ExtStr = 'GL_EXT_misc_attribute';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMultiDrawArraysEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_multi_draw_arrays';
    
    private MultiDrawArraysEXT_adr := GetProcAddress('glMultiDrawArraysEXT');
    private ntv_MultiDrawArraysEXT_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; var first: Int32; var count: Int32; primcount: Int32)>(MultiDrawArraysEXT_adr);
    private ntv_MultiDrawArraysEXT_2 := GetProcOrNil&<procedure(mode: glPrimitiveType; var first: Int32; count: IntPtr; primcount: Int32)>(MultiDrawArraysEXT_adr);
    private ntv_MultiDrawArraysEXT_3 := GetProcOrNil&<procedure(mode: glPrimitiveType; first: IntPtr; var count: Int32; primcount: Int32)>(MultiDrawArraysEXT_adr);
    private ntv_MultiDrawArraysEXT_4 := GetProcOrNil&<procedure(mode: glPrimitiveType; first: IntPtr; count: IntPtr; primcount: Int32)>(MultiDrawArraysEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: glPrimitiveType; first: array of Int32; count: array of Int32; primcount: Int32);
    type PInt32 = ^Int32;
    begin
      if (first<>nil) and (first.Length<>0) then
        if (count<>nil) and (count.Length<>0) then
          ntv_MultiDrawArraysEXT_1(mode, first[0], count[0], primcount) else
          ntv_MultiDrawArraysEXT_1(mode, first[0], PInt32(nil)^, primcount) else
        if (count<>nil) and (count.Length<>0) then
          ntv_MultiDrawArraysEXT_1(mode, PInt32(nil)^, count[0], primcount) else
          ntv_MultiDrawArraysEXT_1(mode, PInt32(nil)^, PInt32(nil)^, primcount);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: glPrimitiveType; var first: Int32; var count: Int32; primcount: Int32) :=
      ntv_MultiDrawArraysEXT_1(mode, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: glPrimitiveType; var first: Int32; count: IntPtr; primcount: Int32) :=
      ntv_MultiDrawArraysEXT_2(mode, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: glPrimitiveType; first: IntPtr; var count: Int32; primcount: Int32) :=
      ntv_MultiDrawArraysEXT_3(mode, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: glPrimitiveType; first: IntPtr; count: IntPtr; primcount: Int32) :=
      ntv_MultiDrawArraysEXT_4(mode, first, count, primcount);
    
    private MultiDrawElementsEXT_adr := GetProcAddress('glMultiDrawElementsEXT');
    private ntv_MultiDrawElementsEXT_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; var indices: IntPtr; primcount: Int32)>(MultiDrawElementsEXT_adr);
    private ntv_MultiDrawElementsEXT_2 := GetProcOrNil&<procedure(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; indices: pointer; primcount: Int32)>(MultiDrawElementsEXT_adr);
    private ntv_MultiDrawElementsEXT_3 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; var indices: IntPtr; primcount: Int32)>(MultiDrawElementsEXT_adr);
    private ntv_MultiDrawElementsEXT_4 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; indices: pointer; primcount: Int32)>(MultiDrawElementsEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: glPrimitiveType; count: array of Int32; &type: glDrawElementsType; indices: array of IntPtr; primcount: Int32);
    type PInt32 = ^Int32;
    type PIntPtr = ^IntPtr;
    begin
      if (count<>nil) and (count.Length<>0) then
        if (indices<>nil) and (indices.Length<>0) then
          ntv_MultiDrawElementsEXT_1(mode, count[0], &type, indices[0], primcount) else
          ntv_MultiDrawElementsEXT_1(mode, count[0], &type, PIntPtr(nil)^, primcount) else
        if (indices<>nil) and (indices.Length<>0) then
          ntv_MultiDrawElementsEXT_1(mode, PInt32(nil)^, &type, indices[0], primcount) else
          ntv_MultiDrawElementsEXT_1(mode, PInt32(nil)^, &type, PIntPtr(nil)^, primcount);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; var indices: IntPtr; primcount: Int32) :=
      ntv_MultiDrawElementsEXT_1(mode, count, &type, indices, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; indices: pointer; primcount: Int32) :=
      ntv_MultiDrawElementsEXT_2(mode, count, &type, indices, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; var indices: IntPtr; primcount: Int32) :=
      ntv_MultiDrawElementsEXT_3(mode, count, &type, indices, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; indices: pointer; primcount: Int32) :=
      ntv_MultiDrawElementsEXT_4(mode, count, &type, indices, primcount);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMultisampleEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_multisample';
    
    private SampleMaskEXT_adr := GetProcAddress('glSampleMaskEXT');
    private ntv_SampleMaskEXT_1 := GetProcOrNil&<procedure(value: single; invert: glBool8)>(SampleMaskEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMaskEXT(value: single; invert: glBool8) :=
      ntv_SampleMaskEXT_1(value, invert);
    
    private SamplePatternEXT_adr := GetProcAddress('glSamplePatternEXT');
    private ntv_SamplePatternEXT_1 := GetProcOrNil&<procedure(pattern: glSamplePattern)>(SamplePatternEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplePatternEXT(pattern: glSamplePattern) :=
      ntv_SamplePatternEXT_1(pattern);
    
  end;
  
  ///
  glMultiviewTessellationGeometryShaderEXT = static class
    public const _ExtStr = 'GL_EXT_multiview_tessellation_geometry_shader';
  end;
  
  ///
  glMultiviewTextureMultisampleEXT = static class
    public const _ExtStr = 'GL_EXT_multiview_texture_multisample';
  end;
  
  ///
  glMultiviewTimerQueryEXT = static class
    public const _ExtStr = 'GL_EXT_multiview_timer_query';
  end;
  
  ///
  glPackedDepthStencilEXT = static class
    public const _ExtStr = 'GL_EXT_packed_depth_stencil';
  end;
  
  ///
  glPackedFloatEXT = static class
    public const _ExtStr = 'GL_EXT_packed_float';
  end;
  
  ///
  glPackedPixelsEXT = static class
    public const _ExtStr = 'GL_EXT_packed_pixels';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPalettedTextureEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_paletted_texture';
    
    private ColorTableEXT_adr := GetProcAddress('glColorTableEXT');
    private ntv_ColorTableEXT_1 := GetProcOrNil&<procedure(target: glColorTableTarget; internalFormat: glInternalFormat; width: Int32; format: glPixelFormat; &type: glPixelType; table: IntPtr)>(ColorTableEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableEXT(target: glColorTableTarget; internalFormat: glInternalFormat; width: Int32; format: glPixelFormat; &type: glPixelType; table: IntPtr) :=
      ntv_ColorTableEXT_1(target, internalFormat, width, format, &type, table);
    
    private GetColorTableEXT_adr := GetProcAddress('glGetColorTableEXT');
    private ntv_GetColorTableEXT_1 := GetProcOrNil&<procedure(target: glColorTableTarget; format: glPixelFormat; &type: glPixelType; data: IntPtr)>(GetColorTableEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableEXT(target: glColorTableTarget; format: glPixelFormat; &type: glPixelType; data: IntPtr) :=
      ntv_GetColorTableEXT_1(target, format, &type, data);
    
    private GetColorTableParameterivEXT_adr := GetProcAddress('glGetColorTableParameterivEXT');
    private ntv_GetColorTableParameterivEXT_1 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Int32)>(GetColorTableParameterivEXT_adr);
    private ntv_GetColorTableParameterivEXT_2 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr)>(GetColorTableParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterivEXT(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Int32) :=
      ntv_GetColorTableParameterivEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterivEXT(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr) :=
      ntv_GetColorTableParameterivEXT_2(target, pname, &params);
    
    private GetColorTableParameterfvEXT_adr := GetProcAddress('glGetColorTableParameterfvEXT');
    private ntv_GetColorTableParameterfvEXT_1 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: single)>(GetColorTableParameterfvEXT_adr);
    private ntv_GetColorTableParameterfvEXT_2 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr)>(GetColorTableParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfvEXT(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: single) :=
      ntv_GetColorTableParameterfvEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfvEXT(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr) :=
      ntv_GetColorTableParameterfvEXT_2(target, pname, &params);
    
  end;
  
  ///
  glPixelBufferObjectEXT = static class
    public const _ExtStr = 'GL_EXT_pixel_buffer_object';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPixelTransformEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_pixel_transform';
    
    private PixelTransformParameteriEXT_adr := GetProcAddress('glPixelTransformParameteriEXT');
    private ntv_PixelTransformParameteriEXT_1 := GetProcOrNil&<procedure(target: glPixelTransformTarget; pname: glPixelTransformPName; param: Int32)>(PixelTransformParameteriEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameteriEXT(target: glPixelTransformTarget; pname: glPixelTransformPName; param: Int32) :=
      ntv_PixelTransformParameteriEXT_1(target, pname, param);
    
    private PixelTransformParameterfEXT_adr := GetProcAddress('glPixelTransformParameterfEXT');
    private ntv_PixelTransformParameterfEXT_1 := GetProcOrNil&<procedure(target: glPixelTransformTarget; pname: glPixelTransformPName; param: single)>(PixelTransformParameterfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfEXT(target: glPixelTransformTarget; pname: glPixelTransformPName; param: single) :=
      ntv_PixelTransformParameterfEXT_1(target, pname, param);
    
    private PixelTransformParameterivEXT_adr := GetProcAddress('glPixelTransformParameterivEXT');
    private ntv_PixelTransformParameterivEXT_1 := GetProcOrNil&<procedure(target: glPixelTransformTarget; pname: glPixelTransformPName; var &params: Int32)>(PixelTransformParameterivEXT_adr);
    private ntv_PixelTransformParameterivEXT_2 := GetProcOrNil&<procedure(target: glPixelTransformTarget; pname: glPixelTransformPName; &params: IntPtr)>(PixelTransformParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterivEXT(target: glPixelTransformTarget; pname: glPixelTransformPName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_PixelTransformParameterivEXT_1(target, pname, &params[0]) else
        ntv_PixelTransformParameterivEXT_1(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterivEXT(target: glPixelTransformTarget; pname: glPixelTransformPName; var &params: Int32) :=
      ntv_PixelTransformParameterivEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterivEXT(target: glPixelTransformTarget; pname: glPixelTransformPName; &params: IntPtr) :=
      ntv_PixelTransformParameterivEXT_2(target, pname, &params);
    
    private PixelTransformParameterfvEXT_adr := GetProcAddress('glPixelTransformParameterfvEXT');
    private ntv_PixelTransformParameterfvEXT_1 := GetProcOrNil&<procedure(target: glPixelTransformTarget; pname: glPixelTransformPName; var &params: single)>(PixelTransformParameterfvEXT_adr);
    private ntv_PixelTransformParameterfvEXT_2 := GetProcOrNil&<procedure(target: glPixelTransformTarget; pname: glPixelTransformPName; &params: IntPtr)>(PixelTransformParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfvEXT(target: glPixelTransformTarget; pname: glPixelTransformPName; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_PixelTransformParameterfvEXT_1(target, pname, &params[0]) else
        ntv_PixelTransformParameterfvEXT_1(target, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfvEXT(target: glPixelTransformTarget; pname: glPixelTransformPName; var &params: single) :=
      ntv_PixelTransformParameterfvEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfvEXT(target: glPixelTransformTarget; pname: glPixelTransformPName; &params: IntPtr) :=
      ntv_PixelTransformParameterfvEXT_2(target, pname, &params);
    
    private GetPixelTransformParameterivEXT_adr := GetProcAddress('glGetPixelTransformParameterivEXT');
    private ntv_GetPixelTransformParameterivEXT_1 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; var &params: Int32)>(GetPixelTransformParameterivEXT_adr);
    private ntv_GetPixelTransformParameterivEXT_2 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: IntPtr)>(GetPixelTransformParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterivEXT(target: DummyEnum; pname: DummyEnum; var &params: Int32) :=
      ntv_GetPixelTransformParameterivEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: IntPtr) :=
      ntv_GetPixelTransformParameterivEXT_2(target, pname, &params);
    
    private GetPixelTransformParameterfvEXT_adr := GetProcAddress('glGetPixelTransformParameterfvEXT');
    private ntv_GetPixelTransformParameterfvEXT_1 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; var &params: single)>(GetPixelTransformParameterfvEXT_adr);
    private ntv_GetPixelTransformParameterfvEXT_2 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: IntPtr)>(GetPixelTransformParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterfvEXT(target: DummyEnum; pname: DummyEnum; var &params: single) :=
      ntv_GetPixelTransformParameterfvEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: IntPtr) :=
      ntv_GetPixelTransformParameterfvEXT_2(target, pname, &params);
    
  end;
  
  ///
  glPixelTransformColorTableEXT = static class
    public const _ExtStr = 'GL_EXT_pixel_transform_color_table';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPointParametersEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_point_parameters';
    
    private PointParameterfEXT_adr := GetProcAddress('glPointParameterfEXT');
    private ntv_PointParameterfEXT_1 := GetProcOrNil&<procedure(pname: glPointParameterName; param: single)>(PointParameterfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfEXT(pname: glPointParameterName; param: single) :=
      ntv_PointParameterfEXT_1(pname, param);
    
    private PointParameterfvEXT_adr := GetProcAddress('glPointParameterfvEXT');
    private ntv_PointParameterfvEXT_1 := GetProcOrNil&<procedure(pname: glPointParameterName; var &params: single)>(PointParameterfvEXT_adr);
    private ntv_PointParameterfvEXT_2 := GetProcOrNil&<procedure(pname: glPointParameterName; &params: IntPtr)>(PointParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvEXT(pname: glPointParameterName; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_PointParameterfvEXT_1(pname, &params[0]) else
        ntv_PointParameterfvEXT_1(pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvEXT(pname: glPointParameterName; var &params: single) :=
      ntv_PointParameterfvEXT_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvEXT(pname: glPointParameterName; &params: IntPtr) :=
      ntv_PointParameterfvEXT_2(pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPolygonOffsetEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_polygon_offset';
    
    private PolygonOffsetEXT_adr := GetProcAddress('glPolygonOffsetEXT');
    private ntv_PolygonOffsetEXT_1 := GetProcOrNil&<procedure(factor: single; bias: single)>(PolygonOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffsetEXT(factor: single; bias: single) :=
      ntv_PolygonOffsetEXT_1(factor, bias);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPolygonOffsetClampEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_polygon_offset_clamp';
    
    private PolygonOffsetClampEXT_adr := GetProcAddress('glPolygonOffsetClampEXT');
    private ntv_PolygonOffsetClampEXT_1 := GetProcOrNil&<procedure(factor: single; units: single; clamp: single)>(PolygonOffsetClampEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffsetClampEXT(factor: single; units: single; clamp: single) :=
      ntv_PolygonOffsetClampEXT_1(factor, units, clamp);
    
  end;
  
  ///
  glPostDepthCoverageEXT = static class
    public const _ExtStr = 'GL_EXT_post_depth_coverage';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glProvokingVertexEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_provoking_vertex';
    
    private ProvokingVertexEXT_adr := GetProcAddress('glProvokingVertexEXT');
    private ntv_ProvokingVertexEXT_1 := GetProcOrNil&<procedure(mode: glVertexProvokingMode)>(ProvokingVertexEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProvokingVertexEXT(mode: glVertexProvokingMode) :=
      ntv_ProvokingVertexEXT_1(mode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glRasterMultisampleEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_raster_multisample';
    
    private RasterSamplesEXT_adr := GetProcAddress('glRasterSamplesEXT');
    private ntv_RasterSamplesEXT_1 := GetProcOrNil&<procedure(samples: UInt32; fixedsamplelocations: glBool8)>(RasterSamplesEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterSamplesEXT(samples: UInt32; fixedsamplelocations: glBool8) :=
      ntv_RasterSamplesEXT_1(samples, fixedsamplelocations);
    
  end;
  
  ///
  glRescaleNormalEXT = static class
    public const _ExtStr = 'GL_EXT_rescale_normal';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSecondaryColorEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_secondary_color';
    
    private SecondaryColor3bEXT_adr := GetProcAddress('glSecondaryColor3bEXT');
    private ntv_SecondaryColor3bEXT_1 := GetProcOrNil&<procedure(red: SByte; green: SByte; blue: SByte)>(SecondaryColor3bEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bEXT(red: SByte; green: SByte; blue: SByte) :=
      ntv_SecondaryColor3bEXT_1(red, green, blue);
    
    private SecondaryColor3bvEXT_adr := GetProcAddress('glSecondaryColor3bvEXT');
    private ntv_SecondaryColor3bvEXT_1 := GetProcOrNil&<procedure(var v: SByte)>(SecondaryColor3bvEXT_adr);
    private ntv_SecondaryColor3bvEXT_2 := GetProcOrNil&<procedure(var v: Vec3b)>(SecondaryColor3bvEXT_adr);
    private ntv_SecondaryColor3bvEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(SecondaryColor3bvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bvEXT(v: array of SByte);
    type PSByte = ^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_SecondaryColor3bvEXT_1(v[0]) else
        ntv_SecondaryColor3bvEXT_1(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bvEXT(var v: Vec3b) :=
      ntv_SecondaryColor3bvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bvEXT(var v: SByte) :=
      ntv_SecondaryColor3bvEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bvEXT(v: IntPtr) :=
      ntv_SecondaryColor3bvEXT_3(v);
    
    private SecondaryColor3dEXT_adr := GetProcAddress('glSecondaryColor3dEXT');
    private ntv_SecondaryColor3dEXT_1 := GetProcOrNil&<procedure(red: double; green: double; blue: double)>(SecondaryColor3dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dEXT(red: double; green: double; blue: double) :=
      ntv_SecondaryColor3dEXT_1(red, green, blue);
    
    private SecondaryColor3dvEXT_adr := GetProcAddress('glSecondaryColor3dvEXT');
    private ntv_SecondaryColor3dvEXT_1 := GetProcOrNil&<procedure(var v: double)>(SecondaryColor3dvEXT_adr);
    private ntv_SecondaryColor3dvEXT_2 := GetProcOrNil&<procedure(var v: Vec3d)>(SecondaryColor3dvEXT_adr);
    private ntv_SecondaryColor3dvEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(SecondaryColor3dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dvEXT(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_SecondaryColor3dvEXT_1(v[0]) else
        ntv_SecondaryColor3dvEXT_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dvEXT(var v: Vec3d) :=
      ntv_SecondaryColor3dvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dvEXT(var v: double) :=
      ntv_SecondaryColor3dvEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dvEXT(v: IntPtr) :=
      ntv_SecondaryColor3dvEXT_3(v);
    
    private SecondaryColor3fEXT_adr := GetProcAddress('glSecondaryColor3fEXT');
    private ntv_SecondaryColor3fEXT_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single)>(SecondaryColor3fEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fEXT(red: single; green: single; blue: single) :=
      ntv_SecondaryColor3fEXT_1(red, green, blue);
    
    private SecondaryColor3fvEXT_adr := GetProcAddress('glSecondaryColor3fvEXT');
    private ntv_SecondaryColor3fvEXT_1 := GetProcOrNil&<procedure(var v: single)>(SecondaryColor3fvEXT_adr);
    private ntv_SecondaryColor3fvEXT_2 := GetProcOrNil&<procedure(var v: Vec3f)>(SecondaryColor3fvEXT_adr);
    private ntv_SecondaryColor3fvEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(SecondaryColor3fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fvEXT(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_SecondaryColor3fvEXT_1(v[0]) else
        ntv_SecondaryColor3fvEXT_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fvEXT(var v: Vec3f) :=
      ntv_SecondaryColor3fvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fvEXT(var v: single) :=
      ntv_SecondaryColor3fvEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fvEXT(v: IntPtr) :=
      ntv_SecondaryColor3fvEXT_3(v);
    
    private SecondaryColor3iEXT_adr := GetProcAddress('glSecondaryColor3iEXT');
    private ntv_SecondaryColor3iEXT_1 := GetProcOrNil&<procedure(red: Int32; green: Int32; blue: Int32)>(SecondaryColor3iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3iEXT(red: Int32; green: Int32; blue: Int32) :=
      ntv_SecondaryColor3iEXT_1(red, green, blue);
    
    private SecondaryColor3ivEXT_adr := GetProcAddress('glSecondaryColor3ivEXT');
    private ntv_SecondaryColor3ivEXT_1 := GetProcOrNil&<procedure(var v: Int32)>(SecondaryColor3ivEXT_adr);
    private ntv_SecondaryColor3ivEXT_2 := GetProcOrNil&<procedure(var v: Vec3i)>(SecondaryColor3ivEXT_adr);
    private ntv_SecondaryColor3ivEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(SecondaryColor3ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ivEXT(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_SecondaryColor3ivEXT_1(v[0]) else
        ntv_SecondaryColor3ivEXT_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ivEXT(var v: Vec3i) :=
      ntv_SecondaryColor3ivEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ivEXT(var v: Int32) :=
      ntv_SecondaryColor3ivEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ivEXT(v: IntPtr) :=
      ntv_SecondaryColor3ivEXT_3(v);
    
    private SecondaryColor3sEXT_adr := GetProcAddress('glSecondaryColor3sEXT');
    private ntv_SecondaryColor3sEXT_1 := GetProcOrNil&<procedure(red: Int16; green: Int16; blue: Int16)>(SecondaryColor3sEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3sEXT(red: Int16; green: Int16; blue: Int16) :=
      ntv_SecondaryColor3sEXT_1(red, green, blue);
    
    private SecondaryColor3svEXT_adr := GetProcAddress('glSecondaryColor3svEXT');
    private ntv_SecondaryColor3svEXT_1 := GetProcOrNil&<procedure(var v: Int16)>(SecondaryColor3svEXT_adr);
    private ntv_SecondaryColor3svEXT_2 := GetProcOrNil&<procedure(var v: Vec3s)>(SecondaryColor3svEXT_adr);
    private ntv_SecondaryColor3svEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(SecondaryColor3svEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3svEXT(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_SecondaryColor3svEXT_1(v[0]) else
        ntv_SecondaryColor3svEXT_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3svEXT(var v: Vec3s) :=
      ntv_SecondaryColor3svEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3svEXT(var v: Int16) :=
      ntv_SecondaryColor3svEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3svEXT(v: IntPtr) :=
      ntv_SecondaryColor3svEXT_3(v);
    
    private SecondaryColor3ubEXT_adr := GetProcAddress('glSecondaryColor3ubEXT');
    private ntv_SecondaryColor3ubEXT_1 := GetProcOrNil&<procedure(red: Byte; green: Byte; blue: Byte)>(SecondaryColor3ubEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubEXT(red: Byte; green: Byte; blue: Byte) :=
      ntv_SecondaryColor3ubEXT_1(red, green, blue);
    
    private SecondaryColor3ubvEXT_adr := GetProcAddress('glSecondaryColor3ubvEXT');
    private ntv_SecondaryColor3ubvEXT_1 := GetProcOrNil&<procedure(var v: Byte)>(SecondaryColor3ubvEXT_adr);
    private ntv_SecondaryColor3ubvEXT_2 := GetProcOrNil&<procedure(var v: Vec3ub)>(SecondaryColor3ubvEXT_adr);
    private ntv_SecondaryColor3ubvEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(SecondaryColor3ubvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubvEXT(v: array of Byte);
    type PByte = ^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_SecondaryColor3ubvEXT_1(v[0]) else
        ntv_SecondaryColor3ubvEXT_1(PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubvEXT(var v: Vec3ub) :=
      ntv_SecondaryColor3ubvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubvEXT(var v: Byte) :=
      ntv_SecondaryColor3ubvEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubvEXT(v: IntPtr) :=
      ntv_SecondaryColor3ubvEXT_3(v);
    
    private SecondaryColor3uiEXT_adr := GetProcAddress('glSecondaryColor3uiEXT');
    private ntv_SecondaryColor3uiEXT_1 := GetProcOrNil&<procedure(red: UInt32; green: UInt32; blue: UInt32)>(SecondaryColor3uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uiEXT(red: UInt32; green: UInt32; blue: UInt32) :=
      ntv_SecondaryColor3uiEXT_1(red, green, blue);
    
    private SecondaryColor3uivEXT_adr := GetProcAddress('glSecondaryColor3uivEXT');
    private ntv_SecondaryColor3uivEXT_1 := GetProcOrNil&<procedure(var v: UInt32)>(SecondaryColor3uivEXT_adr);
    private ntv_SecondaryColor3uivEXT_2 := GetProcOrNil&<procedure(var v: Vec3ui)>(SecondaryColor3uivEXT_adr);
    private ntv_SecondaryColor3uivEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(SecondaryColor3uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uivEXT(v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_SecondaryColor3uivEXT_1(v[0]) else
        ntv_SecondaryColor3uivEXT_1(PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uivEXT(var v: Vec3ui) :=
      ntv_SecondaryColor3uivEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uivEXT(var v: UInt32) :=
      ntv_SecondaryColor3uivEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uivEXT(v: IntPtr) :=
      ntv_SecondaryColor3uivEXT_3(v);
    
    private SecondaryColor3usEXT_adr := GetProcAddress('glSecondaryColor3usEXT');
    private ntv_SecondaryColor3usEXT_1 := GetProcOrNil&<procedure(red: UInt16; green: UInt16; blue: UInt16)>(SecondaryColor3usEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usEXT(red: UInt16; green: UInt16; blue: UInt16) :=
      ntv_SecondaryColor3usEXT_1(red, green, blue);
    
    private SecondaryColor3usvEXT_adr := GetProcAddress('glSecondaryColor3usvEXT');
    private ntv_SecondaryColor3usvEXT_1 := GetProcOrNil&<procedure(var v: UInt16)>(SecondaryColor3usvEXT_adr);
    private ntv_SecondaryColor3usvEXT_2 := GetProcOrNil&<procedure(var v: Vec3us)>(SecondaryColor3usvEXT_adr);
    private ntv_SecondaryColor3usvEXT_3 := GetProcOrNil&<procedure(v: IntPtr)>(SecondaryColor3usvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usvEXT(v: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_SecondaryColor3usvEXT_1(v[0]) else
        ntv_SecondaryColor3usvEXT_1(PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usvEXT(var v: Vec3us) :=
      ntv_SecondaryColor3usvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usvEXT(var v: UInt16) :=
      ntv_SecondaryColor3usvEXT_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usvEXT(v: IntPtr) :=
      ntv_SecondaryColor3usvEXT_3(v);
    
    private SecondaryColorPointerEXT_adr := GetProcAddress('glSecondaryColorPointerEXT');
    private ntv_SecondaryColorPointerEXT_1 := GetProcOrNil&<procedure(size: Int32; &type: glColorPointerType; stride: Int32; pointer: IntPtr)>(SecondaryColorPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointerEXT(size: Int32; &type: glColorPointerType; stride: Int32; pointer: IntPtr) :=
      ntv_SecondaryColorPointerEXT_1(size, &type, stride, pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSemaphoreEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_semaphore';
    
    private GetUnsignedBytevEXT_adr := GetProcAddress('glGetUnsignedBytevEXT');
    private ntv_GetUnsignedBytevEXT_1 := GetProcOrNil&<procedure(pname: glGetPName; var data: Byte)>(GetUnsignedBytevEXT_adr);
    private ntv_GetUnsignedBytevEXT_2 := GetProcOrNil&<procedure(pname: glGetPName; data: IntPtr)>(GetUnsignedBytevEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytevEXT(pname: glGetPName; var data: Byte) :=
      ntv_GetUnsignedBytevEXT_1(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytevEXT(pname: glGetPName; data: IntPtr) :=
      ntv_GetUnsignedBytevEXT_2(pname, data);
    
    private GetUnsignedBytei_vEXT_adr := GetProcAddress('glGetUnsignedBytei_vEXT');
    private ntv_GetUnsignedBytei_vEXT_1 := GetProcOrNil&<procedure(target: DummyEnum; index: UInt32; var data: Byte)>(GetUnsignedBytei_vEXT_adr);
    private ntv_GetUnsignedBytei_vEXT_2 := GetProcOrNil&<procedure(target: DummyEnum; index: UInt32; data: IntPtr)>(GetUnsignedBytei_vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytei_vEXT(target: DummyEnum; index: UInt32; var data: Byte) :=
      ntv_GetUnsignedBytei_vEXT_1(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytei_vEXT(target: DummyEnum; index: UInt32; data: IntPtr) :=
      ntv_GetUnsignedBytei_vEXT_2(target, index, data);
    
    private GenSemaphoresEXT_adr := GetProcAddress('glGenSemaphoresEXT');
    private ntv_GenSemaphoresEXT_1 := GetProcOrNil&<procedure(n: Int32; var semaphores: UInt32)>(GenSemaphoresEXT_adr);
    private ntv_GenSemaphoresEXT_2 := GetProcOrNil&<procedure(n: Int32; semaphores: IntPtr)>(GenSemaphoresEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSemaphoresEXT(n: Int32; semaphores: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (semaphores<>nil) and (semaphores.Length<>0) then
        ntv_GenSemaphoresEXT_1(n, semaphores[0]) else
        ntv_GenSemaphoresEXT_1(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSemaphoresEXT(n: Int32; var semaphores: UInt32) :=
      ntv_GenSemaphoresEXT_1(n, semaphores);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSemaphoresEXT(n: Int32; semaphores: IntPtr) :=
      ntv_GenSemaphoresEXT_2(n, semaphores);
    
    private DeleteSemaphoresEXT_adr := GetProcAddress('glDeleteSemaphoresEXT');
    private ntv_DeleteSemaphoresEXT_1 := GetProcOrNil&<procedure(n: Int32; var semaphores: UInt32)>(DeleteSemaphoresEXT_adr);
    private ntv_DeleteSemaphoresEXT_2 := GetProcOrNil&<procedure(n: Int32; semaphores: IntPtr)>(DeleteSemaphoresEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSemaphoresEXT(n: Int32; semaphores: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (semaphores<>nil) and (semaphores.Length<>0) then
        ntv_DeleteSemaphoresEXT_1(n, semaphores[0]) else
        ntv_DeleteSemaphoresEXT_1(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSemaphoresEXT(n: Int32; var semaphores: UInt32) :=
      ntv_DeleteSemaphoresEXT_1(n, semaphores);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSemaphoresEXT(n: Int32; semaphores: IntPtr) :=
      ntv_DeleteSemaphoresEXT_2(n, semaphores);
    
    private IsSemaphoreEXT_adr := GetProcAddress('glIsSemaphoreEXT');
    private ntv_IsSemaphoreEXT_1 := GetProcOrNil&<function(semaphore: UInt32): glBool8>(IsSemaphoreEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsSemaphoreEXT(semaphore: UInt32): glBool8 :=
      ntv_IsSemaphoreEXT_1(semaphore);
    
    private SemaphoreParameterui64vEXT_adr := GetProcAddress('glSemaphoreParameterui64vEXT');
    private ntv_SemaphoreParameterui64vEXT_1 := GetProcOrNil&<procedure(semaphore: UInt32; pname: glSemaphoreParameterName; var &params: UInt64)>(SemaphoreParameterui64vEXT_adr);
    private ntv_SemaphoreParameterui64vEXT_2 := GetProcOrNil&<procedure(semaphore: UInt32; pname: glSemaphoreParameterName; &params: IntPtr)>(SemaphoreParameterui64vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterui64vEXT(semaphore: UInt32; pname: glSemaphoreParameterName; &params: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_SemaphoreParameterui64vEXT_1(semaphore, pname, &params[0]) else
        ntv_SemaphoreParameterui64vEXT_1(semaphore, pname, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterui64vEXT(semaphore: UInt32; pname: glSemaphoreParameterName; var &params: UInt64) :=
      ntv_SemaphoreParameterui64vEXT_1(semaphore, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterui64vEXT(semaphore: UInt32; pname: glSemaphoreParameterName; &params: IntPtr) :=
      ntv_SemaphoreParameterui64vEXT_2(semaphore, pname, &params);
    
    private GetSemaphoreParameterui64vEXT_adr := GetProcAddress('glGetSemaphoreParameterui64vEXT');
    private ntv_GetSemaphoreParameterui64vEXT_1 := GetProcOrNil&<procedure(semaphore: UInt32; pname: glSemaphoreParameterName; var &params: UInt64)>(GetSemaphoreParameterui64vEXT_adr);
    private ntv_GetSemaphoreParameterui64vEXT_2 := GetProcOrNil&<procedure(semaphore: UInt32; pname: glSemaphoreParameterName; &params: IntPtr)>(GetSemaphoreParameterui64vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSemaphoreParameterui64vEXT(semaphore: UInt32; pname: glSemaphoreParameterName; var &params: UInt64) :=
      ntv_GetSemaphoreParameterui64vEXT_1(semaphore, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSemaphoreParameterui64vEXT(semaphore: UInt32; pname: glSemaphoreParameterName; &params: IntPtr) :=
      ntv_GetSemaphoreParameterui64vEXT_2(semaphore, pname, &params);
    
    private WaitSemaphoreEXT_adr := GetProcAddress('glWaitSemaphoreEXT');
    private ntv_WaitSemaphoreEXT_1 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; var textures: gl_texture; var srcLayouts: glTextureLayout)>(WaitSemaphoreEXT_adr);
    private ntv_WaitSemaphoreEXT_2 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; var textures: gl_texture; srcLayouts: IntPtr)>(WaitSemaphoreEXT_adr);
    private ntv_WaitSemaphoreEXT_3 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; textures: IntPtr; var srcLayouts: glTextureLayout)>(WaitSemaphoreEXT_adr);
    private ntv_WaitSemaphoreEXT_4 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; textures: IntPtr; srcLayouts: IntPtr)>(WaitSemaphoreEXT_adr);
    private ntv_WaitSemaphoreEXT_5 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; var textures: gl_texture; var srcLayouts: glTextureLayout)>(WaitSemaphoreEXT_adr);
    private ntv_WaitSemaphoreEXT_6 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; var textures: gl_texture; srcLayouts: IntPtr)>(WaitSemaphoreEXT_adr);
    private ntv_WaitSemaphoreEXT_7 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; textures: IntPtr; var srcLayouts: glTextureLayout)>(WaitSemaphoreEXT_adr);
    private ntv_WaitSemaphoreEXT_8 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; textures: IntPtr; srcLayouts: IntPtr)>(WaitSemaphoreEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of gl_buffer; numTextureBarriers: UInt32; textures: array of gl_texture; srcLayouts: array of glTextureLayout);
    type PGl_buffer = ^gl_buffer;
    type PGl_texture = ^gl_texture;
    type PGlTextureLayout = ^glTextureLayout;
    begin
      if (srcLayouts<>nil) and (srcLayouts.Length<>0) then
        if (buffers<>nil) and (buffers.Length<>0) then
          if (textures<>nil) and (textures.Length<>0) then
            ntv_WaitSemaphoreEXT_1(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], srcLayouts[0]) else
            ntv_WaitSemaphoreEXT_1(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, PGl_texture(nil)^, srcLayouts[0]) else
          if (textures<>nil) and (textures.Length<>0) then
            ntv_WaitSemaphoreEXT_1(semaphore, numBufferBarriers, PGl_buffer(nil)^, numTextureBarriers, textures[0], srcLayouts[0]) else
            ntv_WaitSemaphoreEXT_1(semaphore, numBufferBarriers, PGl_buffer(nil)^, numTextureBarriers, PGl_texture(nil)^, srcLayouts[0]) else
        if (buffers<>nil) and (buffers.Length<>0) then
          if (textures<>nil) and (textures.Length<>0) then
            ntv_WaitSemaphoreEXT_1(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], PGlTextureLayout(nil)^) else
            ntv_WaitSemaphoreEXT_1(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, PGl_texture(nil)^, PGlTextureLayout(nil)^) else
          if (textures<>nil) and (textures.Length<>0) then
            ntv_WaitSemaphoreEXT_1(semaphore, numBufferBarriers, PGl_buffer(nil)^, numTextureBarriers, textures[0], PGlTextureLayout(nil)^) else
            ntv_WaitSemaphoreEXT_1(semaphore, numBufferBarriers, PGl_buffer(nil)^, numTextureBarriers, PGl_texture(nil)^, PGlTextureLayout(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; var textures: gl_texture; var srcLayouts: glTextureLayout) :=
      ntv_WaitSemaphoreEXT_1(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; var textures: gl_texture; srcLayouts: IntPtr) :=
      ntv_WaitSemaphoreEXT_2(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; textures: IntPtr; var srcLayouts: glTextureLayout) :=
      ntv_WaitSemaphoreEXT_3(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; textures: IntPtr; srcLayouts: IntPtr) :=
      ntv_WaitSemaphoreEXT_4(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; var textures: gl_texture; var srcLayouts: glTextureLayout) :=
      ntv_WaitSemaphoreEXT_5(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; var textures: gl_texture; srcLayouts: IntPtr) :=
      ntv_WaitSemaphoreEXT_6(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; textures: IntPtr; var srcLayouts: glTextureLayout) :=
      ntv_WaitSemaphoreEXT_7(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; textures: IntPtr; srcLayouts: IntPtr) :=
      ntv_WaitSemaphoreEXT_8(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    
    private SignalSemaphoreEXT_adr := GetProcAddress('glSignalSemaphoreEXT');
    private ntv_SignalSemaphoreEXT_1 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; var textures: gl_texture; var dstLayouts: glTextureLayout)>(SignalSemaphoreEXT_adr);
    private ntv_SignalSemaphoreEXT_2 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; var textures: gl_texture; dstLayouts: IntPtr)>(SignalSemaphoreEXT_adr);
    private ntv_SignalSemaphoreEXT_3 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; textures: IntPtr; var dstLayouts: glTextureLayout)>(SignalSemaphoreEXT_adr);
    private ntv_SignalSemaphoreEXT_4 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; textures: IntPtr; dstLayouts: IntPtr)>(SignalSemaphoreEXT_adr);
    private ntv_SignalSemaphoreEXT_5 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; var textures: gl_texture; var dstLayouts: glTextureLayout)>(SignalSemaphoreEXT_adr);
    private ntv_SignalSemaphoreEXT_6 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; var textures: gl_texture; dstLayouts: IntPtr)>(SignalSemaphoreEXT_adr);
    private ntv_SignalSemaphoreEXT_7 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; textures: IntPtr; var dstLayouts: glTextureLayout)>(SignalSemaphoreEXT_adr);
    private ntv_SignalSemaphoreEXT_8 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; textures: IntPtr; dstLayouts: IntPtr)>(SignalSemaphoreEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of gl_buffer; numTextureBarriers: UInt32; textures: array of gl_texture; dstLayouts: array of glTextureLayout);
    type PGl_buffer = ^gl_buffer;
    type PGl_texture = ^gl_texture;
    type PGlTextureLayout = ^glTextureLayout;
    begin
      if (dstLayouts<>nil) and (dstLayouts.Length<>0) then
        if (buffers<>nil) and (buffers.Length<>0) then
          if (textures<>nil) and (textures.Length<>0) then
            ntv_SignalSemaphoreEXT_1(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], dstLayouts[0]) else
            ntv_SignalSemaphoreEXT_1(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, PGl_texture(nil)^, dstLayouts[0]) else
          if (textures<>nil) and (textures.Length<>0) then
            ntv_SignalSemaphoreEXT_1(semaphore, numBufferBarriers, PGl_buffer(nil)^, numTextureBarriers, textures[0], dstLayouts[0]) else
            ntv_SignalSemaphoreEXT_1(semaphore, numBufferBarriers, PGl_buffer(nil)^, numTextureBarriers, PGl_texture(nil)^, dstLayouts[0]) else
        if (buffers<>nil) and (buffers.Length<>0) then
          if (textures<>nil) and (textures.Length<>0) then
            ntv_SignalSemaphoreEXT_1(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], PGlTextureLayout(nil)^) else
            ntv_SignalSemaphoreEXT_1(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, PGl_texture(nil)^, PGlTextureLayout(nil)^) else
          if (textures<>nil) and (textures.Length<>0) then
            ntv_SignalSemaphoreEXT_1(semaphore, numBufferBarriers, PGl_buffer(nil)^, numTextureBarriers, textures[0], PGlTextureLayout(nil)^) else
            ntv_SignalSemaphoreEXT_1(semaphore, numBufferBarriers, PGl_buffer(nil)^, numTextureBarriers, PGl_texture(nil)^, PGlTextureLayout(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; var textures: gl_texture; var dstLayouts: glTextureLayout) :=
      ntv_SignalSemaphoreEXT_1(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; var textures: gl_texture; dstLayouts: IntPtr) :=
      ntv_SignalSemaphoreEXT_2(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; textures: IntPtr; var dstLayouts: glTextureLayout) :=
      ntv_SignalSemaphoreEXT_3(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; textures: IntPtr; dstLayouts: IntPtr) :=
      ntv_SignalSemaphoreEXT_4(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; var textures: gl_texture; var dstLayouts: glTextureLayout) :=
      ntv_SignalSemaphoreEXT_5(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; var textures: gl_texture; dstLayouts: IntPtr) :=
      ntv_SignalSemaphoreEXT_6(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; textures: IntPtr; var dstLayouts: glTextureLayout) :=
      ntv_SignalSemaphoreEXT_7(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; textures: IntPtr; dstLayouts: IntPtr) :=
      ntv_SignalSemaphoreEXT_8(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSemaphoreFdEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_semaphore_fd';
    
    private ImportSemaphoreFdEXT_adr := GetProcAddress('glImportSemaphoreFdEXT');
    private ntv_ImportSemaphoreFdEXT_1 := GetProcOrNil&<procedure(semaphore: UInt32; handleType: glExternalHandleType; fd: Int32)>(ImportSemaphoreFdEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportSemaphoreFdEXT(semaphore: UInt32; handleType: glExternalHandleType; fd: Int32) :=
      ntv_ImportSemaphoreFdEXT_1(semaphore, handleType, fd);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSemaphoreWin32EXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_semaphore_win32';
    
    private ImportSemaphoreWin32HandleEXT_adr := GetProcAddress('glImportSemaphoreWin32HandleEXT');
    private ntv_ImportSemaphoreWin32HandleEXT_1 := GetProcOrNil&<procedure(semaphore: UInt32; handleType: glExternalHandleType; handle: IntPtr)>(ImportSemaphoreWin32HandleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportSemaphoreWin32HandleEXT(semaphore: UInt32; handleType: glExternalHandleType; handle: IntPtr) :=
      ntv_ImportSemaphoreWin32HandleEXT_1(semaphore, handleType, handle);
    
    private ImportSemaphoreWin32NameEXT_adr := GetProcAddress('glImportSemaphoreWin32NameEXT');
    private ntv_ImportSemaphoreWin32NameEXT_1 := GetProcOrNil&<procedure(semaphore: UInt32; handleType: glExternalHandleType; name: IntPtr)>(ImportSemaphoreWin32NameEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportSemaphoreWin32NameEXT(semaphore: UInt32; handleType: glExternalHandleType; name: IntPtr) :=
      ntv_ImportSemaphoreWin32NameEXT_1(semaphore, handleType, name);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSeparateShaderObjectsEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_separate_shader_objects';
    
    private UseShaderProgramEXT_adr := GetProcAddress('glUseShaderProgramEXT');
    private ntv_UseShaderProgramEXT_1 := GetProcOrNil&<procedure(&type: DummyEnum; &program: gl_program)>(UseShaderProgramEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseShaderProgramEXT(&type: DummyEnum; &program: gl_program) :=
      ntv_UseShaderProgramEXT_1(&type, &program);
    
    private ActiveProgramEXT_adr := GetProcAddress('glActiveProgramEXT');
    private ntv_ActiveProgramEXT_1 := GetProcOrNil&<procedure(&program: gl_program)>(ActiveProgramEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveProgramEXT(&program: gl_program) :=
      ntv_ActiveProgramEXT_1(&program);
    
    private CreateShaderProgramEXT_adr := GetProcAddress('glCreateShaderProgramEXT');
    private ntv_CreateShaderProgramEXT_1 := GetProcOrNil&<function(&type: glShaderType; string: IntPtr): gl_program>(CreateShaderProgramEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramEXT(&type: glShaderType; string: string): gl_program;
    begin
      var string_str_ptr := Marshal.StringToHGlobalAnsi(string);
      try
        Result := ntv_CreateShaderProgramEXT_1(&type, string_str_ptr);
      finally
        Marshal.FreeHGlobal(string_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramEXT(&type: glShaderType; string: IntPtr): gl_program :=
      ntv_CreateShaderProgramEXT_1(&type, string);
    
  end;
  
  ///
  glSeparateSpecularColorEXT = static class
    public const _ExtStr = 'GL_EXT_separate_specular_color';
  end;
  
  ///
  glShaderFramebufferFetchEXT = static class
    public const _ExtStr = 'GL_EXT_shader_framebuffer_fetch';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glShaderFramebufferFetchNonCoherentEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_shader_framebuffer_fetch_non_coherent';
    
    private FramebufferFetchBarrierEXT_adr := GetProcAddress('glFramebufferFetchBarrierEXT');
    private ntv_FramebufferFetchBarrierEXT_1 := GetProcOrNil&<procedure>(FramebufferFetchBarrierEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferFetchBarrierEXT :=
      ntv_FramebufferFetchBarrierEXT_1;
    
  end;
  
  ///
  glShaderImageLoadFormattedEXT = static class
    public const _ExtStr = 'GL_EXT_shader_image_load_formatted';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glShaderImageLoadStoreEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_shader_image_load_store';
    
    private BindImageTextureEXT_adr := GetProcAddress('glBindImageTextureEXT');
    private ntv_BindImageTextureEXT_1 := GetProcOrNil&<procedure(index: UInt32; texture: gl_texture; level: Int32; layered: glBool8; layer: Int32; access: glBufferAccess; format: Int32)>(BindImageTextureEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextureEXT(index: UInt32; texture: gl_texture; level: Int32; layered: glBool8; layer: Int32; access: glBufferAccess; format: Int32) :=
      ntv_BindImageTextureEXT_1(index, texture, level, layered, layer, access, format);
    
    private MemoryBarrierEXT_adr := GetProcAddress('glMemoryBarrierEXT');
    private ntv_MemoryBarrierEXT_1 := GetProcOrNil&<procedure(barriers: glMemoryBarrierMask)>(MemoryBarrierEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryBarrierEXT(barriers: glMemoryBarrierMask) :=
      ntv_MemoryBarrierEXT_1(barriers);
    
  end;
  
  ///
  glShaderIntegerMixEXT = static class
    public const _ExtStr = 'GL_EXT_shader_integer_mix';
  end;
  
  ///
  glShaderSamplesIdenticalEXT = static class
    public const _ExtStr = 'GL_EXT_shader_samples_identical';
  end;
  
  ///
  glShadowFuncsEXT = static class
    public const _ExtStr = 'GL_EXT_shadow_funcs';
  end;
  
  ///
  glSharedTexturePaletteEXT = static class
    public const _ExtStr = 'GL_EXT_shared_texture_palette';
  end;
  
  ///
  glSparseTexture2EXT = static class
    public const _ExtStr = 'GL_EXT_sparse_texture2';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glStencilClearTagEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_stencil_clear_tag';
    
    private StencilClearTagEXT_adr := GetProcAddress('glStencilClearTagEXT');
    private ntv_StencilClearTagEXT_1 := GetProcOrNil&<procedure(stencilTagBits: Int32; stencilClearTag: UInt32)>(StencilClearTagEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilClearTagEXT(stencilTagBits: Int32; stencilClearTag: UInt32) :=
      ntv_StencilClearTagEXT_1(stencilTagBits, stencilClearTag);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glStencilTwoSideEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_stencil_two_side';
    
    private ActiveStencilFaceEXT_adr := GetProcAddress('glActiveStencilFaceEXT');
    private ntv_ActiveStencilFaceEXT_1 := GetProcOrNil&<procedure(face: glTriangleFace)>(ActiveStencilFaceEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveStencilFaceEXT(face: glTriangleFace) :=
      ntv_ActiveStencilFaceEXT_1(face);
    
  end;
  
  ///
  glStencilWrapEXT = static class
    public const _ExtStr = 'GL_EXT_stencil_wrap';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSubtextureEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_subtexture';
    
    private TexSubImage1DEXT_adr := GetProcAddress('glTexSubImage1DEXT');
    private ntv_TexSubImage1DEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; width: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TexSubImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage1DEXT(target: glTextureTarget; level: Int32; xoffset: Int32; width: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TexSubImage1DEXT_1(target, level, xoffset, width, format, &type, pixels);
    
    private TexSubImage2DEXT_adr := GetProcAddress('glTexSubImage2DEXT');
    private ntv_TexSubImage2DEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TexSubImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage2DEXT(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TexSubImage2DEXT_1(target, level, xoffset, yoffset, width, height, format, &type, pixels);
    
  end;
  
  ///
  glTextureEXT = static class
    public const _ExtStr = 'GL_EXT_texture';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureArrayEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_texture_array';
    
    private FramebufferTextureLayerEXT_adr := GetProcAddress('glFramebufferTextureLayerEXT');
    private ntv_FramebufferTextureLayerEXT_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32)>(FramebufferTextureLayerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureLayerEXT(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32) :=
      ntv_FramebufferTextureLayerEXT_1(target, attachment, texture, level, layer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureBufferObjectEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_texture_buffer_object';
    
    private TexBufferEXT_adr := GetProcAddress('glTexBufferEXT');
    private ntv_TexBufferEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; internalformat: glSizedInternalFormat; buffer: gl_buffer)>(TexBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBufferEXT(target: glTextureTarget; internalformat: glSizedInternalFormat; buffer: gl_buffer) :=
      ntv_TexBufferEXT_1(target, internalformat, buffer);
    
  end;
  
  ///
  glTextureCompressionLatcEXT = static class
    public const _ExtStr = 'GL_EXT_texture_compression_latc';
  end;
  
  ///
  glTextureCompressionRgtcEXT = static class
    public const _ExtStr = 'GL_EXT_texture_compression_rgtc';
  end;
  
  ///
  glTextureCompressionS3tcEXT = static class
    public const _ExtStr = 'GL_EXT_texture_compression_s3tc';
  end;
  
  ///
  glTextureCubeMapEXT = static class
    public const _ExtStr = 'GL_EXT_texture_cube_map';
  end;
  
  ///
  glTextureEnvAddEXT = static class
    public const _ExtStr = 'GL_EXT_texture_env_add';
  end;
  
  ///
  glTextureEnvCombineEXT = static class
    public const _ExtStr = 'GL_EXT_texture_env_combine';
  end;
  
  ///
  glTextureEnvDot3EXT = static class
    public const _ExtStr = 'GL_EXT_texture_env_dot3';
  end;
  
  ///
  glTextureFilterAnisotropicEXT = static class
    public const _ExtStr = 'GL_EXT_texture_filter_anisotropic';
  end;
  
  ///
  glTextureFilterMinmaxEXT = static class
    public const _ExtStr = 'GL_EXT_texture_filter_minmax';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureIntegerEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_texture_integer';
    
    private TexParameterIivEXT_adr := GetProcAddress('glTexParameterIivEXT');
    private ntv_TexParameterIivEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; var &params: Int32)>(TexParameterIivEXT_adr);
    private ntv_TexParameterIivEXT_2 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr)>(TexParameterIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIivEXT(target: glTextureTarget; pname: glTextureParameterName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TexParameterIivEXT_1(target, pname, &params[0]) else
        ntv_TexParameterIivEXT_1(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIivEXT(target: glTextureTarget; pname: glTextureParameterName; var &params: Int32) :=
      ntv_TexParameterIivEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIivEXT(target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_TexParameterIivEXT_2(target, pname, &params);
    
    private TexParameterIuivEXT_adr := GetProcAddress('glTexParameterIuivEXT');
    private ntv_TexParameterIuivEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; var &params: UInt32)>(TexParameterIuivEXT_adr);
    private ntv_TexParameterIuivEXT_2 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr)>(TexParameterIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuivEXT(target: glTextureTarget; pname: glTextureParameterName; &params: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TexParameterIuivEXT_1(target, pname, &params[0]) else
        ntv_TexParameterIuivEXT_1(target, pname, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuivEXT(target: glTextureTarget; pname: glTextureParameterName; var &params: UInt32) :=
      ntv_TexParameterIuivEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuivEXT(target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_TexParameterIuivEXT_2(target, pname, &params);
    
    private GetTexParameterIivEXT_adr := GetProcAddress('glGetTexParameterIivEXT');
    private ntv_GetTexParameterIivEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glGetTextureParameter; var &params: Int32)>(GetTexParameterIivEXT_adr);
    private ntv_GetTexParameterIivEXT_2 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr)>(GetTexParameterIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIivEXT(target: glTextureTarget; pname: glGetTextureParameter; var &params: Int32) :=
      ntv_GetTexParameterIivEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIivEXT(target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTexParameterIivEXT_2(target, pname, &params);
    
    private GetTexParameterIuivEXT_adr := GetProcAddress('glGetTexParameterIuivEXT');
    private ntv_GetTexParameterIuivEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glGetTextureParameter; var &params: UInt32)>(GetTexParameterIuivEXT_adr);
    private ntv_GetTexParameterIuivEXT_2 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr)>(GetTexParameterIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuivEXT(target: glTextureTarget; pname: glGetTextureParameter; var &params: UInt32) :=
      ntv_GetTexParameterIuivEXT_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuivEXT(target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTexParameterIuivEXT_2(target, pname, &params);
    
    private ClearColorIiEXT_adr := GetProcAddress('glClearColorIiEXT');
    private ntv_ClearColorIiEXT_1 := GetProcOrNil&<procedure(red: Int32; green: Int32; blue: Int32; alpha: Int32)>(ClearColorIiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearColorIiEXT(red: Int32; green: Int32; blue: Int32; alpha: Int32) :=
      ntv_ClearColorIiEXT_1(red, green, blue, alpha);
    
    private ClearColorIuiEXT_adr := GetProcAddress('glClearColorIuiEXT');
    private ntv_ClearColorIuiEXT_1 := GetProcOrNil&<procedure(red: UInt32; green: UInt32; blue: UInt32; alpha: UInt32)>(ClearColorIuiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearColorIuiEXT(red: UInt32; green: UInt32; blue: UInt32; alpha: UInt32) :=
      ntv_ClearColorIuiEXT_1(red, green, blue, alpha);
    
  end;
  
  ///
  glTextureLodBiasEXT = static class
    public const _ExtStr = 'GL_EXT_texture_lod_bias';
  end;
  
  ///
  glTextureMirrorClampEXT = static class
    public const _ExtStr = 'GL_EXT_texture_mirror_clamp';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureObjectEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_texture_object';
    
    private AreTexturesResidentEXT_adr := GetProcAddress('glAreTexturesResidentEXT');
    private ntv_AreTexturesResidentEXT_1 := GetProcOrNil&<function(n: Int32; var textures: gl_texture; var residences: glBool8): glBool8>(AreTexturesResidentEXT_adr);
    private ntv_AreTexturesResidentEXT_2 := GetProcOrNil&<function(n: Int32; var textures: gl_texture; residences: IntPtr): glBool8>(AreTexturesResidentEXT_adr);
    private ntv_AreTexturesResidentEXT_3 := GetProcOrNil&<function(n: Int32; textures: IntPtr; var residences: glBool8): glBool8>(AreTexturesResidentEXT_adr);
    private ntv_AreTexturesResidentEXT_4 := GetProcOrNil&<function(n: Int32; textures: IntPtr; residences: IntPtr): glBool8>(AreTexturesResidentEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: array of gl_texture; residences: array of glBool8): glBool8;
    type PGl_texture = ^gl_texture;
    type PGlBool8 = ^glBool8;
    begin
      Result := if (residences<>nil) and (residences.Length<>0) then
        if (textures<>nil) and (textures.Length<>0) then
          ntv_AreTexturesResidentEXT_1(n, textures[0], residences[0]) else
          ntv_AreTexturesResidentEXT_1(n, PGl_texture(nil)^, residences[0]) else
        if (textures<>nil) and (textures.Length<>0) then
          ntv_AreTexturesResidentEXT_1(n, textures[0], PGlBool8(nil)^) else
          ntv_AreTexturesResidentEXT_1(n, PGl_texture(nil)^, PGlBool8(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; var textures: gl_texture; var residences: glBool8): glBool8 :=
      ntv_AreTexturesResidentEXT_1(n, textures, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; var textures: gl_texture; residences: IntPtr): glBool8 :=
      ntv_AreTexturesResidentEXT_2(n, textures, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: IntPtr; var residences: glBool8): glBool8 :=
      ntv_AreTexturesResidentEXT_3(n, textures, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: IntPtr; residences: IntPtr): glBool8 :=
      ntv_AreTexturesResidentEXT_4(n, textures, residences);
    
    private BindTextureEXT_adr := GetProcAddress('glBindTextureEXT');
    private ntv_BindTextureEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; texture: gl_texture)>(BindTextureEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextureEXT(target: glTextureTarget; texture: gl_texture) :=
      ntv_BindTextureEXT_1(target, texture);
    
    private DeleteTexturesEXT_adr := GetProcAddress('glDeleteTexturesEXT');
    private ntv_DeleteTexturesEXT_1 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture)>(DeleteTexturesEXT_adr);
    private ntv_DeleteTexturesEXT_2 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr)>(DeleteTexturesEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTexturesEXT(n: Int32; textures: array of gl_texture);
    type PGl_texture = ^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        ntv_DeleteTexturesEXT_1(n, textures[0]) else
        ntv_DeleteTexturesEXT_1(n, PGl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTexturesEXT(n: Int32; var textures: gl_texture) :=
      ntv_DeleteTexturesEXT_1(n, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTexturesEXT(n: Int32; textures: IntPtr) :=
      ntv_DeleteTexturesEXT_2(n, textures);
    
    private GenTexturesEXT_adr := GetProcAddress('glGenTexturesEXT');
    private ntv_GenTexturesEXT_1 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture)>(GenTexturesEXT_adr);
    private ntv_GenTexturesEXT_2 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr)>(GenTexturesEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTexturesEXT(n: Int32; textures: array of gl_texture);
    type PGl_texture = ^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        ntv_GenTexturesEXT_1(n, textures[0]) else
        ntv_GenTexturesEXT_1(n, PGl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTexturesEXT(n: Int32; var textures: gl_texture) :=
      ntv_GenTexturesEXT_1(n, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTexturesEXT(n: Int32; textures: IntPtr) :=
      ntv_GenTexturesEXT_2(n, textures);
    
    private IsTextureEXT_adr := GetProcAddress('glIsTextureEXT');
    private ntv_IsTextureEXT_1 := GetProcOrNil&<function(texture: gl_texture): glBool8>(IsTextureEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTextureEXT(texture: gl_texture): glBool8 :=
      ntv_IsTextureEXT_1(texture);
    
    private PrioritizeTexturesEXT_adr := GetProcAddress('glPrioritizeTexturesEXT');
    private ntv_PrioritizeTexturesEXT_1 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture; var priorities: single)>(PrioritizeTexturesEXT_adr);
    private ntv_PrioritizeTexturesEXT_2 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture; priorities: IntPtr)>(PrioritizeTexturesEXT_adr);
    private ntv_PrioritizeTexturesEXT_3 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr; var priorities: single)>(PrioritizeTexturesEXT_adr);
    private ntv_PrioritizeTexturesEXT_4 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr; priorities: IntPtr)>(PrioritizeTexturesEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: array of gl_texture; priorities: array of single);
    type PGl_texture = ^gl_texture;
    type PSingle = ^single;
    begin
      if (priorities<>nil) and (priorities.Length<>0) then
        if (textures<>nil) and (textures.Length<>0) then
          ntv_PrioritizeTexturesEXT_1(n, textures[0], priorities[0]) else
          ntv_PrioritizeTexturesEXT_1(n, PGl_texture(nil)^, priorities[0]) else
        if (textures<>nil) and (textures.Length<>0) then
          ntv_PrioritizeTexturesEXT_1(n, textures[0], PSingle(nil)^) else
          ntv_PrioritizeTexturesEXT_1(n, PGl_texture(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; var textures: gl_texture; var priorities: single) :=
      ntv_PrioritizeTexturesEXT_1(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; var textures: gl_texture; priorities: IntPtr) :=
      ntv_PrioritizeTexturesEXT_2(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: IntPtr; var priorities: single) :=
      ntv_PrioritizeTexturesEXT_3(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: IntPtr; priorities: IntPtr) :=
      ntv_PrioritizeTexturesEXT_4(n, textures, priorities);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTexturePerturbNormalEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_texture_perturb_normal';
    
    private TextureNormalEXT_adr := GetProcAddress('glTextureNormalEXT');
    private ntv_TextureNormalEXT_1 := GetProcOrNil&<procedure(mode: glTextureNormalMode)>(TextureNormalEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureNormalEXT(mode: glTextureNormalMode) :=
      ntv_TextureNormalEXT_1(mode);
    
  end;
  
  ///
  glTextureShadowLodEXT = static class
    public const _ExtStr = 'GL_EXT_texture_shadow_lod';
  end;
  
  ///
  glTextureSharedExponentEXT = static class
    public const _ExtStr = 'GL_EXT_texture_shared_exponent';
  end;
  
  ///
  glTextureSnormEXT = static class
    public const _ExtStr = 'GL_EXT_texture_snorm';
  end;
  
  ///
  glTextureSRGBEXT = static class
    public const _ExtStr = 'GL_EXT_texture_sRGB';
  end;
  
  ///
  glTextureSRGBDecodeEXT = static class
    public const _ExtStr = 'GL_EXT_texture_sRGB_decode';
  end;
  
  ///
  glTextureSRGBR8EXT = static class
    public const _ExtStr = 'GL_EXT_texture_sRGB_R8';
  end;
  
  ///
  glTextureSRGBRG8EXT = static class
    public const _ExtStr = 'GL_EXT_texture_sRGB_RG8';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureStorageEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_texture_storage';
    
    private TexStorage1DEXT_adr := GetProcAddress('glTexStorage1DEXT');
    private ntv_TexStorage1DEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32)>(TexStorage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage1DEXT(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32) :=
      ntv_TexStorage1DEXT_1(target, levels, internalformat, width);
    
    private TexStorage2DEXT_adr := GetProcAddress('glTexStorage2DEXT');
    private ntv_TexStorage2DEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32)>(TexStorage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage2DEXT(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32) :=
      ntv_TexStorage2DEXT_1(target, levels, internalformat, width, height);
    
    private TexStorage3DEXT_adr := GetProcAddress('glTexStorage3DEXT');
    private ntv_TexStorage3DEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32)>(TexStorage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage3DEXT(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32) :=
      ntv_TexStorage3DEXT_1(target, levels, internalformat, width, height, depth);
    
    private TextureStorage1DEXT_adr := GetProcAddress('glTextureStorage1DEXT');
    private ntv_TextureStorage1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32)>(TextureStorage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage1DEXT(texture: gl_texture; target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32) :=
      ntv_TextureStorage1DEXT_1(texture, target, levels, internalformat, width);
    
    private TextureStorage2DEXT_adr := GetProcAddress('glTextureStorage2DEXT');
    private ntv_TextureStorage2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32)>(TextureStorage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2DEXT(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32) :=
      ntv_TextureStorage2DEXT_1(texture, target, levels, internalformat, width, height);
    
    private TextureStorage3DEXT_adr := GetProcAddress('glTextureStorage3DEXT');
    private ntv_TextureStorage3DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32)>(TextureStorage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3DEXT(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32) :=
      ntv_TextureStorage3DEXT_1(texture, target, levels, internalformat, width, height, depth);
    
  end;
  
  ///
  glTextureSwizzleEXT = static class
    public const _ExtStr = 'GL_EXT_texture_swizzle';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTexture3DEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_texture3D';
    
    private TexImage3DEXT_adr := GetProcAddress('glTexImage3DEXT');
    private ntv_TexImage3DEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TexImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3DEXT(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TexImage3DEXT_1(target, level, internalformat, width, height, depth, border, format, &type, pixels);
    
    private TexSubImage3DEXT_adr := GetProcAddress('glTexSubImage3DEXT');
    private ntv_TexSubImage3DEXT_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TexSubImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage3DEXT(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TexSubImage3DEXT_1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTimerQueryEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_timer_query';
    
    private GetQueryObjecti64vEXT_adr := GetProcAddress('glGetQueryObjecti64vEXT');
    private ntv_GetQueryObjecti64vEXT_1 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; var &params: Int64)>(GetQueryObjecti64vEXT_adr);
    private ntv_GetQueryObjecti64vEXT_2 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr)>(GetQueryObjecti64vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjecti64vEXT(id: gl_query; pname: glQueryObjectParameterName; var &params: Int64) :=
      ntv_GetQueryObjecti64vEXT_1(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjecti64vEXT(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr) :=
      ntv_GetQueryObjecti64vEXT_2(id, pname, &params);
    
    private GetQueryObjectui64vEXT_adr := GetProcAddress('glGetQueryObjectui64vEXT');
    private ntv_GetQueryObjectui64vEXT_1 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; var &params: UInt64)>(GetQueryObjectui64vEXT_adr);
    private ntv_GetQueryObjectui64vEXT_2 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr)>(GetQueryObjectui64vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64vEXT(id: gl_query; pname: glQueryObjectParameterName; var &params: UInt64) :=
      ntv_GetQueryObjectui64vEXT_1(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64vEXT(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr) :=
      ntv_GetQueryObjectui64vEXT_2(id, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTransformFeedbackEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_transform_feedback';
    
    private BeginTransformFeedbackEXT_adr := GetProcAddress('glBeginTransformFeedbackEXT');
    private ntv_BeginTransformFeedbackEXT_1 := GetProcOrNil&<procedure(primitiveMode: glPrimitiveType)>(BeginTransformFeedbackEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginTransformFeedbackEXT(primitiveMode: glPrimitiveType) :=
      ntv_BeginTransformFeedbackEXT_1(primitiveMode);
    
    private EndTransformFeedbackEXT_adr := GetProcAddress('glEndTransformFeedbackEXT');
    private ntv_EndTransformFeedbackEXT_1 := GetProcOrNil&<procedure>(EndTransformFeedbackEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndTransformFeedbackEXT :=
      ntv_EndTransformFeedbackEXT_1;
    
    private BindBufferRangeEXT_adr := GetProcAddress('glBindBufferRangeEXT');
    private ntv_BindBufferRangeEXT_1 := GetProcOrNil&<procedure(target: glBufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(BindBufferRangeEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferRangeEXT(target: glBufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
      ntv_BindBufferRangeEXT_1(target, index, buffer, offset, size);
    
    private BindBufferOffsetEXT_adr := GetProcAddress('glBindBufferOffsetEXT');
    private ntv_BindBufferOffsetEXT_1 := GetProcOrNil&<procedure(target: glBufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr)>(BindBufferOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferOffsetEXT(target: glBufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr) :=
      ntv_BindBufferOffsetEXT_1(target, index, buffer, offset);
    
    private BindBufferBaseEXT_adr := GetProcAddress('glBindBufferBaseEXT');
    private ntv_BindBufferBaseEXT_1 := GetProcOrNil&<procedure(target: glBufferTarget; index: UInt32; buffer: gl_buffer)>(BindBufferBaseEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferBaseEXT(target: glBufferTarget; index: UInt32; buffer: gl_buffer) :=
      ntv_BindBufferBaseEXT_1(target, index, buffer);
    
    private TransformFeedbackVaryingsEXT_adr := GetProcAddress('glTransformFeedbackVaryingsEXT');
    private ntv_TransformFeedbackVaryingsEXT_1 := GetProcOrNil&<procedure(&program: gl_program; count: Int32; var varyings: IntPtr; bufferMode: glTransformFeedbackBufferMode)>(TransformFeedbackVaryingsEXT_adr);
    private ntv_TransformFeedbackVaryingsEXT_2 := GetProcOrNil&<procedure(&program: gl_program; count: Int32; varyings: pointer; bufferMode: glTransformFeedbackBufferMode)>(TransformFeedbackVaryingsEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsEXT(&program: gl_program; count: Int32; varyings: array of string; bufferMode: glTransformFeedbackBufferMode);
    begin
      if (varyings=nil) or (varyings.Length=0) then
      begin
        ntv_TransformFeedbackVaryingsEXT_2(&program, count, nil, bufferMode);
        exit;
      end;
      var varyings_temp_arr: array of IntPtr;
      try
        begin
          var varyings_org_el_1 := varyings;
          var varyings_len_1 := varyings_org_el_1.Length;
          SetLength(varyings_temp_arr, varyings_len_1);
          var varyings_tmp_el_1 := varyings_temp_arr;
          for var varyings_ind_1 := 0 to varyings_len_1-1 do
          begin
            var varyings_org_el_2 := varyings_org_el_1[varyings_ind_1];
            if (varyings_org_el_2=nil) or (varyings_org_el_2.Length=0) then continue;
            varyings_tmp_el_1[varyings_ind_1] := Marshal.StringToHGlobalAnsi(varyings_org_el_2);
          end;
        end;
        ntv_TransformFeedbackVaryingsEXT_1(&program, count, varyings_temp_arr[0], bufferMode);
      finally
         foreach var arr_el1 in varyings_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsEXT(&program: gl_program; count: Int32; var varyings: IntPtr; bufferMode: glTransformFeedbackBufferMode) :=
      ntv_TransformFeedbackVaryingsEXT_1(&program, count, varyings, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsEXT(&program: gl_program; count: Int32; varyings: pointer; bufferMode: glTransformFeedbackBufferMode) :=
      ntv_TransformFeedbackVaryingsEXT_2(&program, count, varyings, bufferMode);
    
    private GetTransformFeedbackVaryingEXT_adr := GetProcAddress('glGetTransformFeedbackVaryingEXT');
    private ntv_GetTransformFeedbackVaryingEXT_1 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: glAttributeType; name: IntPtr)>(GetTransformFeedbackVaryingEXT_adr);
    private ntv_GetTransformFeedbackVaryingEXT_2 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr)>(GetTransformFeedbackVaryingEXT_adr);
    private ntv_GetTransformFeedbackVaryingEXT_3 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: glAttributeType; name: IntPtr)>(GetTransformFeedbackVaryingEXT_adr);
    private ntv_GetTransformFeedbackVaryingEXT_4 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr)>(GetTransformFeedbackVaryingEXT_adr);
    private ntv_GetTransformFeedbackVaryingEXT_5 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: glAttributeType; name: IntPtr)>(GetTransformFeedbackVaryingEXT_adr);
    private ntv_GetTransformFeedbackVaryingEXT_6 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr)>(GetTransformFeedbackVaryingEXT_adr);
    private ntv_GetTransformFeedbackVaryingEXT_7 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: glAttributeType; name: IntPtr)>(GetTransformFeedbackVaryingEXT_adr);
    private ntv_GetTransformFeedbackVaryingEXT_8 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr)>(GetTransformFeedbackVaryingEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: glAttributeType; name: IntPtr) :=
      ntv_GetTransformFeedbackVaryingEXT_1(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr) :=
      ntv_GetTransformFeedbackVaryingEXT_2(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: glAttributeType; name: IntPtr) :=
      ntv_GetTransformFeedbackVaryingEXT_3(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr) :=
      ntv_GetTransformFeedbackVaryingEXT_4(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: glAttributeType; name: IntPtr) :=
      ntv_GetTransformFeedbackVaryingEXT_5(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr) :=
      ntv_GetTransformFeedbackVaryingEXT_6(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: glAttributeType; name: IntPtr) :=
      ntv_GetTransformFeedbackVaryingEXT_7(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr) :=
      ntv_GetTransformFeedbackVaryingEXT_8(&program, index, bufSize, length, size, &type, name);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexArrayEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_vertex_array';
    
    private ArrayElementEXT_adr := GetProcAddress('glArrayElementEXT');
    private ntv_ArrayElementEXT_1 := GetProcOrNil&<procedure(i: Int32)>(ArrayElementEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ArrayElementEXT(i: Int32) :=
      ntv_ArrayElementEXT_1(i);
    
    private ColorPointerEXT_adr := GetProcAddress('glColorPointerEXT');
    private ntv_ColorPointerEXT_1 := GetProcOrNil&<procedure(size: Int32; &type: glColorPointerType; stride: Int32; count: Int32; pointer: IntPtr)>(ColorPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointerEXT(size: Int32; &type: glColorPointerType; stride: Int32; count: Int32; pointer: IntPtr) :=
      ntv_ColorPointerEXT_1(size, &type, stride, count, pointer);
    
    private DrawArraysEXT_adr := GetProcAddress('glDrawArraysEXT');
    private ntv_DrawArraysEXT_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; first: Int32; count: Int32)>(DrawArraysEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysEXT(mode: glPrimitiveType; first: Int32; count: Int32) :=
      ntv_DrawArraysEXT_1(mode, first, count);
    
    private EdgeFlagPointerEXT_adr := GetProcAddress('glEdgeFlagPointerEXT');
    private ntv_EdgeFlagPointerEXT_1 := GetProcOrNil&<procedure(stride: Int32; count: Int32; var pointer: glBool8)>(EdgeFlagPointerEXT_adr);
    private ntv_EdgeFlagPointerEXT_2 := GetProcOrNil&<procedure(stride: Int32; count: Int32; pointer: IntPtr)>(EdgeFlagPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerEXT(stride: Int32; count: Int32; pointer: array of glBool8);
    type PGlBool8 = ^glBool8;
    begin
      if (pointer<>nil) and (pointer.Length<>0) then
        ntv_EdgeFlagPointerEXT_1(stride, count, pointer[0]) else
        ntv_EdgeFlagPointerEXT_1(stride, count, PGlBool8(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerEXT(stride: Int32; count: Int32; var pointer: glBool8) :=
      ntv_EdgeFlagPointerEXT_1(stride, count, pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerEXT(stride: Int32; count: Int32; pointer: IntPtr) :=
      ntv_EdgeFlagPointerEXT_2(stride, count, pointer);
    
    private GetPointervEXT_adr := GetProcAddress('glGetPointervEXT');
    private ntv_GetPointervEXT_1 := GetProcOrNil&<procedure(pname: glGetPointervPName; var &params: IntPtr)>(GetPointervEXT_adr);
    private ntv_GetPointervEXT_2 := GetProcOrNil&<procedure(pname: glGetPointervPName; &params: pointer)>(GetPointervEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointervEXT(pname: glGetPointervPName; var &params: IntPtr) :=
      ntv_GetPointervEXT_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointervEXT(pname: glGetPointervPName; &params: pointer) :=
      ntv_GetPointervEXT_2(pname, &params);
    
    private IndexPointerEXT_adr := GetProcAddress('glIndexPointerEXT');
    private ntv_IndexPointerEXT_1 := GetProcOrNil&<procedure(&type: glIndexPointerType; stride: Int32; count: Int32; pointer: IntPtr)>(IndexPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointerEXT(&type: glIndexPointerType; stride: Int32; count: Int32; pointer: IntPtr) :=
      ntv_IndexPointerEXT_1(&type, stride, count, pointer);
    
    private NormalPointerEXT_adr := GetProcAddress('glNormalPointerEXT');
    private ntv_NormalPointerEXT_1 := GetProcOrNil&<procedure(&type: glNormalPointerType; stride: Int32; count: Int32; pointer: IntPtr)>(NormalPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointerEXT(&type: glNormalPointerType; stride: Int32; count: Int32; pointer: IntPtr) :=
      ntv_NormalPointerEXT_1(&type, stride, count, pointer);
    
    private TexCoordPointerEXT_adr := GetProcAddress('glTexCoordPointerEXT');
    private ntv_TexCoordPointerEXT_1 := GetProcOrNil&<procedure(size: Int32; &type: glTexCoordPointerType; stride: Int32; count: Int32; pointer: IntPtr)>(TexCoordPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointerEXT(size: Int32; &type: glTexCoordPointerType; stride: Int32; count: Int32; pointer: IntPtr) :=
      ntv_TexCoordPointerEXT_1(size, &type, stride, count, pointer);
    
    private VertexPointerEXT_adr := GetProcAddress('glVertexPointerEXT');
    private ntv_VertexPointerEXT_1 := GetProcOrNil&<procedure(size: Int32; &type: glVertexPointerType; stride: Int32; count: Int32; pointer: IntPtr)>(VertexPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointerEXT(size: Int32; &type: glVertexPointerType; stride: Int32; count: Int32; pointer: IntPtr) :=
      ntv_VertexPointerEXT_1(size, &type, stride, count, pointer);
    
  end;
  
  ///
  glVertexArrayBgraEXT = static class
    public const _ExtStr = 'GL_EXT_vertex_array_bgra';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexAttrib64bitEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_vertex_attrib_64bit';
    
    private VertexAttribL1dEXT_adr := GetProcAddress('glVertexAttribL1dEXT');
    private ntv_VertexAttribL1dEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: double)>(VertexAttribL1dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dEXT(index: UInt32; x: double) :=
      ntv_VertexAttribL1dEXT_1(index, x);
    
    private VertexAttribL2dEXT_adr := GetProcAddress('glVertexAttribL2dEXT');
    private ntv_VertexAttribL2dEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double)>(VertexAttribL2dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dEXT(index: UInt32; x: double; y: double) :=
      ntv_VertexAttribL2dEXT_1(index, x, y);
    
    private VertexAttribL3dEXT_adr := GetProcAddress('glVertexAttribL3dEXT');
    private ntv_VertexAttribL3dEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double; z: double)>(VertexAttribL3dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dEXT(index: UInt32; x: double; y: double; z: double) :=
      ntv_VertexAttribL3dEXT_1(index, x, y, z);
    
    private VertexAttribL4dEXT_adr := GetProcAddress('glVertexAttribL4dEXT');
    private ntv_VertexAttribL4dEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double; z: double; w: double)>(VertexAttribL4dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dEXT(index: UInt32; x: double; y: double; z: double; w: double) :=
      ntv_VertexAttribL4dEXT_1(index, x, y, z, w);
    
    private VertexAttribL1dvEXT_adr := GetProcAddress('glVertexAttribL1dvEXT');
    private ntv_VertexAttribL1dvEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttribL1dvEXT_adr);
    private ntv_VertexAttribL1dvEXT_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL1dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dvEXT(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL1dvEXT_1(index, v[0]) else
        ntv_VertexAttribL1dvEXT_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dvEXT(index: UInt32; var v: double) :=
      ntv_VertexAttribL1dvEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dvEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL1dvEXT_2(index, v);
    
    private VertexAttribL2dvEXT_adr := GetProcAddress('glVertexAttribL2dvEXT');
    private ntv_VertexAttribL2dvEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttribL2dvEXT_adr);
    private ntv_VertexAttribL2dvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2d)>(VertexAttribL2dvEXT_adr);
    private ntv_VertexAttribL2dvEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL2dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dvEXT(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL2dvEXT_1(index, v[0]) else
        ntv_VertexAttribL2dvEXT_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dvEXT(index: UInt32; var v: Vec2d) :=
      ntv_VertexAttribL2dvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dvEXT(index: UInt32; var v: double) :=
      ntv_VertexAttribL2dvEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dvEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL2dvEXT_3(index, v);
    
    private VertexAttribL3dvEXT_adr := GetProcAddress('glVertexAttribL3dvEXT');
    private ntv_VertexAttribL3dvEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttribL3dvEXT_adr);
    private ntv_VertexAttribL3dvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3d)>(VertexAttribL3dvEXT_adr);
    private ntv_VertexAttribL3dvEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL3dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dvEXT(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL3dvEXT_1(index, v[0]) else
        ntv_VertexAttribL3dvEXT_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dvEXT(index: UInt32; var v: Vec3d) :=
      ntv_VertexAttribL3dvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dvEXT(index: UInt32; var v: double) :=
      ntv_VertexAttribL3dvEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dvEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL3dvEXT_3(index, v);
    
    private VertexAttribL4dvEXT_adr := GetProcAddress('glVertexAttribL4dvEXT');
    private ntv_VertexAttribL4dvEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttribL4dvEXT_adr);
    private ntv_VertexAttribL4dvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4d)>(VertexAttribL4dvEXT_adr);
    private ntv_VertexAttribL4dvEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL4dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dvEXT(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL4dvEXT_1(index, v[0]) else
        ntv_VertexAttribL4dvEXT_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dvEXT(index: UInt32; var v: Vec4d) :=
      ntv_VertexAttribL4dvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dvEXT(index: UInt32; var v: double) :=
      ntv_VertexAttribL4dvEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dvEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL4dvEXT_3(index, v);
    
    private VertexAttribLPointerEXT_adr := GetProcAddress('glVertexAttribLPointerEXT');
    private ntv_VertexAttribLPointerEXT_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: glVertexAttribLType; stride: Int32; pointer: IntPtr)>(VertexAttribLPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLPointerEXT(index: UInt32; size: Int32; &type: glVertexAttribLType; stride: Int32; pointer: IntPtr) :=
      ntv_VertexAttribLPointerEXT_1(index, size, &type, stride, pointer);
    
    private GetVertexAttribLdvEXT_adr := GetProcAddress('glGetVertexAttribLdvEXT');
    private ntv_GetVertexAttribLdvEXT_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; var &params: double)>(GetVertexAttribLdvEXT_adr);
    private ntv_GetVertexAttribLdvEXT_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr)>(GetVertexAttribLdvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdvEXT(index: UInt32; pname: glVertexAttribEnum; var &params: double) :=
      ntv_GetVertexAttribLdvEXT_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdvEXT(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr) :=
      ntv_GetVertexAttribLdvEXT_2(index, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexShaderEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_vertex_shader';
    
    private BeginVertexShaderEXT_adr := GetProcAddress('glBeginVertexShaderEXT');
    private ntv_BeginVertexShaderEXT_1 := GetProcOrNil&<procedure>(BeginVertexShaderEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginVertexShaderEXT :=
      ntv_BeginVertexShaderEXT_1;
    
    private EndVertexShaderEXT_adr := GetProcAddress('glEndVertexShaderEXT');
    private ntv_EndVertexShaderEXT_1 := GetProcOrNil&<procedure>(EndVertexShaderEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndVertexShaderEXT :=
      ntv_EndVertexShaderEXT_1;
    
    private BindVertexShaderEXT_adr := GetProcAddress('glBindVertexShaderEXT');
    private ntv_BindVertexShaderEXT_1 := GetProcOrNil&<procedure(id: UInt32)>(BindVertexShaderEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexShaderEXT(id: UInt32) :=
      ntv_BindVertexShaderEXT_1(id);
    
    private GenVertexShadersEXT_adr := GetProcAddress('glGenVertexShadersEXT');
    private ntv_GenVertexShadersEXT_1 := GetProcOrNil&<function(range: UInt32): UInt32>(GenVertexShadersEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenVertexShadersEXT(range: UInt32): UInt32 :=
      ntv_GenVertexShadersEXT_1(range);
    
    private DeleteVertexShaderEXT_adr := GetProcAddress('glDeleteVertexShaderEXT');
    private ntv_DeleteVertexShaderEXT_1 := GetProcOrNil&<procedure(id: UInt32)>(DeleteVertexShaderEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexShaderEXT(id: UInt32) :=
      ntv_DeleteVertexShaderEXT_1(id);
    
    private ShaderOp1EXT_adr := GetProcAddress('glShaderOp1EXT');
    private ntv_ShaderOp1EXT_1 := GetProcOrNil&<procedure(op: glVertexShaderOp; res: UInt32; arg1: UInt32)>(ShaderOp1EXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderOp1EXT(op: glVertexShaderOp; res: UInt32; arg1: UInt32) :=
      ntv_ShaderOp1EXT_1(op, res, arg1);
    
    private ShaderOp2EXT_adr := GetProcAddress('glShaderOp2EXT');
    private ntv_ShaderOp2EXT_1 := GetProcOrNil&<procedure(op: glVertexShaderOp; res: UInt32; arg1: UInt32; arg2: UInt32)>(ShaderOp2EXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderOp2EXT(op: glVertexShaderOp; res: UInt32; arg1: UInt32; arg2: UInt32) :=
      ntv_ShaderOp2EXT_1(op, res, arg1, arg2);
    
    private ShaderOp3EXT_adr := GetProcAddress('glShaderOp3EXT');
    private ntv_ShaderOp3EXT_1 := GetProcOrNil&<procedure(op: glVertexShaderOp; res: UInt32; arg1: UInt32; arg2: UInt32; arg3: UInt32)>(ShaderOp3EXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderOp3EXT(op: glVertexShaderOp; res: UInt32; arg1: UInt32; arg2: UInt32; arg3: UInt32) :=
      ntv_ShaderOp3EXT_1(op, res, arg1, arg2, arg3);
    
    private SwizzleEXT_adr := GetProcAddress('glSwizzleEXT');
    private ntv_SwizzleEXT_1 := GetProcOrNil&<procedure(res: UInt32; &in: UInt32; outX: glVertexShaderCoordOut; outY: glVertexShaderCoordOut; outZ: glVertexShaderCoordOut; outW: glVertexShaderCoordOut)>(SwizzleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SwizzleEXT(res: UInt32; &in: UInt32; outX: glVertexShaderCoordOut; outY: glVertexShaderCoordOut; outZ: glVertexShaderCoordOut; outW: glVertexShaderCoordOut) :=
      ntv_SwizzleEXT_1(res, &in, outX, outY, outZ, outW);
    
    private WriteMaskEXT_adr := GetProcAddress('glWriteMaskEXT');
    private ntv_WriteMaskEXT_1 := GetProcOrNil&<procedure(res: UInt32; &in: UInt32; outX: glVertexShaderWriteMask; outY: glVertexShaderWriteMask; outZ: glVertexShaderWriteMask; outW: glVertexShaderWriteMask)>(WriteMaskEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WriteMaskEXT(res: UInt32; &in: UInt32; outX: glVertexShaderWriteMask; outY: glVertexShaderWriteMask; outZ: glVertexShaderWriteMask; outW: glVertexShaderWriteMask) :=
      ntv_WriteMaskEXT_1(res, &in, outX, outY, outZ, outW);
    
    private InsertComponentEXT_adr := GetProcAddress('glInsertComponentEXT');
    private ntv_InsertComponentEXT_1 := GetProcOrNil&<procedure(res: UInt32; src: UInt32; num: UInt32)>(InsertComponentEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InsertComponentEXT(res: UInt32; src: UInt32; num: UInt32) :=
      ntv_InsertComponentEXT_1(res, src, num);
    
    private ExtractComponentEXT_adr := GetProcAddress('glExtractComponentEXT');
    private ntv_ExtractComponentEXT_1 := GetProcOrNil&<procedure(res: UInt32; src: UInt32; num: UInt32)>(ExtractComponentEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtractComponentEXT(res: UInt32; src: UInt32; num: UInt32) :=
      ntv_ExtractComponentEXT_1(res, src, num);
    
    private GenSymbolsEXT_adr := GetProcAddress('glGenSymbolsEXT');
    private ntv_GenSymbolsEXT_1 := GetProcOrNil&<function(datatype: glDataType; storagetype: glVertexShaderStorageType; range: glParameterRange; components: UInt32): UInt32>(GenSymbolsEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenSymbolsEXT(datatype: glDataType; storagetype: glVertexShaderStorageType; range: glParameterRange; components: UInt32): UInt32 :=
      ntv_GenSymbolsEXT_1(datatype, storagetype, range, components);
    
    private SetInvariantEXT_adr := GetProcAddress('glSetInvariantEXT');
    private ntv_SetInvariantEXT_1 := GetProcOrNil&<procedure(id: UInt32; &type: glScalarType; addr: IntPtr)>(SetInvariantEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetInvariantEXT(id: UInt32; &type: glScalarType; addr: IntPtr) :=
      ntv_SetInvariantEXT_1(id, &type, addr);
    
    private SetLocalConstantEXT_adr := GetProcAddress('glSetLocalConstantEXT');
    private ntv_SetLocalConstantEXT_1 := GetProcOrNil&<procedure(id: UInt32; &type: glScalarType; addr: IntPtr)>(SetLocalConstantEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetLocalConstantEXT(id: UInt32; &type: glScalarType; addr: IntPtr) :=
      ntv_SetLocalConstantEXT_1(id, &type, addr);
    
    private VariantbvEXT_adr := GetProcAddress('glVariantbvEXT');
    private ntv_VariantbvEXT_1 := GetProcOrNil&<procedure(id: UInt32; var addr: SByte)>(VariantbvEXT_adr);
    private ntv_VariantbvEXT_2 := GetProcOrNil&<procedure(id: UInt32; addr: IntPtr)>(VariantbvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantbvEXT(id: UInt32; addr: array of SByte);
    type PSByte = ^SByte;
    begin
      if (addr<>nil) and (addr.Length<>0) then
        ntv_VariantbvEXT_1(id, addr[0]) else
        ntv_VariantbvEXT_1(id, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantbvEXT(id: UInt32; var addr: SByte) :=
      ntv_VariantbvEXT_1(id, addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantbvEXT(id: UInt32; addr: IntPtr) :=
      ntv_VariantbvEXT_2(id, addr);
    
    private VariantsvEXT_adr := GetProcAddress('glVariantsvEXT');
    private ntv_VariantsvEXT_1 := GetProcOrNil&<procedure(id: UInt32; var addr: Int16)>(VariantsvEXT_adr);
    private ntv_VariantsvEXT_2 := GetProcOrNil&<procedure(id: UInt32; addr: IntPtr)>(VariantsvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantsvEXT(id: UInt32; addr: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (addr<>nil) and (addr.Length<>0) then
        ntv_VariantsvEXT_1(id, addr[0]) else
        ntv_VariantsvEXT_1(id, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantsvEXT(id: UInt32; var addr: Int16) :=
      ntv_VariantsvEXT_1(id, addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantsvEXT(id: UInt32; addr: IntPtr) :=
      ntv_VariantsvEXT_2(id, addr);
    
    private VariantivEXT_adr := GetProcAddress('glVariantivEXT');
    private ntv_VariantivEXT_1 := GetProcOrNil&<procedure(id: UInt32; var addr: Int32)>(VariantivEXT_adr);
    private ntv_VariantivEXT_2 := GetProcOrNil&<procedure(id: UInt32; addr: IntPtr)>(VariantivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantivEXT(id: UInt32; addr: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (addr<>nil) and (addr.Length<>0) then
        ntv_VariantivEXT_1(id, addr[0]) else
        ntv_VariantivEXT_1(id, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantivEXT(id: UInt32; var addr: Int32) :=
      ntv_VariantivEXT_1(id, addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantivEXT(id: UInt32; addr: IntPtr) :=
      ntv_VariantivEXT_2(id, addr);
    
    private VariantfvEXT_adr := GetProcAddress('glVariantfvEXT');
    private ntv_VariantfvEXT_1 := GetProcOrNil&<procedure(id: UInt32; var addr: single)>(VariantfvEXT_adr);
    private ntv_VariantfvEXT_2 := GetProcOrNil&<procedure(id: UInt32; addr: IntPtr)>(VariantfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantfvEXT(id: UInt32; addr: array of single);
    type PSingle = ^single;
    begin
      if (addr<>nil) and (addr.Length<>0) then
        ntv_VariantfvEXT_1(id, addr[0]) else
        ntv_VariantfvEXT_1(id, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantfvEXT(id: UInt32; var addr: single) :=
      ntv_VariantfvEXT_1(id, addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantfvEXT(id: UInt32; addr: IntPtr) :=
      ntv_VariantfvEXT_2(id, addr);
    
    private VariantdvEXT_adr := GetProcAddress('glVariantdvEXT');
    private ntv_VariantdvEXT_1 := GetProcOrNil&<procedure(id: UInt32; var addr: double)>(VariantdvEXT_adr);
    private ntv_VariantdvEXT_2 := GetProcOrNil&<procedure(id: UInt32; addr: IntPtr)>(VariantdvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantdvEXT(id: UInt32; addr: array of double);
    type PDouble = ^double;
    begin
      if (addr<>nil) and (addr.Length<>0) then
        ntv_VariantdvEXT_1(id, addr[0]) else
        ntv_VariantdvEXT_1(id, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantdvEXT(id: UInt32; var addr: double) :=
      ntv_VariantdvEXT_1(id, addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantdvEXT(id: UInt32; addr: IntPtr) :=
      ntv_VariantdvEXT_2(id, addr);
    
    private VariantubvEXT_adr := GetProcAddress('glVariantubvEXT');
    private ntv_VariantubvEXT_1 := GetProcOrNil&<procedure(id: UInt32; var addr: Byte)>(VariantubvEXT_adr);
    private ntv_VariantubvEXT_2 := GetProcOrNil&<procedure(id: UInt32; addr: IntPtr)>(VariantubvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantubvEXT(id: UInt32; addr: array of Byte);
    type PByte = ^Byte;
    begin
      if (addr<>nil) and (addr.Length<>0) then
        ntv_VariantubvEXT_1(id, addr[0]) else
        ntv_VariantubvEXT_1(id, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantubvEXT(id: UInt32; var addr: Byte) :=
      ntv_VariantubvEXT_1(id, addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantubvEXT(id: UInt32; addr: IntPtr) :=
      ntv_VariantubvEXT_2(id, addr);
    
    private VariantusvEXT_adr := GetProcAddress('glVariantusvEXT');
    private ntv_VariantusvEXT_1 := GetProcOrNil&<procedure(id: UInt32; var addr: UInt16)>(VariantusvEXT_adr);
    private ntv_VariantusvEXT_2 := GetProcOrNil&<procedure(id: UInt32; addr: IntPtr)>(VariantusvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantusvEXT(id: UInt32; addr: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (addr<>nil) and (addr.Length<>0) then
        ntv_VariantusvEXT_1(id, addr[0]) else
        ntv_VariantusvEXT_1(id, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantusvEXT(id: UInt32; var addr: UInt16) :=
      ntv_VariantusvEXT_1(id, addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantusvEXT(id: UInt32; addr: IntPtr) :=
      ntv_VariantusvEXT_2(id, addr);
    
    private VariantuivEXT_adr := GetProcAddress('glVariantuivEXT');
    private ntv_VariantuivEXT_1 := GetProcOrNil&<procedure(id: UInt32; var addr: UInt32)>(VariantuivEXT_adr);
    private ntv_VariantuivEXT_2 := GetProcOrNil&<procedure(id: UInt32; addr: IntPtr)>(VariantuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantuivEXT(id: UInt32; addr: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (addr<>nil) and (addr.Length<>0) then
        ntv_VariantuivEXT_1(id, addr[0]) else
        ntv_VariantuivEXT_1(id, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantuivEXT(id: UInt32; var addr: UInt32) :=
      ntv_VariantuivEXT_1(id, addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantuivEXT(id: UInt32; addr: IntPtr) :=
      ntv_VariantuivEXT_2(id, addr);
    
    private VariantPointerEXT_adr := GetProcAddress('glVariantPointerEXT');
    private ntv_VariantPointerEXT_1 := GetProcOrNil&<procedure(id: UInt32; &type: glScalarType; stride: UInt32; addr: IntPtr)>(VariantPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantPointerEXT(id: UInt32; &type: glScalarType; stride: UInt32; addr: IntPtr) :=
      ntv_VariantPointerEXT_1(id, &type, stride, addr);
    
    private EnableVariantClientStateEXT_adr := GetProcAddress('glEnableVariantClientStateEXT');
    private ntv_EnableVariantClientStateEXT_1 := GetProcOrNil&<procedure(id: UInt32)>(EnableVariantClientStateEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVariantClientStateEXT(id: UInt32) :=
      ntv_EnableVariantClientStateEXT_1(id);
    
    private DisableVariantClientStateEXT_adr := GetProcAddress('glDisableVariantClientStateEXT');
    private ntv_DisableVariantClientStateEXT_1 := GetProcOrNil&<procedure(id: UInt32)>(DisableVariantClientStateEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVariantClientStateEXT(id: UInt32) :=
      ntv_DisableVariantClientStateEXT_1(id);
    
    private BindLightParameterEXT_adr := GetProcAddress('glBindLightParameterEXT');
    private ntv_BindLightParameterEXT_1 := GetProcOrNil&<function(light: glLightName; value: glLightParameter): UInt32>(BindLightParameterEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindLightParameterEXT(light: glLightName; value: glLightParameter): UInt32 :=
      ntv_BindLightParameterEXT_1(light, value);
    
    private BindMaterialParameterEXT_adr := GetProcAddress('glBindMaterialParameterEXT');
    private ntv_BindMaterialParameterEXT_1 := GetProcOrNil&<function(face: glTriangleFace; value: glMaterialParameter): UInt32>(BindMaterialParameterEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindMaterialParameterEXT(face: glTriangleFace; value: glMaterialParameter): UInt32 :=
      ntv_BindMaterialParameterEXT_1(face, value);
    
    private BindTexGenParameterEXT_adr := GetProcAddress('glBindTexGenParameterEXT');
    private ntv_BindTexGenParameterEXT_1 := GetProcOrNil&<function(&unit: glTextureUnit; coord: glTextureCoordName; value: glTextureGenParameter): UInt32>(BindTexGenParameterEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindTexGenParameterEXT(&unit: glTextureUnit; coord: glTextureCoordName; value: glTextureGenParameter): UInt32 :=
      ntv_BindTexGenParameterEXT_1(&unit, coord, value);
    
    private BindTextureUnitParameterEXT_adr := GetProcAddress('glBindTextureUnitParameterEXT');
    private ntv_BindTextureUnitParameterEXT_1 := GetProcOrNil&<function(&unit: glTextureUnit; value: glVertexShaderTextureUnitParameter): UInt32>(BindTextureUnitParameterEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindTextureUnitParameterEXT(&unit: glTextureUnit; value: glVertexShaderTextureUnitParameter): UInt32 :=
      ntv_BindTextureUnitParameterEXT_1(&unit, value);
    
    private BindParameterEXT_adr := GetProcAddress('glBindParameterEXT');
    private ntv_BindParameterEXT_1 := GetProcOrNil&<function(value: glVertexShaderParameter): UInt32>(BindParameterEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindParameterEXT(value: glVertexShaderParameter): UInt32 :=
      ntv_BindParameterEXT_1(value);
    
    private IsVariantEnabledEXT_adr := GetProcAddress('glIsVariantEnabledEXT');
    private ntv_IsVariantEnabledEXT_1 := GetProcOrNil&<function(id: UInt32; cap: glVariantCap): glBool8>(IsVariantEnabledEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsVariantEnabledEXT(id: UInt32; cap: glVariantCap): glBool8 :=
      ntv_IsVariantEnabledEXT_1(id, cap);
    
    private GetVariantBooleanvEXT_adr := GetProcAddress('glGetVariantBooleanvEXT');
    private ntv_GetVariantBooleanvEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; var data: glBool8)>(GetVariantBooleanvEXT_adr);
    private ntv_GetVariantBooleanvEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; data: IntPtr)>(GetVariantBooleanvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantBooleanvEXT(id: UInt32; value: glGetVariantValue; var data: glBool8) :=
      ntv_GetVariantBooleanvEXT_1(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantBooleanvEXT(id: UInt32; value: glGetVariantValue; data: IntPtr) :=
      ntv_GetVariantBooleanvEXT_2(id, value, data);
    
    private GetVariantIntegervEXT_adr := GetProcAddress('glGetVariantIntegervEXT');
    private ntv_GetVariantIntegervEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; var data: Int32)>(GetVariantIntegervEXT_adr);
    private ntv_GetVariantIntegervEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; data: IntPtr)>(GetVariantIntegervEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantIntegervEXT(id: UInt32; value: glGetVariantValue; var data: Int32) :=
      ntv_GetVariantIntegervEXT_1(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantIntegervEXT(id: UInt32; value: glGetVariantValue; data: IntPtr) :=
      ntv_GetVariantIntegervEXT_2(id, value, data);
    
    private GetVariantFloatvEXT_adr := GetProcAddress('glGetVariantFloatvEXT');
    private ntv_GetVariantFloatvEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; var data: single)>(GetVariantFloatvEXT_adr);
    private ntv_GetVariantFloatvEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; data: IntPtr)>(GetVariantFloatvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantFloatvEXT(id: UInt32; value: glGetVariantValue; var data: single) :=
      ntv_GetVariantFloatvEXT_1(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantFloatvEXT(id: UInt32; value: glGetVariantValue; data: IntPtr) :=
      ntv_GetVariantFloatvEXT_2(id, value, data);
    
    private GetVariantPointervEXT_adr := GetProcAddress('glGetVariantPointervEXT');
    private ntv_GetVariantPointervEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; var data: IntPtr)>(GetVariantPointervEXT_adr);
    private ntv_GetVariantPointervEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; data: pointer)>(GetVariantPointervEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantPointervEXT(id: UInt32; value: glGetVariantValue; var data: IntPtr) :=
      ntv_GetVariantPointervEXT_1(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantPointervEXT(id: UInt32; value: glGetVariantValue; data: pointer) :=
      ntv_GetVariantPointervEXT_2(id, value, data);
    
    private GetInvariantBooleanvEXT_adr := GetProcAddress('glGetInvariantBooleanvEXT');
    private ntv_GetInvariantBooleanvEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; var data: glBool8)>(GetInvariantBooleanvEXT_adr);
    private ntv_GetInvariantBooleanvEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; data: IntPtr)>(GetInvariantBooleanvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantBooleanvEXT(id: UInt32; value: glGetVariantValue; var data: glBool8) :=
      ntv_GetInvariantBooleanvEXT_1(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantBooleanvEXT(id: UInt32; value: glGetVariantValue; data: IntPtr) :=
      ntv_GetInvariantBooleanvEXT_2(id, value, data);
    
    private GetInvariantIntegervEXT_adr := GetProcAddress('glGetInvariantIntegervEXT');
    private ntv_GetInvariantIntegervEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; var data: Int32)>(GetInvariantIntegervEXT_adr);
    private ntv_GetInvariantIntegervEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; data: IntPtr)>(GetInvariantIntegervEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantIntegervEXT(id: UInt32; value: glGetVariantValue; var data: Int32) :=
      ntv_GetInvariantIntegervEXT_1(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantIntegervEXT(id: UInt32; value: glGetVariantValue; data: IntPtr) :=
      ntv_GetInvariantIntegervEXT_2(id, value, data);
    
    private GetInvariantFloatvEXT_adr := GetProcAddress('glGetInvariantFloatvEXT');
    private ntv_GetInvariantFloatvEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; var data: single)>(GetInvariantFloatvEXT_adr);
    private ntv_GetInvariantFloatvEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; data: IntPtr)>(GetInvariantFloatvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantFloatvEXT(id: UInt32; value: glGetVariantValue; var data: single) :=
      ntv_GetInvariantFloatvEXT_1(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantFloatvEXT(id: UInt32; value: glGetVariantValue; data: IntPtr) :=
      ntv_GetInvariantFloatvEXT_2(id, value, data);
    
    private GetLocalConstantBooleanvEXT_adr := GetProcAddress('glGetLocalConstantBooleanvEXT');
    private ntv_GetLocalConstantBooleanvEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; var data: glBool8)>(GetLocalConstantBooleanvEXT_adr);
    private ntv_GetLocalConstantBooleanvEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; data: IntPtr)>(GetLocalConstantBooleanvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantBooleanvEXT(id: UInt32; value: glGetVariantValue; var data: glBool8) :=
      ntv_GetLocalConstantBooleanvEXT_1(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantBooleanvEXT(id: UInt32; value: glGetVariantValue; data: IntPtr) :=
      ntv_GetLocalConstantBooleanvEXT_2(id, value, data);
    
    private GetLocalConstantIntegervEXT_adr := GetProcAddress('glGetLocalConstantIntegervEXT');
    private ntv_GetLocalConstantIntegervEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; var data: Int32)>(GetLocalConstantIntegervEXT_adr);
    private ntv_GetLocalConstantIntegervEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; data: IntPtr)>(GetLocalConstantIntegervEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantIntegervEXT(id: UInt32; value: glGetVariantValue; var data: Int32) :=
      ntv_GetLocalConstantIntegervEXT_1(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantIntegervEXT(id: UInt32; value: glGetVariantValue; data: IntPtr) :=
      ntv_GetLocalConstantIntegervEXT_2(id, value, data);
    
    private GetLocalConstantFloatvEXT_adr := GetProcAddress('glGetLocalConstantFloatvEXT');
    private ntv_GetLocalConstantFloatvEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; var data: single)>(GetLocalConstantFloatvEXT_adr);
    private ntv_GetLocalConstantFloatvEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: glGetVariantValue; data: IntPtr)>(GetLocalConstantFloatvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantFloatvEXT(id: UInt32; value: glGetVariantValue; var data: single) :=
      ntv_GetLocalConstantFloatvEXT_1(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantFloatvEXT(id: UInt32; value: glGetVariantValue; data: IntPtr) :=
      ntv_GetLocalConstantFloatvEXT_2(id, value, data);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexWeightingEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_vertex_weighting';
    
    private VertexWeightfEXT_adr := GetProcAddress('glVertexWeightfEXT');
    private ntv_VertexWeightfEXT_1 := GetProcOrNil&<procedure(weight: single)>(VertexWeightfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightfEXT(weight: single) :=
      ntv_VertexWeightfEXT_1(weight);
    
    private VertexWeightfvEXT_adr := GetProcAddress('glVertexWeightfvEXT');
    private ntv_VertexWeightfvEXT_1 := GetProcOrNil&<procedure(var weight: single)>(VertexWeightfvEXT_adr);
    private ntv_VertexWeightfvEXT_2 := GetProcOrNil&<procedure(weight: IntPtr)>(VertexWeightfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightfvEXT(weight: array of single);
    type PSingle = ^single;
    begin
      if (weight<>nil) and (weight.Length<>0) then
        ntv_VertexWeightfvEXT_1(weight[0]) else
        ntv_VertexWeightfvEXT_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightfvEXT(var weight: single) :=
      ntv_VertexWeightfvEXT_1(weight);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightfvEXT(weight: IntPtr) :=
      ntv_VertexWeightfvEXT_2(weight);
    
    private VertexWeightPointerEXT_adr := GetProcAddress('glVertexWeightPointerEXT');
    private ntv_VertexWeightPointerEXT_1 := GetProcOrNil&<procedure(size: Int32; &type: glVertexWeightPointerType; stride: Int32; pointer: IntPtr)>(VertexWeightPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightPointerEXT(size: Int32; &type: glVertexWeightPointerType; stride: Int32; pointer: IntPtr) :=
      ntv_VertexWeightPointerEXT_1(size, &type, stride, pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glWin32KeyedMutexEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_win32_keyed_mutex';
    
    private AcquireKeyedMutexWin32EXT_adr := GetProcAddress('glAcquireKeyedMutexWin32EXT');
    private ntv_AcquireKeyedMutexWin32EXT_1 := GetProcOrNil&<function(memory: UInt32; key: UInt64; timeout: UInt32): glBool8>(AcquireKeyedMutexWin32EXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AcquireKeyedMutexWin32EXT(memory: UInt32; key: UInt64; timeout: UInt32): glBool8 :=
      ntv_AcquireKeyedMutexWin32EXT_1(memory, key, timeout);
    
    private ReleaseKeyedMutexWin32EXT_adr := GetProcAddress('glReleaseKeyedMutexWin32EXT');
    private ntv_ReleaseKeyedMutexWin32EXT_1 := GetProcOrNil&<function(memory: UInt32; key: UInt64): glBool8>(ReleaseKeyedMutexWin32EXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseKeyedMutexWin32EXT(memory: UInt32; key: UInt64): glBool8 :=
      ntv_ReleaseKeyedMutexWin32EXT_1(memory, key);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glWindowRectanglesEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_window_rectangles';
    
    private WindowRectanglesEXT_adr := GetProcAddress('glWindowRectanglesEXT');
    private ntv_WindowRectanglesEXT_1 := GetProcOrNil&<procedure(mode: DummyEnum; count: Int32; var box: Int32)>(WindowRectanglesEXT_adr);
    private ntv_WindowRectanglesEXT_2 := GetProcOrNil&<procedure(mode: DummyEnum; count: Int32; box: IntPtr)>(WindowRectanglesEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowRectanglesEXT(mode: DummyEnum; count: Int32; box: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (box<>nil) and (box.Length<>0) then
        ntv_WindowRectanglesEXT_1(mode, count, box[0]) else
        ntv_WindowRectanglesEXT_1(mode, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowRectanglesEXT(mode: DummyEnum; count: Int32; var box: Int32) :=
      ntv_WindowRectanglesEXT_1(mode, count, box);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowRectanglesEXT(mode: DummyEnum; count: Int32; box: IntPtr) :=
      ntv_WindowRectanglesEXT_2(mode, count, box);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glX11SyncObjectEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_EXT_x11_sync_object';
    
    private ImportSyncEXT_adr := GetProcAddress('glImportSyncEXT');
    private ntv_ImportSyncEXT_1 := GetProcOrNil&<function(external_sync_type: DummyEnum; external_sync: IntPtr; flags: DummyFlags): gl_sync>(ImportSyncEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ImportSyncEXT(external_sync_type: DummyEnum; external_sync: IntPtr; flags: DummyFlags): gl_sync :=
      ntv_ImportSyncEXT_1(external_sync_type, external_sync, flags);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFrameTerminatorGREMEDY = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_GREMEDY_frame_terminator';
    
    private FrameTerminatorGREMEDY_adr := GetProcAddress('glFrameTerminatorGREMEDY');
    private ntv_FrameTerminatorGREMEDY_1 := GetProcOrNil&<procedure>(FrameTerminatorGREMEDY_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrameTerminatorGREMEDY :=
      ntv_FrameTerminatorGREMEDY_1;
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glStringMarkerGREMEDY = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_GREMEDY_string_marker';
    
    private StringMarkerGREMEDY_adr := GetProcAddress('glStringMarkerGREMEDY');
    private ntv_StringMarkerGREMEDY_1 := GetProcOrNil&<procedure(len: Int32; string: IntPtr)>(StringMarkerGREMEDY_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StringMarkerGREMEDY(len: Int32; string: IntPtr) :=
      ntv_StringMarkerGREMEDY_1(len, string);
    
  end;
  
  ///
  glConvolutionBorderModesHP = static class
    public const _ExtStr = 'GL_HP_convolution_border_modes';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glImageTransformHP = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_HP_image_transform';
    
    private ImageTransformParameteriHP_adr := GetProcAddress('glImageTransformParameteriHP');
    private ntv_ImageTransformParameteriHP_1 := GetProcOrNil&<procedure(target: glImageTransformTarget; pname: glImageTransformPName; param: Int32)>(ImageTransformParameteriHP_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameteriHP(target: glImageTransformTarget; pname: glImageTransformPName; param: Int32) :=
      ntv_ImageTransformParameteriHP_1(target, pname, param);
    
    private ImageTransformParameterfHP_adr := GetProcAddress('glImageTransformParameterfHP');
    private ntv_ImageTransformParameterfHP_1 := GetProcOrNil&<procedure(target: glImageTransformTarget; pname: glImageTransformPName; param: single)>(ImageTransformParameterfHP_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterfHP(target: glImageTransformTarget; pname: glImageTransformPName; param: single) :=
      ntv_ImageTransformParameterfHP_1(target, pname, param);
    
    private ImageTransformParameterivHP_adr := GetProcAddress('glImageTransformParameterivHP');
    private ntv_ImageTransformParameterivHP_1 := GetProcOrNil&<procedure(target: glImageTransformTarget; pname: glImageTransformPName; var &params: Int32)>(ImageTransformParameterivHP_adr);
    private ntv_ImageTransformParameterivHP_2 := GetProcOrNil&<procedure(target: glImageTransformTarget; pname: glImageTransformPName; &params: IntPtr)>(ImageTransformParameterivHP_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterivHP(target: glImageTransformTarget; pname: glImageTransformPName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ImageTransformParameterivHP_1(target, pname, &params[0]) else
        ntv_ImageTransformParameterivHP_1(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterivHP(target: glImageTransformTarget; pname: glImageTransformPName; var &params: Int32) :=
      ntv_ImageTransformParameterivHP_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterivHP(target: glImageTransformTarget; pname: glImageTransformPName; &params: IntPtr) :=
      ntv_ImageTransformParameterivHP_2(target, pname, &params);
    
    private ImageTransformParameterfvHP_adr := GetProcAddress('glImageTransformParameterfvHP');
    private ntv_ImageTransformParameterfvHP_1 := GetProcOrNil&<procedure(target: glImageTransformTarget; pname: glImageTransformPName; var &params: single)>(ImageTransformParameterfvHP_adr);
    private ntv_ImageTransformParameterfvHP_2 := GetProcOrNil&<procedure(target: glImageTransformTarget; pname: glImageTransformPName; &params: IntPtr)>(ImageTransformParameterfvHP_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterfvHP(target: glImageTransformTarget; pname: glImageTransformPName; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ImageTransformParameterfvHP_1(target, pname, &params[0]) else
        ntv_ImageTransformParameterfvHP_1(target, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterfvHP(target: glImageTransformTarget; pname: glImageTransformPName; var &params: single) :=
      ntv_ImageTransformParameterfvHP_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterfvHP(target: glImageTransformTarget; pname: glImageTransformPName; &params: IntPtr) :=
      ntv_ImageTransformParameterfvHP_2(target, pname, &params);
    
    private GetImageTransformParameterivHP_adr := GetProcAddress('glGetImageTransformParameterivHP');
    private ntv_GetImageTransformParameterivHP_1 := GetProcOrNil&<procedure(target: glImageTransformTarget; pname: glImageTransformPName; var &params: Int32)>(GetImageTransformParameterivHP_adr);
    private ntv_GetImageTransformParameterivHP_2 := GetProcOrNil&<procedure(target: glImageTransformTarget; pname: glImageTransformPName; &params: IntPtr)>(GetImageTransformParameterivHP_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterivHP(target: glImageTransformTarget; pname: glImageTransformPName; var &params: Int32) :=
      ntv_GetImageTransformParameterivHP_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterivHP(target: glImageTransformTarget; pname: glImageTransformPName; &params: IntPtr) :=
      ntv_GetImageTransformParameterivHP_2(target, pname, &params);
    
    private GetImageTransformParameterfvHP_adr := GetProcAddress('glGetImageTransformParameterfvHP');
    private ntv_GetImageTransformParameterfvHP_1 := GetProcOrNil&<procedure(target: glImageTransformTarget; pname: glImageTransformPName; var &params: single)>(GetImageTransformParameterfvHP_adr);
    private ntv_GetImageTransformParameterfvHP_2 := GetProcOrNil&<procedure(target: glImageTransformTarget; pname: glImageTransformPName; &params: IntPtr)>(GetImageTransformParameterfvHP_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterfvHP(target: glImageTransformTarget; pname: glImageTransformPName; var &params: single) :=
      ntv_GetImageTransformParameterfvHP_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterfvHP(target: glImageTransformTarget; pname: glImageTransformPName; &params: IntPtr) :=
      ntv_GetImageTransformParameterfvHP_2(target, pname, &params);
    
  end;
  
  ///
  glOcclusionTestHP = static class
    public const _ExtStr = 'GL_HP_occlusion_test';
  end;
  
  ///
  glTextureLightingHP = static class
    public const _ExtStr = 'GL_HP_texture_lighting';
  end;
  
  ///
  glCullVertexIBM = static class
    public const _ExtStr = 'GL_IBM_cull_vertex';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMultimodeDrawArraysIBM = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_IBM_multimode_draw_arrays';
    
    private MultiModeDrawArraysIBM_adr := GetProcAddress('glMultiModeDrawArraysIBM');
    private ntv_MultiModeDrawArraysIBM_1 := GetProcOrNil&<procedure(var mode: glPrimitiveType; var first: Int32; var count: Int32; primcount: Int32; modestride: Int32)>(MultiModeDrawArraysIBM_adr);
    private ntv_MultiModeDrawArraysIBM_2 := GetProcOrNil&<procedure(var mode: glPrimitiveType; var first: Int32; count: IntPtr; primcount: Int32; modestride: Int32)>(MultiModeDrawArraysIBM_adr);
    private ntv_MultiModeDrawArraysIBM_3 := GetProcOrNil&<procedure(var mode: glPrimitiveType; first: IntPtr; var count: Int32; primcount: Int32; modestride: Int32)>(MultiModeDrawArraysIBM_adr);
    private ntv_MultiModeDrawArraysIBM_4 := GetProcOrNil&<procedure(var mode: glPrimitiveType; first: IntPtr; count: IntPtr; primcount: Int32; modestride: Int32)>(MultiModeDrawArraysIBM_adr);
    private ntv_MultiModeDrawArraysIBM_5 := GetProcOrNil&<procedure(mode: IntPtr; var first: Int32; var count: Int32; primcount: Int32; modestride: Int32)>(MultiModeDrawArraysIBM_adr);
    private ntv_MultiModeDrawArraysIBM_6 := GetProcOrNil&<procedure(mode: IntPtr; var first: Int32; count: IntPtr; primcount: Int32; modestride: Int32)>(MultiModeDrawArraysIBM_adr);
    private ntv_MultiModeDrawArraysIBM_7 := GetProcOrNil&<procedure(mode: IntPtr; first: IntPtr; var count: Int32; primcount: Int32; modestride: Int32)>(MultiModeDrawArraysIBM_adr);
    private ntv_MultiModeDrawArraysIBM_8 := GetProcOrNil&<procedure(mode: IntPtr; first: IntPtr; count: IntPtr; primcount: Int32; modestride: Int32)>(MultiModeDrawArraysIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of glPrimitiveType; first: array of Int32; count: array of Int32; primcount: Int32; modestride: Int32);
    type PGlPrimitiveType = ^glPrimitiveType;
    type PInt32 = ^Int32;
    begin
      if (first<>nil) and (first.Length<>0) then
        if (mode<>nil) and (mode.Length<>0) then
          if (count<>nil) and (count.Length<>0) then
            ntv_MultiModeDrawArraysIBM_1(mode[0], first[0], count[0], primcount, modestride) else
            ntv_MultiModeDrawArraysIBM_1(mode[0], first[0], PInt32(nil)^, primcount, modestride) else
          if (count<>nil) and (count.Length<>0) then
            ntv_MultiModeDrawArraysIBM_1(PGlPrimitiveType(nil)^, first[0], count[0], primcount, modestride) else
            ntv_MultiModeDrawArraysIBM_1(PGlPrimitiveType(nil)^, first[0], PInt32(nil)^, primcount, modestride) else
        if (mode<>nil) and (mode.Length<>0) then
          if (count<>nil) and (count.Length<>0) then
            ntv_MultiModeDrawArraysIBM_1(mode[0], PInt32(nil)^, count[0], primcount, modestride) else
            ntv_MultiModeDrawArraysIBM_1(mode[0], PInt32(nil)^, PInt32(nil)^, primcount, modestride) else
          if (count<>nil) and (count.Length<>0) then
            ntv_MultiModeDrawArraysIBM_1(PGlPrimitiveType(nil)^, PInt32(nil)^, count[0], primcount, modestride) else
            ntv_MultiModeDrawArraysIBM_1(PGlPrimitiveType(nil)^, PInt32(nil)^, PInt32(nil)^, primcount, modestride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: glPrimitiveType; var first: Int32; var count: Int32; primcount: Int32; modestride: Int32) :=
      ntv_MultiModeDrawArraysIBM_1(mode, first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: glPrimitiveType; var first: Int32; count: IntPtr; primcount: Int32; modestride: Int32) :=
      ntv_MultiModeDrawArraysIBM_2(mode, first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: glPrimitiveType; first: IntPtr; var count: Int32; primcount: Int32; modestride: Int32) :=
      ntv_MultiModeDrawArraysIBM_3(mode, first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: glPrimitiveType; first: IntPtr; count: IntPtr; primcount: Int32; modestride: Int32) :=
      ntv_MultiModeDrawArraysIBM_4(mode, first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: IntPtr; var first: Int32; var count: Int32; primcount: Int32; modestride: Int32) :=
      ntv_MultiModeDrawArraysIBM_5(mode, first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: IntPtr; var first: Int32; count: IntPtr; primcount: Int32; modestride: Int32) :=
      ntv_MultiModeDrawArraysIBM_6(mode, first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: IntPtr; first: IntPtr; var count: Int32; primcount: Int32; modestride: Int32) :=
      ntv_MultiModeDrawArraysIBM_7(mode, first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: IntPtr; first: IntPtr; count: IntPtr; primcount: Int32; modestride: Int32) :=
      ntv_MultiModeDrawArraysIBM_8(mode, first, count, primcount, modestride);
    
    private MultiModeDrawElementsIBM_adr := GetProcAddress('glMultiModeDrawElementsIBM');
    private ntv_MultiModeDrawElementsIBM_1 := GetProcOrNil&<procedure(var mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; var indices: IntPtr; primcount: Int32; modestride: Int32)>(MultiModeDrawElementsIBM_adr);
    private ntv_MultiModeDrawElementsIBM_2 := GetProcOrNil&<procedure(var mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; indices: pointer; primcount: Int32; modestride: Int32)>(MultiModeDrawElementsIBM_adr);
    private ntv_MultiModeDrawElementsIBM_3 := GetProcOrNil&<procedure(var mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; var indices: IntPtr; primcount: Int32; modestride: Int32)>(MultiModeDrawElementsIBM_adr);
    private ntv_MultiModeDrawElementsIBM_4 := GetProcOrNil&<procedure(var mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; indices: pointer; primcount: Int32; modestride: Int32)>(MultiModeDrawElementsIBM_adr);
    private ntv_MultiModeDrawElementsIBM_5 := GetProcOrNil&<procedure(mode: IntPtr; var count: Int32; &type: glDrawElementsType; var indices: IntPtr; primcount: Int32; modestride: Int32)>(MultiModeDrawElementsIBM_adr);
    private ntv_MultiModeDrawElementsIBM_6 := GetProcOrNil&<procedure(mode: IntPtr; var count: Int32; &type: glDrawElementsType; indices: pointer; primcount: Int32; modestride: Int32)>(MultiModeDrawElementsIBM_adr);
    private ntv_MultiModeDrawElementsIBM_7 := GetProcOrNil&<procedure(mode: IntPtr; count: IntPtr; &type: glDrawElementsType; var indices: IntPtr; primcount: Int32; modestride: Int32)>(MultiModeDrawElementsIBM_adr);
    private ntv_MultiModeDrawElementsIBM_8 := GetProcOrNil&<procedure(mode: IntPtr; count: IntPtr; &type: glDrawElementsType; indices: pointer; primcount: Int32; modestride: Int32)>(MultiModeDrawElementsIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of glPrimitiveType; count: array of Int32; &type: glDrawElementsType; indices: array of IntPtr; primcount: Int32; modestride: Int32);
    type PGlPrimitiveType = ^glPrimitiveType;
    type PInt32 = ^Int32;
    type PIntPtr = ^IntPtr;
    begin
      if (mode<>nil) and (mode.Length<>0) then
        if (count<>nil) and (count.Length<>0) then
          if (indices<>nil) and (indices.Length<>0) then
            ntv_MultiModeDrawElementsIBM_1(mode[0], count[0], &type, indices[0], primcount, modestride) else
            ntv_MultiModeDrawElementsIBM_1(mode[0], count[0], &type, PIntPtr(nil)^, primcount, modestride) else
          if (indices<>nil) and (indices.Length<>0) then
            ntv_MultiModeDrawElementsIBM_1(mode[0], PInt32(nil)^, &type, indices[0], primcount, modestride) else
            ntv_MultiModeDrawElementsIBM_1(mode[0], PInt32(nil)^, &type, PIntPtr(nil)^, primcount, modestride) else
        if (count<>nil) and (count.Length<>0) then
          if (indices<>nil) and (indices.Length<>0) then
            ntv_MultiModeDrawElementsIBM_1(PGlPrimitiveType(nil)^, count[0], &type, indices[0], primcount, modestride) else
            ntv_MultiModeDrawElementsIBM_1(PGlPrimitiveType(nil)^, count[0], &type, PIntPtr(nil)^, primcount, modestride) else
          if (indices<>nil) and (indices.Length<>0) then
            ntv_MultiModeDrawElementsIBM_1(PGlPrimitiveType(nil)^, PInt32(nil)^, &type, indices[0], primcount, modestride) else
            ntv_MultiModeDrawElementsIBM_1(PGlPrimitiveType(nil)^, PInt32(nil)^, &type, PIntPtr(nil)^, primcount, modestride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; var indices: IntPtr; primcount: Int32; modestride: Int32) :=
      ntv_MultiModeDrawElementsIBM_1(mode, count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; indices: pointer; primcount: Int32; modestride: Int32) :=
      ntv_MultiModeDrawElementsIBM_2(mode, count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; var indices: IntPtr; primcount: Int32; modestride: Int32) :=
      ntv_MultiModeDrawElementsIBM_3(mode, count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; indices: pointer; primcount: Int32; modestride: Int32) :=
      ntv_MultiModeDrawElementsIBM_4(mode, count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: IntPtr; var count: Int32; &type: glDrawElementsType; var indices: IntPtr; primcount: Int32; modestride: Int32) :=
      ntv_MultiModeDrawElementsIBM_5(mode, count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: IntPtr; var count: Int32; &type: glDrawElementsType; indices: pointer; primcount: Int32; modestride: Int32) :=
      ntv_MultiModeDrawElementsIBM_6(mode, count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: IntPtr; count: IntPtr; &type: glDrawElementsType; var indices: IntPtr; primcount: Int32; modestride: Int32) :=
      ntv_MultiModeDrawElementsIBM_7(mode, count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: IntPtr; count: IntPtr; &type: glDrawElementsType; indices: pointer; primcount: Int32; modestride: Int32) :=
      ntv_MultiModeDrawElementsIBM_8(mode, count, &type, indices, primcount, modestride);
    
  end;
  
  ///
  glRasterposClipIBM = static class
    public const _ExtStr = 'GL_IBM_rasterpos_clip';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glStaticDataIBM = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_IBM_static_data';
    
    private FlushStaticDataIBM_adr := GetProcAddress('glFlushStaticDataIBM');
    private ntv_FlushStaticDataIBM_1 := GetProcOrNil&<procedure(target: DummyEnum)>(FlushStaticDataIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushStaticDataIBM(target: DummyEnum) :=
      ntv_FlushStaticDataIBM_1(target);
    
  end;
  
  ///
  glTextureMirroredRepeatIBM = static class
    public const _ExtStr = 'GL_IBM_texture_mirrored_repeat';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexArrayListsIBM = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_IBM_vertex_array_lists';
    
    private ColorPointerListIBM_adr := GetProcAddress('glColorPointerListIBM');
    private ntv_ColorPointerListIBM_1 := GetProcOrNil&<procedure(size: Int32; &type: glColorPointerType; stride: Int32; var pointer: IntPtr; ptrstride: Int32)>(ColorPointerListIBM_adr);
    private ntv_ColorPointerListIBM_2 := GetProcOrNil&<procedure(size: Int32; &type: glColorPointerType; stride: Int32; pointer: pointer; ptrstride: Int32)>(ColorPointerListIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointerListIBM(size: Int32; &type: glColorPointerType; stride: Int32; pointer: array of IntPtr; ptrstride: Int32);
    type PIntPtr = ^IntPtr;
    begin
      if (pointer<>nil) and (pointer.Length<>0) then
        ntv_ColorPointerListIBM_1(size, &type, stride, pointer[0], ptrstride) else
        ntv_ColorPointerListIBM_1(size, &type, stride, PIntPtr(nil)^, ptrstride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointerListIBM(size: Int32; &type: glColorPointerType; stride: Int32; var pointer: IntPtr; ptrstride: Int32) :=
      ntv_ColorPointerListIBM_1(size, &type, stride, pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointerListIBM(size: Int32; &type: glColorPointerType; stride: Int32; pointer: pointer; ptrstride: Int32) :=
      ntv_ColorPointerListIBM_2(size, &type, stride, pointer, ptrstride);
    
    private SecondaryColorPointerListIBM_adr := GetProcAddress('glSecondaryColorPointerListIBM');
    private ntv_SecondaryColorPointerListIBM_1 := GetProcOrNil&<procedure(size: Int32; &type: glSecondaryColorPointerType; stride: Int32; var pointer: IntPtr; ptrstride: Int32)>(SecondaryColorPointerListIBM_adr);
    private ntv_SecondaryColorPointerListIBM_2 := GetProcOrNil&<procedure(size: Int32; &type: glSecondaryColorPointerType; stride: Int32; pointer: pointer; ptrstride: Int32)>(SecondaryColorPointerListIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointerListIBM(size: Int32; &type: glSecondaryColorPointerType; stride: Int32; pointer: array of IntPtr; ptrstride: Int32);
    type PIntPtr = ^IntPtr;
    begin
      if (pointer<>nil) and (pointer.Length<>0) then
        ntv_SecondaryColorPointerListIBM_1(size, &type, stride, pointer[0], ptrstride) else
        ntv_SecondaryColorPointerListIBM_1(size, &type, stride, PIntPtr(nil)^, ptrstride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointerListIBM(size: Int32; &type: glSecondaryColorPointerType; stride: Int32; var pointer: IntPtr; ptrstride: Int32) :=
      ntv_SecondaryColorPointerListIBM_1(size, &type, stride, pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointerListIBM(size: Int32; &type: glSecondaryColorPointerType; stride: Int32; pointer: pointer; ptrstride: Int32) :=
      ntv_SecondaryColorPointerListIBM_2(size, &type, stride, pointer, ptrstride);
    
    private EdgeFlagPointerListIBM_adr := GetProcAddress('glEdgeFlagPointerListIBM');
    private ntv_EdgeFlagPointerListIBM_1 := GetProcOrNil&<procedure(stride: Int32; var pointer: IntPtr; ptrstride: Int32)>(EdgeFlagPointerListIBM_adr);
    private ntv_EdgeFlagPointerListIBM_2 := GetProcOrNil&<procedure(stride: Int32; pointer: pointer; ptrstride: Int32)>(EdgeFlagPointerListIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerListIBM(stride: Int32; pointer: array of array of glBool8; ptrstride: Int32);
    begin
      if (pointer=nil) or (pointer.Length=0) then
      begin
        ntv_EdgeFlagPointerListIBM_2(stride, nil, ptrstride);
        exit;
      end;
      var pointer_temp_arr: array of IntPtr;
      try
        begin
          var pointer_el_sz := Marshal.SizeOf&<glBool8>;
          var pointer_org_el_1 := pointer;
          var pointer_len_1 := pointer_org_el_1.Length;
          SetLength(pointer_temp_arr, pointer_len_1);
          var pointer_tmp_el_1 := pointer_temp_arr;
          for var pointer_ind_1 := 0 to pointer_len_1-1 do
          begin
            var pointer_org_el_2 := pointer_org_el_1[pointer_ind_1];
            if (pointer_org_el_2=nil) or (pointer_org_el_2.Length=0) then continue;
            var pointer_len_2 := pointer_org_el_2.Length;
            var pointer_tmp_el_2_ptr := Marshal.AllocHGlobal(pointer_len_2 * pointer_el_sz);
            pointer_tmp_el_1[pointer_ind_1] := pointer_tmp_el_2_ptr;
            for var pointer_ind_2 := 0 to pointer_len_2-1 do
            begin
              var pointer_tmp_el_2_ptr_typed: ^glBool8 := pointer_tmp_el_2_ptr.ToPointer;
              pointer_tmp_el_2_ptr_typed^ := pointer_org_el_2[pointer_ind_2];
              pointer_tmp_el_2_ptr := pointer_tmp_el_2_ptr + pointer_el_sz;
            end;
          end;
        end;
        ntv_EdgeFlagPointerListIBM_1(stride, pointer_temp_arr[0], ptrstride);
      finally
         foreach var arr_el1 in pointer_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerListIBM(stride: Int32; var pointer: IntPtr; ptrstride: Int32) :=
      ntv_EdgeFlagPointerListIBM_1(stride, pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerListIBM(stride: Int32; pointer: pointer; ptrstride: Int32) :=
      ntv_EdgeFlagPointerListIBM_2(stride, pointer, ptrstride);
    
    private FogCoordPointerListIBM_adr := GetProcAddress('glFogCoordPointerListIBM');
    private ntv_FogCoordPointerListIBM_1 := GetProcOrNil&<procedure(&type: glFogPointerType; stride: Int32; var pointer: IntPtr; ptrstride: Int32)>(FogCoordPointerListIBM_adr);
    private ntv_FogCoordPointerListIBM_2 := GetProcOrNil&<procedure(&type: glFogPointerType; stride: Int32; pointer: pointer; ptrstride: Int32)>(FogCoordPointerListIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointerListIBM(&type: glFogPointerType; stride: Int32; pointer: array of IntPtr; ptrstride: Int32);
    type PIntPtr = ^IntPtr;
    begin
      if (pointer<>nil) and (pointer.Length<>0) then
        ntv_FogCoordPointerListIBM_1(&type, stride, pointer[0], ptrstride) else
        ntv_FogCoordPointerListIBM_1(&type, stride, PIntPtr(nil)^, ptrstride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointerListIBM(&type: glFogPointerType; stride: Int32; var pointer: IntPtr; ptrstride: Int32) :=
      ntv_FogCoordPointerListIBM_1(&type, stride, pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointerListIBM(&type: glFogPointerType; stride: Int32; pointer: pointer; ptrstride: Int32) :=
      ntv_FogCoordPointerListIBM_2(&type, stride, pointer, ptrstride);
    
    private IndexPointerListIBM_adr := GetProcAddress('glIndexPointerListIBM');
    private ntv_IndexPointerListIBM_1 := GetProcOrNil&<procedure(&type: glIndexPointerType; stride: Int32; var pointer: IntPtr; ptrstride: Int32)>(IndexPointerListIBM_adr);
    private ntv_IndexPointerListIBM_2 := GetProcOrNil&<procedure(&type: glIndexPointerType; stride: Int32; pointer: pointer; ptrstride: Int32)>(IndexPointerListIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointerListIBM(&type: glIndexPointerType; stride: Int32; pointer: array of IntPtr; ptrstride: Int32);
    type PIntPtr = ^IntPtr;
    begin
      if (pointer<>nil) and (pointer.Length<>0) then
        ntv_IndexPointerListIBM_1(&type, stride, pointer[0], ptrstride) else
        ntv_IndexPointerListIBM_1(&type, stride, PIntPtr(nil)^, ptrstride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointerListIBM(&type: glIndexPointerType; stride: Int32; var pointer: IntPtr; ptrstride: Int32) :=
      ntv_IndexPointerListIBM_1(&type, stride, pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointerListIBM(&type: glIndexPointerType; stride: Int32; pointer: pointer; ptrstride: Int32) :=
      ntv_IndexPointerListIBM_2(&type, stride, pointer, ptrstride);
    
    private NormalPointerListIBM_adr := GetProcAddress('glNormalPointerListIBM');
    private ntv_NormalPointerListIBM_1 := GetProcOrNil&<procedure(&type: glNormalPointerType; stride: Int32; var pointer: IntPtr; ptrstride: Int32)>(NormalPointerListIBM_adr);
    private ntv_NormalPointerListIBM_2 := GetProcOrNil&<procedure(&type: glNormalPointerType; stride: Int32; pointer: pointer; ptrstride: Int32)>(NormalPointerListIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointerListIBM(&type: glNormalPointerType; stride: Int32; pointer: array of IntPtr; ptrstride: Int32);
    type PIntPtr = ^IntPtr;
    begin
      if (pointer<>nil) and (pointer.Length<>0) then
        ntv_NormalPointerListIBM_1(&type, stride, pointer[0], ptrstride) else
        ntv_NormalPointerListIBM_1(&type, stride, PIntPtr(nil)^, ptrstride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointerListIBM(&type: glNormalPointerType; stride: Int32; var pointer: IntPtr; ptrstride: Int32) :=
      ntv_NormalPointerListIBM_1(&type, stride, pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointerListIBM(&type: glNormalPointerType; stride: Int32; pointer: pointer; ptrstride: Int32) :=
      ntv_NormalPointerListIBM_2(&type, stride, pointer, ptrstride);
    
    private TexCoordPointerListIBM_adr := GetProcAddress('glTexCoordPointerListIBM');
    private ntv_TexCoordPointerListIBM_1 := GetProcOrNil&<procedure(size: Int32; &type: glTexCoordPointerType; stride: Int32; var pointer: IntPtr; ptrstride: Int32)>(TexCoordPointerListIBM_adr);
    private ntv_TexCoordPointerListIBM_2 := GetProcOrNil&<procedure(size: Int32; &type: glTexCoordPointerType; stride: Int32; pointer: pointer; ptrstride: Int32)>(TexCoordPointerListIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointerListIBM(size: Int32; &type: glTexCoordPointerType; stride: Int32; pointer: array of IntPtr; ptrstride: Int32);
    type PIntPtr = ^IntPtr;
    begin
      if (pointer<>nil) and (pointer.Length<>0) then
        ntv_TexCoordPointerListIBM_1(size, &type, stride, pointer[0], ptrstride) else
        ntv_TexCoordPointerListIBM_1(size, &type, stride, PIntPtr(nil)^, ptrstride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointerListIBM(size: Int32; &type: glTexCoordPointerType; stride: Int32; var pointer: IntPtr; ptrstride: Int32) :=
      ntv_TexCoordPointerListIBM_1(size, &type, stride, pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointerListIBM(size: Int32; &type: glTexCoordPointerType; stride: Int32; pointer: pointer; ptrstride: Int32) :=
      ntv_TexCoordPointerListIBM_2(size, &type, stride, pointer, ptrstride);
    
    private VertexPointerListIBM_adr := GetProcAddress('glVertexPointerListIBM');
    private ntv_VertexPointerListIBM_1 := GetProcOrNil&<procedure(size: Int32; &type: glVertexPointerType; stride: Int32; var pointer: IntPtr; ptrstride: Int32)>(VertexPointerListIBM_adr);
    private ntv_VertexPointerListIBM_2 := GetProcOrNil&<procedure(size: Int32; &type: glVertexPointerType; stride: Int32; pointer: pointer; ptrstride: Int32)>(VertexPointerListIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointerListIBM(size: Int32; &type: glVertexPointerType; stride: Int32; pointer: array of IntPtr; ptrstride: Int32);
    type PIntPtr = ^IntPtr;
    begin
      if (pointer<>nil) and (pointer.Length<>0) then
        ntv_VertexPointerListIBM_1(size, &type, stride, pointer[0], ptrstride) else
        ntv_VertexPointerListIBM_1(size, &type, stride, PIntPtr(nil)^, ptrstride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointerListIBM(size: Int32; &type: glVertexPointerType; stride: Int32; var pointer: IntPtr; ptrstride: Int32) :=
      ntv_VertexPointerListIBM_1(size, &type, stride, pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointerListIBM(size: Int32; &type: glVertexPointerType; stride: Int32; pointer: pointer; ptrstride: Int32) :=
      ntv_VertexPointerListIBM_2(size, &type, stride, pointer, ptrstride);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glBlendFuncSeparateINGR = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_INGR_blend_func_separate';
    
    private BlendFuncSeparateINGR_adr := GetProcAddress('glBlendFuncSeparateINGR');
    private ntv_BlendFuncSeparateINGR_1 := GetProcOrNil&<procedure(sfactorRGB: glBlendingFactor; dfactorRGB: glBlendingFactor; sfactorAlpha: glBlendingFactor; dfactorAlpha: glBlendingFactor)>(BlendFuncSeparateINGR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparateINGR(sfactorRGB: glBlendingFactor; dfactorRGB: glBlendingFactor; sfactorAlpha: glBlendingFactor; dfactorAlpha: glBlendingFactor) :=
      ntv_BlendFuncSeparateINGR_1(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    
  end;
  
  ///
  glColorClampINGR = static class
    public const _ExtStr = 'GL_INGR_color_clamp';
  end;
  
  ///
  glInterlaceReadINGR = static class
    public const _ExtStr = 'GL_INGR_interlace_read';
  end;
  
  ///
  glBlackholeRenderINTEL = static class
    public const _ExtStr = 'GL_INTEL_blackhole_render';
  end;
  
  ///
  glConservativeRasterizationINTEL = static class
    public const _ExtStr = 'GL_INTEL_conservative_rasterization';
  end;
  
  ///
  glFragmentShaderOrderingINTEL = static class
    public const _ExtStr = 'GL_INTEL_fragment_shader_ordering';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFramebufferCMAAINTEL = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_INTEL_framebuffer_CMAA';
    
    private ApplyFramebufferAttachmentCMAAINTEL_adr := GetProcAddress('glApplyFramebufferAttachmentCMAAINTEL');
    private ntv_ApplyFramebufferAttachmentCMAAINTEL_1 := GetProcOrNil&<procedure>(ApplyFramebufferAttachmentCMAAINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ApplyFramebufferAttachmentCMAAINTEL :=
      ntv_ApplyFramebufferAttachmentCMAAINTEL_1;
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMapTextureINTEL = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_INTEL_map_texture';
    
    private SyncTextureINTEL_adr := GetProcAddress('glSyncTextureINTEL');
    private ntv_SyncTextureINTEL_1 := GetProcOrNil&<procedure(texture: gl_texture)>(SyncTextureINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SyncTextureINTEL(texture: gl_texture) :=
      ntv_SyncTextureINTEL_1(texture);
    
    private UnmapTexture2DINTEL_adr := GetProcAddress('glUnmapTexture2DINTEL');
    private ntv_UnmapTexture2DINTEL_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32)>(UnmapTexture2DINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UnmapTexture2DINTEL(texture: gl_texture; level: Int32) :=
      ntv_UnmapTexture2DINTEL_1(texture, level);
    
    private MapTexture2DINTEL_adr := GetProcAddress('glMapTexture2DINTEL');
    private ntv_MapTexture2DINTEL_1 := GetProcOrNil&<function(texture: gl_texture; level: Int32; access: DummyFlags; var stride: Int32; var layout: DummyEnum): IntPtr>(MapTexture2DINTEL_adr);
    private ntv_MapTexture2DINTEL_2 := GetProcOrNil&<function(texture: gl_texture; level: Int32; access: DummyFlags; var stride: Int32; layout: IntPtr): IntPtr>(MapTexture2DINTEL_adr);
    private ntv_MapTexture2DINTEL_3 := GetProcOrNil&<function(texture: gl_texture; level: Int32; access: DummyFlags; stride: IntPtr; var layout: DummyEnum): IntPtr>(MapTexture2DINTEL_adr);
    private ntv_MapTexture2DINTEL_4 := GetProcOrNil&<function(texture: gl_texture; level: Int32; access: DummyFlags; stride: IntPtr; layout: IntPtr): IntPtr>(MapTexture2DINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: gl_texture; level: Int32; access: DummyFlags; stride: array of Int32; layout: array of DummyEnum): IntPtr;
    type PInt32 = ^Int32;
    type PDummyEnum = ^DummyEnum;
    begin
      Result := if (layout<>nil) and (layout.Length<>0) then
        if (stride<>nil) and (stride.Length<>0) then
          ntv_MapTexture2DINTEL_1(texture, level, access, stride[0], layout[0]) else
          ntv_MapTexture2DINTEL_1(texture, level, access, PInt32(nil)^, layout[0]) else
        if (stride<>nil) and (stride.Length<>0) then
          ntv_MapTexture2DINTEL_1(texture, level, access, stride[0], PDummyEnum(nil)^) else
          ntv_MapTexture2DINTEL_1(texture, level, access, PInt32(nil)^, PDummyEnum(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: gl_texture; level: Int32; access: DummyFlags; var stride: Int32; var layout: DummyEnum): IntPtr :=
      ntv_MapTexture2DINTEL_1(texture, level, access, stride, layout);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: gl_texture; level: Int32; access: DummyFlags; var stride: Int32; layout: IntPtr): IntPtr :=
      ntv_MapTexture2DINTEL_2(texture, level, access, stride, layout);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: gl_texture; level: Int32; access: DummyFlags; stride: IntPtr; var layout: DummyEnum): IntPtr :=
      ntv_MapTexture2DINTEL_3(texture, level, access, stride, layout);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: gl_texture; level: Int32; access: DummyFlags; stride: IntPtr; layout: IntPtr): IntPtr :=
      ntv_MapTexture2DINTEL_4(texture, level, access, stride, layout);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glParallelArraysINTEL = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_INTEL_parallel_arrays';
    
    private VertexPointervINTEL_adr := GetProcAddress('glVertexPointervINTEL');
    private ntv_VertexPointervINTEL_1 := GetProcOrNil&<procedure(size: Int32; &type: glVertexPointerType; var pointer: IntPtr)>(VertexPointervINTEL_adr);
    private ntv_VertexPointervINTEL_2 := GetProcOrNil&<procedure(size: Int32; &type: glVertexPointerType; pointer: pointer)>(VertexPointervINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointervINTEL(size: Int32; &type: glVertexPointerType; pointer: array of IntPtr);
    type PIntPtr = ^IntPtr;
    begin
      if (pointer<>nil) and (pointer.Length<>0) then
        ntv_VertexPointervINTEL_1(size, &type, pointer[0]) else
        ntv_VertexPointervINTEL_1(size, &type, PIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointervINTEL(size: Int32; &type: glVertexPointerType; var pointer: IntPtr) :=
      ntv_VertexPointervINTEL_1(size, &type, pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointervINTEL(size: Int32; &type: glVertexPointerType; pointer: pointer) :=
      ntv_VertexPointervINTEL_2(size, &type, pointer);
    
    private NormalPointervINTEL_adr := GetProcAddress('glNormalPointervINTEL');
    private ntv_NormalPointervINTEL_1 := GetProcOrNil&<procedure(&type: glNormalPointerType; var pointer: IntPtr)>(NormalPointervINTEL_adr);
    private ntv_NormalPointervINTEL_2 := GetProcOrNil&<procedure(&type: glNormalPointerType; pointer: pointer)>(NormalPointervINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointervINTEL(&type: glNormalPointerType; pointer: array of IntPtr);
    type PIntPtr = ^IntPtr;
    begin
      if (pointer<>nil) and (pointer.Length<>0) then
        ntv_NormalPointervINTEL_1(&type, pointer[0]) else
        ntv_NormalPointervINTEL_1(&type, PIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointervINTEL(&type: glNormalPointerType; var pointer: IntPtr) :=
      ntv_NormalPointervINTEL_1(&type, pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointervINTEL(&type: glNormalPointerType; pointer: pointer) :=
      ntv_NormalPointervINTEL_2(&type, pointer);
    
    private ColorPointervINTEL_adr := GetProcAddress('glColorPointervINTEL');
    private ntv_ColorPointervINTEL_1 := GetProcOrNil&<procedure(size: Int32; &type: glVertexPointerType; var pointer: IntPtr)>(ColorPointervINTEL_adr);
    private ntv_ColorPointervINTEL_2 := GetProcOrNil&<procedure(size: Int32; &type: glVertexPointerType; pointer: pointer)>(ColorPointervINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointervINTEL(size: Int32; &type: glVertexPointerType; pointer: array of IntPtr);
    type PIntPtr = ^IntPtr;
    begin
      if (pointer<>nil) and (pointer.Length<>0) then
        ntv_ColorPointervINTEL_1(size, &type, pointer[0]) else
        ntv_ColorPointervINTEL_1(size, &type, PIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointervINTEL(size: Int32; &type: glVertexPointerType; var pointer: IntPtr) :=
      ntv_ColorPointervINTEL_1(size, &type, pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointervINTEL(size: Int32; &type: glVertexPointerType; pointer: pointer) :=
      ntv_ColorPointervINTEL_2(size, &type, pointer);
    
    private TexCoordPointervINTEL_adr := GetProcAddress('glTexCoordPointervINTEL');
    private ntv_TexCoordPointervINTEL_1 := GetProcOrNil&<procedure(size: Int32; &type: glVertexPointerType; var pointer: IntPtr)>(TexCoordPointervINTEL_adr);
    private ntv_TexCoordPointervINTEL_2 := GetProcOrNil&<procedure(size: Int32; &type: glVertexPointerType; pointer: pointer)>(TexCoordPointervINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointervINTEL(size: Int32; &type: glVertexPointerType; pointer: array of IntPtr);
    type PIntPtr = ^IntPtr;
    begin
      if (pointer<>nil) and (pointer.Length<>0) then
        ntv_TexCoordPointervINTEL_1(size, &type, pointer[0]) else
        ntv_TexCoordPointervINTEL_1(size, &type, PIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointervINTEL(size: Int32; &type: glVertexPointerType; var pointer: IntPtr) :=
      ntv_TexCoordPointervINTEL_1(size, &type, pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointervINTEL(size: Int32; &type: glVertexPointerType; pointer: pointer) :=
      ntv_TexCoordPointervINTEL_2(size, &type, pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPerformanceQueryINTEL = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_INTEL_performance_query';
    
    private BeginPerfQueryINTEL_adr := GetProcAddress('glBeginPerfQueryINTEL');
    private ntv_BeginPerfQueryINTEL_1 := GetProcOrNil&<procedure(queryHandle: gl_perf_query_handle)>(BeginPerfQueryINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginPerfQueryINTEL(queryHandle: gl_perf_query_handle) :=
      ntv_BeginPerfQueryINTEL_1(queryHandle);
    
    private CreatePerfQueryINTEL_adr := GetProcAddress('glCreatePerfQueryINTEL');
    private ntv_CreatePerfQueryINTEL_1 := GetProcOrNil&<procedure(queryId: gl_perf_query_id; var queryHandle: gl_perf_query_handle)>(CreatePerfQueryINTEL_adr);
    private ntv_CreatePerfQueryINTEL_2 := GetProcOrNil&<procedure(queryId: gl_perf_query_id; queryHandle: IntPtr)>(CreatePerfQueryINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreatePerfQueryINTEL(queryId: gl_perf_query_id; queryHandle: array of gl_perf_query_handle);
    type PGl_perf_query_handle = ^gl_perf_query_handle;
    begin
      if (queryHandle<>nil) and (queryHandle.Length<>0) then
        ntv_CreatePerfQueryINTEL_1(queryId, queryHandle[0]) else
        ntv_CreatePerfQueryINTEL_1(queryId, PGl_perf_query_handle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreatePerfQueryINTEL(queryId: gl_perf_query_id; var queryHandle: gl_perf_query_handle) :=
      ntv_CreatePerfQueryINTEL_1(queryId, queryHandle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreatePerfQueryINTEL(queryId: gl_perf_query_id; queryHandle: IntPtr) :=
      ntv_CreatePerfQueryINTEL_2(queryId, queryHandle);
    
    private DeletePerfQueryINTEL_adr := GetProcAddress('glDeletePerfQueryINTEL');
    private ntv_DeletePerfQueryINTEL_1 := GetProcOrNil&<procedure(queryHandle: gl_perf_query_handle)>(DeletePerfQueryINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePerfQueryINTEL(queryHandle: gl_perf_query_handle) :=
      ntv_DeletePerfQueryINTEL_1(queryHandle);
    
    private EndPerfQueryINTEL_adr := GetProcAddress('glEndPerfQueryINTEL');
    private ntv_EndPerfQueryINTEL_1 := GetProcOrNil&<procedure(queryHandle: gl_perf_query_handle)>(EndPerfQueryINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndPerfQueryINTEL(queryHandle: gl_perf_query_handle) :=
      ntv_EndPerfQueryINTEL_1(queryHandle);
    
    private GetFirstPerfQueryIdINTEL_adr := GetProcAddress('glGetFirstPerfQueryIdINTEL');
    private ntv_GetFirstPerfQueryIdINTEL_1 := GetProcOrNil&<procedure(var queryId: gl_perf_query_id)>(GetFirstPerfQueryIdINTEL_adr);
    private ntv_GetFirstPerfQueryIdINTEL_2 := GetProcOrNil&<procedure(queryId: IntPtr)>(GetFirstPerfQueryIdINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFirstPerfQueryIdINTEL(var queryId: gl_perf_query_id) :=
      ntv_GetFirstPerfQueryIdINTEL_1(queryId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFirstPerfQueryIdINTEL(queryId: IntPtr) :=
      ntv_GetFirstPerfQueryIdINTEL_2(queryId);
    
    private GetNextPerfQueryIdINTEL_adr := GetProcAddress('glGetNextPerfQueryIdINTEL');
    private ntv_GetNextPerfQueryIdINTEL_1 := GetProcOrNil&<procedure(queryId: gl_perf_query_id; var nextQueryId: gl_perf_query_id)>(GetNextPerfQueryIdINTEL_adr);
    private ntv_GetNextPerfQueryIdINTEL_2 := GetProcOrNil&<procedure(queryId: gl_perf_query_id; nextQueryId: IntPtr)>(GetNextPerfQueryIdINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNextPerfQueryIdINTEL(queryId: gl_perf_query_id; var nextQueryId: gl_perf_query_id) :=
      ntv_GetNextPerfQueryIdINTEL_1(queryId, nextQueryId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNextPerfQueryIdINTEL(queryId: gl_perf_query_id; nextQueryId: IntPtr) :=
      ntv_GetNextPerfQueryIdINTEL_2(queryId, nextQueryId);
    
    private GetPerfCounterInfoINTEL_adr := GetProcAddress('glGetPerfCounterInfoINTEL');
    private ntv_GetPerfCounterInfoINTEL_1 := GetProcOrNil&<procedure(queryId: gl_perf_query_id; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64)>(GetPerfCounterInfoINTEL_adr);
    private ntv_GetPerfCounterInfoINTEL_2 := GetProcOrNil&<procedure(queryId: gl_perf_query_id; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: IntPtr; counterDataSize: IntPtr; counterTypeEnum: IntPtr; counterDataTypeEnum: IntPtr; rawCounterMaxValue: IntPtr)>(GetPerfCounterInfoINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: gl_perf_query_id; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) :=
      ntv_GetPerfCounterInfoINTEL_1(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: gl_perf_query_id; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: IntPtr; counterDataSize: IntPtr; counterTypeEnum: IntPtr; counterDataTypeEnum: IntPtr; rawCounterMaxValue: IntPtr) :=
      ntv_GetPerfCounterInfoINTEL_2(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    
    private GetPerfQueryDataINTEL_adr := GetProcAddress('glGetPerfQueryDataINTEL');
    private ntv_GetPerfQueryDataINTEL_1 := GetProcOrNil&<procedure(queryHandle: gl_perf_query_handle; flags: glPerfQueryDataFlags; dataSize: Int32; data: IntPtr; var bytesWritten: UInt32)>(GetPerfQueryDataINTEL_adr);
    private ntv_GetPerfQueryDataINTEL_2 := GetProcOrNil&<procedure(queryHandle: gl_perf_query_handle; flags: glPerfQueryDataFlags; dataSize: Int32; data: IntPtr; bytesWritten: IntPtr)>(GetPerfQueryDataINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryDataINTEL(queryHandle: gl_perf_query_handle; flags: glPerfQueryDataFlags; dataSize: Int32; data: IntPtr; var bytesWritten: UInt32) :=
      ntv_GetPerfQueryDataINTEL_1(queryHandle, flags, dataSize, data, bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryDataINTEL(queryHandle: gl_perf_query_handle; flags: glPerfQueryDataFlags; dataSize: Int32; data: IntPtr; bytesWritten: IntPtr) :=
      ntv_GetPerfQueryDataINTEL_2(queryHandle, flags, dataSize, data, bytesWritten);
    
    private GetPerfQueryIdByNameINTEL_adr := GetProcAddress('glGetPerfQueryIdByNameINTEL');
    private ntv_GetPerfQueryIdByNameINTEL_1 := GetProcOrNil&<procedure(queryName: IntPtr; var queryId: gl_perf_query_id)>(GetPerfQueryIdByNameINTEL_adr);
    private ntv_GetPerfQueryIdByNameINTEL_2 := GetProcOrNil&<procedure(queryName: IntPtr; queryId: IntPtr)>(GetPerfQueryIdByNameINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: string; var queryId: gl_perf_query_id);
    begin
      var queryName_str_ptr := Marshal.StringToHGlobalAnsi(queryName);
      try
        ntv_GetPerfQueryIdByNameINTEL_1(queryName_str_ptr, queryId);
      finally
        Marshal.FreeHGlobal(queryName_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: string; queryId: IntPtr);
    begin
      var queryName_str_ptr := Marshal.StringToHGlobalAnsi(queryName);
      try
        ntv_GetPerfQueryIdByNameINTEL_2(queryName_str_ptr, queryId);
      finally
        Marshal.FreeHGlobal(queryName_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: IntPtr; var queryId: gl_perf_query_id) :=
      ntv_GetPerfQueryIdByNameINTEL_1(queryName, queryId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: IntPtr; queryId: IntPtr) :=
      ntv_GetPerfQueryIdByNameINTEL_2(queryName, queryId);
    
    private GetPerfQueryInfoINTEL_adr := GetProcAddress('glGetPerfQueryInfoINTEL');
    private ntv_GetPerfQueryInfoINTEL_1 := GetProcOrNil&<procedure(queryId: gl_perf_query_id; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; var noCounters: UInt32; var noInstances: UInt32; var capsMask: glPerformanceQueryCapsMask)>(GetPerfQueryInfoINTEL_adr);
    private ntv_GetPerfQueryInfoINTEL_2 := GetProcOrNil&<procedure(queryId: gl_perf_query_id; queryNameLength: UInt32; queryName: IntPtr; dataSize: IntPtr; noCounters: IntPtr; noInstances: IntPtr; capsMask: IntPtr)>(GetPerfQueryInfoINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: gl_perf_query_id; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; var noCounters: UInt32; var noInstances: UInt32; var capsMask: glPerformanceQueryCapsMask) :=
      ntv_GetPerfQueryInfoINTEL_1(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: gl_perf_query_id; queryNameLength: UInt32; queryName: IntPtr; dataSize: IntPtr; noCounters: IntPtr; noInstances: IntPtr; capsMask: IntPtr) :=
      ntv_GetPerfQueryInfoINTEL_2(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glBlendEquationAdvancedKHR = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_KHR_blend_equation_advanced';
    
    private BlendBarrierKHR_adr := GetProcAddress('glBlendBarrierKHR');
    private ntv_BlendBarrierKHR_1 := GetProcOrNil&<procedure>(BlendBarrierKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendBarrierKHR :=
      ntv_BlendBarrierKHR_1;
    
  end;
  
  ///
  glBlendEquationAdvancedCoherentKHR = static class
    public const _ExtStr = 'GL_KHR_blend_equation_advanced_coherent';
  end;
  
  ///
  glContextFlushControlKHR = static class
    public const _ExtStr = 'GL_KHR_context_flush_control';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDebugKHR = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_KHR_debug';
    
    private DebugMessageControl_adr := GetProcAddress('glDebugMessageControl');
    private ntv_DebugMessageControl_1 := GetProcOrNil&<procedure(source: glDebugSource; &type: glDebugType; severity: glDebugSeverity; count: Int32; var ids: UInt32; enabled: glBool8)>(DebugMessageControl_adr);
    private ntv_DebugMessageControl_2 := GetProcOrNil&<procedure(source: glDebugSource; &type: glDebugType; severity: glDebugSeverity; count: Int32; ids: IntPtr; enabled: glBool8)>(DebugMessageControl_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControl(source: glDebugSource; &type: glDebugType; severity: glDebugSeverity; count: Int32; ids: array of UInt32; enabled: glBool8);
    type PUInt32 = ^UInt32;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_DebugMessageControl_1(source, &type, severity, count, ids[0], enabled) else
        ntv_DebugMessageControl_1(source, &type, severity, count, PUInt32(nil)^, enabled);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControl(source: glDebugSource; &type: glDebugType; severity: glDebugSeverity; count: Int32; var ids: UInt32; enabled: glBool8) :=
      ntv_DebugMessageControl_1(source, &type, severity, count, ids, enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControl(source: glDebugSource; &type: glDebugType; severity: glDebugSeverity; count: Int32; ids: IntPtr; enabled: glBool8) :=
      ntv_DebugMessageControl_2(source, &type, severity, count, ids, enabled);
    
    private DebugMessageInsert_adr := GetProcAddress('glDebugMessageInsert');
    private ntv_DebugMessageInsert_1 := GetProcOrNil&<procedure(source: glDebugSource; &type: glDebugType; id: UInt32; severity: glDebugSeverity; length: Int32; buf: IntPtr)>(DebugMessageInsert_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsert(source: glDebugSource; &type: glDebugType; id: UInt32; severity: glDebugSeverity; length: Int32; buf: string);
    begin
      var buf_str_ptr := Marshal.StringToHGlobalAnsi(buf);
      try
        ntv_DebugMessageInsert_1(source, &type, id, severity, length, buf_str_ptr);
      finally
        Marshal.FreeHGlobal(buf_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsert(source: glDebugSource; &type: glDebugType; id: UInt32; severity: glDebugSeverity; length: Int32; buf: IntPtr) :=
      ntv_DebugMessageInsert_1(source, &type, id, severity, length, buf);
    
    private DebugMessageCallback_adr := GetProcAddress('glDebugMessageCallback');
    private ntv_DebugMessageCallback_1 := GetProcOrNil&<procedure(callback: glDebugProc; userParam: IntPtr)>(DebugMessageCallback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageCallback(callback: glDebugProc; userParam: IntPtr) :=
      ntv_DebugMessageCallback_1(callback, userParam);
    
    private GetDebugMessageLog_adr := GetProcAddress('glGetDebugMessageLog');
    private ntv_GetDebugMessageLog_1 := GetProcOrNil&<function(count: UInt32; bufSize: Int32; var sources: glDebugSource; var types: glDebugType; var ids: UInt32; var severities: glDebugSeverity; var lengths: Int32; messageLog: IntPtr): UInt32>(GetDebugMessageLog_adr);
    private ntv_GetDebugMessageLog_2 := GetProcOrNil&<function(count: UInt32; bufSize: Int32; sources: IntPtr; types: IntPtr; ids: IntPtr; severities: IntPtr; lengths: IntPtr; messageLog: IntPtr): UInt32>(GetDebugMessageLog_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLog(count: UInt32; bufSize: Int32; var sources: glDebugSource; var types: glDebugType; var ids: UInt32; var severities: glDebugSeverity; var lengths: Int32; messageLog: IntPtr): UInt32 :=
      ntv_GetDebugMessageLog_1(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLog(count: UInt32; bufSize: Int32; sources: IntPtr; types: IntPtr; ids: IntPtr; severities: IntPtr; lengths: IntPtr; messageLog: IntPtr): UInt32 :=
      ntv_GetDebugMessageLog_2(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    
    private PushDebugGroup_adr := GetProcAddress('glPushDebugGroup');
    private ntv_PushDebugGroup_1 := GetProcOrNil&<procedure(source: glDebugSource; id: UInt32; length: Int32; message: IntPtr)>(PushDebugGroup_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushDebugGroup(source: glDebugSource; id: UInt32; length: Int32; message: string);
    begin
      var message_str_ptr := Marshal.StringToHGlobalAnsi(message);
      try
        ntv_PushDebugGroup_1(source, id, length, message_str_ptr);
      finally
        Marshal.FreeHGlobal(message_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushDebugGroup(source: glDebugSource; id: UInt32; length: Int32; message: IntPtr) :=
      ntv_PushDebugGroup_1(source, id, length, message);
    
    private PopDebugGroup_adr := GetProcAddress('glPopDebugGroup');
    private ntv_PopDebugGroup_1 := GetProcOrNil&<procedure>(PopDebugGroup_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopDebugGroup :=
      ntv_PopDebugGroup_1;
    
    private ObjectLabel_adr := GetProcAddress('glObjectLabel');
    private ntv_ObjectLabel_1 := GetProcOrNil&<procedure(identifier: glObjectIdentifier; name: UInt32; length: Int32; &label: IntPtr)>(ObjectLabel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectLabel(identifier: glObjectIdentifier; name: UInt32; length: Int32; &label: string);
    begin
      var &label_str_ptr := Marshal.StringToHGlobalAnsi(&label);
      try
        ntv_ObjectLabel_1(identifier, name, length, &label_str_ptr);
      finally
        Marshal.FreeHGlobal(&label_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectLabel(identifier: glObjectIdentifier; name: UInt32; length: Int32; &label: IntPtr) :=
      ntv_ObjectLabel_1(identifier, name, length, &label);
    
    private GetObjectLabel_adr := GetProcAddress('glGetObjectLabel');
    private ntv_GetObjectLabel_1 := GetProcOrNil&<procedure(identifier: glObjectIdentifier; name: UInt32; bufSize: Int32; var length: Int32; &label: IntPtr)>(GetObjectLabel_adr);
    private ntv_GetObjectLabel_2 := GetProcOrNil&<procedure(identifier: glObjectIdentifier; name: UInt32; bufSize: Int32; length: IntPtr; &label: IntPtr)>(GetObjectLabel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabel(identifier: glObjectIdentifier; name: UInt32; bufSize: Int32; var length: Int32; &label: IntPtr) :=
      ntv_GetObjectLabel_1(identifier, name, bufSize, length, &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabel(identifier: glObjectIdentifier; name: UInt32; bufSize: Int32; length: IntPtr; &label: IntPtr) :=
      ntv_GetObjectLabel_2(identifier, name, bufSize, length, &label);
    
    private ObjectPtrLabel_adr := GetProcAddress('glObjectPtrLabel');
    private ntv_ObjectPtrLabel_1 := GetProcOrNil&<procedure(ptr: IntPtr; length: Int32; &label: IntPtr)>(ObjectPtrLabel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabel(ptr: IntPtr; length: Int32; &label: string);
    begin
      var &label_str_ptr := Marshal.StringToHGlobalAnsi(&label);
      try
        ntv_ObjectPtrLabel_1(ptr, length, &label_str_ptr);
      finally
        Marshal.FreeHGlobal(&label_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabel(ptr: IntPtr; length: Int32; &label: IntPtr) :=
      ntv_ObjectPtrLabel_1(ptr, length, &label);
    
    private GetObjectPtrLabel_adr := GetProcAddress('glGetObjectPtrLabel');
    private ntv_GetObjectPtrLabel_1 := GetProcOrNil&<procedure(ptr: IntPtr; bufSize: Int32; var length: Int32; &label: IntPtr)>(GetObjectPtrLabel_adr);
    private ntv_GetObjectPtrLabel_2 := GetProcOrNil&<procedure(ptr: IntPtr; bufSize: Int32; length: IntPtr; &label: IntPtr)>(GetObjectPtrLabel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabel(ptr: IntPtr; bufSize: Int32; var length: Int32; &label: IntPtr) :=
      ntv_GetObjectPtrLabel_1(ptr, bufSize, length, &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabel(ptr: IntPtr; bufSize: Int32; length: IntPtr; &label: IntPtr) :=
      ntv_GetObjectPtrLabel_2(ptr, bufSize, length, &label);
    
    private GetPointerv_adr := GetProcAddress('glGetPointerv');
    private ntv_GetPointerv_1 := GetProcOrNil&<procedure(pname: glGetPointervPName; var &params: IntPtr)>(GetPointerv_adr);
    private ntv_GetPointerv_2 := GetProcOrNil&<procedure(pname: glGetPointervPName; &params: pointer)>(GetPointerv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerv(pname: glGetPointervPName; var &params: IntPtr) :=
      ntv_GetPointerv_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerv(pname: glGetPointervPName; &params: pointer) :=
      ntv_GetPointerv_2(pname, &params);
    
  end;
  
  ///
  glNoErrorKHR = static class
    public const _ExtStr = 'GL_KHR_no_error';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glParallelShaderCompileKHR = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_KHR_parallel_shader_compile';
    
    private MaxShaderCompilerThreadsKHR_adr := GetProcAddress('glMaxShaderCompilerThreadsKHR');
    private ntv_MaxShaderCompilerThreadsKHR_1 := GetProcOrNil&<procedure(count: UInt32)>(MaxShaderCompilerThreadsKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaxShaderCompilerThreadsKHR(count: UInt32) :=
      ntv_MaxShaderCompilerThreadsKHR_1(count);
    
  end;
  
  ///
  glRobustBufferAccessBehaviorKHR = static class
    public const _ExtStr = 'GL_KHR_robust_buffer_access_behavior';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glRobustnessKHR = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_KHR_robustness';
    
    private GetGraphicsResetStatus_adr := GetProcAddress('glGetGraphicsResetStatus');
    private ntv_GetGraphicsResetStatus_1 := GetProcOrNil&<function: glGraphicsResetStatus>(GetGraphicsResetStatus_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGraphicsResetStatus: glGraphicsResetStatus :=
      ntv_GetGraphicsResetStatus_1;
    
    private ReadnPixels_adr := GetProcAddress('glReadnPixels');
    private ntv_ReadnPixels_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; data: IntPtr)>(ReadnPixels_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadnPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; data: IntPtr) :=
      ntv_ReadnPixels_1(x, y, width, height, format, &type, bufSize, data);
    
    private GetnUniformfv_adr := GetProcAddress('glGetnUniformfv');
    private ntv_GetnUniformfv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: single)>(GetnUniformfv_adr);
    private ntv_GetnUniformfv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(GetnUniformfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfv(&program: gl_program; location: Int32; bufSize: Int32; var &params: single) :=
      ntv_GetnUniformfv_1(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfv(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
      ntv_GetnUniformfv_2(&program, location, bufSize, &params);
    
    private GetnUniformiv_adr := GetProcAddress('glGetnUniformiv');
    private ntv_GetnUniformiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: Int32)>(GetnUniformiv_adr);
    private ntv_GetnUniformiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(GetnUniformiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformiv(&program: gl_program; location: Int32; bufSize: Int32; var &params: Int32) :=
      ntv_GetnUniformiv_1(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformiv(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
      ntv_GetnUniformiv_2(&program, location, bufSize, &params);
    
    private GetnUniformuiv_adr := GetProcAddress('glGetnUniformuiv');
    private ntv_GetnUniformuiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: UInt32)>(GetnUniformuiv_adr);
    private ntv_GetnUniformuiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(GetnUniformuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuiv(&program: gl_program; location: Int32; bufSize: Int32; var &params: UInt32) :=
      ntv_GetnUniformuiv_1(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuiv(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
      ntv_GetnUniformuiv_2(&program, location, bufSize, &params);
    
  end;
  
  ///
  glShaderSubgroupKHR = static class
    public const _ExtStr = 'GL_KHR_shader_subgroup';
  end;
  
  ///
  glTextureCompressionAstcHdrKHR = static class
    public const _ExtStr = 'GL_KHR_texture_compression_astc_hdr';
  end;
  
  ///
  glTextureCompressionAstcLdrKHR = static class
    public const _ExtStr = 'GL_KHR_texture_compression_astc_ldr';
  end;
  
  ///
  glTextureCompressionAstcSliced3dKHR = static class
    public const _ExtStr = 'GL_KHR_texture_compression_astc_sliced_3d';
  end;
  
  ///
  glFramebufferFlipXMESA = static class
    public const _ExtStr = 'GL_MESA_framebuffer_flip_x';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFramebufferFlipYMESA = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_MESA_framebuffer_flip_y';
    
    private FramebufferParameteriMESA_adr := GetProcAddress('glFramebufferParameteriMESA');
    private ntv_FramebufferParameteriMESA_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; pname: glFramebufferParameterName; param: Int32)>(FramebufferParameteriMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferParameteriMESA(target: glFramebufferTarget; pname: glFramebufferParameterName; param: Int32) :=
      ntv_FramebufferParameteriMESA_1(target, pname, param);
    
    private GetFramebufferParameterivMESA_adr := GetProcAddress('glGetFramebufferParameterivMESA');
    private ntv_GetFramebufferParameterivMESA_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; pname: glFramebufferAttachmentParameterName; var &params: Int32)>(GetFramebufferParameterivMESA_adr);
    private ntv_GetFramebufferParameterivMESA_2 := GetProcOrNil&<procedure(target: glFramebufferTarget; pname: glFramebufferAttachmentParameterName; &params: IntPtr)>(GetFramebufferParameterivMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterivMESA(target: glFramebufferTarget; pname: glFramebufferAttachmentParameterName; var &params: Int32) :=
      ntv_GetFramebufferParameterivMESA_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterivMESA(target: glFramebufferTarget; pname: glFramebufferAttachmentParameterName; &params: IntPtr) :=
      ntv_GetFramebufferParameterivMESA_2(target, pname, &params);
    
  end;
  
  ///
  glFramebufferSwapXyMESA = static class
    public const _ExtStr = 'GL_MESA_framebuffer_swap_xy';
  end;
  
  ///
  glPackInvertMESA = static class
    public const _ExtStr = 'GL_MESA_pack_invert';
  end;
  
  ///
  glProgramBinaryFormatsMESA = static class
    public const _ExtStr = 'GL_MESA_program_binary_formats';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glResizeBuffersMESA = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_MESA_resize_buffers';
    
    private ResizeBuffersMESA_adr := GetProcAddress('glResizeBuffersMESA');
    private ntv_ResizeBuffersMESA_1 := GetProcOrNil&<procedure>(ResizeBuffersMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResizeBuffersMESA :=
      ntv_ResizeBuffersMESA_1;
    
  end;
  
  ///
  glShaderIntegerFunctionsMESA = static class
    public const _ExtStr = 'GL_MESA_shader_integer_functions';
  end;
  
  ///
  glTileRasterOrderMESA = static class
    public const _ExtStr = 'GL_MESA_tile_raster_order';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glWindowPosMESA = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_MESA_window_pos';
    
    private WindowPos2dMESA_adr := GetProcAddress('glWindowPos2dMESA');
    private ntv_WindowPos2dMESA_1 := GetProcOrNil&<procedure(x: double; y: double)>(WindowPos2dMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dMESA(x: double; y: double) :=
      ntv_WindowPos2dMESA_1(x, y);
    
    private WindowPos2dvMESA_adr := GetProcAddress('glWindowPos2dvMESA');
    private ntv_WindowPos2dvMESA_1 := GetProcOrNil&<procedure(var v: double)>(WindowPos2dvMESA_adr);
    private ntv_WindowPos2dvMESA_2 := GetProcOrNil&<procedure(var v: Vec2d)>(WindowPos2dvMESA_adr);
    private ntv_WindowPos2dvMESA_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos2dvMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvMESA(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos2dvMESA_1(v[0]) else
        ntv_WindowPos2dvMESA_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvMESA(var v: Vec2d) :=
      ntv_WindowPos2dvMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvMESA(var v: double) :=
      ntv_WindowPos2dvMESA_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvMESA(v: IntPtr) :=
      ntv_WindowPos2dvMESA_3(v);
    
    private WindowPos2fMESA_adr := GetProcAddress('glWindowPos2fMESA');
    private ntv_WindowPos2fMESA_1 := GetProcOrNil&<procedure(x: single; y: single)>(WindowPos2fMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fMESA(x: single; y: single) :=
      ntv_WindowPos2fMESA_1(x, y);
    
    private WindowPos2fvMESA_adr := GetProcAddress('glWindowPos2fvMESA');
    private ntv_WindowPos2fvMESA_1 := GetProcOrNil&<procedure(var v: single)>(WindowPos2fvMESA_adr);
    private ntv_WindowPos2fvMESA_2 := GetProcOrNil&<procedure(var v: Vec2f)>(WindowPos2fvMESA_adr);
    private ntv_WindowPos2fvMESA_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos2fvMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvMESA(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos2fvMESA_1(v[0]) else
        ntv_WindowPos2fvMESA_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvMESA(var v: Vec2f) :=
      ntv_WindowPos2fvMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvMESA(var v: single) :=
      ntv_WindowPos2fvMESA_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvMESA(v: IntPtr) :=
      ntv_WindowPos2fvMESA_3(v);
    
    private WindowPos2iMESA_adr := GetProcAddress('glWindowPos2iMESA');
    private ntv_WindowPos2iMESA_1 := GetProcOrNil&<procedure(x: Int32; y: Int32)>(WindowPos2iMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iMESA(x: Int32; y: Int32) :=
      ntv_WindowPos2iMESA_1(x, y);
    
    private WindowPos2ivMESA_adr := GetProcAddress('glWindowPos2ivMESA');
    private ntv_WindowPos2ivMESA_1 := GetProcOrNil&<procedure(var v: Int32)>(WindowPos2ivMESA_adr);
    private ntv_WindowPos2ivMESA_2 := GetProcOrNil&<procedure(var v: Vec2i)>(WindowPos2ivMESA_adr);
    private ntv_WindowPos2ivMESA_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos2ivMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivMESA(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos2ivMESA_1(v[0]) else
        ntv_WindowPos2ivMESA_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivMESA(var v: Vec2i) :=
      ntv_WindowPos2ivMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivMESA(var v: Int32) :=
      ntv_WindowPos2ivMESA_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivMESA(v: IntPtr) :=
      ntv_WindowPos2ivMESA_3(v);
    
    private WindowPos2sMESA_adr := GetProcAddress('glWindowPos2sMESA');
    private ntv_WindowPos2sMESA_1 := GetProcOrNil&<procedure(x: Int16; y: Int16)>(WindowPos2sMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sMESA(x: Int16; y: Int16) :=
      ntv_WindowPos2sMESA_1(x, y);
    
    private WindowPos2svMESA_adr := GetProcAddress('glWindowPos2svMESA');
    private ntv_WindowPos2svMESA_1 := GetProcOrNil&<procedure(var v: Int16)>(WindowPos2svMESA_adr);
    private ntv_WindowPos2svMESA_2 := GetProcOrNil&<procedure(var v: Vec2s)>(WindowPos2svMESA_adr);
    private ntv_WindowPos2svMESA_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos2svMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svMESA(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos2svMESA_1(v[0]) else
        ntv_WindowPos2svMESA_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svMESA(var v: Vec2s) :=
      ntv_WindowPos2svMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svMESA(var v: Int16) :=
      ntv_WindowPos2svMESA_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svMESA(v: IntPtr) :=
      ntv_WindowPos2svMESA_3(v);
    
    private WindowPos3dMESA_adr := GetProcAddress('glWindowPos3dMESA');
    private ntv_WindowPos3dMESA_1 := GetProcOrNil&<procedure(x: double; y: double; z: double)>(WindowPos3dMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dMESA(x: double; y: double; z: double) :=
      ntv_WindowPos3dMESA_1(x, y, z);
    
    private WindowPos3dvMESA_adr := GetProcAddress('glWindowPos3dvMESA');
    private ntv_WindowPos3dvMESA_1 := GetProcOrNil&<procedure(var v: double)>(WindowPos3dvMESA_adr);
    private ntv_WindowPos3dvMESA_2 := GetProcOrNil&<procedure(var v: Vec3d)>(WindowPos3dvMESA_adr);
    private ntv_WindowPos3dvMESA_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos3dvMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvMESA(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos3dvMESA_1(v[0]) else
        ntv_WindowPos3dvMESA_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvMESA(var v: Vec3d) :=
      ntv_WindowPos3dvMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvMESA(var v: double) :=
      ntv_WindowPos3dvMESA_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvMESA(v: IntPtr) :=
      ntv_WindowPos3dvMESA_3(v);
    
    private WindowPos3fMESA_adr := GetProcAddress('glWindowPos3fMESA');
    private ntv_WindowPos3fMESA_1 := GetProcOrNil&<procedure(x: single; y: single; z: single)>(WindowPos3fMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fMESA(x: single; y: single; z: single) :=
      ntv_WindowPos3fMESA_1(x, y, z);
    
    private WindowPos3fvMESA_adr := GetProcAddress('glWindowPos3fvMESA');
    private ntv_WindowPos3fvMESA_1 := GetProcOrNil&<procedure(var v: single)>(WindowPos3fvMESA_adr);
    private ntv_WindowPos3fvMESA_2 := GetProcOrNil&<procedure(var v: Vec3f)>(WindowPos3fvMESA_adr);
    private ntv_WindowPos3fvMESA_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos3fvMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvMESA(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos3fvMESA_1(v[0]) else
        ntv_WindowPos3fvMESA_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvMESA(var v: Vec3f) :=
      ntv_WindowPos3fvMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvMESA(var v: single) :=
      ntv_WindowPos3fvMESA_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvMESA(v: IntPtr) :=
      ntv_WindowPos3fvMESA_3(v);
    
    private WindowPos3iMESA_adr := GetProcAddress('glWindowPos3iMESA');
    private ntv_WindowPos3iMESA_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; z: Int32)>(WindowPos3iMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iMESA(x: Int32; y: Int32; z: Int32) :=
      ntv_WindowPos3iMESA_1(x, y, z);
    
    private WindowPos3ivMESA_adr := GetProcAddress('glWindowPos3ivMESA');
    private ntv_WindowPos3ivMESA_1 := GetProcOrNil&<procedure(var v: Int32)>(WindowPos3ivMESA_adr);
    private ntv_WindowPos3ivMESA_2 := GetProcOrNil&<procedure(var v: Vec3i)>(WindowPos3ivMESA_adr);
    private ntv_WindowPos3ivMESA_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos3ivMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivMESA(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos3ivMESA_1(v[0]) else
        ntv_WindowPos3ivMESA_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivMESA(var v: Vec3i) :=
      ntv_WindowPos3ivMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivMESA(var v: Int32) :=
      ntv_WindowPos3ivMESA_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivMESA(v: IntPtr) :=
      ntv_WindowPos3ivMESA_3(v);
    
    private WindowPos3sMESA_adr := GetProcAddress('glWindowPos3sMESA');
    private ntv_WindowPos3sMESA_1 := GetProcOrNil&<procedure(x: Int16; y: Int16; z: Int16)>(WindowPos3sMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sMESA(x: Int16; y: Int16; z: Int16) :=
      ntv_WindowPos3sMESA_1(x, y, z);
    
    private WindowPos3svMESA_adr := GetProcAddress('glWindowPos3svMESA');
    private ntv_WindowPos3svMESA_1 := GetProcOrNil&<procedure(var v: Int16)>(WindowPos3svMESA_adr);
    private ntv_WindowPos3svMESA_2 := GetProcOrNil&<procedure(var v: Vec3s)>(WindowPos3svMESA_adr);
    private ntv_WindowPos3svMESA_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos3svMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svMESA(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos3svMESA_1(v[0]) else
        ntv_WindowPos3svMESA_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svMESA(var v: Vec3s) :=
      ntv_WindowPos3svMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svMESA(var v: Int16) :=
      ntv_WindowPos3svMESA_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svMESA(v: IntPtr) :=
      ntv_WindowPos3svMESA_3(v);
    
    private WindowPos4dMESA_adr := GetProcAddress('glWindowPos4dMESA');
    private ntv_WindowPos4dMESA_1 := GetProcOrNil&<procedure(x: double; y: double; z: double; w: double)>(WindowPos4dMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4dMESA(x: double; y: double; z: double; w: double) :=
      ntv_WindowPos4dMESA_1(x, y, z, w);
    
    private WindowPos4dvMESA_adr := GetProcAddress('glWindowPos4dvMESA');
    private ntv_WindowPos4dvMESA_1 := GetProcOrNil&<procedure(var v: double)>(WindowPos4dvMESA_adr);
    private ntv_WindowPos4dvMESA_2 := GetProcOrNil&<procedure(var v: Vec4d)>(WindowPos4dvMESA_adr);
    private ntv_WindowPos4dvMESA_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos4dvMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4dvMESA(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos4dvMESA_1(v[0]) else
        ntv_WindowPos4dvMESA_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4dvMESA(var v: Vec4d) :=
      ntv_WindowPos4dvMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4dvMESA(var v: double) :=
      ntv_WindowPos4dvMESA_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4dvMESA(v: IntPtr) :=
      ntv_WindowPos4dvMESA_3(v);
    
    private WindowPos4fMESA_adr := GetProcAddress('glWindowPos4fMESA');
    private ntv_WindowPos4fMESA_1 := GetProcOrNil&<procedure(x: single; y: single; z: single; w: single)>(WindowPos4fMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4fMESA(x: single; y: single; z: single; w: single) :=
      ntv_WindowPos4fMESA_1(x, y, z, w);
    
    private WindowPos4fvMESA_adr := GetProcAddress('glWindowPos4fvMESA');
    private ntv_WindowPos4fvMESA_1 := GetProcOrNil&<procedure(var v: single)>(WindowPos4fvMESA_adr);
    private ntv_WindowPos4fvMESA_2 := GetProcOrNil&<procedure(var v: Vec4f)>(WindowPos4fvMESA_adr);
    private ntv_WindowPos4fvMESA_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos4fvMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4fvMESA(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos4fvMESA_1(v[0]) else
        ntv_WindowPos4fvMESA_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4fvMESA(var v: Vec4f) :=
      ntv_WindowPos4fvMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4fvMESA(var v: single) :=
      ntv_WindowPos4fvMESA_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4fvMESA(v: IntPtr) :=
      ntv_WindowPos4fvMESA_3(v);
    
    private WindowPos4iMESA_adr := GetProcAddress('glWindowPos4iMESA');
    private ntv_WindowPos4iMESA_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; z: Int32; w: Int32)>(WindowPos4iMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4iMESA(x: Int32; y: Int32; z: Int32; w: Int32) :=
      ntv_WindowPos4iMESA_1(x, y, z, w);
    
    private WindowPos4ivMESA_adr := GetProcAddress('glWindowPos4ivMESA');
    private ntv_WindowPos4ivMESA_1 := GetProcOrNil&<procedure(var v: Int32)>(WindowPos4ivMESA_adr);
    private ntv_WindowPos4ivMESA_2 := GetProcOrNil&<procedure(var v: Vec4i)>(WindowPos4ivMESA_adr);
    private ntv_WindowPos4ivMESA_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos4ivMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4ivMESA(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos4ivMESA_1(v[0]) else
        ntv_WindowPos4ivMESA_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4ivMESA(var v: Vec4i) :=
      ntv_WindowPos4ivMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4ivMESA(var v: Int32) :=
      ntv_WindowPos4ivMESA_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4ivMESA(v: IntPtr) :=
      ntv_WindowPos4ivMESA_3(v);
    
    private WindowPos4sMESA_adr := GetProcAddress('glWindowPos4sMESA');
    private ntv_WindowPos4sMESA_1 := GetProcOrNil&<procedure(x: Int16; y: Int16; z: Int16; w: Int16)>(WindowPos4sMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4sMESA(x: Int16; y: Int16; z: Int16; w: Int16) :=
      ntv_WindowPos4sMESA_1(x, y, z, w);
    
    private WindowPos4svMESA_adr := GetProcAddress('glWindowPos4svMESA');
    private ntv_WindowPos4svMESA_1 := GetProcOrNil&<procedure(var v: Int16)>(WindowPos4svMESA_adr);
    private ntv_WindowPos4svMESA_2 := GetProcOrNil&<procedure(var v: Vec4s)>(WindowPos4svMESA_adr);
    private ntv_WindowPos4svMESA_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos4svMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4svMESA(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos4svMESA_1(v[0]) else
        ntv_WindowPos4svMESA_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4svMESA(var v: Vec4s) :=
      ntv_WindowPos4svMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4svMESA(var v: Int16) :=
      ntv_WindowPos4svMESA_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4svMESA(v: IntPtr) :=
      ntv_WindowPos4svMESA_3(v);
    
  end;
  
  ///
  glYcbcrTextureMESA = static class
    public const _ExtStr = 'GL_MESA_ycbcr_texture';
  end;
  
  ///
  glTextureStackMESAX = static class
    public const _ExtStr = 'GL_MESAX_texture_stack';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glAlphaToCoverageDitherControlNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_alpha_to_coverage_dither_control';
    
    private AlphaToCoverageDitherControlNV_adr := GetProcAddress('glAlphaToCoverageDitherControlNV');
    private ntv_AlphaToCoverageDitherControlNV_1 := GetProcOrNil&<procedure(mode: DummyEnum)>(AlphaToCoverageDitherControlNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaToCoverageDitherControlNV(mode: DummyEnum) :=
      ntv_AlphaToCoverageDitherControlNV_1(mode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glBindlessMultiDrawIndirectNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_bindless_multi_draw_indirect';
    
    private MultiDrawArraysIndirectBindlessNV_adr := GetProcAddress('glMultiDrawArraysIndirectBindlessNV');
    private ntv_MultiDrawArraysIndirectBindlessNV_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; indirect: IntPtr; drawCount: Int32; stride: Int32; vertexBufferCount: Int32)>(MultiDrawArraysIndirectBindlessNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectBindlessNV(mode: glPrimitiveType; indirect: IntPtr; drawCount: Int32; stride: Int32; vertexBufferCount: Int32) :=
      ntv_MultiDrawArraysIndirectBindlessNV_1(mode, indirect, drawCount, stride, vertexBufferCount);
    
    private MultiDrawElementsIndirectBindlessNV_adr := GetProcAddress('glMultiDrawElementsIndirectBindlessNV');
    private ntv_MultiDrawElementsIndirectBindlessNV_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr; drawCount: Int32; stride: Int32; vertexBufferCount: Int32)>(MultiDrawElementsIndirectBindlessNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectBindlessNV(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr; drawCount: Int32; stride: Int32; vertexBufferCount: Int32) :=
      ntv_MultiDrawElementsIndirectBindlessNV_1(mode, &type, indirect, drawCount, stride, vertexBufferCount);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glBindlessMultiDrawIndirectCountNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_bindless_multi_draw_indirect_count';
    
    private MultiDrawArraysIndirectBindlessCountNV_adr := GetProcAddress('glMultiDrawArraysIndirectBindlessCountNV');
    private ntv_MultiDrawArraysIndirectBindlessCountNV_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; indirect: IntPtr; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32)>(MultiDrawArraysIndirectBindlessCountNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectBindlessCountNV(mode: glPrimitiveType; indirect: IntPtr; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32) :=
      ntv_MultiDrawArraysIndirectBindlessCountNV_1(mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
    
    private MultiDrawElementsIndirectBindlessCountNV_adr := GetProcAddress('glMultiDrawElementsIndirectBindlessCountNV');
    private ntv_MultiDrawElementsIndirectBindlessCountNV_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32)>(MultiDrawElementsIndirectBindlessCountNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectBindlessCountNV(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32) :=
      ntv_MultiDrawElementsIndirectBindlessCountNV_1(mode, &type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glBindlessTextureNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_bindless_texture';
    
    private GetTextureHandleNV_adr := GetProcAddress('glGetTextureHandleNV');
    private ntv_GetTextureHandleNV_1 := GetProcOrNil&<function(texture: gl_texture): UInt64>(GetTextureHandleNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTextureHandleNV(texture: gl_texture): UInt64 :=
      ntv_GetTextureHandleNV_1(texture);
    
    private GetTextureSamplerHandleNV_adr := GetProcAddress('glGetTextureSamplerHandleNV');
    private ntv_GetTextureSamplerHandleNV_1 := GetProcOrNil&<function(texture: gl_texture; sampler: gl_sampler): UInt64>(GetTextureSamplerHandleNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTextureSamplerHandleNV(texture: gl_texture; sampler: gl_sampler): UInt64 :=
      ntv_GetTextureSamplerHandleNV_1(texture, sampler);
    
    private MakeTextureHandleResidentNV_adr := GetProcAddress('glMakeTextureHandleResidentNV');
    private ntv_MakeTextureHandleResidentNV_1 := GetProcOrNil&<procedure(handle: UInt64)>(MakeTextureHandleResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeTextureHandleResidentNV(handle: UInt64) :=
      ntv_MakeTextureHandleResidentNV_1(handle);
    
    private MakeTextureHandleNonResidentNV_adr := GetProcAddress('glMakeTextureHandleNonResidentNV');
    private ntv_MakeTextureHandleNonResidentNV_1 := GetProcOrNil&<procedure(handle: UInt64)>(MakeTextureHandleNonResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeTextureHandleNonResidentNV(handle: UInt64) :=
      ntv_MakeTextureHandleNonResidentNV_1(handle);
    
    private GetImageHandleNV_adr := GetProcAddress('glGetImageHandleNV');
    private ntv_GetImageHandleNV_1 := GetProcOrNil&<function(texture: gl_texture; level: Int32; layered: glBool8; layer: Int32; format: glPixelFormat): UInt64>(GetImageHandleNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageHandleNV(texture: gl_texture; level: Int32; layered: glBool8; layer: Int32; format: glPixelFormat): UInt64 :=
      ntv_GetImageHandleNV_1(texture, level, layered, layer, format);
    
    private MakeImageHandleResidentNV_adr := GetProcAddress('glMakeImageHandleResidentNV');
    private ntv_MakeImageHandleResidentNV_1 := GetProcOrNil&<procedure(handle: UInt64; access: DummyEnum)>(MakeImageHandleResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeImageHandleResidentNV(handle: UInt64; access: DummyEnum) :=
      ntv_MakeImageHandleResidentNV_1(handle, access);
    
    private MakeImageHandleNonResidentNV_adr := GetProcAddress('glMakeImageHandleNonResidentNV');
    private ntv_MakeImageHandleNonResidentNV_1 := GetProcOrNil&<procedure(handle: UInt64)>(MakeImageHandleNonResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeImageHandleNonResidentNV(handle: UInt64) :=
      ntv_MakeImageHandleNonResidentNV_1(handle);
    
    private UniformHandleui64NV_adr := GetProcAddress('glUniformHandleui64NV');
    private ntv_UniformHandleui64NV_1 := GetProcOrNil&<procedure(location: Int32; value: UInt64)>(UniformHandleui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64NV(location: Int32; value: UInt64) :=
      ntv_UniformHandleui64NV_1(location, value);
    
    private UniformHandleui64vNV_adr := GetProcAddress('glUniformHandleui64vNV');
    private ntv_UniformHandleui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(UniformHandleui64vNV_adr);
    private ntv_UniformHandleui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(UniformHandleui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformHandleui64vNV_1(location, count, value[0]) else
        ntv_UniformHandleui64vNV_1(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vNV(location: Int32; count: Int32; var value: UInt64) :=
      ntv_UniformHandleui64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_UniformHandleui64vNV_2(location, count, value);
    
    private ProgramUniformHandleui64NV_adr := GetProcAddress('glProgramUniformHandleui64NV');
    private ntv_ProgramUniformHandleui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; value: UInt64)>(ProgramUniformHandleui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64NV(&program: gl_program; location: Int32; value: UInt64) :=
      ntv_ProgramUniformHandleui64NV_1(&program, location, value);
    
    private ProgramUniformHandleui64vNV_adr := GetProcAddress('glProgramUniformHandleui64vNV');
    private ntv_ProgramUniformHandleui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var values: UInt64)>(ProgramUniformHandleui64vNV_adr);
    private ntv_ProgramUniformHandleui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; values: IntPtr)>(ProgramUniformHandleui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vNV(&program: gl_program; location: Int32; count: Int32; values: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (values<>nil) and (values.Length<>0) then
        ntv_ProgramUniformHandleui64vNV_1(&program, location, count, values[0]) else
        ntv_ProgramUniformHandleui64vNV_1(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vNV(&program: gl_program; location: Int32; count: Int32; var values: UInt64) :=
      ntv_ProgramUniformHandleui64vNV_1(&program, location, count, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vNV(&program: gl_program; location: Int32; count: Int32; values: IntPtr) :=
      ntv_ProgramUniformHandleui64vNV_2(&program, location, count, values);
    
    private IsTextureHandleResidentNV_adr := GetProcAddress('glIsTextureHandleResidentNV');
    private ntv_IsTextureHandleResidentNV_1 := GetProcOrNil&<function(handle: UInt64): glBool8>(IsTextureHandleResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTextureHandleResidentNV(handle: UInt64): glBool8 :=
      ntv_IsTextureHandleResidentNV_1(handle);
    
    private IsImageHandleResidentNV_adr := GetProcAddress('glIsImageHandleResidentNV');
    private ntv_IsImageHandleResidentNV_1 := GetProcOrNil&<function(handle: UInt64): glBool8>(IsImageHandleResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsImageHandleResidentNV(handle: UInt64): glBool8 :=
      ntv_IsImageHandleResidentNV_1(handle);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glBlendEquationAdvancedNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_blend_equation_advanced';
    
    private BlendParameteriNV_adr := GetProcAddress('glBlendParameteriNV');
    private ntv_BlendParameteriNV_1 := GetProcOrNil&<procedure(pname: DummyEnum; value: Int32)>(BlendParameteriNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendParameteriNV(pname: DummyEnum; value: Int32) :=
      ntv_BlendParameteriNV_1(pname, value);
    
    private BlendBarrierNV_adr := GetProcAddress('glBlendBarrierNV');
    private ntv_BlendBarrierNV_1 := GetProcOrNil&<procedure>(BlendBarrierNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendBarrierNV :=
      ntv_BlendBarrierNV_1;
    
  end;
  
  ///
  glBlendEquationAdvancedCoherentNV = static class
    public const _ExtStr = 'GL_NV_blend_equation_advanced_coherent';
  end;
  
  ///
  glBlendMinmaxFactorNV = static class
    public const _ExtStr = 'GL_NV_blend_minmax_factor';
  end;
  
  ///
  glBlendSquareNV = static class
    public const _ExtStr = 'GL_NV_blend_square';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glClipSpaceWScalingNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_clip_space_w_scaling';
    
    private ViewportPositionWScaleNV_adr := GetProcAddress('glViewportPositionWScaleNV');
    private ntv_ViewportPositionWScaleNV_1 := GetProcOrNil&<procedure(index: UInt32; xcoeff: single; ycoeff: single)>(ViewportPositionWScaleNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportPositionWScaleNV(index: UInt32; xcoeff: single; ycoeff: single) :=
      ntv_ViewportPositionWScaleNV_1(index, xcoeff, ycoeff);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glCommandListNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_command_list';
    
    private CreateStatesNV_adr := GetProcAddress('glCreateStatesNV');
    private ntv_CreateStatesNV_1 := GetProcOrNil&<procedure(n: Int32; var states: UInt32)>(CreateStatesNV_adr);
    private ntv_CreateStatesNV_2 := GetProcOrNil&<procedure(n: Int32; states: IntPtr)>(CreateStatesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateStatesNV(n: Int32; states: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (states<>nil) and (states.Length<>0) then
        ntv_CreateStatesNV_1(n, states[0]) else
        ntv_CreateStatesNV_1(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateStatesNV(n: Int32; var states: UInt32) :=
      ntv_CreateStatesNV_1(n, states);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateStatesNV(n: Int32; states: IntPtr) :=
      ntv_CreateStatesNV_2(n, states);
    
    private DeleteStatesNV_adr := GetProcAddress('glDeleteStatesNV');
    private ntv_DeleteStatesNV_1 := GetProcOrNil&<procedure(n: Int32; var states: UInt32)>(DeleteStatesNV_adr);
    private ntv_DeleteStatesNV_2 := GetProcOrNil&<procedure(n: Int32; states: IntPtr)>(DeleteStatesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteStatesNV(n: Int32; states: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (states<>nil) and (states.Length<>0) then
        ntv_DeleteStatesNV_1(n, states[0]) else
        ntv_DeleteStatesNV_1(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteStatesNV(n: Int32; var states: UInt32) :=
      ntv_DeleteStatesNV_1(n, states);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteStatesNV(n: Int32; states: IntPtr) :=
      ntv_DeleteStatesNV_2(n, states);
    
    private IsStateNV_adr := GetProcAddress('glIsStateNV');
    private ntv_IsStateNV_1 := GetProcOrNil&<function(state: UInt32): glBool8>(IsStateNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsStateNV(state: UInt32): glBool8 :=
      ntv_IsStateNV_1(state);
    
    private StateCaptureNV_adr := GetProcAddress('glStateCaptureNV');
    private ntv_StateCaptureNV_1 := GetProcOrNil&<procedure(state: UInt32; mode: DummyEnum)>(StateCaptureNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StateCaptureNV(state: UInt32; mode: DummyEnum) :=
      ntv_StateCaptureNV_1(state, mode);
    
    private GetCommandHeaderNV_adr := GetProcAddress('glGetCommandHeaderNV');
    private ntv_GetCommandHeaderNV_1 := GetProcOrNil&<function(tokenID: glCommandOpcodes; size: UInt32): UInt32>(GetCommandHeaderNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCommandHeaderNV(tokenID: glCommandOpcodes; size: UInt32): UInt32 :=
      ntv_GetCommandHeaderNV_1(tokenID, size);
    
    private GetStageIndexNV_adr := GetProcAddress('glGetStageIndexNV');
    private ntv_GetStageIndexNV_1 := GetProcOrNil&<function(shadertype: glShaderType): UInt16>(GetStageIndexNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetStageIndexNV(shadertype: glShaderType): UInt16 :=
      ntv_GetStageIndexNV_1(shadertype);
    
    private DrawCommandsNV_adr := GetProcAddress('glDrawCommandsNV');
    private ntv_DrawCommandsNV_1 := GetProcOrNil&<procedure(primitiveMode: DummyEnum; buffer: UInt32; var indirects: IntPtr; var sizes: Int32; count: UInt32)>(DrawCommandsNV_adr);
    private ntv_DrawCommandsNV_2 := GetProcOrNil&<procedure(primitiveMode: DummyEnum; buffer: UInt32; var indirects: IntPtr; sizes: IntPtr; count: UInt32)>(DrawCommandsNV_adr);
    private ntv_DrawCommandsNV_3 := GetProcOrNil&<procedure(primitiveMode: DummyEnum; buffer: UInt32; indirects: pointer; var sizes: Int32; count: UInt32)>(DrawCommandsNV_adr);
    private ntv_DrawCommandsNV_4 := GetProcOrNil&<procedure(primitiveMode: DummyEnum; buffer: UInt32; indirects: pointer; sizes: IntPtr; count: UInt32)>(DrawCommandsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; count: UInt32);
    type PIntPtr = ^IntPtr;
    type PInt32 = ^Int32;
    begin
      if (indirects<>nil) and (indirects.Length<>0) then
        if (sizes<>nil) and (sizes.Length<>0) then
          ntv_DrawCommandsNV_1(primitiveMode, buffer, indirects[0], sizes[0], count) else
          ntv_DrawCommandsNV_1(primitiveMode, buffer, indirects[0], PInt32(nil)^, count) else
        if (sizes<>nil) and (sizes.Length<>0) then
          ntv_DrawCommandsNV_1(primitiveMode, buffer, PIntPtr(nil)^, sizes[0], count) else
          ntv_DrawCommandsNV_1(primitiveMode, buffer, PIntPtr(nil)^, PInt32(nil)^, count);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; var indirects: IntPtr; var sizes: Int32; count: UInt32) :=
      ntv_DrawCommandsNV_1(primitiveMode, buffer, indirects, sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; var indirects: IntPtr; sizes: IntPtr; count: UInt32) :=
      ntv_DrawCommandsNV_2(primitiveMode, buffer, indirects, sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: pointer; var sizes: Int32; count: UInt32) :=
      ntv_DrawCommandsNV_3(primitiveMode, buffer, indirects, sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: pointer; sizes: IntPtr; count: UInt32) :=
      ntv_DrawCommandsNV_4(primitiveMode, buffer, indirects, sizes, count);
    
    private DrawCommandsAddressNV_adr := GetProcAddress('glDrawCommandsAddressNV');
    private ntv_DrawCommandsAddressNV_1 := GetProcOrNil&<procedure(primitiveMode: DummyEnum; var indirects: UInt64; var sizes: Int32; count: UInt32)>(DrawCommandsAddressNV_adr);
    private ntv_DrawCommandsAddressNV_2 := GetProcOrNil&<procedure(primitiveMode: DummyEnum; var indirects: UInt64; sizes: IntPtr; count: UInt32)>(DrawCommandsAddressNV_adr);
    private ntv_DrawCommandsAddressNV_3 := GetProcOrNil&<procedure(primitiveMode: DummyEnum; indirects: IntPtr; var sizes: Int32; count: UInt32)>(DrawCommandsAddressNV_adr);
    private ntv_DrawCommandsAddressNV_4 := GetProcOrNil&<procedure(primitiveMode: DummyEnum; indirects: IntPtr; sizes: IntPtr; count: UInt32)>(DrawCommandsAddressNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: array of UInt64; sizes: array of Int32; count: UInt32);
    type PUInt64 = ^UInt64;
    type PInt32 = ^Int32;
    begin
      if (indirects<>nil) and (indirects.Length<>0) then
        if (sizes<>nil) and (sizes.Length<>0) then
          ntv_DrawCommandsAddressNV_1(primitiveMode, indirects[0], sizes[0], count) else
          ntv_DrawCommandsAddressNV_1(primitiveMode, indirects[0], PInt32(nil)^, count) else
        if (sizes<>nil) and (sizes.Length<>0) then
          ntv_DrawCommandsAddressNV_1(primitiveMode, PUInt64(nil)^, sizes[0], count) else
          ntv_DrawCommandsAddressNV_1(primitiveMode, PUInt64(nil)^, PInt32(nil)^, count);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; var indirects: UInt64; var sizes: Int32; count: UInt32) :=
      ntv_DrawCommandsAddressNV_1(primitiveMode, indirects, sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; var indirects: UInt64; sizes: IntPtr; count: UInt32) :=
      ntv_DrawCommandsAddressNV_2(primitiveMode, indirects, sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: IntPtr; var sizes: Int32; count: UInt32) :=
      ntv_DrawCommandsAddressNV_3(primitiveMode, indirects, sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: IntPtr; sizes: IntPtr; count: UInt32) :=
      ntv_DrawCommandsAddressNV_4(primitiveMode, indirects, sizes, count);
    
    private DrawCommandsStatesNV_adr := GetProcAddress('glDrawCommandsStatesNV');
    private ntv_DrawCommandsStatesNV_1 := GetProcOrNil&<procedure(buffer: gl_buffer; var indirects: IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32)>(DrawCommandsStatesNV_adr);
    private ntv_DrawCommandsStatesNV_2 := GetProcOrNil&<procedure(buffer: gl_buffer; var indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32)>(DrawCommandsStatesNV_adr);
    private ntv_DrawCommandsStatesNV_3 := GetProcOrNil&<procedure(buffer: gl_buffer; var indirects: IntPtr; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32)>(DrawCommandsStatesNV_adr);
    private ntv_DrawCommandsStatesNV_4 := GetProcOrNil&<procedure(buffer: gl_buffer; var indirects: IntPtr; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32)>(DrawCommandsStatesNV_adr);
    private ntv_DrawCommandsStatesNV_5 := GetProcOrNil&<procedure(buffer: gl_buffer; var indirects: IntPtr; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32)>(DrawCommandsStatesNV_adr);
    private ntv_DrawCommandsStatesNV_6 := GetProcOrNil&<procedure(buffer: gl_buffer; var indirects: IntPtr; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32)>(DrawCommandsStatesNV_adr);
    private ntv_DrawCommandsStatesNV_7 := GetProcOrNil&<procedure(buffer: gl_buffer; var indirects: IntPtr; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32)>(DrawCommandsStatesNV_adr);
    private ntv_DrawCommandsStatesNV_8 := GetProcOrNil&<procedure(buffer: gl_buffer; var indirects: IntPtr; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32)>(DrawCommandsStatesNV_adr);
    private ntv_DrawCommandsStatesNV_9 := GetProcOrNil&<procedure(buffer: gl_buffer; indirects: pointer; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32)>(DrawCommandsStatesNV_adr);
    private ntv_DrawCommandsStatesNV_10 := GetProcOrNil&<procedure(buffer: gl_buffer; indirects: pointer; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32)>(DrawCommandsStatesNV_adr);
    private ntv_DrawCommandsStatesNV_11 := GetProcOrNil&<procedure(buffer: gl_buffer; indirects: pointer; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32)>(DrawCommandsStatesNV_adr);
    private ntv_DrawCommandsStatesNV_12 := GetProcOrNil&<procedure(buffer: gl_buffer; indirects: pointer; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32)>(DrawCommandsStatesNV_adr);
    private ntv_DrawCommandsStatesNV_13 := GetProcOrNil&<procedure(buffer: gl_buffer; indirects: pointer; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32)>(DrawCommandsStatesNV_adr);
    private ntv_DrawCommandsStatesNV_14 := GetProcOrNil&<procedure(buffer: gl_buffer; indirects: pointer; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32)>(DrawCommandsStatesNV_adr);
    private ntv_DrawCommandsStatesNV_15 := GetProcOrNil&<procedure(buffer: gl_buffer; indirects: pointer; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32)>(DrawCommandsStatesNV_adr);
    private ntv_DrawCommandsStatesNV_16 := GetProcOrNil&<procedure(buffer: gl_buffer; indirects: pointer; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32)>(DrawCommandsStatesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: array of IntPtr; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32);
    type PIntPtr = ^IntPtr;
    type PInt32 = ^Int32;
    type PUInt32 = ^UInt32;
    begin
      if (sizes<>nil) and (sizes.Length<>0) then
        if (indirects<>nil) and (indirects.Length<>0) then
          if (fbos<>nil) and (fbos.Length<>0) then
            if (states<>nil) and (states.Length<>0) then
              ntv_DrawCommandsStatesNV_1(buffer, indirects[0], sizes[0], states[0], fbos[0], count) else
              ntv_DrawCommandsStatesNV_1(buffer, indirects[0], sizes[0], PUInt32(nil)^, fbos[0], count) else
            if (states<>nil) and (states.Length<>0) then
              ntv_DrawCommandsStatesNV_1(buffer, indirects[0], sizes[0], states[0], PUInt32(nil)^, count) else
              ntv_DrawCommandsStatesNV_1(buffer, indirects[0], sizes[0], PUInt32(nil)^, PUInt32(nil)^, count) else
          if (fbos<>nil) and (fbos.Length<>0) then
            if (states<>nil) and (states.Length<>0) then
              ntv_DrawCommandsStatesNV_1(buffer, PIntPtr(nil)^, sizes[0], states[0], fbos[0], count) else
              ntv_DrawCommandsStatesNV_1(buffer, PIntPtr(nil)^, sizes[0], PUInt32(nil)^, fbos[0], count) else
            if (states<>nil) and (states.Length<>0) then
              ntv_DrawCommandsStatesNV_1(buffer, PIntPtr(nil)^, sizes[0], states[0], PUInt32(nil)^, count) else
              ntv_DrawCommandsStatesNV_1(buffer, PIntPtr(nil)^, sizes[0], PUInt32(nil)^, PUInt32(nil)^, count) else
        if (indirects<>nil) and (indirects.Length<>0) then
          if (fbos<>nil) and (fbos.Length<>0) then
            if (states<>nil) and (states.Length<>0) then
              ntv_DrawCommandsStatesNV_1(buffer, indirects[0], PInt32(nil)^, states[0], fbos[0], count) else
              ntv_DrawCommandsStatesNV_1(buffer, indirects[0], PInt32(nil)^, PUInt32(nil)^, fbos[0], count) else
            if (states<>nil) and (states.Length<>0) then
              ntv_DrawCommandsStatesNV_1(buffer, indirects[0], PInt32(nil)^, states[0], PUInt32(nil)^, count) else
              ntv_DrawCommandsStatesNV_1(buffer, indirects[0], PInt32(nil)^, PUInt32(nil)^, PUInt32(nil)^, count) else
          if (fbos<>nil) and (fbos.Length<>0) then
            if (states<>nil) and (states.Length<>0) then
              ntv_DrawCommandsStatesNV_1(buffer, PIntPtr(nil)^, PInt32(nil)^, states[0], fbos[0], count) else
              ntv_DrawCommandsStatesNV_1(buffer, PIntPtr(nil)^, PInt32(nil)^, PUInt32(nil)^, fbos[0], count) else
            if (states<>nil) and (states.Length<>0) then
              ntv_DrawCommandsStatesNV_1(buffer, PIntPtr(nil)^, PInt32(nil)^, states[0], PUInt32(nil)^, count) else
              ntv_DrawCommandsStatesNV_1(buffer, PIntPtr(nil)^, PInt32(nil)^, PUInt32(nil)^, PUInt32(nil)^, count);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; var indirects: IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) :=
      ntv_DrawCommandsStatesNV_1(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; var indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32) :=
      ntv_DrawCommandsStatesNV_2(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; var indirects: IntPtr; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32) :=
      ntv_DrawCommandsStatesNV_3(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; var indirects: IntPtr; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32) :=
      ntv_DrawCommandsStatesNV_4(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; var indirects: IntPtr; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32) :=
      ntv_DrawCommandsStatesNV_5(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; var indirects: IntPtr; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32) :=
      ntv_DrawCommandsStatesNV_6(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; var indirects: IntPtr; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32) :=
      ntv_DrawCommandsStatesNV_7(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; var indirects: IntPtr; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32) :=
      ntv_DrawCommandsStatesNV_8(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: pointer; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) :=
      ntv_DrawCommandsStatesNV_9(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: pointer; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32) :=
      ntv_DrawCommandsStatesNV_10(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: pointer; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32) :=
      ntv_DrawCommandsStatesNV_11(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: pointer; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32) :=
      ntv_DrawCommandsStatesNV_12(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: pointer; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32) :=
      ntv_DrawCommandsStatesNV_13(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: pointer; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32) :=
      ntv_DrawCommandsStatesNV_14(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: pointer; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32) :=
      ntv_DrawCommandsStatesNV_15(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: pointer; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32) :=
      ntv_DrawCommandsStatesNV_16(buffer, indirects, sizes, states, fbos, count);
    
    private DrawCommandsStatesAddressNV_adr := GetProcAddress('glDrawCommandsStatesAddressNV');
    private ntv_DrawCommandsStatesAddressNV_1 := GetProcOrNil&<procedure(var indirects: UInt64; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32)>(DrawCommandsStatesAddressNV_adr);
    private ntv_DrawCommandsStatesAddressNV_2 := GetProcOrNil&<procedure(var indirects: UInt64; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32)>(DrawCommandsStatesAddressNV_adr);
    private ntv_DrawCommandsStatesAddressNV_3 := GetProcOrNil&<procedure(var indirects: UInt64; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32)>(DrawCommandsStatesAddressNV_adr);
    private ntv_DrawCommandsStatesAddressNV_4 := GetProcOrNil&<procedure(var indirects: UInt64; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32)>(DrawCommandsStatesAddressNV_adr);
    private ntv_DrawCommandsStatesAddressNV_5 := GetProcOrNil&<procedure(var indirects: UInt64; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32)>(DrawCommandsStatesAddressNV_adr);
    private ntv_DrawCommandsStatesAddressNV_6 := GetProcOrNil&<procedure(var indirects: UInt64; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32)>(DrawCommandsStatesAddressNV_adr);
    private ntv_DrawCommandsStatesAddressNV_7 := GetProcOrNil&<procedure(var indirects: UInt64; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32)>(DrawCommandsStatesAddressNV_adr);
    private ntv_DrawCommandsStatesAddressNV_8 := GetProcOrNil&<procedure(var indirects: UInt64; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32)>(DrawCommandsStatesAddressNV_adr);
    private ntv_DrawCommandsStatesAddressNV_9 := GetProcOrNil&<procedure(indirects: IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32)>(DrawCommandsStatesAddressNV_adr);
    private ntv_DrawCommandsStatesAddressNV_10 := GetProcOrNil&<procedure(indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32)>(DrawCommandsStatesAddressNV_adr);
    private ntv_DrawCommandsStatesAddressNV_11 := GetProcOrNil&<procedure(indirects: IntPtr; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32)>(DrawCommandsStatesAddressNV_adr);
    private ntv_DrawCommandsStatesAddressNV_12 := GetProcOrNil&<procedure(indirects: IntPtr; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32)>(DrawCommandsStatesAddressNV_adr);
    private ntv_DrawCommandsStatesAddressNV_13 := GetProcOrNil&<procedure(indirects: IntPtr; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32)>(DrawCommandsStatesAddressNV_adr);
    private ntv_DrawCommandsStatesAddressNV_14 := GetProcOrNil&<procedure(indirects: IntPtr; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32)>(DrawCommandsStatesAddressNV_adr);
    private ntv_DrawCommandsStatesAddressNV_15 := GetProcOrNil&<procedure(indirects: IntPtr; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32)>(DrawCommandsStatesAddressNV_adr);
    private ntv_DrawCommandsStatesAddressNV_16 := GetProcOrNil&<procedure(indirects: IntPtr; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32)>(DrawCommandsStatesAddressNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32);
    type PUInt64 = ^UInt64;
    type PInt32 = ^Int32;
    type PUInt32 = ^UInt32;
    begin
      if (sizes<>nil) and (sizes.Length<>0) then
        if (indirects<>nil) and (indirects.Length<>0) then
          if (fbos<>nil) and (fbos.Length<>0) then
            if (states<>nil) and (states.Length<>0) then
              ntv_DrawCommandsStatesAddressNV_1(indirects[0], sizes[0], states[0], fbos[0], count) else
              ntv_DrawCommandsStatesAddressNV_1(indirects[0], sizes[0], PUInt32(nil)^, fbos[0], count) else
            if (states<>nil) and (states.Length<>0) then
              ntv_DrawCommandsStatesAddressNV_1(indirects[0], sizes[0], states[0], PUInt32(nil)^, count) else
              ntv_DrawCommandsStatesAddressNV_1(indirects[0], sizes[0], PUInt32(nil)^, PUInt32(nil)^, count) else
          if (fbos<>nil) and (fbos.Length<>0) then
            if (states<>nil) and (states.Length<>0) then
              ntv_DrawCommandsStatesAddressNV_1(PUInt64(nil)^, sizes[0], states[0], fbos[0], count) else
              ntv_DrawCommandsStatesAddressNV_1(PUInt64(nil)^, sizes[0], PUInt32(nil)^, fbos[0], count) else
            if (states<>nil) and (states.Length<>0) then
              ntv_DrawCommandsStatesAddressNV_1(PUInt64(nil)^, sizes[0], states[0], PUInt32(nil)^, count) else
              ntv_DrawCommandsStatesAddressNV_1(PUInt64(nil)^, sizes[0], PUInt32(nil)^, PUInt32(nil)^, count) else
        if (indirects<>nil) and (indirects.Length<>0) then
          if (fbos<>nil) and (fbos.Length<>0) then
            if (states<>nil) and (states.Length<>0) then
              ntv_DrawCommandsStatesAddressNV_1(indirects[0], PInt32(nil)^, states[0], fbos[0], count) else
              ntv_DrawCommandsStatesAddressNV_1(indirects[0], PInt32(nil)^, PUInt32(nil)^, fbos[0], count) else
            if (states<>nil) and (states.Length<>0) then
              ntv_DrawCommandsStatesAddressNV_1(indirects[0], PInt32(nil)^, states[0], PUInt32(nil)^, count) else
              ntv_DrawCommandsStatesAddressNV_1(indirects[0], PInt32(nil)^, PUInt32(nil)^, PUInt32(nil)^, count) else
          if (fbos<>nil) and (fbos.Length<>0) then
            if (states<>nil) and (states.Length<>0) then
              ntv_DrawCommandsStatesAddressNV_1(PUInt64(nil)^, PInt32(nil)^, states[0], fbos[0], count) else
              ntv_DrawCommandsStatesAddressNV_1(PUInt64(nil)^, PInt32(nil)^, PUInt32(nil)^, fbos[0], count) else
            if (states<>nil) and (states.Length<>0) then
              ntv_DrawCommandsStatesAddressNV_1(PUInt64(nil)^, PInt32(nil)^, states[0], PUInt32(nil)^, count) else
              ntv_DrawCommandsStatesAddressNV_1(PUInt64(nil)^, PInt32(nil)^, PUInt32(nil)^, PUInt32(nil)^, count);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) :=
      ntv_DrawCommandsStatesAddressNV_1(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32) :=
      ntv_DrawCommandsStatesAddressNV_2(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32) :=
      ntv_DrawCommandsStatesAddressNV_3(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32) :=
      ntv_DrawCommandsStatesAddressNV_4(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32) :=
      ntv_DrawCommandsStatesAddressNV_5(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32) :=
      ntv_DrawCommandsStatesAddressNV_6(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32) :=
      ntv_DrawCommandsStatesAddressNV_7(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32) :=
      ntv_DrawCommandsStatesAddressNV_8(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) :=
      ntv_DrawCommandsStatesAddressNV_9(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32) :=
      ntv_DrawCommandsStatesAddressNV_10(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: IntPtr; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32) :=
      ntv_DrawCommandsStatesAddressNV_11(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: IntPtr; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32) :=
      ntv_DrawCommandsStatesAddressNV_12(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: IntPtr; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32) :=
      ntv_DrawCommandsStatesAddressNV_13(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: IntPtr; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32) :=
      ntv_DrawCommandsStatesAddressNV_14(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: IntPtr; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32) :=
      ntv_DrawCommandsStatesAddressNV_15(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: IntPtr; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32) :=
      ntv_DrawCommandsStatesAddressNV_16(indirects, sizes, states, fbos, count);
    
    private CreateCommandListsNV_adr := GetProcAddress('glCreateCommandListsNV');
    private ntv_CreateCommandListsNV_1 := GetProcOrNil&<procedure(n: Int32; var lists: UInt32)>(CreateCommandListsNV_adr);
    private ntv_CreateCommandListsNV_2 := GetProcOrNil&<procedure(n: Int32; lists: IntPtr)>(CreateCommandListsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateCommandListsNV(n: Int32; lists: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (lists<>nil) and (lists.Length<>0) then
        ntv_CreateCommandListsNV_1(n, lists[0]) else
        ntv_CreateCommandListsNV_1(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateCommandListsNV(n: Int32; var lists: UInt32) :=
      ntv_CreateCommandListsNV_1(n, lists);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateCommandListsNV(n: Int32; lists: IntPtr) :=
      ntv_CreateCommandListsNV_2(n, lists);
    
    private DeleteCommandListsNV_adr := GetProcAddress('glDeleteCommandListsNV');
    private ntv_DeleteCommandListsNV_1 := GetProcOrNil&<procedure(n: Int32; var lists: UInt32)>(DeleteCommandListsNV_adr);
    private ntv_DeleteCommandListsNV_2 := GetProcOrNil&<procedure(n: Int32; lists: IntPtr)>(DeleteCommandListsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteCommandListsNV(n: Int32; lists: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (lists<>nil) and (lists.Length<>0) then
        ntv_DeleteCommandListsNV_1(n, lists[0]) else
        ntv_DeleteCommandListsNV_1(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteCommandListsNV(n: Int32; var lists: UInt32) :=
      ntv_DeleteCommandListsNV_1(n, lists);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteCommandListsNV(n: Int32; lists: IntPtr) :=
      ntv_DeleteCommandListsNV_2(n, lists);
    
    private IsCommandListNV_adr := GetProcAddress('glIsCommandListNV');
    private ntv_IsCommandListNV_1 := GetProcOrNil&<function(list: UInt32): glBool8>(IsCommandListNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsCommandListNV(list: UInt32): glBool8 :=
      ntv_IsCommandListNV_1(list);
    
    private ListDrawCommandsStatesClientNV_adr := GetProcAddress('glListDrawCommandsStatesClientNV');
    private ntv_ListDrawCommandsStatesClientNV_1 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32)>(ListDrawCommandsStatesClientNV_adr);
    private ntv_ListDrawCommandsStatesClientNV_2 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32)>(ListDrawCommandsStatesClientNV_adr);
    private ntv_ListDrawCommandsStatesClientNV_3 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32)>(ListDrawCommandsStatesClientNV_adr);
    private ntv_ListDrawCommandsStatesClientNV_4 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32)>(ListDrawCommandsStatesClientNV_adr);
    private ntv_ListDrawCommandsStatesClientNV_5 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32)>(ListDrawCommandsStatesClientNV_adr);
    private ntv_ListDrawCommandsStatesClientNV_6 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32)>(ListDrawCommandsStatesClientNV_adr);
    private ntv_ListDrawCommandsStatesClientNV_7 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32)>(ListDrawCommandsStatesClientNV_adr);
    private ntv_ListDrawCommandsStatesClientNV_8 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32)>(ListDrawCommandsStatesClientNV_adr);
    private ntv_ListDrawCommandsStatesClientNV_9 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32)>(ListDrawCommandsStatesClientNV_adr);
    private ntv_ListDrawCommandsStatesClientNV_10 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32)>(ListDrawCommandsStatesClientNV_adr);
    private ntv_ListDrawCommandsStatesClientNV_11 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32)>(ListDrawCommandsStatesClientNV_adr);
    private ntv_ListDrawCommandsStatesClientNV_12 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32)>(ListDrawCommandsStatesClientNV_adr);
    private ntv_ListDrawCommandsStatesClientNV_13 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32)>(ListDrawCommandsStatesClientNV_adr);
    private ntv_ListDrawCommandsStatesClientNV_14 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32)>(ListDrawCommandsStatesClientNV_adr);
    private ntv_ListDrawCommandsStatesClientNV_15 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32)>(ListDrawCommandsStatesClientNV_adr);
    private ntv_ListDrawCommandsStatesClientNV_16 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32)>(ListDrawCommandsStatesClientNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32);
    type PIntPtr = ^IntPtr;
    type PInt32 = ^Int32;
    type PUInt32 = ^UInt32;
    begin
      if (sizes<>nil) and (sizes.Length<>0) then
        if (indirects<>nil) and (indirects.Length<>0) then
          if (fbos<>nil) and (fbos.Length<>0) then
            if (states<>nil) and (states.Length<>0) then
              ntv_ListDrawCommandsStatesClientNV_1(list, segment, indirects[0], sizes[0], states[0], fbos[0], count) else
              ntv_ListDrawCommandsStatesClientNV_1(list, segment, indirects[0], sizes[0], PUInt32(nil)^, fbos[0], count) else
            if (states<>nil) and (states.Length<>0) then
              ntv_ListDrawCommandsStatesClientNV_1(list, segment, indirects[0], sizes[0], states[0], PUInt32(nil)^, count) else
              ntv_ListDrawCommandsStatesClientNV_1(list, segment, indirects[0], sizes[0], PUInt32(nil)^, PUInt32(nil)^, count) else
          if (fbos<>nil) and (fbos.Length<>0) then
            if (states<>nil) and (states.Length<>0) then
              ntv_ListDrawCommandsStatesClientNV_1(list, segment, PIntPtr(nil)^, sizes[0], states[0], fbos[0], count) else
              ntv_ListDrawCommandsStatesClientNV_1(list, segment, PIntPtr(nil)^, sizes[0], PUInt32(nil)^, fbos[0], count) else
            if (states<>nil) and (states.Length<>0) then
              ntv_ListDrawCommandsStatesClientNV_1(list, segment, PIntPtr(nil)^, sizes[0], states[0], PUInt32(nil)^, count) else
              ntv_ListDrawCommandsStatesClientNV_1(list, segment, PIntPtr(nil)^, sizes[0], PUInt32(nil)^, PUInt32(nil)^, count) else
        if (indirects<>nil) and (indirects.Length<>0) then
          if (fbos<>nil) and (fbos.Length<>0) then
            if (states<>nil) and (states.Length<>0) then
              ntv_ListDrawCommandsStatesClientNV_1(list, segment, indirects[0], PInt32(nil)^, states[0], fbos[0], count) else
              ntv_ListDrawCommandsStatesClientNV_1(list, segment, indirects[0], PInt32(nil)^, PUInt32(nil)^, fbos[0], count) else
            if (states<>nil) and (states.Length<>0) then
              ntv_ListDrawCommandsStatesClientNV_1(list, segment, indirects[0], PInt32(nil)^, states[0], PUInt32(nil)^, count) else
              ntv_ListDrawCommandsStatesClientNV_1(list, segment, indirects[0], PInt32(nil)^, PUInt32(nil)^, PUInt32(nil)^, count) else
          if (fbos<>nil) and (fbos.Length<>0) then
            if (states<>nil) and (states.Length<>0) then
              ntv_ListDrawCommandsStatesClientNV_1(list, segment, PIntPtr(nil)^, PInt32(nil)^, states[0], fbos[0], count) else
              ntv_ListDrawCommandsStatesClientNV_1(list, segment, PIntPtr(nil)^, PInt32(nil)^, PUInt32(nil)^, fbos[0], count) else
            if (states<>nil) and (states.Length<>0) then
              ntv_ListDrawCommandsStatesClientNV_1(list, segment, PIntPtr(nil)^, PInt32(nil)^, states[0], PUInt32(nil)^, count) else
              ntv_ListDrawCommandsStatesClientNV_1(list, segment, PIntPtr(nil)^, PInt32(nil)^, PUInt32(nil)^, PUInt32(nil)^, count);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) :=
      ntv_ListDrawCommandsStatesClientNV_1(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32) :=
      ntv_ListDrawCommandsStatesClientNV_2(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32) :=
      ntv_ListDrawCommandsStatesClientNV_3(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32) :=
      ntv_ListDrawCommandsStatesClientNV_4(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32) :=
      ntv_ListDrawCommandsStatesClientNV_5(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32) :=
      ntv_ListDrawCommandsStatesClientNV_6(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32) :=
      ntv_ListDrawCommandsStatesClientNV_7(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32) :=
      ntv_ListDrawCommandsStatesClientNV_8(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) :=
      ntv_ListDrawCommandsStatesClientNV_9(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32) :=
      ntv_ListDrawCommandsStatesClientNV_10(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32) :=
      ntv_ListDrawCommandsStatesClientNV_11(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32) :=
      ntv_ListDrawCommandsStatesClientNV_12(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32) :=
      ntv_ListDrawCommandsStatesClientNV_13(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32) :=
      ntv_ListDrawCommandsStatesClientNV_14(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32) :=
      ntv_ListDrawCommandsStatesClientNV_15(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32) :=
      ntv_ListDrawCommandsStatesClientNV_16(list, segment, indirects, sizes, states, fbos, count);
    
    private CommandListSegmentsNV_adr := GetProcAddress('glCommandListSegmentsNV');
    private ntv_CommandListSegmentsNV_1 := GetProcOrNil&<procedure(list: UInt32; segments: UInt32)>(CommandListSegmentsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CommandListSegmentsNV(list: UInt32; segments: UInt32) :=
      ntv_CommandListSegmentsNV_1(list, segments);
    
    private CompileCommandListNV_adr := GetProcAddress('glCompileCommandListNV');
    private ntv_CompileCommandListNV_1 := GetProcOrNil&<procedure(list: UInt32)>(CompileCommandListNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileCommandListNV(list: UInt32) :=
      ntv_CompileCommandListNV_1(list);
    
    private CallCommandListNV_adr := GetProcAddress('glCallCommandListNV');
    private ntv_CallCommandListNV_1 := GetProcOrNil&<procedure(list: UInt32)>(CallCommandListNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CallCommandListNV(list: UInt32) :=
      ntv_CallCommandListNV_1(list);
    
  end;
  
  ///
  glComputeProgram5NV = static class
    public const _ExtStr = 'GL_NV_compute_program5';
  end;
  
  ///
  glComputeShaderDerivativesNV = static class
    public const _ExtStr = 'GL_NV_compute_shader_derivatives';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glConditionalRenderNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_conditional_render';
    
    private BeginConditionalRenderNV_adr := GetProcAddress('glBeginConditionalRenderNV');
    private ntv_BeginConditionalRenderNV_1 := GetProcOrNil&<procedure(id: UInt32; mode: glConditionalRenderMode)>(BeginConditionalRenderNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginConditionalRenderNV(id: UInt32; mode: glConditionalRenderMode) :=
      ntv_BeginConditionalRenderNV_1(id, mode);
    
    private EndConditionalRenderNV_adr := GetProcAddress('glEndConditionalRenderNV');
    private ntv_EndConditionalRenderNV_1 := GetProcOrNil&<procedure>(EndConditionalRenderNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndConditionalRenderNV :=
      ntv_EndConditionalRenderNV_1;
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glConservativeRasterNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_conservative_raster';
    
    private SubpixelPrecisionBiasNV_adr := GetProcAddress('glSubpixelPrecisionBiasNV');
    private ntv_SubpixelPrecisionBiasNV_1 := GetProcOrNil&<procedure(xbits: UInt32; ybits: UInt32)>(SubpixelPrecisionBiasNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SubpixelPrecisionBiasNV(xbits: UInt32; ybits: UInt32) :=
      ntv_SubpixelPrecisionBiasNV_1(xbits, ybits);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glConservativeRasterDilateNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_conservative_raster_dilate';
    
    private ConservativeRasterParameterfNV_adr := GetProcAddress('glConservativeRasterParameterfNV');
    private ntv_ConservativeRasterParameterfNV_1 := GetProcOrNil&<procedure(pname: DummyEnum; value: single)>(ConservativeRasterParameterfNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConservativeRasterParameterfNV(pname: DummyEnum; value: single) :=
      ntv_ConservativeRasterParameterfNV_1(pname, value);
    
  end;
  
  ///
  glConservativeRasterPreSnapNV = static class
    public const _ExtStr = 'GL_NV_conservative_raster_pre_snap';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glConservativeRasterPreSnapTrianglesNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_conservative_raster_pre_snap_triangles';
    
    private ConservativeRasterParameteriNV_adr := GetProcAddress('glConservativeRasterParameteriNV');
    private ntv_ConservativeRasterParameteriNV_1 := GetProcOrNil&<procedure(pname: DummyEnum; param: Int32)>(ConservativeRasterParameteriNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConservativeRasterParameteriNV(pname: DummyEnum; param: Int32) :=
      ntv_ConservativeRasterParameteriNV_1(pname, param);
    
  end;
  
  ///
  glConservativeRasterUnderestimationNV = static class
    public const _ExtStr = 'GL_NV_conservative_raster_underestimation';
  end;
  
  ///
  glCopyDepthToColorNV = static class
    public const _ExtStr = 'GL_NV_copy_depth_to_color';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glCopyImageNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_copy_image';
    
    private CopyImageSubDataNV_adr := GetProcAddress('glCopyImageSubDataNV');
    private ntv_CopyImageSubDataNV_1 := GetProcOrNil&<procedure(srcName: UInt32; srcTarget: glCopyBufferSubDataTarget; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: glCopyBufferSubDataTarget; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32)>(CopyImageSubDataNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyImageSubDataNV(srcName: UInt32; srcTarget: glCopyBufferSubDataTarget; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: glCopyBufferSubDataTarget; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32) :=
      ntv_CopyImageSubDataNV_1(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    
  end;
  
  ///
  glDeepTexture3DNV = static class
    public const _ExtStr = 'GL_NV_deep_texture3D';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDepthBufferFloatNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_depth_buffer_float';
    
    private DepthRangedNV_adr := GetProcAddress('glDepthRangedNV');
    private ntv_DepthRangedNV_1 := GetProcOrNil&<procedure(zNear: double; zFar: double)>(DepthRangedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangedNV(zNear: double; zFar: double) :=
      ntv_DepthRangedNV_1(zNear, zFar);
    
    private ClearDepthdNV_adr := GetProcAddress('glClearDepthdNV');
    private ntv_ClearDepthdNV_1 := GetProcOrNil&<procedure(depth: double)>(ClearDepthdNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepthdNV(depth: double) :=
      ntv_ClearDepthdNV_1(depth);
    
    private DepthBoundsdNV_adr := GetProcAddress('glDepthBoundsdNV');
    private ntv_DepthBoundsdNV_1 := GetProcOrNil&<procedure(zmin: double; zmax: double)>(DepthBoundsdNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthBoundsdNV(zmin: double; zmax: double) :=
      ntv_DepthBoundsdNV_1(zmin, zmax);
    
  end;
  
  ///
  glDepthClampNV = static class
    public const _ExtStr = 'GL_NV_depth_clamp';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDrawTextureNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_draw_texture';
    
    private DrawTextureNV_adr := GetProcAddress('glDrawTextureNV');
    private ntv_DrawTextureNV_1 := GetProcOrNil&<procedure(texture: gl_texture; sampler: gl_sampler; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single)>(DrawTextureNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTextureNV(texture: gl_texture; sampler: gl_sampler; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single) :=
      ntv_DrawTextureNV_1(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDrawVulkanImageNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_draw_vulkan_image';
    
    private DrawVkImageNV_adr := GetProcAddress('glDrawVkImageNV');
    private ntv_DrawVkImageNV_1 := GetProcOrNil&<procedure(vkImage: UInt64; sampler: gl_sampler; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single)>(DrawVkImageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawVkImageNV(vkImage: UInt64; sampler: gl_sampler; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single) :=
      ntv_DrawVkImageNV_1(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
    
    private GetVkProcAddrNV_adr := GetProcAddress('glGetVkProcAddrNV');
    private ntv_GetVkProcAddrNV_1 := GetProcOrNil&<function(name: IntPtr): glVulkanProcNV>(GetVkProcAddrNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVkProcAddrNV(name: string): glVulkanProcNV;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetVkProcAddrNV_1(name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVkProcAddrNV(name: IntPtr): glVulkanProcNV :=
      ntv_GetVkProcAddrNV_1(name);
    
    private WaitVkSemaphoreNV_adr := GetProcAddress('glWaitVkSemaphoreNV');
    private ntv_WaitVkSemaphoreNV_1 := GetProcOrNil&<procedure(vkSemaphore: UInt64)>(WaitVkSemaphoreNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitVkSemaphoreNV(vkSemaphore: UInt64) :=
      ntv_WaitVkSemaphoreNV_1(vkSemaphore);
    
    private SignalVkSemaphoreNV_adr := GetProcAddress('glSignalVkSemaphoreNV');
    private ntv_SignalVkSemaphoreNV_1 := GetProcOrNil&<procedure(vkSemaphore: UInt64)>(SignalVkSemaphoreNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalVkSemaphoreNV(vkSemaphore: UInt64) :=
      ntv_SignalVkSemaphoreNV_1(vkSemaphore);
    
    private SignalVkFenceNV_adr := GetProcAddress('glSignalVkFenceNV');
    private ntv_SignalVkFenceNV_1 := GetProcOrNil&<procedure(vkFence: UInt64)>(SignalVkFenceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalVkFenceNV(vkFence: UInt64) :=
      ntv_SignalVkFenceNV_1(vkFence);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glEvaluatorsNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_evaluators';
    
    private MapControlPointsNV_adr := GetProcAddress('glMapControlPointsNV');
    private ntv_MapControlPointsNV_1 := GetProcOrNil&<procedure(target: glEvalTarget; index: UInt32; &type: glMapType; ustride: Int32; vstride: Int32; uorder: Int32; vorder: Int32; &packed: glBool8; points: IntPtr)>(MapControlPointsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapControlPointsNV(target: glEvalTarget; index: UInt32; &type: glMapType; ustride: Int32; vstride: Int32; uorder: Int32; vorder: Int32; &packed: glBool8; points: IntPtr) :=
      ntv_MapControlPointsNV_1(target, index, &type, ustride, vstride, uorder, vorder, &packed, points);
    
    private MapParameterivNV_adr := GetProcAddress('glMapParameterivNV');
    private ntv_MapParameterivNV_1 := GetProcOrNil&<procedure(target: glEvalTarget; pname: glMapParameter; var &params: Int32)>(MapParameterivNV_adr);
    private ntv_MapParameterivNV_2 := GetProcOrNil&<procedure(target: glEvalTarget; pname: glMapParameter; &params: IntPtr)>(MapParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterivNV(target: glEvalTarget; pname: glMapParameter; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_MapParameterivNV_1(target, pname, &params[0]) else
        ntv_MapParameterivNV_1(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterivNV(target: glEvalTarget; pname: glMapParameter; var &params: Int32) :=
      ntv_MapParameterivNV_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterivNV(target: glEvalTarget; pname: glMapParameter; &params: IntPtr) :=
      ntv_MapParameterivNV_2(target, pname, &params);
    
    private MapParameterfvNV_adr := GetProcAddress('glMapParameterfvNV');
    private ntv_MapParameterfvNV_1 := GetProcOrNil&<procedure(target: glEvalTarget; pname: glMapParameter; var &params: single)>(MapParameterfvNV_adr);
    private ntv_MapParameterfvNV_2 := GetProcOrNil&<procedure(target: glEvalTarget; pname: glMapParameter; &params: IntPtr)>(MapParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterfvNV(target: glEvalTarget; pname: glMapParameter; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_MapParameterfvNV_1(target, pname, &params[0]) else
        ntv_MapParameterfvNV_1(target, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterfvNV(target: glEvalTarget; pname: glMapParameter; var &params: single) :=
      ntv_MapParameterfvNV_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterfvNV(target: glEvalTarget; pname: glMapParameter; &params: IntPtr) :=
      ntv_MapParameterfvNV_2(target, pname, &params);
    
    private GetMapControlPointsNV_adr := GetProcAddress('glGetMapControlPointsNV');
    private ntv_GetMapControlPointsNV_1 := GetProcOrNil&<procedure(target: glEvalTarget; index: UInt32; &type: glMapType; ustride: Int32; vstride: Int32; &packed: glBool8; points: IntPtr)>(GetMapControlPointsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapControlPointsNV(target: glEvalTarget; index: UInt32; &type: glMapType; ustride: Int32; vstride: Int32; &packed: glBool8; points: IntPtr) :=
      ntv_GetMapControlPointsNV_1(target, index, &type, ustride, vstride, &packed, points);
    
    private GetMapParameterivNV_adr := GetProcAddress('glGetMapParameterivNV');
    private ntv_GetMapParameterivNV_1 := GetProcOrNil&<procedure(target: glEvalTarget; pname: glMapParameter; var &params: Int32)>(GetMapParameterivNV_adr);
    private ntv_GetMapParameterivNV_2 := GetProcOrNil&<procedure(target: glEvalTarget; pname: glMapParameter; &params: IntPtr)>(GetMapParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterivNV(target: glEvalTarget; pname: glMapParameter; var &params: Int32) :=
      ntv_GetMapParameterivNV_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterivNV(target: glEvalTarget; pname: glMapParameter; &params: IntPtr) :=
      ntv_GetMapParameterivNV_2(target, pname, &params);
    
    private GetMapParameterfvNV_adr := GetProcAddress('glGetMapParameterfvNV');
    private ntv_GetMapParameterfvNV_1 := GetProcOrNil&<procedure(target: glEvalTarget; pname: glMapParameter; var &params: single)>(GetMapParameterfvNV_adr);
    private ntv_GetMapParameterfvNV_2 := GetProcOrNil&<procedure(target: glEvalTarget; pname: glMapParameter; &params: IntPtr)>(GetMapParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterfvNV(target: glEvalTarget; pname: glMapParameter; var &params: single) :=
      ntv_GetMapParameterfvNV_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterfvNV(target: glEvalTarget; pname: glMapParameter; &params: IntPtr) :=
      ntv_GetMapParameterfvNV_2(target, pname, &params);
    
    private GetMapAttribParameterivNV_adr := GetProcAddress('glGetMapAttribParameterivNV');
    private ntv_GetMapAttribParameterivNV_1 := GetProcOrNil&<procedure(target: glEvalTarget; index: UInt32; pname: glMapAttribParameter; var &params: Int32)>(GetMapAttribParameterivNV_adr);
    private ntv_GetMapAttribParameterivNV_2 := GetProcOrNil&<procedure(target: glEvalTarget; index: UInt32; pname: glMapAttribParameter; &params: IntPtr)>(GetMapAttribParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterivNV(target: glEvalTarget; index: UInt32; pname: glMapAttribParameter; var &params: Int32) :=
      ntv_GetMapAttribParameterivNV_1(target, index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterivNV(target: glEvalTarget; index: UInt32; pname: glMapAttribParameter; &params: IntPtr) :=
      ntv_GetMapAttribParameterivNV_2(target, index, pname, &params);
    
    private GetMapAttribParameterfvNV_adr := GetProcAddress('glGetMapAttribParameterfvNV');
    private ntv_GetMapAttribParameterfvNV_1 := GetProcOrNil&<procedure(target: glEvalTarget; index: UInt32; pname: glMapAttribParameter; var &params: single)>(GetMapAttribParameterfvNV_adr);
    private ntv_GetMapAttribParameterfvNV_2 := GetProcOrNil&<procedure(target: glEvalTarget; index: UInt32; pname: glMapAttribParameter; &params: IntPtr)>(GetMapAttribParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterfvNV(target: glEvalTarget; index: UInt32; pname: glMapAttribParameter; var &params: single) :=
      ntv_GetMapAttribParameterfvNV_1(target, index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterfvNV(target: glEvalTarget; index: UInt32; pname: glMapAttribParameter; &params: IntPtr) :=
      ntv_GetMapAttribParameterfvNV_2(target, index, pname, &params);
    
    private EvalMapsNV_adr := GetProcAddress('glEvalMapsNV');
    private ntv_EvalMapsNV_1 := GetProcOrNil&<procedure(target: glEvalTarget; mode: glEvalMapsMode)>(EvalMapsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalMapsNV(target: glEvalTarget; mode: glEvalMapsMode) :=
      ntv_EvalMapsNV_1(target, mode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glExplicitMultisampleNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_explicit_multisample';
    
    private GetMultisamplefvNV_adr := GetProcAddress('glGetMultisamplefvNV');
    private ntv_GetMultisamplefvNV_1 := GetProcOrNil&<procedure(pname: glGetMultisamplePName; index: UInt32; var val: single)>(GetMultisamplefvNV_adr);
    private ntv_GetMultisamplefvNV_2 := GetProcOrNil&<procedure(pname: glGetMultisamplePName; index: UInt32; val: IntPtr)>(GetMultisamplefvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefvNV(pname: glGetMultisamplePName; index: UInt32; var val: single) :=
      ntv_GetMultisamplefvNV_1(pname, index, val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefvNV(pname: glGetMultisamplePName; index: UInt32; val: IntPtr) :=
      ntv_GetMultisamplefvNV_2(pname, index, val);
    
    private SampleMaskIndexedNV_adr := GetProcAddress('glSampleMaskIndexedNV');
    private ntv_SampleMaskIndexedNV_1 := GetProcOrNil&<procedure(index: UInt32; mask: DummyFlags)>(SampleMaskIndexedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMaskIndexedNV(index: UInt32; mask: DummyFlags) :=
      ntv_SampleMaskIndexedNV_1(index, mask);
    
    private TexRenderbufferNV_adr := GetProcAddress('glTexRenderbufferNV');
    private ntv_TexRenderbufferNV_1 := GetProcOrNil&<procedure(target: glTextureTarget; renderbuffer: gl_renderbuffer)>(TexRenderbufferNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexRenderbufferNV(target: glTextureTarget; renderbuffer: gl_renderbuffer) :=
      ntv_TexRenderbufferNV_1(target, renderbuffer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFenceNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_fence';
    
    private DeleteFencesNV_adr := GetProcAddress('glDeleteFencesNV');
    private ntv_DeleteFencesNV_1 := GetProcOrNil&<procedure(n: Int32; var fences: UInt32)>(DeleteFencesNV_adr);
    private ntv_DeleteFencesNV_2 := GetProcOrNil&<procedure(n: Int32; fences: IntPtr)>(DeleteFencesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesNV(n: Int32; fences: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (fences<>nil) and (fences.Length<>0) then
        ntv_DeleteFencesNV_1(n, fences[0]) else
        ntv_DeleteFencesNV_1(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesNV(n: Int32; var fences: UInt32) :=
      ntv_DeleteFencesNV_1(n, fences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesNV(n: Int32; fences: IntPtr) :=
      ntv_DeleteFencesNV_2(n, fences);
    
    private GenFencesNV_adr := GetProcAddress('glGenFencesNV');
    private ntv_GenFencesNV_1 := GetProcOrNil&<procedure(n: Int32; var fences: UInt32)>(GenFencesNV_adr);
    private ntv_GenFencesNV_2 := GetProcOrNil&<procedure(n: Int32; fences: IntPtr)>(GenFencesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesNV(n: Int32; fences: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (fences<>nil) and (fences.Length<>0) then
        ntv_GenFencesNV_1(n, fences[0]) else
        ntv_GenFencesNV_1(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesNV(n: Int32; var fences: UInt32) :=
      ntv_GenFencesNV_1(n, fences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesNV(n: Int32; fences: IntPtr) :=
      ntv_GenFencesNV_2(n, fences);
    
    private IsFenceNV_adr := GetProcAddress('glIsFenceNV');
    private ntv_IsFenceNV_1 := GetProcOrNil&<function(fence: UInt32): glBool8>(IsFenceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsFenceNV(fence: UInt32): glBool8 :=
      ntv_IsFenceNV_1(fence);
    
    private TestFenceNV_adr := GetProcAddress('glTestFenceNV');
    private ntv_TestFenceNV_1 := GetProcOrNil&<function(fence: UInt32): glBool8>(TestFenceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function TestFenceNV(fence: UInt32): glBool8 :=
      ntv_TestFenceNV_1(fence);
    
    private GetFenceivNV_adr := GetProcAddress('glGetFenceivNV');
    private ntv_GetFenceivNV_1 := GetProcOrNil&<procedure(fence: UInt32; pname: glFenceParameterName; var &params: Int32)>(GetFenceivNV_adr);
    private ntv_GetFenceivNV_2 := GetProcOrNil&<procedure(fence: UInt32; pname: glFenceParameterName; &params: IntPtr)>(GetFenceivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFenceivNV(fence: UInt32; pname: glFenceParameterName; var &params: Int32) :=
      ntv_GetFenceivNV_1(fence, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFenceivNV(fence: UInt32; pname: glFenceParameterName; &params: IntPtr) :=
      ntv_GetFenceivNV_2(fence, pname, &params);
    
    private FinishFenceNV_adr := GetProcAddress('glFinishFenceNV');
    private ntv_FinishFenceNV_1 := GetProcOrNil&<procedure(fence: UInt32)>(FinishFenceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinishFenceNV(fence: UInt32) :=
      ntv_FinishFenceNV_1(fence);
    
    private SetFenceNV_adr := GetProcAddress('glSetFenceNV');
    private ntv_SetFenceNV_1 := GetProcOrNil&<procedure(fence: UInt32; condition: glFenceCondition)>(SetFenceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFenceNV(fence: UInt32; condition: glFenceCondition) :=
      ntv_SetFenceNV_1(fence, condition);
    
  end;
  
  ///
  glFillRectangleNV = static class
    public const _ExtStr = 'GL_NV_fill_rectangle';
  end;
  
  ///
  glFloatBufferNV = static class
    public const _ExtStr = 'GL_NV_float_buffer';
  end;
  
  ///
  glFogDistanceNV = static class
    public const _ExtStr = 'GL_NV_fog_distance';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFragmentCoverageToColorNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_fragment_coverage_to_color';
    
    private FragmentCoverageColorNV_adr := GetProcAddress('glFragmentCoverageColorNV');
    private ntv_FragmentCoverageColorNV_1 := GetProcOrNil&<procedure(color: UInt32)>(FragmentCoverageColorNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentCoverageColorNV(color: UInt32) :=
      ntv_FragmentCoverageColorNV_1(color);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFragmentProgramNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_fragment_program';
    
    private ProgramNamedParameter4fNV_adr := GetProcAddress('glProgramNamedParameter4fNV');
    private ntv_ProgramNamedParameter4fNV_1 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; x: single; y: single; z: single; w: single)>(ProgramNamedParameter4fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fNV(id: gl_program; len: Int32; name: string; x: single; y: single; z: single; w: single);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_ProgramNamedParameter4fNV_1(id, len, name_str_ptr, x, y, z, w);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fNV(id: gl_program; len: Int32; name: IntPtr; x: single; y: single; z: single; w: single) :=
      ntv_ProgramNamedParameter4fNV_1(id, len, name, x, y, z, w);
    
    private ProgramNamedParameter4fvNV_adr := GetProcAddress('glProgramNamedParameter4fvNV');
    private ntv_ProgramNamedParameter4fvNV_1 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; var v: single)>(ProgramNamedParameter4fvNV_adr);
    private ntv_ProgramNamedParameter4fvNV_2 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; var v: Vec4f)>(ProgramNamedParameter4fvNV_adr);
    private ntv_ProgramNamedParameter4fvNV_3 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; v: IntPtr)>(ProgramNamedParameter4fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: gl_program; len: Int32; name: string; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ProgramNamedParameter4fvNV(id, len, name, v[0]) else
        ProgramNamedParameter4fvNV(id, len, name, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: gl_program; len: Int32; name: IntPtr; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_ProgramNamedParameter4fvNV_1(id, len, name, v[0]) else
        ntv_ProgramNamedParameter4fvNV_1(id, len, name, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: gl_program; len: Int32; name: string; var v: Vec4f);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_ProgramNamedParameter4fvNV_2(id, len, name_str_ptr, v);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: gl_program; len: Int32; name: string; var v: single);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_ProgramNamedParameter4fvNV_1(id, len, name_str_ptr, v);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: gl_program; len: Int32; name: string; v: IntPtr);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_ProgramNamedParameter4fvNV_3(id, len, name_str_ptr, v);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: gl_program; len: Int32; name: IntPtr; var v: Vec4f) :=
      ntv_ProgramNamedParameter4fvNV_2(id, len, name, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: gl_program; len: Int32; name: IntPtr; var v: single) :=
      ntv_ProgramNamedParameter4fvNV_1(id, len, name, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: gl_program; len: Int32; name: IntPtr; v: IntPtr) :=
      ntv_ProgramNamedParameter4fvNV_3(id, len, name, v);
    
    private ProgramNamedParameter4dNV_adr := GetProcAddress('glProgramNamedParameter4dNV');
    private ntv_ProgramNamedParameter4dNV_1 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; x: double; y: double; z: double; w: double)>(ProgramNamedParameter4dNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dNV(id: gl_program; len: Int32; name: string; x: double; y: double; z: double; w: double);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_ProgramNamedParameter4dNV_1(id, len, name_str_ptr, x, y, z, w);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dNV(id: gl_program; len: Int32; name: IntPtr; x: double; y: double; z: double; w: double) :=
      ntv_ProgramNamedParameter4dNV_1(id, len, name, x, y, z, w);
    
    private ProgramNamedParameter4dvNV_adr := GetProcAddress('glProgramNamedParameter4dvNV');
    private ntv_ProgramNamedParameter4dvNV_1 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; var v: double)>(ProgramNamedParameter4dvNV_adr);
    private ntv_ProgramNamedParameter4dvNV_2 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; var v: Vec4d)>(ProgramNamedParameter4dvNV_adr);
    private ntv_ProgramNamedParameter4dvNV_3 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; v: IntPtr)>(ProgramNamedParameter4dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: gl_program; len: Int32; name: string; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ProgramNamedParameter4dvNV(id, len, name, v[0]) else
        ProgramNamedParameter4dvNV(id, len, name, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: gl_program; len: Int32; name: IntPtr; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_ProgramNamedParameter4dvNV_1(id, len, name, v[0]) else
        ntv_ProgramNamedParameter4dvNV_1(id, len, name, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: gl_program; len: Int32; name: string; var v: Vec4d);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_ProgramNamedParameter4dvNV_2(id, len, name_str_ptr, v);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: gl_program; len: Int32; name: string; var v: double);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_ProgramNamedParameter4dvNV_1(id, len, name_str_ptr, v);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: gl_program; len: Int32; name: string; v: IntPtr);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_ProgramNamedParameter4dvNV_3(id, len, name_str_ptr, v);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: gl_program; len: Int32; name: IntPtr; var v: Vec4d) :=
      ntv_ProgramNamedParameter4dvNV_2(id, len, name, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: gl_program; len: Int32; name: IntPtr; var v: double) :=
      ntv_ProgramNamedParameter4dvNV_1(id, len, name, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: gl_program; len: Int32; name: IntPtr; v: IntPtr) :=
      ntv_ProgramNamedParameter4dvNV_3(id, len, name, v);
    
    private GetProgramNamedParameterfvNV_adr := GetProcAddress('glGetProgramNamedParameterfvNV');
    private ntv_GetProgramNamedParameterfvNV_1 := GetProcOrNil&<procedure(id: gl_program; len: Int32; var name: Byte; var &params: single)>(GetProgramNamedParameterfvNV_adr);
    private ntv_GetProgramNamedParameterfvNV_2 := GetProcOrNil&<procedure(id: gl_program; len: Int32; var name: Byte; &params: IntPtr)>(GetProgramNamedParameterfvNV_adr);
    private ntv_GetProgramNamedParameterfvNV_3 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; var &params: single)>(GetProgramNamedParameterfvNV_adr);
    private ntv_GetProgramNamedParameterfvNV_4 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; &params: IntPtr)>(GetProgramNamedParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: gl_program; len: Int32; name: array of Byte; var &params: single);
    type PByte = ^Byte;
    begin
      if (name<>nil) and (name.Length<>0) then
        ntv_GetProgramNamedParameterfvNV_1(id, len, name[0], &params) else
        ntv_GetProgramNamedParameterfvNV_1(id, len, PByte(nil)^, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: gl_program; len: Int32; name: array of Byte; &params: IntPtr);
    type PByte = ^Byte;
    begin
      if (name<>nil) and (name.Length<>0) then
        ntv_GetProgramNamedParameterfvNV_2(id, len, name[0], &params) else
        ntv_GetProgramNamedParameterfvNV_2(id, len, PByte(nil)^, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: gl_program; len: Int32; var name: Byte; var &params: single) :=
      ntv_GetProgramNamedParameterfvNV_1(id, len, name, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: gl_program; len: Int32; var name: Byte; &params: IntPtr) :=
      ntv_GetProgramNamedParameterfvNV_2(id, len, name, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: gl_program; len: Int32; name: IntPtr; var &params: single) :=
      ntv_GetProgramNamedParameterfvNV_3(id, len, name, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: gl_program; len: Int32; name: IntPtr; &params: IntPtr) :=
      ntv_GetProgramNamedParameterfvNV_4(id, len, name, &params);
    
    private GetProgramNamedParameterdvNV_adr := GetProcAddress('glGetProgramNamedParameterdvNV');
    private ntv_GetProgramNamedParameterdvNV_1 := GetProcOrNil&<procedure(id: gl_program; len: Int32; var name: Byte; var &params: double)>(GetProgramNamedParameterdvNV_adr);
    private ntv_GetProgramNamedParameterdvNV_2 := GetProcOrNil&<procedure(id: gl_program; len: Int32; var name: Byte; &params: IntPtr)>(GetProgramNamedParameterdvNV_adr);
    private ntv_GetProgramNamedParameterdvNV_3 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; var &params: double)>(GetProgramNamedParameterdvNV_adr);
    private ntv_GetProgramNamedParameterdvNV_4 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; &params: IntPtr)>(GetProgramNamedParameterdvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: gl_program; len: Int32; name: array of Byte; var &params: double);
    type PByte = ^Byte;
    begin
      if (name<>nil) and (name.Length<>0) then
        ntv_GetProgramNamedParameterdvNV_1(id, len, name[0], &params) else
        ntv_GetProgramNamedParameterdvNV_1(id, len, PByte(nil)^, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: gl_program; len: Int32; name: array of Byte; &params: IntPtr);
    type PByte = ^Byte;
    begin
      if (name<>nil) and (name.Length<>0) then
        ntv_GetProgramNamedParameterdvNV_2(id, len, name[0], &params) else
        ntv_GetProgramNamedParameterdvNV_2(id, len, PByte(nil)^, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: gl_program; len: Int32; var name: Byte; var &params: double) :=
      ntv_GetProgramNamedParameterdvNV_1(id, len, name, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: gl_program; len: Int32; var name: Byte; &params: IntPtr) :=
      ntv_GetProgramNamedParameterdvNV_2(id, len, name, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: gl_program; len: Int32; name: IntPtr; var &params: double) :=
      ntv_GetProgramNamedParameterdvNV_3(id, len, name, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: gl_program; len: Int32; name: IntPtr; &params: IntPtr) :=
      ntv_GetProgramNamedParameterdvNV_4(id, len, name, &params);
    
  end;
  
  ///
  glFragmentProgramOptionNV = static class
    public const _ExtStr = 'GL_NV_fragment_program_option';
  end;
  
  ///
  glFragmentProgram2NV = static class
    public const _ExtStr = 'GL_NV_fragment_program2';
  end;
  
  ///
  glFragmentProgram4NV = static class
    public const _ExtStr = 'GL_NV_fragment_program4';
  end;
  
  ///
  glFragmentShaderBarycentricNV = static class
    public const _ExtStr = 'GL_NV_fragment_shader_barycentric';
  end;
  
  ///
  glFragmentShaderInterlockNV = static class
    public const _ExtStr = 'GL_NV_fragment_shader_interlock';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFramebufferMixedSamplesNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_framebuffer_mixed_samples';
    
    private RasterSamplesEXT_adr := GetProcAddress('glRasterSamplesEXT');
    private ntv_RasterSamplesEXT_1 := GetProcOrNil&<procedure(samples: UInt32; fixedsamplelocations: glBool8)>(RasterSamplesEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterSamplesEXT(samples: UInt32; fixedsamplelocations: glBool8) :=
      ntv_RasterSamplesEXT_1(samples, fixedsamplelocations);
    
    private CoverageModulationTableNV_adr := GetProcAddress('glCoverageModulationTableNV');
    private ntv_CoverageModulationTableNV_1 := GetProcOrNil&<procedure(n: Int32; var v: single)>(CoverageModulationTableNV_adr);
    private ntv_CoverageModulationTableNV_2 := GetProcOrNil&<procedure(n: Int32; v: IntPtr)>(CoverageModulationTableNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageModulationTableNV(n: Int32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_CoverageModulationTableNV_1(n, v[0]) else
        ntv_CoverageModulationTableNV_1(n, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageModulationTableNV(n: Int32; var v: single) :=
      ntv_CoverageModulationTableNV_1(n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageModulationTableNV(n: Int32; v: IntPtr) :=
      ntv_CoverageModulationTableNV_2(n, v);
    
    private GetCoverageModulationTableNV_adr := GetProcAddress('glGetCoverageModulationTableNV');
    private ntv_GetCoverageModulationTableNV_1 := GetProcOrNil&<procedure(bufSize: Int32; var v: single)>(GetCoverageModulationTableNV_adr);
    private ntv_GetCoverageModulationTableNV_2 := GetProcOrNil&<procedure(bufSize: Int32; v: IntPtr)>(GetCoverageModulationTableNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCoverageModulationTableNV(bufSize: Int32; var v: single) :=
      ntv_GetCoverageModulationTableNV_1(bufSize, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCoverageModulationTableNV(bufSize: Int32; v: IntPtr) :=
      ntv_GetCoverageModulationTableNV_2(bufSize, v);
    
    private CoverageModulationNV_adr := GetProcAddress('glCoverageModulationNV');
    private ntv_CoverageModulationNV_1 := GetProcOrNil&<procedure(components: DummyEnum)>(CoverageModulationNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageModulationNV(components: DummyEnum) :=
      ntv_CoverageModulationNV_1(components);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFramebufferMultisampleCoverageNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_framebuffer_multisample_coverage';
    
    private RenderbufferStorageMultisampleCoverageNV_adr := GetProcAddress('glRenderbufferStorageMultisampleCoverageNV');
    private ntv_RenderbufferStorageMultisampleCoverageNV_1 := GetProcOrNil&<procedure(target: glRenderbufferTarget; coverageSamples: Int32; colorSamples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32)>(RenderbufferStorageMultisampleCoverageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisampleCoverageNV(target: glRenderbufferTarget; coverageSamples: Int32; colorSamples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32) :=
      ntv_RenderbufferStorageMultisampleCoverageNV_1(target, coverageSamples, colorSamples, internalformat, width, height);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glGeometryProgram4NV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_geometry_program4';
    
    private ProgramVertexLimitNV_adr := GetProcAddress('glProgramVertexLimitNV');
    private ntv_ProgramVertexLimitNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; limit: Int32)>(ProgramVertexLimitNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramVertexLimitNV(target: glProgramTarget; limit: Int32) :=
      ntv_ProgramVertexLimitNV_1(target, limit);
    
    private FramebufferTextureEXT_adr := GetProcAddress('glFramebufferTextureEXT');
    private ntv_FramebufferTextureEXT_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32)>(FramebufferTextureEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureEXT(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32) :=
      ntv_FramebufferTextureEXT_1(target, attachment, texture, level);
    
    private FramebufferTextureLayerEXT_adr := GetProcAddress('glFramebufferTextureLayerEXT');
    private ntv_FramebufferTextureLayerEXT_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32)>(FramebufferTextureLayerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureLayerEXT(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32) :=
      ntv_FramebufferTextureLayerEXT_1(target, attachment, texture, level, layer);
    
    private FramebufferTextureFaceEXT_adr := GetProcAddress('glFramebufferTextureFaceEXT');
    private ntv_FramebufferTextureFaceEXT_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; face: glTextureTarget)>(FramebufferTextureFaceEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureFaceEXT(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; face: glTextureTarget) :=
      ntv_FramebufferTextureFaceEXT_1(target, attachment, texture, level, face);
    
  end;
  
  ///
  glGeometryShaderPassthroughNV = static class
    public const _ExtStr = 'GL_NV_geometry_shader_passthrough';
  end;
  
  ///
  glGeometryShader4NV = static class
    public const _ExtStr = 'GL_NV_geometry_shader4';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glGpuMulticastNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_gpu_multicast';
    
    private RenderGpuMaskNV_adr := GetProcAddress('glRenderGpuMaskNV');
    private ntv_RenderGpuMaskNV_1 := GetProcOrNil&<procedure(mask: DummyFlags)>(RenderGpuMaskNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderGpuMaskNV(mask: DummyFlags) :=
      ntv_RenderGpuMaskNV_1(mask);
    
    private MulticastBufferSubDataNV_adr := GetProcAddress('glMulticastBufferSubDataNV');
    private ntv_MulticastBufferSubDataNV_1 := GetProcOrNil&<procedure(gpuMask: DummyFlags; buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: IntPtr)>(MulticastBufferSubDataNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastBufferSubDataNV(gpuMask: DummyFlags; buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: IntPtr) :=
      ntv_MulticastBufferSubDataNV_1(gpuMask, buffer, offset, size, data);
    
    private MulticastCopyBufferSubDataNV_adr := GetProcAddress('glMulticastCopyBufferSubDataNV');
    private ntv_MulticastCopyBufferSubDataNV_1 := GetProcOrNil&<procedure(readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(MulticastCopyBufferSubDataNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastCopyBufferSubDataNV(readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) :=
      ntv_MulticastCopyBufferSubDataNV_1(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
    
    private MulticastCopyImageSubDataNV_adr := GetProcAddress('glMulticastCopyImageSubDataNV');
    private ntv_MulticastCopyImageSubDataNV_1 := GetProcOrNil&<procedure(srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32)>(MulticastCopyImageSubDataNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastCopyImageSubDataNV(srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32) :=
      ntv_MulticastCopyImageSubDataNV_1(srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    
    private MulticastBlitFramebufferNV_adr := GetProcAddress('glMulticastBlitFramebufferNV');
    private ntv_MulticastBlitFramebufferNV_1 := GetProcOrNil&<procedure(srcGpu: UInt32; dstGpu: UInt32; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: glClearBufferMask; filter: DummyEnum)>(MulticastBlitFramebufferNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastBlitFramebufferNV(srcGpu: UInt32; dstGpu: UInt32; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: glClearBufferMask; filter: DummyEnum) :=
      ntv_MulticastBlitFramebufferNV_1(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    private MulticastFramebufferSampleLocationsfvNV_adr := GetProcAddress('glMulticastFramebufferSampleLocationsfvNV');
    private ntv_MulticastFramebufferSampleLocationsfvNV_1 := GetProcOrNil&<procedure(gpu: UInt32; framebuffer: gl_framebuffer; start: UInt32; count: Int32; var v: single)>(MulticastFramebufferSampleLocationsfvNV_adr);
    private ntv_MulticastFramebufferSampleLocationsfvNV_2 := GetProcOrNil&<procedure(gpu: UInt32; framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: IntPtr)>(MulticastFramebufferSampleLocationsfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastFramebufferSampleLocationsfvNV(gpu: UInt32; framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MulticastFramebufferSampleLocationsfvNV_1(gpu, framebuffer, start, count, v[0]) else
        ntv_MulticastFramebufferSampleLocationsfvNV_1(gpu, framebuffer, start, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastFramebufferSampleLocationsfvNV(gpu: UInt32; framebuffer: gl_framebuffer; start: UInt32; count: Int32; var v: single) :=
      ntv_MulticastFramebufferSampleLocationsfvNV_1(gpu, framebuffer, start, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastFramebufferSampleLocationsfvNV(gpu: UInt32; framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: IntPtr) :=
      ntv_MulticastFramebufferSampleLocationsfvNV_2(gpu, framebuffer, start, count, v);
    
    private MulticastBarrierNV_adr := GetProcAddress('glMulticastBarrierNV');
    private ntv_MulticastBarrierNV_1 := GetProcOrNil&<procedure>(MulticastBarrierNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastBarrierNV :=
      ntv_MulticastBarrierNV_1;
    
    private MulticastWaitSyncNV_adr := GetProcAddress('glMulticastWaitSyncNV');
    private ntv_MulticastWaitSyncNV_1 := GetProcOrNil&<procedure(signalGpu: UInt32; waitGpuMask: DummyFlags)>(MulticastWaitSyncNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastWaitSyncNV(signalGpu: UInt32; waitGpuMask: DummyFlags) :=
      ntv_MulticastWaitSyncNV_1(signalGpu, waitGpuMask);
    
    private MulticastGetQueryObjectivNV_adr := GetProcAddress('glMulticastGetQueryObjectivNV');
    private ntv_MulticastGetQueryObjectivNV_1 := GetProcOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: Int32)>(MulticastGetQueryObjectivNV_adr);
    private ntv_MulticastGetQueryObjectivNV_2 := GetProcOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: IntPtr)>(MulticastGetQueryObjectivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_MulticastGetQueryObjectivNV_1(gpu, id, pname, &params[0]) else
        ntv_MulticastGetQueryObjectivNV_1(gpu, id, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: Int32) :=
      ntv_MulticastGetQueryObjectivNV_1(gpu, id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: IntPtr) :=
      ntv_MulticastGetQueryObjectivNV_2(gpu, id, pname, &params);
    
    private MulticastGetQueryObjectuivNV_adr := GetProcAddress('glMulticastGetQueryObjectuivNV');
    private ntv_MulticastGetQueryObjectuivNV_1 := GetProcOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: UInt32)>(MulticastGetQueryObjectuivNV_adr);
    private ntv_MulticastGetQueryObjectuivNV_2 := GetProcOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: IntPtr)>(MulticastGetQueryObjectuivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectuivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_MulticastGetQueryObjectuivNV_1(gpu, id, pname, &params[0]) else
        ntv_MulticastGetQueryObjectuivNV_1(gpu, id, pname, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectuivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: UInt32) :=
      ntv_MulticastGetQueryObjectuivNV_1(gpu, id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectuivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: IntPtr) :=
      ntv_MulticastGetQueryObjectuivNV_2(gpu, id, pname, &params);
    
    private MulticastGetQueryObjecti64vNV_adr := GetProcAddress('glMulticastGetQueryObjecti64vNV');
    private ntv_MulticastGetQueryObjecti64vNV_1 := GetProcOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: Int64)>(MulticastGetQueryObjecti64vNV_adr);
    private ntv_MulticastGetQueryObjecti64vNV_2 := GetProcOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: IntPtr)>(MulticastGetQueryObjecti64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjecti64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_MulticastGetQueryObjecti64vNV_1(gpu, id, pname, &params[0]) else
        ntv_MulticastGetQueryObjecti64vNV_1(gpu, id, pname, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjecti64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: Int64) :=
      ntv_MulticastGetQueryObjecti64vNV_1(gpu, id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjecti64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: IntPtr) :=
      ntv_MulticastGetQueryObjecti64vNV_2(gpu, id, pname, &params);
    
    private MulticastGetQueryObjectui64vNV_adr := GetProcAddress('glMulticastGetQueryObjectui64vNV');
    private ntv_MulticastGetQueryObjectui64vNV_1 := GetProcOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: UInt64)>(MulticastGetQueryObjectui64vNV_adr);
    private ntv_MulticastGetQueryObjectui64vNV_2 := GetProcOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: IntPtr)>(MulticastGetQueryObjectui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectui64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_MulticastGetQueryObjectui64vNV_1(gpu, id, pname, &params[0]) else
        ntv_MulticastGetQueryObjectui64vNV_1(gpu, id, pname, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectui64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: UInt64) :=
      ntv_MulticastGetQueryObjectui64vNV_1(gpu, id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectui64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: IntPtr) :=
      ntv_MulticastGetQueryObjectui64vNV_2(gpu, id, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glGpuProgram4NV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_gpu_program4';
    
    private ProgramLocalParameterI4iNV_adr := GetProcAddress('glProgramLocalParameterI4iNV');
    private ntv_ProgramLocalParameterI4iNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>(ProgramLocalParameterI4iNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4iNV(target: glProgramTarget; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) :=
      ntv_ProgramLocalParameterI4iNV_1(target, index, x, y, z, w);
    
    private ProgramLocalParameterI4ivNV_adr := GetProcAddress('glProgramLocalParameterI4ivNV');
    private ntv_ProgramLocalParameterI4ivNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: Int32)>(ProgramLocalParameterI4ivNV_adr);
    private ntv_ProgramLocalParameterI4ivNV_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: Vec4i)>(ProgramLocalParameterI4ivNV_adr);
    private ntv_ProgramLocalParameterI4ivNV_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(ProgramLocalParameterI4ivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4ivNV(target: glProgramTarget; index: UInt32; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramLocalParameterI4ivNV_1(target, index, &params[0]) else
        ntv_ProgramLocalParameterI4ivNV_1(target, index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4ivNV(target: glProgramTarget; index: UInt32; var &params: Vec4i) :=
      ntv_ProgramLocalParameterI4ivNV_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4ivNV(target: glProgramTarget; index: UInt32; var &params: Int32) :=
      ntv_ProgramLocalParameterI4ivNV_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4ivNV(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_ProgramLocalParameterI4ivNV_3(target, index, &params);
    
    private ProgramLocalParametersI4ivNV_adr := GetProcAddress('glProgramLocalParametersI4ivNV');
    private ntv_ProgramLocalParametersI4ivNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; var &params: Int32)>(ProgramLocalParametersI4ivNV_adr);
    private ntv_ProgramLocalParametersI4ivNV_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4i)>(ProgramLocalParametersI4ivNV_adr);
    private ntv_ProgramLocalParametersI4ivNV_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(ProgramLocalParametersI4ivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4ivNV(target: glProgramTarget; index: UInt32; count: Int32; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramLocalParametersI4ivNV_1(target, index, count, &params[0]) else
        ntv_ProgramLocalParametersI4ivNV_1(target, index, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4ivNV(target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4i) :=
      ntv_ProgramLocalParametersI4ivNV_2(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4ivNV(target: glProgramTarget; index: UInt32; count: Int32; var &params: Int32) :=
      ntv_ProgramLocalParametersI4ivNV_1(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4ivNV(target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
      ntv_ProgramLocalParametersI4ivNV_3(target, index, count, &params);
    
    private ProgramLocalParameterI4uiNV_adr := GetProcAddress('glProgramLocalParameterI4uiNV');
    private ntv_ProgramLocalParameterI4uiNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>(ProgramLocalParameterI4uiNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4uiNV(target: glProgramTarget; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) :=
      ntv_ProgramLocalParameterI4uiNV_1(target, index, x, y, z, w);
    
    private ProgramLocalParameterI4uivNV_adr := GetProcAddress('glProgramLocalParameterI4uivNV');
    private ntv_ProgramLocalParameterI4uivNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: UInt32)>(ProgramLocalParameterI4uivNV_adr);
    private ntv_ProgramLocalParameterI4uivNV_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: Vec4ui)>(ProgramLocalParameterI4uivNV_adr);
    private ntv_ProgramLocalParameterI4uivNV_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(ProgramLocalParameterI4uivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4uivNV(target: glProgramTarget; index: UInt32; &params: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramLocalParameterI4uivNV_1(target, index, &params[0]) else
        ntv_ProgramLocalParameterI4uivNV_1(target, index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4uivNV(target: glProgramTarget; index: UInt32; var &params: Vec4ui) :=
      ntv_ProgramLocalParameterI4uivNV_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4uivNV(target: glProgramTarget; index: UInt32; var &params: UInt32) :=
      ntv_ProgramLocalParameterI4uivNV_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4uivNV(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_ProgramLocalParameterI4uivNV_3(target, index, &params);
    
    private ProgramLocalParametersI4uivNV_adr := GetProcAddress('glProgramLocalParametersI4uivNV');
    private ntv_ProgramLocalParametersI4uivNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; var &params: UInt32)>(ProgramLocalParametersI4uivNV_adr);
    private ntv_ProgramLocalParametersI4uivNV_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4ui)>(ProgramLocalParametersI4uivNV_adr);
    private ntv_ProgramLocalParametersI4uivNV_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(ProgramLocalParametersI4uivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4uivNV(target: glProgramTarget; index: UInt32; count: Int32; &params: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramLocalParametersI4uivNV_1(target, index, count, &params[0]) else
        ntv_ProgramLocalParametersI4uivNV_1(target, index, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4uivNV(target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4ui) :=
      ntv_ProgramLocalParametersI4uivNV_2(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4uivNV(target: glProgramTarget; index: UInt32; count: Int32; var &params: UInt32) :=
      ntv_ProgramLocalParametersI4uivNV_1(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4uivNV(target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
      ntv_ProgramLocalParametersI4uivNV_3(target, index, count, &params);
    
    private ProgramEnvParameterI4iNV_adr := GetProcAddress('glProgramEnvParameterI4iNV');
    private ntv_ProgramEnvParameterI4iNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>(ProgramEnvParameterI4iNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4iNV(target: glProgramTarget; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) :=
      ntv_ProgramEnvParameterI4iNV_1(target, index, x, y, z, w);
    
    private ProgramEnvParameterI4ivNV_adr := GetProcAddress('glProgramEnvParameterI4ivNV');
    private ntv_ProgramEnvParameterI4ivNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: Int32)>(ProgramEnvParameterI4ivNV_adr);
    private ntv_ProgramEnvParameterI4ivNV_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: Vec4i)>(ProgramEnvParameterI4ivNV_adr);
    private ntv_ProgramEnvParameterI4ivNV_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(ProgramEnvParameterI4ivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4ivNV(target: glProgramTarget; index: UInt32; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramEnvParameterI4ivNV_1(target, index, &params[0]) else
        ntv_ProgramEnvParameterI4ivNV_1(target, index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4ivNV(target: glProgramTarget; index: UInt32; var &params: Vec4i) :=
      ntv_ProgramEnvParameterI4ivNV_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4ivNV(target: glProgramTarget; index: UInt32; var &params: Int32) :=
      ntv_ProgramEnvParameterI4ivNV_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4ivNV(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_ProgramEnvParameterI4ivNV_3(target, index, &params);
    
    private ProgramEnvParametersI4ivNV_adr := GetProcAddress('glProgramEnvParametersI4ivNV');
    private ntv_ProgramEnvParametersI4ivNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; var &params: Int32)>(ProgramEnvParametersI4ivNV_adr);
    private ntv_ProgramEnvParametersI4ivNV_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4i)>(ProgramEnvParametersI4ivNV_adr);
    private ntv_ProgramEnvParametersI4ivNV_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(ProgramEnvParametersI4ivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4ivNV(target: glProgramTarget; index: UInt32; count: Int32; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramEnvParametersI4ivNV_1(target, index, count, &params[0]) else
        ntv_ProgramEnvParametersI4ivNV_1(target, index, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4ivNV(target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4i) :=
      ntv_ProgramEnvParametersI4ivNV_2(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4ivNV(target: glProgramTarget; index: UInt32; count: Int32; var &params: Int32) :=
      ntv_ProgramEnvParametersI4ivNV_1(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4ivNV(target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
      ntv_ProgramEnvParametersI4ivNV_3(target, index, count, &params);
    
    private ProgramEnvParameterI4uiNV_adr := GetProcAddress('glProgramEnvParameterI4uiNV');
    private ntv_ProgramEnvParameterI4uiNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>(ProgramEnvParameterI4uiNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4uiNV(target: glProgramTarget; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) :=
      ntv_ProgramEnvParameterI4uiNV_1(target, index, x, y, z, w);
    
    private ProgramEnvParameterI4uivNV_adr := GetProcAddress('glProgramEnvParameterI4uivNV');
    private ntv_ProgramEnvParameterI4uivNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: UInt32)>(ProgramEnvParameterI4uivNV_adr);
    private ntv_ProgramEnvParameterI4uivNV_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: Vec4ui)>(ProgramEnvParameterI4uivNV_adr);
    private ntv_ProgramEnvParameterI4uivNV_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(ProgramEnvParameterI4uivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4uivNV(target: glProgramTarget; index: UInt32; &params: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramEnvParameterI4uivNV_1(target, index, &params[0]) else
        ntv_ProgramEnvParameterI4uivNV_1(target, index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4uivNV(target: glProgramTarget; index: UInt32; var &params: Vec4ui) :=
      ntv_ProgramEnvParameterI4uivNV_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4uivNV(target: glProgramTarget; index: UInt32; var &params: UInt32) :=
      ntv_ProgramEnvParameterI4uivNV_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4uivNV(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_ProgramEnvParameterI4uivNV_3(target, index, &params);
    
    private ProgramEnvParametersI4uivNV_adr := GetProcAddress('glProgramEnvParametersI4uivNV');
    private ntv_ProgramEnvParametersI4uivNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; var &params: UInt32)>(ProgramEnvParametersI4uivNV_adr);
    private ntv_ProgramEnvParametersI4uivNV_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4ui)>(ProgramEnvParametersI4uivNV_adr);
    private ntv_ProgramEnvParametersI4uivNV_3 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(ProgramEnvParametersI4uivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4uivNV(target: glProgramTarget; index: UInt32; count: Int32; &params: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramEnvParametersI4uivNV_1(target, index, count, &params[0]) else
        ntv_ProgramEnvParametersI4uivNV_1(target, index, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4uivNV(target: glProgramTarget; index: UInt32; count: Int32; var &params: Vec4ui) :=
      ntv_ProgramEnvParametersI4uivNV_2(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4uivNV(target: glProgramTarget; index: UInt32; count: Int32; var &params: UInt32) :=
      ntv_ProgramEnvParametersI4uivNV_1(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4uivNV(target: glProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
      ntv_ProgramEnvParametersI4uivNV_3(target, index, count, &params);
    
    private GetProgramLocalParameterIivNV_adr := GetProcAddress('glGetProgramLocalParameterIivNV');
    private ntv_GetProgramLocalParameterIivNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: Int32)>(GetProgramLocalParameterIivNV_adr);
    private ntv_GetProgramLocalParameterIivNV_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(GetProgramLocalParameterIivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIivNV(target: glProgramTarget; index: UInt32; var &params: Int32) :=
      ntv_GetProgramLocalParameterIivNV_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIivNV(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_GetProgramLocalParameterIivNV_2(target, index, &params);
    
    private GetProgramLocalParameterIuivNV_adr := GetProcAddress('glGetProgramLocalParameterIuivNV');
    private ntv_GetProgramLocalParameterIuivNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: UInt32)>(GetProgramLocalParameterIuivNV_adr);
    private ntv_GetProgramLocalParameterIuivNV_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(GetProgramLocalParameterIuivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIuivNV(target: glProgramTarget; index: UInt32; var &params: UInt32) :=
      ntv_GetProgramLocalParameterIuivNV_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIuivNV(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_GetProgramLocalParameterIuivNV_2(target, index, &params);
    
    private GetProgramEnvParameterIivNV_adr := GetProcAddress('glGetProgramEnvParameterIivNV');
    private ntv_GetProgramEnvParameterIivNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: Int32)>(GetProgramEnvParameterIivNV_adr);
    private ntv_GetProgramEnvParameterIivNV_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(GetProgramEnvParameterIivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIivNV(target: glProgramTarget; index: UInt32; var &params: Int32) :=
      ntv_GetProgramEnvParameterIivNV_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIivNV(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_GetProgramEnvParameterIivNV_2(target, index, &params);
    
    private GetProgramEnvParameterIuivNV_adr := GetProcAddress('glGetProgramEnvParameterIuivNV');
    private ntv_GetProgramEnvParameterIuivNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; var &params: UInt32)>(GetProgramEnvParameterIuivNV_adr);
    private ntv_GetProgramEnvParameterIuivNV_2 := GetProcOrNil&<procedure(target: glProgramTarget; index: UInt32; &params: IntPtr)>(GetProgramEnvParameterIuivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIuivNV(target: glProgramTarget; index: UInt32; var &params: UInt32) :=
      ntv_GetProgramEnvParameterIuivNV_1(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIuivNV(target: glProgramTarget; index: UInt32; &params: IntPtr) :=
      ntv_GetProgramEnvParameterIuivNV_2(target, index, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glGpuProgram5NV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_gpu_program5';
    
    private ProgramSubroutineParametersuivNV_adr := GetProcAddress('glProgramSubroutineParametersuivNV');
    private ntv_ProgramSubroutineParametersuivNV_1 := GetProcOrNil&<procedure(target: DummyEnum; count: Int32; var &params: UInt32)>(ProgramSubroutineParametersuivNV_adr);
    private ntv_ProgramSubroutineParametersuivNV_2 := GetProcOrNil&<procedure(target: DummyEnum; count: Int32; &params: IntPtr)>(ProgramSubroutineParametersuivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramSubroutineParametersuivNV(target: DummyEnum; count: Int32; &params: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramSubroutineParametersuivNV_1(target, count, &params[0]) else
        ntv_ProgramSubroutineParametersuivNV_1(target, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramSubroutineParametersuivNV(target: DummyEnum; count: Int32; var &params: UInt32) :=
      ntv_ProgramSubroutineParametersuivNV_1(target, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramSubroutineParametersuivNV(target: DummyEnum; count: Int32; &params: IntPtr) :=
      ntv_ProgramSubroutineParametersuivNV_2(target, count, &params);
    
    private GetProgramSubroutineParameteruivNV_adr := GetProcAddress('glGetProgramSubroutineParameteruivNV');
    private ntv_GetProgramSubroutineParameteruivNV_1 := GetProcOrNil&<procedure(target: DummyEnum; index: UInt32; var param: UInt32)>(GetProgramSubroutineParameteruivNV_adr);
    private ntv_GetProgramSubroutineParameteruivNV_2 := GetProcOrNil&<procedure(target: DummyEnum; index: UInt32; param: IntPtr)>(GetProgramSubroutineParameteruivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramSubroutineParameteruivNV(target: DummyEnum; index: UInt32; var param: UInt32) :=
      ntv_GetProgramSubroutineParameteruivNV_1(target, index, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramSubroutineParameteruivNV(target: DummyEnum; index: UInt32; param: IntPtr) :=
      ntv_GetProgramSubroutineParameteruivNV_2(target, index, param);
    
  end;
  
  ///
  glGpuProgram5MemExtendedNV = static class
    public const _ExtStr = 'GL_NV_gpu_program5_mem_extended';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glGpuShader5NV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_gpu_shader5';
    
    private Uniform1i64NV_adr := GetProcAddress('glUniform1i64NV');
    private ntv_Uniform1i64NV_1 := GetProcOrNil&<procedure(location: Int32; x: Int64)>(Uniform1i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64NV(location: Int32; x: Int64) :=
      ntv_Uniform1i64NV_1(location, x);
    
    private Uniform2i64NV_adr := GetProcAddress('glUniform2i64NV');
    private ntv_Uniform2i64NV_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64)>(Uniform2i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64NV(location: Int32; x: Int64; y: Int64) :=
      ntv_Uniform2i64NV_1(location, x, y);
    
    private Uniform3i64NV_adr := GetProcAddress('glUniform3i64NV');
    private ntv_Uniform3i64NV_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64)>(Uniform3i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64NV(location: Int32; x: Int64; y: Int64; z: Int64) :=
      ntv_Uniform3i64NV_1(location, x, y, z);
    
    private Uniform4i64NV_adr := GetProcAddress('glUniform4i64NV');
    private ntv_Uniform4i64NV_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>(Uniform4i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64NV(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) :=
      ntv_Uniform4i64NV_1(location, x, y, z, w);
    
    private Uniform1i64vNV_adr := GetProcAddress('glUniform1i64vNV');
    private ntv_Uniform1i64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(Uniform1i64vNV_adr);
    private ntv_Uniform1i64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform1i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vNV(location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform1i64vNV_1(location, count, value[0]) else
        ntv_Uniform1i64vNV_1(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vNV(location: Int32; count: Int32; var value: Int64) :=
      ntv_Uniform1i64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform1i64vNV_2(location, count, value);
    
    private Uniform2i64vNV_adr := GetProcAddress('glUniform2i64vNV');
    private ntv_Uniform2i64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(Uniform2i64vNV_adr);
    private ntv_Uniform2i64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2i64)>(Uniform2i64vNV_adr);
    private ntv_Uniform2i64vNV_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform2i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vNV(location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform2i64vNV_1(location, count, value[0]) else
        ntv_Uniform2i64vNV_1(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vNV(location: Int32; count: Int32; var value: Vec2i64) :=
      ntv_Uniform2i64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vNV(location: Int32; count: Int32; var value: Int64) :=
      ntv_Uniform2i64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform2i64vNV_3(location, count, value);
    
    private Uniform3i64vNV_adr := GetProcAddress('glUniform3i64vNV');
    private ntv_Uniform3i64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(Uniform3i64vNV_adr);
    private ntv_Uniform3i64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3i64)>(Uniform3i64vNV_adr);
    private ntv_Uniform3i64vNV_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform3i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vNV(location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform3i64vNV_1(location, count, value[0]) else
        ntv_Uniform3i64vNV_1(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vNV(location: Int32; count: Int32; var value: Vec3i64) :=
      ntv_Uniform3i64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vNV(location: Int32; count: Int32; var value: Int64) :=
      ntv_Uniform3i64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform3i64vNV_3(location, count, value);
    
    private Uniform4i64vNV_adr := GetProcAddress('glUniform4i64vNV');
    private ntv_Uniform4i64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(Uniform4i64vNV_adr);
    private ntv_Uniform4i64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4i64)>(Uniform4i64vNV_adr);
    private ntv_Uniform4i64vNV_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform4i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vNV(location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform4i64vNV_1(location, count, value[0]) else
        ntv_Uniform4i64vNV_1(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vNV(location: Int32; count: Int32; var value: Vec4i64) :=
      ntv_Uniform4i64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vNV(location: Int32; count: Int32; var value: Int64) :=
      ntv_Uniform4i64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform4i64vNV_3(location, count, value);
    
    private Uniform1ui64NV_adr := GetProcAddress('glUniform1ui64NV');
    private ntv_Uniform1ui64NV_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64)>(Uniform1ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64NV(location: Int32; x: UInt64) :=
      ntv_Uniform1ui64NV_1(location, x);
    
    private Uniform2ui64NV_adr := GetProcAddress('glUniform2ui64NV');
    private ntv_Uniform2ui64NV_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64)>(Uniform2ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64NV(location: Int32; x: UInt64; y: UInt64) :=
      ntv_Uniform2ui64NV_1(location, x, y);
    
    private Uniform3ui64NV_adr := GetProcAddress('glUniform3ui64NV');
    private ntv_Uniform3ui64NV_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64)>(Uniform3ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64NV(location: Int32; x: UInt64; y: UInt64; z: UInt64) :=
      ntv_Uniform3ui64NV_1(location, x, y, z);
    
    private Uniform4ui64NV_adr := GetProcAddress('glUniform4ui64NV');
    private ntv_Uniform4ui64NV_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>(Uniform4ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64NV(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) :=
      ntv_Uniform4ui64NV_1(location, x, y, z, w);
    
    private Uniform1ui64vNV_adr := GetProcAddress('glUniform1ui64vNV');
    private ntv_Uniform1ui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(Uniform1ui64vNV_adr);
    private ntv_Uniform1ui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform1ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform1ui64vNV_1(location, count, value[0]) else
        ntv_Uniform1ui64vNV_1(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vNV(location: Int32; count: Int32; var value: UInt64) :=
      ntv_Uniform1ui64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform1ui64vNV_2(location, count, value);
    
    private Uniform2ui64vNV_adr := GetProcAddress('glUniform2ui64vNV');
    private ntv_Uniform2ui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(Uniform2ui64vNV_adr);
    private ntv_Uniform2ui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2ui64)>(Uniform2ui64vNV_adr);
    private ntv_Uniform2ui64vNV_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform2ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform2ui64vNV_1(location, count, value[0]) else
        ntv_Uniform2ui64vNV_1(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vNV(location: Int32; count: Int32; var value: Vec2ui64) :=
      ntv_Uniform2ui64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vNV(location: Int32; count: Int32; var value: UInt64) :=
      ntv_Uniform2ui64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform2ui64vNV_3(location, count, value);
    
    private Uniform3ui64vNV_adr := GetProcAddress('glUniform3ui64vNV');
    private ntv_Uniform3ui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(Uniform3ui64vNV_adr);
    private ntv_Uniform3ui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3ui64)>(Uniform3ui64vNV_adr);
    private ntv_Uniform3ui64vNV_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform3ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform3ui64vNV_1(location, count, value[0]) else
        ntv_Uniform3ui64vNV_1(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vNV(location: Int32; count: Int32; var value: Vec3ui64) :=
      ntv_Uniform3ui64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vNV(location: Int32; count: Int32; var value: UInt64) :=
      ntv_Uniform3ui64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform3ui64vNV_3(location, count, value);
    
    private Uniform4ui64vNV_adr := GetProcAddress('glUniform4ui64vNV');
    private ntv_Uniform4ui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(Uniform4ui64vNV_adr);
    private ntv_Uniform4ui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4ui64)>(Uniform4ui64vNV_adr);
    private ntv_Uniform4ui64vNV_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform4ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform4ui64vNV_1(location, count, value[0]) else
        ntv_Uniform4ui64vNV_1(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vNV(location: Int32; count: Int32; var value: Vec4ui64) :=
      ntv_Uniform4ui64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vNV(location: Int32; count: Int32; var value: UInt64) :=
      ntv_Uniform4ui64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform4ui64vNV_3(location, count, value);
    
    private GetUniformi64vNV_adr := GetProcAddress('glGetUniformi64vNV');
    private ntv_GetUniformi64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: Int64)>(GetUniformi64vNV_adr);
    private ntv_GetUniformi64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(GetUniformi64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vNV(&program: gl_program; location: Int32; var &params: Int64) :=
      ntv_GetUniformi64vNV_1(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vNV(&program: gl_program; location: Int32; &params: IntPtr) :=
      ntv_GetUniformi64vNV_2(&program, location, &params);
    
    private ProgramUniform1i64NV_adr := GetProcAddress('glProgramUniform1i64NV');
    private ntv_ProgramUniform1i64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64)>(ProgramUniform1i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64NV(&program: gl_program; location: Int32; x: Int64) :=
      ntv_ProgramUniform1i64NV_1(&program, location, x);
    
    private ProgramUniform2i64NV_adr := GetProcAddress('glProgramUniform2i64NV');
    private ntv_ProgramUniform2i64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64)>(ProgramUniform2i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64NV(&program: gl_program; location: Int32; x: Int64; y: Int64) :=
      ntv_ProgramUniform2i64NV_1(&program, location, x, y);
    
    private ProgramUniform3i64NV_adr := GetProcAddress('glProgramUniform3i64NV');
    private ntv_ProgramUniform3i64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64)>(ProgramUniform3i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64NV(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64) :=
      ntv_ProgramUniform3i64NV_1(&program, location, x, y, z);
    
    private ProgramUniform4i64NV_adr := GetProcAddress('glProgramUniform4i64NV');
    private ntv_ProgramUniform4i64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>(ProgramUniform4i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64NV(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) :=
      ntv_ProgramUniform4i64NV_1(&program, location, x, y, z, w);
    
    private ProgramUniform1i64vNV_adr := GetProcAddress('glProgramUniform1i64vNV');
    private ntv_ProgramUniform1i64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(ProgramUniform1i64vNV_adr);
    private ntv_ProgramUniform1i64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vNV(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1i64vNV_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1i64vNV_1(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
      ntv_ProgramUniform1i64vNV_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1i64vNV_2(&program, location, count, value);
    
    private ProgramUniform2i64vNV_adr := GetProcAddress('glProgramUniform2i64vNV');
    private ntv_ProgramUniform2i64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(ProgramUniform2i64vNV_adr);
    private ntv_ProgramUniform2i64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2i64)>(ProgramUniform2i64vNV_adr);
    private ntv_ProgramUniform2i64vNV_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vNV(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2i64vNV_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2i64vNV_1(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Vec2i64) :=
      ntv_ProgramUniform2i64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
      ntv_ProgramUniform2i64vNV_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2i64vNV_3(&program, location, count, value);
    
    private ProgramUniform3i64vNV_adr := GetProcAddress('glProgramUniform3i64vNV');
    private ntv_ProgramUniform3i64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(ProgramUniform3i64vNV_adr);
    private ntv_ProgramUniform3i64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3i64)>(ProgramUniform3i64vNV_adr);
    private ntv_ProgramUniform3i64vNV_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vNV(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3i64vNV_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3i64vNV_1(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Vec3i64) :=
      ntv_ProgramUniform3i64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
      ntv_ProgramUniform3i64vNV_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3i64vNV_3(&program, location, count, value);
    
    private ProgramUniform4i64vNV_adr := GetProcAddress('glProgramUniform4i64vNV');
    private ntv_ProgramUniform4i64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(ProgramUniform4i64vNV_adr);
    private ntv_ProgramUniform4i64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4i64)>(ProgramUniform4i64vNV_adr);
    private ntv_ProgramUniform4i64vNV_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vNV(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4i64vNV_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4i64vNV_1(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Vec4i64) :=
      ntv_ProgramUniform4i64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
      ntv_ProgramUniform4i64vNV_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4i64vNV_3(&program, location, count, value);
    
    private ProgramUniform1ui64NV_adr := GetProcAddress('glProgramUniform1ui64NV');
    private ntv_ProgramUniform1ui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64)>(ProgramUniform1ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64NV(&program: gl_program; location: Int32; x: UInt64) :=
      ntv_ProgramUniform1ui64NV_1(&program, location, x);
    
    private ProgramUniform2ui64NV_adr := GetProcAddress('glProgramUniform2ui64NV');
    private ntv_ProgramUniform2ui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64)>(ProgramUniform2ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64NV(&program: gl_program; location: Int32; x: UInt64; y: UInt64) :=
      ntv_ProgramUniform2ui64NV_1(&program, location, x, y);
    
    private ProgramUniform3ui64NV_adr := GetProcAddress('glProgramUniform3ui64NV');
    private ntv_ProgramUniform3ui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64)>(ProgramUniform3ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64NV(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64) :=
      ntv_ProgramUniform3ui64NV_1(&program, location, x, y, z);
    
    private ProgramUniform4ui64NV_adr := GetProcAddress('glProgramUniform4ui64NV');
    private ntv_ProgramUniform4ui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>(ProgramUniform4ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64NV(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) :=
      ntv_ProgramUniform4ui64NV_1(&program, location, x, y, z, w);
    
    private ProgramUniform1ui64vNV_adr := GetProcAddress('glProgramUniform1ui64vNV');
    private ntv_ProgramUniform1ui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(ProgramUniform1ui64vNV_adr);
    private ntv_ProgramUniform1ui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1ui64vNV_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1ui64vNV_1(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
      ntv_ProgramUniform1ui64vNV_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1ui64vNV_2(&program, location, count, value);
    
    private ProgramUniform2ui64vNV_adr := GetProcAddress('glProgramUniform2ui64vNV');
    private ntv_ProgramUniform2ui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(ProgramUniform2ui64vNV_adr);
    private ntv_ProgramUniform2ui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2ui64)>(ProgramUniform2ui64vNV_adr);
    private ntv_ProgramUniform2ui64vNV_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2ui64vNV_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2ui64vNV_1(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: Vec2ui64) :=
      ntv_ProgramUniform2ui64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
      ntv_ProgramUniform2ui64vNV_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2ui64vNV_3(&program, location, count, value);
    
    private ProgramUniform3ui64vNV_adr := GetProcAddress('glProgramUniform3ui64vNV');
    private ntv_ProgramUniform3ui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(ProgramUniform3ui64vNV_adr);
    private ntv_ProgramUniform3ui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3ui64)>(ProgramUniform3ui64vNV_adr);
    private ntv_ProgramUniform3ui64vNV_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3ui64vNV_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3ui64vNV_1(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: Vec3ui64) :=
      ntv_ProgramUniform3ui64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
      ntv_ProgramUniform3ui64vNV_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3ui64vNV_3(&program, location, count, value);
    
    private ProgramUniform4ui64vNV_adr := GetProcAddress('glProgramUniform4ui64vNV');
    private ntv_ProgramUniform4ui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(ProgramUniform4ui64vNV_adr);
    private ntv_ProgramUniform4ui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4ui64)>(ProgramUniform4ui64vNV_adr);
    private ntv_ProgramUniform4ui64vNV_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4ui64vNV_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4ui64vNV_1(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: Vec4ui64) :=
      ntv_ProgramUniform4ui64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
      ntv_ProgramUniform4ui64vNV_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4ui64vNV_3(&program, location, count, value);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glHalfFloatNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_half_float';
    
    private Vertex2hNV_adr := GetProcAddress('glVertex2hNV');
    private ntv_Vertex2hNV_1 := GetProcOrNil&<procedure(x: gl_half; y: gl_half)>(Vertex2hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2hNV(x: gl_half; y: gl_half) :=
      ntv_Vertex2hNV_1(x, y);
    
    private Vertex2hvNV_adr := GetProcAddress('glVertex2hvNV');
    private ntv_Vertex2hvNV_1 := GetProcOrNil&<procedure(var v: gl_half)>(Vertex2hvNV_adr);
    private ntv_Vertex2hvNV_2 := GetProcOrNil&<procedure(v: IntPtr)>(Vertex2hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2hvNV(v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Vertex2hvNV_1(v[0]) else
        ntv_Vertex2hvNV_1(PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2hvNV(var v: gl_half) :=
      ntv_Vertex2hvNV_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2hvNV(v: IntPtr) :=
      ntv_Vertex2hvNV_2(v);
    
    private Vertex3hNV_adr := GetProcAddress('glVertex3hNV');
    private ntv_Vertex3hNV_1 := GetProcOrNil&<procedure(x: gl_half; y: gl_half; z: gl_half)>(Vertex3hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3hNV(x: gl_half; y: gl_half; z: gl_half) :=
      ntv_Vertex3hNV_1(x, y, z);
    
    private Vertex3hvNV_adr := GetProcAddress('glVertex3hvNV');
    private ntv_Vertex3hvNV_1 := GetProcOrNil&<procedure(var v: gl_half)>(Vertex3hvNV_adr);
    private ntv_Vertex3hvNV_2 := GetProcOrNil&<procedure(v: IntPtr)>(Vertex3hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3hvNV(v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Vertex3hvNV_1(v[0]) else
        ntv_Vertex3hvNV_1(PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3hvNV(var v: gl_half) :=
      ntv_Vertex3hvNV_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3hvNV(v: IntPtr) :=
      ntv_Vertex3hvNV_2(v);
    
    private Vertex4hNV_adr := GetProcAddress('glVertex4hNV');
    private ntv_Vertex4hNV_1 := GetProcOrNil&<procedure(x: gl_half; y: gl_half; z: gl_half; w: gl_half)>(Vertex4hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4hNV(x: gl_half; y: gl_half; z: gl_half; w: gl_half) :=
      ntv_Vertex4hNV_1(x, y, z, w);
    
    private Vertex4hvNV_adr := GetProcAddress('glVertex4hvNV');
    private ntv_Vertex4hvNV_1 := GetProcOrNil&<procedure(var v: gl_half)>(Vertex4hvNV_adr);
    private ntv_Vertex4hvNV_2 := GetProcOrNil&<procedure(v: IntPtr)>(Vertex4hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4hvNV(v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Vertex4hvNV_1(v[0]) else
        ntv_Vertex4hvNV_1(PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4hvNV(var v: gl_half) :=
      ntv_Vertex4hvNV_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4hvNV(v: IntPtr) :=
      ntv_Vertex4hvNV_2(v);
    
    private Normal3hNV_adr := GetProcAddress('glNormal3hNV');
    private ntv_Normal3hNV_1 := GetProcOrNil&<procedure(nx: gl_half; ny: gl_half; nz: gl_half)>(Normal3hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3hNV(nx: gl_half; ny: gl_half; nz: gl_half) :=
      ntv_Normal3hNV_1(nx, ny, nz);
    
    private Normal3hvNV_adr := GetProcAddress('glNormal3hvNV');
    private ntv_Normal3hvNV_1 := GetProcOrNil&<procedure(var v: gl_half)>(Normal3hvNV_adr);
    private ntv_Normal3hvNV_2 := GetProcOrNil&<procedure(v: IntPtr)>(Normal3hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3hvNV(v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Normal3hvNV_1(v[0]) else
        ntv_Normal3hvNV_1(PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3hvNV(var v: gl_half) :=
      ntv_Normal3hvNV_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3hvNV(v: IntPtr) :=
      ntv_Normal3hvNV_2(v);
    
    private Color3hNV_adr := GetProcAddress('glColor3hNV');
    private ntv_Color3hNV_1 := GetProcOrNil&<procedure(red: gl_half; green: gl_half; blue: gl_half)>(Color3hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3hNV(red: gl_half; green: gl_half; blue: gl_half) :=
      ntv_Color3hNV_1(red, green, blue);
    
    private Color3hvNV_adr := GetProcAddress('glColor3hvNV');
    private ntv_Color3hvNV_1 := GetProcOrNil&<procedure(var v: gl_half)>(Color3hvNV_adr);
    private ntv_Color3hvNV_2 := GetProcOrNil&<procedure(v: IntPtr)>(Color3hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3hvNV(v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color3hvNV_1(v[0]) else
        ntv_Color3hvNV_1(PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3hvNV(var v: gl_half) :=
      ntv_Color3hvNV_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3hvNV(v: IntPtr) :=
      ntv_Color3hvNV_2(v);
    
    private Color4hNV_adr := GetProcAddress('glColor4hNV');
    private ntv_Color4hNV_1 := GetProcOrNil&<procedure(red: gl_half; green: gl_half; blue: gl_half; alpha: gl_half)>(Color4hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4hNV(red: gl_half; green: gl_half; blue: gl_half; alpha: gl_half) :=
      ntv_Color4hNV_1(red, green, blue, alpha);
    
    private Color4hvNV_adr := GetProcAddress('glColor4hvNV');
    private ntv_Color4hvNV_1 := GetProcOrNil&<procedure(var v: gl_half)>(Color4hvNV_adr);
    private ntv_Color4hvNV_2 := GetProcOrNil&<procedure(v: IntPtr)>(Color4hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4hvNV(v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color4hvNV_1(v[0]) else
        ntv_Color4hvNV_1(PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4hvNV(var v: gl_half) :=
      ntv_Color4hvNV_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4hvNV(v: IntPtr) :=
      ntv_Color4hvNV_2(v);
    
    private TexCoord1hNV_adr := GetProcAddress('glTexCoord1hNV');
    private ntv_TexCoord1hNV_1 := GetProcOrNil&<procedure(s: gl_half)>(TexCoord1hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1hNV(s: gl_half) :=
      ntv_TexCoord1hNV_1(s);
    
    private TexCoord1hvNV_adr := GetProcAddress('glTexCoord1hvNV');
    private ntv_TexCoord1hvNV_1 := GetProcOrNil&<procedure(var v: gl_half)>(TexCoord1hvNV_adr);
    private ntv_TexCoord1hvNV_2 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord1hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1hvNV(v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord1hvNV_1(v[0]) else
        ntv_TexCoord1hvNV_1(PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1hvNV(var v: gl_half) :=
      ntv_TexCoord1hvNV_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1hvNV(v: IntPtr) :=
      ntv_TexCoord1hvNV_2(v);
    
    private TexCoord2hNV_adr := GetProcAddress('glTexCoord2hNV');
    private ntv_TexCoord2hNV_1 := GetProcOrNil&<procedure(s: gl_half; t: gl_half)>(TexCoord2hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2hNV(s: gl_half; t: gl_half) :=
      ntv_TexCoord2hNV_1(s, t);
    
    private TexCoord2hvNV_adr := GetProcAddress('glTexCoord2hvNV');
    private ntv_TexCoord2hvNV_1 := GetProcOrNil&<procedure(var v: gl_half)>(TexCoord2hvNV_adr);
    private ntv_TexCoord2hvNV_2 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord2hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2hvNV(v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord2hvNV_1(v[0]) else
        ntv_TexCoord2hvNV_1(PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2hvNV(var v: gl_half) :=
      ntv_TexCoord2hvNV_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2hvNV(v: IntPtr) :=
      ntv_TexCoord2hvNV_2(v);
    
    private TexCoord3hNV_adr := GetProcAddress('glTexCoord3hNV');
    private ntv_TexCoord3hNV_1 := GetProcOrNil&<procedure(s: gl_half; t: gl_half; r: gl_half)>(TexCoord3hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3hNV(s: gl_half; t: gl_half; r: gl_half) :=
      ntv_TexCoord3hNV_1(s, t, r);
    
    private TexCoord3hvNV_adr := GetProcAddress('glTexCoord3hvNV');
    private ntv_TexCoord3hvNV_1 := GetProcOrNil&<procedure(var v: gl_half)>(TexCoord3hvNV_adr);
    private ntv_TexCoord3hvNV_2 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord3hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3hvNV(v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord3hvNV_1(v[0]) else
        ntv_TexCoord3hvNV_1(PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3hvNV(var v: gl_half) :=
      ntv_TexCoord3hvNV_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3hvNV(v: IntPtr) :=
      ntv_TexCoord3hvNV_2(v);
    
    private TexCoord4hNV_adr := GetProcAddress('glTexCoord4hNV');
    private ntv_TexCoord4hNV_1 := GetProcOrNil&<procedure(s: gl_half; t: gl_half; r: gl_half; q: gl_half)>(TexCoord4hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4hNV(s: gl_half; t: gl_half; r: gl_half; q: gl_half) :=
      ntv_TexCoord4hNV_1(s, t, r, q);
    
    private TexCoord4hvNV_adr := GetProcAddress('glTexCoord4hvNV');
    private ntv_TexCoord4hvNV_1 := GetProcOrNil&<procedure(var v: gl_half)>(TexCoord4hvNV_adr);
    private ntv_TexCoord4hvNV_2 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord4hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4hvNV(v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord4hvNV_1(v[0]) else
        ntv_TexCoord4hvNV_1(PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4hvNV(var v: gl_half) :=
      ntv_TexCoord4hvNV_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4hvNV(v: IntPtr) :=
      ntv_TexCoord4hvNV_2(v);
    
    private MultiTexCoord1hNV_adr := GetProcAddress('glMultiTexCoord1hNV');
    private ntv_MultiTexCoord1hNV_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: gl_half)>(MultiTexCoord1hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1hNV(target: glTextureUnit; s: gl_half) :=
      ntv_MultiTexCoord1hNV_1(target, s);
    
    private MultiTexCoord1hvNV_adr := GetProcAddress('glMultiTexCoord1hvNV');
    private ntv_MultiTexCoord1hvNV_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: gl_half)>(MultiTexCoord1hvNV_adr);
    private ntv_MultiTexCoord1hvNV_2 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord1hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1hvNV(target: glTextureUnit; v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord1hvNV_1(target, v[0]) else
        ntv_MultiTexCoord1hvNV_1(target, PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1hvNV(target: glTextureUnit; var v: gl_half) :=
      ntv_MultiTexCoord1hvNV_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1hvNV(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord1hvNV_2(target, v);
    
    private MultiTexCoord2hNV_adr := GetProcAddress('glMultiTexCoord2hNV');
    private ntv_MultiTexCoord2hNV_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: gl_half; t: gl_half)>(MultiTexCoord2hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2hNV(target: glTextureUnit; s: gl_half; t: gl_half) :=
      ntv_MultiTexCoord2hNV_1(target, s, t);
    
    private MultiTexCoord2hvNV_adr := GetProcAddress('glMultiTexCoord2hvNV');
    private ntv_MultiTexCoord2hvNV_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: gl_half)>(MultiTexCoord2hvNV_adr);
    private ntv_MultiTexCoord2hvNV_2 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord2hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2hvNV(target: glTextureUnit; v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord2hvNV_1(target, v[0]) else
        ntv_MultiTexCoord2hvNV_1(target, PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2hvNV(target: glTextureUnit; var v: gl_half) :=
      ntv_MultiTexCoord2hvNV_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2hvNV(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord2hvNV_2(target, v);
    
    private MultiTexCoord3hNV_adr := GetProcAddress('glMultiTexCoord3hNV');
    private ntv_MultiTexCoord3hNV_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: gl_half; t: gl_half; r: gl_half)>(MultiTexCoord3hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3hNV(target: glTextureUnit; s: gl_half; t: gl_half; r: gl_half) :=
      ntv_MultiTexCoord3hNV_1(target, s, t, r);
    
    private MultiTexCoord3hvNV_adr := GetProcAddress('glMultiTexCoord3hvNV');
    private ntv_MultiTexCoord3hvNV_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: gl_half)>(MultiTexCoord3hvNV_adr);
    private ntv_MultiTexCoord3hvNV_2 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord3hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3hvNV(target: glTextureUnit; v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord3hvNV_1(target, v[0]) else
        ntv_MultiTexCoord3hvNV_1(target, PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3hvNV(target: glTextureUnit; var v: gl_half) :=
      ntv_MultiTexCoord3hvNV_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3hvNV(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord3hvNV_2(target, v);
    
    private MultiTexCoord4hNV_adr := GetProcAddress('glMultiTexCoord4hNV');
    private ntv_MultiTexCoord4hNV_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: gl_half; t: gl_half; r: gl_half; q: gl_half)>(MultiTexCoord4hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4hNV(target: glTextureUnit; s: gl_half; t: gl_half; r: gl_half; q: gl_half) :=
      ntv_MultiTexCoord4hNV_1(target, s, t, r, q);
    
    private MultiTexCoord4hvNV_adr := GetProcAddress('glMultiTexCoord4hvNV');
    private ntv_MultiTexCoord4hvNV_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: gl_half)>(MultiTexCoord4hvNV_adr);
    private ntv_MultiTexCoord4hvNV_2 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord4hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4hvNV(target: glTextureUnit; v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord4hvNV_1(target, v[0]) else
        ntv_MultiTexCoord4hvNV_1(target, PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4hvNV(target: glTextureUnit; var v: gl_half) :=
      ntv_MultiTexCoord4hvNV_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4hvNV(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord4hvNV_2(target, v);
    
    private VertexAttrib1hNV_adr := GetProcAddress('glVertexAttrib1hNV');
    private ntv_VertexAttrib1hNV_1 := GetProcOrNil&<procedure(index: UInt32; x: gl_half)>(VertexAttrib1hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1hNV(index: UInt32; x: gl_half) :=
      ntv_VertexAttrib1hNV_1(index, x);
    
    private VertexAttrib1hvNV_adr := GetProcAddress('glVertexAttrib1hvNV');
    private ntv_VertexAttrib1hvNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: gl_half)>(VertexAttrib1hvNV_adr);
    private ntv_VertexAttrib1hvNV_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib1hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1hvNV(index: UInt32; v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib1hvNV_1(index, v[0]) else
        ntv_VertexAttrib1hvNV_1(index, PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1hvNV(index: UInt32; var v: gl_half) :=
      ntv_VertexAttrib1hvNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1hvNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib1hvNV_2(index, v);
    
    private VertexAttrib2hNV_adr := GetProcAddress('glVertexAttrib2hNV');
    private ntv_VertexAttrib2hNV_1 := GetProcOrNil&<procedure(index: UInt32; x: gl_half; y: gl_half)>(VertexAttrib2hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2hNV(index: UInt32; x: gl_half; y: gl_half) :=
      ntv_VertexAttrib2hNV_1(index, x, y);
    
    private VertexAttrib2hvNV_adr := GetProcAddress('glVertexAttrib2hvNV');
    private ntv_VertexAttrib2hvNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: gl_half)>(VertexAttrib2hvNV_adr);
    private ntv_VertexAttrib2hvNV_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib2hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2hvNV(index: UInt32; v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib2hvNV_1(index, v[0]) else
        ntv_VertexAttrib2hvNV_1(index, PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2hvNV(index: UInt32; var v: gl_half) :=
      ntv_VertexAttrib2hvNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2hvNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib2hvNV_2(index, v);
    
    private VertexAttrib3hNV_adr := GetProcAddress('glVertexAttrib3hNV');
    private ntv_VertexAttrib3hNV_1 := GetProcOrNil&<procedure(index: UInt32; x: gl_half; y: gl_half; z: gl_half)>(VertexAttrib3hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3hNV(index: UInt32; x: gl_half; y: gl_half; z: gl_half) :=
      ntv_VertexAttrib3hNV_1(index, x, y, z);
    
    private VertexAttrib3hvNV_adr := GetProcAddress('glVertexAttrib3hvNV');
    private ntv_VertexAttrib3hvNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: gl_half)>(VertexAttrib3hvNV_adr);
    private ntv_VertexAttrib3hvNV_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib3hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3hvNV(index: UInt32; v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib3hvNV_1(index, v[0]) else
        ntv_VertexAttrib3hvNV_1(index, PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3hvNV(index: UInt32; var v: gl_half) :=
      ntv_VertexAttrib3hvNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3hvNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib3hvNV_2(index, v);
    
    private VertexAttrib4hNV_adr := GetProcAddress('glVertexAttrib4hNV');
    private ntv_VertexAttrib4hNV_1 := GetProcOrNil&<procedure(index: UInt32; x: gl_half; y: gl_half; z: gl_half; w: gl_half)>(VertexAttrib4hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4hNV(index: UInt32; x: gl_half; y: gl_half; z: gl_half; w: gl_half) :=
      ntv_VertexAttrib4hNV_1(index, x, y, z, w);
    
    private VertexAttrib4hvNV_adr := GetProcAddress('glVertexAttrib4hvNV');
    private ntv_VertexAttrib4hvNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: gl_half)>(VertexAttrib4hvNV_adr);
    private ntv_VertexAttrib4hvNV_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4hvNV(index: UInt32; v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4hvNV_1(index, v[0]) else
        ntv_VertexAttrib4hvNV_1(index, PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4hvNV(index: UInt32; var v: gl_half) :=
      ntv_VertexAttrib4hvNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4hvNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4hvNV_2(index, v);
    
    private VertexAttribs1hvNV_adr := GetProcAddress('glVertexAttribs1hvNV');
    private ntv_VertexAttribs1hvNV_1 := GetProcOrNil&<procedure(index: UInt32; n: Int32; var v: gl_half)>(VertexAttribs1hvNV_adr);
    private ntv_VertexAttribs1hvNV_2 := GetProcOrNil&<procedure(index: UInt32; n: Int32; v: IntPtr)>(VertexAttribs1hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1hvNV(index: UInt32; n: Int32; v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribs1hvNV_1(index, n, v[0]) else
        ntv_VertexAttribs1hvNV_1(index, n, PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1hvNV(index: UInt32; n: Int32; var v: gl_half) :=
      ntv_VertexAttribs1hvNV_1(index, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1hvNV(index: UInt32; n: Int32; v: IntPtr) :=
      ntv_VertexAttribs1hvNV_2(index, n, v);
    
    private VertexAttribs2hvNV_adr := GetProcAddress('glVertexAttribs2hvNV');
    private ntv_VertexAttribs2hvNV_1 := GetProcOrNil&<procedure(index: UInt32; n: Int32; var v: gl_half)>(VertexAttribs2hvNV_adr);
    private ntv_VertexAttribs2hvNV_2 := GetProcOrNil&<procedure(index: UInt32; n: Int32; v: IntPtr)>(VertexAttribs2hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2hvNV(index: UInt32; n: Int32; v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribs2hvNV_1(index, n, v[0]) else
        ntv_VertexAttribs2hvNV_1(index, n, PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2hvNV(index: UInt32; n: Int32; var v: gl_half) :=
      ntv_VertexAttribs2hvNV_1(index, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2hvNV(index: UInt32; n: Int32; v: IntPtr) :=
      ntv_VertexAttribs2hvNV_2(index, n, v);
    
    private VertexAttribs3hvNV_adr := GetProcAddress('glVertexAttribs3hvNV');
    private ntv_VertexAttribs3hvNV_1 := GetProcOrNil&<procedure(index: UInt32; n: Int32; var v: gl_half)>(VertexAttribs3hvNV_adr);
    private ntv_VertexAttribs3hvNV_2 := GetProcOrNil&<procedure(index: UInt32; n: Int32; v: IntPtr)>(VertexAttribs3hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3hvNV(index: UInt32; n: Int32; v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribs3hvNV_1(index, n, v[0]) else
        ntv_VertexAttribs3hvNV_1(index, n, PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3hvNV(index: UInt32; n: Int32; var v: gl_half) :=
      ntv_VertexAttribs3hvNV_1(index, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3hvNV(index: UInt32; n: Int32; v: IntPtr) :=
      ntv_VertexAttribs3hvNV_2(index, n, v);
    
    private VertexAttribs4hvNV_adr := GetProcAddress('glVertexAttribs4hvNV');
    private ntv_VertexAttribs4hvNV_1 := GetProcOrNil&<procedure(index: UInt32; n: Int32; var v: gl_half)>(VertexAttribs4hvNV_adr);
    private ntv_VertexAttribs4hvNV_2 := GetProcOrNil&<procedure(index: UInt32; n: Int32; v: IntPtr)>(VertexAttribs4hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4hvNV(index: UInt32; n: Int32; v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribs4hvNV_1(index, n, v[0]) else
        ntv_VertexAttribs4hvNV_1(index, n, PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4hvNV(index: UInt32; n: Int32; var v: gl_half) :=
      ntv_VertexAttribs4hvNV_1(index, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4hvNV(index: UInt32; n: Int32; v: IntPtr) :=
      ntv_VertexAttribs4hvNV_2(index, n, v);
    
    private FogCoordhNV_adr := GetProcAddress('glFogCoordhNV');
    private ntv_FogCoordhNV_1 := GetProcOrNil&<procedure(fog: gl_half)>(FogCoordhNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordhNV(fog: gl_half) :=
      ntv_FogCoordhNV_1(fog);
    
    private FogCoordhvNV_adr := GetProcAddress('glFogCoordhvNV');
    private ntv_FogCoordhvNV_1 := GetProcOrNil&<procedure(var fog: gl_half)>(FogCoordhvNV_adr);
    private ntv_FogCoordhvNV_2 := GetProcOrNil&<procedure(fog: IntPtr)>(FogCoordhvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordhvNV(fog: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (fog<>nil) and (fog.Length<>0) then
        ntv_FogCoordhvNV_1(fog[0]) else
        ntv_FogCoordhvNV_1(PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordhvNV(var fog: gl_half) :=
      ntv_FogCoordhvNV_1(fog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordhvNV(fog: IntPtr) :=
      ntv_FogCoordhvNV_2(fog);
    
    private SecondaryColor3hNV_adr := GetProcAddress('glSecondaryColor3hNV');
    private ntv_SecondaryColor3hNV_1 := GetProcOrNil&<procedure(red: gl_half; green: gl_half; blue: gl_half)>(SecondaryColor3hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3hNV(red: gl_half; green: gl_half; blue: gl_half) :=
      ntv_SecondaryColor3hNV_1(red, green, blue);
    
    private SecondaryColor3hvNV_adr := GetProcAddress('glSecondaryColor3hvNV');
    private ntv_SecondaryColor3hvNV_1 := GetProcOrNil&<procedure(var v: gl_half)>(SecondaryColor3hvNV_adr);
    private ntv_SecondaryColor3hvNV_2 := GetProcOrNil&<procedure(v: IntPtr)>(SecondaryColor3hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3hvNV(v: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_SecondaryColor3hvNV_1(v[0]) else
        ntv_SecondaryColor3hvNV_1(PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3hvNV(var v: gl_half) :=
      ntv_SecondaryColor3hvNV_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3hvNV(v: IntPtr) :=
      ntv_SecondaryColor3hvNV_2(v);
    
    private VertexWeighthNV_adr := GetProcAddress('glVertexWeighthNV');
    private ntv_VertexWeighthNV_1 := GetProcOrNil&<procedure(weight: gl_half)>(VertexWeighthNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeighthNV(weight: gl_half) :=
      ntv_VertexWeighthNV_1(weight);
    
    private VertexWeighthvNV_adr := GetProcAddress('glVertexWeighthvNV');
    private ntv_VertexWeighthvNV_1 := GetProcOrNil&<procedure(var weight: gl_half)>(VertexWeighthvNV_adr);
    private ntv_VertexWeighthvNV_2 := GetProcOrNil&<procedure(weight: IntPtr)>(VertexWeighthvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeighthvNV(weight: array of gl_half);
    type PGl_half = ^gl_half;
    begin
      if (weight<>nil) and (weight.Length<>0) then
        ntv_VertexWeighthvNV_1(weight[0]) else
        ntv_VertexWeighthvNV_1(PGl_half(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeighthvNV(var weight: gl_half) :=
      ntv_VertexWeighthvNV_1(weight);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeighthvNV(weight: IntPtr) :=
      ntv_VertexWeighthvNV_2(weight);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glInternalformatSampleQueryNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_internalformat_sample_query';
    
    private GetInternalformatSampleivNV_adr := GetProcAddress('glGetInternalformatSampleivNV');
    private ntv_GetInternalformatSampleivNV_1 := GetProcOrNil&<procedure(target: glTextureTarget; internalformat: glInternalFormat; samples: Int32; pname: glInternalFormatPName; count: Int32; var &params: Int32)>(GetInternalformatSampleivNV_adr);
    private ntv_GetInternalformatSampleivNV_2 := GetProcOrNil&<procedure(target: glTextureTarget; internalformat: glInternalFormat; samples: Int32; pname: glInternalFormatPName; count: Int32; &params: IntPtr)>(GetInternalformatSampleivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformatSampleivNV(target: glTextureTarget; internalformat: glInternalFormat; samples: Int32; pname: glInternalFormatPName; count: Int32; var &params: Int32) :=
      ntv_GetInternalformatSampleivNV_1(target, internalformat, samples, pname, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformatSampleivNV(target: glTextureTarget; internalformat: glInternalFormat; samples: Int32; pname: glInternalFormatPName; count: Int32; &params: IntPtr) :=
      ntv_GetInternalformatSampleivNV_2(target, internalformat, samples, pname, count, &params);
    
  end;
  
  ///
  glLightMaxExponentNV = static class
    public const _ExtStr = 'GL_NV_light_max_exponent';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMemoryAttachmentNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_memory_attachment';
    
    private GetMemoryObjectDetachedResourcesuivNV_adr := GetProcAddress('glGetMemoryObjectDetachedResourcesuivNV');
    private ntv_GetMemoryObjectDetachedResourcesuivNV_1 := GetProcOrNil&<procedure(memory: UInt32; pname: DummyEnum; first: Int32; count: Int32; var &params: UInt32)>(GetMemoryObjectDetachedResourcesuivNV_adr);
    private ntv_GetMemoryObjectDetachedResourcesuivNV_2 := GetProcOrNil&<procedure(memory: UInt32; pname: DummyEnum; first: Int32; count: Int32; &params: IntPtr)>(GetMemoryObjectDetachedResourcesuivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectDetachedResourcesuivNV(memory: UInt32; pname: DummyEnum; first: Int32; count: Int32; var &params: UInt32) :=
      ntv_GetMemoryObjectDetachedResourcesuivNV_1(memory, pname, first, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectDetachedResourcesuivNV(memory: UInt32; pname: DummyEnum; first: Int32; count: Int32; &params: IntPtr) :=
      ntv_GetMemoryObjectDetachedResourcesuivNV_2(memory, pname, first, count, &params);
    
    private ResetMemoryObjectParameterNV_adr := GetProcAddress('glResetMemoryObjectParameterNV');
    private ntv_ResetMemoryObjectParameterNV_1 := GetProcOrNil&<procedure(memory: UInt32; pname: DummyEnum)>(ResetMemoryObjectParameterNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetMemoryObjectParameterNV(memory: UInt32; pname: DummyEnum) :=
      ntv_ResetMemoryObjectParameterNV_1(memory, pname);
    
    private TexAttachMemoryNV_adr := GetProcAddress('glTexAttachMemoryNV');
    private ntv_TexAttachMemoryNV_1 := GetProcOrNil&<procedure(target: glTextureTarget; memory: UInt32; offset: UInt64)>(TexAttachMemoryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexAttachMemoryNV(target: glTextureTarget; memory: UInt32; offset: UInt64) :=
      ntv_TexAttachMemoryNV_1(target, memory, offset);
    
    private BufferAttachMemoryNV_adr := GetProcAddress('glBufferAttachMemoryNV');
    private ntv_BufferAttachMemoryNV_1 := GetProcOrNil&<procedure(target: glBufferTarget; memory: UInt32; offset: UInt64)>(BufferAttachMemoryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferAttachMemoryNV(target: glBufferTarget; memory: UInt32; offset: UInt64) :=
      ntv_BufferAttachMemoryNV_1(target, memory, offset);
    
    private TextureAttachMemoryNV_adr := GetProcAddress('glTextureAttachMemoryNV');
    private ntv_TextureAttachMemoryNV_1 := GetProcOrNil&<procedure(texture: gl_texture; memory: UInt32; offset: UInt64)>(TextureAttachMemoryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureAttachMemoryNV(texture: gl_texture; memory: UInt32; offset: UInt64) :=
      ntv_TextureAttachMemoryNV_1(texture, memory, offset);
    
    private NamedBufferAttachMemoryNV_adr := GetProcAddress('glNamedBufferAttachMemoryNV');
    private ntv_NamedBufferAttachMemoryNV_1 := GetProcOrNil&<procedure(buffer: gl_buffer; memory: UInt32; offset: UInt64)>(NamedBufferAttachMemoryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferAttachMemoryNV(buffer: gl_buffer; memory: UInt32; offset: UInt64) :=
      ntv_NamedBufferAttachMemoryNV_1(buffer, memory, offset);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMemoryObjectSparseNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_memory_object_sparse';
    
    private BufferPageCommitmentMemNV_adr := GetProcAddress('glBufferPageCommitmentMemNV');
    private ntv_BufferPageCommitmentMemNV_1 := GetProcOrNil&<procedure(target: glBufferStorageTarget; offset: IntPtr; size: UIntPtr; memory: UInt32; memOffset: UInt64; commit: glBool8)>(BufferPageCommitmentMemNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferPageCommitmentMemNV(target: glBufferStorageTarget; offset: IntPtr; size: UIntPtr; memory: UInt32; memOffset: UInt64; commit: glBool8) :=
      ntv_BufferPageCommitmentMemNV_1(target, offset, size, memory, memOffset, commit);
    
    private TexPageCommitmentMemNV_adr := GetProcAddress('glTexPageCommitmentMemNV');
    private ntv_TexPageCommitmentMemNV_1 := GetProcOrNil&<procedure(target: glTextureTarget; layer: Int32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64; commit: glBool8)>(TexPageCommitmentMemNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexPageCommitmentMemNV(target: glTextureTarget; layer: Int32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64; commit: glBool8) :=
      ntv_TexPageCommitmentMemNV_1(target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
    
    private NamedBufferPageCommitmentMemNV_adr := GetProcAddress('glNamedBufferPageCommitmentMemNV');
    private ntv_NamedBufferPageCommitmentMemNV_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; memory: UInt32; memOffset: UInt64; commit: glBool8)>(NamedBufferPageCommitmentMemNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferPageCommitmentMemNV(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; memory: UInt32; memOffset: UInt64; commit: glBool8) :=
      ntv_NamedBufferPageCommitmentMemNV_1(buffer, offset, size, memory, memOffset, commit);
    
    private TexturePageCommitmentMemNV_adr := GetProcAddress('glTexturePageCommitmentMemNV');
    private ntv_TexturePageCommitmentMemNV_1 := GetProcOrNil&<procedure(texture: gl_texture; layer: Int32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64; commit: glBool8)>(TexturePageCommitmentMemNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexturePageCommitmentMemNV(texture: gl_texture; layer: Int32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64; commit: glBool8) :=
      ntv_TexturePageCommitmentMemNV_1(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMeshShaderNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_mesh_shader';
    
    private DrawMeshTasksNV_adr := GetProcAddress('glDrawMeshTasksNV');
    private ntv_DrawMeshTasksNV_1 := GetProcOrNil&<procedure(first: UInt32; count: UInt32)>(DrawMeshTasksNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawMeshTasksNV(first: UInt32; count: UInt32) :=
      ntv_DrawMeshTasksNV_1(first, count);
    
    private DrawMeshTasksIndirectNV_adr := GetProcAddress('glDrawMeshTasksIndirectNV');
    private ntv_DrawMeshTasksIndirectNV_1 := GetProcOrNil&<procedure(indirect: IntPtr)>(DrawMeshTasksIndirectNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawMeshTasksIndirectNV(indirect: IntPtr) :=
      ntv_DrawMeshTasksIndirectNV_1(indirect);
    
    private MultiDrawMeshTasksIndirectNV_adr := GetProcAddress('glMultiDrawMeshTasksIndirectNV');
    private ntv_MultiDrawMeshTasksIndirectNV_1 := GetProcOrNil&<procedure(indirect: IntPtr; drawcount: Int32; stride: Int32)>(MultiDrawMeshTasksIndirectNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawMeshTasksIndirectNV(indirect: IntPtr; drawcount: Int32; stride: Int32) :=
      ntv_MultiDrawMeshTasksIndirectNV_1(indirect, drawcount, stride);
    
    private MultiDrawMeshTasksIndirectCountNV_adr := GetProcAddress('glMultiDrawMeshTasksIndirectCountNV');
    private ntv_MultiDrawMeshTasksIndirectCountNV_1 := GetProcOrNil&<procedure(indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32)>(MultiDrawMeshTasksIndirectCountNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawMeshTasksIndirectCountNV(indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) :=
      ntv_MultiDrawMeshTasksIndirectCountNV_1(indirect, drawcount, maxdrawcount, stride);
    
  end;
  
  ///
  glMultisampleCoverageNV = static class
    public const _ExtStr = 'GL_NV_multisample_coverage';
  end;
  
  ///
  glMultisampleFilterHintNV = static class
    public const _ExtStr = 'GL_NV_multisample_filter_hint';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glOcclusionQueryNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_occlusion_query';
    
    private GenOcclusionQueriesNV_adr := GetProcAddress('glGenOcclusionQueriesNV');
    private ntv_GenOcclusionQueriesNV_1 := GetProcOrNil&<procedure(n: Int32; var ids: UInt32)>(GenOcclusionQueriesNV_adr);
    private ntv_GenOcclusionQueriesNV_2 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(GenOcclusionQueriesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenOcclusionQueriesNV(n: Int32; ids: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_GenOcclusionQueriesNV_1(n, ids[0]) else
        ntv_GenOcclusionQueriesNV_1(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenOcclusionQueriesNV(n: Int32; var ids: UInt32) :=
      ntv_GenOcclusionQueriesNV_1(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenOcclusionQueriesNV(n: Int32; ids: IntPtr) :=
      ntv_GenOcclusionQueriesNV_2(n, ids);
    
    private DeleteOcclusionQueriesNV_adr := GetProcAddress('glDeleteOcclusionQueriesNV');
    private ntv_DeleteOcclusionQueriesNV_1 := GetProcOrNil&<procedure(n: Int32; var ids: UInt32)>(DeleteOcclusionQueriesNV_adr);
    private ntv_DeleteOcclusionQueriesNV_2 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(DeleteOcclusionQueriesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteOcclusionQueriesNV(n: Int32; ids: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_DeleteOcclusionQueriesNV_1(n, ids[0]) else
        ntv_DeleteOcclusionQueriesNV_1(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteOcclusionQueriesNV(n: Int32; var ids: UInt32) :=
      ntv_DeleteOcclusionQueriesNV_1(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteOcclusionQueriesNV(n: Int32; ids: IntPtr) :=
      ntv_DeleteOcclusionQueriesNV_2(n, ids);
    
    private IsOcclusionQueryNV_adr := GetProcAddress('glIsOcclusionQueryNV');
    private ntv_IsOcclusionQueryNV_1 := GetProcOrNil&<function(id: UInt32): glBool8>(IsOcclusionQueryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsOcclusionQueryNV(id: UInt32): glBool8 :=
      ntv_IsOcclusionQueryNV_1(id);
    
    private BeginOcclusionQueryNV_adr := GetProcAddress('glBeginOcclusionQueryNV');
    private ntv_BeginOcclusionQueryNV_1 := GetProcOrNil&<procedure(id: UInt32)>(BeginOcclusionQueryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginOcclusionQueryNV(id: UInt32) :=
      ntv_BeginOcclusionQueryNV_1(id);
    
    private EndOcclusionQueryNV_adr := GetProcAddress('glEndOcclusionQueryNV');
    private ntv_EndOcclusionQueryNV_1 := GetProcOrNil&<procedure>(EndOcclusionQueryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndOcclusionQueryNV :=
      ntv_EndOcclusionQueryNV_1;
    
    private GetOcclusionQueryivNV_adr := GetProcAddress('glGetOcclusionQueryivNV');
    private ntv_GetOcclusionQueryivNV_1 := GetProcOrNil&<procedure(id: UInt32; pname: glOcclusionQueryParameterName; var &params: Int32)>(GetOcclusionQueryivNV_adr);
    private ntv_GetOcclusionQueryivNV_2 := GetProcOrNil&<procedure(id: UInt32; pname: glOcclusionQueryParameterName; &params: IntPtr)>(GetOcclusionQueryivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryivNV(id: UInt32; pname: glOcclusionQueryParameterName; var &params: Int32) :=
      ntv_GetOcclusionQueryivNV_1(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryivNV(id: UInt32; pname: glOcclusionQueryParameterName; &params: IntPtr) :=
      ntv_GetOcclusionQueryivNV_2(id, pname, &params);
    
    private GetOcclusionQueryuivNV_adr := GetProcAddress('glGetOcclusionQueryuivNV');
    private ntv_GetOcclusionQueryuivNV_1 := GetProcOrNil&<procedure(id: UInt32; pname: glOcclusionQueryParameterName; var &params: UInt32)>(GetOcclusionQueryuivNV_adr);
    private ntv_GetOcclusionQueryuivNV_2 := GetProcOrNil&<procedure(id: UInt32; pname: glOcclusionQueryParameterName; &params: IntPtr)>(GetOcclusionQueryuivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryuivNV(id: UInt32; pname: glOcclusionQueryParameterName; var &params: UInt32) :=
      ntv_GetOcclusionQueryuivNV_1(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryuivNV(id: UInt32; pname: glOcclusionQueryParameterName; &params: IntPtr) :=
      ntv_GetOcclusionQueryuivNV_2(id, pname, &params);
    
  end;
  
  ///
  glPackedDepthStencilNV = static class
    public const _ExtStr = 'GL_NV_packed_depth_stencil';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glParameterBufferObjectNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_parameter_buffer_object';
    
    private ProgramBufferParametersfvNV_adr := GetProcAddress('glProgramBufferParametersfvNV');
    private ntv_ProgramBufferParametersfvNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: single)>(ProgramBufferParametersfvNV_adr);
    private ntv_ProgramBufferParametersfvNV_2 := GetProcOrNil&<procedure(target: glProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: IntPtr)>(ProgramBufferParametersfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersfvNV(target: glProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramBufferParametersfvNV_1(target, bindingIndex, wordIndex, count, &params[0]) else
        ntv_ProgramBufferParametersfvNV_1(target, bindingIndex, wordIndex, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersfvNV(target: glProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: single) :=
      ntv_ProgramBufferParametersfvNV_1(target, bindingIndex, wordIndex, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersfvNV(target: glProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: IntPtr) :=
      ntv_ProgramBufferParametersfvNV_2(target, bindingIndex, wordIndex, count, &params);
    
    private ProgramBufferParametersIivNV_adr := GetProcAddress('glProgramBufferParametersIivNV');
    private ntv_ProgramBufferParametersIivNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: Int32)>(ProgramBufferParametersIivNV_adr);
    private ntv_ProgramBufferParametersIivNV_2 := GetProcOrNil&<procedure(target: glProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: IntPtr)>(ProgramBufferParametersIivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIivNV(target: glProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramBufferParametersIivNV_1(target, bindingIndex, wordIndex, count, &params[0]) else
        ntv_ProgramBufferParametersIivNV_1(target, bindingIndex, wordIndex, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIivNV(target: glProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: Int32) :=
      ntv_ProgramBufferParametersIivNV_1(target, bindingIndex, wordIndex, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIivNV(target: glProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: IntPtr) :=
      ntv_ProgramBufferParametersIivNV_2(target, bindingIndex, wordIndex, count, &params);
    
    private ProgramBufferParametersIuivNV_adr := GetProcAddress('glProgramBufferParametersIuivNV');
    private ntv_ProgramBufferParametersIuivNV_1 := GetProcOrNil&<procedure(target: glProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: UInt32)>(ProgramBufferParametersIuivNV_adr);
    private ntv_ProgramBufferParametersIuivNV_2 := GetProcOrNil&<procedure(target: glProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: IntPtr)>(ProgramBufferParametersIuivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIuivNV(target: glProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ProgramBufferParametersIuivNV_1(target, bindingIndex, wordIndex, count, &params[0]) else
        ntv_ProgramBufferParametersIuivNV_1(target, bindingIndex, wordIndex, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIuivNV(target: glProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: UInt32) :=
      ntv_ProgramBufferParametersIuivNV_1(target, bindingIndex, wordIndex, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIuivNV(target: glProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: IntPtr) :=
      ntv_ProgramBufferParametersIuivNV_2(target, bindingIndex, wordIndex, count, &params);
    
  end;
  
  ///
  glParameterBufferObject2NV = static class
    public const _ExtStr = 'GL_NV_parameter_buffer_object2';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPathRenderingNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_path_rendering';
    
    private GenPathsNV_adr := GetProcAddress('glGenPathsNV');
    private ntv_GenPathsNV_1 := GetProcOrNil&<function(range: Int32): UInt32>(GenPathsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenPathsNV(range: Int32): UInt32 :=
      ntv_GenPathsNV_1(range);
    
    private DeletePathsNV_adr := GetProcAddress('glDeletePathsNV');
    private ntv_DeletePathsNV_1 := GetProcOrNil&<procedure(path: UInt32; range: Int32)>(DeletePathsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePathsNV(path: UInt32; range: Int32) :=
      ntv_DeletePathsNV_1(path, range);
    
    private IsPathNV_adr := GetProcAddress('glIsPathNV');
    private ntv_IsPathNV_1 := GetProcOrNil&<function(path: UInt32): glBool8>(IsPathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsPathNV(path: UInt32): glBool8 :=
      ntv_IsPathNV_1(path);
    
    private PathCommandsNV_adr := GetProcAddress('glPathCommandsNV');
    private ntv_PathCommandsNV_1 := GetProcOrNil&<procedure(path: UInt32; numCommands: Int32; var commands: glPathCoordType; numCoords: Int32; coordType: glPathCoordType; coords: IntPtr)>(PathCommandsNV_adr);
    private ntv_PathCommandsNV_2 := GetProcOrNil&<procedure(path: UInt32; numCommands: Int32; commands: IntPtr; numCoords: Int32; coordType: glPathCoordType; coords: IntPtr)>(PathCommandsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCommandsNV(path: UInt32; numCommands: Int32; commands: array of glPathCoordType; numCoords: Int32; coordType: glPathCoordType; coords: IntPtr);
    type PGlPathCoordType = ^glPathCoordType;
    begin
      if (commands<>nil) and (commands.Length<>0) then
        ntv_PathCommandsNV_1(path, numCommands, commands[0], numCoords, coordType, coords) else
        ntv_PathCommandsNV_1(path, numCommands, PGlPathCoordType(nil)^, numCoords, coordType, coords);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCommandsNV(path: UInt32; numCommands: Int32; var commands: glPathCoordType; numCoords: Int32; coordType: glPathCoordType; coords: IntPtr) :=
      ntv_PathCommandsNV_1(path, numCommands, commands, numCoords, coordType, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCommandsNV(path: UInt32; numCommands: Int32; commands: IntPtr; numCoords: Int32; coordType: glPathCoordType; coords: IntPtr) :=
      ntv_PathCommandsNV_2(path, numCommands, commands, numCoords, coordType, coords);
    
    private PathCoordsNV_adr := GetProcAddress('glPathCoordsNV');
    private ntv_PathCoordsNV_1 := GetProcOrNil&<procedure(path: UInt32; numCoords: Int32; coordType: glPathCoordType; coords: IntPtr)>(PathCoordsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCoordsNV(path: UInt32; numCoords: Int32; coordType: glPathCoordType; coords: IntPtr) :=
      ntv_PathCoordsNV_1(path, numCoords, coordType, coords);
    
    private PathSubCommandsNV_adr := GetProcAddress('glPathSubCommandsNV');
    private ntv_PathSubCommandsNV_1 := GetProcOrNil&<procedure(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; var commands: glPathCoordType; numCoords: Int32; coordType: glPathCoordType; coords: IntPtr)>(PathSubCommandsNV_adr);
    private ntv_PathSubCommandsNV_2 := GetProcOrNil&<procedure(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; commands: IntPtr; numCoords: Int32; coordType: glPathCoordType; coords: IntPtr)>(PathSubCommandsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathSubCommandsNV(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; commands: array of glPathCoordType; numCoords: Int32; coordType: glPathCoordType; coords: IntPtr);
    type PGlPathCoordType = ^glPathCoordType;
    begin
      if (commands<>nil) and (commands.Length<>0) then
        ntv_PathSubCommandsNV_1(path, commandStart, commandsToDelete, numCommands, commands[0], numCoords, coordType, coords) else
        ntv_PathSubCommandsNV_1(path, commandStart, commandsToDelete, numCommands, PGlPathCoordType(nil)^, numCoords, coordType, coords);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathSubCommandsNV(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; var commands: glPathCoordType; numCoords: Int32; coordType: glPathCoordType; coords: IntPtr) :=
      ntv_PathSubCommandsNV_1(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathSubCommandsNV(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; commands: IntPtr; numCoords: Int32; coordType: glPathCoordType; coords: IntPtr) :=
      ntv_PathSubCommandsNV_2(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
    
    private PathSubCoordsNV_adr := GetProcAddress('glPathSubCoordsNV');
    private ntv_PathSubCoordsNV_1 := GetProcOrNil&<procedure(path: UInt32; coordStart: Int32; numCoords: Int32; coordType: glPathCoordType; coords: IntPtr)>(PathSubCoordsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathSubCoordsNV(path: UInt32; coordStart: Int32; numCoords: Int32; coordType: glPathCoordType; coords: IntPtr) :=
      ntv_PathSubCoordsNV_1(path, coordStart, numCoords, coordType, coords);
    
    private PathStringNV_adr := GetProcAddress('glPathStringNV');
    private ntv_PathStringNV_1 := GetProcOrNil&<procedure(path: UInt32; format: glPathStringFormat; length: Int32; pathString: IntPtr)>(PathStringNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathStringNV(path: UInt32; format: glPathStringFormat; length: Int32; pathString: IntPtr) :=
      ntv_PathStringNV_1(path, format, length, pathString);
    
    private PathGlyphsNV_adr := GetProcAddress('glPathGlyphsNV');
    private ntv_PathGlyphsNV_1 := GetProcOrNil&<procedure(firstPathName: UInt32; fontTarget: glPathFontTarget; fontName: IntPtr; fontStyle: glPathFontStyle; numGlyphs: Int32; &type: glPathElementType; charcodes: IntPtr; handleMissingGlyphs: glPathHandleMissingGlyphs; pathParameterTemplate: UInt32; emScale: single)>(PathGlyphsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathGlyphsNV(firstPathName: UInt32; fontTarget: glPathFontTarget; fontName: IntPtr; fontStyle: glPathFontStyle; numGlyphs: Int32; &type: glPathElementType; charcodes: IntPtr; handleMissingGlyphs: glPathHandleMissingGlyphs; pathParameterTemplate: UInt32; emScale: single) :=
      ntv_PathGlyphsNV_1(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, &type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
    
    private PathGlyphRangeNV_adr := GetProcAddress('glPathGlyphRangeNV');
    private ntv_PathGlyphRangeNV_1 := GetProcOrNil&<procedure(firstPathName: UInt32; fontTarget: glPathFontTarget; fontName: IntPtr; fontStyle: glPathFontStyle; firstGlyph: UInt32; numGlyphs: Int32; handleMissingGlyphs: glPathHandleMissingGlyphs; pathParameterTemplate: UInt32; emScale: single)>(PathGlyphRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathGlyphRangeNV(firstPathName: UInt32; fontTarget: glPathFontTarget; fontName: IntPtr; fontStyle: glPathFontStyle; firstGlyph: UInt32; numGlyphs: Int32; handleMissingGlyphs: glPathHandleMissingGlyphs; pathParameterTemplate: UInt32; emScale: single) :=
      ntv_PathGlyphRangeNV_1(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
    
    private WeightPathsNV_adr := GetProcAddress('glWeightPathsNV');
    private ntv_WeightPathsNV_1 := GetProcOrNil&<procedure(resultPath: UInt32; numPaths: Int32; var paths: UInt32; var weights: single)>(WeightPathsNV_adr);
    private ntv_WeightPathsNV_2 := GetProcOrNil&<procedure(resultPath: UInt32; numPaths: Int32; var paths: UInt32; weights: IntPtr)>(WeightPathsNV_adr);
    private ntv_WeightPathsNV_3 := GetProcOrNil&<procedure(resultPath: UInt32; numPaths: Int32; paths: IntPtr; var weights: single)>(WeightPathsNV_adr);
    private ntv_WeightPathsNV_4 := GetProcOrNil&<procedure(resultPath: UInt32; numPaths: Int32; paths: IntPtr; weights: IntPtr)>(WeightPathsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: array of UInt32; weights: array of single);
    type PUInt32 = ^UInt32;
    type PSingle = ^single;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        if (paths<>nil) and (paths.Length<>0) then
          ntv_WeightPathsNV_1(resultPath, numPaths, paths[0], weights[0]) else
          ntv_WeightPathsNV_1(resultPath, numPaths, PUInt32(nil)^, weights[0]) else
        if (paths<>nil) and (paths.Length<>0) then
          ntv_WeightPathsNV_1(resultPath, numPaths, paths[0], PSingle(nil)^) else
          ntv_WeightPathsNV_1(resultPath, numPaths, PUInt32(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; var paths: UInt32; var weights: single) :=
      ntv_WeightPathsNV_1(resultPath, numPaths, paths, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; var paths: UInt32; weights: IntPtr) :=
      ntv_WeightPathsNV_2(resultPath, numPaths, paths, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: IntPtr; var weights: single) :=
      ntv_WeightPathsNV_3(resultPath, numPaths, paths, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: IntPtr; weights: IntPtr) :=
      ntv_WeightPathsNV_4(resultPath, numPaths, paths, weights);
    
    private CopyPathNV_adr := GetProcAddress('glCopyPathNV');
    private ntv_CopyPathNV_1 := GetProcOrNil&<procedure(resultPath: UInt32; srcPath: UInt32)>(CopyPathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyPathNV(resultPath: UInt32; srcPath: UInt32) :=
      ntv_CopyPathNV_1(resultPath, srcPath);
    
    private InterpolatePathsNV_adr := GetProcAddress('glInterpolatePathsNV');
    private ntv_InterpolatePathsNV_1 := GetProcOrNil&<procedure(resultPath: UInt32; pathA: UInt32; pathB: UInt32; weight: single)>(InterpolatePathsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InterpolatePathsNV(resultPath: UInt32; pathA: UInt32; pathB: UInt32; weight: single) :=
      ntv_InterpolatePathsNV_1(resultPath, pathA, pathB, weight);
    
    private TransformPathNV_adr := GetProcAddress('glTransformPathNV');
    private ntv_TransformPathNV_1 := GetProcOrNil&<procedure(resultPath: UInt32; srcPath: UInt32; transformType: glPathTransformType; var transformValues: single)>(TransformPathNV_adr);
    private ntv_TransformPathNV_2 := GetProcOrNil&<procedure(resultPath: UInt32; srcPath: UInt32; transformType: glPathTransformType; transformValues: IntPtr)>(TransformPathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformPathNV(resultPath: UInt32; srcPath: UInt32; transformType: glPathTransformType; transformValues: array of single);
    type PSingle = ^single;
    begin
      if (transformValues<>nil) and (transformValues.Length<>0) then
        ntv_TransformPathNV_1(resultPath, srcPath, transformType, transformValues[0]) else
        ntv_TransformPathNV_1(resultPath, srcPath, transformType, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformPathNV(resultPath: UInt32; srcPath: UInt32; transformType: glPathTransformType; var transformValues: single) :=
      ntv_TransformPathNV_1(resultPath, srcPath, transformType, transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformPathNV(resultPath: UInt32; srcPath: UInt32; transformType: glPathTransformType; transformValues: IntPtr) :=
      ntv_TransformPathNV_2(resultPath, srcPath, transformType, transformValues);
    
    private PathParameterivNV_adr := GetProcAddress('glPathParameterivNV');
    private ntv_PathParameterivNV_1 := GetProcOrNil&<procedure(path: UInt32; pname: glPathParameter; var value: Int32)>(PathParameterivNV_adr);
    private ntv_PathParameterivNV_2 := GetProcOrNil&<procedure(path: UInt32; pname: glPathParameter; value: IntPtr)>(PathParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterivNV(path: UInt32; pname: glPathParameter; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_PathParameterivNV_1(path, pname, value[0]) else
        ntv_PathParameterivNV_1(path, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterivNV(path: UInt32; pname: glPathParameter; var value: Int32) :=
      ntv_PathParameterivNV_1(path, pname, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterivNV(path: UInt32; pname: glPathParameter; value: IntPtr) :=
      ntv_PathParameterivNV_2(path, pname, value);
    
    private PathParameteriNV_adr := GetProcAddress('glPathParameteriNV');
    private ntv_PathParameteriNV_1 := GetProcOrNil&<procedure(path: UInt32; pname: glPathParameter; value: Int32)>(PathParameteriNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameteriNV(path: UInt32; pname: glPathParameter; value: Int32) :=
      ntv_PathParameteriNV_1(path, pname, value);
    
    private PathParameterfvNV_adr := GetProcAddress('glPathParameterfvNV');
    private ntv_PathParameterfvNV_1 := GetProcOrNil&<procedure(path: UInt32; pname: glPathParameter; var value: single)>(PathParameterfvNV_adr);
    private ntv_PathParameterfvNV_2 := GetProcOrNil&<procedure(path: UInt32; pname: glPathParameter; value: IntPtr)>(PathParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterfvNV(path: UInt32; pname: glPathParameter; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_PathParameterfvNV_1(path, pname, value[0]) else
        ntv_PathParameterfvNV_1(path, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterfvNV(path: UInt32; pname: glPathParameter; var value: single) :=
      ntv_PathParameterfvNV_1(path, pname, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterfvNV(path: UInt32; pname: glPathParameter; value: IntPtr) :=
      ntv_PathParameterfvNV_2(path, pname, value);
    
    private PathParameterfNV_adr := GetProcAddress('glPathParameterfNV');
    private ntv_PathParameterfNV_1 := GetProcOrNil&<procedure(path: UInt32; pname: glPathParameter; value: single)>(PathParameterfNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterfNV(path: UInt32; pname: glPathParameter; value: single) :=
      ntv_PathParameterfNV_1(path, pname, value);
    
    private PathDashArrayNV_adr := GetProcAddress('glPathDashArrayNV');
    private ntv_PathDashArrayNV_1 := GetProcOrNil&<procedure(path: UInt32; dashCount: Int32; var dashArray: single)>(PathDashArrayNV_adr);
    private ntv_PathDashArrayNV_2 := GetProcOrNil&<procedure(path: UInt32; dashCount: Int32; dashArray: IntPtr)>(PathDashArrayNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathDashArrayNV(path: UInt32; dashCount: Int32; dashArray: array of single);
    type PSingle = ^single;
    begin
      if (dashArray<>nil) and (dashArray.Length<>0) then
        ntv_PathDashArrayNV_1(path, dashCount, dashArray[0]) else
        ntv_PathDashArrayNV_1(path, dashCount, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathDashArrayNV(path: UInt32; dashCount: Int32; var dashArray: single) :=
      ntv_PathDashArrayNV_1(path, dashCount, dashArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathDashArrayNV(path: UInt32; dashCount: Int32; dashArray: IntPtr) :=
      ntv_PathDashArrayNV_2(path, dashCount, dashArray);
    
    private PathStencilFuncNV_adr := GetProcAddress('glPathStencilFuncNV');
    private ntv_PathStencilFuncNV_1 := GetProcOrNil&<procedure(func: glStencilFunction; ref: Int32; mask: UInt32)>(PathStencilFuncNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathStencilFuncNV(func: glStencilFunction; ref: Int32; mask: UInt32) :=
      ntv_PathStencilFuncNV_1(func, ref, mask);
    
    private PathStencilDepthOffsetNV_adr := GetProcAddress('glPathStencilDepthOffsetNV');
    private ntv_PathStencilDepthOffsetNV_1 := GetProcOrNil&<procedure(factor: single; units: single)>(PathStencilDepthOffsetNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathStencilDepthOffsetNV(factor: single; units: single) :=
      ntv_PathStencilDepthOffsetNV_1(factor, units);
    
    private StencilFillPathNV_adr := GetProcAddress('glStencilFillPathNV');
    private ntv_StencilFillPathNV_1 := GetProcOrNil&<procedure(path: UInt32; fillMode: glPathFillMode; mask: UInt32)>(StencilFillPathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFillPathNV(path: UInt32; fillMode: glPathFillMode; mask: UInt32) :=
      ntv_StencilFillPathNV_1(path, fillMode, mask);
    
    private StencilStrokePathNV_adr := GetProcAddress('glStencilStrokePathNV');
    private ntv_StencilStrokePathNV_1 := GetProcOrNil&<procedure(path: UInt32; reference: Int32; mask: UInt32)>(StencilStrokePathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilStrokePathNV(path: UInt32; reference: Int32; mask: UInt32) :=
      ntv_StencilStrokePathNV_1(path, reference, mask);
    
    private StencilFillPathInstancedNV_adr := GetProcAddress('glStencilFillPathInstancedNV');
    private ntv_StencilFillPathInstancedNV_1 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; fillMode: glPathFillMode; mask: UInt32; transformType: glPathTransformType; var transformValues: single)>(StencilFillPathInstancedNV_adr);
    private ntv_StencilFillPathInstancedNV_2 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; fillMode: glPathFillMode; mask: UInt32; transformType: glPathTransformType; transformValues: IntPtr)>(StencilFillPathInstancedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFillPathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; fillMode: glPathFillMode; mask: UInt32; transformType: glPathTransformType; transformValues: array of single);
    type PSingle = ^single;
    begin
      if (transformValues<>nil) and (transformValues.Length<>0) then
        ntv_StencilFillPathInstancedNV_1(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues[0]) else
        ntv_StencilFillPathInstancedNV_1(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFillPathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; fillMode: glPathFillMode; mask: UInt32; transformType: glPathTransformType; var transformValues: single) :=
      ntv_StencilFillPathInstancedNV_1(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFillPathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; fillMode: glPathFillMode; mask: UInt32; transformType: glPathTransformType; transformValues: IntPtr) :=
      ntv_StencilFillPathInstancedNV_2(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
    
    private StencilStrokePathInstancedNV_adr := GetProcAddress('glStencilStrokePathInstancedNV');
    private ntv_StencilStrokePathInstancedNV_1 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: glPathTransformType; var transformValues: single)>(StencilStrokePathInstancedNV_adr);
    private ntv_StencilStrokePathInstancedNV_2 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: glPathTransformType; transformValues: IntPtr)>(StencilStrokePathInstancedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilStrokePathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: glPathTransformType; transformValues: array of single);
    type PSingle = ^single;
    begin
      if (transformValues<>nil) and (transformValues.Length<>0) then
        ntv_StencilStrokePathInstancedNV_1(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues[0]) else
        ntv_StencilStrokePathInstancedNV_1(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilStrokePathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: glPathTransformType; var transformValues: single) :=
      ntv_StencilStrokePathInstancedNV_1(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilStrokePathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: glPathTransformType; transformValues: IntPtr) :=
      ntv_StencilStrokePathInstancedNV_2(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
    
    private PathCoverDepthFuncNV_adr := GetProcAddress('glPathCoverDepthFuncNV');
    private ntv_PathCoverDepthFuncNV_1 := GetProcOrNil&<procedure(func: glDepthFunction)>(PathCoverDepthFuncNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCoverDepthFuncNV(func: glDepthFunction) :=
      ntv_PathCoverDepthFuncNV_1(func);
    
    private CoverFillPathNV_adr := GetProcAddress('glCoverFillPathNV');
    private ntv_CoverFillPathNV_1 := GetProcOrNil&<procedure(path: UInt32; coverMode: glPathCoverMode)>(CoverFillPathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverFillPathNV(path: UInt32; coverMode: glPathCoverMode) :=
      ntv_CoverFillPathNV_1(path, coverMode);
    
    private CoverStrokePathNV_adr := GetProcAddress('glCoverStrokePathNV');
    private ntv_CoverStrokePathNV_1 := GetProcOrNil&<procedure(path: UInt32; coverMode: glPathCoverMode)>(CoverStrokePathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverStrokePathNV(path: UInt32; coverMode: glPathCoverMode) :=
      ntv_CoverStrokePathNV_1(path, coverMode);
    
    private CoverFillPathInstancedNV_adr := GetProcAddress('glCoverFillPathInstancedNV');
    private ntv_CoverFillPathInstancedNV_1 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; var transformValues: single)>(CoverFillPathInstancedNV_adr);
    private ntv_CoverFillPathInstancedNV_2 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; transformValues: IntPtr)>(CoverFillPathInstancedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverFillPathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; transformValues: array of single);
    type PSingle = ^single;
    begin
      if (transformValues<>nil) and (transformValues.Length<>0) then
        ntv_CoverFillPathInstancedNV_1(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues[0]) else
        ntv_CoverFillPathInstancedNV_1(numPaths, pathNameType, paths, pathBase, coverMode, transformType, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverFillPathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; var transformValues: single) :=
      ntv_CoverFillPathInstancedNV_1(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverFillPathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; transformValues: IntPtr) :=
      ntv_CoverFillPathInstancedNV_2(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    
    private CoverStrokePathInstancedNV_adr := GetProcAddress('glCoverStrokePathInstancedNV');
    private ntv_CoverStrokePathInstancedNV_1 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; var transformValues: single)>(CoverStrokePathInstancedNV_adr);
    private ntv_CoverStrokePathInstancedNV_2 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; transformValues: IntPtr)>(CoverStrokePathInstancedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverStrokePathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; transformValues: array of single);
    type PSingle = ^single;
    begin
      if (transformValues<>nil) and (transformValues.Length<>0) then
        ntv_CoverStrokePathInstancedNV_1(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues[0]) else
        ntv_CoverStrokePathInstancedNV_1(numPaths, pathNameType, paths, pathBase, coverMode, transformType, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverStrokePathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; var transformValues: single) :=
      ntv_CoverStrokePathInstancedNV_1(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverStrokePathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; transformValues: IntPtr) :=
      ntv_CoverStrokePathInstancedNV_2(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    
    private GetPathParameterivNV_adr := GetProcAddress('glGetPathParameterivNV');
    private ntv_GetPathParameterivNV_1 := GetProcOrNil&<procedure(path: UInt32; pname: glPathParameter; var value: Int32)>(GetPathParameterivNV_adr);
    private ntv_GetPathParameterivNV_2 := GetProcOrNil&<procedure(path: UInt32; pname: glPathParameter; value: IntPtr)>(GetPathParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterivNV(path: UInt32; pname: glPathParameter; var value: Int32) :=
      ntv_GetPathParameterivNV_1(path, pname, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterivNV(path: UInt32; pname: glPathParameter; value: IntPtr) :=
      ntv_GetPathParameterivNV_2(path, pname, value);
    
    private GetPathParameterfvNV_adr := GetProcAddress('glGetPathParameterfvNV');
    private ntv_GetPathParameterfvNV_1 := GetProcOrNil&<procedure(path: UInt32; pname: glPathParameter; var value: single)>(GetPathParameterfvNV_adr);
    private ntv_GetPathParameterfvNV_2 := GetProcOrNil&<procedure(path: UInt32; pname: glPathParameter; value: IntPtr)>(GetPathParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterfvNV(path: UInt32; pname: glPathParameter; var value: single) :=
      ntv_GetPathParameterfvNV_1(path, pname, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterfvNV(path: UInt32; pname: glPathParameter; value: IntPtr) :=
      ntv_GetPathParameterfvNV_2(path, pname, value);
    
    private GetPathCommandsNV_adr := GetProcAddress('glGetPathCommandsNV');
    private ntv_GetPathCommandsNV_1 := GetProcOrNil&<procedure(path: UInt32; var commands: glPathCoordType)>(GetPathCommandsNV_adr);
    private ntv_GetPathCommandsNV_2 := GetProcOrNil&<procedure(path: UInt32; commands: IntPtr)>(GetPathCommandsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCommandsNV(path: UInt32; var commands: glPathCoordType) :=
      ntv_GetPathCommandsNV_1(path, commands);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCommandsNV(path: UInt32; commands: IntPtr) :=
      ntv_GetPathCommandsNV_2(path, commands);
    
    private GetPathCoordsNV_adr := GetProcAddress('glGetPathCoordsNV');
    private ntv_GetPathCoordsNV_1 := GetProcOrNil&<procedure(path: UInt32; var coords: single)>(GetPathCoordsNV_adr);
    private ntv_GetPathCoordsNV_2 := GetProcOrNil&<procedure(path: UInt32; coords: IntPtr)>(GetPathCoordsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCoordsNV(path: UInt32; var coords: single) :=
      ntv_GetPathCoordsNV_1(path, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCoordsNV(path: UInt32; coords: IntPtr) :=
      ntv_GetPathCoordsNV_2(path, coords);
    
    private GetPathDashArrayNV_adr := GetProcAddress('glGetPathDashArrayNV');
    private ntv_GetPathDashArrayNV_1 := GetProcOrNil&<procedure(path: UInt32; var dashArray: single)>(GetPathDashArrayNV_adr);
    private ntv_GetPathDashArrayNV_2 := GetProcOrNil&<procedure(path: UInt32; dashArray: IntPtr)>(GetPathDashArrayNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathDashArrayNV(path: UInt32; var dashArray: single) :=
      ntv_GetPathDashArrayNV_1(path, dashArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathDashArrayNV(path: UInt32; dashArray: IntPtr) :=
      ntv_GetPathDashArrayNV_2(path, dashArray);
    
    private GetPathMetricsNV_adr := GetProcAddress('glGetPathMetricsNV');
    private ntv_GetPathMetricsNV_1 := GetProcOrNil&<procedure(metricQueryMask: glPathMetricMask; numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; stride: Int32; var metrics: single)>(GetPathMetricsNV_adr);
    private ntv_GetPathMetricsNV_2 := GetProcOrNil&<procedure(metricQueryMask: glPathMetricMask; numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; stride: Int32; metrics: IntPtr)>(GetPathMetricsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricsNV(metricQueryMask: glPathMetricMask; numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; stride: Int32; var metrics: single) :=
      ntv_GetPathMetricsNV_1(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricsNV(metricQueryMask: glPathMetricMask; numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; stride: Int32; metrics: IntPtr) :=
      ntv_GetPathMetricsNV_2(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
    
    private GetPathMetricRangeNV_adr := GetProcAddress('glGetPathMetricRangeNV');
    private ntv_GetPathMetricRangeNV_1 := GetProcOrNil&<procedure(metricQueryMask: glPathMetricMask; firstPathName: UInt32; numPaths: Int32; stride: Int32; var metrics: single)>(GetPathMetricRangeNV_adr);
    private ntv_GetPathMetricRangeNV_2 := GetProcOrNil&<procedure(metricQueryMask: glPathMetricMask; firstPathName: UInt32; numPaths: Int32; stride: Int32; metrics: IntPtr)>(GetPathMetricRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricRangeNV(metricQueryMask: glPathMetricMask; firstPathName: UInt32; numPaths: Int32; stride: Int32; var metrics: single) :=
      ntv_GetPathMetricRangeNV_1(metricQueryMask, firstPathName, numPaths, stride, metrics);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricRangeNV(metricQueryMask: glPathMetricMask; firstPathName: UInt32; numPaths: Int32; stride: Int32; metrics: IntPtr) :=
      ntv_GetPathMetricRangeNV_2(metricQueryMask, firstPathName, numPaths, stride, metrics);
    
    private GetPathSpacingNV_adr := GetProcAddress('glGetPathSpacingNV');
    private ntv_GetPathSpacingNV_1 := GetProcOrNil&<procedure(pathListMode: glPathListMode; numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: glPathTransformType; var returnedSpacing: single)>(GetPathSpacingNV_adr);
    private ntv_GetPathSpacingNV_2 := GetProcOrNil&<procedure(pathListMode: glPathListMode; numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: glPathTransformType; returnedSpacing: IntPtr)>(GetPathSpacingNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathSpacingNV(pathListMode: glPathListMode; numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: glPathTransformType; var returnedSpacing: single) :=
      ntv_GetPathSpacingNV_1(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathSpacingNV(pathListMode: glPathListMode; numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: glPathTransformType; returnedSpacing: IntPtr) :=
      ntv_GetPathSpacingNV_2(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
    
    private IsPointInFillPathNV_adr := GetProcAddress('glIsPointInFillPathNV');
    private ntv_IsPointInFillPathNV_1 := GetProcOrNil&<function(path: UInt32; mask: UInt32; x: single; y: single): glBool8>(IsPointInFillPathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsPointInFillPathNV(path: UInt32; mask: UInt32; x: single; y: single): glBool8 :=
      ntv_IsPointInFillPathNV_1(path, mask, x, y);
    
    private IsPointInStrokePathNV_adr := GetProcAddress('glIsPointInStrokePathNV');
    private ntv_IsPointInStrokePathNV_1 := GetProcOrNil&<function(path: UInt32; x: single; y: single): glBool8>(IsPointInStrokePathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsPointInStrokePathNV(path: UInt32; x: single; y: single): glBool8 :=
      ntv_IsPointInStrokePathNV_1(path, x, y);
    
    private GetPathLengthNV_adr := GetProcAddress('glGetPathLengthNV');
    private ntv_GetPathLengthNV_1 := GetProcOrNil&<function(path: UInt32; startSegment: Int32; numSegments: Int32): single>(GetPathLengthNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPathLengthNV(path: UInt32; startSegment: Int32; numSegments: Int32): single :=
      ntv_GetPathLengthNV_1(path, startSegment, numSegments);
    
    private PointAlongPathNV_adr := GetProcAddress('glPointAlongPathNV');
    private ntv_PointAlongPathNV_1 := GetProcOrNil&<function(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; var tangentX: single; var tangentY: single): glBool8>(PointAlongPathNV_adr);
    private ntv_PointAlongPathNV_2 := GetProcOrNil&<function(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; tangentX: IntPtr; tangentY: IntPtr): glBool8>(PointAlongPathNV_adr);
    private ntv_PointAlongPathNV_3 := GetProcOrNil&<function(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: IntPtr; y: IntPtr; var tangentX: single; var tangentY: single): glBool8>(PointAlongPathNV_adr);
    private ntv_PointAlongPathNV_4 := GetProcOrNil&<function(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: IntPtr; y: IntPtr; tangentX: IntPtr; tangentY: IntPtr): glBool8>(PointAlongPathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; var tangentX: single; var tangentY: single): glBool8 :=
      ntv_PointAlongPathNV_1(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; tangentX: IntPtr; tangentY: IntPtr): glBool8 :=
      ntv_PointAlongPathNV_2(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: IntPtr; y: IntPtr; var tangentX: single; var tangentY: single): glBool8 :=
      ntv_PointAlongPathNV_3(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: IntPtr; y: IntPtr; tangentX: IntPtr; tangentY: IntPtr): glBool8 :=
      ntv_PointAlongPathNV_4(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
    
    private MatrixLoad3x2fNV_adr := GetProcAddress('glMatrixLoad3x2fNV');
    private ntv_MatrixLoad3x2fNV_1 := GetProcOrNil&<procedure(matrixMode: DummyEnum; var m: single)>(MatrixLoad3x2fNV_adr);
    private ntv_MatrixLoad3x2fNV_2 := GetProcOrNil&<procedure(matrixMode: DummyEnum; m: IntPtr)>(MatrixLoad3x2fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x2fNV(matrixMode: DummyEnum; m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixLoad3x2fNV_1(matrixMode, m[0]) else
        ntv_MatrixLoad3x2fNV_1(matrixMode, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x2fNV(matrixMode: DummyEnum; var m: single) :=
      ntv_MatrixLoad3x2fNV_1(matrixMode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x2fNV(matrixMode: DummyEnum; m: IntPtr) :=
      ntv_MatrixLoad3x2fNV_2(matrixMode, m);
    
    private MatrixLoad3x3fNV_adr := GetProcAddress('glMatrixLoad3x3fNV');
    private ntv_MatrixLoad3x3fNV_1 := GetProcOrNil&<procedure(matrixMode: DummyEnum; var m: single)>(MatrixLoad3x3fNV_adr);
    private ntv_MatrixLoad3x3fNV_2 := GetProcOrNil&<procedure(matrixMode: DummyEnum; m: IntPtr)>(MatrixLoad3x3fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x3fNV(matrixMode: DummyEnum; m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixLoad3x3fNV_1(matrixMode, m[0]) else
        ntv_MatrixLoad3x3fNV_1(matrixMode, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x3fNV(matrixMode: DummyEnum; var m: single) :=
      ntv_MatrixLoad3x3fNV_1(matrixMode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x3fNV(matrixMode: DummyEnum; m: IntPtr) :=
      ntv_MatrixLoad3x3fNV_2(matrixMode, m);
    
    private MatrixLoadTranspose3x3fNV_adr := GetProcAddress('glMatrixLoadTranspose3x3fNV');
    private ntv_MatrixLoadTranspose3x3fNV_1 := GetProcOrNil&<procedure(matrixMode: DummyEnum; var m: single)>(MatrixLoadTranspose3x3fNV_adr);
    private ntv_MatrixLoadTranspose3x3fNV_2 := GetProcOrNil&<procedure(matrixMode: DummyEnum; m: IntPtr)>(MatrixLoadTranspose3x3fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTranspose3x3fNV(matrixMode: DummyEnum; m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixLoadTranspose3x3fNV_1(matrixMode, m[0]) else
        ntv_MatrixLoadTranspose3x3fNV_1(matrixMode, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTranspose3x3fNV(matrixMode: DummyEnum; var m: single) :=
      ntv_MatrixLoadTranspose3x3fNV_1(matrixMode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTranspose3x3fNV(matrixMode: DummyEnum; m: IntPtr) :=
      ntv_MatrixLoadTranspose3x3fNV_2(matrixMode, m);
    
    private MatrixMult3x2fNV_adr := GetProcAddress('glMatrixMult3x2fNV');
    private ntv_MatrixMult3x2fNV_1 := GetProcOrNil&<procedure(matrixMode: DummyEnum; var m: single)>(MatrixMult3x2fNV_adr);
    private ntv_MatrixMult3x2fNV_2 := GetProcOrNil&<procedure(matrixMode: DummyEnum; m: IntPtr)>(MatrixMult3x2fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x2fNV(matrixMode: DummyEnum; m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixMult3x2fNV_1(matrixMode, m[0]) else
        ntv_MatrixMult3x2fNV_1(matrixMode, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x2fNV(matrixMode: DummyEnum; var m: single) :=
      ntv_MatrixMult3x2fNV_1(matrixMode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x2fNV(matrixMode: DummyEnum; m: IntPtr) :=
      ntv_MatrixMult3x2fNV_2(matrixMode, m);
    
    private MatrixMult3x3fNV_adr := GetProcAddress('glMatrixMult3x3fNV');
    private ntv_MatrixMult3x3fNV_1 := GetProcOrNil&<procedure(matrixMode: DummyEnum; var m: single)>(MatrixMult3x3fNV_adr);
    private ntv_MatrixMult3x3fNV_2 := GetProcOrNil&<procedure(matrixMode: DummyEnum; m: IntPtr)>(MatrixMult3x3fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x3fNV(matrixMode: DummyEnum; m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixMult3x3fNV_1(matrixMode, m[0]) else
        ntv_MatrixMult3x3fNV_1(matrixMode, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x3fNV(matrixMode: DummyEnum; var m: single) :=
      ntv_MatrixMult3x3fNV_1(matrixMode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x3fNV(matrixMode: DummyEnum; m: IntPtr) :=
      ntv_MatrixMult3x3fNV_2(matrixMode, m);
    
    private MatrixMultTranspose3x3fNV_adr := GetProcAddress('glMatrixMultTranspose3x3fNV');
    private ntv_MatrixMultTranspose3x3fNV_1 := GetProcOrNil&<procedure(matrixMode: DummyEnum; var m: single)>(MatrixMultTranspose3x3fNV_adr);
    private ntv_MatrixMultTranspose3x3fNV_2 := GetProcOrNil&<procedure(matrixMode: DummyEnum; m: IntPtr)>(MatrixMultTranspose3x3fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTranspose3x3fNV(matrixMode: DummyEnum; m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixMultTranspose3x3fNV_1(matrixMode, m[0]) else
        ntv_MatrixMultTranspose3x3fNV_1(matrixMode, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTranspose3x3fNV(matrixMode: DummyEnum; var m: single) :=
      ntv_MatrixMultTranspose3x3fNV_1(matrixMode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTranspose3x3fNV(matrixMode: DummyEnum; m: IntPtr) :=
      ntv_MatrixMultTranspose3x3fNV_2(matrixMode, m);
    
    private StencilThenCoverFillPathNV_adr := GetProcAddress('glStencilThenCoverFillPathNV');
    private ntv_StencilThenCoverFillPathNV_1 := GetProcOrNil&<procedure(path: UInt32; fillMode: glPathFillMode; mask: UInt32; coverMode: glPathCoverMode)>(StencilThenCoverFillPathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverFillPathNV(path: UInt32; fillMode: glPathFillMode; mask: UInt32; coverMode: glPathCoverMode) :=
      ntv_StencilThenCoverFillPathNV_1(path, fillMode, mask, coverMode);
    
    private StencilThenCoverStrokePathNV_adr := GetProcAddress('glStencilThenCoverStrokePathNV');
    private ntv_StencilThenCoverStrokePathNV_1 := GetProcOrNil&<procedure(path: UInt32; reference: Int32; mask: UInt32; coverMode: glPathCoverMode)>(StencilThenCoverStrokePathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverStrokePathNV(path: UInt32; reference: Int32; mask: UInt32; coverMode: glPathCoverMode) :=
      ntv_StencilThenCoverStrokePathNV_1(path, reference, mask, coverMode);
    
    private StencilThenCoverFillPathInstancedNV_adr := GetProcAddress('glStencilThenCoverFillPathInstancedNV');
    private ntv_StencilThenCoverFillPathInstancedNV_1 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; fillMode: glPathFillMode; mask: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; var transformValues: single)>(StencilThenCoverFillPathInstancedNV_adr);
    private ntv_StencilThenCoverFillPathInstancedNV_2 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; fillMode: glPathFillMode; mask: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; transformValues: IntPtr)>(StencilThenCoverFillPathInstancedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverFillPathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; fillMode: glPathFillMode; mask: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; transformValues: array of single);
    type PSingle = ^single;
    begin
      if (transformValues<>nil) and (transformValues.Length<>0) then
        ntv_StencilThenCoverFillPathInstancedNV_1(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues[0]) else
        ntv_StencilThenCoverFillPathInstancedNV_1(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverFillPathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; fillMode: glPathFillMode; mask: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; var transformValues: single) :=
      ntv_StencilThenCoverFillPathInstancedNV_1(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverFillPathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; fillMode: glPathFillMode; mask: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; transformValues: IntPtr) :=
      ntv_StencilThenCoverFillPathInstancedNV_2(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
    
    private StencilThenCoverStrokePathInstancedNV_adr := GetProcAddress('glStencilThenCoverStrokePathInstancedNV');
    private ntv_StencilThenCoverStrokePathInstancedNV_1 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; var transformValues: single)>(StencilThenCoverStrokePathInstancedNV_adr);
    private ntv_StencilThenCoverStrokePathInstancedNV_2 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; transformValues: IntPtr)>(StencilThenCoverStrokePathInstancedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverStrokePathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; transformValues: array of single);
    type PSingle = ^single;
    begin
      if (transformValues<>nil) and (transformValues.Length<>0) then
        ntv_StencilThenCoverStrokePathInstancedNV_1(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues[0]) else
        ntv_StencilThenCoverStrokePathInstancedNV_1(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverStrokePathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; var transformValues: single) :=
      ntv_StencilThenCoverStrokePathInstancedNV_1(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverStrokePathInstancedNV(numPaths: Int32; pathNameType: glPathElementType; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: glInstancedPathCoverMode; transformType: glPathTransformType; transformValues: IntPtr) :=
      ntv_StencilThenCoverStrokePathInstancedNV_2(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
    
    private PathGlyphIndexRangeNV_adr := GetProcAddress('glPathGlyphIndexRangeNV');
    private ntv_PathGlyphIndexRangeNV_1 := GetProcOrNil&<function(fontTarget: DummyEnum; fontName: IntPtr; fontStyle: glPathFontStyle; pathParameterTemplate: UInt32; emScale: single; var baseAndCount: UInt32): DummyEnum>(PathGlyphIndexRangeNV_adr);
    private ntv_PathGlyphIndexRangeNV_2 := GetProcOrNil&<function(fontTarget: DummyEnum; fontName: IntPtr; fontStyle: glPathFontStyle; pathParameterTemplate: UInt32; emScale: single; baseAndCount: IntPtr): DummyEnum>(PathGlyphIndexRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PathGlyphIndexRangeNV(fontTarget: DummyEnum; fontName: IntPtr; fontStyle: glPathFontStyle; pathParameterTemplate: UInt32; emScale: single; baseAndCount: array of UInt32): DummyEnum;
    type PUInt32 = ^UInt32;
    begin
      Result := if (baseAndCount<>nil) and (baseAndCount.Length<>0) then
        ntv_PathGlyphIndexRangeNV_1(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount[0]) else
        ntv_PathGlyphIndexRangeNV_1(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PathGlyphIndexRangeNV(fontTarget: DummyEnum; fontName: IntPtr; fontStyle: glPathFontStyle; pathParameterTemplate: UInt32; emScale: single; var baseAndCount: UInt32): DummyEnum :=
      ntv_PathGlyphIndexRangeNV_1(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PathGlyphIndexRangeNV(fontTarget: DummyEnum; fontName: IntPtr; fontStyle: glPathFontStyle; pathParameterTemplate: UInt32; emScale: single; baseAndCount: IntPtr): DummyEnum :=
      ntv_PathGlyphIndexRangeNV_2(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
    
    private PathGlyphIndexArrayNV_adr := GetProcAddress('glPathGlyphIndexArrayNV');
    private ntv_PathGlyphIndexArrayNV_1 := GetProcOrNil&<function(firstPathName: UInt32; fontTarget: DummyEnum; fontName: IntPtr; fontStyle: glPathFontStyle; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum>(PathGlyphIndexArrayNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PathGlyphIndexArrayNV(firstPathName: UInt32; fontTarget: DummyEnum; fontName: IntPtr; fontStyle: glPathFontStyle; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum :=
      ntv_PathGlyphIndexArrayNV_1(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    
    private PathMemoryGlyphIndexArrayNV_adr := GetProcAddress('glPathMemoryGlyphIndexArrayNV');
    private ntv_PathMemoryGlyphIndexArrayNV_1 := GetProcOrNil&<function(firstPathName: UInt32; fontTarget: DummyEnum; fontSize: UIntPtr; fontData: IntPtr; faceIndex: Int32; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum>(PathMemoryGlyphIndexArrayNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PathMemoryGlyphIndexArrayNV(firstPathName: UInt32; fontTarget: DummyEnum; fontSize: UIntPtr; fontData: IntPtr; faceIndex: Int32; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum :=
      ntv_PathMemoryGlyphIndexArrayNV_1(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    
    private ProgramPathFragmentInputGenNV_adr := GetProcAddress('glProgramPathFragmentInputGenNV');
    private ntv_ProgramPathFragmentInputGenNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; genMode: DummyEnum; components: Int32; var coeffs: single)>(ProgramPathFragmentInputGenNV_adr);
    private ntv_ProgramPathFragmentInputGenNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; genMode: DummyEnum; components: Int32; coeffs: IntPtr)>(ProgramPathFragmentInputGenNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramPathFragmentInputGenNV(&program: gl_program; location: Int32; genMode: DummyEnum; components: Int32; coeffs: array of single);
    type PSingle = ^single;
    begin
      if (coeffs<>nil) and (coeffs.Length<>0) then
        ntv_ProgramPathFragmentInputGenNV_1(&program, location, genMode, components, coeffs[0]) else
        ntv_ProgramPathFragmentInputGenNV_1(&program, location, genMode, components, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramPathFragmentInputGenNV(&program: gl_program; location: Int32; genMode: DummyEnum; components: Int32; var coeffs: single) :=
      ntv_ProgramPathFragmentInputGenNV_1(&program, location, genMode, components, coeffs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramPathFragmentInputGenNV(&program: gl_program; location: Int32; genMode: DummyEnum; components: Int32; coeffs: IntPtr) :=
      ntv_ProgramPathFragmentInputGenNV_2(&program, location, genMode, components, coeffs);
    
    private GetProgramResourcefvNV_adr := GetProcAddress('glGetProgramResourcefvNV');
    private ntv_GetProgramResourcefvNV_1 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: DummyEnum; count: Int32; var length: Int32; var &params: single)>(GetProgramResourcefvNV_adr);
    private ntv_GetProgramResourcefvNV_2 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: DummyEnum; count: Int32; var length: Int32; &params: IntPtr)>(GetProgramResourcefvNV_adr);
    private ntv_GetProgramResourcefvNV_3 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: DummyEnum; count: Int32; length: IntPtr; var &params: single)>(GetProgramResourcefvNV_adr);
    private ntv_GetProgramResourcefvNV_4 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: DummyEnum; count: Int32; length: IntPtr; &params: IntPtr)>(GetProgramResourcefvNV_adr);
    private ntv_GetProgramResourcefvNV_5 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; var &params: single)>(GetProgramResourcefvNV_adr);
    private ntv_GetProgramResourcefvNV_6 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; &params: IntPtr)>(GetProgramResourcefvNV_adr);
    private ntv_GetProgramResourcefvNV_7 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; var &params: single)>(GetProgramResourcefvNV_adr);
    private ntv_GetProgramResourcefvNV_8 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; &params: IntPtr)>(GetProgramResourcefvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: array of DummyEnum; count: Int32; var length: Int32; var &params: single);
    type PDummyEnum = ^DummyEnum;
    begin
      if (props<>nil) and (props.Length<>0) then
        ntv_GetProgramResourcefvNV_1(&program, programInterface, index, propCount, props[0], count, length, &params) else
        ntv_GetProgramResourcefvNV_1(&program, programInterface, index, propCount, PDummyEnum(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: array of DummyEnum; count: Int32; var length: Int32; &params: IntPtr);
    type PDummyEnum = ^DummyEnum;
    begin
      if (props<>nil) and (props.Length<>0) then
        ntv_GetProgramResourcefvNV_2(&program, programInterface, index, propCount, props[0], count, length, &params) else
        ntv_GetProgramResourcefvNV_2(&program, programInterface, index, propCount, PDummyEnum(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: array of DummyEnum; count: Int32; length: IntPtr; var &params: single);
    type PDummyEnum = ^DummyEnum;
    begin
      if (props<>nil) and (props.Length<>0) then
        ntv_GetProgramResourcefvNV_3(&program, programInterface, index, propCount, props[0], count, length, &params) else
        ntv_GetProgramResourcefvNV_3(&program, programInterface, index, propCount, PDummyEnum(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: array of DummyEnum; count: Int32; length: IntPtr; &params: IntPtr);
    type PDummyEnum = ^DummyEnum;
    begin
      if (props<>nil) and (props.Length<>0) then
        ntv_GetProgramResourcefvNV_4(&program, programInterface, index, propCount, props[0], count, length, &params) else
        ntv_GetProgramResourcefvNV_4(&program, programInterface, index, propCount, PDummyEnum(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: DummyEnum; count: Int32; var length: Int32; var &params: single) :=
      ntv_GetProgramResourcefvNV_1(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: DummyEnum; count: Int32; var length: Int32; &params: IntPtr) :=
      ntv_GetProgramResourcefvNV_2(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: DummyEnum; count: Int32; length: IntPtr; var &params: single) :=
      ntv_GetProgramResourcefvNV_3(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: DummyEnum; count: Int32; length: IntPtr; &params: IntPtr) :=
      ntv_GetProgramResourcefvNV_4(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; var &params: single) :=
      ntv_GetProgramResourcefvNV_5(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; &params: IntPtr) :=
      ntv_GetProgramResourcefvNV_6(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; var &params: single) :=
      ntv_GetProgramResourcefvNV_7(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; &params: IntPtr) :=
      ntv_GetProgramResourcefvNV_8(&program, programInterface, index, propCount, props, count, length, &params);
    
    private PathColorGenNV_adr := GetProcAddress('glPathColorGenNV');
    private ntv_PathColorGenNV_1 := GetProcOrNil&<procedure(color: glPathColor; genMode: glPathGenMode; colorFormat: glPathColorFormat; var coeffs: single)>(PathColorGenNV_adr);
    private ntv_PathColorGenNV_2 := GetProcOrNil&<procedure(color: glPathColor; genMode: glPathGenMode; colorFormat: glPathColorFormat; coeffs: IntPtr)>(PathColorGenNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathColorGenNV(color: glPathColor; genMode: glPathGenMode; colorFormat: glPathColorFormat; coeffs: array of single);
    type PSingle = ^single;
    begin
      if (coeffs<>nil) and (coeffs.Length<>0) then
        ntv_PathColorGenNV_1(color, genMode, colorFormat, coeffs[0]) else
        ntv_PathColorGenNV_1(color, genMode, colorFormat, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathColorGenNV(color: glPathColor; genMode: glPathGenMode; colorFormat: glPathColorFormat; var coeffs: single) :=
      ntv_PathColorGenNV_1(color, genMode, colorFormat, coeffs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathColorGenNV(color: glPathColor; genMode: glPathGenMode; colorFormat: glPathColorFormat; coeffs: IntPtr) :=
      ntv_PathColorGenNV_2(color, genMode, colorFormat, coeffs);
    
    private PathTexGenNV_adr := GetProcAddress('glPathTexGenNV');
    private ntv_PathTexGenNV_1 := GetProcOrNil&<procedure(texCoordSet: glPathColor; genMode: glPathGenMode; components: Int32; var coeffs: single)>(PathTexGenNV_adr);
    private ntv_PathTexGenNV_2 := GetProcOrNil&<procedure(texCoordSet: glPathColor; genMode: glPathGenMode; components: Int32; coeffs: IntPtr)>(PathTexGenNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathTexGenNV(texCoordSet: glPathColor; genMode: glPathGenMode; components: Int32; coeffs: array of single);
    type PSingle = ^single;
    begin
      if (coeffs<>nil) and (coeffs.Length<>0) then
        ntv_PathTexGenNV_1(texCoordSet, genMode, components, coeffs[0]) else
        ntv_PathTexGenNV_1(texCoordSet, genMode, components, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathTexGenNV(texCoordSet: glPathColor; genMode: glPathGenMode; components: Int32; var coeffs: single) :=
      ntv_PathTexGenNV_1(texCoordSet, genMode, components, coeffs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathTexGenNV(texCoordSet: glPathColor; genMode: glPathGenMode; components: Int32; coeffs: IntPtr) :=
      ntv_PathTexGenNV_2(texCoordSet, genMode, components, coeffs);
    
    private PathFogGenNV_adr := GetProcAddress('glPathFogGenNV');
    private ntv_PathFogGenNV_1 := GetProcOrNil&<procedure(genMode: glPathGenMode)>(PathFogGenNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathFogGenNV(genMode: glPathGenMode) :=
      ntv_PathFogGenNV_1(genMode);
    
    private GetPathColorGenivNV_adr := GetProcAddress('glGetPathColorGenivNV');
    private ntv_GetPathColorGenivNV_1 := GetProcOrNil&<procedure(color: glPathColor; pname: glPathGenMode; var value: Int32)>(GetPathColorGenivNV_adr);
    private ntv_GetPathColorGenivNV_2 := GetProcOrNil&<procedure(color: glPathColor; pname: glPathGenMode; value: IntPtr)>(GetPathColorGenivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenivNV(color: glPathColor; pname: glPathGenMode; var value: Int32) :=
      ntv_GetPathColorGenivNV_1(color, pname, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenivNV(color: glPathColor; pname: glPathGenMode; value: IntPtr) :=
      ntv_GetPathColorGenivNV_2(color, pname, value);
    
    private GetPathColorGenfvNV_adr := GetProcAddress('glGetPathColorGenfvNV');
    private ntv_GetPathColorGenfvNV_1 := GetProcOrNil&<procedure(color: glPathColor; pname: glPathGenMode; var value: single)>(GetPathColorGenfvNV_adr);
    private ntv_GetPathColorGenfvNV_2 := GetProcOrNil&<procedure(color: glPathColor; pname: glPathGenMode; value: IntPtr)>(GetPathColorGenfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenfvNV(color: glPathColor; pname: glPathGenMode; var value: single) :=
      ntv_GetPathColorGenfvNV_1(color, pname, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenfvNV(color: glPathColor; pname: glPathGenMode; value: IntPtr) :=
      ntv_GetPathColorGenfvNV_2(color, pname, value);
    
    private GetPathTexGenivNV_adr := GetProcAddress('glGetPathTexGenivNV');
    private ntv_GetPathTexGenivNV_1 := GetProcOrNil&<procedure(texCoordSet: glTextureUnit; pname: glPathGenMode; var value: Int32)>(GetPathTexGenivNV_adr);
    private ntv_GetPathTexGenivNV_2 := GetProcOrNil&<procedure(texCoordSet: glTextureUnit; pname: glPathGenMode; value: IntPtr)>(GetPathTexGenivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenivNV(texCoordSet: glTextureUnit; pname: glPathGenMode; var value: Int32) :=
      ntv_GetPathTexGenivNV_1(texCoordSet, pname, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenivNV(texCoordSet: glTextureUnit; pname: glPathGenMode; value: IntPtr) :=
      ntv_GetPathTexGenivNV_2(texCoordSet, pname, value);
    
    private GetPathTexGenfvNV_adr := GetProcAddress('glGetPathTexGenfvNV');
    private ntv_GetPathTexGenfvNV_1 := GetProcOrNil&<procedure(texCoordSet: glTextureUnit; pname: glPathGenMode; var value: single)>(GetPathTexGenfvNV_adr);
    private ntv_GetPathTexGenfvNV_2 := GetProcOrNil&<procedure(texCoordSet: glTextureUnit; pname: glPathGenMode; value: IntPtr)>(GetPathTexGenfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenfvNV(texCoordSet: glTextureUnit; pname: glPathGenMode; var value: single) :=
      ntv_GetPathTexGenfvNV_1(texCoordSet, pname, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenfvNV(texCoordSet: glTextureUnit; pname: glPathGenMode; value: IntPtr) :=
      ntv_GetPathTexGenfvNV_2(texCoordSet, pname, value);
    
    private MatrixFrustumEXT_adr := GetProcAddress('glMatrixFrustumEXT');
    private ntv_MatrixFrustumEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double)>(MatrixFrustumEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixFrustumEXT(mode: glMatrixMode; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double) :=
      ntv_MatrixFrustumEXT_1(mode, left, right, bottom, top, zNear, zFar);
    
    private MatrixLoadIdentityEXT_adr := GetProcAddress('glMatrixLoadIdentityEXT');
    private ntv_MatrixLoadIdentityEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode)>(MatrixLoadIdentityEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadIdentityEXT(mode: glMatrixMode) :=
      ntv_MatrixLoadIdentityEXT_1(mode);
    
    private MatrixLoadTransposefEXT_adr := GetProcAddress('glMatrixLoadTransposefEXT');
    private ntv_MatrixLoadTransposefEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; var m: single)>(MatrixLoadTransposefEXT_adr);
    private ntv_MatrixLoadTransposefEXT_2 := GetProcOrNil&<procedure(mode: glMatrixMode; m: IntPtr)>(MatrixLoadTransposefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: glMatrixMode; m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixLoadTransposefEXT_1(mode, m[0]) else
        ntv_MatrixLoadTransposefEXT_1(mode, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: glMatrixMode; var m: single) :=
      ntv_MatrixLoadTransposefEXT_1(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: glMatrixMode; m: IntPtr) :=
      ntv_MatrixLoadTransposefEXT_2(mode, m);
    
    private MatrixLoadTransposedEXT_adr := GetProcAddress('glMatrixLoadTransposedEXT');
    private ntv_MatrixLoadTransposedEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; var m: double)>(MatrixLoadTransposedEXT_adr);
    private ntv_MatrixLoadTransposedEXT_2 := GetProcOrNil&<procedure(mode: glMatrixMode; m: IntPtr)>(MatrixLoadTransposedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: glMatrixMode; m: array of double);
    type PDouble = ^double;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixLoadTransposedEXT_1(mode, m[0]) else
        ntv_MatrixLoadTransposedEXT_1(mode, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: glMatrixMode; var m: double) :=
      ntv_MatrixLoadTransposedEXT_1(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: glMatrixMode; m: IntPtr) :=
      ntv_MatrixLoadTransposedEXT_2(mode, m);
    
    private MatrixLoadfEXT_adr := GetProcAddress('glMatrixLoadfEXT');
    private ntv_MatrixLoadfEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; var m: single)>(MatrixLoadfEXT_adr);
    private ntv_MatrixLoadfEXT_2 := GetProcOrNil&<procedure(mode: glMatrixMode; m: IntPtr)>(MatrixLoadfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: glMatrixMode; m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixLoadfEXT_1(mode, m[0]) else
        ntv_MatrixLoadfEXT_1(mode, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: glMatrixMode; var m: single) :=
      ntv_MatrixLoadfEXT_1(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: glMatrixMode; m: IntPtr) :=
      ntv_MatrixLoadfEXT_2(mode, m);
    
    private MatrixLoaddEXT_adr := GetProcAddress('glMatrixLoaddEXT');
    private ntv_MatrixLoaddEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; var m: double)>(MatrixLoaddEXT_adr);
    private ntv_MatrixLoaddEXT_2 := GetProcOrNil&<procedure(mode: glMatrixMode; m: IntPtr)>(MatrixLoaddEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: glMatrixMode; m: array of double);
    type PDouble = ^double;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixLoaddEXT_1(mode, m[0]) else
        ntv_MatrixLoaddEXT_1(mode, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: glMatrixMode; var m: double) :=
      ntv_MatrixLoaddEXT_1(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: glMatrixMode; m: IntPtr) :=
      ntv_MatrixLoaddEXT_2(mode, m);
    
    private MatrixMultTransposefEXT_adr := GetProcAddress('glMatrixMultTransposefEXT');
    private ntv_MatrixMultTransposefEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; var m: single)>(MatrixMultTransposefEXT_adr);
    private ntv_MatrixMultTransposefEXT_2 := GetProcOrNil&<procedure(mode: glMatrixMode; m: IntPtr)>(MatrixMultTransposefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: glMatrixMode; m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixMultTransposefEXT_1(mode, m[0]) else
        ntv_MatrixMultTransposefEXT_1(mode, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: glMatrixMode; var m: single) :=
      ntv_MatrixMultTransposefEXT_1(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: glMatrixMode; m: IntPtr) :=
      ntv_MatrixMultTransposefEXT_2(mode, m);
    
    private MatrixMultTransposedEXT_adr := GetProcAddress('glMatrixMultTransposedEXT');
    private ntv_MatrixMultTransposedEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; var m: double)>(MatrixMultTransposedEXT_adr);
    private ntv_MatrixMultTransposedEXT_2 := GetProcOrNil&<procedure(mode: glMatrixMode; m: IntPtr)>(MatrixMultTransposedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: glMatrixMode; m: array of double);
    type PDouble = ^double;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixMultTransposedEXT_1(mode, m[0]) else
        ntv_MatrixMultTransposedEXT_1(mode, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: glMatrixMode; var m: double) :=
      ntv_MatrixMultTransposedEXT_1(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: glMatrixMode; m: IntPtr) :=
      ntv_MatrixMultTransposedEXT_2(mode, m);
    
    private MatrixMultfEXT_adr := GetProcAddress('glMatrixMultfEXT');
    private ntv_MatrixMultfEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; var m: single)>(MatrixMultfEXT_adr);
    private ntv_MatrixMultfEXT_2 := GetProcOrNil&<procedure(mode: glMatrixMode; m: IntPtr)>(MatrixMultfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: glMatrixMode; m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixMultfEXT_1(mode, m[0]) else
        ntv_MatrixMultfEXT_1(mode, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: glMatrixMode; var m: single) :=
      ntv_MatrixMultfEXT_1(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: glMatrixMode; m: IntPtr) :=
      ntv_MatrixMultfEXT_2(mode, m);
    
    private MatrixMultdEXT_adr := GetProcAddress('glMatrixMultdEXT');
    private ntv_MatrixMultdEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; var m: double)>(MatrixMultdEXT_adr);
    private ntv_MatrixMultdEXT_2 := GetProcOrNil&<procedure(mode: glMatrixMode; m: IntPtr)>(MatrixMultdEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: glMatrixMode; m: array of double);
    type PDouble = ^double;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MatrixMultdEXT_1(mode, m[0]) else
        ntv_MatrixMultdEXT_1(mode, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: glMatrixMode; var m: double) :=
      ntv_MatrixMultdEXT_1(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: glMatrixMode; m: IntPtr) :=
      ntv_MatrixMultdEXT_2(mode, m);
    
    private MatrixOrthoEXT_adr := GetProcAddress('glMatrixOrthoEXT');
    private ntv_MatrixOrthoEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double)>(MatrixOrthoEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixOrthoEXT(mode: glMatrixMode; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double) :=
      ntv_MatrixOrthoEXT_1(mode, left, right, bottom, top, zNear, zFar);
    
    private MatrixPopEXT_adr := GetProcAddress('glMatrixPopEXT');
    private ntv_MatrixPopEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode)>(MatrixPopEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixPopEXT(mode: glMatrixMode) :=
      ntv_MatrixPopEXT_1(mode);
    
    private MatrixPushEXT_adr := GetProcAddress('glMatrixPushEXT');
    private ntv_MatrixPushEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode)>(MatrixPushEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixPushEXT(mode: glMatrixMode) :=
      ntv_MatrixPushEXT_1(mode);
    
    private MatrixRotatefEXT_adr := GetProcAddress('glMatrixRotatefEXT');
    private ntv_MatrixRotatefEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; angle: single; x: single; y: single; z: single)>(MatrixRotatefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixRotatefEXT(mode: glMatrixMode; angle: single; x: single; y: single; z: single) :=
      ntv_MatrixRotatefEXT_1(mode, angle, x, y, z);
    
    private MatrixRotatedEXT_adr := GetProcAddress('glMatrixRotatedEXT');
    private ntv_MatrixRotatedEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; angle: double; x: double; y: double; z: double)>(MatrixRotatedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixRotatedEXT(mode: glMatrixMode; angle: double; x: double; y: double; z: double) :=
      ntv_MatrixRotatedEXT_1(mode, angle, x, y, z);
    
    private MatrixScalefEXT_adr := GetProcAddress('glMatrixScalefEXT');
    private ntv_MatrixScalefEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; x: single; y: single; z: single)>(MatrixScalefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixScalefEXT(mode: glMatrixMode; x: single; y: single; z: single) :=
      ntv_MatrixScalefEXT_1(mode, x, y, z);
    
    private MatrixScaledEXT_adr := GetProcAddress('glMatrixScaledEXT');
    private ntv_MatrixScaledEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; x: double; y: double; z: double)>(MatrixScaledEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixScaledEXT(mode: glMatrixMode; x: double; y: double; z: double) :=
      ntv_MatrixScaledEXT_1(mode, x, y, z);
    
    private MatrixTranslatefEXT_adr := GetProcAddress('glMatrixTranslatefEXT');
    private ntv_MatrixTranslatefEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; x: single; y: single; z: single)>(MatrixTranslatefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixTranslatefEXT(mode: glMatrixMode; x: single; y: single; z: single) :=
      ntv_MatrixTranslatefEXT_1(mode, x, y, z);
    
    private MatrixTranslatedEXT_adr := GetProcAddress('glMatrixTranslatedEXT');
    private ntv_MatrixTranslatedEXT_1 := GetProcOrNil&<procedure(mode: glMatrixMode; x: double; y: double; z: double)>(MatrixTranslatedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixTranslatedEXT(mode: glMatrixMode; x: double; y: double; z: double) :=
      ntv_MatrixTranslatedEXT_1(mode, x, y, z);
    
  end;
  
  ///
  glPathRenderingSharedEdgeNV = static class
    public const _ExtStr = 'GL_NV_path_rendering_shared_edge';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPixelDataRangeNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_pixel_data_range';
    
    private PixelDataRangeNV_adr := GetProcAddress('glPixelDataRangeNV');
    private ntv_PixelDataRangeNV_1 := GetProcOrNil&<procedure(target: glPixelDataRangeTarget; length: Int32; pointer: IntPtr)>(PixelDataRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelDataRangeNV(target: glPixelDataRangeTarget; length: Int32; pointer: IntPtr) :=
      ntv_PixelDataRangeNV_1(target, length, pointer);
    
    private FlushPixelDataRangeNV_adr := GetProcAddress('glFlushPixelDataRangeNV');
    private ntv_FlushPixelDataRangeNV_1 := GetProcOrNil&<procedure(target: glPixelDataRangeTarget)>(FlushPixelDataRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushPixelDataRangeNV(target: glPixelDataRangeTarget) :=
      ntv_FlushPixelDataRangeNV_1(target);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPointSpriteNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_point_sprite';
    
    private PointParameteriNV_adr := GetProcAddress('glPointParameteriNV');
    private ntv_PointParameteriNV_1 := GetProcOrNil&<procedure(pname: glPointParameterName; param: Int32)>(PointParameteriNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameteriNV(pname: glPointParameterName; param: Int32) :=
      ntv_PointParameteriNV_1(pname, param);
    
    private PointParameterivNV_adr := GetProcAddress('glPointParameterivNV');
    private ntv_PointParameterivNV_1 := GetProcOrNil&<procedure(pname: glPointParameterName; var &params: Int32)>(PointParameterivNV_adr);
    private ntv_PointParameterivNV_2 := GetProcOrNil&<procedure(pname: glPointParameterName; &params: IntPtr)>(PointParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterivNV(pname: glPointParameterName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_PointParameterivNV_1(pname, &params[0]) else
        ntv_PointParameterivNV_1(pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterivNV(pname: glPointParameterName; var &params: Int32) :=
      ntv_PointParameterivNV_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterivNV(pname: glPointParameterName; &params: IntPtr) :=
      ntv_PointParameterivNV_2(pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPresentVideoNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_present_video';
    
    private PresentFrameKeyedNV_adr := GetProcAddress('glPresentFrameKeyedNV');
    private ntv_PresentFrameKeyedNV_1 := GetProcOrNil&<procedure(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; key0: UInt32; target1: DummyEnum; fill1: UInt32; key1: UInt32)>(PresentFrameKeyedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PresentFrameKeyedNV(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; key0: UInt32; target1: DummyEnum; fill1: UInt32; key1: UInt32) :=
      ntv_PresentFrameKeyedNV_1(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, &type, target0, fill0, key0, target1, fill1, key1);
    
    private PresentFrameDualFillNV_adr := GetProcAddress('glPresentFrameDualFillNV');
    private ntv_PresentFrameDualFillNV_1 := GetProcOrNil&<procedure(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; target1: DummyEnum; fill1: UInt32; target2: DummyEnum; fill2: UInt32; target3: DummyEnum; fill3: UInt32)>(PresentFrameDualFillNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PresentFrameDualFillNV(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; target1: DummyEnum; fill1: UInt32; target2: DummyEnum; fill2: UInt32; target3: DummyEnum; fill3: UInt32) :=
      ntv_PresentFrameDualFillNV_1(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, &type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
    
    private GetVideoivNV_adr := GetProcAddress('glGetVideoivNV');
    private ntv_GetVideoivNV_1 := GetProcOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; var &params: Int32)>(GetVideoivNV_adr);
    private ntv_GetVideoivNV_2 := GetProcOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: IntPtr)>(GetVideoivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoivNV(video_slot: UInt32; pname: DummyEnum; var &params: Int32) :=
      ntv_GetVideoivNV_1(video_slot, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoivNV(video_slot: UInt32; pname: DummyEnum; &params: IntPtr) :=
      ntv_GetVideoivNV_2(video_slot, pname, &params);
    
    private GetVideouivNV_adr := GetProcAddress('glGetVideouivNV');
    private ntv_GetVideouivNV_1 := GetProcOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; var &params: UInt32)>(GetVideouivNV_adr);
    private ntv_GetVideouivNV_2 := GetProcOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: IntPtr)>(GetVideouivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideouivNV(video_slot: UInt32; pname: DummyEnum; var &params: UInt32) :=
      ntv_GetVideouivNV_1(video_slot, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideouivNV(video_slot: UInt32; pname: DummyEnum; &params: IntPtr) :=
      ntv_GetVideouivNV_2(video_slot, pname, &params);
    
    private GetVideoi64vNV_adr := GetProcAddress('glGetVideoi64vNV');
    private ntv_GetVideoi64vNV_1 := GetProcOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; var &params: Int64)>(GetVideoi64vNV_adr);
    private ntv_GetVideoi64vNV_2 := GetProcOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: IntPtr)>(GetVideoi64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoi64vNV(video_slot: UInt32; pname: DummyEnum; var &params: Int64) :=
      ntv_GetVideoi64vNV_1(video_slot, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoi64vNV(video_slot: UInt32; pname: DummyEnum; &params: IntPtr) :=
      ntv_GetVideoi64vNV_2(video_slot, pname, &params);
    
    private GetVideoui64vNV_adr := GetProcAddress('glGetVideoui64vNV');
    private ntv_GetVideoui64vNV_1 := GetProcOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; var &params: UInt64)>(GetVideoui64vNV_adr);
    private ntv_GetVideoui64vNV_2 := GetProcOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: IntPtr)>(GetVideoui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoui64vNV(video_slot: UInt32; pname: DummyEnum; var &params: UInt64) :=
      ntv_GetVideoui64vNV_1(video_slot, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoui64vNV(video_slot: UInt32; pname: DummyEnum; &params: IntPtr) :=
      ntv_GetVideoui64vNV_2(video_slot, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPrimitiveRestartNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_primitive_restart';
    
    private PrimitiveRestartNV_adr := GetProcAddress('glPrimitiveRestartNV');
    private ntv_PrimitiveRestartNV_1 := GetProcOrNil&<procedure>(PrimitiveRestartNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrimitiveRestartNV :=
      ntv_PrimitiveRestartNV_1;
    
    private PrimitiveRestartIndexNV_adr := GetProcAddress('glPrimitiveRestartIndexNV');
    private ntv_PrimitiveRestartIndexNV_1 := GetProcOrNil&<procedure(index: UInt32)>(PrimitiveRestartIndexNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrimitiveRestartIndexNV(index: UInt32) :=
      ntv_PrimitiveRestartIndexNV_1(index);
    
  end;
  
  ///
  glPrimitiveShadingRateNV = static class
    public const _ExtStr = 'GL_NV_primitive_shading_rate';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glQueryResourceNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_query_resource';
    
    private QueryResourceNV_adr := GetProcAddress('glQueryResourceNV');
    private ntv_QueryResourceNV_1 := GetProcOrNil&<function(queryType: DummyEnum; tagId: Int32; count: UInt32; var buffer: Int32): Int32>(QueryResourceNV_adr);
    private ntv_QueryResourceNV_2 := GetProcOrNil&<function(queryType: DummyEnum; tagId: Int32; count: UInt32; buffer: IntPtr): Int32>(QueryResourceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryResourceNV(queryType: DummyEnum; tagId: Int32; count: UInt32; buffer: array of Int32): Int32;
    type PInt32 = ^Int32;
    begin
      Result := if (buffer<>nil) and (buffer.Length<>0) then
        ntv_QueryResourceNV_1(queryType, tagId, count, buffer[0]) else
        ntv_QueryResourceNV_1(queryType, tagId, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryResourceNV(queryType: DummyEnum; tagId: Int32; count: UInt32; var buffer: Int32): Int32 :=
      ntv_QueryResourceNV_1(queryType, tagId, count, buffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryResourceNV(queryType: DummyEnum; tagId: Int32; count: UInt32; buffer: IntPtr): Int32 :=
      ntv_QueryResourceNV_2(queryType, tagId, count, buffer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glQueryResourceTagNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_query_resource_tag';
    
    private GenQueryResourceTagNV_adr := GetProcAddress('glGenQueryResourceTagNV');
    private ntv_GenQueryResourceTagNV_1 := GetProcOrNil&<procedure(n: Int32; var tagIds: Int32)>(GenQueryResourceTagNV_adr);
    private ntv_GenQueryResourceTagNV_2 := GetProcOrNil&<procedure(n: Int32; tagIds: IntPtr)>(GenQueryResourceTagNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueryResourceTagNV(n: Int32; tagIds: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (tagIds<>nil) and (tagIds.Length<>0) then
        ntv_GenQueryResourceTagNV_1(n, tagIds[0]) else
        ntv_GenQueryResourceTagNV_1(n, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueryResourceTagNV(n: Int32; var tagIds: Int32) :=
      ntv_GenQueryResourceTagNV_1(n, tagIds);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueryResourceTagNV(n: Int32; tagIds: IntPtr) :=
      ntv_GenQueryResourceTagNV_2(n, tagIds);
    
    private DeleteQueryResourceTagNV_adr := GetProcAddress('glDeleteQueryResourceTagNV');
    private ntv_DeleteQueryResourceTagNV_1 := GetProcOrNil&<procedure(n: Int32; var tagIds: Int32)>(DeleteQueryResourceTagNV_adr);
    private ntv_DeleteQueryResourceTagNV_2 := GetProcOrNil&<procedure(n: Int32; tagIds: IntPtr)>(DeleteQueryResourceTagNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueryResourceTagNV(n: Int32; tagIds: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (tagIds<>nil) and (tagIds.Length<>0) then
        ntv_DeleteQueryResourceTagNV_1(n, tagIds[0]) else
        ntv_DeleteQueryResourceTagNV_1(n, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueryResourceTagNV(n: Int32; var tagIds: Int32) :=
      ntv_DeleteQueryResourceTagNV_1(n, tagIds);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueryResourceTagNV(n: Int32; tagIds: IntPtr) :=
      ntv_DeleteQueryResourceTagNV_2(n, tagIds);
    
    private QueryResourceTagNV_adr := GetProcAddress('glQueryResourceTagNV');
    private ntv_QueryResourceTagNV_1 := GetProcOrNil&<procedure(tagId: Int32; tagString: IntPtr)>(QueryResourceTagNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryResourceTagNV(tagId: Int32; tagString: string);
    begin
      var tagString_str_ptr := Marshal.StringToHGlobalAnsi(tagString);
      try
        ntv_QueryResourceTagNV_1(tagId, tagString_str_ptr);
      finally
        Marshal.FreeHGlobal(tagString_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryResourceTagNV(tagId: Int32; tagString: IntPtr) :=
      ntv_QueryResourceTagNV_1(tagId, tagString);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glRegisterCombinersNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_register_combiners';
    
    private CombinerParameterfvNV_adr := GetProcAddress('glCombinerParameterfvNV');
    private ntv_CombinerParameterfvNV_1 := GetProcOrNil&<procedure(pname: glCombinerParameter; var &params: single)>(CombinerParameterfvNV_adr);
    private ntv_CombinerParameterfvNV_2 := GetProcOrNil&<procedure(pname: glCombinerParameter; &params: IntPtr)>(CombinerParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterfvNV(pname: glCombinerParameter; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_CombinerParameterfvNV_1(pname, &params[0]) else
        ntv_CombinerParameterfvNV_1(pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterfvNV(pname: glCombinerParameter; var &params: single) :=
      ntv_CombinerParameterfvNV_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterfvNV(pname: glCombinerParameter; &params: IntPtr) :=
      ntv_CombinerParameterfvNV_2(pname, &params);
    
    private CombinerParameterfNV_adr := GetProcAddress('glCombinerParameterfNV');
    private ntv_CombinerParameterfNV_1 := GetProcOrNil&<procedure(pname: glCombinerParameter; param: single)>(CombinerParameterfNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterfNV(pname: glCombinerParameter; param: single) :=
      ntv_CombinerParameterfNV_1(pname, param);
    
    private CombinerParameterivNV_adr := GetProcAddress('glCombinerParameterivNV');
    private ntv_CombinerParameterivNV_1 := GetProcOrNil&<procedure(pname: glCombinerParameter; var &params: Int32)>(CombinerParameterivNV_adr);
    private ntv_CombinerParameterivNV_2 := GetProcOrNil&<procedure(pname: glCombinerParameter; &params: IntPtr)>(CombinerParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterivNV(pname: glCombinerParameter; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_CombinerParameterivNV_1(pname, &params[0]) else
        ntv_CombinerParameterivNV_1(pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterivNV(pname: glCombinerParameter; var &params: Int32) :=
      ntv_CombinerParameterivNV_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterivNV(pname: glCombinerParameter; &params: IntPtr) :=
      ntv_CombinerParameterivNV_2(pname, &params);
    
    private CombinerParameteriNV_adr := GetProcAddress('glCombinerParameteriNV');
    private ntv_CombinerParameteriNV_1 := GetProcOrNil&<procedure(pname: glCombinerParameter; param: Int32)>(CombinerParameteriNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameteriNV(pname: glCombinerParameter; param: Int32) :=
      ntv_CombinerParameteriNV_1(pname, param);
    
    private CombinerInputNV_adr := GetProcAddress('glCombinerInputNV');
    private ntv_CombinerInputNV_1 := GetProcOrNil&<procedure(stage: glCombinerStage; portion: glCombinerPortion; variable: glCombinerVariable; input: glCombinerRegister; mapping: glCombinerMapping; componentUsage: glCombinerComponentUsage)>(CombinerInputNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerInputNV(stage: glCombinerStage; portion: glCombinerPortion; variable: glCombinerVariable; input: glCombinerRegister; mapping: glCombinerMapping; componentUsage: glCombinerComponentUsage) :=
      ntv_CombinerInputNV_1(stage, portion, variable, input, mapping, componentUsage);
    
    private CombinerOutputNV_adr := GetProcAddress('glCombinerOutputNV');
    private ntv_CombinerOutputNV_1 := GetProcOrNil&<procedure(stage: glCombinerStage; portion: glCombinerPortion; abOutput: glCombinerRegister; cdOutput: glCombinerRegister; sumOutput: glCombinerRegister; scale: glCombinerScale; bias: glCombinerBias; abDotProduct: glBool8; cdDotProduct: glBool8; muxSum: glBool8)>(CombinerOutputNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerOutputNV(stage: glCombinerStage; portion: glCombinerPortion; abOutput: glCombinerRegister; cdOutput: glCombinerRegister; sumOutput: glCombinerRegister; scale: glCombinerScale; bias: glCombinerBias; abDotProduct: glBool8; cdDotProduct: glBool8; muxSum: glBool8) :=
      ntv_CombinerOutputNV_1(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
    
    private FinalCombinerInputNV_adr := GetProcAddress('glFinalCombinerInputNV');
    private ntv_FinalCombinerInputNV_1 := GetProcOrNil&<procedure(variable: glCombinerVariable; input: glCombinerRegister; mapping: glCombinerMapping; componentUsage: glCombinerComponentUsage)>(FinalCombinerInputNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinalCombinerInputNV(variable: glCombinerVariable; input: glCombinerRegister; mapping: glCombinerMapping; componentUsage: glCombinerComponentUsage) :=
      ntv_FinalCombinerInputNV_1(variable, input, mapping, componentUsage);
    
    private GetCombinerInputParameterfvNV_adr := GetProcAddress('glGetCombinerInputParameterfvNV');
    private ntv_GetCombinerInputParameterfvNV_1 := GetProcOrNil&<procedure(stage: glCombinerStage; portion: glCombinerPortion; variable: glCombinerVariable; pname: glCombinerParameter; var &params: single)>(GetCombinerInputParameterfvNV_adr);
    private ntv_GetCombinerInputParameterfvNV_2 := GetProcOrNil&<procedure(stage: glCombinerStage; portion: glCombinerPortion; variable: glCombinerVariable; pname: glCombinerParameter; &params: IntPtr)>(GetCombinerInputParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterfvNV(stage: glCombinerStage; portion: glCombinerPortion; variable: glCombinerVariable; pname: glCombinerParameter; var &params: single) :=
      ntv_GetCombinerInputParameterfvNV_1(stage, portion, variable, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterfvNV(stage: glCombinerStage; portion: glCombinerPortion; variable: glCombinerVariable; pname: glCombinerParameter; &params: IntPtr) :=
      ntv_GetCombinerInputParameterfvNV_2(stage, portion, variable, pname, &params);
    
    private GetCombinerInputParameterivNV_adr := GetProcAddress('glGetCombinerInputParameterivNV');
    private ntv_GetCombinerInputParameterivNV_1 := GetProcOrNil&<procedure(stage: glCombinerStage; portion: glCombinerPortion; variable: glCombinerVariable; pname: glCombinerParameter; var &params: Int32)>(GetCombinerInputParameterivNV_adr);
    private ntv_GetCombinerInputParameterivNV_2 := GetProcOrNil&<procedure(stage: glCombinerStage; portion: glCombinerPortion; variable: glCombinerVariable; pname: glCombinerParameter; &params: IntPtr)>(GetCombinerInputParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterivNV(stage: glCombinerStage; portion: glCombinerPortion; variable: glCombinerVariable; pname: glCombinerParameter; var &params: Int32) :=
      ntv_GetCombinerInputParameterivNV_1(stage, portion, variable, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterivNV(stage: glCombinerStage; portion: glCombinerPortion; variable: glCombinerVariable; pname: glCombinerParameter; &params: IntPtr) :=
      ntv_GetCombinerInputParameterivNV_2(stage, portion, variable, pname, &params);
    
    private GetCombinerOutputParameterfvNV_adr := GetProcAddress('glGetCombinerOutputParameterfvNV');
    private ntv_GetCombinerOutputParameterfvNV_1 := GetProcOrNil&<procedure(stage: glCombinerStage; portion: glCombinerPortion; pname: glCombinerParameter; var &params: single)>(GetCombinerOutputParameterfvNV_adr);
    private ntv_GetCombinerOutputParameterfvNV_2 := GetProcOrNil&<procedure(stage: glCombinerStage; portion: glCombinerPortion; pname: glCombinerParameter; &params: IntPtr)>(GetCombinerOutputParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterfvNV(stage: glCombinerStage; portion: glCombinerPortion; pname: glCombinerParameter; var &params: single) :=
      ntv_GetCombinerOutputParameterfvNV_1(stage, portion, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterfvNV(stage: glCombinerStage; portion: glCombinerPortion; pname: glCombinerParameter; &params: IntPtr) :=
      ntv_GetCombinerOutputParameterfvNV_2(stage, portion, pname, &params);
    
    private GetCombinerOutputParameterivNV_adr := GetProcAddress('glGetCombinerOutputParameterivNV');
    private ntv_GetCombinerOutputParameterivNV_1 := GetProcOrNil&<procedure(stage: glCombinerStage; portion: glCombinerPortion; pname: glCombinerParameter; var &params: Int32)>(GetCombinerOutputParameterivNV_adr);
    private ntv_GetCombinerOutputParameterivNV_2 := GetProcOrNil&<procedure(stage: glCombinerStage; portion: glCombinerPortion; pname: glCombinerParameter; &params: IntPtr)>(GetCombinerOutputParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterivNV(stage: glCombinerStage; portion: glCombinerPortion; pname: glCombinerParameter; var &params: Int32) :=
      ntv_GetCombinerOutputParameterivNV_1(stage, portion, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterivNV(stage: glCombinerStage; portion: glCombinerPortion; pname: glCombinerParameter; &params: IntPtr) :=
      ntv_GetCombinerOutputParameterivNV_2(stage, portion, pname, &params);
    
    private GetFinalCombinerInputParameterfvNV_adr := GetProcAddress('glGetFinalCombinerInputParameterfvNV');
    private ntv_GetFinalCombinerInputParameterfvNV_1 := GetProcOrNil&<procedure(variable: glCombinerVariable; pname: glCombinerParameter; var &params: single)>(GetFinalCombinerInputParameterfvNV_adr);
    private ntv_GetFinalCombinerInputParameterfvNV_2 := GetProcOrNil&<procedure(variable: glCombinerVariable; pname: glCombinerParameter; &params: IntPtr)>(GetFinalCombinerInputParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterfvNV(variable: glCombinerVariable; pname: glCombinerParameter; var &params: single) :=
      ntv_GetFinalCombinerInputParameterfvNV_1(variable, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterfvNV(variable: glCombinerVariable; pname: glCombinerParameter; &params: IntPtr) :=
      ntv_GetFinalCombinerInputParameterfvNV_2(variable, pname, &params);
    
    private GetFinalCombinerInputParameterivNV_adr := GetProcAddress('glGetFinalCombinerInputParameterivNV');
    private ntv_GetFinalCombinerInputParameterivNV_1 := GetProcOrNil&<procedure(variable: glCombinerVariable; pname: glCombinerParameter; var &params: Int32)>(GetFinalCombinerInputParameterivNV_adr);
    private ntv_GetFinalCombinerInputParameterivNV_2 := GetProcOrNil&<procedure(variable: glCombinerVariable; pname: glCombinerParameter; &params: IntPtr)>(GetFinalCombinerInputParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterivNV(variable: glCombinerVariable; pname: glCombinerParameter; var &params: Int32) :=
      ntv_GetFinalCombinerInputParameterivNV_1(variable, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterivNV(variable: glCombinerVariable; pname: glCombinerParameter; &params: IntPtr) :=
      ntv_GetFinalCombinerInputParameterivNV_2(variable, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glRegisterCombiners2NV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_register_combiners2';
    
    private CombinerStageParameterfvNV_adr := GetProcAddress('glCombinerStageParameterfvNV');
    private ntv_CombinerStageParameterfvNV_1 := GetProcOrNil&<procedure(stage: glCombinerStage; pname: glCombinerParameter; var &params: single)>(CombinerStageParameterfvNV_adr);
    private ntv_CombinerStageParameterfvNV_2 := GetProcOrNil&<procedure(stage: glCombinerStage; pname: glCombinerParameter; &params: IntPtr)>(CombinerStageParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerStageParameterfvNV(stage: glCombinerStage; pname: glCombinerParameter; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_CombinerStageParameterfvNV_1(stage, pname, &params[0]) else
        ntv_CombinerStageParameterfvNV_1(stage, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerStageParameterfvNV(stage: glCombinerStage; pname: glCombinerParameter; var &params: single) :=
      ntv_CombinerStageParameterfvNV_1(stage, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerStageParameterfvNV(stage: glCombinerStage; pname: glCombinerParameter; &params: IntPtr) :=
      ntv_CombinerStageParameterfvNV_2(stage, pname, &params);
    
    private GetCombinerStageParameterfvNV_adr := GetProcAddress('glGetCombinerStageParameterfvNV');
    private ntv_GetCombinerStageParameterfvNV_1 := GetProcOrNil&<procedure(stage: glCombinerStage; pname: glCombinerParameter; var &params: single)>(GetCombinerStageParameterfvNV_adr);
    private ntv_GetCombinerStageParameterfvNV_2 := GetProcOrNil&<procedure(stage: glCombinerStage; pname: glCombinerParameter; &params: IntPtr)>(GetCombinerStageParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerStageParameterfvNV(stage: glCombinerStage; pname: glCombinerParameter; var &params: single) :=
      ntv_GetCombinerStageParameterfvNV_1(stage, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerStageParameterfvNV(stage: glCombinerStage; pname: glCombinerParameter; &params: IntPtr) :=
      ntv_GetCombinerStageParameterfvNV_2(stage, pname, &params);
    
  end;
  
  ///
  glRepresentativeFragmentTestNV = static class
    public const _ExtStr = 'GL_NV_representative_fragment_test';
  end;
  
  ///
  glRobustnessVideoMemoryPurgeNV = static class
    public const _ExtStr = 'GL_NV_robustness_video_memory_purge';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSampleLocationsNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_sample_locations';
    
    private FramebufferSampleLocationsfvNV_adr := GetProcAddress('glFramebufferSampleLocationsfvNV');
    private ntv_FramebufferSampleLocationsfvNV_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; start: UInt32; count: Int32; var v: single)>(FramebufferSampleLocationsfvNV_adr);
    private ntv_FramebufferSampleLocationsfvNV_2 := GetProcOrNil&<procedure(target: glFramebufferTarget; start: UInt32; count: Int32; v: IntPtr)>(FramebufferSampleLocationsfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvNV(target: glFramebufferTarget; start: UInt32; count: Int32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_FramebufferSampleLocationsfvNV_1(target, start, count, v[0]) else
        ntv_FramebufferSampleLocationsfvNV_1(target, start, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvNV(target: glFramebufferTarget; start: UInt32; count: Int32; var v: single) :=
      ntv_FramebufferSampleLocationsfvNV_1(target, start, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvNV(target: glFramebufferTarget; start: UInt32; count: Int32; v: IntPtr) :=
      ntv_FramebufferSampleLocationsfvNV_2(target, start, count, v);
    
    private NamedFramebufferSampleLocationsfvNV_adr := GetProcAddress('glNamedFramebufferSampleLocationsfvNV');
    private ntv_NamedFramebufferSampleLocationsfvNV_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; start: UInt32; count: Int32; var v: single)>(NamedFramebufferSampleLocationsfvNV_adr);
    private ntv_NamedFramebufferSampleLocationsfvNV_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: IntPtr)>(NamedFramebufferSampleLocationsfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvNV(framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_NamedFramebufferSampleLocationsfvNV_1(framebuffer, start, count, v[0]) else
        ntv_NamedFramebufferSampleLocationsfvNV_1(framebuffer, start, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvNV(framebuffer: gl_framebuffer; start: UInt32; count: Int32; var v: single) :=
      ntv_NamedFramebufferSampleLocationsfvNV_1(framebuffer, start, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvNV(framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: IntPtr) :=
      ntv_NamedFramebufferSampleLocationsfvNV_2(framebuffer, start, count, v);
    
    private ResolveDepthValuesNV_adr := GetProcAddress('glResolveDepthValuesNV');
    private ntv_ResolveDepthValuesNV_1 := GetProcOrNil&<procedure>(ResolveDepthValuesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResolveDepthValuesNV :=
      ntv_ResolveDepthValuesNV_1;
    
  end;
  
  ///
  glSampleMaskOverrideCoverageNV = static class
    public const _ExtStr = 'GL_NV_sample_mask_override_coverage';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glScissorExclusiveNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_scissor_exclusive';
    
    private ScissorExclusiveNV_adr := GetProcAddress('glScissorExclusiveNV');
    private ntv_ScissorExclusiveNV_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32)>(ScissorExclusiveNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorExclusiveNV(x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_ScissorExclusiveNV_1(x, y, width, height);
    
    private ScissorExclusiveArrayvNV_adr := GetProcAddress('glScissorExclusiveArrayvNV');
    private ntv_ScissorExclusiveArrayvNV_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var v: Int32)>(ScissorExclusiveArrayvNV_adr);
    private ntv_ScissorExclusiveArrayvNV_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; v: IntPtr)>(ScissorExclusiveArrayvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorExclusiveArrayvNV(first: UInt32; count: Int32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_ScissorExclusiveArrayvNV_1(first, count, v[0]) else
        ntv_ScissorExclusiveArrayvNV_1(first, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorExclusiveArrayvNV(first: UInt32; count: Int32; var v: Int32) :=
      ntv_ScissorExclusiveArrayvNV_1(first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorExclusiveArrayvNV(first: UInt32; count: Int32; v: IntPtr) :=
      ntv_ScissorExclusiveArrayvNV_2(first, count, v);
    
  end;
  
  ///
  glShaderAtomicCountersNV = static class
    public const _ExtStr = 'GL_NV_shader_atomic_counters';
  end;
  
  ///
  glShaderAtomicFloatNV = static class
    public const _ExtStr = 'GL_NV_shader_atomic_float';
  end;
  
  ///
  glShaderAtomicFloat64NV = static class
    public const _ExtStr = 'GL_NV_shader_atomic_float64';
  end;
  
  ///
  glShaderAtomicFp16VectorNV = static class
    public const _ExtStr = 'GL_NV_shader_atomic_fp16_vector';
  end;
  
  ///
  glShaderAtomicInt64NV = static class
    public const _ExtStr = 'GL_NV_shader_atomic_int64';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glShaderBufferLoadNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_shader_buffer_load';
    
    private MakeBufferResidentNV_adr := GetProcAddress('glMakeBufferResidentNV');
    private ntv_MakeBufferResidentNV_1 := GetProcOrNil&<procedure(target: DummyEnum; access: DummyEnum)>(MakeBufferResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeBufferResidentNV(target: DummyEnum; access: DummyEnum) :=
      ntv_MakeBufferResidentNV_1(target, access);
    
    private MakeBufferNonResidentNV_adr := GetProcAddress('glMakeBufferNonResidentNV');
    private ntv_MakeBufferNonResidentNV_1 := GetProcOrNil&<procedure(target: DummyEnum)>(MakeBufferNonResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeBufferNonResidentNV(target: DummyEnum) :=
      ntv_MakeBufferNonResidentNV_1(target);
    
    private IsBufferResidentNV_adr := GetProcAddress('glIsBufferResidentNV');
    private ntv_IsBufferResidentNV_1 := GetProcOrNil&<function(target: DummyEnum): glBool8>(IsBufferResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsBufferResidentNV(target: DummyEnum): glBool8 :=
      ntv_IsBufferResidentNV_1(target);
    
    private MakeNamedBufferResidentNV_adr := GetProcAddress('glMakeNamedBufferResidentNV');
    private ntv_MakeNamedBufferResidentNV_1 := GetProcOrNil&<procedure(buffer: gl_buffer; access: DummyEnum)>(MakeNamedBufferResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeNamedBufferResidentNV(buffer: gl_buffer; access: DummyEnum) :=
      ntv_MakeNamedBufferResidentNV_1(buffer, access);
    
    private MakeNamedBufferNonResidentNV_adr := GetProcAddress('glMakeNamedBufferNonResidentNV');
    private ntv_MakeNamedBufferNonResidentNV_1 := GetProcOrNil&<procedure(buffer: gl_buffer)>(MakeNamedBufferNonResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeNamedBufferNonResidentNV(buffer: gl_buffer) :=
      ntv_MakeNamedBufferNonResidentNV_1(buffer);
    
    private IsNamedBufferResidentNV_adr := GetProcAddress('glIsNamedBufferResidentNV');
    private ntv_IsNamedBufferResidentNV_1 := GetProcOrNil&<function(buffer: gl_buffer): glBool8>(IsNamedBufferResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsNamedBufferResidentNV(buffer: gl_buffer): glBool8 :=
      ntv_IsNamedBufferResidentNV_1(buffer);
    
    private GetBufferParameterui64vNV_adr := GetProcAddress('glGetBufferParameterui64vNV');
    private ntv_GetBufferParameterui64vNV_1 := GetProcOrNil&<procedure(target: glBufferTarget; pname: DummyEnum; var &params: UInt64)>(GetBufferParameterui64vNV_adr);
    private ntv_GetBufferParameterui64vNV_2 := GetProcOrNil&<procedure(target: glBufferTarget; pname: DummyEnum; &params: IntPtr)>(GetBufferParameterui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameterui64vNV(target: glBufferTarget; pname: DummyEnum; var &params: UInt64) :=
      ntv_GetBufferParameterui64vNV_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameterui64vNV(target: glBufferTarget; pname: DummyEnum; &params: IntPtr) :=
      ntv_GetBufferParameterui64vNV_2(target, pname, &params);
    
    private GetNamedBufferParameterui64vNV_adr := GetProcAddress('glGetNamedBufferParameterui64vNV');
    private ntv_GetNamedBufferParameterui64vNV_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPName; var &params: UInt64)>(GetNamedBufferParameterui64vNV_adr);
    private ntv_GetNamedBufferParameterui64vNV_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPName; &params: IntPtr)>(GetNamedBufferParameterui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameterui64vNV(buffer: gl_buffer; pname: glBufferPName; var &params: UInt64) :=
      ntv_GetNamedBufferParameterui64vNV_1(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameterui64vNV(buffer: gl_buffer; pname: glBufferPName; &params: IntPtr) :=
      ntv_GetNamedBufferParameterui64vNV_2(buffer, pname, &params);
    
    private GetIntegerui64vNV_adr := GetProcAddress('glGetIntegerui64vNV');
    private ntv_GetIntegerui64vNV_1 := GetProcOrNil&<procedure(value: DummyEnum; var result: UInt64)>(GetIntegerui64vNV_adr);
    private ntv_GetIntegerui64vNV_2 := GetProcOrNil&<procedure(value: DummyEnum; result: IntPtr)>(GetIntegerui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64vNV(value: DummyEnum; var result: UInt64) :=
      ntv_GetIntegerui64vNV_1(value, result);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64vNV(value: DummyEnum; result: IntPtr) :=
      ntv_GetIntegerui64vNV_2(value, result);
    
    private Uniformui64NV_adr := GetProcAddress('glUniformui64NV');
    private ntv_Uniformui64NV_1 := GetProcOrNil&<procedure(location: Int32; value: UInt64)>(Uniformui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniformui64NV(location: Int32; value: UInt64) :=
      ntv_Uniformui64NV_1(location, value);
    
    private Uniformui64vNV_adr := GetProcAddress('glUniformui64vNV');
    private ntv_Uniformui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(Uniformui64vNV_adr);
    private ntv_Uniformui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniformui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniformui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniformui64vNV_1(location, count, value[0]) else
        ntv_Uniformui64vNV_1(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniformui64vNV(location: Int32; count: Int32; var value: UInt64) :=
      ntv_Uniformui64vNV_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniformui64vNV(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniformui64vNV_2(location, count, value);
    
    private GetUniformui64vNV_adr := GetProcAddress('glGetUniformui64vNV');
    private ntv_GetUniformui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: UInt64)>(GetUniformui64vNV_adr);
    private ntv_GetUniformui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(GetUniformui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vNV(&program: gl_program; location: Int32; var &params: UInt64) :=
      ntv_GetUniformui64vNV_1(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vNV(&program: gl_program; location: Int32; &params: IntPtr) :=
      ntv_GetUniformui64vNV_2(&program, location, &params);
    
    private ProgramUniformui64NV_adr := GetProcAddress('glProgramUniformui64NV');
    private ntv_ProgramUniformui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; value: UInt64)>(ProgramUniformui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformui64NV(&program: gl_program; location: Int32; value: UInt64) :=
      ntv_ProgramUniformui64NV_1(&program, location, value);
    
    private ProgramUniformui64vNV_adr := GetProcAddress('glProgramUniformui64vNV');
    private ntv_ProgramUniformui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(ProgramUniformui64vNV_adr);
    private ntv_ProgramUniformui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniformui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformui64vNV_1(&program, location, count, value[0]) else
        ntv_ProgramUniformui64vNV_1(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
      ntv_ProgramUniformui64vNV_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniformui64vNV_2(&program, location, count, value);
    
  end;
  
  ///
  glShaderBufferStoreNV = static class
    public const _ExtStr = 'GL_NV_shader_buffer_store';
  end;
  
  ///
  glShaderStorageBufferObjectNV = static class
    public const _ExtStr = 'GL_NV_shader_storage_buffer_object';
  end;
  
  ///
  glShaderSubgroupPartitionedNV = static class
    public const _ExtStr = 'GL_NV_shader_subgroup_partitioned';
  end;
  
  ///
  glShaderTextureFootprintNV = static class
    public const _ExtStr = 'GL_NV_shader_texture_footprint';
  end;
  
  ///
  glShaderThreadGroupNV = static class
    public const _ExtStr = 'GL_NV_shader_thread_group';
  end;
  
  ///
  glShaderThreadShuffleNV = static class
    public const _ExtStr = 'GL_NV_shader_thread_shuffle';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glShadingRateImageNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_shading_rate_image';
    
    private BindShadingRateImageNV_adr := GetProcAddress('glBindShadingRateImageNV');
    private ntv_BindShadingRateImageNV_1 := GetProcOrNil&<procedure(texture: gl_texture)>(BindShadingRateImageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindShadingRateImageNV(texture: gl_texture) :=
      ntv_BindShadingRateImageNV_1(texture);
    
    private GetShadingRateImagePaletteNV_adr := GetProcAddress('glGetShadingRateImagePaletteNV');
    private ntv_GetShadingRateImagePaletteNV_1 := GetProcOrNil&<procedure(viewport: UInt32; entry: UInt32; var rate: DummyEnum)>(GetShadingRateImagePaletteNV_adr);
    private ntv_GetShadingRateImagePaletteNV_2 := GetProcOrNil&<procedure(viewport: UInt32; entry: UInt32; rate: IntPtr)>(GetShadingRateImagePaletteNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateImagePaletteNV(viewport: UInt32; entry: UInt32; var rate: DummyEnum) :=
      ntv_GetShadingRateImagePaletteNV_1(viewport, entry, rate);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateImagePaletteNV(viewport: UInt32; entry: UInt32; rate: IntPtr) :=
      ntv_GetShadingRateImagePaletteNV_2(viewport, entry, rate);
    
    private GetShadingRateSampleLocationivNV_adr := GetProcAddress('glGetShadingRateSampleLocationivNV');
    private ntv_GetShadingRateSampleLocationivNV_1 := GetProcOrNil&<procedure(rate: DummyEnum; samples: UInt32; index: UInt32; var location: Int32)>(GetShadingRateSampleLocationivNV_adr);
    private ntv_GetShadingRateSampleLocationivNV_2 := GetProcOrNil&<procedure(rate: DummyEnum; samples: UInt32; index: UInt32; location: IntPtr)>(GetShadingRateSampleLocationivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateSampleLocationivNV(rate: DummyEnum; samples: UInt32; index: UInt32; var location: Int32) :=
      ntv_GetShadingRateSampleLocationivNV_1(rate, samples, index, location);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateSampleLocationivNV(rate: DummyEnum; samples: UInt32; index: UInt32; location: IntPtr) :=
      ntv_GetShadingRateSampleLocationivNV_2(rate, samples, index, location);
    
    private ShadingRateImageBarrierNV_adr := GetProcAddress('glShadingRateImageBarrierNV');
    private ntv_ShadingRateImageBarrierNV_1 := GetProcOrNil&<procedure(synchronize: glBool8)>(ShadingRateImageBarrierNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateImageBarrierNV(synchronize: glBool8) :=
      ntv_ShadingRateImageBarrierNV_1(synchronize);
    
    private ShadingRateImagePaletteNV_adr := GetProcAddress('glShadingRateImagePaletteNV');
    private ntv_ShadingRateImagePaletteNV_1 := GetProcOrNil&<procedure(viewport: UInt32; first: UInt32; count: Int32; var rates: DummyEnum)>(ShadingRateImagePaletteNV_adr);
    private ntv_ShadingRateImagePaletteNV_2 := GetProcOrNil&<procedure(viewport: UInt32; first: UInt32; count: Int32; rates: IntPtr)>(ShadingRateImagePaletteNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateImagePaletteNV(viewport: UInt32; first: UInt32; count: Int32; rates: array of DummyEnum);
    type PDummyEnum = ^DummyEnum;
    begin
      if (rates<>nil) and (rates.Length<>0) then
        ntv_ShadingRateImagePaletteNV_1(viewport, first, count, rates[0]) else
        ntv_ShadingRateImagePaletteNV_1(viewport, first, count, PDummyEnum(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateImagePaletteNV(viewport: UInt32; first: UInt32; count: Int32; var rates: DummyEnum) :=
      ntv_ShadingRateImagePaletteNV_1(viewport, first, count, rates);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateImagePaletteNV(viewport: UInt32; first: UInt32; count: Int32; rates: IntPtr) :=
      ntv_ShadingRateImagePaletteNV_2(viewport, first, count, rates);
    
    private ShadingRateSampleOrderNV_adr := GetProcAddress('glShadingRateSampleOrderNV');
    private ntv_ShadingRateSampleOrderNV_1 := GetProcOrNil&<procedure(order: DummyEnum)>(ShadingRateSampleOrderNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateSampleOrderNV(order: DummyEnum) :=
      ntv_ShadingRateSampleOrderNV_1(order);
    
    private ShadingRateSampleOrderCustomNV_adr := GetProcAddress('glShadingRateSampleOrderCustomNV');
    private ntv_ShadingRateSampleOrderCustomNV_1 := GetProcOrNil&<procedure(rate: DummyEnum; samples: UInt32; var locations: Int32)>(ShadingRateSampleOrderCustomNV_adr);
    private ntv_ShadingRateSampleOrderCustomNV_2 := GetProcOrNil&<procedure(rate: DummyEnum; samples: UInt32; locations: IntPtr)>(ShadingRateSampleOrderCustomNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateSampleOrderCustomNV(rate: DummyEnum; samples: UInt32; locations: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (locations<>nil) and (locations.Length<>0) then
        ntv_ShadingRateSampleOrderCustomNV_1(rate, samples, locations[0]) else
        ntv_ShadingRateSampleOrderCustomNV_1(rate, samples, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateSampleOrderCustomNV(rate: DummyEnum; samples: UInt32; var locations: Int32) :=
      ntv_ShadingRateSampleOrderCustomNV_1(rate, samples, locations);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateSampleOrderCustomNV(rate: DummyEnum; samples: UInt32; locations: IntPtr) :=
      ntv_ShadingRateSampleOrderCustomNV_2(rate, samples, locations);
    
  end;
  
  ///
  glStereoViewRenderingNV = static class
    public const _ExtStr = 'GL_NV_stereo_view_rendering';
  end;
  
  ///
  glTessellationProgram5NV = static class
    public const _ExtStr = 'GL_NV_tessellation_program5';
  end;
  
  ///
  glTexgenEmbossNV = static class
    public const _ExtStr = 'GL_NV_texgen_emboss';
  end;
  
  ///
  glTexgenReflectionNV = static class
    public const _ExtStr = 'GL_NV_texgen_reflection';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureBarrierNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_texture_barrier';
    
    private TextureBarrierNV_adr := GetProcAddress('glTextureBarrierNV');
    private ntv_TextureBarrierNV_1 := GetProcOrNil&<procedure>(TextureBarrierNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBarrierNV :=
      ntv_TextureBarrierNV_1;
    
  end;
  
  ///
  glTextureCompressionVtcNV = static class
    public const _ExtStr = 'GL_NV_texture_compression_vtc';
  end;
  
  ///
  glTextureEnvCombine4NV = static class
    public const _ExtStr = 'GL_NV_texture_env_combine4';
  end;
  
  ///
  glTextureExpandNormalNV = static class
    public const _ExtStr = 'GL_NV_texture_expand_normal';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureMultisampleNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_texture_multisample';
    
    private TexImage2DMultisampleCoverageNV_adr := GetProcAddress('glTexImage2DMultisampleCoverageNV');
    private ntv_TexImage2DMultisampleCoverageNV_1 := GetProcOrNil&<procedure(target: glTextureTarget; coverageSamples: Int32; colorSamples: Int32; internalFormat: glInternalFormat; width: Int32; height: Int32; fixedSampleLocations: glBool8)>(TexImage2DMultisampleCoverageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage2DMultisampleCoverageNV(target: glTextureTarget; coverageSamples: Int32; colorSamples: Int32; internalFormat: glInternalFormat; width: Int32; height: Int32; fixedSampleLocations: glBool8) :=
      ntv_TexImage2DMultisampleCoverageNV_1(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
    
    private TexImage3DMultisampleCoverageNV_adr := GetProcAddress('glTexImage3DMultisampleCoverageNV');
    private ntv_TexImage3DMultisampleCoverageNV_1 := GetProcOrNil&<procedure(target: glTextureTarget; coverageSamples: Int32; colorSamples: Int32; internalFormat: glInternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: glBool8)>(TexImage3DMultisampleCoverageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3DMultisampleCoverageNV(target: glTextureTarget; coverageSamples: Int32; colorSamples: Int32; internalFormat: glInternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: glBool8) :=
      ntv_TexImage3DMultisampleCoverageNV_1(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
    
    private TextureImage2DMultisampleNV_adr := GetProcAddress('glTextureImage2DMultisampleNV');
    private ntv_TextureImage2DMultisampleNV_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; samples: Int32; internalFormat: glInternalFormat; width: Int32; height: Int32; fixedSampleLocations: glBool8)>(TextureImage2DMultisampleNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage2DMultisampleNV(texture: gl_texture; target: glTextureTarget; samples: Int32; internalFormat: glInternalFormat; width: Int32; height: Int32; fixedSampleLocations: glBool8) :=
      ntv_TextureImage2DMultisampleNV_1(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
    
    private TextureImage3DMultisampleNV_adr := GetProcAddress('glTextureImage3DMultisampleNV');
    private ntv_TextureImage3DMultisampleNV_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; samples: Int32; internalFormat: glInternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: glBool8)>(TextureImage3DMultisampleNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage3DMultisampleNV(texture: gl_texture; target: glTextureTarget; samples: Int32; internalFormat: glInternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: glBool8) :=
      ntv_TextureImage3DMultisampleNV_1(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
    
    private TextureImage2DMultisampleCoverageNV_adr := GetProcAddress('glTextureImage2DMultisampleCoverageNV');
    private ntv_TextureImage2DMultisampleCoverageNV_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; coverageSamples: Int32; colorSamples: Int32; internalFormat: glInternalFormat; width: Int32; height: Int32; fixedSampleLocations: glBool8)>(TextureImage2DMultisampleCoverageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage2DMultisampleCoverageNV(texture: gl_texture; target: glTextureTarget; coverageSamples: Int32; colorSamples: Int32; internalFormat: glInternalFormat; width: Int32; height: Int32; fixedSampleLocations: glBool8) :=
      ntv_TextureImage2DMultisampleCoverageNV_1(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
    
    private TextureImage3DMultisampleCoverageNV_adr := GetProcAddress('glTextureImage3DMultisampleCoverageNV');
    private ntv_TextureImage3DMultisampleCoverageNV_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; coverageSamples: Int32; colorSamples: Int32; internalFormat: glInternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: glBool8)>(TextureImage3DMultisampleCoverageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage3DMultisampleCoverageNV(texture: gl_texture; target: glTextureTarget; coverageSamples: Int32; colorSamples: Int32; internalFormat: glInternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: glBool8) :=
      ntv_TextureImage3DMultisampleCoverageNV_1(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
    
  end;
  
  ///
  glTextureRectangleNV = static class
    public const _ExtStr = 'GL_NV_texture_rectangle';
  end;
  
  ///
  glTextureRectangleCompressedNV = static class
    public const _ExtStr = 'GL_NV_texture_rectangle_compressed';
  end;
  
  ///
  glTextureShaderNV = static class
    public const _ExtStr = 'GL_NV_texture_shader';
  end;
  
  ///
  glTextureShader2NV = static class
    public const _ExtStr = 'GL_NV_texture_shader2';
  end;
  
  ///
  glTextureShader3NV = static class
    public const _ExtStr = 'GL_NV_texture_shader3';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTimelineSemaphoreNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_timeline_semaphore';
    
    private CreateSemaphoresNV_adr := GetProcAddress('glCreateSemaphoresNV');
    private ntv_CreateSemaphoresNV_1 := GetProcOrNil&<procedure(n: Int32; var semaphores: UInt32)>(CreateSemaphoresNV_adr);
    private ntv_CreateSemaphoresNV_2 := GetProcOrNil&<procedure(n: Int32; semaphores: IntPtr)>(CreateSemaphoresNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSemaphoresNV(n: Int32; semaphores: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (semaphores<>nil) and (semaphores.Length<>0) then
        ntv_CreateSemaphoresNV_1(n, semaphores[0]) else
        ntv_CreateSemaphoresNV_1(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSemaphoresNV(n: Int32; var semaphores: UInt32) :=
      ntv_CreateSemaphoresNV_1(n, semaphores);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSemaphoresNV(n: Int32; semaphores: IntPtr) :=
      ntv_CreateSemaphoresNV_2(n, semaphores);
    
    private SemaphoreParameterivNV_adr := GetProcAddress('glSemaphoreParameterivNV');
    private ntv_SemaphoreParameterivNV_1 := GetProcOrNil&<procedure(semaphore: UInt32; pname: glSemaphoreParameterName; var &params: Int32)>(SemaphoreParameterivNV_adr);
    private ntv_SemaphoreParameterivNV_2 := GetProcOrNil&<procedure(semaphore: UInt32; pname: glSemaphoreParameterName; &params: IntPtr)>(SemaphoreParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterivNV(semaphore: UInt32; pname: glSemaphoreParameterName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_SemaphoreParameterivNV_1(semaphore, pname, &params[0]) else
        ntv_SemaphoreParameterivNV_1(semaphore, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterivNV(semaphore: UInt32; pname: glSemaphoreParameterName; var &params: Int32) :=
      ntv_SemaphoreParameterivNV_1(semaphore, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterivNV(semaphore: UInt32; pname: glSemaphoreParameterName; &params: IntPtr) :=
      ntv_SemaphoreParameterivNV_2(semaphore, pname, &params);
    
    private GetSemaphoreParameterivNV_adr := GetProcAddress('glGetSemaphoreParameterivNV');
    private ntv_GetSemaphoreParameterivNV_1 := GetProcOrNil&<procedure(semaphore: UInt32; pname: glSemaphoreParameterName; var &params: Int32)>(GetSemaphoreParameterivNV_adr);
    private ntv_GetSemaphoreParameterivNV_2 := GetProcOrNil&<procedure(semaphore: UInt32; pname: glSemaphoreParameterName; &params: IntPtr)>(GetSemaphoreParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSemaphoreParameterivNV(semaphore: UInt32; pname: glSemaphoreParameterName; var &params: Int32) :=
      ntv_GetSemaphoreParameterivNV_1(semaphore, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSemaphoreParameterivNV(semaphore: UInt32; pname: glSemaphoreParameterName; &params: IntPtr) :=
      ntv_GetSemaphoreParameterivNV_2(semaphore, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTransformFeedbackNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_transform_feedback';
    
    private BeginTransformFeedbackNV_adr := GetProcAddress('glBeginTransformFeedbackNV');
    private ntv_BeginTransformFeedbackNV_1 := GetProcOrNil&<procedure(primitiveMode: glPrimitiveType)>(BeginTransformFeedbackNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginTransformFeedbackNV(primitiveMode: glPrimitiveType) :=
      ntv_BeginTransformFeedbackNV_1(primitiveMode);
    
    private EndTransformFeedbackNV_adr := GetProcAddress('glEndTransformFeedbackNV');
    private ntv_EndTransformFeedbackNV_1 := GetProcOrNil&<procedure>(EndTransformFeedbackNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndTransformFeedbackNV :=
      ntv_EndTransformFeedbackNV_1;
    
    private TransformFeedbackAttribsNV_adr := GetProcAddress('glTransformFeedbackAttribsNV');
    private ntv_TransformFeedbackAttribsNV_1 := GetProcOrNil&<procedure(count: Int32; var attribs: Int32; bufferMode: DummyEnum)>(TransformFeedbackAttribsNV_adr);
    private ntv_TransformFeedbackAttribsNV_2 := GetProcOrNil&<procedure(count: Int32; attribs: IntPtr; bufferMode: DummyEnum)>(TransformFeedbackAttribsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackAttribsNV(count: Int32; attribs: array of Int32; bufferMode: DummyEnum);
    type PInt32 = ^Int32;
    begin
      if (attribs<>nil) and (attribs.Length<>0) then
        ntv_TransformFeedbackAttribsNV_1(count, attribs[0], bufferMode) else
        ntv_TransformFeedbackAttribsNV_1(count, PInt32(nil)^, bufferMode);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackAttribsNV(count: Int32; var attribs: Int32; bufferMode: DummyEnum) :=
      ntv_TransformFeedbackAttribsNV_1(count, attribs, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackAttribsNV(count: Int32; attribs: IntPtr; bufferMode: DummyEnum) :=
      ntv_TransformFeedbackAttribsNV_2(count, attribs, bufferMode);
    
    private BindBufferRangeNV_adr := GetProcAddress('glBindBufferRangeNV');
    private ntv_BindBufferRangeNV_1 := GetProcOrNil&<procedure(target: glBufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(BindBufferRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferRangeNV(target: glBufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
      ntv_BindBufferRangeNV_1(target, index, buffer, offset, size);
    
    private BindBufferOffsetNV_adr := GetProcAddress('glBindBufferOffsetNV');
    private ntv_BindBufferOffsetNV_1 := GetProcOrNil&<procedure(target: glBufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr)>(BindBufferOffsetNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferOffsetNV(target: glBufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr) :=
      ntv_BindBufferOffsetNV_1(target, index, buffer, offset);
    
    private BindBufferBaseNV_adr := GetProcAddress('glBindBufferBaseNV');
    private ntv_BindBufferBaseNV_1 := GetProcOrNil&<procedure(target: glBufferTarget; index: UInt32; buffer: gl_buffer)>(BindBufferBaseNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferBaseNV(target: glBufferTarget; index: UInt32; buffer: gl_buffer) :=
      ntv_BindBufferBaseNV_1(target, index, buffer);
    
    private TransformFeedbackVaryingsNV_adr := GetProcAddress('glTransformFeedbackVaryingsNV');
    private ntv_TransformFeedbackVaryingsNV_1 := GetProcOrNil&<procedure(&program: gl_program; count: Int32; var locations: glTransformFeedbackToken; bufferMode: glTransformFeedbackBufferMode)>(TransformFeedbackVaryingsNV_adr);
    private ntv_TransformFeedbackVaryingsNV_2 := GetProcOrNil&<procedure(&program: gl_program; count: Int32; locations: IntPtr; bufferMode: glTransformFeedbackBufferMode)>(TransformFeedbackVaryingsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsNV(&program: gl_program; count: Int32; locations: array of glTransformFeedbackToken; bufferMode: glTransformFeedbackBufferMode);
    type PGlTransformFeedbackToken = ^glTransformFeedbackToken;
    begin
      if (locations<>nil) and (locations.Length<>0) then
        ntv_TransformFeedbackVaryingsNV_1(&program, count, locations[0], bufferMode) else
        ntv_TransformFeedbackVaryingsNV_1(&program, count, PGlTransformFeedbackToken(nil)^, bufferMode);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsNV(&program: gl_program; count: Int32; var locations: glTransformFeedbackToken; bufferMode: glTransformFeedbackBufferMode) :=
      ntv_TransformFeedbackVaryingsNV_1(&program, count, locations, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsNV(&program: gl_program; count: Int32; locations: IntPtr; bufferMode: glTransformFeedbackBufferMode) :=
      ntv_TransformFeedbackVaryingsNV_2(&program, count, locations, bufferMode);
    
    private ActiveVaryingNV_adr := GetProcAddress('glActiveVaryingNV');
    private ntv_ActiveVaryingNV_1 := GetProcOrNil&<procedure(&program: gl_program; name: IntPtr)>(ActiveVaryingNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveVaryingNV(&program: gl_program; name: string);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_ActiveVaryingNV_1(&program, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveVaryingNV(&program: gl_program; name: IntPtr) :=
      ntv_ActiveVaryingNV_1(&program, name);
    
    private GetVaryingLocationNV_adr := GetProcAddress('glGetVaryingLocationNV');
    private ntv_GetVaryingLocationNV_1 := GetProcOrNil&<function(&program: gl_program; name: IntPtr): Int32>(GetVaryingLocationNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVaryingLocationNV(&program: gl_program; name: string): Int32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetVaryingLocationNV_1(&program, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVaryingLocationNV(&program: gl_program; name: IntPtr): Int32 :=
      ntv_GetVaryingLocationNV_1(&program, name);
    
    private GetActiveVaryingNV_adr := GetProcAddress('glGetActiveVaryingNV');
    private ntv_GetActiveVaryingNV_1 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: DummyEnum; name: IntPtr)>(GetActiveVaryingNV_adr);
    private ntv_GetActiveVaryingNV_2 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr)>(GetActiveVaryingNV_adr);
    private ntv_GetActiveVaryingNV_3 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: DummyEnum; name: IntPtr)>(GetActiveVaryingNV_adr);
    private ntv_GetActiveVaryingNV_4 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr)>(GetActiveVaryingNV_adr);
    private ntv_GetActiveVaryingNV_5 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: DummyEnum; name: IntPtr)>(GetActiveVaryingNV_adr);
    private ntv_GetActiveVaryingNV_6 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr)>(GetActiveVaryingNV_adr);
    private ntv_GetActiveVaryingNV_7 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: DummyEnum; name: IntPtr)>(GetActiveVaryingNV_adr);
    private ntv_GetActiveVaryingNV_8 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr)>(GetActiveVaryingNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: DummyEnum; name: IntPtr) :=
      ntv_GetActiveVaryingNV_1(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveVaryingNV_2(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: DummyEnum; name: IntPtr) :=
      ntv_GetActiveVaryingNV_3(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveVaryingNV_4(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: DummyEnum; name: IntPtr) :=
      ntv_GetActiveVaryingNV_5(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveVaryingNV_6(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: DummyEnum; name: IntPtr) :=
      ntv_GetActiveVaryingNV_7(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveVaryingNV_8(&program, index, bufSize, length, size, &type, name);
    
    private GetTransformFeedbackVaryingNV_adr := GetProcAddress('glGetTransformFeedbackVaryingNV');
    private ntv_GetTransformFeedbackVaryingNV_1 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; var location: Int32)>(GetTransformFeedbackVaryingNV_adr);
    private ntv_GetTransformFeedbackVaryingNV_2 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; location: IntPtr)>(GetTransformFeedbackVaryingNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingNV(&program: gl_program; index: UInt32; var location: Int32) :=
      ntv_GetTransformFeedbackVaryingNV_1(&program, index, location);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingNV(&program: gl_program; index: UInt32; location: IntPtr) :=
      ntv_GetTransformFeedbackVaryingNV_2(&program, index, location);
    
    private TransformFeedbackStreamAttribsNV_adr := GetProcAddress('glTransformFeedbackStreamAttribsNV');
    private ntv_TransformFeedbackStreamAttribsNV_1 := GetProcOrNil&<procedure(count: Int32; var attribs: Int32; nbuffers: Int32; var bufstreams: Int32; bufferMode: DummyEnum)>(TransformFeedbackStreamAttribsNV_adr);
    private ntv_TransformFeedbackStreamAttribsNV_2 := GetProcOrNil&<procedure(count: Int32; var attribs: Int32; nbuffers: Int32; bufstreams: IntPtr; bufferMode: DummyEnum)>(TransformFeedbackStreamAttribsNV_adr);
    private ntv_TransformFeedbackStreamAttribsNV_3 := GetProcOrNil&<procedure(count: Int32; attribs: IntPtr; nbuffers: Int32; var bufstreams: Int32; bufferMode: DummyEnum)>(TransformFeedbackStreamAttribsNV_adr);
    private ntv_TransformFeedbackStreamAttribsNV_4 := GetProcOrNil&<procedure(count: Int32; attribs: IntPtr; nbuffers: Int32; bufstreams: IntPtr; bufferMode: DummyEnum)>(TransformFeedbackStreamAttribsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: array of Int32; nbuffers: Int32; bufstreams: array of Int32; bufferMode: DummyEnum);
    type PInt32 = ^Int32;
    begin
      if (attribs<>nil) and (attribs.Length<>0) then
        if (bufstreams<>nil) and (bufstreams.Length<>0) then
          ntv_TransformFeedbackStreamAttribsNV_1(count, attribs[0], nbuffers, bufstreams[0], bufferMode) else
          ntv_TransformFeedbackStreamAttribsNV_1(count, attribs[0], nbuffers, PInt32(nil)^, bufferMode) else
        if (bufstreams<>nil) and (bufstreams.Length<>0) then
          ntv_TransformFeedbackStreamAttribsNV_1(count, PInt32(nil)^, nbuffers, bufstreams[0], bufferMode) else
          ntv_TransformFeedbackStreamAttribsNV_1(count, PInt32(nil)^, nbuffers, PInt32(nil)^, bufferMode);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; var attribs: Int32; nbuffers: Int32; var bufstreams: Int32; bufferMode: DummyEnum) :=
      ntv_TransformFeedbackStreamAttribsNV_1(count, attribs, nbuffers, bufstreams, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; var attribs: Int32; nbuffers: Int32; bufstreams: IntPtr; bufferMode: DummyEnum) :=
      ntv_TransformFeedbackStreamAttribsNV_2(count, attribs, nbuffers, bufstreams, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: IntPtr; nbuffers: Int32; var bufstreams: Int32; bufferMode: DummyEnum) :=
      ntv_TransformFeedbackStreamAttribsNV_3(count, attribs, nbuffers, bufstreams, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: IntPtr; nbuffers: Int32; bufstreams: IntPtr; bufferMode: DummyEnum) :=
      ntv_TransformFeedbackStreamAttribsNV_4(count, attribs, nbuffers, bufstreams, bufferMode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTransformFeedback2NV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_transform_feedback2';
    
    private BindTransformFeedbackNV_adr := GetProcAddress('glBindTransformFeedbackNV');
    private ntv_BindTransformFeedbackNV_1 := GetProcOrNil&<procedure(target: glBufferTarget; id: gl_transform_feedback)>(BindTransformFeedbackNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTransformFeedbackNV(target: glBufferTarget; id: gl_transform_feedback) :=
      ntv_BindTransformFeedbackNV_1(target, id);
    
    private DeleteTransformFeedbacksNV_adr := GetProcAddress('glDeleteTransformFeedbacksNV');
    private ntv_DeleteTransformFeedbacksNV_1 := GetProcOrNil&<procedure(n: Int32; var ids: gl_transform_feedback)>(DeleteTransformFeedbacksNV_adr);
    private ntv_DeleteTransformFeedbacksNV_2 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(DeleteTransformFeedbacksNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacksNV(n: Int32; ids: array of gl_transform_feedback);
    type PGl_transform_feedback = ^gl_transform_feedback;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_DeleteTransformFeedbacksNV_1(n, ids[0]) else
        ntv_DeleteTransformFeedbacksNV_1(n, PGl_transform_feedback(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacksNV(n: Int32; var ids: gl_transform_feedback) :=
      ntv_DeleteTransformFeedbacksNV_1(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacksNV(n: Int32; ids: IntPtr) :=
      ntv_DeleteTransformFeedbacksNV_2(n, ids);
    
    private GenTransformFeedbacksNV_adr := GetProcAddress('glGenTransformFeedbacksNV');
    private ntv_GenTransformFeedbacksNV_1 := GetProcOrNil&<procedure(n: Int32; var ids: gl_transform_feedback)>(GenTransformFeedbacksNV_adr);
    private ntv_GenTransformFeedbacksNV_2 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(GenTransformFeedbacksNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacksNV(n: Int32; ids: array of gl_transform_feedback);
    type PGl_transform_feedback = ^gl_transform_feedback;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_GenTransformFeedbacksNV_1(n, ids[0]) else
        ntv_GenTransformFeedbacksNV_1(n, PGl_transform_feedback(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacksNV(n: Int32; var ids: gl_transform_feedback) :=
      ntv_GenTransformFeedbacksNV_1(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacksNV(n: Int32; ids: IntPtr) :=
      ntv_GenTransformFeedbacksNV_2(n, ids);
    
    private IsTransformFeedbackNV_adr := GetProcAddress('glIsTransformFeedbackNV');
    private ntv_IsTransformFeedbackNV_1 := GetProcOrNil&<function(id: gl_transform_feedback): glBool8>(IsTransformFeedbackNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTransformFeedbackNV(id: gl_transform_feedback): glBool8 :=
      ntv_IsTransformFeedbackNV_1(id);
    
    private PauseTransformFeedbackNV_adr := GetProcAddress('glPauseTransformFeedbackNV');
    private ntv_PauseTransformFeedbackNV_1 := GetProcOrNil&<procedure>(PauseTransformFeedbackNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PauseTransformFeedbackNV :=
      ntv_PauseTransformFeedbackNV_1;
    
    private ResumeTransformFeedbackNV_adr := GetProcAddress('glResumeTransformFeedbackNV');
    private ntv_ResumeTransformFeedbackNV_1 := GetProcOrNil&<procedure>(ResumeTransformFeedbackNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResumeTransformFeedbackNV :=
      ntv_ResumeTransformFeedbackNV_1;
    
    private DrawTransformFeedbackNV_adr := GetProcAddress('glDrawTransformFeedbackNV');
    private ntv_DrawTransformFeedbackNV_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; id: gl_transform_feedback)>(DrawTransformFeedbackNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackNV(mode: glPrimitiveType; id: gl_transform_feedback) :=
      ntv_DrawTransformFeedbackNV_1(mode, id);
    
  end;
  
  ///
  glUniformBufferStd430LayoutNV = static class
    public const _ExtStr = 'GL_NV_uniform_buffer_std430_layout';
  end;
  
  ///
  glUniformBufferUnifiedMemoryNV = static class
    public const _ExtStr = 'GL_NV_uniform_buffer_unified_memory';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVdpauInteropNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_vdpau_interop';
    
    private VDPAUInitNV_adr := GetProcAddress('glVDPAUInitNV');
    private ntv_VDPAUInitNV_1 := GetProcOrNil&<procedure(vdpDevice: IntPtr; getProcAddress: IntPtr)>(VDPAUInitNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUInitNV(vdpDevice: IntPtr; getProcAddress: IntPtr) :=
      ntv_VDPAUInitNV_1(vdpDevice, getProcAddress);
    
    private VDPAUFiniNV_adr := GetProcAddress('glVDPAUFiniNV');
    private ntv_VDPAUFiniNV_1 := GetProcOrNil&<procedure>(VDPAUFiniNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUFiniNV :=
      ntv_VDPAUFiniNV_1;
    
    private VDPAURegisterVideoSurfaceNV_adr := GetProcAddress('glVDPAURegisterVideoSurfaceNV');
    private ntv_VDPAURegisterVideoSurfaceNV_1 := GetProcOrNil&<function(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32): gl_vdpau_surface>(VDPAURegisterVideoSurfaceNV_adr);
    private ntv_VDPAURegisterVideoSurfaceNV_2 := GetProcOrNil&<function(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: IntPtr): gl_vdpau_surface>(VDPAURegisterVideoSurfaceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: array of UInt32): gl_vdpau_surface;
    type PUInt32 = ^UInt32;
    begin
      Result := if (textureNames<>nil) and (textureNames.Length<>0) then
        ntv_VDPAURegisterVideoSurfaceNV_1(vdpSurface, target, numTextureNames, textureNames[0]) else
        ntv_VDPAURegisterVideoSurfaceNV_1(vdpSurface, target, numTextureNames, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32): gl_vdpau_surface :=
      ntv_VDPAURegisterVideoSurfaceNV_1(vdpSurface, target, numTextureNames, textureNames);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: IntPtr): gl_vdpau_surface :=
      ntv_VDPAURegisterVideoSurfaceNV_2(vdpSurface, target, numTextureNames, textureNames);
    
    private VDPAURegisterOutputSurfaceNV_adr := GetProcAddress('glVDPAURegisterOutputSurfaceNV');
    private ntv_VDPAURegisterOutputSurfaceNV_1 := GetProcOrNil&<function(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32): gl_vdpau_surface>(VDPAURegisterOutputSurfaceNV_adr);
    private ntv_VDPAURegisterOutputSurfaceNV_2 := GetProcOrNil&<function(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: IntPtr): gl_vdpau_surface>(VDPAURegisterOutputSurfaceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterOutputSurfaceNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: array of UInt32): gl_vdpau_surface;
    type PUInt32 = ^UInt32;
    begin
      Result := if (textureNames<>nil) and (textureNames.Length<>0) then
        ntv_VDPAURegisterOutputSurfaceNV_1(vdpSurface, target, numTextureNames, textureNames[0]) else
        ntv_VDPAURegisterOutputSurfaceNV_1(vdpSurface, target, numTextureNames, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterOutputSurfaceNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32): gl_vdpau_surface :=
      ntv_VDPAURegisterOutputSurfaceNV_1(vdpSurface, target, numTextureNames, textureNames);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterOutputSurfaceNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: IntPtr): gl_vdpau_surface :=
      ntv_VDPAURegisterOutputSurfaceNV_2(vdpSurface, target, numTextureNames, textureNames);
    
    private VDPAUIsSurfaceNV_adr := GetProcAddress('glVDPAUIsSurfaceNV');
    private ntv_VDPAUIsSurfaceNV_1 := GetProcOrNil&<function(surface: gl_vdpau_surface): glBool8>(VDPAUIsSurfaceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAUIsSurfaceNV(surface: gl_vdpau_surface): glBool8 :=
      ntv_VDPAUIsSurfaceNV_1(surface);
    
    private VDPAUUnregisterSurfaceNV_adr := GetProcAddress('glVDPAUUnregisterSurfaceNV');
    private ntv_VDPAUUnregisterSurfaceNV_1 := GetProcOrNil&<procedure(surface: gl_vdpau_surface)>(VDPAUUnregisterSurfaceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUUnregisterSurfaceNV(surface: gl_vdpau_surface) :=
      ntv_VDPAUUnregisterSurfaceNV_1(surface);
    
    private VDPAUGetSurfaceivNV_adr := GetProcAddress('glVDPAUGetSurfaceivNV');
    private ntv_VDPAUGetSurfaceivNV_1 := GetProcOrNil&<procedure(surface: gl_vdpau_surface; pname: DummyEnum; count: Int32; var length: Int32; var values: Int32)>(VDPAUGetSurfaceivNV_adr);
    private ntv_VDPAUGetSurfaceivNV_2 := GetProcOrNil&<procedure(surface: gl_vdpau_surface; pname: DummyEnum; count: Int32; var length: Int32; values: IntPtr)>(VDPAUGetSurfaceivNV_adr);
    private ntv_VDPAUGetSurfaceivNV_3 := GetProcOrNil&<procedure(surface: gl_vdpau_surface; pname: DummyEnum; count: Int32; length: IntPtr; var values: Int32)>(VDPAUGetSurfaceivNV_adr);
    private ntv_VDPAUGetSurfaceivNV_4 := GetProcOrNil&<procedure(surface: gl_vdpau_surface; pname: DummyEnum; count: Int32; length: IntPtr; values: IntPtr)>(VDPAUGetSurfaceivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: gl_vdpau_surface; pname: DummyEnum; count: Int32; length: array of Int32; values: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (values<>nil) and (values.Length<>0) then
        if (length<>nil) and (length.Length<>0) then
          ntv_VDPAUGetSurfaceivNV_1(surface, pname, count, length[0], values[0]) else
          ntv_VDPAUGetSurfaceivNV_1(surface, pname, count, PInt32(nil)^, values[0]) else
        if (length<>nil) and (length.Length<>0) then
          ntv_VDPAUGetSurfaceivNV_1(surface, pname, count, length[0], PInt32(nil)^) else
          ntv_VDPAUGetSurfaceivNV_1(surface, pname, count, PInt32(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: gl_vdpau_surface; pname: DummyEnum; count: Int32; var length: Int32; var values: Int32) :=
      ntv_VDPAUGetSurfaceivNV_1(surface, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: gl_vdpau_surface; pname: DummyEnum; count: Int32; var length: Int32; values: IntPtr) :=
      ntv_VDPAUGetSurfaceivNV_2(surface, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: gl_vdpau_surface; pname: DummyEnum; count: Int32; length: IntPtr; var values: Int32) :=
      ntv_VDPAUGetSurfaceivNV_3(surface, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: gl_vdpau_surface; pname: DummyEnum; count: Int32; length: IntPtr; values: IntPtr) :=
      ntv_VDPAUGetSurfaceivNV_4(surface, pname, count, length, values);
    
    private VDPAUSurfaceAccessNV_adr := GetProcAddress('glVDPAUSurfaceAccessNV');
    private ntv_VDPAUSurfaceAccessNV_1 := GetProcOrNil&<procedure(surface: gl_vdpau_surface; access: DummyEnum)>(VDPAUSurfaceAccessNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUSurfaceAccessNV(surface: gl_vdpau_surface; access: DummyEnum) :=
      ntv_VDPAUSurfaceAccessNV_1(surface, access);
    
    private VDPAUMapSurfacesNV_adr := GetProcAddress('glVDPAUMapSurfacesNV');
    private ntv_VDPAUMapSurfacesNV_1 := GetProcOrNil&<procedure(numSurfaces: Int32; var surfaces: gl_vdpau_surface)>(VDPAUMapSurfacesNV_adr);
    private ntv_VDPAUMapSurfacesNV_2 := GetProcOrNil&<procedure(numSurfaces: Int32; surfaces: IntPtr)>(VDPAUMapSurfacesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUMapSurfacesNV(numSurfaces: Int32; surfaces: array of gl_vdpau_surface);
    type PGl_vdpau_surface = ^gl_vdpau_surface;
    begin
      if (surfaces<>nil) and (surfaces.Length<>0) then
        ntv_VDPAUMapSurfacesNV_1(numSurfaces, surfaces[0]) else
        ntv_VDPAUMapSurfacesNV_1(numSurfaces, PGl_vdpau_surface(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUMapSurfacesNV(numSurfaces: Int32; var surfaces: gl_vdpau_surface) :=
      ntv_VDPAUMapSurfacesNV_1(numSurfaces, surfaces);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUMapSurfacesNV(numSurfaces: Int32; surfaces: IntPtr) :=
      ntv_VDPAUMapSurfacesNV_2(numSurfaces, surfaces);
    
    private VDPAUUnmapSurfacesNV_adr := GetProcAddress('glVDPAUUnmapSurfacesNV');
    private ntv_VDPAUUnmapSurfacesNV_1 := GetProcOrNil&<procedure(numSurface: Int32; var surfaces: gl_vdpau_surface)>(VDPAUUnmapSurfacesNV_adr);
    private ntv_VDPAUUnmapSurfacesNV_2 := GetProcOrNil&<procedure(numSurface: Int32; surfaces: IntPtr)>(VDPAUUnmapSurfacesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUUnmapSurfacesNV(numSurface: Int32; surfaces: array of gl_vdpau_surface);
    type PGl_vdpau_surface = ^gl_vdpau_surface;
    begin
      if (surfaces<>nil) and (surfaces.Length<>0) then
        ntv_VDPAUUnmapSurfacesNV_1(numSurface, surfaces[0]) else
        ntv_VDPAUUnmapSurfacesNV_1(numSurface, PGl_vdpau_surface(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUUnmapSurfacesNV(numSurface: Int32; var surfaces: gl_vdpau_surface) :=
      ntv_VDPAUUnmapSurfacesNV_1(numSurface, surfaces);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUUnmapSurfacesNV(numSurface: Int32; surfaces: IntPtr) :=
      ntv_VDPAUUnmapSurfacesNV_2(numSurface, surfaces);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVdpauInterop2NV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_vdpau_interop2';
    
    private VDPAURegisterVideoSurfaceWithPictureStructureNV_adr := GetProcAddress('glVDPAURegisterVideoSurfaceWithPictureStructureNV');
    private ntv_VDPAURegisterVideoSurfaceWithPictureStructureNV_1 := GetProcOrNil&<function(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32; isFrameStructure: glBool8): gl_vdpau_surface>(VDPAURegisterVideoSurfaceWithPictureStructureNV_adr);
    private ntv_VDPAURegisterVideoSurfaceWithPictureStructureNV_2 := GetProcOrNil&<function(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: IntPtr; isFrameStructure: glBool8): gl_vdpau_surface>(VDPAURegisterVideoSurfaceWithPictureStructureNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: array of UInt32; isFrameStructure: glBool8): gl_vdpau_surface;
    type PUInt32 = ^UInt32;
    begin
      Result := if (textureNames<>nil) and (textureNames.Length<>0) then
        ntv_VDPAURegisterVideoSurfaceWithPictureStructureNV_1(vdpSurface, target, numTextureNames, textureNames[0], isFrameStructure) else
        ntv_VDPAURegisterVideoSurfaceWithPictureStructureNV_1(vdpSurface, target, numTextureNames, PUInt32(nil)^, isFrameStructure);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32; isFrameStructure: glBool8): gl_vdpau_surface :=
      ntv_VDPAURegisterVideoSurfaceWithPictureStructureNV_1(vdpSurface, target, numTextureNames, textureNames, isFrameStructure);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: IntPtr; isFrameStructure: glBool8): gl_vdpau_surface :=
      ntv_VDPAURegisterVideoSurfaceWithPictureStructureNV_2(vdpSurface, target, numTextureNames, textureNames, isFrameStructure);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexArrayRangeNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_vertex_array_range';
    
    private FlushVertexArrayRangeNV_adr := GetProcAddress('glFlushVertexArrayRangeNV');
    private ntv_FlushVertexArrayRangeNV_1 := GetProcOrNil&<procedure>(FlushVertexArrayRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushVertexArrayRangeNV :=
      ntv_FlushVertexArrayRangeNV_1;
    
    private VertexArrayRangeNV_adr := GetProcAddress('glVertexArrayRangeNV');
    private ntv_VertexArrayRangeNV_1 := GetProcOrNil&<procedure(length: Int32; pointer: IntPtr)>(VertexArrayRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayRangeNV(length: Int32; pointer: IntPtr) :=
      ntv_VertexArrayRangeNV_1(length, pointer);
    
  end;
  
  ///
  glVertexArrayRange2NV = static class
    public const _ExtStr = 'GL_NV_vertex_array_range2';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexAttribInteger64bitNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_vertex_attrib_integer_64bit';
    
    private VertexAttribL1i64NV_adr := GetProcAddress('glVertexAttribL1i64NV');
    private ntv_VertexAttribL1i64NV_1 := GetProcOrNil&<procedure(index: UInt32; x: Int64)>(VertexAttribL1i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1i64NV(index: UInt32; x: Int64) :=
      ntv_VertexAttribL1i64NV_1(index, x);
    
    private VertexAttribL2i64NV_adr := GetProcAddress('glVertexAttribL2i64NV');
    private ntv_VertexAttribL2i64NV_1 := GetProcOrNil&<procedure(index: UInt32; x: Int64; y: Int64)>(VertexAttribL2i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2i64NV(index: UInt32; x: Int64; y: Int64) :=
      ntv_VertexAttribL2i64NV_1(index, x, y);
    
    private VertexAttribL3i64NV_adr := GetProcAddress('glVertexAttribL3i64NV');
    private ntv_VertexAttribL3i64NV_1 := GetProcOrNil&<procedure(index: UInt32; x: Int64; y: Int64; z: Int64)>(VertexAttribL3i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3i64NV(index: UInt32; x: Int64; y: Int64; z: Int64) :=
      ntv_VertexAttribL3i64NV_1(index, x, y, z);
    
    private VertexAttribL4i64NV_adr := GetProcAddress('glVertexAttribL4i64NV');
    private ntv_VertexAttribL4i64NV_1 := GetProcOrNil&<procedure(index: UInt32; x: Int64; y: Int64; z: Int64; w: Int64)>(VertexAttribL4i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4i64NV(index: UInt32; x: Int64; y: Int64; z: Int64; w: Int64) :=
      ntv_VertexAttribL4i64NV_1(index, x, y, z, w);
    
    private VertexAttribL1i64vNV_adr := GetProcAddress('glVertexAttribL1i64vNV');
    private ntv_VertexAttribL1i64vNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int64)>(VertexAttribL1i64vNV_adr);
    private ntv_VertexAttribL1i64vNV_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL1i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1i64vNV(index: UInt32; v: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL1i64vNV_1(index, v[0]) else
        ntv_VertexAttribL1i64vNV_1(index, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1i64vNV(index: UInt32; var v: Int64) :=
      ntv_VertexAttribL1i64vNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1i64vNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL1i64vNV_2(index, v);
    
    private VertexAttribL2i64vNV_adr := GetProcAddress('glVertexAttribL2i64vNV');
    private ntv_VertexAttribL2i64vNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int64)>(VertexAttribL2i64vNV_adr);
    private ntv_VertexAttribL2i64vNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2i64)>(VertexAttribL2i64vNV_adr);
    private ntv_VertexAttribL2i64vNV_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL2i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2i64vNV(index: UInt32; v: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL2i64vNV_1(index, v[0]) else
        ntv_VertexAttribL2i64vNV_1(index, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2i64vNV(index: UInt32; var v: Vec2i64) :=
      ntv_VertexAttribL2i64vNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2i64vNV(index: UInt32; var v: Int64) :=
      ntv_VertexAttribL2i64vNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2i64vNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL2i64vNV_3(index, v);
    
    private VertexAttribL3i64vNV_adr := GetProcAddress('glVertexAttribL3i64vNV');
    private ntv_VertexAttribL3i64vNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int64)>(VertexAttribL3i64vNV_adr);
    private ntv_VertexAttribL3i64vNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3i64)>(VertexAttribL3i64vNV_adr);
    private ntv_VertexAttribL3i64vNV_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL3i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3i64vNV(index: UInt32; v: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL3i64vNV_1(index, v[0]) else
        ntv_VertexAttribL3i64vNV_1(index, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3i64vNV(index: UInt32; var v: Vec3i64) :=
      ntv_VertexAttribL3i64vNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3i64vNV(index: UInt32; var v: Int64) :=
      ntv_VertexAttribL3i64vNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3i64vNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL3i64vNV_3(index, v);
    
    private VertexAttribL4i64vNV_adr := GetProcAddress('glVertexAttribL4i64vNV');
    private ntv_VertexAttribL4i64vNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int64)>(VertexAttribL4i64vNV_adr);
    private ntv_VertexAttribL4i64vNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4i64)>(VertexAttribL4i64vNV_adr);
    private ntv_VertexAttribL4i64vNV_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL4i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4i64vNV(index: UInt32; v: array of Int64);
    type PInt64 = ^Int64;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL4i64vNV_1(index, v[0]) else
        ntv_VertexAttribL4i64vNV_1(index, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4i64vNV(index: UInt32; var v: Vec4i64) :=
      ntv_VertexAttribL4i64vNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4i64vNV(index: UInt32; var v: Int64) :=
      ntv_VertexAttribL4i64vNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4i64vNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL4i64vNV_3(index, v);
    
    private VertexAttribL1ui64NV_adr := GetProcAddress('glVertexAttribL1ui64NV');
    private ntv_VertexAttribL1ui64NV_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt64)>(VertexAttribL1ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64NV(index: UInt32; x: UInt64) :=
      ntv_VertexAttribL1ui64NV_1(index, x);
    
    private VertexAttribL2ui64NV_adr := GetProcAddress('glVertexAttribL2ui64NV');
    private ntv_VertexAttribL2ui64NV_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt64; y: UInt64)>(VertexAttribL2ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2ui64NV(index: UInt32; x: UInt64; y: UInt64) :=
      ntv_VertexAttribL2ui64NV_1(index, x, y);
    
    private VertexAttribL3ui64NV_adr := GetProcAddress('glVertexAttribL3ui64NV');
    private ntv_VertexAttribL3ui64NV_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt64; y: UInt64; z: UInt64)>(VertexAttribL3ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3ui64NV(index: UInt32; x: UInt64; y: UInt64; z: UInt64) :=
      ntv_VertexAttribL3ui64NV_1(index, x, y, z);
    
    private VertexAttribL4ui64NV_adr := GetProcAddress('glVertexAttribL4ui64NV');
    private ntv_VertexAttribL4ui64NV_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>(VertexAttribL4ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4ui64NV(index: UInt32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) :=
      ntv_VertexAttribL4ui64NV_1(index, x, y, z, w);
    
    private VertexAttribL1ui64vNV_adr := GetProcAddress('glVertexAttribL1ui64vNV');
    private ntv_VertexAttribL1ui64vNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt64)>(VertexAttribL1ui64vNV_adr);
    private ntv_VertexAttribL1ui64vNV_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL1ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vNV(index: UInt32; v: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL1ui64vNV_1(index, v[0]) else
        ntv_VertexAttribL1ui64vNV_1(index, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vNV(index: UInt32; var v: UInt64) :=
      ntv_VertexAttribL1ui64vNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL1ui64vNV_2(index, v);
    
    private VertexAttribL2ui64vNV_adr := GetProcAddress('glVertexAttribL2ui64vNV');
    private ntv_VertexAttribL2ui64vNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt64)>(VertexAttribL2ui64vNV_adr);
    private ntv_VertexAttribL2ui64vNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2ui64)>(VertexAttribL2ui64vNV_adr);
    private ntv_VertexAttribL2ui64vNV_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL2ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2ui64vNV(index: UInt32; v: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL2ui64vNV_1(index, v[0]) else
        ntv_VertexAttribL2ui64vNV_1(index, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2ui64vNV(index: UInt32; var v: Vec2ui64) :=
      ntv_VertexAttribL2ui64vNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2ui64vNV(index: UInt32; var v: UInt64) :=
      ntv_VertexAttribL2ui64vNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2ui64vNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL2ui64vNV_3(index, v);
    
    private VertexAttribL3ui64vNV_adr := GetProcAddress('glVertexAttribL3ui64vNV');
    private ntv_VertexAttribL3ui64vNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt64)>(VertexAttribL3ui64vNV_adr);
    private ntv_VertexAttribL3ui64vNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3ui64)>(VertexAttribL3ui64vNV_adr);
    private ntv_VertexAttribL3ui64vNV_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL3ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3ui64vNV(index: UInt32; v: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL3ui64vNV_1(index, v[0]) else
        ntv_VertexAttribL3ui64vNV_1(index, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3ui64vNV(index: UInt32; var v: Vec3ui64) :=
      ntv_VertexAttribL3ui64vNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3ui64vNV(index: UInt32; var v: UInt64) :=
      ntv_VertexAttribL3ui64vNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3ui64vNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL3ui64vNV_3(index, v);
    
    private VertexAttribL4ui64vNV_adr := GetProcAddress('glVertexAttribL4ui64vNV');
    private ntv_VertexAttribL4ui64vNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt64)>(VertexAttribL4ui64vNV_adr);
    private ntv_VertexAttribL4ui64vNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ui64)>(VertexAttribL4ui64vNV_adr);
    private ntv_VertexAttribL4ui64vNV_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL4ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4ui64vNV(index: UInt32; v: array of UInt64);
    type PUInt64 = ^UInt64;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL4ui64vNV_1(index, v[0]) else
        ntv_VertexAttribL4ui64vNV_1(index, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4ui64vNV(index: UInt32; var v: Vec4ui64) :=
      ntv_VertexAttribL4ui64vNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4ui64vNV(index: UInt32; var v: UInt64) :=
      ntv_VertexAttribL4ui64vNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4ui64vNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL4ui64vNV_3(index, v);
    
    private GetVertexAttribLi64vNV_adr := GetProcAddress('glGetVertexAttribLi64vNV');
    private ntv_GetVertexAttribLi64vNV_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; var &params: Int64)>(GetVertexAttribLi64vNV_adr);
    private ntv_GetVertexAttribLi64vNV_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr)>(GetVertexAttribLi64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLi64vNV(index: UInt32; pname: glVertexAttribEnum; var &params: Int64) :=
      ntv_GetVertexAttribLi64vNV_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLi64vNV(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr) :=
      ntv_GetVertexAttribLi64vNV_2(index, pname, &params);
    
    private GetVertexAttribLui64vNV_adr := GetProcAddress('glGetVertexAttribLui64vNV');
    private ntv_GetVertexAttribLui64vNV_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; var &params: UInt64)>(GetVertexAttribLui64vNV_adr);
    private ntv_GetVertexAttribLui64vNV_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr)>(GetVertexAttribLui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLui64vNV(index: UInt32; pname: glVertexAttribEnum; var &params: UInt64) :=
      ntv_GetVertexAttribLui64vNV_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLui64vNV(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr) :=
      ntv_GetVertexAttribLui64vNV_2(index, pname, &params);
    
    private VertexAttribLFormatNV_adr := GetProcAddress('glVertexAttribLFormatNV');
    private ntv_VertexAttribLFormatNV_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: glVertexAttribLType; stride: Int32)>(VertexAttribLFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLFormatNV(index: UInt32; size: Int32; &type: glVertexAttribLType; stride: Int32) :=
      ntv_VertexAttribLFormatNV_1(index, size, &type, stride);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexBufferUnifiedMemoryNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_vertex_buffer_unified_memory';
    
    private BufferAddressRangeNV_adr := GetProcAddress('glBufferAddressRangeNV');
    private ntv_BufferAddressRangeNV_1 := GetProcOrNil&<procedure(pname: DummyEnum; index: UInt32; address: UInt64; length: UIntPtr)>(BufferAddressRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferAddressRangeNV(pname: DummyEnum; index: UInt32; address: UInt64; length: UIntPtr) :=
      ntv_BufferAddressRangeNV_1(pname, index, address, length);
    
    private VertexFormatNV_adr := GetProcAddress('glVertexFormatNV');
    private ntv_VertexFormatNV_1 := GetProcOrNil&<procedure(size: Int32; &type: glVertexPointerType; stride: Int32)>(VertexFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexFormatNV(size: Int32; &type: glVertexPointerType; stride: Int32) :=
      ntv_VertexFormatNV_1(size, &type, stride);
    
    private NormalFormatNV_adr := GetProcAddress('glNormalFormatNV');
    private ntv_NormalFormatNV_1 := GetProcOrNil&<procedure(&type: DummyEnum; stride: Int32)>(NormalFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalFormatNV(&type: DummyEnum; stride: Int32) :=
      ntv_NormalFormatNV_1(&type, stride);
    
    private ColorFormatNV_adr := GetProcAddress('glColorFormatNV');
    private ntv_ColorFormatNV_1 := GetProcOrNil&<procedure(size: Int32; &type: glColorPointerType; stride: Int32)>(ColorFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorFormatNV(size: Int32; &type: glColorPointerType; stride: Int32) :=
      ntv_ColorFormatNV_1(size, &type, stride);
    
    private IndexFormatNV_adr := GetProcAddress('glIndexFormatNV');
    private ntv_IndexFormatNV_1 := GetProcOrNil&<procedure(&type: DummyEnum; stride: Int32)>(IndexFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexFormatNV(&type: DummyEnum; stride: Int32) :=
      ntv_IndexFormatNV_1(&type, stride);
    
    private TexCoordFormatNV_adr := GetProcAddress('glTexCoordFormatNV');
    private ntv_TexCoordFormatNV_1 := GetProcOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32)>(TexCoordFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordFormatNV(size: Int32; &type: DummyEnum; stride: Int32) :=
      ntv_TexCoordFormatNV_1(size, &type, stride);
    
    private EdgeFlagFormatNV_adr := GetProcAddress('glEdgeFlagFormatNV');
    private ntv_EdgeFlagFormatNV_1 := GetProcOrNil&<procedure(stride: Int32)>(EdgeFlagFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagFormatNV(stride: Int32) :=
      ntv_EdgeFlagFormatNV_1(stride);
    
    private SecondaryColorFormatNV_adr := GetProcAddress('glSecondaryColorFormatNV');
    private ntv_SecondaryColorFormatNV_1 := GetProcOrNil&<procedure(size: Int32; &type: glColorPointerType; stride: Int32)>(SecondaryColorFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorFormatNV(size: Int32; &type: glColorPointerType; stride: Int32) :=
      ntv_SecondaryColorFormatNV_1(size, &type, stride);
    
    private FogCoordFormatNV_adr := GetProcAddress('glFogCoordFormatNV');
    private ntv_FogCoordFormatNV_1 := GetProcOrNil&<procedure(&type: DummyEnum; stride: Int32)>(FogCoordFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordFormatNV(&type: DummyEnum; stride: Int32) :=
      ntv_FogCoordFormatNV_1(&type, stride);
    
    private VertexAttribFormatNV_adr := GetProcAddress('glVertexAttribFormatNV');
    private ntv_VertexAttribFormatNV_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: glVertexAttribType; normalized: glBool8; stride: Int32)>(VertexAttribFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribFormatNV(index: UInt32; size: Int32; &type: glVertexAttribType; normalized: glBool8; stride: Int32) :=
      ntv_VertexAttribFormatNV_1(index, size, &type, normalized, stride);
    
    private VertexAttribIFormatNV_adr := GetProcAddress('glVertexAttribIFormatNV');
    private ntv_VertexAttribIFormatNV_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: glVertexAttribIType; stride: Int32)>(VertexAttribIFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIFormatNV(index: UInt32; size: Int32; &type: glVertexAttribIType; stride: Int32) :=
      ntv_VertexAttribIFormatNV_1(index, size, &type, stride);
    
    private GetIntegerui64i_vNV_adr := GetProcAddress('glGetIntegerui64i_vNV');
    private ntv_GetIntegerui64i_vNV_1 := GetProcOrNil&<procedure(value: DummyEnum; index: UInt32; var result: UInt64)>(GetIntegerui64i_vNV_adr);
    private ntv_GetIntegerui64i_vNV_2 := GetProcOrNil&<procedure(value: DummyEnum; index: UInt32; result: IntPtr)>(GetIntegerui64i_vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64i_vNV(value: DummyEnum; index: UInt32; var result: UInt64) :=
      ntv_GetIntegerui64i_vNV_1(value, index, result);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64i_vNV(value: DummyEnum; index: UInt32; result: IntPtr) :=
      ntv_GetIntegerui64i_vNV_2(value, index, result);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexProgramNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_vertex_program';
    
    private AreProgramsResidentNV_adr := GetProcAddress('glAreProgramsResidentNV');
    private ntv_AreProgramsResidentNV_1 := GetProcOrNil&<function(n: Int32; var programs: gl_program; var residences: glBool8): glBool8>(AreProgramsResidentNV_adr);
    private ntv_AreProgramsResidentNV_2 := GetProcOrNil&<function(n: Int32; var programs: gl_program; residences: IntPtr): glBool8>(AreProgramsResidentNV_adr);
    private ntv_AreProgramsResidentNV_3 := GetProcOrNil&<function(n: Int32; programs: IntPtr; var residences: glBool8): glBool8>(AreProgramsResidentNV_adr);
    private ntv_AreProgramsResidentNV_4 := GetProcOrNil&<function(n: Int32; programs: IntPtr; residences: IntPtr): glBool8>(AreProgramsResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: array of gl_program; residences: array of glBool8): glBool8;
    type PGl_program = ^gl_program;
    type PGlBool8 = ^glBool8;
    begin
      Result := if (residences<>nil) and (residences.Length<>0) then
        if (programs<>nil) and (programs.Length<>0) then
          ntv_AreProgramsResidentNV_1(n, programs[0], residences[0]) else
          ntv_AreProgramsResidentNV_1(n, PGl_program(nil)^, residences[0]) else
        if (programs<>nil) and (programs.Length<>0) then
          ntv_AreProgramsResidentNV_1(n, programs[0], PGlBool8(nil)^) else
          ntv_AreProgramsResidentNV_1(n, PGl_program(nil)^, PGlBool8(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; var programs: gl_program; var residences: glBool8): glBool8 :=
      ntv_AreProgramsResidentNV_1(n, programs, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; var programs: gl_program; residences: IntPtr): glBool8 :=
      ntv_AreProgramsResidentNV_2(n, programs, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: IntPtr; var residences: glBool8): glBool8 :=
      ntv_AreProgramsResidentNV_3(n, programs, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: IntPtr; residences: IntPtr): glBool8 :=
      ntv_AreProgramsResidentNV_4(n, programs, residences);
    
    private BindProgramNV_adr := GetProcAddress('glBindProgramNV');
    private ntv_BindProgramNV_1 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; id: gl_program)>(BindProgramNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindProgramNV(target: glVertexAttribEnumNV; id: gl_program) :=
      ntv_BindProgramNV_1(target, id);
    
    private DeleteProgramsNV_adr := GetProcAddress('glDeleteProgramsNV');
    private ntv_DeleteProgramsNV_1 := GetProcOrNil&<procedure(n: Int32; var programs: gl_program)>(DeleteProgramsNV_adr);
    private ntv_DeleteProgramsNV_2 := GetProcOrNil&<procedure(n: Int32; programs: IntPtr)>(DeleteProgramsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsNV(n: Int32; programs: array of gl_program);
    type PGl_program = ^gl_program;
    begin
      if (programs<>nil) and (programs.Length<>0) then
        ntv_DeleteProgramsNV_1(n, programs[0]) else
        ntv_DeleteProgramsNV_1(n, PGl_program(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsNV(n: Int32; var programs: gl_program) :=
      ntv_DeleteProgramsNV_1(n, programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsNV(n: Int32; programs: IntPtr) :=
      ntv_DeleteProgramsNV_2(n, programs);
    
    private ExecuteProgramNV_adr := GetProcAddress('glExecuteProgramNV');
    private ntv_ExecuteProgramNV_1 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; id: UInt32; var &params: single)>(ExecuteProgramNV_adr);
    private ntv_ExecuteProgramNV_2 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; id: UInt32; &params: IntPtr)>(ExecuteProgramNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExecuteProgramNV(target: glVertexAttribEnumNV; id: UInt32; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ExecuteProgramNV_1(target, id, &params[0]) else
        ntv_ExecuteProgramNV_1(target, id, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExecuteProgramNV(target: glVertexAttribEnumNV; id: UInt32; var &params: single) :=
      ntv_ExecuteProgramNV_1(target, id, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExecuteProgramNV(target: glVertexAttribEnumNV; id: UInt32; &params: IntPtr) :=
      ntv_ExecuteProgramNV_2(target, id, &params);
    
    private GenProgramsNV_adr := GetProcAddress('glGenProgramsNV');
    private ntv_GenProgramsNV_1 := GetProcOrNil&<procedure(n: Int32; var programs: gl_program)>(GenProgramsNV_adr);
    private ntv_GenProgramsNV_2 := GetProcOrNil&<procedure(n: Int32; programs: IntPtr)>(GenProgramsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsNV(n: Int32; programs: array of gl_program);
    type PGl_program = ^gl_program;
    begin
      if (programs<>nil) and (programs.Length<>0) then
        ntv_GenProgramsNV_1(n, programs[0]) else
        ntv_GenProgramsNV_1(n, PGl_program(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsNV(n: Int32; var programs: gl_program) :=
      ntv_GenProgramsNV_1(n, programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsNV(n: Int32; programs: IntPtr) :=
      ntv_GenProgramsNV_2(n, programs);
    
    private GetProgramParameterdvNV_adr := GetProcAddress('glGetProgramParameterdvNV');
    private ntv_GetProgramParameterdvNV_1 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; pname: glVertexAttribEnumNV; var &params: double)>(GetProgramParameterdvNV_adr);
    private ntv_GetProgramParameterdvNV_2 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; pname: glVertexAttribEnumNV; &params: IntPtr)>(GetProgramParameterdvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterdvNV(target: glVertexAttribEnumNV; index: UInt32; pname: glVertexAttribEnumNV; var &params: double) :=
      ntv_GetProgramParameterdvNV_1(target, index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterdvNV(target: glVertexAttribEnumNV; index: UInt32; pname: glVertexAttribEnumNV; &params: IntPtr) :=
      ntv_GetProgramParameterdvNV_2(target, index, pname, &params);
    
    private GetProgramParameterfvNV_adr := GetProcAddress('glGetProgramParameterfvNV');
    private ntv_GetProgramParameterfvNV_1 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; pname: glVertexAttribEnumNV; var &params: single)>(GetProgramParameterfvNV_adr);
    private ntv_GetProgramParameterfvNV_2 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; pname: glVertexAttribEnumNV; &params: IntPtr)>(GetProgramParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterfvNV(target: glVertexAttribEnumNV; index: UInt32; pname: glVertexAttribEnumNV; var &params: single) :=
      ntv_GetProgramParameterfvNV_1(target, index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterfvNV(target: glVertexAttribEnumNV; index: UInt32; pname: glVertexAttribEnumNV; &params: IntPtr) :=
      ntv_GetProgramParameterfvNV_2(target, index, pname, &params);
    
    private GetProgramivNV_adr := GetProcAddress('glGetProgramivNV');
    private ntv_GetProgramivNV_1 := GetProcOrNil&<procedure(id: gl_program; pname: glVertexAttribEnumNV; var &params: Int32)>(GetProgramivNV_adr);
    private ntv_GetProgramivNV_2 := GetProcOrNil&<procedure(id: gl_program; pname: glVertexAttribEnumNV; &params: IntPtr)>(GetProgramivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivNV(id: gl_program; pname: glVertexAttribEnumNV; var &params: Int32) :=
      ntv_GetProgramivNV_1(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivNV(id: gl_program; pname: glVertexAttribEnumNV; &params: IntPtr) :=
      ntv_GetProgramivNV_2(id, pname, &params);
    
    private GetProgramStringNV_adr := GetProcAddress('glGetProgramStringNV');
    private ntv_GetProgramStringNV_1 := GetProcOrNil&<procedure(id: gl_program; pname: glVertexAttribEnumNV; &program: IntPtr)>(GetProgramStringNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStringNV(id: gl_program; pname: glVertexAttribEnumNV; &program: IntPtr) :=
      ntv_GetProgramStringNV_1(id, pname, &program);
    
    private GetTrackMatrixivNV_adr := GetProcAddress('glGetTrackMatrixivNV');
    private ntv_GetTrackMatrixivNV_1 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; address: UInt32; pname: glVertexAttribEnumNV; var &params: Int32)>(GetTrackMatrixivNV_adr);
    private ntv_GetTrackMatrixivNV_2 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; address: UInt32; pname: glVertexAttribEnumNV; &params: IntPtr)>(GetTrackMatrixivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTrackMatrixivNV(target: glVertexAttribEnumNV; address: UInt32; pname: glVertexAttribEnumNV; var &params: Int32) :=
      ntv_GetTrackMatrixivNV_1(target, address, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTrackMatrixivNV(target: glVertexAttribEnumNV; address: UInt32; pname: glVertexAttribEnumNV; &params: IntPtr) :=
      ntv_GetTrackMatrixivNV_2(target, address, pname, &params);
    
    private GetVertexAttribdvNV_adr := GetProcAddress('glGetVertexAttribdvNV');
    private ntv_GetVertexAttribdvNV_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnumNV; var &params: double)>(GetVertexAttribdvNV_adr);
    private ntv_GetVertexAttribdvNV_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnumNV; &params: IntPtr)>(GetVertexAttribdvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvNV(index: UInt32; pname: glVertexAttribEnumNV; var &params: double) :=
      ntv_GetVertexAttribdvNV_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvNV(index: UInt32; pname: glVertexAttribEnumNV; &params: IntPtr) :=
      ntv_GetVertexAttribdvNV_2(index, pname, &params);
    
    private GetVertexAttribfvNV_adr := GetProcAddress('glGetVertexAttribfvNV');
    private ntv_GetVertexAttribfvNV_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnumNV; var &params: single)>(GetVertexAttribfvNV_adr);
    private ntv_GetVertexAttribfvNV_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnumNV; &params: IntPtr)>(GetVertexAttribfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvNV(index: UInt32; pname: glVertexAttribEnumNV; var &params: single) :=
      ntv_GetVertexAttribfvNV_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvNV(index: UInt32; pname: glVertexAttribEnumNV; &params: IntPtr) :=
      ntv_GetVertexAttribfvNV_2(index, pname, &params);
    
    private GetVertexAttribivNV_adr := GetProcAddress('glGetVertexAttribivNV');
    private ntv_GetVertexAttribivNV_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnumNV; var &params: Int32)>(GetVertexAttribivNV_adr);
    private ntv_GetVertexAttribivNV_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnumNV; &params: IntPtr)>(GetVertexAttribivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivNV(index: UInt32; pname: glVertexAttribEnumNV; var &params: Int32) :=
      ntv_GetVertexAttribivNV_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivNV(index: UInt32; pname: glVertexAttribEnumNV; &params: IntPtr) :=
      ntv_GetVertexAttribivNV_2(index, pname, &params);
    
    private GetVertexAttribPointervNV_adr := GetProcAddress('glGetVertexAttribPointervNV');
    private ntv_GetVertexAttribPointervNV_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnumNV; var pointer: IntPtr)>(GetVertexAttribPointervNV_adr);
    private ntv_GetVertexAttribPointervNV_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnumNV; pointer: pointer)>(GetVertexAttribPointervNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervNV(index: UInt32; pname: glVertexAttribEnumNV; var pointer: IntPtr) :=
      ntv_GetVertexAttribPointervNV_1(index, pname, pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervNV(index: UInt32; pname: glVertexAttribEnumNV; pointer: pointer) :=
      ntv_GetVertexAttribPointervNV_2(index, pname, pointer);
    
    private IsProgramNV_adr := GetProcAddress('glIsProgramNV');
    private ntv_IsProgramNV_1 := GetProcOrNil&<function(id: gl_program): glBool8>(IsProgramNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsProgramNV(id: gl_program): glBool8 :=
      ntv_IsProgramNV_1(id);
    
    private LoadProgramNV_adr := GetProcAddress('glLoadProgramNV');
    private ntv_LoadProgramNV_1 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; id: UInt32; len: Int32; var &program: Byte)>(LoadProgramNV_adr);
    private ntv_LoadProgramNV_2 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; id: UInt32; len: Int32; &program: IntPtr)>(LoadProgramNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadProgramNV(target: glVertexAttribEnumNV; id: UInt32; len: Int32; &program: array of Byte);
    type PByte = ^Byte;
    begin
      if (&program<>nil) and (&program.Length<>0) then
        ntv_LoadProgramNV_1(target, id, len, &program[0]) else
        ntv_LoadProgramNV_1(target, id, len, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadProgramNV(target: glVertexAttribEnumNV; id: UInt32; len: Int32; var &program: Byte) :=
      ntv_LoadProgramNV_1(target, id, len, &program);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadProgramNV(target: glVertexAttribEnumNV; id: UInt32; len: Int32; &program: IntPtr) :=
      ntv_LoadProgramNV_2(target, id, len, &program);
    
    private ProgramParameter4dNV_adr := GetProcAddress('glProgramParameter4dNV');
    private ntv_ProgramParameter4dNV_1 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; x: double; y: double; z: double; w: double)>(ProgramParameter4dNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4dNV(target: glVertexAttribEnumNV; index: UInt32; x: double; y: double; z: double; w: double) :=
      ntv_ProgramParameter4dNV_1(target, index, x, y, z, w);
    
    private ProgramParameter4dvNV_adr := GetProcAddress('glProgramParameter4dvNV');
    private ntv_ProgramParameter4dvNV_1 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; var v: double)>(ProgramParameter4dvNV_adr);
    private ntv_ProgramParameter4dvNV_2 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; var v: Vec4d)>(ProgramParameter4dvNV_adr);
    private ntv_ProgramParameter4dvNV_3 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; v: IntPtr)>(ProgramParameter4dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4dvNV(target: glVertexAttribEnumNV; index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_ProgramParameter4dvNV_1(target, index, v[0]) else
        ntv_ProgramParameter4dvNV_1(target, index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4dvNV(target: glVertexAttribEnumNV; index: UInt32; var v: Vec4d) :=
      ntv_ProgramParameter4dvNV_2(target, index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4dvNV(target: glVertexAttribEnumNV; index: UInt32; var v: double) :=
      ntv_ProgramParameter4dvNV_1(target, index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4dvNV(target: glVertexAttribEnumNV; index: UInt32; v: IntPtr) :=
      ntv_ProgramParameter4dvNV_3(target, index, v);
    
    private ProgramParameter4fNV_adr := GetProcAddress('glProgramParameter4fNV');
    private ntv_ProgramParameter4fNV_1 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; x: single; y: single; z: single; w: single)>(ProgramParameter4fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4fNV(target: glVertexAttribEnumNV; index: UInt32; x: single; y: single; z: single; w: single) :=
      ntv_ProgramParameter4fNV_1(target, index, x, y, z, w);
    
    private ProgramParameter4fvNV_adr := GetProcAddress('glProgramParameter4fvNV');
    private ntv_ProgramParameter4fvNV_1 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; var v: single)>(ProgramParameter4fvNV_adr);
    private ntv_ProgramParameter4fvNV_2 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; var v: Vec4f)>(ProgramParameter4fvNV_adr);
    private ntv_ProgramParameter4fvNV_3 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; v: IntPtr)>(ProgramParameter4fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4fvNV(target: glVertexAttribEnumNV; index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_ProgramParameter4fvNV_1(target, index, v[0]) else
        ntv_ProgramParameter4fvNV_1(target, index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4fvNV(target: glVertexAttribEnumNV; index: UInt32; var v: Vec4f) :=
      ntv_ProgramParameter4fvNV_2(target, index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4fvNV(target: glVertexAttribEnumNV; index: UInt32; var v: single) :=
      ntv_ProgramParameter4fvNV_1(target, index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4fvNV(target: glVertexAttribEnumNV; index: UInt32; v: IntPtr) :=
      ntv_ProgramParameter4fvNV_3(target, index, v);
    
    private ProgramParameters4dvNV_adr := GetProcAddress('glProgramParameters4dvNV');
    private ntv_ProgramParameters4dvNV_1 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; count: Int32; var v: double)>(ProgramParameters4dvNV_adr);
    private ntv_ProgramParameters4dvNV_2 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; count: Int32; var v: Vec4d)>(ProgramParameters4dvNV_adr);
    private ntv_ProgramParameters4dvNV_3 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; count: Int32; v: IntPtr)>(ProgramParameters4dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4dvNV(target: glVertexAttribEnumNV; index: UInt32; count: Int32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_ProgramParameters4dvNV_1(target, index, count, v[0]) else
        ntv_ProgramParameters4dvNV_1(target, index, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4dvNV(target: glVertexAttribEnumNV; index: UInt32; count: Int32; var v: Vec4d) :=
      ntv_ProgramParameters4dvNV_2(target, index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4dvNV(target: glVertexAttribEnumNV; index: UInt32; count: Int32; var v: double) :=
      ntv_ProgramParameters4dvNV_1(target, index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4dvNV(target: glVertexAttribEnumNV; index: UInt32; count: Int32; v: IntPtr) :=
      ntv_ProgramParameters4dvNV_3(target, index, count, v);
    
    private ProgramParameters4fvNV_adr := GetProcAddress('glProgramParameters4fvNV');
    private ntv_ProgramParameters4fvNV_1 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; count: Int32; var v: single)>(ProgramParameters4fvNV_adr);
    private ntv_ProgramParameters4fvNV_2 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; count: Int32; var v: Vec4f)>(ProgramParameters4fvNV_adr);
    private ntv_ProgramParameters4fvNV_3 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; index: UInt32; count: Int32; v: IntPtr)>(ProgramParameters4fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4fvNV(target: glVertexAttribEnumNV; index: UInt32; count: Int32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_ProgramParameters4fvNV_1(target, index, count, v[0]) else
        ntv_ProgramParameters4fvNV_1(target, index, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4fvNV(target: glVertexAttribEnumNV; index: UInt32; count: Int32; var v: Vec4f) :=
      ntv_ProgramParameters4fvNV_2(target, index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4fvNV(target: glVertexAttribEnumNV; index: UInt32; count: Int32; var v: single) :=
      ntv_ProgramParameters4fvNV_1(target, index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4fvNV(target: glVertexAttribEnumNV; index: UInt32; count: Int32; v: IntPtr) :=
      ntv_ProgramParameters4fvNV_3(target, index, count, v);
    
    private RequestResidentProgramsNV_adr := GetProcAddress('glRequestResidentProgramsNV');
    private ntv_RequestResidentProgramsNV_1 := GetProcOrNil&<procedure(n: Int32; var programs: gl_program)>(RequestResidentProgramsNV_adr);
    private ntv_RequestResidentProgramsNV_2 := GetProcOrNil&<procedure(n: Int32; programs: IntPtr)>(RequestResidentProgramsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RequestResidentProgramsNV(n: Int32; programs: array of gl_program);
    type PGl_program = ^gl_program;
    begin
      if (programs<>nil) and (programs.Length<>0) then
        ntv_RequestResidentProgramsNV_1(n, programs[0]) else
        ntv_RequestResidentProgramsNV_1(n, PGl_program(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RequestResidentProgramsNV(n: Int32; var programs: gl_program) :=
      ntv_RequestResidentProgramsNV_1(n, programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RequestResidentProgramsNV(n: Int32; programs: IntPtr) :=
      ntv_RequestResidentProgramsNV_2(n, programs);
    
    private TrackMatrixNV_adr := GetProcAddress('glTrackMatrixNV');
    private ntv_TrackMatrixNV_1 := GetProcOrNil&<procedure(target: glVertexAttribEnumNV; address: UInt32; matrix: glVertexAttribEnumNV; transform: glVertexAttribEnumNV)>(TrackMatrixNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TrackMatrixNV(target: glVertexAttribEnumNV; address: UInt32; matrix: glVertexAttribEnumNV; transform: glVertexAttribEnumNV) :=
      ntv_TrackMatrixNV_1(target, address, matrix, transform);
    
    private VertexAttribPointerNV_adr := GetProcAddress('glVertexAttribPointerNV');
    private ntv_VertexAttribPointerNV_1 := GetProcOrNil&<procedure(index: UInt32; fsize: Int32; &type: glVertexAttribEnumNV; stride: Int32; pointer: IntPtr)>(VertexAttribPointerNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribPointerNV(index: UInt32; fsize: Int32; &type: glVertexAttribEnumNV; stride: Int32; pointer: IntPtr) :=
      ntv_VertexAttribPointerNV_1(index, fsize, &type, stride, pointer);
    
    private VertexAttrib1dNV_adr := GetProcAddress('glVertexAttrib1dNV');
    private ntv_VertexAttrib1dNV_1 := GetProcOrNil&<procedure(index: UInt32; x: double)>(VertexAttrib1dNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dNV(index: UInt32; x: double) :=
      ntv_VertexAttrib1dNV_1(index, x);
    
    private VertexAttrib1dvNV_adr := GetProcAddress('glVertexAttrib1dvNV');
    private ntv_VertexAttrib1dvNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttrib1dvNV_adr);
    private ntv_VertexAttrib1dvNV_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib1dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvNV(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib1dvNV_1(index, v[0]) else
        ntv_VertexAttrib1dvNV_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvNV(index: UInt32; var v: double) :=
      ntv_VertexAttrib1dvNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib1dvNV_2(index, v);
    
    private VertexAttrib1fNV_adr := GetProcAddress('glVertexAttrib1fNV');
    private ntv_VertexAttrib1fNV_1 := GetProcOrNil&<procedure(index: UInt32; x: single)>(VertexAttrib1fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fNV(index: UInt32; x: single) :=
      ntv_VertexAttrib1fNV_1(index, x);
    
    private VertexAttrib1fvNV_adr := GetProcAddress('glVertexAttrib1fvNV');
    private ntv_VertexAttrib1fvNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(VertexAttrib1fvNV_adr);
    private ntv_VertexAttrib1fvNV_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib1fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvNV(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib1fvNV_1(index, v[0]) else
        ntv_VertexAttrib1fvNV_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvNV(index: UInt32; var v: single) :=
      ntv_VertexAttrib1fvNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib1fvNV_2(index, v);
    
    private VertexAttrib1sNV_adr := GetProcAddress('glVertexAttrib1sNV');
    private ntv_VertexAttrib1sNV_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16)>(VertexAttrib1sNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sNV(index: UInt32; x: Int16) :=
      ntv_VertexAttrib1sNV_1(index, x);
    
    private VertexAttrib1svNV_adr := GetProcAddress('glVertexAttrib1svNV');
    private ntv_VertexAttrib1svNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib1svNV_adr);
    private ntv_VertexAttrib1svNV_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib1svNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svNV(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib1svNV_1(index, v[0]) else
        ntv_VertexAttrib1svNV_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svNV(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib1svNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib1svNV_2(index, v);
    
    private VertexAttrib2dNV_adr := GetProcAddress('glVertexAttrib2dNV');
    private ntv_VertexAttrib2dNV_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double)>(VertexAttrib2dNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dNV(index: UInt32; x: double; y: double) :=
      ntv_VertexAttrib2dNV_1(index, x, y);
    
    private VertexAttrib2dvNV_adr := GetProcAddress('glVertexAttrib2dvNV');
    private ntv_VertexAttrib2dvNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttrib2dvNV_adr);
    private ntv_VertexAttrib2dvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2d)>(VertexAttrib2dvNV_adr);
    private ntv_VertexAttrib2dvNV_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib2dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvNV(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib2dvNV_1(index, v[0]) else
        ntv_VertexAttrib2dvNV_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvNV(index: UInt32; var v: Vec2d) :=
      ntv_VertexAttrib2dvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvNV(index: UInt32; var v: double) :=
      ntv_VertexAttrib2dvNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib2dvNV_3(index, v);
    
    private VertexAttrib2fNV_adr := GetProcAddress('glVertexAttrib2fNV');
    private ntv_VertexAttrib2fNV_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single)>(VertexAttrib2fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fNV(index: UInt32; x: single; y: single) :=
      ntv_VertexAttrib2fNV_1(index, x, y);
    
    private VertexAttrib2fvNV_adr := GetProcAddress('glVertexAttrib2fvNV');
    private ntv_VertexAttrib2fvNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(VertexAttrib2fvNV_adr);
    private ntv_VertexAttrib2fvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2f)>(VertexAttrib2fvNV_adr);
    private ntv_VertexAttrib2fvNV_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib2fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvNV(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib2fvNV_1(index, v[0]) else
        ntv_VertexAttrib2fvNV_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvNV(index: UInt32; var v: Vec2f) :=
      ntv_VertexAttrib2fvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvNV(index: UInt32; var v: single) :=
      ntv_VertexAttrib2fvNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib2fvNV_3(index, v);
    
    private VertexAttrib2sNV_adr := GetProcAddress('glVertexAttrib2sNV');
    private ntv_VertexAttrib2sNV_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16)>(VertexAttrib2sNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sNV(index: UInt32; x: Int16; y: Int16) :=
      ntv_VertexAttrib2sNV_1(index, x, y);
    
    private VertexAttrib2svNV_adr := GetProcAddress('glVertexAttrib2svNV');
    private ntv_VertexAttrib2svNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib2svNV_adr);
    private ntv_VertexAttrib2svNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2s)>(VertexAttrib2svNV_adr);
    private ntv_VertexAttrib2svNV_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib2svNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svNV(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib2svNV_1(index, v[0]) else
        ntv_VertexAttrib2svNV_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svNV(index: UInt32; var v: Vec2s) :=
      ntv_VertexAttrib2svNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svNV(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib2svNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib2svNV_3(index, v);
    
    private VertexAttrib3dNV_adr := GetProcAddress('glVertexAttrib3dNV');
    private ntv_VertexAttrib3dNV_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double; z: double)>(VertexAttrib3dNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dNV(index: UInt32; x: double; y: double; z: double) :=
      ntv_VertexAttrib3dNV_1(index, x, y, z);
    
    private VertexAttrib3dvNV_adr := GetProcAddress('glVertexAttrib3dvNV');
    private ntv_VertexAttrib3dvNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttrib3dvNV_adr);
    private ntv_VertexAttrib3dvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3d)>(VertexAttrib3dvNV_adr);
    private ntv_VertexAttrib3dvNV_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib3dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvNV(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib3dvNV_1(index, v[0]) else
        ntv_VertexAttrib3dvNV_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvNV(index: UInt32; var v: Vec3d) :=
      ntv_VertexAttrib3dvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvNV(index: UInt32; var v: double) :=
      ntv_VertexAttrib3dvNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib3dvNV_3(index, v);
    
    private VertexAttrib3fNV_adr := GetProcAddress('glVertexAttrib3fNV');
    private ntv_VertexAttrib3fNV_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; z: single)>(VertexAttrib3fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fNV(index: UInt32; x: single; y: single; z: single) :=
      ntv_VertexAttrib3fNV_1(index, x, y, z);
    
    private VertexAttrib3fvNV_adr := GetProcAddress('glVertexAttrib3fvNV');
    private ntv_VertexAttrib3fvNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(VertexAttrib3fvNV_adr);
    private ntv_VertexAttrib3fvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3f)>(VertexAttrib3fvNV_adr);
    private ntv_VertexAttrib3fvNV_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib3fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvNV(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib3fvNV_1(index, v[0]) else
        ntv_VertexAttrib3fvNV_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvNV(index: UInt32; var v: Vec3f) :=
      ntv_VertexAttrib3fvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvNV(index: UInt32; var v: single) :=
      ntv_VertexAttrib3fvNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib3fvNV_3(index, v);
    
    private VertexAttrib3sNV_adr := GetProcAddress('glVertexAttrib3sNV');
    private ntv_VertexAttrib3sNV_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16)>(VertexAttrib3sNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sNV(index: UInt32; x: Int16; y: Int16; z: Int16) :=
      ntv_VertexAttrib3sNV_1(index, x, y, z);
    
    private VertexAttrib3svNV_adr := GetProcAddress('glVertexAttrib3svNV');
    private ntv_VertexAttrib3svNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib3svNV_adr);
    private ntv_VertexAttrib3svNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3s)>(VertexAttrib3svNV_adr);
    private ntv_VertexAttrib3svNV_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib3svNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svNV(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib3svNV_1(index, v[0]) else
        ntv_VertexAttrib3svNV_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svNV(index: UInt32; var v: Vec3s) :=
      ntv_VertexAttrib3svNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svNV(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib3svNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib3svNV_3(index, v);
    
    private VertexAttrib4dNV_adr := GetProcAddress('glVertexAttrib4dNV');
    private ntv_VertexAttrib4dNV_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double; z: double; w: double)>(VertexAttrib4dNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dNV(index: UInt32; x: double; y: double; z: double; w: double) :=
      ntv_VertexAttrib4dNV_1(index, x, y, z, w);
    
    private VertexAttrib4dvNV_adr := GetProcAddress('glVertexAttrib4dvNV');
    private ntv_VertexAttrib4dvNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttrib4dvNV_adr);
    private ntv_VertexAttrib4dvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4d)>(VertexAttrib4dvNV_adr);
    private ntv_VertexAttrib4dvNV_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvNV(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4dvNV_1(index, v[0]) else
        ntv_VertexAttrib4dvNV_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvNV(index: UInt32; var v: Vec4d) :=
      ntv_VertexAttrib4dvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvNV(index: UInt32; var v: double) :=
      ntv_VertexAttrib4dvNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4dvNV_3(index, v);
    
    private VertexAttrib4fNV_adr := GetProcAddress('glVertexAttrib4fNV');
    private ntv_VertexAttrib4fNV_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; z: single; w: single)>(VertexAttrib4fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fNV(index: UInt32; x: single; y: single; z: single; w: single) :=
      ntv_VertexAttrib4fNV_1(index, x, y, z, w);
    
    private VertexAttrib4fvNV_adr := GetProcAddress('glVertexAttrib4fvNV');
    private ntv_VertexAttrib4fvNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(VertexAttrib4fvNV_adr);
    private ntv_VertexAttrib4fvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4f)>(VertexAttrib4fvNV_adr);
    private ntv_VertexAttrib4fvNV_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvNV(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4fvNV_1(index, v[0]) else
        ntv_VertexAttrib4fvNV_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvNV(index: UInt32; var v: Vec4f) :=
      ntv_VertexAttrib4fvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvNV(index: UInt32; var v: single) :=
      ntv_VertexAttrib4fvNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4fvNV_3(index, v);
    
    private VertexAttrib4sNV_adr := GetProcAddress('glVertexAttrib4sNV');
    private ntv_VertexAttrib4sNV_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16)>(VertexAttrib4sNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sNV(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16) :=
      ntv_VertexAttrib4sNV_1(index, x, y, z, w);
    
    private VertexAttrib4svNV_adr := GetProcAddress('glVertexAttrib4svNV');
    private ntv_VertexAttrib4svNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib4svNV_adr);
    private ntv_VertexAttrib4svNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4s)>(VertexAttrib4svNV_adr);
    private ntv_VertexAttrib4svNV_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4svNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svNV(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4svNV_1(index, v[0]) else
        ntv_VertexAttrib4svNV_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svNV(index: UInt32; var v: Vec4s) :=
      ntv_VertexAttrib4svNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svNV(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib4svNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4svNV_3(index, v);
    
    private VertexAttrib4ubNV_adr := GetProcAddress('glVertexAttrib4ubNV');
    private ntv_VertexAttrib4ubNV_1 := GetProcOrNil&<procedure(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte)>(VertexAttrib4ubNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubNV(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte) :=
      ntv_VertexAttrib4ubNV_1(index, x, y, z, w);
    
    private VertexAttrib4ubvNV_adr := GetProcAddress('glVertexAttrib4ubvNV');
    private ntv_VertexAttrib4ubvNV_1 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(VertexAttrib4ubvNV_adr);
    private ntv_VertexAttrib4ubvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ub)>(VertexAttrib4ubvNV_adr);
    private ntv_VertexAttrib4ubvNV_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4ubvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvNV(index: UInt32; v: array of Byte);
    type PByte = ^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4ubvNV_1(index, v[0]) else
        ntv_VertexAttrib4ubvNV_1(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvNV(index: UInt32; var v: Vec4ub) :=
      ntv_VertexAttrib4ubvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvNV(index: UInt32; var v: Byte) :=
      ntv_VertexAttrib4ubvNV_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvNV(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4ubvNV_3(index, v);
    
    private VertexAttribs1dvNV_adr := GetProcAddress('glVertexAttribs1dvNV');
    private ntv_VertexAttribs1dvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: double)>(VertexAttribs1dvNV_adr);
    private ntv_VertexAttribs1dvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(VertexAttribs1dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1dvNV(index: UInt32; count: Int32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribs1dvNV_1(index, count, v[0]) else
        ntv_VertexAttribs1dvNV_1(index, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1dvNV(index: UInt32; count: Int32; var v: double) :=
      ntv_VertexAttribs1dvNV_1(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1dvNV(index: UInt32; count: Int32; v: IntPtr) :=
      ntv_VertexAttribs1dvNV_2(index, count, v);
    
    private VertexAttribs1fvNV_adr := GetProcAddress('glVertexAttribs1fvNV');
    private ntv_VertexAttribs1fvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: single)>(VertexAttribs1fvNV_adr);
    private ntv_VertexAttribs1fvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(VertexAttribs1fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1fvNV(index: UInt32; count: Int32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribs1fvNV_1(index, count, v[0]) else
        ntv_VertexAttribs1fvNV_1(index, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1fvNV(index: UInt32; count: Int32; var v: single) :=
      ntv_VertexAttribs1fvNV_1(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1fvNV(index: UInt32; count: Int32; v: IntPtr) :=
      ntv_VertexAttribs1fvNV_2(index, count, v);
    
    private VertexAttribs1svNV_adr := GetProcAddress('glVertexAttribs1svNV');
    private ntv_VertexAttribs1svNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Int16)>(VertexAttribs1svNV_adr);
    private ntv_VertexAttribs1svNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(VertexAttribs1svNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1svNV(index: UInt32; count: Int32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribs1svNV_1(index, count, v[0]) else
        ntv_VertexAttribs1svNV_1(index, count, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1svNV(index: UInt32; count: Int32; var v: Int16) :=
      ntv_VertexAttribs1svNV_1(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1svNV(index: UInt32; count: Int32; v: IntPtr) :=
      ntv_VertexAttribs1svNV_2(index, count, v);
    
    private VertexAttribs2dvNV_adr := GetProcAddress('glVertexAttribs2dvNV');
    private ntv_VertexAttribs2dvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: double)>(VertexAttribs2dvNV_adr);
    private ntv_VertexAttribs2dvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Vec2d)>(VertexAttribs2dvNV_adr);
    private ntv_VertexAttribs2dvNV_3 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(VertexAttribs2dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2dvNV(index: UInt32; count: Int32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribs2dvNV_1(index, count, v[0]) else
        ntv_VertexAttribs2dvNV_1(index, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2dvNV(index: UInt32; count: Int32; var v: Vec2d) :=
      ntv_VertexAttribs2dvNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2dvNV(index: UInt32; count: Int32; var v: double) :=
      ntv_VertexAttribs2dvNV_1(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2dvNV(index: UInt32; count: Int32; v: IntPtr) :=
      ntv_VertexAttribs2dvNV_3(index, count, v);
    
    private VertexAttribs2fvNV_adr := GetProcAddress('glVertexAttribs2fvNV');
    private ntv_VertexAttribs2fvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: single)>(VertexAttribs2fvNV_adr);
    private ntv_VertexAttribs2fvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Vec2f)>(VertexAttribs2fvNV_adr);
    private ntv_VertexAttribs2fvNV_3 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(VertexAttribs2fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2fvNV(index: UInt32; count: Int32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribs2fvNV_1(index, count, v[0]) else
        ntv_VertexAttribs2fvNV_1(index, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2fvNV(index: UInt32; count: Int32; var v: Vec2f) :=
      ntv_VertexAttribs2fvNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2fvNV(index: UInt32; count: Int32; var v: single) :=
      ntv_VertexAttribs2fvNV_1(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2fvNV(index: UInt32; count: Int32; v: IntPtr) :=
      ntv_VertexAttribs2fvNV_3(index, count, v);
    
    private VertexAttribs2svNV_adr := GetProcAddress('glVertexAttribs2svNV');
    private ntv_VertexAttribs2svNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Int16)>(VertexAttribs2svNV_adr);
    private ntv_VertexAttribs2svNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Vec2s)>(VertexAttribs2svNV_adr);
    private ntv_VertexAttribs2svNV_3 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(VertexAttribs2svNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2svNV(index: UInt32; count: Int32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribs2svNV_1(index, count, v[0]) else
        ntv_VertexAttribs2svNV_1(index, count, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2svNV(index: UInt32; count: Int32; var v: Vec2s) :=
      ntv_VertexAttribs2svNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2svNV(index: UInt32; count: Int32; var v: Int16) :=
      ntv_VertexAttribs2svNV_1(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2svNV(index: UInt32; count: Int32; v: IntPtr) :=
      ntv_VertexAttribs2svNV_3(index, count, v);
    
    private VertexAttribs3dvNV_adr := GetProcAddress('glVertexAttribs3dvNV');
    private ntv_VertexAttribs3dvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: double)>(VertexAttribs3dvNV_adr);
    private ntv_VertexAttribs3dvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Vec3d)>(VertexAttribs3dvNV_adr);
    private ntv_VertexAttribs3dvNV_3 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(VertexAttribs3dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3dvNV(index: UInt32; count: Int32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribs3dvNV_1(index, count, v[0]) else
        ntv_VertexAttribs3dvNV_1(index, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3dvNV(index: UInt32; count: Int32; var v: Vec3d) :=
      ntv_VertexAttribs3dvNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3dvNV(index: UInt32; count: Int32; var v: double) :=
      ntv_VertexAttribs3dvNV_1(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3dvNV(index: UInt32; count: Int32; v: IntPtr) :=
      ntv_VertexAttribs3dvNV_3(index, count, v);
    
    private VertexAttribs3fvNV_adr := GetProcAddress('glVertexAttribs3fvNV');
    private ntv_VertexAttribs3fvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: single)>(VertexAttribs3fvNV_adr);
    private ntv_VertexAttribs3fvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Vec3f)>(VertexAttribs3fvNV_adr);
    private ntv_VertexAttribs3fvNV_3 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(VertexAttribs3fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3fvNV(index: UInt32; count: Int32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribs3fvNV_1(index, count, v[0]) else
        ntv_VertexAttribs3fvNV_1(index, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3fvNV(index: UInt32; count: Int32; var v: Vec3f) :=
      ntv_VertexAttribs3fvNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3fvNV(index: UInt32; count: Int32; var v: single) :=
      ntv_VertexAttribs3fvNV_1(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3fvNV(index: UInt32; count: Int32; v: IntPtr) :=
      ntv_VertexAttribs3fvNV_3(index, count, v);
    
    private VertexAttribs3svNV_adr := GetProcAddress('glVertexAttribs3svNV');
    private ntv_VertexAttribs3svNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Int16)>(VertexAttribs3svNV_adr);
    private ntv_VertexAttribs3svNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Vec3s)>(VertexAttribs3svNV_adr);
    private ntv_VertexAttribs3svNV_3 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(VertexAttribs3svNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3svNV(index: UInt32; count: Int32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribs3svNV_1(index, count, v[0]) else
        ntv_VertexAttribs3svNV_1(index, count, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3svNV(index: UInt32; count: Int32; var v: Vec3s) :=
      ntv_VertexAttribs3svNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3svNV(index: UInt32; count: Int32; var v: Int16) :=
      ntv_VertexAttribs3svNV_1(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3svNV(index: UInt32; count: Int32; v: IntPtr) :=
      ntv_VertexAttribs3svNV_3(index, count, v);
    
    private VertexAttribs4dvNV_adr := GetProcAddress('glVertexAttribs4dvNV');
    private ntv_VertexAttribs4dvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: double)>(VertexAttribs4dvNV_adr);
    private ntv_VertexAttribs4dvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Vec4d)>(VertexAttribs4dvNV_adr);
    private ntv_VertexAttribs4dvNV_3 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(VertexAttribs4dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4dvNV(index: UInt32; count: Int32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribs4dvNV_1(index, count, v[0]) else
        ntv_VertexAttribs4dvNV_1(index, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4dvNV(index: UInt32; count: Int32; var v: Vec4d) :=
      ntv_VertexAttribs4dvNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4dvNV(index: UInt32; count: Int32; var v: double) :=
      ntv_VertexAttribs4dvNV_1(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4dvNV(index: UInt32; count: Int32; v: IntPtr) :=
      ntv_VertexAttribs4dvNV_3(index, count, v);
    
    private VertexAttribs4fvNV_adr := GetProcAddress('glVertexAttribs4fvNV');
    private ntv_VertexAttribs4fvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: single)>(VertexAttribs4fvNV_adr);
    private ntv_VertexAttribs4fvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Vec4f)>(VertexAttribs4fvNV_adr);
    private ntv_VertexAttribs4fvNV_3 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(VertexAttribs4fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4fvNV(index: UInt32; count: Int32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribs4fvNV_1(index, count, v[0]) else
        ntv_VertexAttribs4fvNV_1(index, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4fvNV(index: UInt32; count: Int32; var v: Vec4f) :=
      ntv_VertexAttribs4fvNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4fvNV(index: UInt32; count: Int32; var v: single) :=
      ntv_VertexAttribs4fvNV_1(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4fvNV(index: UInt32; count: Int32; v: IntPtr) :=
      ntv_VertexAttribs4fvNV_3(index, count, v);
    
    private VertexAttribs4svNV_adr := GetProcAddress('glVertexAttribs4svNV');
    private ntv_VertexAttribs4svNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Int16)>(VertexAttribs4svNV_adr);
    private ntv_VertexAttribs4svNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Vec4s)>(VertexAttribs4svNV_adr);
    private ntv_VertexAttribs4svNV_3 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(VertexAttribs4svNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4svNV(index: UInt32; count: Int32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribs4svNV_1(index, count, v[0]) else
        ntv_VertexAttribs4svNV_1(index, count, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4svNV(index: UInt32; count: Int32; var v: Vec4s) :=
      ntv_VertexAttribs4svNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4svNV(index: UInt32; count: Int32; var v: Int16) :=
      ntv_VertexAttribs4svNV_1(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4svNV(index: UInt32; count: Int32; v: IntPtr) :=
      ntv_VertexAttribs4svNV_3(index, count, v);
    
    private VertexAttribs4ubvNV_adr := GetProcAddress('glVertexAttribs4ubvNV');
    private ntv_VertexAttribs4ubvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Byte)>(VertexAttribs4ubvNV_adr);
    private ntv_VertexAttribs4ubvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Vec4ub)>(VertexAttribs4ubvNV_adr);
    private ntv_VertexAttribs4ubvNV_3 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(VertexAttribs4ubvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4ubvNV(index: UInt32; count: Int32; v: array of Byte);
    type PByte = ^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribs4ubvNV_1(index, count, v[0]) else
        ntv_VertexAttribs4ubvNV_1(index, count, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4ubvNV(index: UInt32; count: Int32; var v: Vec4ub) :=
      ntv_VertexAttribs4ubvNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4ubvNV(index: UInt32; count: Int32; var v: Byte) :=
      ntv_VertexAttribs4ubvNV_1(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4ubvNV(index: UInt32; count: Int32; v: IntPtr) :=
      ntv_VertexAttribs4ubvNV_3(index, count, v);
    
  end;
  
  ///
  glVertexProgram11NV = static class
    public const _ExtStr = 'GL_NV_vertex_program1_1';
  end;
  
  ///
  glVertexProgram2NV = static class
    public const _ExtStr = 'GL_NV_vertex_program2';
  end;
  
  ///
  glVertexProgram2OptionNV = static class
    public const _ExtStr = 'GL_NV_vertex_program2_option';
  end;
  
  ///
  glVertexProgram3NV = static class
    public const _ExtStr = 'GL_NV_vertex_program3';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexProgram4NV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_vertex_program4';
    
    private VertexAttribI1iEXT_adr := GetProcAddress('glVertexAttribI1iEXT');
    private ntv_VertexAttribI1iEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32)>(VertexAttribI1iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1iEXT(index: UInt32; x: Int32) :=
      ntv_VertexAttribI1iEXT_1(index, x);
    
    private VertexAttribI2iEXT_adr := GetProcAddress('glVertexAttribI2iEXT');
    private ntv_VertexAttribI2iEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32)>(VertexAttribI2iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2iEXT(index: UInt32; x: Int32; y: Int32) :=
      ntv_VertexAttribI2iEXT_1(index, x, y);
    
    private VertexAttribI3iEXT_adr := GetProcAddress('glVertexAttribI3iEXT');
    private ntv_VertexAttribI3iEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32; z: Int32)>(VertexAttribI3iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3iEXT(index: UInt32; x: Int32; y: Int32; z: Int32) :=
      ntv_VertexAttribI3iEXT_1(index, x, y, z);
    
    private VertexAttribI4iEXT_adr := GetProcAddress('glVertexAttribI4iEXT');
    private ntv_VertexAttribI4iEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>(VertexAttribI4iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4iEXT(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) :=
      ntv_VertexAttribI4iEXT_1(index, x, y, z, w);
    
    private VertexAttribI1uiEXT_adr := GetProcAddress('glVertexAttribI1uiEXT');
    private ntv_VertexAttribI1uiEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32)>(VertexAttribI1uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uiEXT(index: UInt32; x: UInt32) :=
      ntv_VertexAttribI1uiEXT_1(index, x);
    
    private VertexAttribI2uiEXT_adr := GetProcAddress('glVertexAttribI2uiEXT');
    private ntv_VertexAttribI2uiEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32)>(VertexAttribI2uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uiEXT(index: UInt32; x: UInt32; y: UInt32) :=
      ntv_VertexAttribI2uiEXT_1(index, x, y);
    
    private VertexAttribI3uiEXT_adr := GetProcAddress('glVertexAttribI3uiEXT');
    private ntv_VertexAttribI3uiEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32; z: UInt32)>(VertexAttribI3uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uiEXT(index: UInt32; x: UInt32; y: UInt32; z: UInt32) :=
      ntv_VertexAttribI3uiEXT_1(index, x, y, z);
    
    private VertexAttribI4uiEXT_adr := GetProcAddress('glVertexAttribI4uiEXT');
    private ntv_VertexAttribI4uiEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>(VertexAttribI4uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uiEXT(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) :=
      ntv_VertexAttribI4uiEXT_1(index, x, y, z, w);
    
    private VertexAttribI1ivEXT_adr := GetProcAddress('glVertexAttribI1ivEXT');
    private ntv_VertexAttribI1ivEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttribI1ivEXT_adr);
    private ntv_VertexAttribI1ivEXT_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI1ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ivEXT(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI1ivEXT_1(index, v[0]) else
        ntv_VertexAttribI1ivEXT_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ivEXT(index: UInt32; var v: Int32) :=
      ntv_VertexAttribI1ivEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ivEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI1ivEXT_2(index, v);
    
    private VertexAttribI2ivEXT_adr := GetProcAddress('glVertexAttribI2ivEXT');
    private ntv_VertexAttribI2ivEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttribI2ivEXT_adr);
    private ntv_VertexAttribI2ivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2i)>(VertexAttribI2ivEXT_adr);
    private ntv_VertexAttribI2ivEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI2ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ivEXT(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI2ivEXT_1(index, v[0]) else
        ntv_VertexAttribI2ivEXT_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ivEXT(index: UInt32; var v: Vec2i) :=
      ntv_VertexAttribI2ivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ivEXT(index: UInt32; var v: Int32) :=
      ntv_VertexAttribI2ivEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ivEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI2ivEXT_3(index, v);
    
    private VertexAttribI3ivEXT_adr := GetProcAddress('glVertexAttribI3ivEXT');
    private ntv_VertexAttribI3ivEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttribI3ivEXT_adr);
    private ntv_VertexAttribI3ivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3i)>(VertexAttribI3ivEXT_adr);
    private ntv_VertexAttribI3ivEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI3ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ivEXT(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI3ivEXT_1(index, v[0]) else
        ntv_VertexAttribI3ivEXT_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ivEXT(index: UInt32; var v: Vec3i) :=
      ntv_VertexAttribI3ivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ivEXT(index: UInt32; var v: Int32) :=
      ntv_VertexAttribI3ivEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ivEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI3ivEXT_3(index, v);
    
    private VertexAttribI4ivEXT_adr := GetProcAddress('glVertexAttribI4ivEXT');
    private ntv_VertexAttribI4ivEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttribI4ivEXT_adr);
    private ntv_VertexAttribI4ivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4i)>(VertexAttribI4ivEXT_adr);
    private ntv_VertexAttribI4ivEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ivEXT(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4ivEXT_1(index, v[0]) else
        ntv_VertexAttribI4ivEXT_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ivEXT(index: UInt32; var v: Vec4i) :=
      ntv_VertexAttribI4ivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ivEXT(index: UInt32; var v: Int32) :=
      ntv_VertexAttribI4ivEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ivEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4ivEXT_3(index, v);
    
    private VertexAttribI1uivEXT_adr := GetProcAddress('glVertexAttribI1uivEXT');
    private ntv_VertexAttribI1uivEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttribI1uivEXT_adr);
    private ntv_VertexAttribI1uivEXT_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI1uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uivEXT(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI1uivEXT_1(index, v[0]) else
        ntv_VertexAttribI1uivEXT_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uivEXT(index: UInt32; var v: UInt32) :=
      ntv_VertexAttribI1uivEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uivEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI1uivEXT_2(index, v);
    
    private VertexAttribI2uivEXT_adr := GetProcAddress('glVertexAttribI2uivEXT');
    private ntv_VertexAttribI2uivEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttribI2uivEXT_adr);
    private ntv_VertexAttribI2uivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2ui)>(VertexAttribI2uivEXT_adr);
    private ntv_VertexAttribI2uivEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI2uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uivEXT(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI2uivEXT_1(index, v[0]) else
        ntv_VertexAttribI2uivEXT_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uivEXT(index: UInt32; var v: Vec2ui) :=
      ntv_VertexAttribI2uivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uivEXT(index: UInt32; var v: UInt32) :=
      ntv_VertexAttribI2uivEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uivEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI2uivEXT_3(index, v);
    
    private VertexAttribI3uivEXT_adr := GetProcAddress('glVertexAttribI3uivEXT');
    private ntv_VertexAttribI3uivEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttribI3uivEXT_adr);
    private ntv_VertexAttribI3uivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3ui)>(VertexAttribI3uivEXT_adr);
    private ntv_VertexAttribI3uivEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI3uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uivEXT(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI3uivEXT_1(index, v[0]) else
        ntv_VertexAttribI3uivEXT_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uivEXT(index: UInt32; var v: Vec3ui) :=
      ntv_VertexAttribI3uivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uivEXT(index: UInt32; var v: UInt32) :=
      ntv_VertexAttribI3uivEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uivEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI3uivEXT_3(index, v);
    
    private VertexAttribI4uivEXT_adr := GetProcAddress('glVertexAttribI4uivEXT');
    private ntv_VertexAttribI4uivEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttribI4uivEXT_adr);
    private ntv_VertexAttribI4uivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ui)>(VertexAttribI4uivEXT_adr);
    private ntv_VertexAttribI4uivEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uivEXT(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4uivEXT_1(index, v[0]) else
        ntv_VertexAttribI4uivEXT_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uivEXT(index: UInt32; var v: Vec4ui) :=
      ntv_VertexAttribI4uivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uivEXT(index: UInt32; var v: UInt32) :=
      ntv_VertexAttribI4uivEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uivEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4uivEXT_3(index, v);
    
    private VertexAttribI4bvEXT_adr := GetProcAddress('glVertexAttribI4bvEXT');
    private ntv_VertexAttribI4bvEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(VertexAttribI4bvEXT_adr);
    private ntv_VertexAttribI4bvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4b)>(VertexAttribI4bvEXT_adr);
    private ntv_VertexAttribI4bvEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4bvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bvEXT(index: UInt32; v: array of SByte);
    type PSByte = ^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4bvEXT_1(index, v[0]) else
        ntv_VertexAttribI4bvEXT_1(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bvEXT(index: UInt32; var v: Vec4b) :=
      ntv_VertexAttribI4bvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bvEXT(index: UInt32; var v: SByte) :=
      ntv_VertexAttribI4bvEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bvEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4bvEXT_3(index, v);
    
    private VertexAttribI4svEXT_adr := GetProcAddress('glVertexAttribI4svEXT');
    private ntv_VertexAttribI4svEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttribI4svEXT_adr);
    private ntv_VertexAttribI4svEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4s)>(VertexAttribI4svEXT_adr);
    private ntv_VertexAttribI4svEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4svEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4svEXT(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4svEXT_1(index, v[0]) else
        ntv_VertexAttribI4svEXT_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4svEXT(index: UInt32; var v: Vec4s) :=
      ntv_VertexAttribI4svEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4svEXT(index: UInt32; var v: Int16) :=
      ntv_VertexAttribI4svEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4svEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4svEXT_3(index, v);
    
    private VertexAttribI4ubvEXT_adr := GetProcAddress('glVertexAttribI4ubvEXT');
    private ntv_VertexAttribI4ubvEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(VertexAttribI4ubvEXT_adr);
    private ntv_VertexAttribI4ubvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ub)>(VertexAttribI4ubvEXT_adr);
    private ntv_VertexAttribI4ubvEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4ubvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubvEXT(index: UInt32; v: array of Byte);
    type PByte = ^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4ubvEXT_1(index, v[0]) else
        ntv_VertexAttribI4ubvEXT_1(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubvEXT(index: UInt32; var v: Vec4ub) :=
      ntv_VertexAttribI4ubvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubvEXT(index: UInt32; var v: Byte) :=
      ntv_VertexAttribI4ubvEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubvEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4ubvEXT_3(index, v);
    
    private VertexAttribI4usvEXT_adr := GetProcAddress('glVertexAttribI4usvEXT');
    private ntv_VertexAttribI4usvEXT_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(VertexAttribI4usvEXT_adr);
    private ntv_VertexAttribI4usvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4us)>(VertexAttribI4usvEXT_adr);
    private ntv_VertexAttribI4usvEXT_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4usvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usvEXT(index: UInt32; v: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4usvEXT_1(index, v[0]) else
        ntv_VertexAttribI4usvEXT_1(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usvEXT(index: UInt32; var v: Vec4us) :=
      ntv_VertexAttribI4usvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usvEXT(index: UInt32; var v: UInt16) :=
      ntv_VertexAttribI4usvEXT_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usvEXT(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4usvEXT_3(index, v);
    
    private VertexAttribIPointerEXT_adr := GetProcAddress('glVertexAttribIPointerEXT');
    private ntv_VertexAttribIPointerEXT_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: glVertexAttribIType; stride: Int32; pointer: IntPtr)>(VertexAttribIPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIPointerEXT(index: UInt32; size: Int32; &type: glVertexAttribIType; stride: Int32; pointer: IntPtr) :=
      ntv_VertexAttribIPointerEXT_1(index, size, &type, stride, pointer);
    
    private GetVertexAttribIivEXT_adr := GetProcAddress('glGetVertexAttribIivEXT');
    private ntv_GetVertexAttribIivEXT_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; var &params: Int32)>(GetVertexAttribIivEXT_adr);
    private ntv_GetVertexAttribIivEXT_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr)>(GetVertexAttribIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIivEXT(index: UInt32; pname: glVertexAttribEnum; var &params: Int32) :=
      ntv_GetVertexAttribIivEXT_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIivEXT(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr) :=
      ntv_GetVertexAttribIivEXT_2(index, pname, &params);
    
    private GetVertexAttribIuivEXT_adr := GetProcAddress('glGetVertexAttribIuivEXT');
    private ntv_GetVertexAttribIuivEXT_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; var &params: UInt32)>(GetVertexAttribIuivEXT_adr);
    private ntv_GetVertexAttribIuivEXT_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr)>(GetVertexAttribIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuivEXT(index: UInt32; pname: glVertexAttribEnum; var &params: UInt32) :=
      ntv_GetVertexAttribIuivEXT_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuivEXT(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr) :=
      ntv_GetVertexAttribIuivEXT_2(index, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVideoCaptureNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_video_capture';
    
    private BeginVideoCaptureNV_adr := GetProcAddress('glBeginVideoCaptureNV');
    private ntv_BeginVideoCaptureNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32)>(BeginVideoCaptureNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginVideoCaptureNV(video_capture_slot: UInt32) :=
      ntv_BeginVideoCaptureNV_1(video_capture_slot);
    
    private BindVideoCaptureStreamBufferNV_adr := GetProcAddress('glBindVideoCaptureStreamBufferNV');
    private ntv_BindVideoCaptureStreamBufferNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; offset: IntPtr)>(BindVideoCaptureStreamBufferNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVideoCaptureStreamBufferNV(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; offset: IntPtr) :=
      ntv_BindVideoCaptureStreamBufferNV_1(video_capture_slot, stream, frame_region, offset);
    
    private BindVideoCaptureStreamTextureNV_adr := GetProcAddress('glBindVideoCaptureStreamTextureNV');
    private ntv_BindVideoCaptureStreamTextureNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; target: DummyEnum; texture: gl_texture)>(BindVideoCaptureStreamTextureNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVideoCaptureStreamTextureNV(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; target: DummyEnum; texture: gl_texture) :=
      ntv_BindVideoCaptureStreamTextureNV_1(video_capture_slot, stream, frame_region, target, texture);
    
    private EndVideoCaptureNV_adr := GetProcAddress('glEndVideoCaptureNV');
    private ntv_EndVideoCaptureNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32)>(EndVideoCaptureNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndVideoCaptureNV(video_capture_slot: UInt32) :=
      ntv_EndVideoCaptureNV_1(video_capture_slot);
    
    private GetVideoCaptureivNV_adr := GetProcAddress('glGetVideoCaptureivNV');
    private ntv_GetVideoCaptureivNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; pname: DummyEnum; var &params: Int32)>(GetVideoCaptureivNV_adr);
    private ntv_GetVideoCaptureivNV_2 := GetProcOrNil&<procedure(video_capture_slot: UInt32; pname: DummyEnum; &params: IntPtr)>(GetVideoCaptureivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureivNV(video_capture_slot: UInt32; pname: DummyEnum; var &params: Int32) :=
      ntv_GetVideoCaptureivNV_1(video_capture_slot, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureivNV(video_capture_slot: UInt32; pname: DummyEnum; &params: IntPtr) :=
      ntv_GetVideoCaptureivNV_2(video_capture_slot, pname, &params);
    
    private GetVideoCaptureStreamivNV_adr := GetProcAddress('glGetVideoCaptureStreamivNV');
    private ntv_GetVideoCaptureStreamivNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: Int32)>(GetVideoCaptureStreamivNV_adr);
    private ntv_GetVideoCaptureStreamivNV_2 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr)>(GetVideoCaptureStreamivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: Int32) :=
      ntv_GetVideoCaptureStreamivNV_1(video_capture_slot, stream, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr) :=
      ntv_GetVideoCaptureStreamivNV_2(video_capture_slot, stream, pname, &params);
    
    private GetVideoCaptureStreamfvNV_adr := GetProcAddress('glGetVideoCaptureStreamfvNV');
    private ntv_GetVideoCaptureStreamfvNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: single)>(GetVideoCaptureStreamfvNV_adr);
    private ntv_GetVideoCaptureStreamfvNV_2 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr)>(GetVideoCaptureStreamfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: single) :=
      ntv_GetVideoCaptureStreamfvNV_1(video_capture_slot, stream, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr) :=
      ntv_GetVideoCaptureStreamfvNV_2(video_capture_slot, stream, pname, &params);
    
    private GetVideoCaptureStreamdvNV_adr := GetProcAddress('glGetVideoCaptureStreamdvNV');
    private ntv_GetVideoCaptureStreamdvNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: double)>(GetVideoCaptureStreamdvNV_adr);
    private ntv_GetVideoCaptureStreamdvNV_2 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr)>(GetVideoCaptureStreamdvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: double) :=
      ntv_GetVideoCaptureStreamdvNV_1(video_capture_slot, stream, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr) :=
      ntv_GetVideoCaptureStreamdvNV_2(video_capture_slot, stream, pname, &params);
    
    private VideoCaptureNV_adr := GetProcAddress('glVideoCaptureNV');
    private ntv_VideoCaptureNV_1 := GetProcOrNil&<function(video_capture_slot: UInt32; var sequence_num: UInt32; var capture_time: UInt64): DummyEnum>(VideoCaptureNV_adr);
    private ntv_VideoCaptureNV_2 := GetProcOrNil&<function(video_capture_slot: UInt32; var sequence_num: UInt32; capture_time: IntPtr): DummyEnum>(VideoCaptureNV_adr);
    private ntv_VideoCaptureNV_3 := GetProcOrNil&<function(video_capture_slot: UInt32; sequence_num: IntPtr; var capture_time: UInt64): DummyEnum>(VideoCaptureNV_adr);
    private ntv_VideoCaptureNV_4 := GetProcOrNil&<function(video_capture_slot: UInt32; sequence_num: IntPtr; capture_time: IntPtr): DummyEnum>(VideoCaptureNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: array of UInt32; capture_time: array of UInt64): DummyEnum;
    type PUInt32 = ^UInt32;
    type PUInt64 = ^UInt64;
    begin
      Result := if (capture_time<>nil) and (capture_time.Length<>0) then
        if (sequence_num<>nil) and (sequence_num.Length<>0) then
          ntv_VideoCaptureNV_1(video_capture_slot, sequence_num[0], capture_time[0]) else
          ntv_VideoCaptureNV_1(video_capture_slot, PUInt32(nil)^, capture_time[0]) else
        if (sequence_num<>nil) and (sequence_num.Length<>0) then
          ntv_VideoCaptureNV_1(video_capture_slot, sequence_num[0], PUInt64(nil)^) else
          ntv_VideoCaptureNV_1(video_capture_slot, PUInt32(nil)^, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; var sequence_num: UInt32; var capture_time: UInt64): DummyEnum :=
      ntv_VideoCaptureNV_1(video_capture_slot, sequence_num, capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; var sequence_num: UInt32; capture_time: IntPtr): DummyEnum :=
      ntv_VideoCaptureNV_2(video_capture_slot, sequence_num, capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: IntPtr; var capture_time: UInt64): DummyEnum :=
      ntv_VideoCaptureNV_3(video_capture_slot, sequence_num, capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: IntPtr; capture_time: IntPtr): DummyEnum :=
      ntv_VideoCaptureNV_4(video_capture_slot, sequence_num, capture_time);
    
    private VideoCaptureStreamParameterivNV_adr := GetProcAddress('glVideoCaptureStreamParameterivNV');
    private ntv_VideoCaptureStreamParameterivNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: Int32)>(VideoCaptureStreamParameterivNV_adr);
    private ntv_VideoCaptureStreamParameterivNV_2 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr)>(VideoCaptureStreamParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_VideoCaptureStreamParameterivNV_1(video_capture_slot, stream, pname, &params[0]) else
        ntv_VideoCaptureStreamParameterivNV_1(video_capture_slot, stream, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: Int32) :=
      ntv_VideoCaptureStreamParameterivNV_1(video_capture_slot, stream, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr) :=
      ntv_VideoCaptureStreamParameterivNV_2(video_capture_slot, stream, pname, &params);
    
    private VideoCaptureStreamParameterfvNV_adr := GetProcAddress('glVideoCaptureStreamParameterfvNV');
    private ntv_VideoCaptureStreamParameterfvNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: single)>(VideoCaptureStreamParameterfvNV_adr);
    private ntv_VideoCaptureStreamParameterfvNV_2 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr)>(VideoCaptureStreamParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_VideoCaptureStreamParameterfvNV_1(video_capture_slot, stream, pname, &params[0]) else
        ntv_VideoCaptureStreamParameterfvNV_1(video_capture_slot, stream, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: single) :=
      ntv_VideoCaptureStreamParameterfvNV_1(video_capture_slot, stream, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr) :=
      ntv_VideoCaptureStreamParameterfvNV_2(video_capture_slot, stream, pname, &params);
    
    private VideoCaptureStreamParameterdvNV_adr := GetProcAddress('glVideoCaptureStreamParameterdvNV');
    private ntv_VideoCaptureStreamParameterdvNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: double)>(VideoCaptureStreamParameterdvNV_adr);
    private ntv_VideoCaptureStreamParameterdvNV_2 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr)>(VideoCaptureStreamParameterdvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of double);
    type PDouble = ^double;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_VideoCaptureStreamParameterdvNV_1(video_capture_slot, stream, pname, &params[0]) else
        ntv_VideoCaptureStreamParameterdvNV_1(video_capture_slot, stream, pname, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: double) :=
      ntv_VideoCaptureStreamParameterdvNV_1(video_capture_slot, stream, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr) :=
      ntv_VideoCaptureStreamParameterdvNV_2(video_capture_slot, stream, pname, &params);
    
  end;
  
  ///
  glViewportArray2NV = static class
    public const _ExtStr = 'GL_NV_viewport_array2';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glViewportSwizzleNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NV_viewport_swizzle';
    
    private ViewportSwizzleNV_adr := GetProcAddress('glViewportSwizzleNV');
    private ntv_ViewportSwizzleNV_1 := GetProcOrNil&<procedure(index: UInt32; swizzlex: DummyEnum; swizzley: DummyEnum; swizzlez: DummyEnum; swizzlew: DummyEnum)>(ViewportSwizzleNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportSwizzleNV(index: UInt32; swizzlex: DummyEnum; swizzley: DummyEnum; swizzlez: DummyEnum; swizzlew: DummyEnum) :=
      ntv_ViewportSwizzleNV_1(index, swizzlex, swizzley, swizzlez, swizzlew);
    
  end;
  
  ///
  glBlendEquationAdvancedMultiDrawBuffersNVX = static class
    public const _ExtStr = 'GL_NVX_blend_equation_advanced_multi_draw_buffers';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glConditionalRenderNVX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NVX_conditional_render';
    
    private BeginConditionalRenderNVX_adr := GetProcAddress('glBeginConditionalRenderNVX');
    private ntv_BeginConditionalRenderNVX_1 := GetProcOrNil&<procedure(id: UInt32)>(BeginConditionalRenderNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginConditionalRenderNVX(id: UInt32) :=
      ntv_BeginConditionalRenderNVX_1(id);
    
    private EndConditionalRenderNVX_adr := GetProcAddress('glEndConditionalRenderNVX');
    private ntv_EndConditionalRenderNVX_1 := GetProcOrNil&<procedure>(EndConditionalRenderNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndConditionalRenderNVX :=
      ntv_EndConditionalRenderNVX_1;
    
  end;
  
  ///
  glGpuMemoryInfoNVX = static class
    public const _ExtStr = 'GL_NVX_gpu_memory_info';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glGpuMulticast2NVX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NVX_gpu_multicast2';
    
    private UploadGpuMaskNVX_adr := GetProcAddress('glUploadGpuMaskNVX');
    private ntv_UploadGpuMaskNVX_1 := GetProcOrNil&<procedure(mask: DummyFlags)>(UploadGpuMaskNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UploadGpuMaskNVX(mask: DummyFlags) :=
      ntv_UploadGpuMaskNVX_1(mask);
    
    private MulticastViewportArrayvNVX_adr := GetProcAddress('glMulticastViewportArrayvNVX');
    private ntv_MulticastViewportArrayvNVX_1 := GetProcOrNil&<procedure(gpu: UInt32; first: UInt32; count: Int32; var v: single)>(MulticastViewportArrayvNVX_adr);
    private ntv_MulticastViewportArrayvNVX_2 := GetProcOrNil&<procedure(gpu: UInt32; first: UInt32; count: Int32; v: IntPtr)>(MulticastViewportArrayvNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastViewportArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MulticastViewportArrayvNVX_1(gpu, first, count, v[0]) else
        ntv_MulticastViewportArrayvNVX_1(gpu, first, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastViewportArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; var v: single) :=
      ntv_MulticastViewportArrayvNVX_1(gpu, first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastViewportArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; v: IntPtr) :=
      ntv_MulticastViewportArrayvNVX_2(gpu, first, count, v);
    
    private MulticastViewportPositionWScaleNVX_adr := GetProcAddress('glMulticastViewportPositionWScaleNVX');
    private ntv_MulticastViewportPositionWScaleNVX_1 := GetProcOrNil&<procedure(gpu: UInt32; index: UInt32; xcoeff: single; ycoeff: single)>(MulticastViewportPositionWScaleNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastViewportPositionWScaleNVX(gpu: UInt32; index: UInt32; xcoeff: single; ycoeff: single) :=
      ntv_MulticastViewportPositionWScaleNVX_1(gpu, index, xcoeff, ycoeff);
    
    private MulticastScissorArrayvNVX_adr := GetProcAddress('glMulticastScissorArrayvNVX');
    private ntv_MulticastScissorArrayvNVX_1 := GetProcOrNil&<procedure(gpu: UInt32; first: UInt32; count: Int32; var v: Int32)>(MulticastScissorArrayvNVX_adr);
    private ntv_MulticastScissorArrayvNVX_2 := GetProcOrNil&<procedure(gpu: UInt32; first: UInt32; count: Int32; v: IntPtr)>(MulticastScissorArrayvNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastScissorArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MulticastScissorArrayvNVX_1(gpu, first, count, v[0]) else
        ntv_MulticastScissorArrayvNVX_1(gpu, first, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastScissorArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; var v: Int32) :=
      ntv_MulticastScissorArrayvNVX_1(gpu, first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastScissorArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; v: IntPtr) :=
      ntv_MulticastScissorArrayvNVX_2(gpu, first, count, v);
    
    private AsyncCopyBufferSubDataNVX_adr := GetProcAddress('glAsyncCopyBufferSubDataNVX');
    private ntv_AsyncCopyBufferSubDataNVX_1 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32>(AsyncCopyBufferSubDataNVX_adr);
    private ntv_AsyncCopyBufferSubDataNVX_2 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32>(AsyncCopyBufferSubDataNVX_adr);
    private ntv_AsyncCopyBufferSubDataNVX_3 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32>(AsyncCopyBufferSubDataNVX_adr);
    private ntv_AsyncCopyBufferSubDataNVX_4 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32>(AsyncCopyBufferSubDataNVX_adr);
    private ntv_AsyncCopyBufferSubDataNVX_5 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32>(AsyncCopyBufferSubDataNVX_adr);
    private ntv_AsyncCopyBufferSubDataNVX_6 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32>(AsyncCopyBufferSubDataNVX_adr);
    private ntv_AsyncCopyBufferSubDataNVX_7 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32>(AsyncCopyBufferSubDataNVX_adr);
    private ntv_AsyncCopyBufferSubDataNVX_8 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32>(AsyncCopyBufferSubDataNVX_adr);
    private ntv_AsyncCopyBufferSubDataNVX_9 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32>(AsyncCopyBufferSubDataNVX_adr);
    private ntv_AsyncCopyBufferSubDataNVX_10 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32>(AsyncCopyBufferSubDataNVX_adr);
    private ntv_AsyncCopyBufferSubDataNVX_11 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32>(AsyncCopyBufferSubDataNVX_adr);
    private ntv_AsyncCopyBufferSubDataNVX_12 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32>(AsyncCopyBufferSubDataNVX_adr);
    private ntv_AsyncCopyBufferSubDataNVX_13 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32>(AsyncCopyBufferSubDataNVX_adr);
    private ntv_AsyncCopyBufferSubDataNVX_14 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32>(AsyncCopyBufferSubDataNVX_adr);
    private ntv_AsyncCopyBufferSubDataNVX_15 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32>(AsyncCopyBufferSubDataNVX_adr);
    private ntv_AsyncCopyBufferSubDataNVX_16 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32>(AsyncCopyBufferSubDataNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32;
    type PUInt32 = ^UInt32;
    type PUInt64 = ^UInt64;
    begin
      Result := if (signalValueArray<>nil) and (signalValueArray.Length<>0) then
        if (fenceValueArray<>nil) and (fenceValueArray.Length<>0) then
          if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
            if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
              ntv_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]) else
              ntv_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, PUInt32(nil)^, signalValueArray[0]) else
            if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
              ntv_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, PUInt32(nil)^, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]) else
              ntv_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, PUInt32(nil)^, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, PUInt32(nil)^, signalValueArray[0]) else
          if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
            if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
              ntv_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray[0], PUInt64(nil)^, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]) else
              ntv_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray[0], PUInt64(nil)^, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, PUInt32(nil)^, signalValueArray[0]) else
            if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
              ntv_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]) else
              ntv_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, PUInt32(nil)^, signalValueArray[0]) else
        if (fenceValueArray<>nil) and (fenceValueArray.Length<>0) then
          if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
            if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
              ntv_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], PUInt64(nil)^) else
              ntv_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^) else
            if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
              ntv_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, PUInt32(nil)^, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], PUInt64(nil)^) else
              ntv_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, PUInt32(nil)^, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^) else
          if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
            if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
              ntv_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray[0], PUInt64(nil)^, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], PUInt64(nil)^) else
              ntv_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray[0], PUInt64(nil)^, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^) else
            if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
              ntv_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], PUInt64(nil)^) else
              ntv_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 :=
      ntv_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32 :=
      ntv_AsyncCopyBufferSubDataNVX_2(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32 :=
      ntv_AsyncCopyBufferSubDataNVX_3(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32 :=
      ntv_AsyncCopyBufferSubDataNVX_4(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 :=
      ntv_AsyncCopyBufferSubDataNVX_5(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32 :=
      ntv_AsyncCopyBufferSubDataNVX_6(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32 :=
      ntv_AsyncCopyBufferSubDataNVX_7(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32 :=
      ntv_AsyncCopyBufferSubDataNVX_8(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 :=
      ntv_AsyncCopyBufferSubDataNVX_9(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32 :=
      ntv_AsyncCopyBufferSubDataNVX_10(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32 :=
      ntv_AsyncCopyBufferSubDataNVX_11(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32 :=
      ntv_AsyncCopyBufferSubDataNVX_12(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 :=
      ntv_AsyncCopyBufferSubDataNVX_13(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32 :=
      ntv_AsyncCopyBufferSubDataNVX_14(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32 :=
      ntv_AsyncCopyBufferSubDataNVX_15(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32 :=
      ntv_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    
    private AsyncCopyImageSubDataNVX_adr := GetProcAddress('glAsyncCopyImageSubDataNVX');
    private ntv_AsyncCopyImageSubDataNVX_1 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32>(AsyncCopyImageSubDataNVX_adr);
    private ntv_AsyncCopyImageSubDataNVX_2 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32>(AsyncCopyImageSubDataNVX_adr);
    private ntv_AsyncCopyImageSubDataNVX_3 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32>(AsyncCopyImageSubDataNVX_adr);
    private ntv_AsyncCopyImageSubDataNVX_4 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32>(AsyncCopyImageSubDataNVX_adr);
    private ntv_AsyncCopyImageSubDataNVX_5 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32>(AsyncCopyImageSubDataNVX_adr);
    private ntv_AsyncCopyImageSubDataNVX_6 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32>(AsyncCopyImageSubDataNVX_adr);
    private ntv_AsyncCopyImageSubDataNVX_7 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32>(AsyncCopyImageSubDataNVX_adr);
    private ntv_AsyncCopyImageSubDataNVX_8 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32>(AsyncCopyImageSubDataNVX_adr);
    private ntv_AsyncCopyImageSubDataNVX_9 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32>(AsyncCopyImageSubDataNVX_adr);
    private ntv_AsyncCopyImageSubDataNVX_10 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32>(AsyncCopyImageSubDataNVX_adr);
    private ntv_AsyncCopyImageSubDataNVX_11 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32>(AsyncCopyImageSubDataNVX_adr);
    private ntv_AsyncCopyImageSubDataNVX_12 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32>(AsyncCopyImageSubDataNVX_adr);
    private ntv_AsyncCopyImageSubDataNVX_13 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32>(AsyncCopyImageSubDataNVX_adr);
    private ntv_AsyncCopyImageSubDataNVX_14 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32>(AsyncCopyImageSubDataNVX_adr);
    private ntv_AsyncCopyImageSubDataNVX_15 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32>(AsyncCopyImageSubDataNVX_adr);
    private ntv_AsyncCopyImageSubDataNVX_16 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32>(AsyncCopyImageSubDataNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32;
    type PUInt32 = ^UInt32;
    type PUInt64 = ^UInt64;
    begin
      Result := if (signalValueArray<>nil) and (signalValueArray.Length<>0) then
        if (waitValueArray<>nil) and (waitValueArray.Length<>0) then
          if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
            if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
              ntv_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]) else
              ntv_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, PUInt32(nil)^, signalValueArray[0]) else
            if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
              ntv_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, PUInt32(nil)^, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]) else
              ntv_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, PUInt32(nil)^, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, PUInt32(nil)^, signalValueArray[0]) else
          if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
            if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
              ntv_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray[0], PUInt64(nil)^, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]) else
              ntv_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray[0], PUInt64(nil)^, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, PUInt32(nil)^, signalValueArray[0]) else
            if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
              ntv_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]) else
              ntv_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, PUInt32(nil)^, signalValueArray[0]) else
        if (waitValueArray<>nil) and (waitValueArray.Length<>0) then
          if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
            if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
              ntv_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], PUInt64(nil)^) else
              ntv_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^) else
            if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
              ntv_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, PUInt32(nil)^, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], PUInt64(nil)^) else
              ntv_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, PUInt32(nil)^, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^) else
          if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
            if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
              ntv_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray[0], PUInt64(nil)^, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], PUInt64(nil)^) else
              ntv_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray[0], PUInt64(nil)^, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^) else
            if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
              ntv_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], PUInt64(nil)^) else
              ntv_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 :=
      ntv_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32 :=
      ntv_AsyncCopyImageSubDataNVX_2(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32 :=
      ntv_AsyncCopyImageSubDataNVX_3(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32 :=
      ntv_AsyncCopyImageSubDataNVX_4(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 :=
      ntv_AsyncCopyImageSubDataNVX_5(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32 :=
      ntv_AsyncCopyImageSubDataNVX_6(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32 :=
      ntv_AsyncCopyImageSubDataNVX_7(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32 :=
      ntv_AsyncCopyImageSubDataNVX_8(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 :=
      ntv_AsyncCopyImageSubDataNVX_9(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32 :=
      ntv_AsyncCopyImageSubDataNVX_10(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32 :=
      ntv_AsyncCopyImageSubDataNVX_11(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32 :=
      ntv_AsyncCopyImageSubDataNVX_12(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 :=
      ntv_AsyncCopyImageSubDataNVX_13(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32 :=
      ntv_AsyncCopyImageSubDataNVX_14(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32 :=
      ntv_AsyncCopyImageSubDataNVX_15(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32 :=
      ntv_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glLinkedGpuMulticastNVX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NVX_linked_gpu_multicast';
    
    private LGPUNamedBufferSubDataNVX_adr := GetProcAddress('glLGPUNamedBufferSubDataNVX');
    private ntv_LGPUNamedBufferSubDataNVX_1 := GetProcOrNil&<procedure(gpuMask: DummyFlags; buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: IntPtr)>(LGPUNamedBufferSubDataNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LGPUNamedBufferSubDataNVX(gpuMask: DummyFlags; buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: IntPtr) :=
      ntv_LGPUNamedBufferSubDataNVX_1(gpuMask, buffer, offset, size, data);
    
    private LGPUCopyImageSubDataNVX_adr := GetProcAddress('glLGPUCopyImageSubDataNVX');
    private ntv_LGPUCopyImageSubDataNVX_1 := GetProcOrNil&<procedure(sourceGpu: UInt32; destinationGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srxY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32)>(LGPUCopyImageSubDataNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LGPUCopyImageSubDataNVX(sourceGpu: UInt32; destinationGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srxY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32) :=
      ntv_LGPUCopyImageSubDataNVX_1(sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    
    private LGPUInterlockNVX_adr := GetProcAddress('glLGPUInterlockNVX');
    private ntv_LGPUInterlockNVX_1 := GetProcOrNil&<procedure>(LGPUInterlockNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LGPUInterlockNVX :=
      ntv_LGPUInterlockNVX_1;
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glProgressFenceNVX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_NVX_progress_fence';
    
    private CreateProgressFenceNVX_adr := GetProcAddress('glCreateProgressFenceNVX');
    private ntv_CreateProgressFenceNVX_1 := GetProcOrNil&<function: UInt32>(CreateProgressFenceNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateProgressFenceNVX: UInt32 :=
      ntv_CreateProgressFenceNVX_1;
    
    private SignalSemaphoreui64NVX_adr := GetProcAddress('glSignalSemaphoreui64NVX');
    private ntv_SignalSemaphoreui64NVX_1 := GetProcOrNil&<procedure(signalGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64)>(SignalSemaphoreui64NVX_adr);
    private ntv_SignalSemaphoreui64NVX_2 := GetProcOrNil&<procedure(signalGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: IntPtr)>(SignalSemaphoreui64NVX_adr);
    private ntv_SignalSemaphoreui64NVX_3 := GetProcOrNil&<procedure(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: IntPtr; var fenceValueArray: UInt64)>(SignalSemaphoreui64NVX_adr);
    private ntv_SignalSemaphoreui64NVX_4 := GetProcOrNil&<procedure(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: IntPtr; fenceValueArray: IntPtr)>(SignalSemaphoreui64NVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: array of UInt64);
    type PUInt32 = ^UInt32;
    type PUInt64 = ^UInt64;
    begin
      if (fenceValueArray<>nil) and (fenceValueArray.Length<>0) then
        if (semaphoreArray<>nil) and (semaphoreArray.Length<>0) then
          ntv_SignalSemaphoreui64NVX_1(signalGpu, fenceObjectCount, semaphoreArray[0], fenceValueArray[0]) else
          ntv_SignalSemaphoreui64NVX_1(signalGpu, fenceObjectCount, PUInt32(nil)^, fenceValueArray[0]) else
        if (semaphoreArray<>nil) and (semaphoreArray.Length<>0) then
          ntv_SignalSemaphoreui64NVX_1(signalGpu, fenceObjectCount, semaphoreArray[0], PUInt64(nil)^) else
          ntv_SignalSemaphoreui64NVX_1(signalGpu, fenceObjectCount, PUInt32(nil)^, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64) :=
      ntv_SignalSemaphoreui64NVX_1(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: IntPtr) :=
      ntv_SignalSemaphoreui64NVX_2(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: IntPtr; var fenceValueArray: UInt64) :=
      ntv_SignalSemaphoreui64NVX_3(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: IntPtr; fenceValueArray: IntPtr) :=
      ntv_SignalSemaphoreui64NVX_4(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    
    private WaitSemaphoreui64NVX_adr := GetProcAddress('glWaitSemaphoreui64NVX');
    private ntv_WaitSemaphoreui64NVX_1 := GetProcOrNil&<procedure(waitGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64)>(WaitSemaphoreui64NVX_adr);
    private ntv_WaitSemaphoreui64NVX_2 := GetProcOrNil&<procedure(waitGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: IntPtr)>(WaitSemaphoreui64NVX_adr);
    private ntv_WaitSemaphoreui64NVX_3 := GetProcOrNil&<procedure(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: IntPtr; var fenceValueArray: UInt64)>(WaitSemaphoreui64NVX_adr);
    private ntv_WaitSemaphoreui64NVX_4 := GetProcOrNil&<procedure(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: IntPtr; fenceValueArray: IntPtr)>(WaitSemaphoreui64NVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: array of UInt64);
    type PUInt32 = ^UInt32;
    type PUInt64 = ^UInt64;
    begin
      if (fenceValueArray<>nil) and (fenceValueArray.Length<>0) then
        if (semaphoreArray<>nil) and (semaphoreArray.Length<>0) then
          ntv_WaitSemaphoreui64NVX_1(waitGpu, fenceObjectCount, semaphoreArray[0], fenceValueArray[0]) else
          ntv_WaitSemaphoreui64NVX_1(waitGpu, fenceObjectCount, PUInt32(nil)^, fenceValueArray[0]) else
        if (semaphoreArray<>nil) and (semaphoreArray.Length<>0) then
          ntv_WaitSemaphoreui64NVX_1(waitGpu, fenceObjectCount, semaphoreArray[0], PUInt64(nil)^) else
          ntv_WaitSemaphoreui64NVX_1(waitGpu, fenceObjectCount, PUInt32(nil)^, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64) :=
      ntv_WaitSemaphoreui64NVX_1(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: IntPtr) :=
      ntv_WaitSemaphoreui64NVX_2(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: IntPtr; var fenceValueArray: UInt64) :=
      ntv_WaitSemaphoreui64NVX_3(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: IntPtr; fenceValueArray: IntPtr) :=
      ntv_WaitSemaphoreui64NVX_4(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    
    private ClientWaitSemaphoreui64NVX_adr := GetProcAddress('glClientWaitSemaphoreui64NVX');
    private ntv_ClientWaitSemaphoreui64NVX_1 := GetProcOrNil&<procedure(fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64)>(ClientWaitSemaphoreui64NVX_adr);
    private ntv_ClientWaitSemaphoreui64NVX_2 := GetProcOrNil&<procedure(fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: IntPtr)>(ClientWaitSemaphoreui64NVX_adr);
    private ntv_ClientWaitSemaphoreui64NVX_3 := GetProcOrNil&<procedure(fenceObjectCount: Int32; semaphoreArray: IntPtr; var fenceValueArray: UInt64)>(ClientWaitSemaphoreui64NVX_adr);
    private ntv_ClientWaitSemaphoreui64NVX_4 := GetProcOrNil&<procedure(fenceObjectCount: Int32; semaphoreArray: IntPtr; fenceValueArray: IntPtr)>(ClientWaitSemaphoreui64NVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: array of UInt64);
    type PUInt32 = ^UInt32;
    type PUInt64 = ^UInt64;
    begin
      if (fenceValueArray<>nil) and (fenceValueArray.Length<>0) then
        if (semaphoreArray<>nil) and (semaphoreArray.Length<>0) then
          ntv_ClientWaitSemaphoreui64NVX_1(fenceObjectCount, semaphoreArray[0], fenceValueArray[0]) else
          ntv_ClientWaitSemaphoreui64NVX_1(fenceObjectCount, PUInt32(nil)^, fenceValueArray[0]) else
        if (semaphoreArray<>nil) and (semaphoreArray.Length<>0) then
          ntv_ClientWaitSemaphoreui64NVX_1(fenceObjectCount, semaphoreArray[0], PUInt64(nil)^) else
          ntv_ClientWaitSemaphoreui64NVX_1(fenceObjectCount, PUInt32(nil)^, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64) :=
      ntv_ClientWaitSemaphoreui64NVX_1(fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: IntPtr) :=
      ntv_ClientWaitSemaphoreui64NVX_2(fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: IntPtr; var fenceValueArray: UInt64) :=
      ntv_ClientWaitSemaphoreui64NVX_3(fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: IntPtr; fenceValueArray: IntPtr) :=
      ntv_ClientWaitSemaphoreui64NVX_4(fenceObjectCount, semaphoreArray, fenceValueArray);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glByteCoordinatesOES = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_OES_byte_coordinates';
    
    private MultiTexCoord1bOES_adr := GetProcAddress('glMultiTexCoord1bOES');
    private ntv_MultiTexCoord1bOES_1 := GetProcOrNil&<procedure(texture: glTextureUnit; s: SByte)>(MultiTexCoord1bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1bOES(texture: glTextureUnit; s: SByte) :=
      ntv_MultiTexCoord1bOES_1(texture, s);
    
    private MultiTexCoord1bvOES_adr := GetProcAddress('glMultiTexCoord1bvOES');
    private ntv_MultiTexCoord1bvOES_1 := GetProcOrNil&<procedure(texture: glTextureUnit; var coords: SByte)>(MultiTexCoord1bvOES_adr);
    private ntv_MultiTexCoord1bvOES_2 := GetProcOrNil&<procedure(texture: glTextureUnit; coords: IntPtr)>(MultiTexCoord1bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1bvOES(texture: glTextureUnit; coords: array of SByte);
    type PSByte = ^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_MultiTexCoord1bvOES_1(texture, coords[0]) else
        ntv_MultiTexCoord1bvOES_1(texture, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1bvOES(texture: glTextureUnit; var coords: SByte) :=
      ntv_MultiTexCoord1bvOES_1(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1bvOES(texture: glTextureUnit; coords: IntPtr) :=
      ntv_MultiTexCoord1bvOES_2(texture, coords);
    
    private MultiTexCoord2bOES_adr := GetProcAddress('glMultiTexCoord2bOES');
    private ntv_MultiTexCoord2bOES_1 := GetProcOrNil&<procedure(texture: glTextureUnit; s: SByte; t: SByte)>(MultiTexCoord2bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2bOES(texture: glTextureUnit; s: SByte; t: SByte) :=
      ntv_MultiTexCoord2bOES_1(texture, s, t);
    
    private MultiTexCoord2bvOES_adr := GetProcAddress('glMultiTexCoord2bvOES');
    private ntv_MultiTexCoord2bvOES_1 := GetProcOrNil&<procedure(texture: glTextureUnit; var coords: SByte)>(MultiTexCoord2bvOES_adr);
    private ntv_MultiTexCoord2bvOES_2 := GetProcOrNil&<procedure(texture: glTextureUnit; var coords: Vec2b)>(MultiTexCoord2bvOES_adr);
    private ntv_MultiTexCoord2bvOES_3 := GetProcOrNil&<procedure(texture: glTextureUnit; coords: IntPtr)>(MultiTexCoord2bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2bvOES(texture: glTextureUnit; coords: array of SByte);
    type PSByte = ^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_MultiTexCoord2bvOES_1(texture, coords[0]) else
        ntv_MultiTexCoord2bvOES_1(texture, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2bvOES(texture: glTextureUnit; var coords: Vec2b) :=
      ntv_MultiTexCoord2bvOES_2(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2bvOES(texture: glTextureUnit; var coords: SByte) :=
      ntv_MultiTexCoord2bvOES_1(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2bvOES(texture: glTextureUnit; coords: IntPtr) :=
      ntv_MultiTexCoord2bvOES_3(texture, coords);
    
    private MultiTexCoord3bOES_adr := GetProcAddress('glMultiTexCoord3bOES');
    private ntv_MultiTexCoord3bOES_1 := GetProcOrNil&<procedure(texture: glTextureUnit; s: SByte; t: SByte; r: SByte)>(MultiTexCoord3bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3bOES(texture: glTextureUnit; s: SByte; t: SByte; r: SByte) :=
      ntv_MultiTexCoord3bOES_1(texture, s, t, r);
    
    private MultiTexCoord3bvOES_adr := GetProcAddress('glMultiTexCoord3bvOES');
    private ntv_MultiTexCoord3bvOES_1 := GetProcOrNil&<procedure(texture: glTextureUnit; var coords: SByte)>(MultiTexCoord3bvOES_adr);
    private ntv_MultiTexCoord3bvOES_2 := GetProcOrNil&<procedure(texture: glTextureUnit; var coords: Vec3b)>(MultiTexCoord3bvOES_adr);
    private ntv_MultiTexCoord3bvOES_3 := GetProcOrNil&<procedure(texture: glTextureUnit; coords: IntPtr)>(MultiTexCoord3bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3bvOES(texture: glTextureUnit; coords: array of SByte);
    type PSByte = ^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_MultiTexCoord3bvOES_1(texture, coords[0]) else
        ntv_MultiTexCoord3bvOES_1(texture, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3bvOES(texture: glTextureUnit; var coords: Vec3b) :=
      ntv_MultiTexCoord3bvOES_2(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3bvOES(texture: glTextureUnit; var coords: SByte) :=
      ntv_MultiTexCoord3bvOES_1(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3bvOES(texture: glTextureUnit; coords: IntPtr) :=
      ntv_MultiTexCoord3bvOES_3(texture, coords);
    
    private MultiTexCoord4bOES_adr := GetProcAddress('glMultiTexCoord4bOES');
    private ntv_MultiTexCoord4bOES_1 := GetProcOrNil&<procedure(texture: glTextureUnit; s: SByte; t: SByte; r: SByte; q: SByte)>(MultiTexCoord4bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4bOES(texture: glTextureUnit; s: SByte; t: SByte; r: SByte; q: SByte) :=
      ntv_MultiTexCoord4bOES_1(texture, s, t, r, q);
    
    private MultiTexCoord4bvOES_adr := GetProcAddress('glMultiTexCoord4bvOES');
    private ntv_MultiTexCoord4bvOES_1 := GetProcOrNil&<procedure(texture: glTextureUnit; var coords: SByte)>(MultiTexCoord4bvOES_adr);
    private ntv_MultiTexCoord4bvOES_2 := GetProcOrNil&<procedure(texture: glTextureUnit; var coords: Vec4b)>(MultiTexCoord4bvOES_adr);
    private ntv_MultiTexCoord4bvOES_3 := GetProcOrNil&<procedure(texture: glTextureUnit; coords: IntPtr)>(MultiTexCoord4bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4bvOES(texture: glTextureUnit; coords: array of SByte);
    type PSByte = ^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_MultiTexCoord4bvOES_1(texture, coords[0]) else
        ntv_MultiTexCoord4bvOES_1(texture, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4bvOES(texture: glTextureUnit; var coords: Vec4b) :=
      ntv_MultiTexCoord4bvOES_2(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4bvOES(texture: glTextureUnit; var coords: SByte) :=
      ntv_MultiTexCoord4bvOES_1(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4bvOES(texture: glTextureUnit; coords: IntPtr) :=
      ntv_MultiTexCoord4bvOES_3(texture, coords);
    
    private TexCoord1bOES_adr := GetProcAddress('glTexCoord1bOES');
    private ntv_TexCoord1bOES_1 := GetProcOrNil&<procedure(s: SByte)>(TexCoord1bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1bOES(s: SByte) :=
      ntv_TexCoord1bOES_1(s);
    
    private TexCoord1bvOES_adr := GetProcAddress('glTexCoord1bvOES');
    private ntv_TexCoord1bvOES_1 := GetProcOrNil&<procedure(var coords: SByte)>(TexCoord1bvOES_adr);
    private ntv_TexCoord1bvOES_2 := GetProcOrNil&<procedure(coords: IntPtr)>(TexCoord1bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1bvOES(coords: array of SByte);
    type PSByte = ^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_TexCoord1bvOES_1(coords[0]) else
        ntv_TexCoord1bvOES_1(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1bvOES(var coords: SByte) :=
      ntv_TexCoord1bvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1bvOES(coords: IntPtr) :=
      ntv_TexCoord1bvOES_2(coords);
    
    private TexCoord2bOES_adr := GetProcAddress('glTexCoord2bOES');
    private ntv_TexCoord2bOES_1 := GetProcOrNil&<procedure(s: SByte; t: SByte)>(TexCoord2bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2bOES(s: SByte; t: SByte) :=
      ntv_TexCoord2bOES_1(s, t);
    
    private TexCoord2bvOES_adr := GetProcAddress('glTexCoord2bvOES');
    private ntv_TexCoord2bvOES_1 := GetProcOrNil&<procedure(var coords: SByte)>(TexCoord2bvOES_adr);
    private ntv_TexCoord2bvOES_2 := GetProcOrNil&<procedure(var coords: Vec2b)>(TexCoord2bvOES_adr);
    private ntv_TexCoord2bvOES_3 := GetProcOrNil&<procedure(coords: IntPtr)>(TexCoord2bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2bvOES(coords: array of SByte);
    type PSByte = ^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_TexCoord2bvOES_1(coords[0]) else
        ntv_TexCoord2bvOES_1(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2bvOES(var coords: Vec2b) :=
      ntv_TexCoord2bvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2bvOES(var coords: SByte) :=
      ntv_TexCoord2bvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2bvOES(coords: IntPtr) :=
      ntv_TexCoord2bvOES_3(coords);
    
    private TexCoord3bOES_adr := GetProcAddress('glTexCoord3bOES');
    private ntv_TexCoord3bOES_1 := GetProcOrNil&<procedure(s: SByte; t: SByte; r: SByte)>(TexCoord3bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3bOES(s: SByte; t: SByte; r: SByte) :=
      ntv_TexCoord3bOES_1(s, t, r);
    
    private TexCoord3bvOES_adr := GetProcAddress('glTexCoord3bvOES');
    private ntv_TexCoord3bvOES_1 := GetProcOrNil&<procedure(var coords: SByte)>(TexCoord3bvOES_adr);
    private ntv_TexCoord3bvOES_2 := GetProcOrNil&<procedure(var coords: Vec3b)>(TexCoord3bvOES_adr);
    private ntv_TexCoord3bvOES_3 := GetProcOrNil&<procedure(coords: IntPtr)>(TexCoord3bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3bvOES(coords: array of SByte);
    type PSByte = ^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_TexCoord3bvOES_1(coords[0]) else
        ntv_TexCoord3bvOES_1(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3bvOES(var coords: Vec3b) :=
      ntv_TexCoord3bvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3bvOES(var coords: SByte) :=
      ntv_TexCoord3bvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3bvOES(coords: IntPtr) :=
      ntv_TexCoord3bvOES_3(coords);
    
    private TexCoord4bOES_adr := GetProcAddress('glTexCoord4bOES');
    private ntv_TexCoord4bOES_1 := GetProcOrNil&<procedure(s: SByte; t: SByte; r: SByte; q: SByte)>(TexCoord4bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4bOES(s: SByte; t: SByte; r: SByte; q: SByte) :=
      ntv_TexCoord4bOES_1(s, t, r, q);
    
    private TexCoord4bvOES_adr := GetProcAddress('glTexCoord4bvOES');
    private ntv_TexCoord4bvOES_1 := GetProcOrNil&<procedure(var coords: SByte)>(TexCoord4bvOES_adr);
    private ntv_TexCoord4bvOES_2 := GetProcOrNil&<procedure(var coords: Vec4b)>(TexCoord4bvOES_adr);
    private ntv_TexCoord4bvOES_3 := GetProcOrNil&<procedure(coords: IntPtr)>(TexCoord4bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4bvOES(coords: array of SByte);
    type PSByte = ^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_TexCoord4bvOES_1(coords[0]) else
        ntv_TexCoord4bvOES_1(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4bvOES(var coords: Vec4b) :=
      ntv_TexCoord4bvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4bvOES(var coords: SByte) :=
      ntv_TexCoord4bvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4bvOES(coords: IntPtr) :=
      ntv_TexCoord4bvOES_3(coords);
    
    private Vertex2bOES_adr := GetProcAddress('glVertex2bOES');
    private ntv_Vertex2bOES_1 := GetProcOrNil&<procedure(x: SByte; y: SByte)>(Vertex2bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2bOES(x: SByte; y: SByte) :=
      ntv_Vertex2bOES_1(x, y);
    
    private Vertex2bvOES_adr := GetProcAddress('glVertex2bvOES');
    private ntv_Vertex2bvOES_1 := GetProcOrNil&<procedure(var coords: SByte)>(Vertex2bvOES_adr);
    private ntv_Vertex2bvOES_2 := GetProcOrNil&<procedure(var coords: Vec2b)>(Vertex2bvOES_adr);
    private ntv_Vertex2bvOES_3 := GetProcOrNil&<procedure(coords: IntPtr)>(Vertex2bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2bvOES(coords: array of SByte);
    type PSByte = ^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_Vertex2bvOES_1(coords[0]) else
        ntv_Vertex2bvOES_1(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2bvOES(var coords: Vec2b) :=
      ntv_Vertex2bvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2bvOES(var coords: SByte) :=
      ntv_Vertex2bvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2bvOES(coords: IntPtr) :=
      ntv_Vertex2bvOES_3(coords);
    
    private Vertex3bOES_adr := GetProcAddress('glVertex3bOES');
    private ntv_Vertex3bOES_1 := GetProcOrNil&<procedure(x: SByte; y: SByte; z: SByte)>(Vertex3bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3bOES(x: SByte; y: SByte; z: SByte) :=
      ntv_Vertex3bOES_1(x, y, z);
    
    private Vertex3bvOES_adr := GetProcAddress('glVertex3bvOES');
    private ntv_Vertex3bvOES_1 := GetProcOrNil&<procedure(var coords: SByte)>(Vertex3bvOES_adr);
    private ntv_Vertex3bvOES_2 := GetProcOrNil&<procedure(var coords: Vec3b)>(Vertex3bvOES_adr);
    private ntv_Vertex3bvOES_3 := GetProcOrNil&<procedure(coords: IntPtr)>(Vertex3bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3bvOES(coords: array of SByte);
    type PSByte = ^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_Vertex3bvOES_1(coords[0]) else
        ntv_Vertex3bvOES_1(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3bvOES(var coords: Vec3b) :=
      ntv_Vertex3bvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3bvOES(var coords: SByte) :=
      ntv_Vertex3bvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3bvOES(coords: IntPtr) :=
      ntv_Vertex3bvOES_3(coords);
    
    private Vertex4bOES_adr := GetProcAddress('glVertex4bOES');
    private ntv_Vertex4bOES_1 := GetProcOrNil&<procedure(x: SByte; y: SByte; z: SByte; w: SByte)>(Vertex4bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4bOES(x: SByte; y: SByte; z: SByte; w: SByte) :=
      ntv_Vertex4bOES_1(x, y, z, w);
    
    private Vertex4bvOES_adr := GetProcAddress('glVertex4bvOES');
    private ntv_Vertex4bvOES_1 := GetProcOrNil&<procedure(var coords: SByte)>(Vertex4bvOES_adr);
    private ntv_Vertex4bvOES_2 := GetProcOrNil&<procedure(var coords: Vec4b)>(Vertex4bvOES_adr);
    private ntv_Vertex4bvOES_3 := GetProcOrNil&<procedure(coords: IntPtr)>(Vertex4bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4bvOES(coords: array of SByte);
    type PSByte = ^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_Vertex4bvOES_1(coords[0]) else
        ntv_Vertex4bvOES_1(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4bvOES(var coords: Vec4b) :=
      ntv_Vertex4bvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4bvOES(var coords: SByte) :=
      ntv_Vertex4bvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4bvOES(coords: IntPtr) :=
      ntv_Vertex4bvOES_3(coords);
    
  end;
  
  ///
  glCompressedPalettedTextureOES = static class
    public const _ExtStr = 'GL_OES_compressed_paletted_texture';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFixedPointOES = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_OES_fixed_point';
    
    private AlphaFuncxOES_adr := GetProcAddress('glAlphaFuncxOES');
    private ntv_AlphaFuncxOES_1 := GetProcOrNil&<procedure(func: glAlphaFunction; ref: gl_fixed)>(AlphaFuncxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFuncxOES(func: glAlphaFunction; ref: gl_fixed) :=
      ntv_AlphaFuncxOES_1(func, ref);
    
    private ClearColorxOES_adr := GetProcAddress('glClearColorxOES');
    private ntv_ClearColorxOES_1 := GetProcOrNil&<procedure(red: gl_fixed; green: gl_fixed; blue: gl_fixed; alpha: gl_fixed)>(ClearColorxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearColorxOES(red: gl_fixed; green: gl_fixed; blue: gl_fixed; alpha: gl_fixed) :=
      ntv_ClearColorxOES_1(red, green, blue, alpha);
    
    private ClearDepthxOES_adr := GetProcAddress('glClearDepthxOES');
    private ntv_ClearDepthxOES_1 := GetProcOrNil&<procedure(depth: gl_fixed)>(ClearDepthxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepthxOES(depth: gl_fixed) :=
      ntv_ClearDepthxOES_1(depth);
    
    private ClipPlanexOES_adr := GetProcAddress('glClipPlanexOES');
    private ntv_ClipPlanexOES_1 := GetProcOrNil&<procedure(plane: glClipPlaneName; var equation: gl_fixed)>(ClipPlanexOES_adr);
    private ntv_ClipPlanexOES_2 := GetProcOrNil&<procedure(plane: glClipPlaneName; equation: IntPtr)>(ClipPlanexOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanexOES(plane: glClipPlaneName; equation: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (equation<>nil) and (equation.Length<>0) then
        ntv_ClipPlanexOES_1(plane, equation[0]) else
        ntv_ClipPlanexOES_1(plane, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanexOES(plane: glClipPlaneName; var equation: gl_fixed) :=
      ntv_ClipPlanexOES_1(plane, equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanexOES(plane: glClipPlaneName; equation: IntPtr) :=
      ntv_ClipPlanexOES_2(plane, equation);
    
    private Color4xOES_adr := GetProcAddress('glColor4xOES');
    private ntv_Color4xOES_1 := GetProcOrNil&<procedure(red: gl_fixed; green: gl_fixed; blue: gl_fixed; alpha: gl_fixed)>(Color4xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4xOES(red: gl_fixed; green: gl_fixed; blue: gl_fixed; alpha: gl_fixed) :=
      ntv_Color4xOES_1(red, green, blue, alpha);
    
    private DepthRangexOES_adr := GetProcAddress('glDepthRangexOES');
    private ntv_DepthRangexOES_1 := GetProcOrNil&<procedure(n: gl_fixed; f: gl_fixed)>(DepthRangexOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangexOES(n: gl_fixed; f: gl_fixed) :=
      ntv_DepthRangexOES_1(n, f);
    
    private FogxOES_adr := GetProcAddress('glFogxOES');
    private ntv_FogxOES_1 := GetProcOrNil&<procedure(pname: glFogPName; param: gl_fixed)>(FogxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogxOES(pname: glFogPName; param: gl_fixed) :=
      ntv_FogxOES_1(pname, param);
    
    private FogxvOES_adr := GetProcAddress('glFogxvOES');
    private ntv_FogxvOES_1 := GetProcOrNil&<procedure(pname: glFogPName; var param: gl_fixed)>(FogxvOES_adr);
    private ntv_FogxvOES_2 := GetProcOrNil&<procedure(pname: glFogPName; param: IntPtr)>(FogxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogxvOES(pname: glFogPName; param: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (param<>nil) and (param.Length<>0) then
        ntv_FogxvOES_1(pname, param[0]) else
        ntv_FogxvOES_1(pname, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogxvOES(pname: glFogPName; var param: gl_fixed) :=
      ntv_FogxvOES_1(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogxvOES(pname: glFogPName; param: IntPtr) :=
      ntv_FogxvOES_2(pname, param);
    
    private FrustumxOES_adr := GetProcAddress('glFrustumxOES');
    private ntv_FrustumxOES_1 := GetProcOrNil&<procedure(l: gl_fixed; r: gl_fixed; b: gl_fixed; t: gl_fixed; n: gl_fixed; f: gl_fixed)>(FrustumxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrustumxOES(l: gl_fixed; r: gl_fixed; b: gl_fixed; t: gl_fixed; n: gl_fixed; f: gl_fixed) :=
      ntv_FrustumxOES_1(l, r, b, t, n, f);
    
    private GetClipPlanexOES_adr := GetProcAddress('glGetClipPlanexOES');
    private ntv_GetClipPlanexOES_1 := GetProcOrNil&<procedure(plane: glClipPlaneName; var equation: gl_fixed)>(GetClipPlanexOES_adr);
    private ntv_GetClipPlanexOES_2 := GetProcOrNil&<procedure(plane: glClipPlaneName; equation: IntPtr)>(GetClipPlanexOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanexOES(plane: glClipPlaneName; var equation: gl_fixed) :=
      ntv_GetClipPlanexOES_1(plane, equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanexOES(plane: glClipPlaneName; equation: IntPtr) :=
      ntv_GetClipPlanexOES_2(plane, equation);
    
    private GetFixedvOES_adr := GetProcAddress('glGetFixedvOES');
    private ntv_GetFixedvOES_1 := GetProcOrNil&<procedure(pname: glGetPName; var &params: gl_fixed)>(GetFixedvOES_adr);
    private ntv_GetFixedvOES_2 := GetProcOrNil&<procedure(pname: glGetPName; &params: IntPtr)>(GetFixedvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFixedvOES(pname: glGetPName; var &params: gl_fixed) :=
      ntv_GetFixedvOES_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFixedvOES(pname: glGetPName; &params: IntPtr) :=
      ntv_GetFixedvOES_2(pname, &params);
    
    private GetTexEnvxvOES_adr := GetProcAddress('glGetTexEnvxvOES');
    private ntv_GetTexEnvxvOES_1 := GetProcOrNil&<procedure(target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: gl_fixed)>(GetTexEnvxvOES_adr);
    private ntv_GetTexEnvxvOES_2 := GetProcOrNil&<procedure(target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr)>(GetTexEnvxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvxvOES(target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: gl_fixed) :=
      ntv_GetTexEnvxvOES_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvxvOES(target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr) :=
      ntv_GetTexEnvxvOES_2(target, pname, &params);
    
    private GetTexParameterxvOES_adr := GetProcAddress('glGetTexParameterxvOES');
    private ntv_GetTexParameterxvOES_1 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glGetTextureParameter; var &params: gl_fixed)>(GetTexParameterxvOES_adr);
    private ntv_GetTexParameterxvOES_2 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr)>(GetTexParameterxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterxvOES(target: glTextureTarget; pname: glGetTextureParameter; var &params: gl_fixed) :=
      ntv_GetTexParameterxvOES_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterxvOES(target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTexParameterxvOES_2(target, pname, &params);
    
    private LightModelxOES_adr := GetProcAddress('glLightModelxOES');
    private ntv_LightModelxOES_1 := GetProcOrNil&<procedure(pname: glLightModelParameter; param: gl_fixed)>(LightModelxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelxOES(pname: glLightModelParameter; param: gl_fixed) :=
      ntv_LightModelxOES_1(pname, param);
    
    private LightModelxvOES_adr := GetProcAddress('glLightModelxvOES');
    private ntv_LightModelxvOES_1 := GetProcOrNil&<procedure(pname: glLightModelParameter; var param: gl_fixed)>(LightModelxvOES_adr);
    private ntv_LightModelxvOES_2 := GetProcOrNil&<procedure(pname: glLightModelParameter; param: IntPtr)>(LightModelxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelxvOES(pname: glLightModelParameter; param: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (param<>nil) and (param.Length<>0) then
        ntv_LightModelxvOES_1(pname, param[0]) else
        ntv_LightModelxvOES_1(pname, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelxvOES(pname: glLightModelParameter; var param: gl_fixed) :=
      ntv_LightModelxvOES_1(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelxvOES(pname: glLightModelParameter; param: IntPtr) :=
      ntv_LightModelxvOES_2(pname, param);
    
    private LightxOES_adr := GetProcAddress('glLightxOES');
    private ntv_LightxOES_1 := GetProcOrNil&<procedure(light: glLightName; pname: glLightParameter; param: gl_fixed)>(LightxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightxOES(light: glLightName; pname: glLightParameter; param: gl_fixed) :=
      ntv_LightxOES_1(light, pname, param);
    
    private LightxvOES_adr := GetProcAddress('glLightxvOES');
    private ntv_LightxvOES_1 := GetProcOrNil&<procedure(light: glLightName; pname: glLightParameter; var &params: gl_fixed)>(LightxvOES_adr);
    private ntv_LightxvOES_2 := GetProcOrNil&<procedure(light: glLightName; pname: glLightParameter; &params: IntPtr)>(LightxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightxvOES(light: glLightName; pname: glLightParameter; &params: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_LightxvOES_1(light, pname, &params[0]) else
        ntv_LightxvOES_1(light, pname, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightxvOES(light: glLightName; pname: glLightParameter; var &params: gl_fixed) :=
      ntv_LightxvOES_1(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightxvOES(light: glLightName; pname: glLightParameter; &params: IntPtr) :=
      ntv_LightxvOES_2(light, pname, &params);
    
    private LineWidthxOES_adr := GetProcAddress('glLineWidthxOES');
    private ntv_LineWidthxOES_1 := GetProcOrNil&<procedure(width: gl_fixed)>(LineWidthxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LineWidthxOES(width: gl_fixed) :=
      ntv_LineWidthxOES_1(width);
    
    private LoadMatrixxOES_adr := GetProcAddress('glLoadMatrixxOES');
    private ntv_LoadMatrixxOES_1 := GetProcOrNil&<procedure(var m: gl_fixed)>(LoadMatrixxOES_adr);
    private ntv_LoadMatrixxOES_2 := GetProcOrNil&<procedure(m: IntPtr)>(LoadMatrixxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixxOES(m: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_LoadMatrixxOES_1(m[0]) else
        ntv_LoadMatrixxOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixxOES(var m: gl_fixed) :=
      ntv_LoadMatrixxOES_1(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixxOES(m: IntPtr) :=
      ntv_LoadMatrixxOES_2(m);
    
    private MaterialxOES_adr := GetProcAddress('glMaterialxOES');
    private ntv_MaterialxOES_1 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; param: gl_fixed)>(MaterialxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaterialxOES(face: glTriangleFace; pname: glMaterialParameter; param: gl_fixed) :=
      ntv_MaterialxOES_1(face, pname, param);
    
    private MaterialxvOES_adr := GetProcAddress('glMaterialxvOES');
    private ntv_MaterialxvOES_1 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; var param: gl_fixed)>(MaterialxvOES_adr);
    private ntv_MaterialxvOES_2 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; param: IntPtr)>(MaterialxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaterialxvOES(face: glTriangleFace; pname: glMaterialParameter; param: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (param<>nil) and (param.Length<>0) then
        ntv_MaterialxvOES_1(face, pname, param[0]) else
        ntv_MaterialxvOES_1(face, pname, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaterialxvOES(face: glTriangleFace; pname: glMaterialParameter; var param: gl_fixed) :=
      ntv_MaterialxvOES_1(face, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaterialxvOES(face: glTriangleFace; pname: glMaterialParameter; param: IntPtr) :=
      ntv_MaterialxvOES_2(face, pname, param);
    
    private MultMatrixxOES_adr := GetProcAddress('glMultMatrixxOES');
    private ntv_MultMatrixxOES_1 := GetProcOrNil&<procedure(var m: gl_fixed)>(MultMatrixxOES_adr);
    private ntv_MultMatrixxOES_2 := GetProcOrNil&<procedure(m: IntPtr)>(MultMatrixxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixxOES(m: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MultMatrixxOES_1(m[0]) else
        ntv_MultMatrixxOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixxOES(var m: gl_fixed) :=
      ntv_MultMatrixxOES_1(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixxOES(m: IntPtr) :=
      ntv_MultMatrixxOES_2(m);
    
    private MultiTexCoord4xOES_adr := GetProcAddress('glMultiTexCoord4xOES');
    private ntv_MultiTexCoord4xOES_1 := GetProcOrNil&<procedure(texture: glTextureUnit; s: gl_fixed; t: gl_fixed; r: gl_fixed; q: gl_fixed)>(MultiTexCoord4xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4xOES(texture: glTextureUnit; s: gl_fixed; t: gl_fixed; r: gl_fixed; q: gl_fixed) :=
      ntv_MultiTexCoord4xOES_1(texture, s, t, r, q);
    
    private Normal3xOES_adr := GetProcAddress('glNormal3xOES');
    private ntv_Normal3xOES_1 := GetProcOrNil&<procedure(nx: gl_fixed; ny: gl_fixed; nz: gl_fixed)>(Normal3xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3xOES(nx: gl_fixed; ny: gl_fixed; nz: gl_fixed) :=
      ntv_Normal3xOES_1(nx, ny, nz);
    
    private OrthoxOES_adr := GetProcAddress('glOrthoxOES');
    private ntv_OrthoxOES_1 := GetProcOrNil&<procedure(l: gl_fixed; r: gl_fixed; b: gl_fixed; t: gl_fixed; n: gl_fixed; f: gl_fixed)>(OrthoxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure OrthoxOES(l: gl_fixed; r: gl_fixed; b: gl_fixed; t: gl_fixed; n: gl_fixed; f: gl_fixed) :=
      ntv_OrthoxOES_1(l, r, b, t, n, f);
    
    private PointParameterxvOES_adr := GetProcAddress('glPointParameterxvOES');
    private ntv_PointParameterxvOES_1 := GetProcOrNil&<procedure(pname: glPointParameterName; var &params: gl_fixed)>(PointParameterxvOES_adr);
    private ntv_PointParameterxvOES_2 := GetProcOrNil&<procedure(pname: glPointParameterName; &params: IntPtr)>(PointParameterxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterxvOES(pname: glPointParameterName; &params: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_PointParameterxvOES_1(pname, &params[0]) else
        ntv_PointParameterxvOES_1(pname, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterxvOES(pname: glPointParameterName; var &params: gl_fixed) :=
      ntv_PointParameterxvOES_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterxvOES(pname: glPointParameterName; &params: IntPtr) :=
      ntv_PointParameterxvOES_2(pname, &params);
    
    private PointSizexOES_adr := GetProcAddress('glPointSizexOES');
    private ntv_PointSizexOES_1 := GetProcOrNil&<procedure(size: gl_fixed)>(PointSizexOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointSizexOES(size: gl_fixed) :=
      ntv_PointSizexOES_1(size);
    
    private PolygonOffsetxOES_adr := GetProcAddress('glPolygonOffsetxOES');
    private ntv_PolygonOffsetxOES_1 := GetProcOrNil&<procedure(factor: gl_fixed; units: gl_fixed)>(PolygonOffsetxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffsetxOES(factor: gl_fixed; units: gl_fixed) :=
      ntv_PolygonOffsetxOES_1(factor, units);
    
    private RotatexOES_adr := GetProcAddress('glRotatexOES');
    private ntv_RotatexOES_1 := GetProcOrNil&<procedure(angle: gl_fixed; x: gl_fixed; y: gl_fixed; z: gl_fixed)>(RotatexOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RotatexOES(angle: gl_fixed; x: gl_fixed; y: gl_fixed; z: gl_fixed) :=
      ntv_RotatexOES_1(angle, x, y, z);
    
    private ScalexOES_adr := GetProcAddress('glScalexOES');
    private ntv_ScalexOES_1 := GetProcOrNil&<procedure(x: gl_fixed; y: gl_fixed; z: gl_fixed)>(ScalexOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScalexOES(x: gl_fixed; y: gl_fixed; z: gl_fixed) :=
      ntv_ScalexOES_1(x, y, z);
    
    private TexEnvxOES_adr := GetProcAddress('glTexEnvxOES');
    private ntv_TexEnvxOES_1 := GetProcOrNil&<procedure(target: glTextureEnvTarget; pname: glTextureEnvParameter; param: gl_fixed)>(TexEnvxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvxOES(target: glTextureEnvTarget; pname: glTextureEnvParameter; param: gl_fixed) :=
      ntv_TexEnvxOES_1(target, pname, param);
    
    private TexEnvxvOES_adr := GetProcAddress('glTexEnvxvOES');
    private ntv_TexEnvxvOES_1 := GetProcOrNil&<procedure(target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: gl_fixed)>(TexEnvxvOES_adr);
    private ntv_TexEnvxvOES_2 := GetProcOrNil&<procedure(target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr)>(TexEnvxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvxvOES(target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TexEnvxvOES_1(target, pname, &params[0]) else
        ntv_TexEnvxvOES_1(target, pname, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvxvOES(target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: gl_fixed) :=
      ntv_TexEnvxvOES_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvxvOES(target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr) :=
      ntv_TexEnvxvOES_2(target, pname, &params);
    
    private TexParameterxOES_adr := GetProcAddress('glTexParameterxOES');
    private ntv_TexParameterxOES_1 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glGetTextureParameter; param: gl_fixed)>(TexParameterxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxOES(target: glTextureTarget; pname: glGetTextureParameter; param: gl_fixed) :=
      ntv_TexParameterxOES_1(target, pname, param);
    
    private TexParameterxvOES_adr := GetProcAddress('glTexParameterxvOES');
    private ntv_TexParameterxvOES_1 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glGetTextureParameter; var &params: gl_fixed)>(TexParameterxvOES_adr);
    private ntv_TexParameterxvOES_2 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr)>(TexParameterxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxvOES(target: glTextureTarget; pname: glGetTextureParameter; &params: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TexParameterxvOES_1(target, pname, &params[0]) else
        ntv_TexParameterxvOES_1(target, pname, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxvOES(target: glTextureTarget; pname: glGetTextureParameter; var &params: gl_fixed) :=
      ntv_TexParameterxvOES_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxvOES(target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_TexParameterxvOES_2(target, pname, &params);
    
    private TranslatexOES_adr := GetProcAddress('glTranslatexOES');
    private ntv_TranslatexOES_1 := GetProcOrNil&<procedure(x: gl_fixed; y: gl_fixed; z: gl_fixed)>(TranslatexOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TranslatexOES(x: gl_fixed; y: gl_fixed; z: gl_fixed) :=
      ntv_TranslatexOES_1(x, y, z);
    
    private AccumxOES_adr := GetProcAddress('glAccumxOES');
    private ntv_AccumxOES_1 := GetProcOrNil&<procedure(op: DummyEnum; value: gl_fixed)>(AccumxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AccumxOES(op: DummyEnum; value: gl_fixed) :=
      ntv_AccumxOES_1(op, value);
    
    private BitmapxOES_adr := GetProcAddress('glBitmapxOES');
    private ntv_BitmapxOES_1 := GetProcOrNil&<procedure(width: Int32; height: Int32; xorig: gl_fixed; yorig: gl_fixed; xmove: gl_fixed; ymove: gl_fixed; var bitmap: Byte)>(BitmapxOES_adr);
    private ntv_BitmapxOES_2 := GetProcOrNil&<procedure(width: Int32; height: Int32; xorig: gl_fixed; yorig: gl_fixed; xmove: gl_fixed; ymove: gl_fixed; bitmap: IntPtr)>(BitmapxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BitmapxOES(width: Int32; height: Int32; xorig: gl_fixed; yorig: gl_fixed; xmove: gl_fixed; ymove: gl_fixed; bitmap: array of Byte);
    type PByte = ^Byte;
    begin
      if (bitmap<>nil) and (bitmap.Length<>0) then
        ntv_BitmapxOES_1(width, height, xorig, yorig, xmove, ymove, bitmap[0]) else
        ntv_BitmapxOES_1(width, height, xorig, yorig, xmove, ymove, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BitmapxOES(width: Int32; height: Int32; xorig: gl_fixed; yorig: gl_fixed; xmove: gl_fixed; ymove: gl_fixed; var bitmap: Byte) :=
      ntv_BitmapxOES_1(width, height, xorig, yorig, xmove, ymove, bitmap);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BitmapxOES(width: Int32; height: Int32; xorig: gl_fixed; yorig: gl_fixed; xmove: gl_fixed; ymove: gl_fixed; bitmap: IntPtr) :=
      ntv_BitmapxOES_2(width, height, xorig, yorig, xmove, ymove, bitmap);
    
    private BlendColorxOES_adr := GetProcAddress('glBlendColorxOES');
    private ntv_BlendColorxOES_1 := GetProcOrNil&<procedure(red: gl_fixed; green: gl_fixed; blue: gl_fixed; alpha: gl_fixed)>(BlendColorxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendColorxOES(red: gl_fixed; green: gl_fixed; blue: gl_fixed; alpha: gl_fixed) :=
      ntv_BlendColorxOES_1(red, green, blue, alpha);
    
    private ClearAccumxOES_adr := GetProcAddress('glClearAccumxOES');
    private ntv_ClearAccumxOES_1 := GetProcOrNil&<procedure(red: gl_fixed; green: gl_fixed; blue: gl_fixed; alpha: gl_fixed)>(ClearAccumxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearAccumxOES(red: gl_fixed; green: gl_fixed; blue: gl_fixed; alpha: gl_fixed) :=
      ntv_ClearAccumxOES_1(red, green, blue, alpha);
    
    private Color3xOES_adr := GetProcAddress('glColor3xOES');
    private ntv_Color3xOES_1 := GetProcOrNil&<procedure(red: gl_fixed; green: gl_fixed; blue: gl_fixed)>(Color3xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3xOES(red: gl_fixed; green: gl_fixed; blue: gl_fixed) :=
      ntv_Color3xOES_1(red, green, blue);
    
    private Color3xvOES_adr := GetProcAddress('glColor3xvOES');
    private ntv_Color3xvOES_1 := GetProcOrNil&<procedure(var components: gl_fixed)>(Color3xvOES_adr);
    private ntv_Color3xvOES_2 := GetProcOrNil&<procedure(components: IntPtr)>(Color3xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3xvOES(components: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (components<>nil) and (components.Length<>0) then
        ntv_Color3xvOES_1(components[0]) else
        ntv_Color3xvOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3xvOES(var components: gl_fixed) :=
      ntv_Color3xvOES_1(components);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3xvOES(components: IntPtr) :=
      ntv_Color3xvOES_2(components);
    
    private Color4xvOES_adr := GetProcAddress('glColor4xvOES');
    private ntv_Color4xvOES_1 := GetProcOrNil&<procedure(var components: gl_fixed)>(Color4xvOES_adr);
    private ntv_Color4xvOES_2 := GetProcOrNil&<procedure(components: IntPtr)>(Color4xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4xvOES(components: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (components<>nil) and (components.Length<>0) then
        ntv_Color4xvOES_1(components[0]) else
        ntv_Color4xvOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4xvOES(var components: gl_fixed) :=
      ntv_Color4xvOES_1(components);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4xvOES(components: IntPtr) :=
      ntv_Color4xvOES_2(components);
    
    private ConvolutionParameterxOES_adr := GetProcAddress('glConvolutionParameterxOES');
    private ntv_ConvolutionParameterxOES_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; param: gl_fixed)>(ConvolutionParameterxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterxOES(target: glConvolutionTarget; pname: glConvolutionParameter; param: gl_fixed) :=
      ntv_ConvolutionParameterxOES_1(target, pname, param);
    
    private ConvolutionParameterxvOES_adr := GetProcAddress('glConvolutionParameterxvOES');
    private ntv_ConvolutionParameterxvOES_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: gl_fixed)>(ConvolutionParameterxvOES_adr);
    private ntv_ConvolutionParameterxvOES_2 := GetProcOrNil&<procedure(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr)>(ConvolutionParameterxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterxvOES(target: glConvolutionTarget; pname: glConvolutionParameter; &params: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ConvolutionParameterxvOES_1(target, pname, &params[0]) else
        ntv_ConvolutionParameterxvOES_1(target, pname, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterxvOES(target: glConvolutionTarget; pname: glConvolutionParameter; var &params: gl_fixed) :=
      ntv_ConvolutionParameterxvOES_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterxvOES(target: glConvolutionTarget; pname: glConvolutionParameter; &params: IntPtr) :=
      ntv_ConvolutionParameterxvOES_2(target, pname, &params);
    
    private EvalCoord1xOES_adr := GetProcAddress('glEvalCoord1xOES');
    private ntv_EvalCoord1xOES_1 := GetProcOrNil&<procedure(u: gl_fixed)>(EvalCoord1xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1xOES(u: gl_fixed) :=
      ntv_EvalCoord1xOES_1(u);
    
    private EvalCoord1xvOES_adr := GetProcAddress('glEvalCoord1xvOES');
    private ntv_EvalCoord1xvOES_1 := GetProcOrNil&<procedure(var coords: gl_fixed)>(EvalCoord1xvOES_adr);
    private ntv_EvalCoord1xvOES_2 := GetProcOrNil&<procedure(coords: IntPtr)>(EvalCoord1xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1xvOES(coords: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_EvalCoord1xvOES_1(coords[0]) else
        ntv_EvalCoord1xvOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1xvOES(var coords: gl_fixed) :=
      ntv_EvalCoord1xvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1xvOES(coords: IntPtr) :=
      ntv_EvalCoord1xvOES_2(coords);
    
    private EvalCoord2xOES_adr := GetProcAddress('glEvalCoord2xOES');
    private ntv_EvalCoord2xOES_1 := GetProcOrNil&<procedure(u: gl_fixed; v: gl_fixed)>(EvalCoord2xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2xOES(u: gl_fixed; v: gl_fixed) :=
      ntv_EvalCoord2xOES_1(u, v);
    
    private EvalCoord2xvOES_adr := GetProcAddress('glEvalCoord2xvOES');
    private ntv_EvalCoord2xvOES_1 := GetProcOrNil&<procedure(var coords: gl_fixed)>(EvalCoord2xvOES_adr);
    private ntv_EvalCoord2xvOES_2 := GetProcOrNil&<procedure(coords: IntPtr)>(EvalCoord2xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2xvOES(coords: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_EvalCoord2xvOES_1(coords[0]) else
        ntv_EvalCoord2xvOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2xvOES(var coords: gl_fixed) :=
      ntv_EvalCoord2xvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2xvOES(coords: IntPtr) :=
      ntv_EvalCoord2xvOES_2(coords);
    
    private FeedbackBufferxOES_adr := GetProcAddress('glFeedbackBufferxOES');
    private ntv_FeedbackBufferxOES_1 := GetProcOrNil&<procedure(n: Int32; &type: DummyEnum; var buffer: gl_fixed)>(FeedbackBufferxOES_adr);
    private ntv_FeedbackBufferxOES_2 := GetProcOrNil&<procedure(n: Int32; &type: DummyEnum; buffer: IntPtr)>(FeedbackBufferxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBufferxOES(n: Int32; &type: DummyEnum; buffer: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (buffer<>nil) and (buffer.Length<>0) then
        ntv_FeedbackBufferxOES_1(n, &type, buffer[0]) else
        ntv_FeedbackBufferxOES_1(n, &type, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBufferxOES(n: Int32; &type: DummyEnum; var buffer: gl_fixed) :=
      ntv_FeedbackBufferxOES_1(n, &type, buffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBufferxOES(n: Int32; &type: DummyEnum; buffer: IntPtr) :=
      ntv_FeedbackBufferxOES_2(n, &type, buffer);
    
    private GetConvolutionParameterxvOES_adr := GetProcAddress('glGetConvolutionParameterxvOES');
    private ntv_GetConvolutionParameterxvOES_1 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; var &params: gl_fixed)>(GetConvolutionParameterxvOES_adr);
    private ntv_GetConvolutionParameterxvOES_2 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: IntPtr)>(GetConvolutionParameterxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterxvOES(target: DummyEnum; pname: DummyEnum; var &params: gl_fixed) :=
      ntv_GetConvolutionParameterxvOES_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: IntPtr) :=
      ntv_GetConvolutionParameterxvOES_2(target, pname, &params);
    
    private GetHistogramParameterxvOES_adr := GetProcAddress('glGetHistogramParameterxvOES');
    private ntv_GetHistogramParameterxvOES_1 := GetProcOrNil&<procedure(target: glHistogramTarget; pname: glGetHistogramParameterPName; var &params: gl_fixed)>(GetHistogramParameterxvOES_adr);
    private ntv_GetHistogramParameterxvOES_2 := GetProcOrNil&<procedure(target: glHistogramTarget; pname: glGetHistogramParameterPName; &params: IntPtr)>(GetHistogramParameterxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterxvOES(target: glHistogramTarget; pname: glGetHistogramParameterPName; var &params: gl_fixed) :=
      ntv_GetHistogramParameterxvOES_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterxvOES(target: glHistogramTarget; pname: glGetHistogramParameterPName; &params: IntPtr) :=
      ntv_GetHistogramParameterxvOES_2(target, pname, &params);
    
    private GetLightxOES_adr := GetProcAddress('glGetLightxOES');
    private ntv_GetLightxOES_1 := GetProcOrNil&<procedure(light: glLightName; pname: glLightParameter; var &params: gl_fixed)>(GetLightxOES_adr);
    private ntv_GetLightxOES_2 := GetProcOrNil&<procedure(light: glLightName; pname: glLightParameter; &params: IntPtr)>(GetLightxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightxOES(light: glLightName; pname: glLightParameter; var &params: gl_fixed) :=
      ntv_GetLightxOES_1(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightxOES(light: glLightName; pname: glLightParameter; &params: IntPtr) :=
      ntv_GetLightxOES_2(light, pname, &params);
    
    private GetMapxvOES_adr := GetProcAddress('glGetMapxvOES');
    private ntv_GetMapxvOES_1 := GetProcOrNil&<procedure(target: glMapTarget; query: glGetMapQuery; var v: gl_fixed)>(GetMapxvOES_adr);
    private ntv_GetMapxvOES_2 := GetProcOrNil&<procedure(target: glMapTarget; query: glGetMapQuery; v: IntPtr)>(GetMapxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapxvOES(target: glMapTarget; query: glGetMapQuery; var v: gl_fixed) :=
      ntv_GetMapxvOES_1(target, query, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapxvOES(target: glMapTarget; query: glGetMapQuery; v: IntPtr) :=
      ntv_GetMapxvOES_2(target, query, v);
    
    private GetMaterialxOES_adr := GetProcAddress('glGetMaterialxOES');
    private ntv_GetMaterialxOES_1 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; param: gl_fixed)>(GetMaterialxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialxOES(face: glTriangleFace; pname: glMaterialParameter; param: gl_fixed) :=
      ntv_GetMaterialxOES_1(face, pname, param);
    
    private GetPixelMapxv_adr := GetProcAddress('glGetPixelMapxv');
    private ntv_GetPixelMapxv_1 := GetProcOrNil&<procedure(map: glPixelMap; size: Int32; var values: gl_fixed)>(GetPixelMapxv_adr);
    private ntv_GetPixelMapxv_2 := GetProcOrNil&<procedure(map: glPixelMap; size: Int32; values: IntPtr)>(GetPixelMapxv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapxv(map: glPixelMap; size: Int32; var values: gl_fixed) :=
      ntv_GetPixelMapxv_1(map, size, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapxv(map: glPixelMap; size: Int32; values: IntPtr) :=
      ntv_GetPixelMapxv_2(map, size, values);
    
    private GetTexGenxvOES_adr := GetProcAddress('glGetTexGenxvOES');
    private ntv_GetTexGenxvOES_1 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; var &params: gl_fixed)>(GetTexGenxvOES_adr);
    private ntv_GetTexGenxvOES_2 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr)>(GetTexGenxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenxvOES(coord: glTextureCoordName; pname: glTextureGenParameter; var &params: gl_fixed) :=
      ntv_GetTexGenxvOES_1(coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenxvOES(coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr) :=
      ntv_GetTexGenxvOES_2(coord, pname, &params);
    
    private GetTexLevelParameterxvOES_adr := GetProcAddress('glGetTexLevelParameterxvOES');
    private ntv_GetTexLevelParameterxvOES_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; pname: glGetTextureParameter; var &params: gl_fixed)>(GetTexLevelParameterxvOES_adr);
    private ntv_GetTexLevelParameterxvOES_2 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; pname: glGetTextureParameter; &params: IntPtr)>(GetTexLevelParameterxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterxvOES(target: glTextureTarget; level: Int32; pname: glGetTextureParameter; var &params: gl_fixed) :=
      ntv_GetTexLevelParameterxvOES_1(target, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterxvOES(target: glTextureTarget; level: Int32; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTexLevelParameterxvOES_2(target, level, pname, &params);
    
    private IndexxOES_adr := GetProcAddress('glIndexxOES');
    private ntv_IndexxOES_1 := GetProcOrNil&<procedure(component: gl_fixed)>(IndexxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexxOES(component: gl_fixed) :=
      ntv_IndexxOES_1(component);
    
    private IndexxvOES_adr := GetProcAddress('glIndexxvOES');
    private ntv_IndexxvOES_1 := GetProcOrNil&<procedure(var component: gl_fixed)>(IndexxvOES_adr);
    private ntv_IndexxvOES_2 := GetProcOrNil&<procedure(component: IntPtr)>(IndexxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexxvOES(component: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (component<>nil) and (component.Length<>0) then
        ntv_IndexxvOES_1(component[0]) else
        ntv_IndexxvOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexxvOES(var component: gl_fixed) :=
      ntv_IndexxvOES_1(component);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexxvOES(component: IntPtr) :=
      ntv_IndexxvOES_2(component);
    
    private LoadTransposeMatrixxOES_adr := GetProcAddress('glLoadTransposeMatrixxOES');
    private ntv_LoadTransposeMatrixxOES_1 := GetProcOrNil&<procedure(var m: gl_fixed)>(LoadTransposeMatrixxOES_adr);
    private ntv_LoadTransposeMatrixxOES_2 := GetProcOrNil&<procedure(m: IntPtr)>(LoadTransposeMatrixxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixxOES(m: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_LoadTransposeMatrixxOES_1(m[0]) else
        ntv_LoadTransposeMatrixxOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixxOES(var m: gl_fixed) :=
      ntv_LoadTransposeMatrixxOES_1(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixxOES(m: IntPtr) :=
      ntv_LoadTransposeMatrixxOES_2(m);
    
    private Map1xOES_adr := GetProcAddress('glMap1xOES');
    private ntv_Map1xOES_1 := GetProcOrNil&<procedure(target: glMapTarget; u1: gl_fixed; u2: gl_fixed; stride: Int32; order: Int32; points: gl_fixed)>(Map1xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1xOES(target: glMapTarget; u1: gl_fixed; u2: gl_fixed; stride: Int32; order: Int32; points: gl_fixed) :=
      ntv_Map1xOES_1(target, u1, u2, stride, order, points);
    
    private Map2xOES_adr := GetProcAddress('glMap2xOES');
    private ntv_Map2xOES_1 := GetProcOrNil&<procedure(target: glMapTarget; u1: gl_fixed; u2: gl_fixed; ustride: Int32; uorder: Int32; v1: gl_fixed; v2: gl_fixed; vstride: Int32; vorder: Int32; points: gl_fixed)>(Map2xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2xOES(target: glMapTarget; u1: gl_fixed; u2: gl_fixed; ustride: Int32; uorder: Int32; v1: gl_fixed; v2: gl_fixed; vstride: Int32; vorder: Int32; points: gl_fixed) :=
      ntv_Map2xOES_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
    private MapGrid1xOES_adr := GetProcAddress('glMapGrid1xOES');
    private ntv_MapGrid1xOES_1 := GetProcOrNil&<procedure(n: Int32; u1: gl_fixed; u2: gl_fixed)>(MapGrid1xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid1xOES(n: Int32; u1: gl_fixed; u2: gl_fixed) :=
      ntv_MapGrid1xOES_1(n, u1, u2);
    
    private MapGrid2xOES_adr := GetProcAddress('glMapGrid2xOES');
    private ntv_MapGrid2xOES_1 := GetProcOrNil&<procedure(n: Int32; u1: gl_fixed; u2: gl_fixed; v1: gl_fixed; v2: gl_fixed)>(MapGrid2xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid2xOES(n: Int32; u1: gl_fixed; u2: gl_fixed; v1: gl_fixed; v2: gl_fixed) :=
      ntv_MapGrid2xOES_1(n, u1, u2, v1, v2);
    
    private MultTransposeMatrixxOES_adr := GetProcAddress('glMultTransposeMatrixxOES');
    private ntv_MultTransposeMatrixxOES_1 := GetProcOrNil&<procedure(var m: gl_fixed)>(MultTransposeMatrixxOES_adr);
    private ntv_MultTransposeMatrixxOES_2 := GetProcOrNil&<procedure(m: IntPtr)>(MultTransposeMatrixxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixxOES(m: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MultTransposeMatrixxOES_1(m[0]) else
        ntv_MultTransposeMatrixxOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixxOES(var m: gl_fixed) :=
      ntv_MultTransposeMatrixxOES_1(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixxOES(m: IntPtr) :=
      ntv_MultTransposeMatrixxOES_2(m);
    
    private MultiTexCoord1xOES_adr := GetProcAddress('glMultiTexCoord1xOES');
    private ntv_MultiTexCoord1xOES_1 := GetProcOrNil&<procedure(texture: glTextureUnit; s: gl_fixed)>(MultiTexCoord1xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1xOES(texture: glTextureUnit; s: gl_fixed) :=
      ntv_MultiTexCoord1xOES_1(texture, s);
    
    private MultiTexCoord1xvOES_adr := GetProcAddress('glMultiTexCoord1xvOES');
    private ntv_MultiTexCoord1xvOES_1 := GetProcOrNil&<procedure(texture: glTextureUnit; var coords: gl_fixed)>(MultiTexCoord1xvOES_adr);
    private ntv_MultiTexCoord1xvOES_2 := GetProcOrNil&<procedure(texture: glTextureUnit; coords: IntPtr)>(MultiTexCoord1xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1xvOES(texture: glTextureUnit; coords: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_MultiTexCoord1xvOES_1(texture, coords[0]) else
        ntv_MultiTexCoord1xvOES_1(texture, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1xvOES(texture: glTextureUnit; var coords: gl_fixed) :=
      ntv_MultiTexCoord1xvOES_1(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1xvOES(texture: glTextureUnit; coords: IntPtr) :=
      ntv_MultiTexCoord1xvOES_2(texture, coords);
    
    private MultiTexCoord2xOES_adr := GetProcAddress('glMultiTexCoord2xOES');
    private ntv_MultiTexCoord2xOES_1 := GetProcOrNil&<procedure(texture: glTextureUnit; s: gl_fixed; t: gl_fixed)>(MultiTexCoord2xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2xOES(texture: glTextureUnit; s: gl_fixed; t: gl_fixed) :=
      ntv_MultiTexCoord2xOES_1(texture, s, t);
    
    private MultiTexCoord2xvOES_adr := GetProcAddress('glMultiTexCoord2xvOES');
    private ntv_MultiTexCoord2xvOES_1 := GetProcOrNil&<procedure(texture: glTextureUnit; var coords: gl_fixed)>(MultiTexCoord2xvOES_adr);
    private ntv_MultiTexCoord2xvOES_2 := GetProcOrNil&<procedure(texture: glTextureUnit; coords: IntPtr)>(MultiTexCoord2xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2xvOES(texture: glTextureUnit; coords: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_MultiTexCoord2xvOES_1(texture, coords[0]) else
        ntv_MultiTexCoord2xvOES_1(texture, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2xvOES(texture: glTextureUnit; var coords: gl_fixed) :=
      ntv_MultiTexCoord2xvOES_1(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2xvOES(texture: glTextureUnit; coords: IntPtr) :=
      ntv_MultiTexCoord2xvOES_2(texture, coords);
    
    private MultiTexCoord3xOES_adr := GetProcAddress('glMultiTexCoord3xOES');
    private ntv_MultiTexCoord3xOES_1 := GetProcOrNil&<procedure(texture: glTextureUnit; s: gl_fixed; t: gl_fixed; r: gl_fixed)>(MultiTexCoord3xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3xOES(texture: glTextureUnit; s: gl_fixed; t: gl_fixed; r: gl_fixed) :=
      ntv_MultiTexCoord3xOES_1(texture, s, t, r);
    
    private MultiTexCoord3xvOES_adr := GetProcAddress('glMultiTexCoord3xvOES');
    private ntv_MultiTexCoord3xvOES_1 := GetProcOrNil&<procedure(texture: glTextureUnit; var coords: gl_fixed)>(MultiTexCoord3xvOES_adr);
    private ntv_MultiTexCoord3xvOES_2 := GetProcOrNil&<procedure(texture: glTextureUnit; coords: IntPtr)>(MultiTexCoord3xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3xvOES(texture: glTextureUnit; coords: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_MultiTexCoord3xvOES_1(texture, coords[0]) else
        ntv_MultiTexCoord3xvOES_1(texture, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3xvOES(texture: glTextureUnit; var coords: gl_fixed) :=
      ntv_MultiTexCoord3xvOES_1(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3xvOES(texture: glTextureUnit; coords: IntPtr) :=
      ntv_MultiTexCoord3xvOES_2(texture, coords);
    
    private MultiTexCoord4xvOES_adr := GetProcAddress('glMultiTexCoord4xvOES');
    private ntv_MultiTexCoord4xvOES_1 := GetProcOrNil&<procedure(texture: glTextureUnit; var coords: gl_fixed)>(MultiTexCoord4xvOES_adr);
    private ntv_MultiTexCoord4xvOES_2 := GetProcOrNil&<procedure(texture: glTextureUnit; coords: IntPtr)>(MultiTexCoord4xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4xvOES(texture: glTextureUnit; coords: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_MultiTexCoord4xvOES_1(texture, coords[0]) else
        ntv_MultiTexCoord4xvOES_1(texture, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4xvOES(texture: glTextureUnit; var coords: gl_fixed) :=
      ntv_MultiTexCoord4xvOES_1(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4xvOES(texture: glTextureUnit; coords: IntPtr) :=
      ntv_MultiTexCoord4xvOES_2(texture, coords);
    
    private Normal3xvOES_adr := GetProcAddress('glNormal3xvOES');
    private ntv_Normal3xvOES_1 := GetProcOrNil&<procedure(var coords: gl_fixed)>(Normal3xvOES_adr);
    private ntv_Normal3xvOES_2 := GetProcOrNil&<procedure(coords: IntPtr)>(Normal3xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3xvOES(coords: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_Normal3xvOES_1(coords[0]) else
        ntv_Normal3xvOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3xvOES(var coords: gl_fixed) :=
      ntv_Normal3xvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3xvOES(coords: IntPtr) :=
      ntv_Normal3xvOES_2(coords);
    
    private PassThroughxOES_adr := GetProcAddress('glPassThroughxOES');
    private ntv_PassThroughxOES_1 := GetProcOrNil&<procedure(token: gl_fixed)>(PassThroughxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PassThroughxOES(token: gl_fixed) :=
      ntv_PassThroughxOES_1(token);
    
    private PixelMapx_adr := GetProcAddress('glPixelMapx');
    private ntv_PixelMapx_1 := GetProcOrNil&<procedure(map: glPixelMap; size: Int32; var values: gl_fixed)>(PixelMapx_adr);
    private ntv_PixelMapx_2 := GetProcOrNil&<procedure(map: glPixelMap; size: Int32; values: IntPtr)>(PixelMapx_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapx(map: glPixelMap; size: Int32; values: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (values<>nil) and (values.Length<>0) then
        ntv_PixelMapx_1(map, size, values[0]) else
        ntv_PixelMapx_1(map, size, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapx(map: glPixelMap; size: Int32; var values: gl_fixed) :=
      ntv_PixelMapx_1(map, size, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapx(map: glPixelMap; size: Int32; values: IntPtr) :=
      ntv_PixelMapx_2(map, size, values);
    
    private PixelStorex_adr := GetProcAddress('glPixelStorex');
    private ntv_PixelStorex_1 := GetProcOrNil&<procedure(pname: glPixelStoreParameter; param: gl_fixed)>(PixelStorex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelStorex(pname: glPixelStoreParameter; param: gl_fixed) :=
      ntv_PixelStorex_1(pname, param);
    
    private PixelTransferxOES_adr := GetProcAddress('glPixelTransferxOES');
    private ntv_PixelTransferxOES_1 := GetProcOrNil&<procedure(pname: glPixelTransferParameter; param: gl_fixed)>(PixelTransferxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransferxOES(pname: glPixelTransferParameter; param: gl_fixed) :=
      ntv_PixelTransferxOES_1(pname, param);
    
    private PixelZoomxOES_adr := GetProcAddress('glPixelZoomxOES');
    private ntv_PixelZoomxOES_1 := GetProcOrNil&<procedure(xfactor: gl_fixed; yfactor: gl_fixed)>(PixelZoomxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelZoomxOES(xfactor: gl_fixed; yfactor: gl_fixed) :=
      ntv_PixelZoomxOES_1(xfactor, yfactor);
    
    private PrioritizeTexturesxOES_adr := GetProcAddress('glPrioritizeTexturesxOES');
    private ntv_PrioritizeTexturesxOES_1 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture; var priorities: gl_fixed)>(PrioritizeTexturesxOES_adr);
    private ntv_PrioritizeTexturesxOES_2 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture; priorities: IntPtr)>(PrioritizeTexturesxOES_adr);
    private ntv_PrioritizeTexturesxOES_3 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr; var priorities: gl_fixed)>(PrioritizeTexturesxOES_adr);
    private ntv_PrioritizeTexturesxOES_4 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr; priorities: IntPtr)>(PrioritizeTexturesxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: array of gl_texture; priorities: array of gl_fixed);
    type PGl_texture = ^gl_texture;
    type PGl_fixed = ^gl_fixed;
    begin
      if (priorities<>nil) and (priorities.Length<>0) then
        if (textures<>nil) and (textures.Length<>0) then
          ntv_PrioritizeTexturesxOES_1(n, textures[0], priorities[0]) else
          ntv_PrioritizeTexturesxOES_1(n, PGl_texture(nil)^, priorities[0]) else
        if (textures<>nil) and (textures.Length<>0) then
          ntv_PrioritizeTexturesxOES_1(n, textures[0], PGl_fixed(nil)^) else
          ntv_PrioritizeTexturesxOES_1(n, PGl_texture(nil)^, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; var textures: gl_texture; var priorities: gl_fixed) :=
      ntv_PrioritizeTexturesxOES_1(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; var textures: gl_texture; priorities: IntPtr) :=
      ntv_PrioritizeTexturesxOES_2(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: IntPtr; var priorities: gl_fixed) :=
      ntv_PrioritizeTexturesxOES_3(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: IntPtr; priorities: IntPtr) :=
      ntv_PrioritizeTexturesxOES_4(n, textures, priorities);
    
    private RasterPos2xOES_adr := GetProcAddress('glRasterPos2xOES');
    private ntv_RasterPos2xOES_1 := GetProcOrNil&<procedure(x: gl_fixed; y: gl_fixed)>(RasterPos2xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2xOES(x: gl_fixed; y: gl_fixed) :=
      ntv_RasterPos2xOES_1(x, y);
    
    private RasterPos2xvOES_adr := GetProcAddress('glRasterPos2xvOES');
    private ntv_RasterPos2xvOES_1 := GetProcOrNil&<procedure(var coords: gl_fixed)>(RasterPos2xvOES_adr);
    private ntv_RasterPos2xvOES_2 := GetProcOrNil&<procedure(coords: IntPtr)>(RasterPos2xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2xvOES(coords: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_RasterPos2xvOES_1(coords[0]) else
        ntv_RasterPos2xvOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2xvOES(var coords: gl_fixed) :=
      ntv_RasterPos2xvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2xvOES(coords: IntPtr) :=
      ntv_RasterPos2xvOES_2(coords);
    
    private RasterPos3xOES_adr := GetProcAddress('glRasterPos3xOES');
    private ntv_RasterPos3xOES_1 := GetProcOrNil&<procedure(x: gl_fixed; y: gl_fixed; z: gl_fixed)>(RasterPos3xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3xOES(x: gl_fixed; y: gl_fixed; z: gl_fixed) :=
      ntv_RasterPos3xOES_1(x, y, z);
    
    private RasterPos3xvOES_adr := GetProcAddress('glRasterPos3xvOES');
    private ntv_RasterPos3xvOES_1 := GetProcOrNil&<procedure(var coords: gl_fixed)>(RasterPos3xvOES_adr);
    private ntv_RasterPos3xvOES_2 := GetProcOrNil&<procedure(coords: IntPtr)>(RasterPos3xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3xvOES(coords: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_RasterPos3xvOES_1(coords[0]) else
        ntv_RasterPos3xvOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3xvOES(var coords: gl_fixed) :=
      ntv_RasterPos3xvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3xvOES(coords: IntPtr) :=
      ntv_RasterPos3xvOES_2(coords);
    
    private RasterPos4xOES_adr := GetProcAddress('glRasterPos4xOES');
    private ntv_RasterPos4xOES_1 := GetProcOrNil&<procedure(x: gl_fixed; y: gl_fixed; z: gl_fixed; w: gl_fixed)>(RasterPos4xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4xOES(x: gl_fixed; y: gl_fixed; z: gl_fixed; w: gl_fixed) :=
      ntv_RasterPos4xOES_1(x, y, z, w);
    
    private RasterPos4xvOES_adr := GetProcAddress('glRasterPos4xvOES');
    private ntv_RasterPos4xvOES_1 := GetProcOrNil&<procedure(var coords: gl_fixed)>(RasterPos4xvOES_adr);
    private ntv_RasterPos4xvOES_2 := GetProcOrNil&<procedure(coords: IntPtr)>(RasterPos4xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4xvOES(coords: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_RasterPos4xvOES_1(coords[0]) else
        ntv_RasterPos4xvOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4xvOES(var coords: gl_fixed) :=
      ntv_RasterPos4xvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4xvOES(coords: IntPtr) :=
      ntv_RasterPos4xvOES_2(coords);
    
    private RectxOES_adr := GetProcAddress('glRectxOES');
    private ntv_RectxOES_1 := GetProcOrNil&<procedure(x1: gl_fixed; y1: gl_fixed; x2: gl_fixed; y2: gl_fixed)>(RectxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxOES(x1: gl_fixed; y1: gl_fixed; x2: gl_fixed; y2: gl_fixed) :=
      ntv_RectxOES_1(x1, y1, x2, y2);
    
    private RectxvOES_adr := GetProcAddress('glRectxvOES');
    private ntv_RectxvOES_1 := GetProcOrNil&<procedure(var v1: gl_fixed; var v2: gl_fixed)>(RectxvOES_adr);
    private ntv_RectxvOES_2 := GetProcOrNil&<procedure(var v1: gl_fixed; v2: IntPtr)>(RectxvOES_adr);
    private ntv_RectxvOES_3 := GetProcOrNil&<procedure(v1: IntPtr; var v2: gl_fixed)>(RectxvOES_adr);
    private ntv_RectxvOES_4 := GetProcOrNil&<procedure(v1: IntPtr; v2: IntPtr)>(RectxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: array of gl_fixed; v2: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (v1<>nil) and (v1.Length<>0) then
        if (v2<>nil) and (v2.Length<>0) then
          ntv_RectxvOES_1(v1[0], v2[0]) else
          ntv_RectxvOES_1(v1[0], PGl_fixed(nil)^) else
        if (v2<>nil) and (v2.Length<>0) then
          ntv_RectxvOES_1(PGl_fixed(nil)^, v2[0]) else
          ntv_RectxvOES_1(PGl_fixed(nil)^, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(var v1: gl_fixed; var v2: gl_fixed) :=
      ntv_RectxvOES_1(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(var v1: gl_fixed; v2: IntPtr) :=
      ntv_RectxvOES_2(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: IntPtr; var v2: gl_fixed) :=
      ntv_RectxvOES_3(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: IntPtr; v2: IntPtr) :=
      ntv_RectxvOES_4(v1, v2);
    
    private TexCoord1xOES_adr := GetProcAddress('glTexCoord1xOES');
    private ntv_TexCoord1xOES_1 := GetProcOrNil&<procedure(s: gl_fixed)>(TexCoord1xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1xOES(s: gl_fixed) :=
      ntv_TexCoord1xOES_1(s);
    
    private TexCoord1xvOES_adr := GetProcAddress('glTexCoord1xvOES');
    private ntv_TexCoord1xvOES_1 := GetProcOrNil&<procedure(var coords: gl_fixed)>(TexCoord1xvOES_adr);
    private ntv_TexCoord1xvOES_2 := GetProcOrNil&<procedure(coords: IntPtr)>(TexCoord1xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1xvOES(coords: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_TexCoord1xvOES_1(coords[0]) else
        ntv_TexCoord1xvOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1xvOES(var coords: gl_fixed) :=
      ntv_TexCoord1xvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1xvOES(coords: IntPtr) :=
      ntv_TexCoord1xvOES_2(coords);
    
    private TexCoord2xOES_adr := GetProcAddress('glTexCoord2xOES');
    private ntv_TexCoord2xOES_1 := GetProcOrNil&<procedure(s: gl_fixed; t: gl_fixed)>(TexCoord2xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2xOES(s: gl_fixed; t: gl_fixed) :=
      ntv_TexCoord2xOES_1(s, t);
    
    private TexCoord2xvOES_adr := GetProcAddress('glTexCoord2xvOES');
    private ntv_TexCoord2xvOES_1 := GetProcOrNil&<procedure(var coords: gl_fixed)>(TexCoord2xvOES_adr);
    private ntv_TexCoord2xvOES_2 := GetProcOrNil&<procedure(coords: IntPtr)>(TexCoord2xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2xvOES(coords: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_TexCoord2xvOES_1(coords[0]) else
        ntv_TexCoord2xvOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2xvOES(var coords: gl_fixed) :=
      ntv_TexCoord2xvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2xvOES(coords: IntPtr) :=
      ntv_TexCoord2xvOES_2(coords);
    
    private TexCoord3xOES_adr := GetProcAddress('glTexCoord3xOES');
    private ntv_TexCoord3xOES_1 := GetProcOrNil&<procedure(s: gl_fixed; t: gl_fixed; r: gl_fixed)>(TexCoord3xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3xOES(s: gl_fixed; t: gl_fixed; r: gl_fixed) :=
      ntv_TexCoord3xOES_1(s, t, r);
    
    private TexCoord3xvOES_adr := GetProcAddress('glTexCoord3xvOES');
    private ntv_TexCoord3xvOES_1 := GetProcOrNil&<procedure(var coords: gl_fixed)>(TexCoord3xvOES_adr);
    private ntv_TexCoord3xvOES_2 := GetProcOrNil&<procedure(coords: IntPtr)>(TexCoord3xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3xvOES(coords: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_TexCoord3xvOES_1(coords[0]) else
        ntv_TexCoord3xvOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3xvOES(var coords: gl_fixed) :=
      ntv_TexCoord3xvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3xvOES(coords: IntPtr) :=
      ntv_TexCoord3xvOES_2(coords);
    
    private TexCoord4xOES_adr := GetProcAddress('glTexCoord4xOES');
    private ntv_TexCoord4xOES_1 := GetProcOrNil&<procedure(s: gl_fixed; t: gl_fixed; r: gl_fixed; q: gl_fixed)>(TexCoord4xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4xOES(s: gl_fixed; t: gl_fixed; r: gl_fixed; q: gl_fixed) :=
      ntv_TexCoord4xOES_1(s, t, r, q);
    
    private TexCoord4xvOES_adr := GetProcAddress('glTexCoord4xvOES');
    private ntv_TexCoord4xvOES_1 := GetProcOrNil&<procedure(var coords: gl_fixed)>(TexCoord4xvOES_adr);
    private ntv_TexCoord4xvOES_2 := GetProcOrNil&<procedure(coords: IntPtr)>(TexCoord4xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4xvOES(coords: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_TexCoord4xvOES_1(coords[0]) else
        ntv_TexCoord4xvOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4xvOES(var coords: gl_fixed) :=
      ntv_TexCoord4xvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4xvOES(coords: IntPtr) :=
      ntv_TexCoord4xvOES_2(coords);
    
    private TexGenxOES_adr := GetProcAddress('glTexGenxOES');
    private ntv_TexGenxOES_1 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; param: gl_fixed)>(TexGenxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenxOES(coord: glTextureCoordName; pname: glTextureGenParameter; param: gl_fixed) :=
      ntv_TexGenxOES_1(coord, pname, param);
    
    private TexGenxvOES_adr := GetProcAddress('glTexGenxvOES');
    private ntv_TexGenxvOES_1 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; var &params: gl_fixed)>(TexGenxvOES_adr);
    private ntv_TexGenxvOES_2 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr)>(TexGenxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenxvOES(coord: glTextureCoordName; pname: glTextureGenParameter; &params: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TexGenxvOES_1(coord, pname, &params[0]) else
        ntv_TexGenxvOES_1(coord, pname, PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenxvOES(coord: glTextureCoordName; pname: glTextureGenParameter; var &params: gl_fixed) :=
      ntv_TexGenxvOES_1(coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenxvOES(coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr) :=
      ntv_TexGenxvOES_2(coord, pname, &params);
    
    private Vertex2xOES_adr := GetProcAddress('glVertex2xOES');
    private ntv_Vertex2xOES_1 := GetProcOrNil&<procedure(x: gl_fixed)>(Vertex2xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2xOES(x: gl_fixed) :=
      ntv_Vertex2xOES_1(x);
    
    private Vertex2xvOES_adr := GetProcAddress('glVertex2xvOES');
    private ntv_Vertex2xvOES_1 := GetProcOrNil&<procedure(var coords: gl_fixed)>(Vertex2xvOES_adr);
    private ntv_Vertex2xvOES_2 := GetProcOrNil&<procedure(coords: IntPtr)>(Vertex2xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2xvOES(coords: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_Vertex2xvOES_1(coords[0]) else
        ntv_Vertex2xvOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2xvOES(var coords: gl_fixed) :=
      ntv_Vertex2xvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2xvOES(coords: IntPtr) :=
      ntv_Vertex2xvOES_2(coords);
    
    private Vertex3xOES_adr := GetProcAddress('glVertex3xOES');
    private ntv_Vertex3xOES_1 := GetProcOrNil&<procedure(x: gl_fixed; y: gl_fixed)>(Vertex3xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3xOES(x: gl_fixed; y: gl_fixed) :=
      ntv_Vertex3xOES_1(x, y);
    
    private Vertex3xvOES_adr := GetProcAddress('glVertex3xvOES');
    private ntv_Vertex3xvOES_1 := GetProcOrNil&<procedure(var coords: gl_fixed)>(Vertex3xvOES_adr);
    private ntv_Vertex3xvOES_2 := GetProcOrNil&<procedure(coords: IntPtr)>(Vertex3xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3xvOES(coords: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_Vertex3xvOES_1(coords[0]) else
        ntv_Vertex3xvOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3xvOES(var coords: gl_fixed) :=
      ntv_Vertex3xvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3xvOES(coords: IntPtr) :=
      ntv_Vertex3xvOES_2(coords);
    
    private Vertex4xOES_adr := GetProcAddress('glVertex4xOES');
    private ntv_Vertex4xOES_1 := GetProcOrNil&<procedure(x: gl_fixed; y: gl_fixed; z: gl_fixed)>(Vertex4xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4xOES(x: gl_fixed; y: gl_fixed; z: gl_fixed) :=
      ntv_Vertex4xOES_1(x, y, z);
    
    private Vertex4xvOES_adr := GetProcAddress('glVertex4xvOES');
    private ntv_Vertex4xvOES_1 := GetProcOrNil&<procedure(var coords: gl_fixed)>(Vertex4xvOES_adr);
    private ntv_Vertex4xvOES_2 := GetProcOrNil&<procedure(coords: IntPtr)>(Vertex4xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4xvOES(coords: array of gl_fixed);
    type PGl_fixed = ^gl_fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_Vertex4xvOES_1(coords[0]) else
        ntv_Vertex4xvOES_1(PGl_fixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4xvOES(var coords: gl_fixed) :=
      ntv_Vertex4xvOES_1(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4xvOES(coords: IntPtr) :=
      ntv_Vertex4xvOES_2(coords);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glQueryMatrixOES = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_OES_query_matrix';
    
    private QueryMatrixxOES_adr := GetProcAddress('glQueryMatrixxOES');
    private ntv_QueryMatrixxOES_1 := GetProcOrNil&<function(var mantissa: gl_fixed; var exponent: Int32): DummyFlags>(QueryMatrixxOES_adr);
    private ntv_QueryMatrixxOES_2 := GetProcOrNil&<function(var mantissa: gl_fixed; exponent: IntPtr): DummyFlags>(QueryMatrixxOES_adr);
    private ntv_QueryMatrixxOES_3 := GetProcOrNil&<function(mantissa: IntPtr; var exponent: Int32): DummyFlags>(QueryMatrixxOES_adr);
    private ntv_QueryMatrixxOES_4 := GetProcOrNil&<function(mantissa: IntPtr; exponent: IntPtr): DummyFlags>(QueryMatrixxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: array of gl_fixed; exponent: array of Int32): DummyFlags;
    type PGl_fixed = ^gl_fixed;
    type PInt32 = ^Int32;
    begin
      Result := if (mantissa<>nil) and (mantissa.Length<>0) then
        if (exponent<>nil) and (exponent.Length<>0) then
          ntv_QueryMatrixxOES_1(mantissa[0], exponent[0]) else
          ntv_QueryMatrixxOES_1(mantissa[0], PInt32(nil)^) else
        if (exponent<>nil) and (exponent.Length<>0) then
          ntv_QueryMatrixxOES_1(PGl_fixed(nil)^, exponent[0]) else
          ntv_QueryMatrixxOES_1(PGl_fixed(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(var mantissa: gl_fixed; var exponent: Int32): DummyFlags :=
      ntv_QueryMatrixxOES_1(mantissa, exponent);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(var mantissa: gl_fixed; exponent: IntPtr): DummyFlags :=
      ntv_QueryMatrixxOES_2(mantissa, exponent);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: IntPtr; var exponent: Int32): DummyFlags :=
      ntv_QueryMatrixxOES_3(mantissa, exponent);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: IntPtr; exponent: IntPtr): DummyFlags :=
      ntv_QueryMatrixxOES_4(mantissa, exponent);
    
  end;
  
  ///
  glReadFormatOES = static class
    public const _ExtStr = 'GL_OES_read_format';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSinglePrecisionOES = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_OES_single_precision';
    
    private ClearDepthfOES_adr := GetProcAddress('glClearDepthfOES');
    private ntv_ClearDepthfOES_1 := GetProcOrNil&<procedure(depth: single)>(ClearDepthfOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepthfOES(depth: single) :=
      ntv_ClearDepthfOES_1(depth);
    
    private ClipPlanefOES_adr := GetProcAddress('glClipPlanefOES');
    private ntv_ClipPlanefOES_1 := GetProcOrNil&<procedure(plane: glClipPlaneName; var equation: single)>(ClipPlanefOES_adr);
    private ntv_ClipPlanefOES_2 := GetProcOrNil&<procedure(plane: glClipPlaneName; equation: IntPtr)>(ClipPlanefOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanefOES(plane: glClipPlaneName; equation: array of single);
    type PSingle = ^single;
    begin
      if (equation<>nil) and (equation.Length<>0) then
        ntv_ClipPlanefOES_1(plane, equation[0]) else
        ntv_ClipPlanefOES_1(plane, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanefOES(plane: glClipPlaneName; var equation: single) :=
      ntv_ClipPlanefOES_1(plane, equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanefOES(plane: glClipPlaneName; equation: IntPtr) :=
      ntv_ClipPlanefOES_2(plane, equation);
    
    private DepthRangefOES_adr := GetProcAddress('glDepthRangefOES');
    private ntv_DepthRangefOES_1 := GetProcOrNil&<procedure(n: single; f: single)>(DepthRangefOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangefOES(n: single; f: single) :=
      ntv_DepthRangefOES_1(n, f);
    
    private FrustumfOES_adr := GetProcAddress('glFrustumfOES');
    private ntv_FrustumfOES_1 := GetProcOrNil&<procedure(l: single; r: single; b: single; t: single; n: single; f: single)>(FrustumfOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrustumfOES(l: single; r: single; b: single; t: single; n: single; f: single) :=
      ntv_FrustumfOES_1(l, r, b, t, n, f);
    
    private GetClipPlanefOES_adr := GetProcAddress('glGetClipPlanefOES');
    private ntv_GetClipPlanefOES_1 := GetProcOrNil&<procedure(plane: glClipPlaneName; var equation: single)>(GetClipPlanefOES_adr);
    private ntv_GetClipPlanefOES_2 := GetProcOrNil&<procedure(plane: glClipPlaneName; equation: IntPtr)>(GetClipPlanefOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanefOES(plane: glClipPlaneName; var equation: single) :=
      ntv_GetClipPlanefOES_1(plane, equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanefOES(plane: glClipPlaneName; equation: IntPtr) :=
      ntv_GetClipPlanefOES_2(plane, equation);
    
    private OrthofOES_adr := GetProcAddress('glOrthofOES');
    private ntv_OrthofOES_1 := GetProcOrNil&<procedure(l: single; r: single; b: single; t: single; n: single; f: single)>(OrthofOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure OrthofOES(l: single; r: single; b: single; t: single; n: single; f: single) :=
      ntv_OrthofOES_1(l, r, b, t, n, f);
    
  end;
  
  ///
  glInterlaceOML = static class
    public const _ExtStr = 'GL_OML_interlace';
  end;
  
  ///
  glResampleOML = static class
    public const _ExtStr = 'GL_OML_resample';
  end;
  
  ///
  glSubsampleOML = static class
    public const _ExtStr = 'GL_OML_subsample';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMultiviewOVR = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_OVR_multiview';
    
    private FramebufferTextureMultiviewOVR_adr := GetProcAddress('glFramebufferTextureMultiviewOVR');
    private ntv_FramebufferTextureMultiviewOVR_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; baseViewIndex: Int32; numViews: Int32)>(FramebufferTextureMultiviewOVR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureMultiviewOVR(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; baseViewIndex: Int32; numViews: Int32) :=
      ntv_FramebufferTextureMultiviewOVR_1(target, attachment, texture, level, baseViewIndex, numViews);
    
  end;
  
  ///
  glMultiview2OVR = static class
    public const _ExtStr = 'GL_OVR_multiview2';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMiscHintsPGI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_PGI_misc_hints';
    
    private HintPGI_adr := GetProcAddress('glHintPGI');
    private ntv_HintPGI_1 := GetProcOrNil&<procedure(target: glHintTarget; mode: glVertexHintsMask)>(HintPGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure HintPGI(target: glHintTarget; mode: glVertexHintsMask) :=
      ntv_HintPGI_1(target, mode);
    
  end;
  
  ///
  glVertexHintsPGI = static class
    public const _ExtStr = 'GL_PGI_vertex_hints';
  end;
  
  ///
  glScreenCoordinatesREND = static class
    public const _ExtStr = 'GL_REND_screen_coordinates';
  end;
  
  ///
  glS3tcS3 = static class
    public const _ExtStr = 'GL_S3_s3tc';
  end;
  
  ///
  glColorMatrixSGI = static class
    public const _ExtStr = 'GL_SGI_color_matrix';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glColorTableSGI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGI_color_table';
    
    private ColorTableSGI_adr := GetProcAddress('glColorTableSGI');
    private ntv_ColorTableSGI_1 := GetProcOrNil&<procedure(target: glColorTableTarget; internalformat: glInternalFormat; width: Int32; format: glPixelFormat; &type: glPixelType; table: IntPtr)>(ColorTableSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableSGI(target: glColorTableTarget; internalformat: glInternalFormat; width: Int32; format: glPixelFormat; &type: glPixelType; table: IntPtr) :=
      ntv_ColorTableSGI_1(target, internalformat, width, format, &type, table);
    
    private ColorTableParameterfvSGI_adr := GetProcAddress('glColorTableParameterfvSGI');
    private ntv_ColorTableParameterfvSGI_1 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: single)>(ColorTableParameterfvSGI_adr);
    private ntv_ColorTableParameterfvSGI_2 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Vec4f)>(ColorTableParameterfvSGI_adr);
    private ntv_ColorTableParameterfvSGI_3 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr)>(ColorTableParameterfvSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfvSGI(target: glColorTableTarget; pname: glColorTableParameterPName; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ColorTableParameterfvSGI_1(target, pname, &params[0]) else
        ntv_ColorTableParameterfvSGI_1(target, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfvSGI(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Vec4f) :=
      ntv_ColorTableParameterfvSGI_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfvSGI(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: single) :=
      ntv_ColorTableParameterfvSGI_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfvSGI(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr) :=
      ntv_ColorTableParameterfvSGI_3(target, pname, &params);
    
    private ColorTableParameterivSGI_adr := GetProcAddress('glColorTableParameterivSGI');
    private ntv_ColorTableParameterivSGI_1 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Int32)>(ColorTableParameterivSGI_adr);
    private ntv_ColorTableParameterivSGI_2 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Vec4i)>(ColorTableParameterivSGI_adr);
    private ntv_ColorTableParameterivSGI_3 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr)>(ColorTableParameterivSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterivSGI(target: glColorTableTarget; pname: glColorTableParameterPName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ColorTableParameterivSGI_1(target, pname, &params[0]) else
        ntv_ColorTableParameterivSGI_1(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterivSGI(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Vec4i) :=
      ntv_ColorTableParameterivSGI_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterivSGI(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Int32) :=
      ntv_ColorTableParameterivSGI_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterivSGI(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr) :=
      ntv_ColorTableParameterivSGI_3(target, pname, &params);
    
    private CopyColorTableSGI_adr := GetProcAddress('glCopyColorTableSGI');
    private ntv_CopyColorTableSGI_1 := GetProcOrNil&<procedure(target: glColorTableTarget; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32)>(CopyColorTableSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyColorTableSGI(target: glColorTableTarget; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32) :=
      ntv_CopyColorTableSGI_1(target, internalformat, x, y, width);
    
    private GetColorTableSGI_adr := GetProcAddress('glGetColorTableSGI');
    private ntv_GetColorTableSGI_1 := GetProcOrNil&<procedure(target: glColorTableTarget; format: glPixelFormat; &type: glPixelType; table: IntPtr)>(GetColorTableSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableSGI(target: glColorTableTarget; format: glPixelFormat; &type: glPixelType; table: IntPtr) :=
      ntv_GetColorTableSGI_1(target, format, &type, table);
    
    private GetColorTableParameterfvSGI_adr := GetProcAddress('glGetColorTableParameterfvSGI');
    private ntv_GetColorTableParameterfvSGI_1 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: single)>(GetColorTableParameterfvSGI_adr);
    private ntv_GetColorTableParameterfvSGI_2 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr)>(GetColorTableParameterfvSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfvSGI(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: single) :=
      ntv_GetColorTableParameterfvSGI_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfvSGI(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr) :=
      ntv_GetColorTableParameterfvSGI_2(target, pname, &params);
    
    private GetColorTableParameterivSGI_adr := GetProcAddress('glGetColorTableParameterivSGI');
    private ntv_GetColorTableParameterivSGI_1 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Int32)>(GetColorTableParameterivSGI_adr);
    private ntv_GetColorTableParameterivSGI_2 := GetProcOrNil&<procedure(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr)>(GetColorTableParameterivSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterivSGI(target: glColorTableTarget; pname: glColorTableParameterPName; var &params: Int32) :=
      ntv_GetColorTableParameterivSGI_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterivSGI(target: glColorTableTarget; pname: glColorTableParameterPName; &params: IntPtr) :=
      ntv_GetColorTableParameterivSGI_2(target, pname, &params);
    
  end;
  
  ///
  glTextureColorTableSGI = static class
    public const _ExtStr = 'GL_SGI_texture_color_table';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glDetailTextureSGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIS_detail_texture';
    
    private DetailTexFuncSGIS_adr := GetProcAddress('glDetailTexFuncSGIS');
    private ntv_DetailTexFuncSGIS_1 := GetProcOrNil&<procedure(target: glTextureTarget; n: Int32; var points: single)>(DetailTexFuncSGIS_adr);
    private ntv_DetailTexFuncSGIS_2 := GetProcOrNil&<procedure(target: glTextureTarget; n: Int32; points: IntPtr)>(DetailTexFuncSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetailTexFuncSGIS(target: glTextureTarget; n: Int32; points: array of single);
    type PSingle = ^single;
    begin
      if (points<>nil) and (points.Length<>0) then
        ntv_DetailTexFuncSGIS_1(target, n, points[0]) else
        ntv_DetailTexFuncSGIS_1(target, n, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetailTexFuncSGIS(target: glTextureTarget; n: Int32; var points: single) :=
      ntv_DetailTexFuncSGIS_1(target, n, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetailTexFuncSGIS(target: glTextureTarget; n: Int32; points: IntPtr) :=
      ntv_DetailTexFuncSGIS_2(target, n, points);
    
    private GetDetailTexFuncSGIS_adr := GetProcAddress('glGetDetailTexFuncSGIS');
    private ntv_GetDetailTexFuncSGIS_1 := GetProcOrNil&<procedure(target: glTextureTarget; var points: single)>(GetDetailTexFuncSGIS_adr);
    private ntv_GetDetailTexFuncSGIS_2 := GetProcOrNil&<procedure(target: glTextureTarget; points: IntPtr)>(GetDetailTexFuncSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDetailTexFuncSGIS(target: glTextureTarget; var points: single) :=
      ntv_GetDetailTexFuncSGIS_1(target, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDetailTexFuncSGIS(target: glTextureTarget; points: IntPtr) :=
      ntv_GetDetailTexFuncSGIS_2(target, points);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFogFunctionSGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIS_fog_function';
    
    private FogFuncSGIS_adr := GetProcAddress('glFogFuncSGIS');
    private ntv_FogFuncSGIS_1 := GetProcOrNil&<procedure(n: Int32; var points: single)>(FogFuncSGIS_adr);
    private ntv_FogFuncSGIS_2 := GetProcOrNil&<procedure(n: Int32; points: IntPtr)>(FogFuncSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogFuncSGIS(n: Int32; points: array of single);
    type PSingle = ^single;
    begin
      if (points<>nil) and (points.Length<>0) then
        ntv_FogFuncSGIS_1(n, points[0]) else
        ntv_FogFuncSGIS_1(n, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogFuncSGIS(n: Int32; var points: single) :=
      ntv_FogFuncSGIS_1(n, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogFuncSGIS(n: Int32; points: IntPtr) :=
      ntv_FogFuncSGIS_2(n, points);
    
    private GetFogFuncSGIS_adr := GetProcAddress('glGetFogFuncSGIS');
    private ntv_GetFogFuncSGIS_1 := GetProcOrNil&<procedure(var points: single)>(GetFogFuncSGIS_adr);
    private ntv_GetFogFuncSGIS_2 := GetProcOrNil&<procedure(points: IntPtr)>(GetFogFuncSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFogFuncSGIS(var points: single) :=
      ntv_GetFogFuncSGIS_1(points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFogFuncSGIS(points: IntPtr) :=
      ntv_GetFogFuncSGIS_2(points);
    
  end;
  
  ///
  glGenerateMipmapSGIS = static class
    public const _ExtStr = 'GL_SGIS_generate_mipmap';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMultisampleSGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIS_multisample';
    
    private SampleMaskSGIS_adr := GetProcAddress('glSampleMaskSGIS');
    private ntv_SampleMaskSGIS_1 := GetProcOrNil&<procedure(value: single; invert: glBool8)>(SampleMaskSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMaskSGIS(value: single; invert: glBool8) :=
      ntv_SampleMaskSGIS_1(value, invert);
    
    private SamplePatternSGIS_adr := GetProcAddress('glSamplePatternSGIS');
    private ntv_SamplePatternSGIS_1 := GetProcOrNil&<procedure(pattern: glSamplePattern)>(SamplePatternSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplePatternSGIS(pattern: glSamplePattern) :=
      ntv_SamplePatternSGIS_1(pattern);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPixelTextureSGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIS_pixel_texture';
    
    private PixelTexGenParameteriSGIS_adr := GetProcAddress('glPixelTexGenParameteriSGIS');
    private ntv_PixelTexGenParameteriSGIS_1 := GetProcOrNil&<procedure(pname: glPixelTexGenParameterName; param: Int32)>(PixelTexGenParameteriSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameteriSGIS(pname: glPixelTexGenParameterName; param: Int32) :=
      ntv_PixelTexGenParameteriSGIS_1(pname, param);
    
    private PixelTexGenParameterivSGIS_adr := GetProcAddress('glPixelTexGenParameterivSGIS');
    private ntv_PixelTexGenParameterivSGIS_1 := GetProcOrNil&<procedure(pname: glPixelTexGenParameterName; var &params: Int32)>(PixelTexGenParameterivSGIS_adr);
    private ntv_PixelTexGenParameterivSGIS_2 := GetProcOrNil&<procedure(pname: glPixelTexGenParameterName; &params: IntPtr)>(PixelTexGenParameterivSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterivSGIS(pname: glPixelTexGenParameterName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_PixelTexGenParameterivSGIS_1(pname, &params[0]) else
        ntv_PixelTexGenParameterivSGIS_1(pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterivSGIS(pname: glPixelTexGenParameterName; var &params: Int32) :=
      ntv_PixelTexGenParameterivSGIS_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterivSGIS(pname: glPixelTexGenParameterName; &params: IntPtr) :=
      ntv_PixelTexGenParameterivSGIS_2(pname, &params);
    
    private PixelTexGenParameterfSGIS_adr := GetProcAddress('glPixelTexGenParameterfSGIS');
    private ntv_PixelTexGenParameterfSGIS_1 := GetProcOrNil&<procedure(pname: glPixelTexGenParameterName; param: single)>(PixelTexGenParameterfSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterfSGIS(pname: glPixelTexGenParameterName; param: single) :=
      ntv_PixelTexGenParameterfSGIS_1(pname, param);
    
    private PixelTexGenParameterfvSGIS_adr := GetProcAddress('glPixelTexGenParameterfvSGIS');
    private ntv_PixelTexGenParameterfvSGIS_1 := GetProcOrNil&<procedure(pname: glPixelTexGenParameterName; var &params: single)>(PixelTexGenParameterfvSGIS_adr);
    private ntv_PixelTexGenParameterfvSGIS_2 := GetProcOrNil&<procedure(pname: glPixelTexGenParameterName; &params: IntPtr)>(PixelTexGenParameterfvSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterfvSGIS(pname: glPixelTexGenParameterName; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_PixelTexGenParameterfvSGIS_1(pname, &params[0]) else
        ntv_PixelTexGenParameterfvSGIS_1(pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterfvSGIS(pname: glPixelTexGenParameterName; var &params: single) :=
      ntv_PixelTexGenParameterfvSGIS_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterfvSGIS(pname: glPixelTexGenParameterName; &params: IntPtr) :=
      ntv_PixelTexGenParameterfvSGIS_2(pname, &params);
    
    private GetPixelTexGenParameterivSGIS_adr := GetProcAddress('glGetPixelTexGenParameterivSGIS');
    private ntv_GetPixelTexGenParameterivSGIS_1 := GetProcOrNil&<procedure(pname: glPixelTexGenParameterName; var &params: Int32)>(GetPixelTexGenParameterivSGIS_adr);
    private ntv_GetPixelTexGenParameterivSGIS_2 := GetProcOrNil&<procedure(pname: glPixelTexGenParameterName; &params: IntPtr)>(GetPixelTexGenParameterivSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterivSGIS(pname: glPixelTexGenParameterName; var &params: Int32) :=
      ntv_GetPixelTexGenParameterivSGIS_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterivSGIS(pname: glPixelTexGenParameterName; &params: IntPtr) :=
      ntv_GetPixelTexGenParameterivSGIS_2(pname, &params);
    
    private GetPixelTexGenParameterfvSGIS_adr := GetProcAddress('glGetPixelTexGenParameterfvSGIS');
    private ntv_GetPixelTexGenParameterfvSGIS_1 := GetProcOrNil&<procedure(pname: glPixelTexGenParameterName; var &params: single)>(GetPixelTexGenParameterfvSGIS_adr);
    private ntv_GetPixelTexGenParameterfvSGIS_2 := GetProcOrNil&<procedure(pname: glPixelTexGenParameterName; &params: IntPtr)>(GetPixelTexGenParameterfvSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterfvSGIS(pname: glPixelTexGenParameterName; var &params: single) :=
      ntv_GetPixelTexGenParameterfvSGIS_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterfvSGIS(pname: glPixelTexGenParameterName; &params: IntPtr) :=
      ntv_GetPixelTexGenParameterfvSGIS_2(pname, &params);
    
  end;
  
  ///
  glPointLineTexgenSGIS = static class
    public const _ExtStr = 'GL_SGIS_point_line_texgen';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPointParametersSGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIS_point_parameters';
    
    private PointParameterfSGIS_adr := GetProcAddress('glPointParameterfSGIS');
    private ntv_PointParameterfSGIS_1 := GetProcOrNil&<procedure(pname: glPointParameterName; param: single)>(PointParameterfSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfSGIS(pname: glPointParameterName; param: single) :=
      ntv_PointParameterfSGIS_1(pname, param);
    
    private PointParameterfvSGIS_adr := GetProcAddress('glPointParameterfvSGIS');
    private ntv_PointParameterfvSGIS_1 := GetProcOrNil&<procedure(pname: glPointParameterName; var &params: single)>(PointParameterfvSGIS_adr);
    private ntv_PointParameterfvSGIS_2 := GetProcOrNil&<procedure(pname: glPointParameterName; &params: IntPtr)>(PointParameterfvSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvSGIS(pname: glPointParameterName; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_PointParameterfvSGIS_1(pname, &params[0]) else
        ntv_PointParameterfvSGIS_1(pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvSGIS(pname: glPointParameterName; var &params: single) :=
      ntv_PointParameterfvSGIS_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvSGIS(pname: glPointParameterName; &params: IntPtr) :=
      ntv_PointParameterfvSGIS_2(pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSharpenTextureSGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIS_sharpen_texture';
    
    private SharpenTexFuncSGIS_adr := GetProcAddress('glSharpenTexFuncSGIS');
    private ntv_SharpenTexFuncSGIS_1 := GetProcOrNil&<procedure(target: glTextureTarget; n: Int32; var points: single)>(SharpenTexFuncSGIS_adr);
    private ntv_SharpenTexFuncSGIS_2 := GetProcOrNil&<procedure(target: glTextureTarget; n: Int32; points: IntPtr)>(SharpenTexFuncSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SharpenTexFuncSGIS(target: glTextureTarget; n: Int32; points: array of single);
    type PSingle = ^single;
    begin
      if (points<>nil) and (points.Length<>0) then
        ntv_SharpenTexFuncSGIS_1(target, n, points[0]) else
        ntv_SharpenTexFuncSGIS_1(target, n, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SharpenTexFuncSGIS(target: glTextureTarget; n: Int32; var points: single) :=
      ntv_SharpenTexFuncSGIS_1(target, n, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SharpenTexFuncSGIS(target: glTextureTarget; n: Int32; points: IntPtr) :=
      ntv_SharpenTexFuncSGIS_2(target, n, points);
    
    private GetSharpenTexFuncSGIS_adr := GetProcAddress('glGetSharpenTexFuncSGIS');
    private ntv_GetSharpenTexFuncSGIS_1 := GetProcOrNil&<procedure(target: glTextureTarget; var points: single)>(GetSharpenTexFuncSGIS_adr);
    private ntv_GetSharpenTexFuncSGIS_2 := GetProcOrNil&<procedure(target: glTextureTarget; points: IntPtr)>(GetSharpenTexFuncSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSharpenTexFuncSGIS(target: glTextureTarget; var points: single) :=
      ntv_GetSharpenTexFuncSGIS_1(target, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSharpenTexFuncSGIS(target: glTextureTarget; points: IntPtr) :=
      ntv_GetSharpenTexFuncSGIS_2(target, points);
    
  end;
  
  ///
  glTextureBorderClampSGIS = static class
    public const _ExtStr = 'GL_SGIS_texture_border_clamp';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureColorMaskSGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIS_texture_color_mask';
    
    private TextureColorMaskSGIS_adr := GetProcAddress('glTextureColorMaskSGIS');
    private ntv_TextureColorMaskSGIS_1 := GetProcOrNil&<procedure(red: glBool8; green: glBool8; blue: glBool8; alpha: glBool8)>(TextureColorMaskSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureColorMaskSGIS(red: glBool8; green: glBool8; blue: glBool8; alpha: glBool8) :=
      ntv_TextureColorMaskSGIS_1(red, green, blue, alpha);
    
  end;
  
  ///
  glTextureEdgeClampSGIS = static class
    public const _ExtStr = 'GL_SGIS_texture_edge_clamp';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTextureFilter4SGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIS_texture_filter4';
    
    private GetTexFilterFuncSGIS_adr := GetProcAddress('glGetTexFilterFuncSGIS');
    private ntv_GetTexFilterFuncSGIS_1 := GetProcOrNil&<procedure(target: glTextureTarget; filter: glTextureFilter; var weights: single)>(GetTexFilterFuncSGIS_adr);
    private ntv_GetTexFilterFuncSGIS_2 := GetProcOrNil&<procedure(target: glTextureTarget; filter: glTextureFilter; weights: IntPtr)>(GetTexFilterFuncSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexFilterFuncSGIS(target: glTextureTarget; filter: glTextureFilter; var weights: single) :=
      ntv_GetTexFilterFuncSGIS_1(target, filter, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexFilterFuncSGIS(target: glTextureTarget; filter: glTextureFilter; weights: IntPtr) :=
      ntv_GetTexFilterFuncSGIS_2(target, filter, weights);
    
    private TexFilterFuncSGIS_adr := GetProcAddress('glTexFilterFuncSGIS');
    private ntv_TexFilterFuncSGIS_1 := GetProcOrNil&<procedure(target: glTextureTarget; filter: glTextureFilter; n: Int32; var weights: single)>(TexFilterFuncSGIS_adr);
    private ntv_TexFilterFuncSGIS_2 := GetProcOrNil&<procedure(target: glTextureTarget; filter: glTextureFilter; n: Int32; weights: IntPtr)>(TexFilterFuncSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexFilterFuncSGIS(target: glTextureTarget; filter: glTextureFilter; n: Int32; weights: array of single);
    type PSingle = ^single;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        ntv_TexFilterFuncSGIS_1(target, filter, n, weights[0]) else
        ntv_TexFilterFuncSGIS_1(target, filter, n, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexFilterFuncSGIS(target: glTextureTarget; filter: glTextureFilter; n: Int32; var weights: single) :=
      ntv_TexFilterFuncSGIS_1(target, filter, n, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexFilterFuncSGIS(target: glTextureTarget; filter: glTextureFilter; n: Int32; weights: IntPtr) :=
      ntv_TexFilterFuncSGIS_2(target, filter, n, weights);
    
  end;
  
  ///
  glTextureLodSGIS = static class
    public const _ExtStr = 'GL_SGIS_texture_lod';
  end;
  
  ///
  glTextureSelectSGIS = static class
    public const _ExtStr = 'GL_SGIS_texture_select';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTexture4DSGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIS_texture4D';
    
    private TexImage4DSGIS_adr := GetProcAddress('glTexImage4DSGIS');
    private ntv_TexImage4DSGIS_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; size4d: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TexImage4DSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage4DSGIS(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; size4d: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TexImage4DSGIS_1(target, level, internalformat, width, height, depth, size4d, border, format, &type, pixels);
    
    private TexSubImage4DSGIS_adr := GetProcAddress('glTexSubImage4DSGIS');
    private ntv_TexSubImage4DSGIS_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; woffset: Int32; width: Int32; height: Int32; depth: Int32; size4d: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TexSubImage4DSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage4DSGIS(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; woffset: Int32; width: Int32; height: Int32; depth: Int32; size4d: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TexSubImage4DSGIS_1(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, &type, pixels);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glAsyncSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIX_async';
    
    private AsyncMarkerSGIX_adr := GetProcAddress('glAsyncMarkerSGIX');
    private ntv_AsyncMarkerSGIX_1 := GetProcOrNil&<procedure(marker: UInt32)>(AsyncMarkerSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AsyncMarkerSGIX(marker: UInt32) :=
      ntv_AsyncMarkerSGIX_1(marker);
    
    private FinishAsyncSGIX_adr := GetProcAddress('glFinishAsyncSGIX');
    private ntv_FinishAsyncSGIX_1 := GetProcOrNil&<function(var markerp: UInt32): Int32>(FinishAsyncSGIX_adr);
    private ntv_FinishAsyncSGIX_2 := GetProcOrNil&<function(markerp: IntPtr): Int32>(FinishAsyncSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function FinishAsyncSGIX(markerp: array of UInt32): Int32;
    type PUInt32 = ^UInt32;
    begin
      Result := if (markerp<>nil) and (markerp.Length<>0) then
        ntv_FinishAsyncSGIX_1(markerp[0]) else
        ntv_FinishAsyncSGIX_1(PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function FinishAsyncSGIX(var markerp: UInt32): Int32 :=
      ntv_FinishAsyncSGIX_1(markerp);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function FinishAsyncSGIX(markerp: IntPtr): Int32 :=
      ntv_FinishAsyncSGIX_2(markerp);
    
    private PollAsyncSGIX_adr := GetProcAddress('glPollAsyncSGIX');
    private ntv_PollAsyncSGIX_1 := GetProcOrNil&<function(var markerp: UInt32): Int32>(PollAsyncSGIX_adr);
    private ntv_PollAsyncSGIX_2 := GetProcOrNil&<function(markerp: IntPtr): Int32>(PollAsyncSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollAsyncSGIX(markerp: array of UInt32): Int32;
    type PUInt32 = ^UInt32;
    begin
      Result := if (markerp<>nil) and (markerp.Length<>0) then
        ntv_PollAsyncSGIX_1(markerp[0]) else
        ntv_PollAsyncSGIX_1(PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollAsyncSGIX(var markerp: UInt32): Int32 :=
      ntv_PollAsyncSGIX_1(markerp);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollAsyncSGIX(markerp: IntPtr): Int32 :=
      ntv_PollAsyncSGIX_2(markerp);
    
    private GenAsyncMarkersSGIX_adr := GetProcAddress('glGenAsyncMarkersSGIX');
    private ntv_GenAsyncMarkersSGIX_1 := GetProcOrNil&<function(range: Int32): UInt32>(GenAsyncMarkersSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenAsyncMarkersSGIX(range: Int32): UInt32 :=
      ntv_GenAsyncMarkersSGIX_1(range);
    
    private DeleteAsyncMarkersSGIX_adr := GetProcAddress('glDeleteAsyncMarkersSGIX');
    private ntv_DeleteAsyncMarkersSGIX_1 := GetProcOrNil&<procedure(marker: UInt32; range: Int32)>(DeleteAsyncMarkersSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteAsyncMarkersSGIX(marker: UInt32; range: Int32) :=
      ntv_DeleteAsyncMarkersSGIX_1(marker, range);
    
    private IsAsyncMarkerSGIX_adr := GetProcAddress('glIsAsyncMarkerSGIX');
    private ntv_IsAsyncMarkerSGIX_1 := GetProcOrNil&<function(marker: UInt32): glBool8>(IsAsyncMarkerSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsAsyncMarkerSGIX(marker: UInt32): glBool8 :=
      ntv_IsAsyncMarkerSGIX_1(marker);
    
  end;
  
  ///
  glAsyncHistogramSGIX = static class
    public const _ExtStr = 'GL_SGIX_async_histogram';
  end;
  
  ///
  glAsyncPixelSGIX = static class
    public const _ExtStr = 'GL_SGIX_async_pixel';
  end;
  
  ///
  glBlendAlphaMinmaxSGIX = static class
    public const _ExtStr = 'GL_SGIX_blend_alpha_minmax';
  end;
  
  ///
  glCalligraphicFragmentSGIX = static class
    public const _ExtStr = 'GL_SGIX_calligraphic_fragment';
  end;
  
  ///
  glClipmapSGIX = static class
    public const _ExtStr = 'GL_SGIX_clipmap';
  end;
  
  ///
  glConvolutionAccuracySGIX = static class
    public const _ExtStr = 'GL_SGIX_convolution_accuracy';
  end;
  
  ///
  glDepthPassInstrumentSGIX = static class
    public const _ExtStr = 'GL_SGIX_depth_pass_instrument';
  end;
  
  ///
  glDepthTextureSGIX = static class
    public const _ExtStr = 'GL_SGIX_depth_texture';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFlushRasterSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIX_flush_raster';
    
    private FlushRasterSGIX_adr := GetProcAddress('glFlushRasterSGIX');
    private ntv_FlushRasterSGIX_1 := GetProcOrNil&<procedure>(FlushRasterSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushRasterSGIX :=
      ntv_FlushRasterSGIX_1;
    
  end;
  
  ///
  glFogOffsetSGIX = static class
    public const _ExtStr = 'GL_SGIX_fog_offset';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFragmentLightingSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIX_fragment_lighting';
    
    private FragmentColorMaterialSGIX_adr := GetProcAddress('glFragmentColorMaterialSGIX');
    private ntv_FragmentColorMaterialSGIX_1 := GetProcOrNil&<procedure(face: glTriangleFace; mode: glMaterialParameter)>(FragmentColorMaterialSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentColorMaterialSGIX(face: glTriangleFace; mode: glMaterialParameter) :=
      ntv_FragmentColorMaterialSGIX_1(face, mode);
    
    private FragmentLightfSGIX_adr := GetProcAddress('glFragmentLightfSGIX');
    private ntv_FragmentLightfSGIX_1 := GetProcOrNil&<procedure(light: glFragmentLightName; pname: glFragmentLightParameter; param: single)>(FragmentLightfSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightfSGIX(light: glFragmentLightName; pname: glFragmentLightParameter; param: single) :=
      ntv_FragmentLightfSGIX_1(light, pname, param);
    
    private FragmentLightfvSGIX_adr := GetProcAddress('glFragmentLightfvSGIX');
    private ntv_FragmentLightfvSGIX_1 := GetProcOrNil&<procedure(light: glFragmentLightName; pname: glFragmentLightParameter; var &params: single)>(FragmentLightfvSGIX_adr);
    private ntv_FragmentLightfvSGIX_2 := GetProcOrNil&<procedure(light: glFragmentLightName; pname: glFragmentLightParameter; &params: IntPtr)>(FragmentLightfvSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightfvSGIX(light: glFragmentLightName; pname: glFragmentLightParameter; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_FragmentLightfvSGIX_1(light, pname, &params[0]) else
        ntv_FragmentLightfvSGIX_1(light, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightfvSGIX(light: glFragmentLightName; pname: glFragmentLightParameter; var &params: single) :=
      ntv_FragmentLightfvSGIX_1(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightfvSGIX(light: glFragmentLightName; pname: glFragmentLightParameter; &params: IntPtr) :=
      ntv_FragmentLightfvSGIX_2(light, pname, &params);
    
    private FragmentLightiSGIX_adr := GetProcAddress('glFragmentLightiSGIX');
    private ntv_FragmentLightiSGIX_1 := GetProcOrNil&<procedure(light: glFragmentLightName; pname: glFragmentLightParameter; param: Int32)>(FragmentLightiSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightiSGIX(light: glFragmentLightName; pname: glFragmentLightParameter; param: Int32) :=
      ntv_FragmentLightiSGIX_1(light, pname, param);
    
    private FragmentLightivSGIX_adr := GetProcAddress('glFragmentLightivSGIX');
    private ntv_FragmentLightivSGIX_1 := GetProcOrNil&<procedure(light: glFragmentLightName; pname: glFragmentLightParameter; var &params: Int32)>(FragmentLightivSGIX_adr);
    private ntv_FragmentLightivSGIX_2 := GetProcOrNil&<procedure(light: glFragmentLightName; pname: glFragmentLightParameter; &params: IntPtr)>(FragmentLightivSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightivSGIX(light: glFragmentLightName; pname: glFragmentLightParameter; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_FragmentLightivSGIX_1(light, pname, &params[0]) else
        ntv_FragmentLightivSGIX_1(light, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightivSGIX(light: glFragmentLightName; pname: glFragmentLightParameter; var &params: Int32) :=
      ntv_FragmentLightivSGIX_1(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightivSGIX(light: glFragmentLightName; pname: glFragmentLightParameter; &params: IntPtr) :=
      ntv_FragmentLightivSGIX_2(light, pname, &params);
    
    private FragmentLightModelfSGIX_adr := GetProcAddress('glFragmentLightModelfSGIX');
    private ntv_FragmentLightModelfSGIX_1 := GetProcOrNil&<procedure(pname: glFragmentLightModelParameter; param: single)>(FragmentLightModelfSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelfSGIX(pname: glFragmentLightModelParameter; param: single) :=
      ntv_FragmentLightModelfSGIX_1(pname, param);
    
    private FragmentLightModelfvSGIX_adr := GetProcAddress('glFragmentLightModelfvSGIX');
    private ntv_FragmentLightModelfvSGIX_1 := GetProcOrNil&<procedure(pname: glFragmentLightModelParameter; var &params: single)>(FragmentLightModelfvSGIX_adr);
    private ntv_FragmentLightModelfvSGIX_2 := GetProcOrNil&<procedure(pname: glFragmentLightModelParameter; &params: IntPtr)>(FragmentLightModelfvSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelfvSGIX(pname: glFragmentLightModelParameter; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_FragmentLightModelfvSGIX_1(pname, &params[0]) else
        ntv_FragmentLightModelfvSGIX_1(pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelfvSGIX(pname: glFragmentLightModelParameter; var &params: single) :=
      ntv_FragmentLightModelfvSGIX_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelfvSGIX(pname: glFragmentLightModelParameter; &params: IntPtr) :=
      ntv_FragmentLightModelfvSGIX_2(pname, &params);
    
    private FragmentLightModeliSGIX_adr := GetProcAddress('glFragmentLightModeliSGIX');
    private ntv_FragmentLightModeliSGIX_1 := GetProcOrNil&<procedure(pname: glFragmentLightModelParameter; param: Int32)>(FragmentLightModeliSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModeliSGIX(pname: glFragmentLightModelParameter; param: Int32) :=
      ntv_FragmentLightModeliSGIX_1(pname, param);
    
    private FragmentLightModelivSGIX_adr := GetProcAddress('glFragmentLightModelivSGIX');
    private ntv_FragmentLightModelivSGIX_1 := GetProcOrNil&<procedure(pname: glFragmentLightModelParameter; var &params: Int32)>(FragmentLightModelivSGIX_adr);
    private ntv_FragmentLightModelivSGIX_2 := GetProcOrNil&<procedure(pname: glFragmentLightModelParameter; &params: IntPtr)>(FragmentLightModelivSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelivSGIX(pname: glFragmentLightModelParameter; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_FragmentLightModelivSGIX_1(pname, &params[0]) else
        ntv_FragmentLightModelivSGIX_1(pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelivSGIX(pname: glFragmentLightModelParameter; var &params: Int32) :=
      ntv_FragmentLightModelivSGIX_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelivSGIX(pname: glFragmentLightModelParameter; &params: IntPtr) :=
      ntv_FragmentLightModelivSGIX_2(pname, &params);
    
    private FragmentMaterialfSGIX_adr := GetProcAddress('glFragmentMaterialfSGIX');
    private ntv_FragmentMaterialfSGIX_1 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; param: single)>(FragmentMaterialfSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialfSGIX(face: glTriangleFace; pname: glMaterialParameter; param: single) :=
      ntv_FragmentMaterialfSGIX_1(face, pname, param);
    
    private FragmentMaterialfvSGIX_adr := GetProcAddress('glFragmentMaterialfvSGIX');
    private ntv_FragmentMaterialfvSGIX_1 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; var &params: single)>(FragmentMaterialfvSGIX_adr);
    private ntv_FragmentMaterialfvSGIX_2 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; &params: IntPtr)>(FragmentMaterialfvSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialfvSGIX(face: glTriangleFace; pname: glMaterialParameter; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_FragmentMaterialfvSGIX_1(face, pname, &params[0]) else
        ntv_FragmentMaterialfvSGIX_1(face, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialfvSGIX(face: glTriangleFace; pname: glMaterialParameter; var &params: single) :=
      ntv_FragmentMaterialfvSGIX_1(face, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialfvSGIX(face: glTriangleFace; pname: glMaterialParameter; &params: IntPtr) :=
      ntv_FragmentMaterialfvSGIX_2(face, pname, &params);
    
    private FragmentMaterialiSGIX_adr := GetProcAddress('glFragmentMaterialiSGIX');
    private ntv_FragmentMaterialiSGIX_1 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; param: Int32)>(FragmentMaterialiSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialiSGIX(face: glTriangleFace; pname: glMaterialParameter; param: Int32) :=
      ntv_FragmentMaterialiSGIX_1(face, pname, param);
    
    private FragmentMaterialivSGIX_adr := GetProcAddress('glFragmentMaterialivSGIX');
    private ntv_FragmentMaterialivSGIX_1 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; var &params: Int32)>(FragmentMaterialivSGIX_adr);
    private ntv_FragmentMaterialivSGIX_2 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; &params: IntPtr)>(FragmentMaterialivSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialivSGIX(face: glTriangleFace; pname: glMaterialParameter; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_FragmentMaterialivSGIX_1(face, pname, &params[0]) else
        ntv_FragmentMaterialivSGIX_1(face, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialivSGIX(face: glTriangleFace; pname: glMaterialParameter; var &params: Int32) :=
      ntv_FragmentMaterialivSGIX_1(face, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialivSGIX(face: glTriangleFace; pname: glMaterialParameter; &params: IntPtr) :=
      ntv_FragmentMaterialivSGIX_2(face, pname, &params);
    
    private GetFragmentLightfvSGIX_adr := GetProcAddress('glGetFragmentLightfvSGIX');
    private ntv_GetFragmentLightfvSGIX_1 := GetProcOrNil&<procedure(light: glFragmentLightName; pname: glFragmentLightParameter; var &params: single)>(GetFragmentLightfvSGIX_adr);
    private ntv_GetFragmentLightfvSGIX_2 := GetProcOrNil&<procedure(light: glFragmentLightName; pname: glFragmentLightParameter; &params: IntPtr)>(GetFragmentLightfvSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentLightfvSGIX(light: glFragmentLightName; pname: glFragmentLightParameter; var &params: single) :=
      ntv_GetFragmentLightfvSGIX_1(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentLightfvSGIX(light: glFragmentLightName; pname: glFragmentLightParameter; &params: IntPtr) :=
      ntv_GetFragmentLightfvSGIX_2(light, pname, &params);
    
    private GetFragmentLightivSGIX_adr := GetProcAddress('glGetFragmentLightivSGIX');
    private ntv_GetFragmentLightivSGIX_1 := GetProcOrNil&<procedure(light: glFragmentLightName; pname: glFragmentLightParameter; var &params: Int32)>(GetFragmentLightivSGIX_adr);
    private ntv_GetFragmentLightivSGIX_2 := GetProcOrNil&<procedure(light: glFragmentLightName; pname: glFragmentLightParameter; &params: IntPtr)>(GetFragmentLightivSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentLightivSGIX(light: glFragmentLightName; pname: glFragmentLightParameter; var &params: Int32) :=
      ntv_GetFragmentLightivSGIX_1(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentLightivSGIX(light: glFragmentLightName; pname: glFragmentLightParameter; &params: IntPtr) :=
      ntv_GetFragmentLightivSGIX_2(light, pname, &params);
    
    private GetFragmentMaterialfvSGIX_adr := GetProcAddress('glGetFragmentMaterialfvSGIX');
    private ntv_GetFragmentMaterialfvSGIX_1 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; var &params: single)>(GetFragmentMaterialfvSGIX_adr);
    private ntv_GetFragmentMaterialfvSGIX_2 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; &params: IntPtr)>(GetFragmentMaterialfvSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentMaterialfvSGIX(face: glTriangleFace; pname: glMaterialParameter; var &params: single) :=
      ntv_GetFragmentMaterialfvSGIX_1(face, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentMaterialfvSGIX(face: glTriangleFace; pname: glMaterialParameter; &params: IntPtr) :=
      ntv_GetFragmentMaterialfvSGIX_2(face, pname, &params);
    
    private GetFragmentMaterialivSGIX_adr := GetProcAddress('glGetFragmentMaterialivSGIX');
    private ntv_GetFragmentMaterialivSGIX_1 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; var &params: Int32)>(GetFragmentMaterialivSGIX_adr);
    private ntv_GetFragmentMaterialivSGIX_2 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; &params: IntPtr)>(GetFragmentMaterialivSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentMaterialivSGIX(face: glTriangleFace; pname: glMaterialParameter; var &params: Int32) :=
      ntv_GetFragmentMaterialivSGIX_1(face, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentMaterialivSGIX(face: glTriangleFace; pname: glMaterialParameter; &params: IntPtr) :=
      ntv_GetFragmentMaterialivSGIX_2(face, pname, &params);
    
    private LightEnviSGIX_adr := GetProcAddress('glLightEnviSGIX');
    private ntv_LightEnviSGIX_1 := GetProcOrNil&<procedure(pname: glLightEnvParameter; param: glLightEnvMode)>(LightEnviSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightEnviSGIX(pname: glLightEnvParameter; param: glLightEnvMode) :=
      ntv_LightEnviSGIX_1(pname, param);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glFramezoomSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIX_framezoom';
    
    private FrameZoomSGIX_adr := GetProcAddress('glFrameZoomSGIX');
    private ntv_FrameZoomSGIX_1 := GetProcOrNil&<procedure(factor: Int32)>(FrameZoomSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrameZoomSGIX(factor: Int32) :=
      ntv_FrameZoomSGIX_1(factor);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glIglooInterfaceSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIX_igloo_interface';
    
    private IglooInterfaceSGIX_adr := GetProcAddress('glIglooInterfaceSGIX');
    private ntv_IglooInterfaceSGIX_1 := GetProcOrNil&<procedure(pname: DummyEnum; &params: IntPtr)>(IglooInterfaceSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IglooInterfaceSGIX(pname: DummyEnum; &params: IntPtr) :=
      ntv_IglooInterfaceSGIX_1(pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glInstrumentsSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIX_instruments';
    
    private GetInstrumentsSGIX_adr := GetProcAddress('glGetInstrumentsSGIX');
    private ntv_GetInstrumentsSGIX_1 := GetProcOrNil&<function: Int32>(GetInstrumentsSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetInstrumentsSGIX: Int32 :=
      ntv_GetInstrumentsSGIX_1;
    
    private InstrumentsBufferSGIX_adr := GetProcAddress('glInstrumentsBufferSGIX');
    private ntv_InstrumentsBufferSGIX_1 := GetProcOrNil&<procedure(size: Int32; var buffer: Int32)>(InstrumentsBufferSGIX_adr);
    private ntv_InstrumentsBufferSGIX_2 := GetProcOrNil&<procedure(size: Int32; buffer: IntPtr)>(InstrumentsBufferSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InstrumentsBufferSGIX(size: Int32; buffer: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (buffer<>nil) and (buffer.Length<>0) then
        ntv_InstrumentsBufferSGIX_1(size, buffer[0]) else
        ntv_InstrumentsBufferSGIX_1(size, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InstrumentsBufferSGIX(size: Int32; var buffer: Int32) :=
      ntv_InstrumentsBufferSGIX_1(size, buffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InstrumentsBufferSGIX(size: Int32; buffer: IntPtr) :=
      ntv_InstrumentsBufferSGIX_2(size, buffer);
    
    private PollInstrumentsSGIX_adr := GetProcAddress('glPollInstrumentsSGIX');
    private ntv_PollInstrumentsSGIX_1 := GetProcOrNil&<function(var marker_p: Int32): Int32>(PollInstrumentsSGIX_adr);
    private ntv_PollInstrumentsSGIX_2 := GetProcOrNil&<function(marker_p: IntPtr): Int32>(PollInstrumentsSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollInstrumentsSGIX(marker_p: array of Int32): Int32;
    type PInt32 = ^Int32;
    begin
      Result := if (marker_p<>nil) and (marker_p.Length<>0) then
        ntv_PollInstrumentsSGIX_1(marker_p[0]) else
        ntv_PollInstrumentsSGIX_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollInstrumentsSGIX(var marker_p: Int32): Int32 :=
      ntv_PollInstrumentsSGIX_1(marker_p);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollInstrumentsSGIX(marker_p: IntPtr): Int32 :=
      ntv_PollInstrumentsSGIX_2(marker_p);
    
    private ReadInstrumentsSGIX_adr := GetProcAddress('glReadInstrumentsSGIX');
    private ntv_ReadInstrumentsSGIX_1 := GetProcOrNil&<procedure(marker: Int32)>(ReadInstrumentsSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadInstrumentsSGIX(marker: Int32) :=
      ntv_ReadInstrumentsSGIX_1(marker);
    
    private StartInstrumentsSGIX_adr := GetProcAddress('glStartInstrumentsSGIX');
    private ntv_StartInstrumentsSGIX_1 := GetProcOrNil&<procedure>(StartInstrumentsSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StartInstrumentsSGIX :=
      ntv_StartInstrumentsSGIX_1;
    
    private StopInstrumentsSGIX_adr := GetProcAddress('glStopInstrumentsSGIX');
    private ntv_StopInstrumentsSGIX_1 := GetProcOrNil&<procedure(marker: Int32)>(StopInstrumentsSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StopInstrumentsSGIX(marker: Int32) :=
      ntv_StopInstrumentsSGIX_1(marker);
    
  end;
  
  ///
  glInterlaceSGIX = static class
    public const _ExtStr = 'GL_SGIX_interlace';
  end;
  
  ///
  glIrInstrument1SGIX = static class
    public const _ExtStr = 'GL_SGIX_ir_instrument1';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glListPrioritySGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIX_list_priority';
    
    private GetListParameterfvSGIX_adr := GetProcAddress('glGetListParameterfvSGIX');
    private ntv_GetListParameterfvSGIX_1 := GetProcOrNil&<procedure(list: gl_display_list; pname: glListParameterName; var &params: single)>(GetListParameterfvSGIX_adr);
    private ntv_GetListParameterfvSGIX_2 := GetProcOrNil&<procedure(list: gl_display_list; pname: glListParameterName; &params: IntPtr)>(GetListParameterfvSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetListParameterfvSGIX(list: gl_display_list; pname: glListParameterName; var &params: single) :=
      ntv_GetListParameterfvSGIX_1(list, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetListParameterfvSGIX(list: gl_display_list; pname: glListParameterName; &params: IntPtr) :=
      ntv_GetListParameterfvSGIX_2(list, pname, &params);
    
    private GetListParameterivSGIX_adr := GetProcAddress('glGetListParameterivSGIX');
    private ntv_GetListParameterivSGIX_1 := GetProcOrNil&<procedure(list: gl_display_list; pname: glListParameterName; var &params: Int32)>(GetListParameterivSGIX_adr);
    private ntv_GetListParameterivSGIX_2 := GetProcOrNil&<procedure(list: gl_display_list; pname: glListParameterName; &params: IntPtr)>(GetListParameterivSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetListParameterivSGIX(list: gl_display_list; pname: glListParameterName; var &params: Int32) :=
      ntv_GetListParameterivSGIX_1(list, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetListParameterivSGIX(list: gl_display_list; pname: glListParameterName; &params: IntPtr) :=
      ntv_GetListParameterivSGIX_2(list, pname, &params);
    
    private ListParameterfSGIX_adr := GetProcAddress('glListParameterfSGIX');
    private ntv_ListParameterfSGIX_1 := GetProcOrNil&<procedure(list: gl_display_list; pname: glListParameterName; param: single)>(ListParameterfSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterfSGIX(list: gl_display_list; pname: glListParameterName; param: single) :=
      ntv_ListParameterfSGIX_1(list, pname, param);
    
    private ListParameterfvSGIX_adr := GetProcAddress('glListParameterfvSGIX');
    private ntv_ListParameterfvSGIX_1 := GetProcOrNil&<procedure(list: gl_display_list; pname: glListParameterName; var &params: single)>(ListParameterfvSGIX_adr);
    private ntv_ListParameterfvSGIX_2 := GetProcOrNil&<procedure(list: gl_display_list; pname: glListParameterName; &params: IntPtr)>(ListParameterfvSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterfvSGIX(list: gl_display_list; pname: glListParameterName; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ListParameterfvSGIX_1(list, pname, &params[0]) else
        ntv_ListParameterfvSGIX_1(list, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterfvSGIX(list: gl_display_list; pname: glListParameterName; var &params: single) :=
      ntv_ListParameterfvSGIX_1(list, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterfvSGIX(list: gl_display_list; pname: glListParameterName; &params: IntPtr) :=
      ntv_ListParameterfvSGIX_2(list, pname, &params);
    
    private ListParameteriSGIX_adr := GetProcAddress('glListParameteriSGIX');
    private ntv_ListParameteriSGIX_1 := GetProcOrNil&<procedure(list: gl_display_list; pname: glListParameterName; param: Int32)>(ListParameteriSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameteriSGIX(list: gl_display_list; pname: glListParameterName; param: Int32) :=
      ntv_ListParameteriSGIX_1(list, pname, param);
    
    private ListParameterivSGIX_adr := GetProcAddress('glListParameterivSGIX');
    private ntv_ListParameterivSGIX_1 := GetProcOrNil&<procedure(list: gl_display_list; pname: glListParameterName; var &params: Int32)>(ListParameterivSGIX_adr);
    private ntv_ListParameterivSGIX_2 := GetProcOrNil&<procedure(list: gl_display_list; pname: glListParameterName; &params: IntPtr)>(ListParameterivSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterivSGIX(list: gl_display_list; pname: glListParameterName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_ListParameterivSGIX_1(list, pname, &params[0]) else
        ntv_ListParameterivSGIX_1(list, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterivSGIX(list: gl_display_list; pname: glListParameterName; var &params: Int32) :=
      ntv_ListParameterivSGIX_1(list, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterivSGIX(list: gl_display_list; pname: glListParameterName; &params: IntPtr) :=
      ntv_ListParameterivSGIX_2(list, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPixelTextureSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIX_pixel_texture';
    
    private PixelTexGenSGIX_adr := GetProcAddress('glPixelTexGenSGIX');
    private ntv_PixelTexGenSGIX_1 := GetProcOrNil&<procedure(mode: glPixelTexGenMode)>(PixelTexGenSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenSGIX(mode: glPixelTexGenMode) :=
      ntv_PixelTexGenSGIX_1(mode);
    
  end;
  
  ///
  glPixelTilesSGIX = static class
    public const _ExtStr = 'GL_SGIX_pixel_tiles';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glPolynomialFfdSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIX_polynomial_ffd';
    
    private DeformationMap3dSGIX_adr := GetProcAddress('glDeformationMap3dSGIX');
    private ntv_DeformationMap3dSGIX_1 := GetProcOrNil&<procedure(target: glFfdTarget; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; w1: double; w2: double; wstride: Int32; worder: Int32; var points: double)>(DeformationMap3dSGIX_adr);
    private ntv_DeformationMap3dSGIX_2 := GetProcOrNil&<procedure(target: glFfdTarget; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; w1: double; w2: double; wstride: Int32; worder: Int32; points: IntPtr)>(DeformationMap3dSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3dSGIX(target: glFfdTarget; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; w1: double; w2: double; wstride: Int32; worder: Int32; points: array of double);
    type PDouble = ^double;
    begin
      if (points<>nil) and (points.Length<>0) then
        ntv_DeformationMap3dSGIX_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points[0]) else
        ntv_DeformationMap3dSGIX_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3dSGIX(target: glFfdTarget; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; w1: double; w2: double; wstride: Int32; worder: Int32; var points: double) :=
      ntv_DeformationMap3dSGIX_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3dSGIX(target: glFfdTarget; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; w1: double; w2: double; wstride: Int32; worder: Int32; points: IntPtr) :=
      ntv_DeformationMap3dSGIX_2(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    
    private DeformationMap3fSGIX_adr := GetProcAddress('glDeformationMap3fSGIX');
    private ntv_DeformationMap3fSGIX_1 := GetProcOrNil&<procedure(target: glFfdTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; var points: single)>(DeformationMap3fSGIX_adr);
    private ntv_DeformationMap3fSGIX_2 := GetProcOrNil&<procedure(target: glFfdTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; points: IntPtr)>(DeformationMap3fSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3fSGIX(target: glFfdTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; points: array of single);
    type PSingle = ^single;
    begin
      if (points<>nil) and (points.Length<>0) then
        ntv_DeformationMap3fSGIX_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points[0]) else
        ntv_DeformationMap3fSGIX_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3fSGIX(target: glFfdTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; var points: single) :=
      ntv_DeformationMap3fSGIX_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3fSGIX(target: glFfdTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; points: IntPtr) :=
      ntv_DeformationMap3fSGIX_2(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    
    private DeformSGIX_adr := GetProcAddress('glDeformSGIX');
    private ntv_DeformSGIX_1 := GetProcOrNil&<procedure(mask: glFfdMask)>(DeformSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformSGIX(mask: glFfdMask) :=
      ntv_DeformSGIX_1(mask);
    
    private LoadIdentityDeformationMapSGIX_adr := GetProcAddress('glLoadIdentityDeformationMapSGIX');
    private ntv_LoadIdentityDeformationMapSGIX_1 := GetProcOrNil&<procedure(mask: glFfdMask)>(LoadIdentityDeformationMapSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadIdentityDeformationMapSGIX(mask: glFfdMask) :=
      ntv_LoadIdentityDeformationMapSGIX_1(mask);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glReferencePlaneSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIX_reference_plane';
    
    private ReferencePlaneSGIX_adr := GetProcAddress('glReferencePlaneSGIX');
    private ntv_ReferencePlaneSGIX_1 := GetProcOrNil&<procedure(var equation: double)>(ReferencePlaneSGIX_adr);
    private ntv_ReferencePlaneSGIX_2 := GetProcOrNil&<procedure(equation: IntPtr)>(ReferencePlaneSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReferencePlaneSGIX(equation: array of double);
    type PDouble = ^double;
    begin
      if (equation<>nil) and (equation.Length<>0) then
        ntv_ReferencePlaneSGIX_1(equation[0]) else
        ntv_ReferencePlaneSGIX_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReferencePlaneSGIX(var equation: double) :=
      ntv_ReferencePlaneSGIX_1(equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReferencePlaneSGIX(equation: IntPtr) :=
      ntv_ReferencePlaneSGIX_2(equation);
    
  end;
  
  ///
  glResampleSGIX = static class
    public const _ExtStr = 'GL_SGIX_resample';
  end;
  
  ///
  glScalebiasHintSGIX = static class
    public const _ExtStr = 'GL_SGIX_scalebias_hint';
  end;
  
  ///
  glShadowSGIX = static class
    public const _ExtStr = 'GL_SGIX_shadow';
  end;
  
  ///
  glShadowAmbientSGIX = static class
    public const _ExtStr = 'GL_SGIX_shadow_ambient';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glSpriteSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIX_sprite';
    
    private SpriteParameterfSGIX_adr := GetProcAddress('glSpriteParameterfSGIX');
    private ntv_SpriteParameterfSGIX_1 := GetProcOrNil&<procedure(pname: glSpriteParameterName; param: single)>(SpriteParameterfSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterfSGIX(pname: glSpriteParameterName; param: single) :=
      ntv_SpriteParameterfSGIX_1(pname, param);
    
    private SpriteParameterfvSGIX_adr := GetProcAddress('glSpriteParameterfvSGIX');
    private ntv_SpriteParameterfvSGIX_1 := GetProcOrNil&<procedure(pname: glSpriteParameterName; var &params: single)>(SpriteParameterfvSGIX_adr);
    private ntv_SpriteParameterfvSGIX_2 := GetProcOrNil&<procedure(pname: glSpriteParameterName; &params: IntPtr)>(SpriteParameterfvSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterfvSGIX(pname: glSpriteParameterName; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_SpriteParameterfvSGIX_1(pname, &params[0]) else
        ntv_SpriteParameterfvSGIX_1(pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterfvSGIX(pname: glSpriteParameterName; var &params: single) :=
      ntv_SpriteParameterfvSGIX_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterfvSGIX(pname: glSpriteParameterName; &params: IntPtr) :=
      ntv_SpriteParameterfvSGIX_2(pname, &params);
    
    private SpriteParameteriSGIX_adr := GetProcAddress('glSpriteParameteriSGIX');
    private ntv_SpriteParameteriSGIX_1 := GetProcOrNil&<procedure(pname: glSpriteParameterName; param: glSpriteMode)>(SpriteParameteriSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameteriSGIX(pname: glSpriteParameterName; param: glSpriteMode) :=
      ntv_SpriteParameteriSGIX_1(pname, param);
    
    private SpriteParameterivSGIX_adr := GetProcAddress('glSpriteParameterivSGIX');
    private ntv_SpriteParameterivSGIX_1 := GetProcOrNil&<procedure(pname: glSpriteParameterName; var &params: glSpriteMode)>(SpriteParameterivSGIX_adr);
    private ntv_SpriteParameterivSGIX_2 := GetProcOrNil&<procedure(pname: glSpriteParameterName; &params: IntPtr)>(SpriteParameterivSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterivSGIX(pname: glSpriteParameterName; &params: array of glSpriteMode);
    type PGlSpriteMode = ^glSpriteMode;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_SpriteParameterivSGIX_1(pname, &params[0]) else
        ntv_SpriteParameterivSGIX_1(pname, PGlSpriteMode(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterivSGIX(pname: glSpriteParameterName; var &params: glSpriteMode) :=
      ntv_SpriteParameterivSGIX_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterivSGIX(pname: glSpriteParameterName; &params: IntPtr) :=
      ntv_SpriteParameterivSGIX_2(pname, &params);
    
  end;
  
  ///
  glSubsampleSGIX = static class
    public const _ExtStr = 'GL_SGIX_subsample';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTagSampleBufferSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SGIX_tag_sample_buffer';
    
    private TagSampleBufferSGIX_adr := GetProcAddress('glTagSampleBufferSGIX');
    private ntv_TagSampleBufferSGIX_1 := GetProcOrNil&<procedure>(TagSampleBufferSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TagSampleBufferSGIX :=
      ntv_TagSampleBufferSGIX_1;
    
  end;
  
  ///
  glTextureAddEnvSGIX = static class
    public const _ExtStr = 'GL_SGIX_texture_add_env';
  end;
  
  ///
  glTextureCoordinateClampSGIX = static class
    public const _ExtStr = 'GL_SGIX_texture_coordinate_clamp';
  end;
  
  ///
  glTextureLodBiasSGIX = static class
    public const _ExtStr = 'GL_SGIX_texture_lod_bias';
  end;
  
  ///
  glTextureMultiBufferSGIX = static class
    public const _ExtStr = 'GL_SGIX_texture_multi_buffer';
  end;
  
  ///
  glTextureScaleBiasSGIX = static class
    public const _ExtStr = 'GL_SGIX_texture_scale_bias';
  end;
  
  ///
  glVertexPreclipSGIX = static class
    public const _ExtStr = 'GL_SGIX_vertex_preclip';
  end;
  
  ///
  glYcrcbSGIX = static class
    public const _ExtStr = 'GL_SGIX_ycrcb';
  end;
  
  ///
  glYcrcbSubsampleSGIX = static class
    public const _ExtStr = 'GL_SGIX_ycrcb_subsample';
  end;
  
  ///
  glYcrcbaSGIX = static class
    public const _ExtStr = 'GL_SGIX_ycrcba';
  end;
  
  ///
  glConvolutionBorderModesSUN = static class
    public const _ExtStr = 'GL_SUN_convolution_border_modes';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glGlobalAlphaSUN = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SUN_global_alpha';
    
    private GlobalAlphaFactorbSUN_adr := GetProcAddress('glGlobalAlphaFactorbSUN');
    private ntv_GlobalAlphaFactorbSUN_1 := GetProcOrNil&<procedure(factor: SByte)>(GlobalAlphaFactorbSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorbSUN(factor: SByte) :=
      ntv_GlobalAlphaFactorbSUN_1(factor);
    
    private GlobalAlphaFactorsSUN_adr := GetProcAddress('glGlobalAlphaFactorsSUN');
    private ntv_GlobalAlphaFactorsSUN_1 := GetProcOrNil&<procedure(factor: Int16)>(GlobalAlphaFactorsSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorsSUN(factor: Int16) :=
      ntv_GlobalAlphaFactorsSUN_1(factor);
    
    private GlobalAlphaFactoriSUN_adr := GetProcAddress('glGlobalAlphaFactoriSUN');
    private ntv_GlobalAlphaFactoriSUN_1 := GetProcOrNil&<procedure(factor: Int32)>(GlobalAlphaFactoriSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactoriSUN(factor: Int32) :=
      ntv_GlobalAlphaFactoriSUN_1(factor);
    
    private GlobalAlphaFactorfSUN_adr := GetProcAddress('glGlobalAlphaFactorfSUN');
    private ntv_GlobalAlphaFactorfSUN_1 := GetProcOrNil&<procedure(factor: single)>(GlobalAlphaFactorfSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorfSUN(factor: single) :=
      ntv_GlobalAlphaFactorfSUN_1(factor);
    
    private GlobalAlphaFactordSUN_adr := GetProcAddress('glGlobalAlphaFactordSUN');
    private ntv_GlobalAlphaFactordSUN_1 := GetProcOrNil&<procedure(factor: double)>(GlobalAlphaFactordSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactordSUN(factor: double) :=
      ntv_GlobalAlphaFactordSUN_1(factor);
    
    private GlobalAlphaFactorubSUN_adr := GetProcAddress('glGlobalAlphaFactorubSUN');
    private ntv_GlobalAlphaFactorubSUN_1 := GetProcOrNil&<procedure(factor: Byte)>(GlobalAlphaFactorubSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorubSUN(factor: Byte) :=
      ntv_GlobalAlphaFactorubSUN_1(factor);
    
    private GlobalAlphaFactorusSUN_adr := GetProcAddress('glGlobalAlphaFactorusSUN');
    private ntv_GlobalAlphaFactorusSUN_1 := GetProcOrNil&<procedure(factor: UInt16)>(GlobalAlphaFactorusSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorusSUN(factor: UInt16) :=
      ntv_GlobalAlphaFactorusSUN_1(factor);
    
    private GlobalAlphaFactoruiSUN_adr := GetProcAddress('glGlobalAlphaFactoruiSUN');
    private ntv_GlobalAlphaFactoruiSUN_1 := GetProcOrNil&<procedure(factor: UInt32)>(GlobalAlphaFactoruiSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactoruiSUN(factor: UInt32) :=
      ntv_GlobalAlphaFactoruiSUN_1(factor);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glMeshArraySUN = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SUN_mesh_array';
    
    private DrawMeshArraysSUN_adr := GetProcAddress('glDrawMeshArraysSUN');
    private ntv_DrawMeshArraysSUN_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; first: Int32; count: Int32; width: Int32)>(DrawMeshArraysSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawMeshArraysSUN(mode: glPrimitiveType; first: Int32; count: Int32; width: Int32) :=
      ntv_DrawMeshArraysSUN_1(mode, first, count, width);
    
  end;
  
  ///
  glSliceAccumSUN = static class
    public const _ExtStr = 'GL_SUN_slice_accum';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glTriangleListSUN = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SUN_triangle_list';
    
    private ReplacementCodeuiSUN_adr := GetProcAddress('glReplacementCodeuiSUN');
    private ntv_ReplacementCodeuiSUN_1 := GetProcOrNil&<procedure(code: glTriangleList)>(ReplacementCodeuiSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiSUN(code: glTriangleList) :=
      ntv_ReplacementCodeuiSUN_1(code);
    
    private ReplacementCodeusSUN_adr := GetProcAddress('glReplacementCodeusSUN');
    private ntv_ReplacementCodeusSUN_1 := GetProcOrNil&<procedure(code: UInt16)>(ReplacementCodeusSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeusSUN(code: UInt16) :=
      ntv_ReplacementCodeusSUN_1(code);
    
    private ReplacementCodeubSUN_adr := GetProcAddress('glReplacementCodeubSUN');
    private ntv_ReplacementCodeubSUN_1 := GetProcOrNil&<procedure(code: Byte)>(ReplacementCodeubSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeubSUN(code: Byte) :=
      ntv_ReplacementCodeubSUN_1(code);
    
    private ReplacementCodeuivSUN_adr := GetProcAddress('glReplacementCodeuivSUN');
    private ntv_ReplacementCodeuivSUN_1 := GetProcOrNil&<procedure(var code: glTriangleList)>(ReplacementCodeuivSUN_adr);
    private ntv_ReplacementCodeuivSUN_2 := GetProcOrNil&<procedure(code: IntPtr)>(ReplacementCodeuivSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuivSUN(code: array of glTriangleList);
    type PGlTriangleList = ^glTriangleList;
    begin
      if (code<>nil) and (code.Length<>0) then
        ntv_ReplacementCodeuivSUN_1(code[0]) else
        ntv_ReplacementCodeuivSUN_1(PGlTriangleList(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuivSUN(var code: glTriangleList) :=
      ntv_ReplacementCodeuivSUN_1(code);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuivSUN(code: IntPtr) :=
      ntv_ReplacementCodeuivSUN_2(code);
    
    private ReplacementCodeusvSUN_adr := GetProcAddress('glReplacementCodeusvSUN');
    private ntv_ReplacementCodeusvSUN_1 := GetProcOrNil&<procedure(var code: UInt16)>(ReplacementCodeusvSUN_adr);
    private ntv_ReplacementCodeusvSUN_2 := GetProcOrNil&<procedure(code: IntPtr)>(ReplacementCodeusvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeusvSUN(code: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (code<>nil) and (code.Length<>0) then
        ntv_ReplacementCodeusvSUN_1(code[0]) else
        ntv_ReplacementCodeusvSUN_1(PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeusvSUN(var code: UInt16) :=
      ntv_ReplacementCodeusvSUN_1(code);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeusvSUN(code: IntPtr) :=
      ntv_ReplacementCodeusvSUN_2(code);
    
    private ReplacementCodeubvSUN_adr := GetProcAddress('glReplacementCodeubvSUN');
    private ntv_ReplacementCodeubvSUN_1 := GetProcOrNil&<procedure(var code: Byte)>(ReplacementCodeubvSUN_adr);
    private ntv_ReplacementCodeubvSUN_2 := GetProcOrNil&<procedure(code: IntPtr)>(ReplacementCodeubvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeubvSUN(code: array of Byte);
    type PByte = ^Byte;
    begin
      if (code<>nil) and (code.Length<>0) then
        ntv_ReplacementCodeubvSUN_1(code[0]) else
        ntv_ReplacementCodeubvSUN_1(PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeubvSUN(var code: Byte) :=
      ntv_ReplacementCodeubvSUN_1(code);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeubvSUN(code: IntPtr) :=
      ntv_ReplacementCodeubvSUN_2(code);
    
    private ReplacementCodePointerSUN_adr := GetProcAddress('glReplacementCodePointerSUN');
    private ntv_ReplacementCodePointerSUN_1 := GetProcOrNil&<procedure(&type: glReplacementCodeType; stride: Int32; var pointer: IntPtr)>(ReplacementCodePointerSUN_adr);
    private ntv_ReplacementCodePointerSUN_2 := GetProcOrNil&<procedure(&type: glReplacementCodeType; stride: Int32; pointer: pointer)>(ReplacementCodePointerSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodePointerSUN(&type: glReplacementCodeType; stride: Int32; pointer: array of IntPtr);
    type PIntPtr = ^IntPtr;
    begin
      if (pointer<>nil) and (pointer.Length<>0) then
        ntv_ReplacementCodePointerSUN_1(&type, stride, pointer[0]) else
        ntv_ReplacementCodePointerSUN_1(&type, stride, PIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodePointerSUN(&type: glReplacementCodeType; stride: Int32; var pointer: IntPtr) :=
      ntv_ReplacementCodePointerSUN_1(&type, stride, pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodePointerSUN(&type: glReplacementCodeType; stride: Int32; pointer: pointer) :=
      ntv_ReplacementCodePointerSUN_2(&type, stride, pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glVertexSUN = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SUN_vertex';
    
    private Color4ubVertex2fSUN_adr := GetProcAddress('glColor4ubVertex2fSUN');
    private ntv_Color4ubVertex2fSUN_1 := GetProcOrNil&<procedure(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single)>(Color4ubVertex2fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fSUN(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single) :=
      ntv_Color4ubVertex2fSUN_1(r, g, b, a, x, y);
    
    private Color4ubVertex2fvSUN_adr := GetProcAddress('glColor4ubVertex2fvSUN');
    private ntv_Color4ubVertex2fvSUN_1 := GetProcOrNil&<procedure(var c: Byte; var v: single)>(Color4ubVertex2fvSUN_adr);
    private ntv_Color4ubVertex2fvSUN_2 := GetProcOrNil&<procedure(var c: Vec4ub; var v: Vec2f)>(Color4ubVertex2fvSUN_adr);
    private ntv_Color4ubVertex2fvSUN_3 := GetProcOrNil&<procedure(c: IntPtr; v: IntPtr)>(Color4ubVertex2fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(c: array of Byte; v: array of single);
    type PByte = ^Byte;
    type PSingle = ^single;
    begin
      if (c<>nil) and (c.Length<>0) then
        if (v<>nil) and (v.Length<>0) then
          ntv_Color4ubVertex2fvSUN_1(c[0], v[0]) else
          ntv_Color4ubVertex2fvSUN_1(c[0], PSingle(nil)^) else
        if (v<>nil) and (v.Length<>0) then
          ntv_Color4ubVertex2fvSUN_1(PByte(nil)^, v[0]) else
          ntv_Color4ubVertex2fvSUN_1(PByte(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(var c: Vec4ub; var v: Vec2f) :=
      ntv_Color4ubVertex2fvSUN_2(c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(var c: Byte; var v: single) :=
      ntv_Color4ubVertex2fvSUN_1(c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(c: IntPtr; v: IntPtr) :=
      ntv_Color4ubVertex2fvSUN_3(c, v);
    
    private Color4ubVertex3fSUN_adr := GetProcAddress('glColor4ubVertex3fSUN');
    private ntv_Color4ubVertex3fSUN_1 := GetProcOrNil&<procedure(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single)>(Color4ubVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fSUN(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single) :=
      ntv_Color4ubVertex3fSUN_1(r, g, b, a, x, y, z);
    
    private Color4ubVertex3fvSUN_adr := GetProcAddress('glColor4ubVertex3fvSUN');
    private ntv_Color4ubVertex3fvSUN_1 := GetProcOrNil&<procedure(var c: Byte; var v: single)>(Color4ubVertex3fvSUN_adr);
    private ntv_Color4ubVertex3fvSUN_2 := GetProcOrNil&<procedure(var c: Vec4ub; var v: Vec3f)>(Color4ubVertex3fvSUN_adr);
    private ntv_Color4ubVertex3fvSUN_3 := GetProcOrNil&<procedure(c: IntPtr; v: IntPtr)>(Color4ubVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(c: array of Byte; v: array of single);
    type PByte = ^Byte;
    type PSingle = ^single;
    begin
      if (c<>nil) and (c.Length<>0) then
        if (v<>nil) and (v.Length<>0) then
          ntv_Color4ubVertex3fvSUN_1(c[0], v[0]) else
          ntv_Color4ubVertex3fvSUN_1(c[0], PSingle(nil)^) else
        if (v<>nil) and (v.Length<>0) then
          ntv_Color4ubVertex3fvSUN_1(PByte(nil)^, v[0]) else
          ntv_Color4ubVertex3fvSUN_1(PByte(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(var c: Vec4ub; var v: Vec3f) :=
      ntv_Color4ubVertex3fvSUN_2(c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(var c: Byte; var v: single) :=
      ntv_Color4ubVertex3fvSUN_1(c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(c: IntPtr; v: IntPtr) :=
      ntv_Color4ubVertex3fvSUN_3(c, v);
    
    private Color3fVertex3fSUN_adr := GetProcAddress('glColor3fVertex3fSUN');
    private ntv_Color3fVertex3fSUN_1 := GetProcOrNil&<procedure(r: single; g: single; b: single; x: single; y: single; z: single)>(Color3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fSUN(r: single; g: single; b: single; x: single; y: single; z: single) :=
      ntv_Color3fVertex3fSUN_1(r, g, b, x, y, z);
    
    private Color3fVertex3fvSUN_adr := GetProcAddress('glColor3fVertex3fvSUN');
    private ntv_Color3fVertex3fvSUN_1 := GetProcOrNil&<procedure(var c: single; var v: single)>(Color3fVertex3fvSUN_adr);
    private ntv_Color3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var c: Vec3f; var v: Vec3f)>(Color3fVertex3fvSUN_adr);
    private ntv_Color3fVertex3fvSUN_3 := GetProcOrNil&<procedure(c: IntPtr; v: IntPtr)>(Color3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(c: array of single; v: array of single);
    type PSingle = ^single;
    begin
      if (c<>nil) and (c.Length<>0) then
        if (v<>nil) and (v.Length<>0) then
          ntv_Color3fVertex3fvSUN_1(c[0], v[0]) else
          ntv_Color3fVertex3fvSUN_1(c[0], PSingle(nil)^) else
        if (v<>nil) and (v.Length<>0) then
          ntv_Color3fVertex3fvSUN_1(PSingle(nil)^, v[0]) else
          ntv_Color3fVertex3fvSUN_1(PSingle(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(var c: Vec3f; var v: Vec3f) :=
      ntv_Color3fVertex3fvSUN_2(c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(var c: single; var v: single) :=
      ntv_Color3fVertex3fvSUN_1(c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(c: IntPtr; v: IntPtr) :=
      ntv_Color3fVertex3fvSUN_3(c, v);
    
    private Normal3fVertex3fSUN_adr := GetProcAddress('glNormal3fVertex3fSUN');
    private ntv_Normal3fVertex3fSUN_1 := GetProcOrNil&<procedure(nx: single; ny: single; nz: single; x: single; y: single; z: single)>(Normal3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fSUN(nx: single; ny: single; nz: single; x: single; y: single; z: single) :=
      ntv_Normal3fVertex3fSUN_1(nx, ny, nz, x, y, z);
    
    private Normal3fVertex3fvSUN_adr := GetProcAddress('glNormal3fVertex3fvSUN');
    private ntv_Normal3fVertex3fvSUN_1 := GetProcOrNil&<procedure(var n: single; var v: single)>(Normal3fVertex3fvSUN_adr);
    private ntv_Normal3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var n: Vec3f; var v: Vec3f)>(Normal3fVertex3fvSUN_adr);
    private ntv_Normal3fVertex3fvSUN_3 := GetProcOrNil&<procedure(n: IntPtr; v: IntPtr)>(Normal3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(n: array of single; v: array of single);
    type PSingle = ^single;
    begin
      if (n<>nil) and (n.Length<>0) then
        if (v<>nil) and (v.Length<>0) then
          ntv_Normal3fVertex3fvSUN_1(n[0], v[0]) else
          ntv_Normal3fVertex3fvSUN_1(n[0], PSingle(nil)^) else
        if (v<>nil) and (v.Length<>0) then
          ntv_Normal3fVertex3fvSUN_1(PSingle(nil)^, v[0]) else
          ntv_Normal3fVertex3fvSUN_1(PSingle(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(var n: Vec3f; var v: Vec3f) :=
      ntv_Normal3fVertex3fvSUN_2(n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(var n: single; var v: single) :=
      ntv_Normal3fVertex3fvSUN_1(n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(n: IntPtr; v: IntPtr) :=
      ntv_Normal3fVertex3fvSUN_3(n, v);
    
    private Color4fNormal3fVertex3fSUN_adr := GetProcAddress('glColor4fNormal3fVertex3fSUN');
    private ntv_Color4fNormal3fVertex3fSUN_1 := GetProcOrNil&<procedure(r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(Color4fNormal3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fSUN(r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) :=
      ntv_Color4fNormal3fVertex3fSUN_1(r, g, b, a, nx, ny, nz, x, y, z);
    
    private Color4fNormal3fVertex3fvSUN_adr := GetProcAddress('glColor4fNormal3fVertex3fvSUN');
    private ntv_Color4fNormal3fVertex3fvSUN_1 := GetProcOrNil&<procedure(var c: single; var n: single; var v: single)>(Color4fNormal3fVertex3fvSUN_adr);
    private ntv_Color4fNormal3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var c: Vec4f; var n: Vec3f; var v: Vec3f)>(Color4fNormal3fVertex3fvSUN_adr);
    private ntv_Color4fNormal3fVertex3fvSUN_3 := GetProcOrNil&<procedure(c: IntPtr; n: IntPtr; v: IntPtr)>(Color4fNormal3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: array of single; n: array of single; v: array of single);
    type PSingle = ^single;
    begin
      if (c<>nil) and (c.Length<>0) then
        if (v<>nil) and (v.Length<>0) then
          if (n<>nil) and (n.Length<>0) then
            ntv_Color4fNormal3fVertex3fvSUN_1(c[0], n[0], v[0]) else
            ntv_Color4fNormal3fVertex3fvSUN_1(c[0], PSingle(nil)^, v[0]) else
          if (n<>nil) and (n.Length<>0) then
            ntv_Color4fNormal3fVertex3fvSUN_1(c[0], n[0], PSingle(nil)^) else
            ntv_Color4fNormal3fVertex3fvSUN_1(c[0], PSingle(nil)^, PSingle(nil)^) else
        if (v<>nil) and (v.Length<>0) then
          if (n<>nil) and (n.Length<>0) then
            ntv_Color4fNormal3fVertex3fvSUN_1(PSingle(nil)^, n[0], v[0]) else
            ntv_Color4fNormal3fVertex3fvSUN_1(PSingle(nil)^, PSingle(nil)^, v[0]) else
          if (n<>nil) and (n.Length<>0) then
            ntv_Color4fNormal3fVertex3fvSUN_1(PSingle(nil)^, n[0], PSingle(nil)^) else
            ntv_Color4fNormal3fVertex3fvSUN_1(PSingle(nil)^, PSingle(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(var c: Vec4f; var n: Vec3f; var v: Vec3f) :=
      ntv_Color4fNormal3fVertex3fvSUN_2(c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(var c: single; var n: single; var v: single) :=
      ntv_Color4fNormal3fVertex3fvSUN_1(c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: IntPtr; n: IntPtr; v: IntPtr) :=
      ntv_Color4fNormal3fVertex3fvSUN_3(c, n, v);
    
    private TexCoord2fVertex3fSUN_adr := GetProcAddress('glTexCoord2fVertex3fSUN');
    private ntv_TexCoord2fVertex3fSUN_1 := GetProcOrNil&<procedure(s: single; t: single; x: single; y: single; z: single)>(TexCoord2fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fSUN(s: single; t: single; x: single; y: single; z: single) :=
      ntv_TexCoord2fVertex3fSUN_1(s, t, x, y, z);
    
    private TexCoord2fVertex3fvSUN_adr := GetProcAddress('glTexCoord2fVertex3fvSUN');
    private ntv_TexCoord2fVertex3fvSUN_1 := GetProcOrNil&<procedure(var tc: single; var v: single)>(TexCoord2fVertex3fvSUN_adr);
    private ntv_TexCoord2fVertex3fvSUN_2 := GetProcOrNil&<procedure(var tc: Vec2f; var v: Vec3f)>(TexCoord2fVertex3fvSUN_adr);
    private ntv_TexCoord2fVertex3fvSUN_3 := GetProcOrNil&<procedure(tc: IntPtr; v: IntPtr)>(TexCoord2fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(tc: array of single; v: array of single);
    type PSingle = ^single;
    begin
      if (tc<>nil) and (tc.Length<>0) then
        if (v<>nil) and (v.Length<>0) then
          ntv_TexCoord2fVertex3fvSUN_1(tc[0], v[0]) else
          ntv_TexCoord2fVertex3fvSUN_1(tc[0], PSingle(nil)^) else
        if (v<>nil) and (v.Length<>0) then
          ntv_TexCoord2fVertex3fvSUN_1(PSingle(nil)^, v[0]) else
          ntv_TexCoord2fVertex3fvSUN_1(PSingle(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(var tc: Vec2f; var v: Vec3f) :=
      ntv_TexCoord2fVertex3fvSUN_2(tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(var tc: single; var v: single) :=
      ntv_TexCoord2fVertex3fvSUN_1(tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(tc: IntPtr; v: IntPtr) :=
      ntv_TexCoord2fVertex3fvSUN_3(tc, v);
    
    private TexCoord4fVertex4fSUN_adr := GetProcAddress('glTexCoord4fVertex4fSUN');
    private ntv_TexCoord4fVertex4fSUN_1 := GetProcOrNil&<procedure(s: single; t: single; p: single; q: single; x: single; y: single; z: single; w: single)>(TexCoord4fVertex4fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fSUN(s: single; t: single; p: single; q: single; x: single; y: single; z: single; w: single) :=
      ntv_TexCoord4fVertex4fSUN_1(s, t, p, q, x, y, z, w);
    
    private TexCoord4fVertex4fvSUN_adr := GetProcAddress('glTexCoord4fVertex4fvSUN');
    private ntv_TexCoord4fVertex4fvSUN_1 := GetProcOrNil&<procedure(var tc: single; var v: single)>(TexCoord4fVertex4fvSUN_adr);
    private ntv_TexCoord4fVertex4fvSUN_2 := GetProcOrNil&<procedure(var tc: Vec4f; var v: Vec4f)>(TexCoord4fVertex4fvSUN_adr);
    private ntv_TexCoord4fVertex4fvSUN_3 := GetProcOrNil&<procedure(tc: IntPtr; v: IntPtr)>(TexCoord4fVertex4fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(tc: array of single; v: array of single);
    type PSingle = ^single;
    begin
      if (tc<>nil) and (tc.Length<>0) then
        if (v<>nil) and (v.Length<>0) then
          ntv_TexCoord4fVertex4fvSUN_1(tc[0], v[0]) else
          ntv_TexCoord4fVertex4fvSUN_1(tc[0], PSingle(nil)^) else
        if (v<>nil) and (v.Length<>0) then
          ntv_TexCoord4fVertex4fvSUN_1(PSingle(nil)^, v[0]) else
          ntv_TexCoord4fVertex4fvSUN_1(PSingle(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(var tc: Vec4f; var v: Vec4f) :=
      ntv_TexCoord4fVertex4fvSUN_2(tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(var tc: single; var v: single) :=
      ntv_TexCoord4fVertex4fvSUN_1(tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(tc: IntPtr; v: IntPtr) :=
      ntv_TexCoord4fVertex4fvSUN_3(tc, v);
    
    private TexCoord2fColor4ubVertex3fSUN_adr := GetProcAddress('glTexCoord2fColor4ubVertex3fSUN');
    private ntv_TexCoord2fColor4ubVertex3fSUN_1 := GetProcOrNil&<procedure(s: single; t: single; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single)>(TexCoord2fColor4ubVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fSUN(s: single; t: single; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single) :=
      ntv_TexCoord2fColor4ubVertex3fSUN_1(s, t, r, g, b, a, x, y, z);
    
    private TexCoord2fColor4ubVertex3fvSUN_adr := GetProcAddress('glTexCoord2fColor4ubVertex3fvSUN');
    private ntv_TexCoord2fColor4ubVertex3fvSUN_1 := GetProcOrNil&<procedure(var tc: single; var c: Byte; var v: single)>(TexCoord2fColor4ubVertex3fvSUN_adr);
    private ntv_TexCoord2fColor4ubVertex3fvSUN_2 := GetProcOrNil&<procedure(var tc: Vec2f; var c: Vec4ub; var v: Vec3f)>(TexCoord2fColor4ubVertex3fvSUN_adr);
    private ntv_TexCoord2fColor4ubVertex3fvSUN_3 := GetProcOrNil&<procedure(tc: IntPtr; c: IntPtr; v: IntPtr)>(TexCoord2fColor4ubVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: array of single; c: array of Byte; v: array of single);
    type PSingle = ^single;
    type PByte = ^Byte;
    begin
      if (tc<>nil) and (tc.Length<>0) then
        if (v<>nil) and (v.Length<>0) then
          if (c<>nil) and (c.Length<>0) then
            ntv_TexCoord2fColor4ubVertex3fvSUN_1(tc[0], c[0], v[0]) else
            ntv_TexCoord2fColor4ubVertex3fvSUN_1(tc[0], PByte(nil)^, v[0]) else
          if (c<>nil) and (c.Length<>0) then
            ntv_TexCoord2fColor4ubVertex3fvSUN_1(tc[0], c[0], PSingle(nil)^) else
            ntv_TexCoord2fColor4ubVertex3fvSUN_1(tc[0], PByte(nil)^, PSingle(nil)^) else
        if (v<>nil) and (v.Length<>0) then
          if (c<>nil) and (c.Length<>0) then
            ntv_TexCoord2fColor4ubVertex3fvSUN_1(PSingle(nil)^, c[0], v[0]) else
            ntv_TexCoord2fColor4ubVertex3fvSUN_1(PSingle(nil)^, PByte(nil)^, v[0]) else
          if (c<>nil) and (c.Length<>0) then
            ntv_TexCoord2fColor4ubVertex3fvSUN_1(PSingle(nil)^, c[0], PSingle(nil)^) else
            ntv_TexCoord2fColor4ubVertex3fvSUN_1(PSingle(nil)^, PByte(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(var tc: Vec2f; var c: Vec4ub; var v: Vec3f) :=
      ntv_TexCoord2fColor4ubVertex3fvSUN_2(tc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(var tc: single; var c: Byte; var v: single) :=
      ntv_TexCoord2fColor4ubVertex3fvSUN_1(tc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: IntPtr; c: IntPtr; v: IntPtr) :=
      ntv_TexCoord2fColor4ubVertex3fvSUN_3(tc, c, v);
    
    private TexCoord2fColor3fVertex3fSUN_adr := GetProcAddress('glTexCoord2fColor3fVertex3fSUN');
    private ntv_TexCoord2fColor3fVertex3fSUN_1 := GetProcOrNil&<procedure(s: single; t: single; r: single; g: single; b: single; x: single; y: single; z: single)>(TexCoord2fColor3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fSUN(s: single; t: single; r: single; g: single; b: single; x: single; y: single; z: single) :=
      ntv_TexCoord2fColor3fVertex3fSUN_1(s, t, r, g, b, x, y, z);
    
    private TexCoord2fColor3fVertex3fvSUN_adr := GetProcAddress('glTexCoord2fColor3fVertex3fvSUN');
    private ntv_TexCoord2fColor3fVertex3fvSUN_1 := GetProcOrNil&<procedure(var tc: single; var c: single; var v: single)>(TexCoord2fColor3fVertex3fvSUN_adr);
    private ntv_TexCoord2fColor3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var tc: Vec2f; var c: Vec3f; var v: Vec3f)>(TexCoord2fColor3fVertex3fvSUN_adr);
    private ntv_TexCoord2fColor3fVertex3fvSUN_3 := GetProcOrNil&<procedure(tc: IntPtr; c: IntPtr; v: IntPtr)>(TexCoord2fColor3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: array of single; c: array of single; v: array of single);
    type PSingle = ^single;
    begin
      if (tc<>nil) and (tc.Length<>0) then
        if (v<>nil) and (v.Length<>0) then
          if (c<>nil) and (c.Length<>0) then
            ntv_TexCoord2fColor3fVertex3fvSUN_1(tc[0], c[0], v[0]) else
            ntv_TexCoord2fColor3fVertex3fvSUN_1(tc[0], PSingle(nil)^, v[0]) else
          if (c<>nil) and (c.Length<>0) then
            ntv_TexCoord2fColor3fVertex3fvSUN_1(tc[0], c[0], PSingle(nil)^) else
            ntv_TexCoord2fColor3fVertex3fvSUN_1(tc[0], PSingle(nil)^, PSingle(nil)^) else
        if (v<>nil) and (v.Length<>0) then
          if (c<>nil) and (c.Length<>0) then
            ntv_TexCoord2fColor3fVertex3fvSUN_1(PSingle(nil)^, c[0], v[0]) else
            ntv_TexCoord2fColor3fVertex3fvSUN_1(PSingle(nil)^, PSingle(nil)^, v[0]) else
          if (c<>nil) and (c.Length<>0) then
            ntv_TexCoord2fColor3fVertex3fvSUN_1(PSingle(nil)^, c[0], PSingle(nil)^) else
            ntv_TexCoord2fColor3fVertex3fvSUN_1(PSingle(nil)^, PSingle(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(var tc: Vec2f; var c: Vec3f; var v: Vec3f) :=
      ntv_TexCoord2fColor3fVertex3fvSUN_2(tc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(var tc: single; var c: single; var v: single) :=
      ntv_TexCoord2fColor3fVertex3fvSUN_1(tc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: IntPtr; c: IntPtr; v: IntPtr) :=
      ntv_TexCoord2fColor3fVertex3fvSUN_3(tc, c, v);
    
    private TexCoord2fNormal3fVertex3fSUN_adr := GetProcAddress('glTexCoord2fNormal3fVertex3fSUN');
    private ntv_TexCoord2fNormal3fVertex3fSUN_1 := GetProcOrNil&<procedure(s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(TexCoord2fNormal3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fSUN(s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) :=
      ntv_TexCoord2fNormal3fVertex3fSUN_1(s, t, nx, ny, nz, x, y, z);
    
    private TexCoord2fNormal3fVertex3fvSUN_adr := GetProcAddress('glTexCoord2fNormal3fVertex3fvSUN');
    private ntv_TexCoord2fNormal3fVertex3fvSUN_1 := GetProcOrNil&<procedure(var tc: single; var n: single; var v: single)>(TexCoord2fNormal3fVertex3fvSUN_adr);
    private ntv_TexCoord2fNormal3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var tc: Vec2f; var n: Vec3f; var v: Vec3f)>(TexCoord2fNormal3fVertex3fvSUN_adr);
    private ntv_TexCoord2fNormal3fVertex3fvSUN_3 := GetProcOrNil&<procedure(tc: IntPtr; n: IntPtr; v: IntPtr)>(TexCoord2fNormal3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: array of single; n: array of single; v: array of single);
    type PSingle = ^single;
    begin
      if (tc<>nil) and (tc.Length<>0) then
        if (v<>nil) and (v.Length<>0) then
          if (n<>nil) and (n.Length<>0) then
            ntv_TexCoord2fNormal3fVertex3fvSUN_1(tc[0], n[0], v[0]) else
            ntv_TexCoord2fNormal3fVertex3fvSUN_1(tc[0], PSingle(nil)^, v[0]) else
          if (n<>nil) and (n.Length<>0) then
            ntv_TexCoord2fNormal3fVertex3fvSUN_1(tc[0], n[0], PSingle(nil)^) else
            ntv_TexCoord2fNormal3fVertex3fvSUN_1(tc[0], PSingle(nil)^, PSingle(nil)^) else
        if (v<>nil) and (v.Length<>0) then
          if (n<>nil) and (n.Length<>0) then
            ntv_TexCoord2fNormal3fVertex3fvSUN_1(PSingle(nil)^, n[0], v[0]) else
            ntv_TexCoord2fNormal3fVertex3fvSUN_1(PSingle(nil)^, PSingle(nil)^, v[0]) else
          if (n<>nil) and (n.Length<>0) then
            ntv_TexCoord2fNormal3fVertex3fvSUN_1(PSingle(nil)^, n[0], PSingle(nil)^) else
            ntv_TexCoord2fNormal3fVertex3fvSUN_1(PSingle(nil)^, PSingle(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(var tc: Vec2f; var n: Vec3f; var v: Vec3f) :=
      ntv_TexCoord2fNormal3fVertex3fvSUN_2(tc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(var tc: single; var n: single; var v: single) :=
      ntv_TexCoord2fNormal3fVertex3fvSUN_1(tc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: IntPtr; n: IntPtr; v: IntPtr) :=
      ntv_TexCoord2fNormal3fVertex3fvSUN_3(tc, n, v);
    
    private TexCoord2fColor4fNormal3fVertex3fSUN_adr := GetProcAddress('glTexCoord2fColor4fNormal3fVertex3fSUN');
    private ntv_TexCoord2fColor4fNormal3fVertex3fSUN_1 := GetProcOrNil&<procedure(s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(TexCoord2fColor4fNormal3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fSUN(s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) :=
      ntv_TexCoord2fColor4fNormal3fVertex3fSUN_1(s, t, r, g, b, a, nx, ny, nz, x, y, z);
    
    private TexCoord2fColor4fNormal3fVertex3fvSUN_adr := GetProcAddress('glTexCoord2fColor4fNormal3fVertex3fvSUN');
    private ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1 := GetProcOrNil&<procedure(var tc: single; var c: single; var n: single; var v: single)>(TexCoord2fColor4fNormal3fVertex3fvSUN_adr);
    private ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var tc: Vec2f; var c: Vec4f; var n: Vec3f; var v: Vec3f)>(TexCoord2fColor4fNormal3fVertex3fvSUN_adr);
    private ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_3 := GetProcOrNil&<procedure(tc: IntPtr; c: IntPtr; n: IntPtr; v: IntPtr)>(TexCoord2fColor4fNormal3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: array of single; n: array of single; v: array of single);
    type PSingle = ^single;
    begin
      if (tc<>nil) and (tc.Length<>0) then
        if (c<>nil) and (c.Length<>0) then
          if (n<>nil) and (n.Length<>0) then
            if (v<>nil) and (v.Length<>0) then
              ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1(tc[0], c[0], n[0], v[0]) else
              ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1(tc[0], c[0], n[0], PSingle(nil)^) else
            if (v<>nil) and (v.Length<>0) then
              ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1(tc[0], c[0], PSingle(nil)^, v[0]) else
              ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1(tc[0], c[0], PSingle(nil)^, PSingle(nil)^) else
          if (n<>nil) and (n.Length<>0) then
            if (v<>nil) and (v.Length<>0) then
              ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1(tc[0], PSingle(nil)^, n[0], v[0]) else
              ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1(tc[0], PSingle(nil)^, n[0], PSingle(nil)^) else
            if (v<>nil) and (v.Length<>0) then
              ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1(tc[0], PSingle(nil)^, PSingle(nil)^, v[0]) else
              ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1(tc[0], PSingle(nil)^, PSingle(nil)^, PSingle(nil)^) else
        if (c<>nil) and (c.Length<>0) then
          if (n<>nil) and (n.Length<>0) then
            if (v<>nil) and (v.Length<>0) then
              ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1(PSingle(nil)^, c[0], n[0], v[0]) else
              ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1(PSingle(nil)^, c[0], n[0], PSingle(nil)^) else
            if (v<>nil) and (v.Length<>0) then
              ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1(PSingle(nil)^, c[0], PSingle(nil)^, v[0]) else
              ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1(PSingle(nil)^, c[0], PSingle(nil)^, PSingle(nil)^) else
          if (n<>nil) and (n.Length<>0) then
            if (v<>nil) and (v.Length<>0) then
              ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1(PSingle(nil)^, PSingle(nil)^, n[0], v[0]) else
              ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1(PSingle(nil)^, PSingle(nil)^, n[0], PSingle(nil)^) else
            if (v<>nil) and (v.Length<>0) then
              ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1(PSingle(nil)^, PSingle(nil)^, PSingle(nil)^, v[0]) else
              ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1(PSingle(nil)^, PSingle(nil)^, PSingle(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: Vec2f; var c: Vec4f; var n: Vec3f; var v: Vec3f) :=
      ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_2(tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; var c: single; var n: single; var v: single) :=
      ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_1(tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: IntPtr; c: IntPtr; n: IntPtr; v: IntPtr) :=
      ntv_TexCoord2fColor4fNormal3fVertex3fvSUN_3(tc, c, n, v);
    
    private TexCoord4fColor4fNormal3fVertex4fSUN_adr := GetProcAddress('glTexCoord4fColor4fNormal3fVertex4fSUN');
    private ntv_TexCoord4fColor4fNormal3fVertex4fSUN_1 := GetProcOrNil&<procedure(s: single; t: single; p: single; q: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single; w: single)>(TexCoord4fColor4fNormal3fVertex4fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fSUN(s: single; t: single; p: single; q: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single; w: single) :=
      ntv_TexCoord4fColor4fNormal3fVertex4fSUN_1(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
    
    private TexCoord4fColor4fNormal3fVertex4fvSUN_adr := GetProcAddress('glTexCoord4fColor4fNormal3fVertex4fvSUN');
    private ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1 := GetProcOrNil&<procedure(var tc: single; var c: single; var n: single; var v: single)>(TexCoord4fColor4fNormal3fVertex4fvSUN_adr);
    private ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_2 := GetProcOrNil&<procedure(var tc: Vec4f; var c: Vec4f; var n: Vec3f; var v: Vec4f)>(TexCoord4fColor4fNormal3fVertex4fvSUN_adr);
    private ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_3 := GetProcOrNil&<procedure(tc: IntPtr; c: IntPtr; n: IntPtr; v: IntPtr)>(TexCoord4fColor4fNormal3fVertex4fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: array of single; n: array of single; v: array of single);
    type PSingle = ^single;
    begin
      if (tc<>nil) and (tc.Length<>0) then
        if (c<>nil) and (c.Length<>0) then
          if (n<>nil) and (n.Length<>0) then
            if (v<>nil) and (v.Length<>0) then
              ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1(tc[0], c[0], n[0], v[0]) else
              ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1(tc[0], c[0], n[0], PSingle(nil)^) else
            if (v<>nil) and (v.Length<>0) then
              ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1(tc[0], c[0], PSingle(nil)^, v[0]) else
              ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1(tc[0], c[0], PSingle(nil)^, PSingle(nil)^) else
          if (n<>nil) and (n.Length<>0) then
            if (v<>nil) and (v.Length<>0) then
              ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1(tc[0], PSingle(nil)^, n[0], v[0]) else
              ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1(tc[0], PSingle(nil)^, n[0], PSingle(nil)^) else
            if (v<>nil) and (v.Length<>0) then
              ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1(tc[0], PSingle(nil)^, PSingle(nil)^, v[0]) else
              ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1(tc[0], PSingle(nil)^, PSingle(nil)^, PSingle(nil)^) else
        if (c<>nil) and (c.Length<>0) then
          if (n<>nil) and (n.Length<>0) then
            if (v<>nil) and (v.Length<>0) then
              ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1(PSingle(nil)^, c[0], n[0], v[0]) else
              ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1(PSingle(nil)^, c[0], n[0], PSingle(nil)^) else
            if (v<>nil) and (v.Length<>0) then
              ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1(PSingle(nil)^, c[0], PSingle(nil)^, v[0]) else
              ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1(PSingle(nil)^, c[0], PSingle(nil)^, PSingle(nil)^) else
          if (n<>nil) and (n.Length<>0) then
            if (v<>nil) and (v.Length<>0) then
              ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1(PSingle(nil)^, PSingle(nil)^, n[0], v[0]) else
              ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1(PSingle(nil)^, PSingle(nil)^, n[0], PSingle(nil)^) else
            if (v<>nil) and (v.Length<>0) then
              ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1(PSingle(nil)^, PSingle(nil)^, PSingle(nil)^, v[0]) else
              ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1(PSingle(nil)^, PSingle(nil)^, PSingle(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: Vec4f; var c: Vec4f; var n: Vec3f; var v: Vec4f) :=
      ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_2(tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; var c: single; var n: single; var v: single) :=
      ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_1(tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: IntPtr; c: IntPtr; n: IntPtr; v: IntPtr) :=
      ntv_TexCoord4fColor4fNormal3fVertex4fvSUN_3(tc, c, n, v);
    
    private ReplacementCodeuiVertex3fSUN_adr := GetProcAddress('glReplacementCodeuiVertex3fSUN');
    private ntv_ReplacementCodeuiVertex3fSUN_1 := GetProcOrNil&<procedure(rc: glTriangleList; x: single; y: single; z: single)>(ReplacementCodeuiVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fSUN(rc: glTriangleList; x: single; y: single; z: single) :=
      ntv_ReplacementCodeuiVertex3fSUN_1(rc, x, y, z);
    
    private ReplacementCodeuiVertex3fvSUN_adr := GetProcAddress('glReplacementCodeuiVertex3fvSUN');
    private ntv_ReplacementCodeuiVertex3fvSUN_1 := GetProcOrNil&<procedure(var rc: glTriangleList; var v: single)>(ReplacementCodeuiVertex3fvSUN_adr);
    private ntv_ReplacementCodeuiVertex3fvSUN_2 := GetProcOrNil&<procedure(var rc: glTriangleList; var v: Vec3f)>(ReplacementCodeuiVertex3fvSUN_adr);
    private ntv_ReplacementCodeuiVertex3fvSUN_3 := GetProcOrNil&<procedure(rc: IntPtr; v: IntPtr)>(ReplacementCodeuiVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(var rc: glTriangleList; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_ReplacementCodeuiVertex3fvSUN_1(rc, v[0]) else
        ntv_ReplacementCodeuiVertex3fvSUN_1(rc, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(var rc: glTriangleList; var v: Vec3f) :=
      ntv_ReplacementCodeuiVertex3fvSUN_2(rc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(var rc: glTriangleList; var v: single) :=
      ntv_ReplacementCodeuiVertex3fvSUN_1(rc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(rc: IntPtr; v: IntPtr) :=
      ntv_ReplacementCodeuiVertex3fvSUN_3(rc, v);
    
    private ReplacementCodeuiColor4ubVertex3fSUN_adr := GetProcAddress('glReplacementCodeuiColor4ubVertex3fSUN');
    private ntv_ReplacementCodeuiColor4ubVertex3fSUN_1 := GetProcOrNil&<procedure(rc: glTriangleList; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single)>(ReplacementCodeuiColor4ubVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fSUN(rc: glTriangleList; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single) :=
      ntv_ReplacementCodeuiColor4ubVertex3fSUN_1(rc, r, g, b, a, x, y, z);
    
    private ReplacementCodeuiColor4ubVertex3fvSUN_adr := GetProcAddress('glReplacementCodeuiColor4ubVertex3fvSUN');
    private ntv_ReplacementCodeuiColor4ubVertex3fvSUN_1 := GetProcOrNil&<procedure(var rc: glTriangleList; var c: Byte; var v: single)>(ReplacementCodeuiColor4ubVertex3fvSUN_adr);
    private ntv_ReplacementCodeuiColor4ubVertex3fvSUN_2 := GetProcOrNil&<procedure(var rc: glTriangleList; var c: Vec4ub; var v: Vec3f)>(ReplacementCodeuiColor4ubVertex3fvSUN_adr);
    private ntv_ReplacementCodeuiColor4ubVertex3fvSUN_3 := GetProcOrNil&<procedure(rc: IntPtr; c: IntPtr; v: IntPtr)>(ReplacementCodeuiColor4ubVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: glTriangleList; c: array of Byte; v: array of single);
    type PByte = ^Byte;
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (c<>nil) and (c.Length<>0) then
          ntv_ReplacementCodeuiColor4ubVertex3fvSUN_1(rc, c[0], v[0]) else
          ntv_ReplacementCodeuiColor4ubVertex3fvSUN_1(rc, PByte(nil)^, v[0]) else
        if (c<>nil) and (c.Length<>0) then
          ntv_ReplacementCodeuiColor4ubVertex3fvSUN_1(rc, c[0], PSingle(nil)^) else
          ntv_ReplacementCodeuiColor4ubVertex3fvSUN_1(rc, PByte(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: glTriangleList; var c: Vec4ub; var v: Vec3f) :=
      ntv_ReplacementCodeuiColor4ubVertex3fvSUN_2(rc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: glTriangleList; var c: Byte; var v: single) :=
      ntv_ReplacementCodeuiColor4ubVertex3fvSUN_1(rc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: IntPtr; c: IntPtr; v: IntPtr) :=
      ntv_ReplacementCodeuiColor4ubVertex3fvSUN_3(rc, c, v);
    
    private ReplacementCodeuiColor3fVertex3fSUN_adr := GetProcAddress('glReplacementCodeuiColor3fVertex3fSUN');
    private ntv_ReplacementCodeuiColor3fVertex3fSUN_1 := GetProcOrNil&<procedure(rc: glTriangleList; r: single; g: single; b: single; x: single; y: single; z: single)>(ReplacementCodeuiColor3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fSUN(rc: glTriangleList; r: single; g: single; b: single; x: single; y: single; z: single) :=
      ntv_ReplacementCodeuiColor3fVertex3fSUN_1(rc, r, g, b, x, y, z);
    
    private ReplacementCodeuiColor3fVertex3fvSUN_adr := GetProcAddress('glReplacementCodeuiColor3fVertex3fvSUN');
    private ntv_ReplacementCodeuiColor3fVertex3fvSUN_1 := GetProcOrNil&<procedure(var rc: glTriangleList; var c: single; var v: single)>(ReplacementCodeuiColor3fVertex3fvSUN_adr);
    private ntv_ReplacementCodeuiColor3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var rc: glTriangleList; var c: Vec3f; var v: Vec3f)>(ReplacementCodeuiColor3fVertex3fvSUN_adr);
    private ntv_ReplacementCodeuiColor3fVertex3fvSUN_3 := GetProcOrNil&<procedure(rc: IntPtr; c: IntPtr; v: IntPtr)>(ReplacementCodeuiColor3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: glTriangleList; c: array of single; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (c<>nil) and (c.Length<>0) then
          ntv_ReplacementCodeuiColor3fVertex3fvSUN_1(rc, c[0], v[0]) else
          ntv_ReplacementCodeuiColor3fVertex3fvSUN_1(rc, PSingle(nil)^, v[0]) else
        if (c<>nil) and (c.Length<>0) then
          ntv_ReplacementCodeuiColor3fVertex3fvSUN_1(rc, c[0], PSingle(nil)^) else
          ntv_ReplacementCodeuiColor3fVertex3fvSUN_1(rc, PSingle(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: glTriangleList; var c: Vec3f; var v: Vec3f) :=
      ntv_ReplacementCodeuiColor3fVertex3fvSUN_2(rc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: glTriangleList; var c: single; var v: single) :=
      ntv_ReplacementCodeuiColor3fVertex3fvSUN_1(rc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: IntPtr; c: IntPtr; v: IntPtr) :=
      ntv_ReplacementCodeuiColor3fVertex3fvSUN_3(rc, c, v);
    
    private ReplacementCodeuiNormal3fVertex3fSUN_adr := GetProcAddress('glReplacementCodeuiNormal3fVertex3fSUN');
    private ntv_ReplacementCodeuiNormal3fVertex3fSUN_1 := GetProcOrNil&<procedure(rc: glTriangleList; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(ReplacementCodeuiNormal3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fSUN(rc: glTriangleList; nx: single; ny: single; nz: single; x: single; y: single; z: single) :=
      ntv_ReplacementCodeuiNormal3fVertex3fSUN_1(rc, nx, ny, nz, x, y, z);
    
    private ReplacementCodeuiNormal3fVertex3fvSUN_adr := GetProcAddress('glReplacementCodeuiNormal3fVertex3fvSUN');
    private ntv_ReplacementCodeuiNormal3fVertex3fvSUN_1 := GetProcOrNil&<procedure(var rc: glTriangleList; var n: single; var v: single)>(ReplacementCodeuiNormal3fVertex3fvSUN_adr);
    private ntv_ReplacementCodeuiNormal3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var rc: glTriangleList; var n: Vec3f; var v: Vec3f)>(ReplacementCodeuiNormal3fVertex3fvSUN_adr);
    private ntv_ReplacementCodeuiNormal3fVertex3fvSUN_3 := GetProcOrNil&<procedure(rc: IntPtr; n: IntPtr; v: IntPtr)>(ReplacementCodeuiNormal3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: glTriangleList; n: array of single; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (n<>nil) and (n.Length<>0) then
          ntv_ReplacementCodeuiNormal3fVertex3fvSUN_1(rc, n[0], v[0]) else
          ntv_ReplacementCodeuiNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, v[0]) else
        if (n<>nil) and (n.Length<>0) then
          ntv_ReplacementCodeuiNormal3fVertex3fvSUN_1(rc, n[0], PSingle(nil)^) else
          ntv_ReplacementCodeuiNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: glTriangleList; var n: Vec3f; var v: Vec3f) :=
      ntv_ReplacementCodeuiNormal3fVertex3fvSUN_2(rc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: glTriangleList; var n: single; var v: single) :=
      ntv_ReplacementCodeuiNormal3fVertex3fvSUN_1(rc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: IntPtr; n: IntPtr; v: IntPtr) :=
      ntv_ReplacementCodeuiNormal3fVertex3fvSUN_3(rc, n, v);
    
    private ReplacementCodeuiColor4fNormal3fVertex3fSUN_adr := GetProcAddress('glReplacementCodeuiColor4fNormal3fVertex3fSUN');
    private ntv_ReplacementCodeuiColor4fNormal3fVertex3fSUN_1 := GetProcOrNil&<procedure(rc: glTriangleList; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(ReplacementCodeuiColor4fNormal3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fSUN(rc: glTriangleList; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) :=
      ntv_ReplacementCodeuiColor4fNormal3fVertex3fSUN_1(rc, r, g, b, a, nx, ny, nz, x, y, z);
    
    private ReplacementCodeuiColor4fNormal3fVertex3fvSUN_adr := GetProcAddress('glReplacementCodeuiColor4fNormal3fVertex3fvSUN');
    private ntv_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_1 := GetProcOrNil&<procedure(var rc: glTriangleList; var c: single; var n: single; var v: single)>(ReplacementCodeuiColor4fNormal3fVertex3fvSUN_adr);
    private ntv_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var rc: glTriangleList; var c: Vec4f; var n: Vec3f; var v: Vec3f)>(ReplacementCodeuiColor4fNormal3fVertex3fvSUN_adr);
    private ntv_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_3 := GetProcOrNil&<procedure(rc: IntPtr; c: IntPtr; n: IntPtr; v: IntPtr)>(ReplacementCodeuiColor4fNormal3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: glTriangleList; c: array of single; n: array of single; v: array of single);
    type PSingle = ^single;
    begin
      if (c<>nil) and (c.Length<>0) then
        if (v<>nil) and (v.Length<>0) then
          if (n<>nil) and (n.Length<>0) then
            ntv_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_1(rc, c[0], n[0], v[0]) else
            ntv_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_1(rc, c[0], PSingle(nil)^, v[0]) else
          if (n<>nil) and (n.Length<>0) then
            ntv_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_1(rc, c[0], n[0], PSingle(nil)^) else
            ntv_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_1(rc, c[0], PSingle(nil)^, PSingle(nil)^) else
        if (v<>nil) and (v.Length<>0) then
          if (n<>nil) and (n.Length<>0) then
            ntv_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, n[0], v[0]) else
            ntv_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, PSingle(nil)^, v[0]) else
          if (n<>nil) and (n.Length<>0) then
            ntv_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, n[0], PSingle(nil)^) else
            ntv_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, PSingle(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: glTriangleList; var c: Vec4f; var n: Vec3f; var v: Vec3f) :=
      ntv_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_2(rc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: glTriangleList; var c: single; var n: single; var v: single) :=
      ntv_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_1(rc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: IntPtr; c: IntPtr; n: IntPtr; v: IntPtr) :=
      ntv_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_3(rc, c, n, v);
    
    private ReplacementCodeuiTexCoord2fVertex3fSUN_adr := GetProcAddress('glReplacementCodeuiTexCoord2fVertex3fSUN');
    private ntv_ReplacementCodeuiTexCoord2fVertex3fSUN_1 := GetProcOrNil&<procedure(rc: glTriangleList; s: single; t: single; x: single; y: single; z: single)>(ReplacementCodeuiTexCoord2fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fSUN(rc: glTriangleList; s: single; t: single; x: single; y: single; z: single) :=
      ntv_ReplacementCodeuiTexCoord2fVertex3fSUN_1(rc, s, t, x, y, z);
    
    private ReplacementCodeuiTexCoord2fVertex3fvSUN_adr := GetProcAddress('glReplacementCodeuiTexCoord2fVertex3fvSUN');
    private ntv_ReplacementCodeuiTexCoord2fVertex3fvSUN_1 := GetProcOrNil&<procedure(var rc: glTriangleList; var tc: single; var v: single)>(ReplacementCodeuiTexCoord2fVertex3fvSUN_adr);
    private ntv_ReplacementCodeuiTexCoord2fVertex3fvSUN_2 := GetProcOrNil&<procedure(var rc: glTriangleList; var tc: Vec2f; var v: Vec3f)>(ReplacementCodeuiTexCoord2fVertex3fvSUN_adr);
    private ntv_ReplacementCodeuiTexCoord2fVertex3fvSUN_3 := GetProcOrNil&<procedure(rc: IntPtr; tc: IntPtr; v: IntPtr)>(ReplacementCodeuiTexCoord2fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: glTriangleList; tc: array of single; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (tc<>nil) and (tc.Length<>0) then
          ntv_ReplacementCodeuiTexCoord2fVertex3fvSUN_1(rc, tc[0], v[0]) else
          ntv_ReplacementCodeuiTexCoord2fVertex3fvSUN_1(rc, PSingle(nil)^, v[0]) else
        if (tc<>nil) and (tc.Length<>0) then
          ntv_ReplacementCodeuiTexCoord2fVertex3fvSUN_1(rc, tc[0], PSingle(nil)^) else
          ntv_ReplacementCodeuiTexCoord2fVertex3fvSUN_1(rc, PSingle(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: glTriangleList; var tc: Vec2f; var v: Vec3f) :=
      ntv_ReplacementCodeuiTexCoord2fVertex3fvSUN_2(rc, tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: glTriangleList; var tc: single; var v: single) :=
      ntv_ReplacementCodeuiTexCoord2fVertex3fvSUN_1(rc, tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: IntPtr; tc: IntPtr; v: IntPtr) :=
      ntv_ReplacementCodeuiTexCoord2fVertex3fvSUN_3(rc, tc, v);
    
    private ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_adr := GetProcAddress('glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN');
    private ntv_ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_1 := GetProcOrNil&<procedure(rc: glTriangleList; s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc: glTriangleList; s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) :=
      ntv_ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_1(rc, s, t, nx, ny, nz, x, y, z);
    
    private ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_adr := GetProcAddress('glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN');
    private ntv_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_1 := GetProcOrNil&<procedure(var rc: glTriangleList; var tc: single; var n: single; var v: single)>(ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_adr);
    private ntv_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var rc: glTriangleList; var tc: Vec2f; var n: Vec3f; var v: Vec3f)>(ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_adr);
    private ntv_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_3 := GetProcOrNil&<procedure(rc: IntPtr; tc: IntPtr; n: IntPtr; v: IntPtr)>(ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: glTriangleList; tc: array of single; n: array of single; v: array of single);
    type PSingle = ^single;
    begin
      if (tc<>nil) and (tc.Length<>0) then
        if (v<>nil) and (v.Length<>0) then
          if (n<>nil) and (n.Length<>0) then
            ntv_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_1(rc, tc[0], n[0], v[0]) else
            ntv_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_1(rc, tc[0], PSingle(nil)^, v[0]) else
          if (n<>nil) and (n.Length<>0) then
            ntv_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_1(rc, tc[0], n[0], PSingle(nil)^) else
            ntv_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_1(rc, tc[0], PSingle(nil)^, PSingle(nil)^) else
        if (v<>nil) and (v.Length<>0) then
          if (n<>nil) and (n.Length<>0) then
            ntv_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, n[0], v[0]) else
            ntv_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, PSingle(nil)^, v[0]) else
          if (n<>nil) and (n.Length<>0) then
            ntv_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, n[0], PSingle(nil)^) else
            ntv_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, PSingle(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: glTriangleList; var tc: Vec2f; var n: Vec3f; var v: Vec3f) :=
      ntv_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_2(rc, tc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: glTriangleList; var tc: single; var n: single; var v: single) :=
      ntv_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_1(rc, tc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: IntPtr; tc: IntPtr; n: IntPtr; v: IntPtr) :=
      ntv_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_3(rc, tc, n, v);
    
    private ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_adr := GetProcAddress('glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN');
    private ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_1 := GetProcOrNil&<procedure(rc: glTriangleList; s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc: glTriangleList; s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) :=
      ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_1(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
    
    private ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_adr := GetProcAddress('glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN');
    private ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1 := GetProcOrNil&<procedure(var rc: glTriangleList; var tc: single; var c: single; var n: single; var v: single)>(ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_adr);
    private ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var rc: glTriangleList; var tc: Vec2f; var c: Vec4f; var n: Vec3f; var v: Vec3f)>(ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_adr);
    private ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_3 := GetProcOrNil&<procedure(rc: IntPtr; tc: IntPtr; c: IntPtr; n: IntPtr; v: IntPtr)>(ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: glTriangleList; tc: array of single; c: array of single; n: array of single; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (tc<>nil) and (tc.Length<>0) then
          if (n<>nil) and (n.Length<>0) then
            if (c<>nil) and (c.Length<>0) then
              ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, tc[0], c[0], n[0], v[0]) else
              ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, tc[0], PSingle(nil)^, n[0], v[0]) else
            if (c<>nil) and (c.Length<>0) then
              ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, tc[0], c[0], PSingle(nil)^, v[0]) else
              ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, tc[0], PSingle(nil)^, PSingle(nil)^, v[0]) else
          if (n<>nil) and (n.Length<>0) then
            if (c<>nil) and (c.Length<>0) then
              ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, c[0], n[0], v[0]) else
              ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, PSingle(nil)^, n[0], v[0]) else
            if (c<>nil) and (c.Length<>0) then
              ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, c[0], PSingle(nil)^, v[0]) else
              ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, PSingle(nil)^, PSingle(nil)^, v[0]) else
        if (tc<>nil) and (tc.Length<>0) then
          if (n<>nil) and (n.Length<>0) then
            if (c<>nil) and (c.Length<>0) then
              ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, tc[0], c[0], n[0], PSingle(nil)^) else
              ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, tc[0], PSingle(nil)^, n[0], PSingle(nil)^) else
            if (c<>nil) and (c.Length<>0) then
              ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, tc[0], c[0], PSingle(nil)^, PSingle(nil)^) else
              ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, tc[0], PSingle(nil)^, PSingle(nil)^, PSingle(nil)^) else
          if (n<>nil) and (n.Length<>0) then
            if (c<>nil) and (c.Length<>0) then
              ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, c[0], n[0], PSingle(nil)^) else
              ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, PSingle(nil)^, n[0], PSingle(nil)^) else
            if (c<>nil) and (c.Length<>0) then
              ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, c[0], PSingle(nil)^, PSingle(nil)^) else
              ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, PSingle(nil)^, PSingle(nil)^, PSingle(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: glTriangleList; var tc: Vec2f; var c: Vec4f; var n: Vec3f; var v: Vec3f) :=
      ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: glTriangleList; var tc: single; var c: single; var n: single; var v: single) :=
      ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: IntPtr; tc: IntPtr; c: IntPtr; n: IntPtr; v: IntPtr) :=
      ntv_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_3(rc, tc, c, n, v);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glConstantDataSUNX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GL_SUNX_constant_data';
    
    private FinishTextureSUNX_adr := GetProcAddress('glFinishTextureSUNX');
    private ntv_FinishTextureSUNX_1 := GetProcOrNil&<procedure>(FinishTextureSUNX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinishTextureSUNX :=
      ntv_FinishTextureSUNX_1;
    
  end;
  
  ///
  glPhongShadingWIN = static class
    public const _ExtStr = 'GL_WIN_phong_shading';
  end;
  
  ///
  glSpecularFogWIN = static class
    public const _ExtStr = 'GL_WIN_specular_fog';
  end;
  
  ///
  glxMultisample3DFX = static class
    public const _ExtStr = 'GLX_3DFX_multisample';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxGpuAssociationAMD = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_AMD_gpu_association';
    
    private GetGPUIDsAMD_adr := GetProcAddress('glXGetGPUIDsAMD');
    private ntv_GetGPUIDsAMD_1 := GetProcOrNil&<function(maxCount: UInt32; var ids: UInt32): UInt32>(GetGPUIDsAMD_adr);
    private ntv_GetGPUIDsAMD_2 := GetProcOrNil&<function(maxCount: UInt32; ids: IntPtr): UInt32>(GetGPUIDsAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUIDsAMD(maxCount: UInt32; var ids: UInt32): UInt32 :=
      ntv_GetGPUIDsAMD_1(maxCount, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUIDsAMD(maxCount: UInt32; ids: IntPtr): UInt32 :=
      ntv_GetGPUIDsAMD_2(maxCount, ids);
    
    private GetGPUInfoAMD_adr := GetProcAddress('glXGetGPUInfoAMD');
    private ntv_GetGPUInfoAMD_1 := GetProcOrNil&<function(id: UInt32; &property: Int32; dataType: DummyEnum; size: UInt32; data: IntPtr): Int32>(GetGPUInfoAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUInfoAMD(id: UInt32; &property: Int32; dataType: DummyEnum; size: UInt32; data: IntPtr): Int32 :=
      ntv_GetGPUInfoAMD_1(id, &property, dataType, size, data);
    
    private GetContextGPUIDAMD_adr := GetProcAddress('glXGetContextGPUIDAMD');
    private ntv_GetContextGPUIDAMD_1 := GetProcOrNil&<function(ctx: glx_context): UInt32>(GetContextGPUIDAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetContextGPUIDAMD(ctx: glx_context): UInt32 :=
      ntv_GetContextGPUIDAMD_1(ctx);
    
    private CreateAssociatedContextAMD_adr := GetProcAddress('glXCreateAssociatedContextAMD');
    private ntv_CreateAssociatedContextAMD_1 := GetProcOrNil&<function(id: UInt32; share_list: glx_context): glx_context>(CreateAssociatedContextAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAMD(id: UInt32; share_list: glx_context): glx_context :=
      ntv_CreateAssociatedContextAMD_1(id, share_list);
    
    private CreateAssociatedContextAttribsAMD_adr := GetProcAddress('glXCreateAssociatedContextAttribsAMD');
    private ntv_CreateAssociatedContextAttribsAMD_1 := GetProcOrNil&<function(id: UInt32; share_context: glx_context; var attribList: Int32): glx_context>(CreateAssociatedContextAttribsAMD_adr);
    private ntv_CreateAssociatedContextAttribsAMD_2 := GetProcOrNil&<function(id: UInt32; share_context: glx_context; attribList: IntPtr): glx_context>(CreateAssociatedContextAttribsAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; share_context: glx_context; attribList: array of Int32): glx_context;
    type PInt32 = ^Int32;
    begin
      Result := if (attribList<>nil) and (attribList.Length<>0) then
        ntv_CreateAssociatedContextAttribsAMD_1(id, share_context, attribList[0]) else
        ntv_CreateAssociatedContextAttribsAMD_1(id, share_context, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; share_context: glx_context; var attribList: Int32): glx_context :=
      ntv_CreateAssociatedContextAttribsAMD_1(id, share_context, attribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; share_context: glx_context; attribList: IntPtr): glx_context :=
      ntv_CreateAssociatedContextAttribsAMD_2(id, share_context, attribList);
    
    private DeleteAssociatedContextAMD_adr := GetProcAddress('glXDeleteAssociatedContextAMD');
    private ntv_DeleteAssociatedContextAMD_1 := GetProcOrNil&<function(ctx: glx_context): glBool8>(DeleteAssociatedContextAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DeleteAssociatedContextAMD(ctx: glx_context): glBool8 :=
      ntv_DeleteAssociatedContextAMD_1(ctx);
    
    private MakeAssociatedContextCurrentAMD_adr := GetProcAddress('glXMakeAssociatedContextCurrentAMD');
    private ntv_MakeAssociatedContextCurrentAMD_1 := GetProcOrNil&<function(ctx: glx_context): glBool8>(MakeAssociatedContextCurrentAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeAssociatedContextCurrentAMD(ctx: glx_context): glBool8 :=
      ntv_MakeAssociatedContextCurrentAMD_1(ctx);
    
    private GetCurrentAssociatedContextAMD_adr := GetProcAddress('glXGetCurrentAssociatedContextAMD');
    private ntv_GetCurrentAssociatedContextAMD_1 := GetProcOrNil&<function: glx_context>(GetCurrentAssociatedContextAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentAssociatedContextAMD: glx_context :=
      ntv_GetCurrentAssociatedContextAMD_1;
    
    private BlitContextFramebufferAMD_adr := GetProcAddress('glXBlitContextFramebufferAMD');
    private ntv_BlitContextFramebufferAMD_1 := GetProcOrNil&<procedure(dstCtx: glx_context; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum)>(BlitContextFramebufferAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitContextFramebufferAMD(dstCtx: glx_context; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum) :=
      ntv_BlitContextFramebufferAMD_1(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
  end;
  
  ///
  glxContextFlushControlARB = static class
    public const _ExtStr = 'GLX_ARB_context_flush_control';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxCreateContextARB = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_ARB_create_context';
    
    private CreateContextAttribsARB_adr := GetProcAddress('glXCreateContextAttribsARB');
    private ntv_CreateContextAttribsARB_1 := GetProcOrNil&<function(dpy: x_display_ptr; config: glx_frame_buffer_config; share_context: glx_context; direct: glBool8; var attrib_list: Int32): glx_context>(CreateContextAttribsARB_adr);
    private ntv_CreateContextAttribsARB_2 := GetProcOrNil&<function(dpy: x_display_ptr; config: glx_frame_buffer_config; share_context: glx_context; direct: glBool8; attrib_list: IntPtr): glx_context>(CreateContextAttribsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(dpy: x_display_ptr; config: glx_frame_buffer_config; share_context: glx_context; direct: glBool8; attrib_list: array of Int32): glx_context;
    type PInt32 = ^Int32;
    begin
      Result := if (attrib_list<>nil) and (attrib_list.Length<>0) then
        ntv_CreateContextAttribsARB_1(dpy, config, share_context, direct, attrib_list[0]) else
        ntv_CreateContextAttribsARB_1(dpy, config, share_context, direct, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(dpy: x_display_ptr; config: glx_frame_buffer_config; share_context: glx_context; direct: glBool8; var attrib_list: Int32): glx_context :=
      ntv_CreateContextAttribsARB_1(dpy, config, share_context, direct, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(dpy: x_display_ptr; config: glx_frame_buffer_config; share_context: glx_context; direct: glBool8; attrib_list: IntPtr): glx_context :=
      ntv_CreateContextAttribsARB_2(dpy, config, share_context, direct, attrib_list);
    
  end;
  
  ///
  glxCreateContextNoErrorARB = static class
    public const _ExtStr = 'GLX_ARB_create_context_no_error';
  end;
  
  ///
  glxCreateContextProfileARB = static class
    public const _ExtStr = 'GLX_ARB_create_context_profile';
  end;
  
  ///
  glxCreateContextRobustnessARB = static class
    public const _ExtStr = 'GLX_ARB_create_context_robustness';
  end;
  
  ///
  glxFbconfigFloatARB = static class
    public const _ExtStr = 'GLX_ARB_fbconfig_float';
  end;
  
  ///
  glxFramebufferSRGBARB = static class
    public const _ExtStr = 'GLX_ARB_framebuffer_sRGB';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxGetProcAddressARB = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_ARB_get_proc_address';
    
    private GetProcAddressARB_adr := GetProcAddress('glXGetProcAddressARB');
    private ntv_GetProcAddressARB_1 := GetProcOrNil&<function(procName: IntPtr): IntPtr>(GetProcAddressARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProcAddressARB(procName: string): IntPtr;
    begin
      var procName_str_ptr := Marshal.StringToHGlobalAnsi(procName);
      try
        Result := ntv_GetProcAddressARB_1(procName_str_ptr);
      finally
        Marshal.FreeHGlobal(procName_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProcAddressARB(procName: IntPtr): IntPtr :=
      ntv_GetProcAddressARB_1(procName);
    
  end;
  
  ///
  glxMultisampleARB = static class
    public const _ExtStr = 'GLX_ARB_multisample';
  end;
  
  ///
  glxRobustnessApplicationIsolationARB = static class
    public const _ExtStr = 'GLX_ARB_robustness_application_isolation';
  end;
  
  ///
  glxRobustnessShareGroupIsolationARB = static class
    public const _ExtStr = 'GLX_ARB_robustness_share_group_isolation';
  end;
  
  ///
  glxVertexBufferObjectARB = static class
    public const _ExtStr = 'GLX_ARB_vertex_buffer_object';
  end;
  
  ///
  glxBufferAgeEXT = static class
    public const _ExtStr = 'GLX_EXT_buffer_age';
  end;
  
  ///
  glxContextPriorityEXT = static class
    public const _ExtStr = 'GLX_EXT_context_priority';
  end;
  
  ///
  glxCreateContextEsProfileEXT = static class
    public const _ExtStr = 'GLX_EXT_create_context_es_profile';
  end;
  
  ///
  glxCreateContextEs2ProfileEXT = static class
    public const _ExtStr = 'GLX_EXT_create_context_es2_profile';
  end;
  
  ///
  glxFbconfigPackedFloatEXT = static class
    public const _ExtStr = 'GLX_EXT_fbconfig_packed_float';
  end;
  
  ///
  glxFramebufferSRGBEXT = static class
    public const _ExtStr = 'GLX_EXT_framebuffer_sRGB';
  end;
  
  ///
  glxGetDrawableTypeEXT = static class
    public const _ExtStr = 'GLX_EXT_get_drawable_type';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxImportContextEXT = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_EXT_import_context';
    
    private GetCurrentDisplayEXT_adr := GetProcAddress('glXGetCurrentDisplayEXT');
    private ntv_GetCurrentDisplayEXT_1 := GetProcOrNil&<function: x_display_ptr>(GetCurrentDisplayEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentDisplayEXT: x_display_ptr :=
      ntv_GetCurrentDisplayEXT_1;
    
    private QueryContextInfoEXT_adr := GetProcAddress('glXQueryContextInfoEXT');
    private ntv_QueryContextInfoEXT_1 := GetProcOrNil&<function(dpy: x_display_ptr; context: glx_context; attribute: Int32; var value: Int32): Int32>(QueryContextInfoEXT_adr);
    private ntv_QueryContextInfoEXT_2 := GetProcOrNil&<function(dpy: x_display_ptr; context: glx_context; attribute: Int32; value: IntPtr): Int32>(QueryContextInfoEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryContextInfoEXT(dpy: x_display_ptr; context: glx_context; attribute: Int32; value: array of Int32): Int32;
    type PInt32 = ^Int32;
    begin
      Result := if (value<>nil) and (value.Length<>0) then
        ntv_QueryContextInfoEXT_1(dpy, context, attribute, value[0]) else
        ntv_QueryContextInfoEXT_1(dpy, context, attribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryContextInfoEXT(dpy: x_display_ptr; context: glx_context; attribute: Int32; var value: Int32): Int32 :=
      ntv_QueryContextInfoEXT_1(dpy, context, attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryContextInfoEXT(dpy: x_display_ptr; context: glx_context; attribute: Int32; value: IntPtr): Int32 :=
      ntv_QueryContextInfoEXT_2(dpy, context, attribute, value);
    
    private GetContextIDEXT_adr := GetProcAddress('glXGetContextIDEXT');
    private ntv_GetContextIDEXT_1 := GetProcOrNil&<function(context: glx_context): glx_context_id>(GetContextIDEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetContextIDEXT(context: glx_context): glx_context_id :=
      ntv_GetContextIDEXT_1(context);
    
    private ImportContextEXT_adr := GetProcAddress('glXImportContextEXT');
    private ntv_ImportContextEXT_1 := GetProcOrNil&<function(dpy: x_display_ptr; contextID: glx_context_id): glx_context>(ImportContextEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ImportContextEXT(dpy: x_display_ptr; contextID: glx_context_id): glx_context :=
      ntv_ImportContextEXT_1(dpy, contextID);
    
    private FreeContextEXT_adr := GetProcAddress('glXFreeContextEXT');
    private ntv_FreeContextEXT_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; context: glx_context)>(FreeContextEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FreeContextEXT(dpy: x_display_ptr; context: glx_context) :=
      ntv_FreeContextEXT_1(dpy, context);
    
  end;
  
  ///
  glxLibglvndEXT = static class
    public const _ExtStr = 'GLX_EXT_libglvnd';
  end;
  
  ///
  glxNoConfigContextEXT = static class
    public const _ExtStr = 'GLX_EXT_no_config_context';
  end;
  
  ///
  glxStereoTreeEXT = static class
    public const _ExtStr = 'GLX_EXT_stereo_tree';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxSwapControlEXT = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_EXT_swap_control';
    
    private SwapIntervalEXT_adr := GetProcAddress('glXSwapIntervalEXT');
    private ntv_SwapIntervalEXT_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; drawable: glx_drawable; interval: Int32)>(SwapIntervalEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SwapIntervalEXT(dpy: x_display_ptr; drawable: glx_drawable; interval: Int32) :=
      ntv_SwapIntervalEXT_1(dpy, drawable, interval);
    
  end;
  
  ///
  glxSwapControlTearEXT = static class
    public const _ExtStr = 'GLX_EXT_swap_control_tear';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxTextureFromPixmapEXT = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_EXT_texture_from_pixmap';
    
    private BindTexImageEXT_adr := GetProcAddress('glXBindTexImageEXT');
    private ntv_BindTexImageEXT_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; drawable: glx_drawable; buffer: Int32; var attrib_list: Int32)>(BindTexImageEXT_adr);
    private ntv_BindTexImageEXT_2 := GetProcOrNil&<procedure(dpy: x_display_ptr; drawable: glx_drawable; buffer: Int32; attrib_list: IntPtr)>(BindTexImageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTexImageEXT(dpy: x_display_ptr; drawable: glx_drawable; buffer: Int32; attrib_list: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (attrib_list<>nil) and (attrib_list.Length<>0) then
        ntv_BindTexImageEXT_1(dpy, drawable, buffer, attrib_list[0]) else
        ntv_BindTexImageEXT_1(dpy, drawable, buffer, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTexImageEXT(dpy: x_display_ptr; drawable: glx_drawable; buffer: Int32; var attrib_list: Int32) :=
      ntv_BindTexImageEXT_1(dpy, drawable, buffer, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTexImageEXT(dpy: x_display_ptr; drawable: glx_drawable; buffer: Int32; attrib_list: IntPtr) :=
      ntv_BindTexImageEXT_2(dpy, drawable, buffer, attrib_list);
    
    private ReleaseTexImageEXT_adr := GetProcAddress('glXReleaseTexImageEXT');
    private ntv_ReleaseTexImageEXT_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; drawable: glx_drawable; buffer: Int32)>(ReleaseTexImageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReleaseTexImageEXT(dpy: x_display_ptr; drawable: glx_drawable; buffer: Int32) :=
      ntv_ReleaseTexImageEXT_1(dpy, drawable, buffer);
    
  end;
  
  ///
  glxVisualInfoEXT = static class
    public const _ExtStr = 'GLX_EXT_visual_info';
  end;
  
  ///
  glxVisualRatingEXT = static class
    public const _ExtStr = 'GLX_EXT_visual_rating';
  end;
  
  ///
  glxSwapEventINTEL = static class
    public const _ExtStr = 'GLX_INTEL_swap_event';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxAgpOffsetMESA = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_MESA_agp_offset';
    
    private GetAGPOffsetMESA_adr := GetProcAddress('glXGetAGPOffsetMESA');
    private ntv_GetAGPOffsetMESA_1 := GetProcOrNil&<function(pointer: IntPtr): UInt32>(GetAGPOffsetMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAGPOffsetMESA(pointer: IntPtr): UInt32 :=
      ntv_GetAGPOffsetMESA_1(pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxCopySubBufferMESA = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_MESA_copy_sub_buffer';
    
    private CopySubBufferMESA_adr := GetProcAddress('glXCopySubBufferMESA');
    private ntv_CopySubBufferMESA_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; drawable: glx_drawable; x: Int32; y: Int32; width: Int32; height: Int32)>(CopySubBufferMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopySubBufferMESA(dpy: x_display_ptr; drawable: glx_drawable; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_CopySubBufferMESA_1(dpy, drawable, x, y, width, height);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxPixmapColormapMESA = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_MESA_pixmap_colormap';
    
    private CreateGLXPixmapMESA_adr := GetProcAddress('glXCreateGLXPixmapMESA');
    private ntv_CreateGLXPixmapMESA_1 := GetProcOrNil&<function(dpy: x_display_ptr; visual: x_visual_info_ptr; pixmap: x_pixel_map; cmap: x_color_map): glx_pixel_map>(CreateGLXPixmapMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPixmapMESA(dpy: x_display_ptr; visual: x_visual_info_ptr; pixmap: x_pixel_map; cmap: x_color_map): glx_pixel_map :=
      ntv_CreateGLXPixmapMESA_1(dpy, visual, pixmap, cmap);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxQueryRendererMESA = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_MESA_query_renderer';
    
    private QueryCurrentRendererIntegerMESA_adr := GetProcAddress('glXQueryCurrentRendererIntegerMESA');
    private ntv_QueryCurrentRendererIntegerMESA_1 := GetProcOrNil&<function(attribute: Int32; var value: UInt32): glBool8>(QueryCurrentRendererIntegerMESA_adr);
    private ntv_QueryCurrentRendererIntegerMESA_2 := GetProcOrNil&<function(attribute: Int32; value: IntPtr): glBool8>(QueryCurrentRendererIntegerMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererIntegerMESA(attribute: Int32; value: array of UInt32): glBool8;
    type PUInt32 = ^UInt32;
    begin
      Result := if (value<>nil) and (value.Length<>0) then
        ntv_QueryCurrentRendererIntegerMESA_1(attribute, value[0]) else
        ntv_QueryCurrentRendererIntegerMESA_1(attribute, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererIntegerMESA(attribute: Int32; var value: UInt32): glBool8 :=
      ntv_QueryCurrentRendererIntegerMESA_1(attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererIntegerMESA(attribute: Int32; value: IntPtr): glBool8 :=
      ntv_QueryCurrentRendererIntegerMESA_2(attribute, value);
    
    private QueryCurrentRendererStringMESA_adr := GetProcAddress('glXQueryCurrentRendererStringMESA');
    private ntv_QueryCurrentRendererStringMESA_1 := GetProcOrNil&<function(attribute: Int32): IntPtr>(QueryCurrentRendererStringMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererStringMESA(attribute: Int32): string :=
      Marshal.PtrToStringAnsi(ntv_QueryCurrentRendererStringMESA_1(attribute));
    
    private QueryRendererIntegerMESA_adr := GetProcAddress('glXQueryRendererIntegerMESA');
    private ntv_QueryRendererIntegerMESA_1 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; renderer: Int32; attribute: Int32; var value: UInt32): glBool8>(QueryRendererIntegerMESA_adr);
    private ntv_QueryRendererIntegerMESA_2 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; renderer: Int32; attribute: Int32; value: IntPtr): glBool8>(QueryRendererIntegerMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererIntegerMESA(dpy: x_display_ptr; screen: Int32; renderer: Int32; attribute: Int32; value: array of UInt32): glBool8;
    type PUInt32 = ^UInt32;
    begin
      Result := if (value<>nil) and (value.Length<>0) then
        ntv_QueryRendererIntegerMESA_1(dpy, screen, renderer, attribute, value[0]) else
        ntv_QueryRendererIntegerMESA_1(dpy, screen, renderer, attribute, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererIntegerMESA(dpy: x_display_ptr; screen: Int32; renderer: Int32; attribute: Int32; var value: UInt32): glBool8 :=
      ntv_QueryRendererIntegerMESA_1(dpy, screen, renderer, attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererIntegerMESA(dpy: x_display_ptr; screen: Int32; renderer: Int32; attribute: Int32; value: IntPtr): glBool8 :=
      ntv_QueryRendererIntegerMESA_2(dpy, screen, renderer, attribute, value);
    
    private QueryRendererStringMESA_adr := GetProcAddress('glXQueryRendererStringMESA');
    private ntv_QueryRendererStringMESA_1 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; renderer: Int32; attribute: Int32): IntPtr>(QueryRendererStringMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererStringMESA(dpy: x_display_ptr; screen: Int32; renderer: Int32; attribute: Int32): string :=
      Marshal.PtrToStringAnsi(ntv_QueryRendererStringMESA_1(dpy, screen, renderer, attribute));
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxReleaseBuffersMESA = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_MESA_release_buffers';
    
    private ReleaseBuffersMESA_adr := GetProcAddress('glXReleaseBuffersMESA');
    private ntv_ReleaseBuffersMESA_1 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable): glBool8>(ReleaseBuffersMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseBuffersMESA(dpy: x_display_ptr; drawable: glx_drawable): glBool8 :=
      ntv_ReleaseBuffersMESA_1(dpy, drawable);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxSet3dfxModeMESA = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_MESA_set_3dfx_mode';
    
    private Set3DfxModeMESA_adr := GetProcAddress('glXSet3DfxModeMESA');
    private ntv_Set3DfxModeMESA_1 := GetProcOrNil&<function(mode: Int32): glBool8>(Set3DfxModeMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function Set3DfxModeMESA(mode: Int32): glBool8 :=
      ntv_Set3DfxModeMESA_1(mode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxSwapControlMESA = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_MESA_swap_control';
    
    private GetSwapIntervalMESA_adr := GetProcAddress('glXGetSwapIntervalMESA');
    private ntv_GetSwapIntervalMESA_1 := GetProcOrNil&<function: Int32>(GetSwapIntervalMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSwapIntervalMESA: Int32 :=
      ntv_GetSwapIntervalMESA_1;
    
    private SwapIntervalMESA_adr := GetProcAddress('glXSwapIntervalMESA');
    private ntv_SwapIntervalMESA_1 := GetProcOrNil&<function(interval: UInt32): Int32>(SwapIntervalMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapIntervalMESA(interval: UInt32): Int32 :=
      ntv_SwapIntervalMESA_1(interval);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxCopyBufferNV = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_NV_copy_buffer';
    
    private CopyBufferSubDataNV_adr := GetProcAddress('glXCopyBufferSubDataNV');
    private ntv_CopyBufferSubDataNV_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; readCtx: glx_context; writeCtx: glx_context; readTarget: DummyEnum; writeTarget: DummyEnum; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(CopyBufferSubDataNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyBufferSubDataNV(dpy: x_display_ptr; readCtx: glx_context; writeCtx: glx_context; readTarget: DummyEnum; writeTarget: DummyEnum; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) :=
      ntv_CopyBufferSubDataNV_1(dpy, readCtx, writeCtx, readTarget, writeTarget, readOffset, writeOffset, size);
    
    private NamedCopyBufferSubDataNV_adr := GetProcAddress('glXNamedCopyBufferSubDataNV');
    private ntv_NamedCopyBufferSubDataNV_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; readCtx: glx_context; writeCtx: glx_context; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(NamedCopyBufferSubDataNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedCopyBufferSubDataNV(dpy: x_display_ptr; readCtx: glx_context; writeCtx: glx_context; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) :=
      ntv_NamedCopyBufferSubDataNV_1(dpy, readCtx, writeCtx, readBuffer, writeBuffer, readOffset, writeOffset, size);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxCopyImageNV = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_NV_copy_image';
    
    private CopyImageSubDataNV_adr := GetProcAddress('glXCopyImageSubDataNV');
    private ntv_CopyImageSubDataNV_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; srcCtx: glx_context; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstCtx: glx_context; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32)>(CopyImageSubDataNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyImageSubDataNV(dpy: x_display_ptr; srcCtx: glx_context; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstCtx: glx_context; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32) :=
      ntv_CopyImageSubDataNV_1(dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxDelayBeforeSwapNV = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_NV_delay_before_swap';
    
    private DelayBeforeSwapNV_adr := GetProcAddress('glXDelayBeforeSwapNV');
    private ntv_DelayBeforeSwapNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; seconds: single): glBool8>(DelayBeforeSwapNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DelayBeforeSwapNV(dpy: x_display_ptr; drawable: glx_drawable; seconds: single): glBool8 :=
      ntv_DelayBeforeSwapNV_1(dpy, drawable, seconds);
    
  end;
  
  ///
  glxFloatBufferNV = static class
    public const _ExtStr = 'GLX_NV_float_buffer';
  end;
  
  ///
  glxMultigpuContextNV = static class
    public const _ExtStr = 'GLX_NV_multigpu_context';
  end;
  
  ///
  glxMultisampleCoverageNV = static class
    public const _ExtStr = 'GLX_NV_multisample_coverage';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxPresentVideoNV = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_NV_present_video';
    
    private EnumerateVideoDevicesNV_adr := GetProcAddress('glXEnumerateVideoDevicesNV');
    private ntv_EnumerateVideoDevicesNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; var nelements: Int32): ^UInt32>(EnumerateVideoDevicesNV_adr);
    private ntv_EnumerateVideoDevicesNV_2 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; nelements: IntPtr): ^UInt32>(EnumerateVideoDevicesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(dpy: x_display_ptr; screen: Int32; nelements: array of Int32): ^UInt32;
    type PInt32 = ^Int32;
    begin
      Result := if (nelements<>nil) and (nelements.Length<>0) then
        ntv_EnumerateVideoDevicesNV_1(dpy, screen, nelements[0]) else
        ntv_EnumerateVideoDevicesNV_1(dpy, screen, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(dpy: x_display_ptr; screen: Int32; var nelements: Int32): ^UInt32 :=
      ntv_EnumerateVideoDevicesNV_1(dpy, screen, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(dpy: x_display_ptr; screen: Int32; nelements: IntPtr): ^UInt32 :=
      ntv_EnumerateVideoDevicesNV_2(dpy, screen, nelements);
    
    private BindVideoDeviceNV_adr := GetProcAddress('glXBindVideoDeviceNV');
    private ntv_BindVideoDeviceNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; video_slot: UInt32; video_device: UInt32; var attrib_list: Int32): Int32>(BindVideoDeviceNV_adr);
    private ntv_BindVideoDeviceNV_2 := GetProcOrNil&<function(dpy: x_display_ptr; video_slot: UInt32; video_device: UInt32; attrib_list: IntPtr): Int32>(BindVideoDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(dpy: x_display_ptr; video_slot: UInt32; video_device: UInt32; attrib_list: array of Int32): Int32;
    type PInt32 = ^Int32;
    begin
      Result := if (attrib_list<>nil) and (attrib_list.Length<>0) then
        ntv_BindVideoDeviceNV_1(dpy, video_slot, video_device, attrib_list[0]) else
        ntv_BindVideoDeviceNV_1(dpy, video_slot, video_device, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(dpy: x_display_ptr; video_slot: UInt32; video_device: UInt32; var attrib_list: Int32): Int32 :=
      ntv_BindVideoDeviceNV_1(dpy, video_slot, video_device, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(dpy: x_display_ptr; video_slot: UInt32; video_device: UInt32; attrib_list: IntPtr): Int32 :=
      ntv_BindVideoDeviceNV_2(dpy, video_slot, video_device, attrib_list);
    
  end;
  
  ///
  glxRobustnessVideoMemoryPurgeNV = static class
    public const _ExtStr = 'GLX_NV_robustness_video_memory_purge';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxSwapGroupNV = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_NV_swap_group';
    
    private JoinSwapGroupNV_adr := GetProcAddress('glXJoinSwapGroupNV');
    private ntv_JoinSwapGroupNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; group: UInt32): glBool8>(JoinSwapGroupNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function JoinSwapGroupNV(dpy: x_display_ptr; drawable: glx_drawable; group: UInt32): glBool8 :=
      ntv_JoinSwapGroupNV_1(dpy, drawable, group);
    
    private BindSwapBarrierNV_adr := GetProcAddress('glXBindSwapBarrierNV');
    private ntv_BindSwapBarrierNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; group: UInt32; barrier: UInt32): glBool8>(BindSwapBarrierNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindSwapBarrierNV(dpy: x_display_ptr; group: UInt32; barrier: UInt32): glBool8 :=
      ntv_BindSwapBarrierNV_1(dpy, group, barrier);
    
    private QuerySwapGroupNV_adr := GetProcAddress('glXQuerySwapGroupNV');
    private ntv_QuerySwapGroupNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; var group: UInt32; var barrier: UInt32): glBool8>(QuerySwapGroupNV_adr);
    private ntv_QuerySwapGroupNV_2 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; var group: UInt32; barrier: IntPtr): glBool8>(QuerySwapGroupNV_adr);
    private ntv_QuerySwapGroupNV_3 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; group: IntPtr; var barrier: UInt32): glBool8>(QuerySwapGroupNV_adr);
    private ntv_QuerySwapGroupNV_4 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; group: IntPtr; barrier: IntPtr): glBool8>(QuerySwapGroupNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: x_display_ptr; drawable: glx_drawable; group: array of UInt32; barrier: array of UInt32): glBool8;
    type PUInt32 = ^UInt32;
    begin
      Result := if (barrier<>nil) and (barrier.Length<>0) then
        if (group<>nil) and (group.Length<>0) then
          ntv_QuerySwapGroupNV_1(dpy, drawable, group[0], barrier[0]) else
          ntv_QuerySwapGroupNV_1(dpy, drawable, PUInt32(nil)^, barrier[0]) else
        if (group<>nil) and (group.Length<>0) then
          ntv_QuerySwapGroupNV_1(dpy, drawable, group[0], PUInt32(nil)^) else
          ntv_QuerySwapGroupNV_1(dpy, drawable, PUInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: x_display_ptr; drawable: glx_drawable; var group: UInt32; var barrier: UInt32): glBool8 :=
      ntv_QuerySwapGroupNV_1(dpy, drawable, group, barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: x_display_ptr; drawable: glx_drawable; var group: UInt32; barrier: IntPtr): glBool8 :=
      ntv_QuerySwapGroupNV_2(dpy, drawable, group, barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: x_display_ptr; drawable: glx_drawable; group: IntPtr; var barrier: UInt32): glBool8 :=
      ntv_QuerySwapGroupNV_3(dpy, drawable, group, barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: x_display_ptr; drawable: glx_drawable; group: IntPtr; barrier: IntPtr): glBool8 :=
      ntv_QuerySwapGroupNV_4(dpy, drawable, group, barrier);
    
    private QueryMaxSwapGroupsNV_adr := GetProcAddress('glXQueryMaxSwapGroupsNV');
    private ntv_QueryMaxSwapGroupsNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; var maxGroups: UInt32; var maxBarriers: UInt32): glBool8>(QueryMaxSwapGroupsNV_adr);
    private ntv_QueryMaxSwapGroupsNV_2 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; var maxGroups: UInt32; maxBarriers: IntPtr): glBool8>(QueryMaxSwapGroupsNV_adr);
    private ntv_QueryMaxSwapGroupsNV_3 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; maxGroups: IntPtr; var maxBarriers: UInt32): glBool8>(QueryMaxSwapGroupsNV_adr);
    private ntv_QueryMaxSwapGroupsNV_4 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; maxGroups: IntPtr; maxBarriers: IntPtr): glBool8>(QueryMaxSwapGroupsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: x_display_ptr; screen: Int32; maxGroups: array of UInt32; maxBarriers: array of UInt32): glBool8;
    type PUInt32 = ^UInt32;
    begin
      Result := if (maxBarriers<>nil) and (maxBarriers.Length<>0) then
        if (maxGroups<>nil) and (maxGroups.Length<>0) then
          ntv_QueryMaxSwapGroupsNV_1(dpy, screen, maxGroups[0], maxBarriers[0]) else
          ntv_QueryMaxSwapGroupsNV_1(dpy, screen, PUInt32(nil)^, maxBarriers[0]) else
        if (maxGroups<>nil) and (maxGroups.Length<>0) then
          ntv_QueryMaxSwapGroupsNV_1(dpy, screen, maxGroups[0], PUInt32(nil)^) else
          ntv_QueryMaxSwapGroupsNV_1(dpy, screen, PUInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: x_display_ptr; screen: Int32; var maxGroups: UInt32; var maxBarriers: UInt32): glBool8 :=
      ntv_QueryMaxSwapGroupsNV_1(dpy, screen, maxGroups, maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: x_display_ptr; screen: Int32; var maxGroups: UInt32; maxBarriers: IntPtr): glBool8 :=
      ntv_QueryMaxSwapGroupsNV_2(dpy, screen, maxGroups, maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: x_display_ptr; screen: Int32; maxGroups: IntPtr; var maxBarriers: UInt32): glBool8 :=
      ntv_QueryMaxSwapGroupsNV_3(dpy, screen, maxGroups, maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: x_display_ptr; screen: Int32; maxGroups: IntPtr; maxBarriers: IntPtr): glBool8 :=
      ntv_QueryMaxSwapGroupsNV_4(dpy, screen, maxGroups, maxBarriers);
    
    private QueryFrameCountNV_adr := GetProcAddress('glXQueryFrameCountNV');
    private ntv_QueryFrameCountNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; var count: UInt32): glBool8>(QueryFrameCountNV_adr);
    private ntv_QueryFrameCountNV_2 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; count: IntPtr): glBool8>(QueryFrameCountNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(dpy: x_display_ptr; screen: Int32; count: array of UInt32): glBool8;
    type PUInt32 = ^UInt32;
    begin
      Result := if (count<>nil) and (count.Length<>0) then
        ntv_QueryFrameCountNV_1(dpy, screen, count[0]) else
        ntv_QueryFrameCountNV_1(dpy, screen, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(dpy: x_display_ptr; screen: Int32; var count: UInt32): glBool8 :=
      ntv_QueryFrameCountNV_1(dpy, screen, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(dpy: x_display_ptr; screen: Int32; count: IntPtr): glBool8 :=
      ntv_QueryFrameCountNV_2(dpy, screen, count);
    
    private ResetFrameCountNV_adr := GetProcAddress('glXResetFrameCountNV');
    private ntv_ResetFrameCountNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32): glBool8>(ResetFrameCountNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ResetFrameCountNV(dpy: x_display_ptr; screen: Int32): glBool8 :=
      ntv_ResetFrameCountNV_1(dpy, screen);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxVideoCaptureNV = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_NV_video_capture';
    
    private BindVideoCaptureDeviceNV_adr := GetProcAddress('glXBindVideoCaptureDeviceNV');
    private ntv_BindVideoCaptureDeviceNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; video_capture_slot: UInt32; device: glx_video_capture_device_NV): Int32>(BindVideoCaptureDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoCaptureDeviceNV(dpy: x_display_ptr; video_capture_slot: UInt32; device: glx_video_capture_device_NV): Int32 :=
      ntv_BindVideoCaptureDeviceNV_1(dpy, video_capture_slot, device);
    
    private EnumerateVideoCaptureDevicesNV_adr := GetProcAddress('glXEnumerateVideoCaptureDevicesNV');
    private ntv_EnumerateVideoCaptureDevicesNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; var nelements: Int32): ^glx_video_capture_device_NV>(EnumerateVideoCaptureDevicesNV_adr);
    private ntv_EnumerateVideoCaptureDevicesNV_2 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; nelements: IntPtr): ^glx_video_capture_device_NV>(EnumerateVideoCaptureDevicesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(dpy: x_display_ptr; screen: Int32; nelements: array of Int32): ^glx_video_capture_device_NV;
    type PInt32 = ^Int32;
    begin
      Result := if (nelements<>nil) and (nelements.Length<>0) then
        ntv_EnumerateVideoCaptureDevicesNV_1(dpy, screen, nelements[0]) else
        ntv_EnumerateVideoCaptureDevicesNV_1(dpy, screen, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(dpy: x_display_ptr; screen: Int32; var nelements: Int32): ^glx_video_capture_device_NV :=
      ntv_EnumerateVideoCaptureDevicesNV_1(dpy, screen, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(dpy: x_display_ptr; screen: Int32; nelements: IntPtr): ^glx_video_capture_device_NV :=
      ntv_EnumerateVideoCaptureDevicesNV_2(dpy, screen, nelements);
    
    private LockVideoCaptureDeviceNV_adr := GetProcAddress('glXLockVideoCaptureDeviceNV');
    private ntv_LockVideoCaptureDeviceNV_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; device: glx_video_capture_device_NV)>(LockVideoCaptureDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LockVideoCaptureDeviceNV(dpy: x_display_ptr; device: glx_video_capture_device_NV) :=
      ntv_LockVideoCaptureDeviceNV_1(dpy, device);
    
    private QueryVideoCaptureDeviceNV_adr := GetProcAddress('glXQueryVideoCaptureDeviceNV');
    private ntv_QueryVideoCaptureDeviceNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; device: glx_video_capture_device_NV; attribute: Int32; var value: Int32): Int32>(QueryVideoCaptureDeviceNV_adr);
    private ntv_QueryVideoCaptureDeviceNV_2 := GetProcOrNil&<function(dpy: x_display_ptr; device: glx_video_capture_device_NV; attribute: Int32; value: IntPtr): Int32>(QueryVideoCaptureDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(dpy: x_display_ptr; device: glx_video_capture_device_NV; attribute: Int32; value: array of Int32): Int32;
    type PInt32 = ^Int32;
    begin
      Result := if (value<>nil) and (value.Length<>0) then
        ntv_QueryVideoCaptureDeviceNV_1(dpy, device, attribute, value[0]) else
        ntv_QueryVideoCaptureDeviceNV_1(dpy, device, attribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(dpy: x_display_ptr; device: glx_video_capture_device_NV; attribute: Int32; var value: Int32): Int32 :=
      ntv_QueryVideoCaptureDeviceNV_1(dpy, device, attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(dpy: x_display_ptr; device: glx_video_capture_device_NV; attribute: Int32; value: IntPtr): Int32 :=
      ntv_QueryVideoCaptureDeviceNV_2(dpy, device, attribute, value);
    
    private ReleaseVideoCaptureDeviceNV_adr := GetProcAddress('glXReleaseVideoCaptureDeviceNV');
    private ntv_ReleaseVideoCaptureDeviceNV_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; device: glx_video_capture_device_NV)>(ReleaseVideoCaptureDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReleaseVideoCaptureDeviceNV(dpy: x_display_ptr; device: glx_video_capture_device_NV) :=
      ntv_ReleaseVideoCaptureDeviceNV_1(dpy, device);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxVideoOutNV = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_NV_video_out';
    
    private GetVideoDeviceNV_adr := GetProcAddress('glXGetVideoDeviceNV');
    private ntv_GetVideoDeviceNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; numVideoDevices: Int32; var pVideoDevice: glx_video_device_NV): Int32>(GetVideoDeviceNV_adr);
    private ntv_GetVideoDeviceNV_2 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; numVideoDevices: Int32; pVideoDevice: IntPtr): Int32>(GetVideoDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoDeviceNV(dpy: x_display_ptr; screen: Int32; numVideoDevices: Int32; var pVideoDevice: glx_video_device_NV): Int32 :=
      ntv_GetVideoDeviceNV_1(dpy, screen, numVideoDevices, pVideoDevice);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoDeviceNV(dpy: x_display_ptr; screen: Int32; numVideoDevices: Int32; pVideoDevice: IntPtr): Int32 :=
      ntv_GetVideoDeviceNV_2(dpy, screen, numVideoDevices, pVideoDevice);
    
    private ReleaseVideoDeviceNV_adr := GetProcAddress('glXReleaseVideoDeviceNV');
    private ntv_ReleaseVideoDeviceNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; VideoDevice: glx_video_device_NV): Int32>(ReleaseVideoDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseVideoDeviceNV(dpy: x_display_ptr; screen: Int32; VideoDevice: glx_video_device_NV): Int32 :=
      ntv_ReleaseVideoDeviceNV_1(dpy, screen, VideoDevice);
    
    private BindVideoImageNV_adr := GetProcAddress('glXBindVideoImageNV');
    private ntv_BindVideoImageNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; VideoDevice: glx_video_device_NV; pbuf: glx_pixel_buffer; iVideoBuffer: Int32): Int32>(BindVideoImageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoImageNV(dpy: x_display_ptr; VideoDevice: glx_video_device_NV; pbuf: glx_pixel_buffer; iVideoBuffer: Int32): Int32 :=
      ntv_BindVideoImageNV_1(dpy, VideoDevice, pbuf, iVideoBuffer);
    
    private ReleaseVideoImageNV_adr := GetProcAddress('glXReleaseVideoImageNV');
    private ntv_ReleaseVideoImageNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; pbuf: glx_pixel_buffer): Int32>(ReleaseVideoImageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseVideoImageNV(dpy: x_display_ptr; pbuf: glx_pixel_buffer): Int32 :=
      ntv_ReleaseVideoImageNV_1(dpy, pbuf);
    
    private SendPbufferToVideoNV_adr := GetProcAddress('glXSendPbufferToVideoNV');
    private ntv_SendPbufferToVideoNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; pbuf: glx_pixel_buffer; iBufferType: Int32; var pulCounterPbuffer: UInt32; bBlock: glBool8): Int32>(SendPbufferToVideoNV_adr);
    private ntv_SendPbufferToVideoNV_2 := GetProcOrNil&<function(dpy: x_display_ptr; pbuf: glx_pixel_buffer; iBufferType: Int32; pulCounterPbuffer: IntPtr; bBlock: glBool8): Int32>(SendPbufferToVideoNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(dpy: x_display_ptr; pbuf: glx_pixel_buffer; iBufferType: Int32; pulCounterPbuffer: array of UInt32; bBlock: glBool8): Int32;
    type PUInt32 = ^UInt32;
    begin
      Result := if (pulCounterPbuffer<>nil) and (pulCounterPbuffer.Length<>0) then
        ntv_SendPbufferToVideoNV_1(dpy, pbuf, iBufferType, pulCounterPbuffer[0], bBlock) else
        ntv_SendPbufferToVideoNV_1(dpy, pbuf, iBufferType, PUInt32(nil)^, bBlock);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(dpy: x_display_ptr; pbuf: glx_pixel_buffer; iBufferType: Int32; var pulCounterPbuffer: UInt32; bBlock: glBool8): Int32 :=
      ntv_SendPbufferToVideoNV_1(dpy, pbuf, iBufferType, pulCounterPbuffer, bBlock);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(dpy: x_display_ptr; pbuf: glx_pixel_buffer; iBufferType: Int32; pulCounterPbuffer: IntPtr; bBlock: glBool8): Int32 :=
      ntv_SendPbufferToVideoNV_2(dpy, pbuf, iBufferType, pulCounterPbuffer, bBlock);
    
    private GetVideoInfoNV_adr := GetProcAddress('glXGetVideoInfoNV');
    private ntv_GetVideoInfoNV_1 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; VideoDevice: glx_video_device_NV; var pulCounterOutputPbuffer: UInt32; var pulCounterOutputVideo: UInt32): Int32>(GetVideoInfoNV_adr);
    private ntv_GetVideoInfoNV_2 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; VideoDevice: glx_video_device_NV; var pulCounterOutputPbuffer: UInt32; pulCounterOutputVideo: IntPtr): Int32>(GetVideoInfoNV_adr);
    private ntv_GetVideoInfoNV_3 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; VideoDevice: glx_video_device_NV; pulCounterOutputPbuffer: IntPtr; var pulCounterOutputVideo: UInt32): Int32>(GetVideoInfoNV_adr);
    private ntv_GetVideoInfoNV_4 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; VideoDevice: glx_video_device_NV; pulCounterOutputPbuffer: IntPtr; pulCounterOutputVideo: IntPtr): Int32>(GetVideoInfoNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(dpy: x_display_ptr; screen: Int32; VideoDevice: glx_video_device_NV; var pulCounterOutputPbuffer: UInt32; var pulCounterOutputVideo: UInt32): Int32 :=
      ntv_GetVideoInfoNV_1(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(dpy: x_display_ptr; screen: Int32; VideoDevice: glx_video_device_NV; var pulCounterOutputPbuffer: UInt32; pulCounterOutputVideo: IntPtr): Int32 :=
      ntv_GetVideoInfoNV_2(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(dpy: x_display_ptr; screen: Int32; VideoDevice: glx_video_device_NV; pulCounterOutputPbuffer: IntPtr; var pulCounterOutputVideo: UInt32): Int32 :=
      ntv_GetVideoInfoNV_3(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(dpy: x_display_ptr; screen: Int32; VideoDevice: glx_video_device_NV; pulCounterOutputPbuffer: IntPtr; pulCounterOutputVideo: IntPtr): Int32 :=
      ntv_GetVideoInfoNV_4(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    
  end;
  
  ///
  glxSwapMethodOML = static class
    public const _ExtStr = 'GLX_OML_swap_method';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxSyncControlOML = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_OML_sync_control';
    
    private GetSyncValuesOML_adr := GetProcAddress('glXGetSyncValuesOML');
    private ntv_GetSyncValuesOML_1 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; var ust: Int64; var msc: Int64; var sbc: Int64): glBool8>(GetSyncValuesOML_adr);
    private ntv_GetSyncValuesOML_2 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; var ust: Int64; var msc: Int64; sbc: IntPtr): glBool8>(GetSyncValuesOML_adr);
    private ntv_GetSyncValuesOML_3 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; var ust: Int64; msc: IntPtr; var sbc: Int64): glBool8>(GetSyncValuesOML_adr);
    private ntv_GetSyncValuesOML_4 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; var ust: Int64; msc: IntPtr; sbc: IntPtr): glBool8>(GetSyncValuesOML_adr);
    private ntv_GetSyncValuesOML_5 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; ust: IntPtr; var msc: Int64; var sbc: Int64): glBool8>(GetSyncValuesOML_adr);
    private ntv_GetSyncValuesOML_6 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; ust: IntPtr; var msc: Int64; sbc: IntPtr): glBool8>(GetSyncValuesOML_adr);
    private ntv_GetSyncValuesOML_7 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; ust: IntPtr; msc: IntPtr; var sbc: Int64): glBool8>(GetSyncValuesOML_adr);
    private ntv_GetSyncValuesOML_8 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; ust: IntPtr; msc: IntPtr; sbc: IntPtr): glBool8>(GetSyncValuesOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: x_display_ptr; drawable: glx_drawable; var ust: Int64; var msc: Int64; var sbc: Int64): glBool8 :=
      ntv_GetSyncValuesOML_1(dpy, drawable, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: x_display_ptr; drawable: glx_drawable; var ust: Int64; var msc: Int64; sbc: IntPtr): glBool8 :=
      ntv_GetSyncValuesOML_2(dpy, drawable, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: x_display_ptr; drawable: glx_drawable; var ust: Int64; msc: IntPtr; var sbc: Int64): glBool8 :=
      ntv_GetSyncValuesOML_3(dpy, drawable, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: x_display_ptr; drawable: glx_drawable; var ust: Int64; msc: IntPtr; sbc: IntPtr): glBool8 :=
      ntv_GetSyncValuesOML_4(dpy, drawable, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: x_display_ptr; drawable: glx_drawable; ust: IntPtr; var msc: Int64; var sbc: Int64): glBool8 :=
      ntv_GetSyncValuesOML_5(dpy, drawable, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: x_display_ptr; drawable: glx_drawable; ust: IntPtr; var msc: Int64; sbc: IntPtr): glBool8 :=
      ntv_GetSyncValuesOML_6(dpy, drawable, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: x_display_ptr; drawable: glx_drawable; ust: IntPtr; msc: IntPtr; var sbc: Int64): glBool8 :=
      ntv_GetSyncValuesOML_7(dpy, drawable, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: x_display_ptr; drawable: glx_drawable; ust: IntPtr; msc: IntPtr; sbc: IntPtr): glBool8 :=
      ntv_GetSyncValuesOML_8(dpy, drawable, ust, msc, sbc);
    
    private GetMscRateOML_adr := GetProcAddress('glXGetMscRateOML');
    private ntv_GetMscRateOML_1 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; var numerator: Int32; var denominator: Int32): glBool8>(GetMscRateOML_adr);
    private ntv_GetMscRateOML_2 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; var numerator: Int32; denominator: IntPtr): glBool8>(GetMscRateOML_adr);
    private ntv_GetMscRateOML_3 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; numerator: IntPtr; var denominator: Int32): glBool8>(GetMscRateOML_adr);
    private ntv_GetMscRateOML_4 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; numerator: IntPtr; denominator: IntPtr): glBool8>(GetMscRateOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(dpy: x_display_ptr; drawable: glx_drawable; var numerator: Int32; var denominator: Int32): glBool8 :=
      ntv_GetMscRateOML_1(dpy, drawable, numerator, denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(dpy: x_display_ptr; drawable: glx_drawable; var numerator: Int32; denominator: IntPtr): glBool8 :=
      ntv_GetMscRateOML_2(dpy, drawable, numerator, denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(dpy: x_display_ptr; drawable: glx_drawable; numerator: IntPtr; var denominator: Int32): glBool8 :=
      ntv_GetMscRateOML_3(dpy, drawable, numerator, denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(dpy: x_display_ptr; drawable: glx_drawable; numerator: IntPtr; denominator: IntPtr): glBool8 :=
      ntv_GetMscRateOML_4(dpy, drawable, numerator, denominator);
    
    private SwapBuffersMscOML_adr := GetProcAddress('glXSwapBuffersMscOML');
    private ntv_SwapBuffersMscOML_1 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64): Int64>(SwapBuffersMscOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapBuffersMscOML(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64): Int64 :=
      ntv_SwapBuffersMscOML_1(dpy, drawable, target_msc, divisor, remainder);
    
    private WaitForMscOML_adr := GetProcAddress('glXWaitForMscOML');
    private ntv_WaitForMscOML_1 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): glBool8>(WaitForMscOML_adr);
    private ntv_WaitForMscOML_2 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; sbc: IntPtr): glBool8>(WaitForMscOML_adr);
    private ntv_WaitForMscOML_3 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: IntPtr; var sbc: Int64): glBool8>(WaitForMscOML_adr);
    private ntv_WaitForMscOML_4 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: IntPtr; sbc: IntPtr): glBool8>(WaitForMscOML_adr);
    private ntv_WaitForMscOML_5 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; var msc: Int64; var sbc: Int64): glBool8>(WaitForMscOML_adr);
    private ntv_WaitForMscOML_6 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; var msc: Int64; sbc: IntPtr): glBool8>(WaitForMscOML_adr);
    private ntv_WaitForMscOML_7 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; msc: IntPtr; var sbc: Int64): glBool8>(WaitForMscOML_adr);
    private ntv_WaitForMscOML_8 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; msc: IntPtr; sbc: IntPtr): glBool8>(WaitForMscOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: array of Int64; sbc: array of Int64): glBool8;
    type PInt64 = ^Int64;
    begin
      Result := if (sbc<>nil) and (sbc.Length<>0) then
        if (ust<>nil) and (ust.Length<>0) then
          if (msc<>nil) and (msc.Length<>0) then
            ntv_WaitForMscOML_1(dpy, drawable, target_msc, divisor, remainder, ust[0], msc[0], sbc[0]) else
            ntv_WaitForMscOML_1(dpy, drawable, target_msc, divisor, remainder, ust[0], PInt64(nil)^, sbc[0]) else
          if (msc<>nil) and (msc.Length<>0) then
            ntv_WaitForMscOML_1(dpy, drawable, target_msc, divisor, remainder, PInt64(nil)^, msc[0], sbc[0]) else
            ntv_WaitForMscOML_1(dpy, drawable, target_msc, divisor, remainder, PInt64(nil)^, PInt64(nil)^, sbc[0]) else
        if (ust<>nil) and (ust.Length<>0) then
          if (msc<>nil) and (msc.Length<>0) then
            ntv_WaitForMscOML_1(dpy, drawable, target_msc, divisor, remainder, ust[0], msc[0], PInt64(nil)^) else
            ntv_WaitForMscOML_1(dpy, drawable, target_msc, divisor, remainder, ust[0], PInt64(nil)^, PInt64(nil)^) else
          if (msc<>nil) and (msc.Length<>0) then
            ntv_WaitForMscOML_1(dpy, drawable, target_msc, divisor, remainder, PInt64(nil)^, msc[0], PInt64(nil)^) else
            ntv_WaitForMscOML_1(dpy, drawable, target_msc, divisor, remainder, PInt64(nil)^, PInt64(nil)^, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): glBool8 :=
      ntv_WaitForMscOML_1(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; sbc: IntPtr): glBool8 :=
      ntv_WaitForMscOML_2(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: IntPtr; var sbc: Int64): glBool8 :=
      ntv_WaitForMscOML_3(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: IntPtr; sbc: IntPtr): glBool8 :=
      ntv_WaitForMscOML_4(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; var msc: Int64; var sbc: Int64): glBool8 :=
      ntv_WaitForMscOML_5(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; var msc: Int64; sbc: IntPtr): glBool8 :=
      ntv_WaitForMscOML_6(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; msc: IntPtr; var sbc: Int64): glBool8 :=
      ntv_WaitForMscOML_7(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_display_ptr; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; msc: IntPtr; sbc: IntPtr): glBool8 :=
      ntv_WaitForMscOML_8(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    
    private WaitForSbcOML_adr := GetProcAddress('glXWaitForSbcOML');
    private ntv_WaitForSbcOML_1 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; target_sbc: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): glBool8>(WaitForSbcOML_adr);
    private ntv_WaitForSbcOML_2 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; target_sbc: Int64; var ust: Int64; var msc: Int64; sbc: IntPtr): glBool8>(WaitForSbcOML_adr);
    private ntv_WaitForSbcOML_3 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; target_sbc: Int64; var ust: Int64; msc: IntPtr; var sbc: Int64): glBool8>(WaitForSbcOML_adr);
    private ntv_WaitForSbcOML_4 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; target_sbc: Int64; var ust: Int64; msc: IntPtr; sbc: IntPtr): glBool8>(WaitForSbcOML_adr);
    private ntv_WaitForSbcOML_5 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; target_sbc: Int64; ust: IntPtr; var msc: Int64; var sbc: Int64): glBool8>(WaitForSbcOML_adr);
    private ntv_WaitForSbcOML_6 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; target_sbc: Int64; ust: IntPtr; var msc: Int64; sbc: IntPtr): glBool8>(WaitForSbcOML_adr);
    private ntv_WaitForSbcOML_7 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; target_sbc: Int64; ust: IntPtr; msc: IntPtr; var sbc: Int64): glBool8>(WaitForSbcOML_adr);
    private ntv_WaitForSbcOML_8 := GetProcOrNil&<function(dpy: x_display_ptr; drawable: glx_drawable; target_sbc: Int64; ust: IntPtr; msc: IntPtr; sbc: IntPtr): glBool8>(WaitForSbcOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_display_ptr; drawable: glx_drawable; target_sbc: Int64; ust: array of Int64; msc: array of Int64; sbc: array of Int64): glBool8;
    type PInt64 = ^Int64;
    begin
      Result := if (sbc<>nil) and (sbc.Length<>0) then
        if (ust<>nil) and (ust.Length<>0) then
          if (msc<>nil) and (msc.Length<>0) then
            ntv_WaitForSbcOML_1(dpy, drawable, target_sbc, ust[0], msc[0], sbc[0]) else
            ntv_WaitForSbcOML_1(dpy, drawable, target_sbc, ust[0], PInt64(nil)^, sbc[0]) else
          if (msc<>nil) and (msc.Length<>0) then
            ntv_WaitForSbcOML_1(dpy, drawable, target_sbc, PInt64(nil)^, msc[0], sbc[0]) else
            ntv_WaitForSbcOML_1(dpy, drawable, target_sbc, PInt64(nil)^, PInt64(nil)^, sbc[0]) else
        if (ust<>nil) and (ust.Length<>0) then
          if (msc<>nil) and (msc.Length<>0) then
            ntv_WaitForSbcOML_1(dpy, drawable, target_sbc, ust[0], msc[0], PInt64(nil)^) else
            ntv_WaitForSbcOML_1(dpy, drawable, target_sbc, ust[0], PInt64(nil)^, PInt64(nil)^) else
          if (msc<>nil) and (msc.Length<>0) then
            ntv_WaitForSbcOML_1(dpy, drawable, target_sbc, PInt64(nil)^, msc[0], PInt64(nil)^) else
            ntv_WaitForSbcOML_1(dpy, drawable, target_sbc, PInt64(nil)^, PInt64(nil)^, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_display_ptr; drawable: glx_drawable; target_sbc: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): glBool8 :=
      ntv_WaitForSbcOML_1(dpy, drawable, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_display_ptr; drawable: glx_drawable; target_sbc: Int64; var ust: Int64; var msc: Int64; sbc: IntPtr): glBool8 :=
      ntv_WaitForSbcOML_2(dpy, drawable, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_display_ptr; drawable: glx_drawable; target_sbc: Int64; var ust: Int64; msc: IntPtr; var sbc: Int64): glBool8 :=
      ntv_WaitForSbcOML_3(dpy, drawable, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_display_ptr; drawable: glx_drawable; target_sbc: Int64; var ust: Int64; msc: IntPtr; sbc: IntPtr): glBool8 :=
      ntv_WaitForSbcOML_4(dpy, drawable, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_display_ptr; drawable: glx_drawable; target_sbc: Int64; ust: IntPtr; var msc: Int64; var sbc: Int64): glBool8 :=
      ntv_WaitForSbcOML_5(dpy, drawable, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_display_ptr; drawable: glx_drawable; target_sbc: Int64; ust: IntPtr; var msc: Int64; sbc: IntPtr): glBool8 :=
      ntv_WaitForSbcOML_6(dpy, drawable, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_display_ptr; drawable: glx_drawable; target_sbc: Int64; ust: IntPtr; msc: IntPtr; var sbc: Int64): glBool8 :=
      ntv_WaitForSbcOML_7(dpy, drawable, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_display_ptr; drawable: glx_drawable; target_sbc: Int64; ust: IntPtr; msc: IntPtr; sbc: IntPtr): glBool8 :=
      ntv_WaitForSbcOML_8(dpy, drawable, target_sbc, ust, msc, sbc);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxCushionSGI = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_SGI_cushion';
    
    private CushionSGI_adr := GetProcAddress('glXCushionSGI');
    private ntv_CushionSGI_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; window: x_window; cushion: single)>(CushionSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CushionSGI(dpy: x_display_ptr; window: x_window; cushion: single) :=
      ntv_CushionSGI_1(dpy, window, cushion);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxMakeCurrentReadSGI = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_SGI_make_current_read';
    
    private MakeCurrentReadSGI_adr := GetProcAddress('glXMakeCurrentReadSGI');
    private ntv_MakeCurrentReadSGI_1 := GetProcOrNil&<function(dpy: x_display_ptr; draw: glx_drawable; read: glx_drawable; ctx: glx_context): glBool8>(MakeCurrentReadSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeCurrentReadSGI(dpy: x_display_ptr; draw: glx_drawable; read: glx_drawable; ctx: glx_context): glBool8 :=
      ntv_MakeCurrentReadSGI_1(dpy, draw, read, ctx);
    
    private GetCurrentReadDrawableSGI_adr := GetProcAddress('glXGetCurrentReadDrawableSGI');
    private ntv_GetCurrentReadDrawableSGI_1 := GetProcOrNil&<function: glx_drawable>(GetCurrentReadDrawableSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentReadDrawableSGI: glx_drawable :=
      ntv_GetCurrentReadDrawableSGI_1;
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxSwapControlSGI = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_SGI_swap_control';
    
    private SwapIntervalSGI_adr := GetProcAddress('glXSwapIntervalSGI');
    private ntv_SwapIntervalSGI_1 := GetProcOrNil&<function(interval: Int32): Int32>(SwapIntervalSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapIntervalSGI(interval: Int32): Int32 :=
      ntv_SwapIntervalSGI_1(interval);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxVideoSyncSGI = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_SGI_video_sync';
    
    private GetVideoSyncSGI_adr := GetProcAddress('glXGetVideoSyncSGI');
    private ntv_GetVideoSyncSGI_1 := GetProcOrNil&<function(var count: UInt32): Int32>(GetVideoSyncSGI_adr);
    private ntv_GetVideoSyncSGI_2 := GetProcOrNil&<function(count: IntPtr): Int32>(GetVideoSyncSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoSyncSGI(var count: UInt32): Int32 :=
      ntv_GetVideoSyncSGI_1(count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoSyncSGI(count: IntPtr): Int32 :=
      ntv_GetVideoSyncSGI_2(count);
    
    private WaitVideoSyncSGI_adr := GetProcAddress('glXWaitVideoSyncSGI');
    private ntv_WaitVideoSyncSGI_1 := GetProcOrNil&<function(divisor: Int32; remainder: Int32; var count: UInt32): Int32>(WaitVideoSyncSGI_adr);
    private ntv_WaitVideoSyncSGI_2 := GetProcOrNil&<function(divisor: Int32; remainder: Int32; count: IntPtr): Int32>(WaitVideoSyncSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitVideoSyncSGI(divisor: Int32; remainder: Int32; count: array of UInt32): Int32;
    type PUInt32 = ^UInt32;
    begin
      Result := if (count<>nil) and (count.Length<>0) then
        ntv_WaitVideoSyncSGI_1(divisor, remainder, count[0]) else
        ntv_WaitVideoSyncSGI_1(divisor, remainder, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitVideoSyncSGI(divisor: Int32; remainder: Int32; var count: UInt32): Int32 :=
      ntv_WaitVideoSyncSGI_1(divisor, remainder, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitVideoSyncSGI(divisor: Int32; remainder: Int32; count: IntPtr): Int32 :=
      ntv_WaitVideoSyncSGI_2(divisor, remainder, count);
    
  end;
  
  ///
  glxBlendedOverlaySGIS = static class
    public const _ExtStr = 'GLX_SGIS_blended_overlay';
  end;
  
  ///
  glxMultisampleSGIS = static class
    public const _ExtStr = 'GLX_SGIS_multisample';
  end;
  
  ///
  glxSharedMultisampleSGIS = static class
    public const _ExtStr = 'GLX_SGIS_shared_multisample';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxDmbufferSGIX = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_SGIX_dmbuffer';
    
    private AssociateDMPbufferSGIX_adr := GetProcAddress('glXAssociateDMPbufferSGIX');
    private ntv_AssociateDMPbufferSGIX_1 := GetProcOrNil&<function(dpy: x_display_ptr; pbuffer: glx_pixel_buffer; var &params: x_direct_memory_params; dmbuffer: x_direct_memory_buffer): glBool8>(AssociateDMPbufferSGIX_adr);
    private ntv_AssociateDMPbufferSGIX_2 := GetProcOrNil&<function(dpy: x_display_ptr; pbuffer: glx_pixel_buffer; &params: IntPtr; dmbuffer: x_direct_memory_buffer): glBool8>(AssociateDMPbufferSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateDMPbufferSGIX(dpy: x_display_ptr; pbuffer: glx_pixel_buffer; &params: array of x_direct_memory_params; dmbuffer: x_direct_memory_buffer): glBool8;
    type PX_direct_memory_params = ^x_direct_memory_params;
    begin
      Result := if (&params<>nil) and (&params.Length<>0) then
        ntv_AssociateDMPbufferSGIX_1(dpy, pbuffer, &params[0], dmbuffer) else
        ntv_AssociateDMPbufferSGIX_1(dpy, pbuffer, PX_direct_memory_params(nil)^, dmbuffer);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateDMPbufferSGIX(dpy: x_display_ptr; pbuffer: glx_pixel_buffer; var &params: x_direct_memory_params; dmbuffer: x_direct_memory_buffer): glBool8 :=
      ntv_AssociateDMPbufferSGIX_1(dpy, pbuffer, &params, dmbuffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateDMPbufferSGIX(dpy: x_display_ptr; pbuffer: glx_pixel_buffer; &params: IntPtr; dmbuffer: x_direct_memory_buffer): glBool8 :=
      ntv_AssociateDMPbufferSGIX_2(dpy, pbuffer, &params, dmbuffer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxFbconfigSGIX = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_SGIX_fbconfig';
    
    private GetFBConfigAttribSGIX_adr := GetProcAddress('glXGetFBConfigAttribSGIX');
    private ntv_GetFBConfigAttribSGIX_1 := GetProcOrNil&<function(dpy: x_display_ptr; config: glx_frame_buffer_config; attribute: Int32; var value: Int32): Int32>(GetFBConfigAttribSGIX_adr);
    private ntv_GetFBConfigAttribSGIX_2 := GetProcOrNil&<function(dpy: x_display_ptr; config: glx_frame_buffer_config; attribute: Int32; value: IntPtr): Int32>(GetFBConfigAttribSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFBConfigAttribSGIX(dpy: x_display_ptr; config: glx_frame_buffer_config; attribute: Int32; var value: Int32): Int32 :=
      ntv_GetFBConfigAttribSGIX_1(dpy, config, attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFBConfigAttribSGIX(dpy: x_display_ptr; config: glx_frame_buffer_config; attribute: Int32; value: IntPtr): Int32 :=
      ntv_GetFBConfigAttribSGIX_2(dpy, config, attribute, value);
    
    private ChooseFBConfigSGIX_adr := GetProcAddress('glXChooseFBConfigSGIX');
    private ntv_ChooseFBConfigSGIX_1 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; var attrib_list: Int32; var nelements: Int32): ^glx_frame_buffer_config>(ChooseFBConfigSGIX_adr);
    private ntv_ChooseFBConfigSGIX_2 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; var attrib_list: Int32; nelements: IntPtr): ^glx_frame_buffer_config>(ChooseFBConfigSGIX_adr);
    private ntv_ChooseFBConfigSGIX_3 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; attrib_list: IntPtr; var nelements: Int32): ^glx_frame_buffer_config>(ChooseFBConfigSGIX_adr);
    private ntv_ChooseFBConfigSGIX_4 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; attrib_list: IntPtr; nelements: IntPtr): ^glx_frame_buffer_config>(ChooseFBConfigSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: x_display_ptr; screen: Int32; attrib_list: array of Int32; nelements: array of Int32): ^glx_frame_buffer_config;
    type PInt32 = ^Int32;
    begin
      Result := if (nelements<>nil) and (nelements.Length<>0) then
        if (attrib_list<>nil) and (attrib_list.Length<>0) then
          ntv_ChooseFBConfigSGIX_1(dpy, screen, attrib_list[0], nelements[0]) else
          ntv_ChooseFBConfigSGIX_1(dpy, screen, PInt32(nil)^, nelements[0]) else
        if (attrib_list<>nil) and (attrib_list.Length<>0) then
          ntv_ChooseFBConfigSGIX_1(dpy, screen, attrib_list[0], PInt32(nil)^) else
          ntv_ChooseFBConfigSGIX_1(dpy, screen, PInt32(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: x_display_ptr; screen: Int32; var attrib_list: Int32; var nelements: Int32): ^glx_frame_buffer_config :=
      ntv_ChooseFBConfigSGIX_1(dpy, screen, attrib_list, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: x_display_ptr; screen: Int32; var attrib_list: Int32; nelements: IntPtr): ^glx_frame_buffer_config :=
      ntv_ChooseFBConfigSGIX_2(dpy, screen, attrib_list, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: x_display_ptr; screen: Int32; attrib_list: IntPtr; var nelements: Int32): ^glx_frame_buffer_config :=
      ntv_ChooseFBConfigSGIX_3(dpy, screen, attrib_list, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: x_display_ptr; screen: Int32; attrib_list: IntPtr; nelements: IntPtr): ^glx_frame_buffer_config :=
      ntv_ChooseFBConfigSGIX_4(dpy, screen, attrib_list, nelements);
    
    private CreateGLXPixmapWithConfigSGIX_adr := GetProcAddress('glXCreateGLXPixmapWithConfigSGIX');
    private ntv_CreateGLXPixmapWithConfigSGIX_1 := GetProcOrNil&<function(dpy: x_display_ptr; config: glx_frame_buffer_config; pixmap: x_pixel_map): glx_pixel_map>(CreateGLXPixmapWithConfigSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPixmapWithConfigSGIX(dpy: x_display_ptr; config: glx_frame_buffer_config; pixmap: x_pixel_map): glx_pixel_map :=
      ntv_CreateGLXPixmapWithConfigSGIX_1(dpy, config, pixmap);
    
    private CreateContextWithConfigSGIX_adr := GetProcAddress('glXCreateContextWithConfigSGIX');
    private ntv_CreateContextWithConfigSGIX_1 := GetProcOrNil&<function(dpy: x_display_ptr; config: glx_frame_buffer_config; render_type: Int32; share_list: glx_context; direct: glBool8): glx_context>(CreateContextWithConfigSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextWithConfigSGIX(dpy: x_display_ptr; config: glx_frame_buffer_config; render_type: Int32; share_list: glx_context; direct: glBool8): glx_context :=
      ntv_CreateContextWithConfigSGIX_1(dpy, config, render_type, share_list, direct);
    
    private GetVisualFromFBConfigSGIX_adr := GetProcAddress('glXGetVisualFromFBConfigSGIX');
    private ntv_GetVisualFromFBConfigSGIX_1 := GetProcOrNil&<function(dpy: x_display_ptr; config: glx_frame_buffer_config): x_visual_info_ptr>(GetVisualFromFBConfigSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVisualFromFBConfigSGIX(dpy: x_display_ptr; config: glx_frame_buffer_config): x_visual_info_ptr :=
      ntv_GetVisualFromFBConfigSGIX_1(dpy, config);
    
    private GetFBConfigFromVisualSGIX_adr := GetProcAddress('glXGetFBConfigFromVisualSGIX');
    private ntv_GetFBConfigFromVisualSGIX_1 := GetProcOrNil&<function(dpy: x_display_ptr; vis: x_visual_info_ptr): glx_frame_buffer_config>(GetFBConfigFromVisualSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFBConfigFromVisualSGIX(dpy: x_display_ptr; vis: x_visual_info_ptr): glx_frame_buffer_config :=
      ntv_GetFBConfigFromVisualSGIX_1(dpy, vis);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxHyperpipeSGIX = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_SGIX_hyperpipe';
    
    private QueryHyperpipeNetworkSGIX_adr := GetProcAddress('glXQueryHyperpipeNetworkSGIX');
    private ntv_QueryHyperpipeNetworkSGIX_1 := GetProcOrNil&<function(dpy: x_display_ptr; var npipes: Int32): IntPtr>(QueryHyperpipeNetworkSGIX_adr);
    private ntv_QueryHyperpipeNetworkSGIX_2 := GetProcOrNil&<function(dpy: x_display_ptr; npipes: IntPtr): IntPtr>(QueryHyperpipeNetworkSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeNetworkSGIX(dpy: x_display_ptr; var npipes: Int32): IntPtr :=
      ntv_QueryHyperpipeNetworkSGIX_1(dpy, npipes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeNetworkSGIX(dpy: x_display_ptr; npipes: IntPtr): IntPtr :=
      ntv_QueryHyperpipeNetworkSGIX_2(dpy, npipes);
    
    private HyperpipeConfigSGIX_adr := GetProcAddress('glXHyperpipeConfigSGIX');
    private ntv_HyperpipeConfigSGIX_1 := GetProcOrNil&<function(dpy: x_display_ptr; networkId: Int32; npipes: Int32; cfg: IntPtr; var hpId: Int32): Int32>(HyperpipeConfigSGIX_adr);
    private ntv_HyperpipeConfigSGIX_2 := GetProcOrNil&<function(dpy: x_display_ptr; networkId: Int32; npipes: Int32; cfg: IntPtr; hpId: IntPtr): Int32>(HyperpipeConfigSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: x_display_ptr; networkId: Int32; npipes: Int32; cfg: IntPtr; var hpId: Int32): Int32 :=
      ntv_HyperpipeConfigSGIX_1(dpy, networkId, npipes, cfg, hpId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: x_display_ptr; networkId: Int32; npipes: Int32; cfg: IntPtr; hpId: IntPtr): Int32 :=
      ntv_HyperpipeConfigSGIX_2(dpy, networkId, npipes, cfg, hpId);
    
    private QueryHyperpipeConfigSGIX_adr := GetProcAddress('glXQueryHyperpipeConfigSGIX');
    private ntv_QueryHyperpipeConfigSGIX_1 := GetProcOrNil&<function(dpy: x_display_ptr; hpId: Int32; var npipes: Int32): IntPtr>(QueryHyperpipeConfigSGIX_adr);
    private ntv_QueryHyperpipeConfigSGIX_2 := GetProcOrNil&<function(dpy: x_display_ptr; hpId: Int32; npipes: IntPtr): IntPtr>(QueryHyperpipeConfigSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeConfigSGIX(dpy: x_display_ptr; hpId: Int32; var npipes: Int32): IntPtr :=
      ntv_QueryHyperpipeConfigSGIX_1(dpy, hpId, npipes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeConfigSGIX(dpy: x_display_ptr; hpId: Int32; npipes: IntPtr): IntPtr :=
      ntv_QueryHyperpipeConfigSGIX_2(dpy, hpId, npipes);
    
    private DestroyHyperpipeConfigSGIX_adr := GetProcAddress('glXDestroyHyperpipeConfigSGIX');
    private ntv_DestroyHyperpipeConfigSGIX_1 := GetProcOrNil&<function(dpy: x_display_ptr; hpId: Int32): Int32>(DestroyHyperpipeConfigSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DestroyHyperpipeConfigSGIX(dpy: x_display_ptr; hpId: Int32): Int32 :=
      ntv_DestroyHyperpipeConfigSGIX_1(dpy, hpId);
    
    private BindHyperpipeSGIX_adr := GetProcAddress('glXBindHyperpipeSGIX');
    private ntv_BindHyperpipeSGIX_1 := GetProcOrNil&<function(dpy: x_display_ptr; hpId: Int32): Int32>(BindHyperpipeSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindHyperpipeSGIX(dpy: x_display_ptr; hpId: Int32): Int32 :=
      ntv_BindHyperpipeSGIX_1(dpy, hpId);
    
    private QueryHyperpipeBestAttribSGIX_adr := GetProcAddress('glXQueryHyperpipeBestAttribSGIX');
    private ntv_QueryHyperpipeBestAttribSGIX_1 := GetProcOrNil&<function(dpy: x_display_ptr; timeSlice: Int32; attrib: Int32; size: Int32; attribList: IntPtr; returnAttribList: IntPtr): Int32>(QueryHyperpipeBestAttribSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeBestAttribSGIX(dpy: x_display_ptr; timeSlice: Int32; attrib: Int32; size: Int32; attribList: IntPtr; returnAttribList: IntPtr): Int32 :=
      ntv_QueryHyperpipeBestAttribSGIX_1(dpy, timeSlice, attrib, size, attribList, returnAttribList);
    
    private HyperpipeAttribSGIX_adr := GetProcAddress('glXHyperpipeAttribSGIX');
    private ntv_HyperpipeAttribSGIX_1 := GetProcOrNil&<function(dpy: x_display_ptr; timeSlice: Int32; attrib: Int32; size: Int32; attribList: IntPtr): Int32>(HyperpipeAttribSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeAttribSGIX(dpy: x_display_ptr; timeSlice: Int32; attrib: Int32; size: Int32; attribList: IntPtr): Int32 :=
      ntv_HyperpipeAttribSGIX_1(dpy, timeSlice, attrib, size, attribList);
    
    private QueryHyperpipeAttribSGIX_adr := GetProcAddress('glXQueryHyperpipeAttribSGIX');
    private ntv_QueryHyperpipeAttribSGIX_1 := GetProcOrNil&<function(dpy: x_display_ptr; timeSlice: Int32; attrib: Int32; size: Int32; returnAttribList: IntPtr): Int32>(QueryHyperpipeAttribSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeAttribSGIX(dpy: x_display_ptr; timeSlice: Int32; attrib: Int32; size: Int32; returnAttribList: IntPtr): Int32 :=
      ntv_QueryHyperpipeAttribSGIX_1(dpy, timeSlice, attrib, size, returnAttribList);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxPbufferSGIX = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_SGIX_pbuffer';
    
    private CreateGLXPbufferSGIX_adr := GetProcAddress('glXCreateGLXPbufferSGIX');
    private ntv_CreateGLXPbufferSGIX_1 := GetProcOrNil&<function(dpy: x_display_ptr; config: glx_frame_buffer_config; width: UInt32; height: UInt32; var attrib_list: Int32): glx_pixel_buffer>(CreateGLXPbufferSGIX_adr);
    private ntv_CreateGLXPbufferSGIX_2 := GetProcOrNil&<function(dpy: x_display_ptr; config: glx_frame_buffer_config; width: UInt32; height: UInt32; attrib_list: IntPtr): glx_pixel_buffer>(CreateGLXPbufferSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPbufferSGIX(dpy: x_display_ptr; config: glx_frame_buffer_config; width: UInt32; height: UInt32; attrib_list: array of Int32): glx_pixel_buffer;
    type PInt32 = ^Int32;
    begin
      Result := if (attrib_list<>nil) and (attrib_list.Length<>0) then
        ntv_CreateGLXPbufferSGIX_1(dpy, config, width, height, attrib_list[0]) else
        ntv_CreateGLXPbufferSGIX_1(dpy, config, width, height, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPbufferSGIX(dpy: x_display_ptr; config: glx_frame_buffer_config; width: UInt32; height: UInt32; var attrib_list: Int32): glx_pixel_buffer :=
      ntv_CreateGLXPbufferSGIX_1(dpy, config, width, height, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPbufferSGIX(dpy: x_display_ptr; config: glx_frame_buffer_config; width: UInt32; height: UInt32; attrib_list: IntPtr): glx_pixel_buffer :=
      ntv_CreateGLXPbufferSGIX_2(dpy, config, width, height, attrib_list);
    
    private DestroyGLXPbufferSGIX_adr := GetProcAddress('glXDestroyGLXPbufferSGIX');
    private ntv_DestroyGLXPbufferSGIX_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; pbuf: glx_pixel_buffer)>(DestroyGLXPbufferSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DestroyGLXPbufferSGIX(dpy: x_display_ptr; pbuf: glx_pixel_buffer) :=
      ntv_DestroyGLXPbufferSGIX_1(dpy, pbuf);
    
    private QueryGLXPbufferSGIX_adr := GetProcAddress('glXQueryGLXPbufferSGIX');
    private ntv_QueryGLXPbufferSGIX_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; pbuf: glx_pixel_buffer; attribute: Int32; var value: UInt32)>(QueryGLXPbufferSGIX_adr);
    private ntv_QueryGLXPbufferSGIX_2 := GetProcOrNil&<procedure(dpy: x_display_ptr; pbuf: glx_pixel_buffer; attribute: Int32; value: IntPtr)>(QueryGLXPbufferSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryGLXPbufferSGIX(dpy: x_display_ptr; pbuf: glx_pixel_buffer; attribute: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_QueryGLXPbufferSGIX_1(dpy, pbuf, attribute, value[0]) else
        ntv_QueryGLXPbufferSGIX_1(dpy, pbuf, attribute, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryGLXPbufferSGIX(dpy: x_display_ptr; pbuf: glx_pixel_buffer; attribute: Int32; var value: UInt32) :=
      ntv_QueryGLXPbufferSGIX_1(dpy, pbuf, attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryGLXPbufferSGIX(dpy: x_display_ptr; pbuf: glx_pixel_buffer; attribute: Int32; value: IntPtr) :=
      ntv_QueryGLXPbufferSGIX_2(dpy, pbuf, attribute, value);
    
    private SelectEventSGIX_adr := GetProcAddress('glXSelectEventSGIX');
    private ntv_SelectEventSGIX_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; drawable: glx_drawable; mask: UInt32)>(SelectEventSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectEventSGIX(dpy: x_display_ptr; drawable: glx_drawable; mask: UInt32) :=
      ntv_SelectEventSGIX_1(dpy, drawable, mask);
    
    private GetSelectedEventSGIX_adr := GetProcAddress('glXGetSelectedEventSGIX');
    private ntv_GetSelectedEventSGIX_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; drawable: glx_drawable; var mask: UInt32)>(GetSelectedEventSGIX_adr);
    private ntv_GetSelectedEventSGIX_2 := GetProcOrNil&<procedure(dpy: x_display_ptr; drawable: glx_drawable; mask: IntPtr)>(GetSelectedEventSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSelectedEventSGIX(dpy: x_display_ptr; drawable: glx_drawable; var mask: UInt32) :=
      ntv_GetSelectedEventSGIX_1(dpy, drawable, mask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSelectedEventSGIX(dpy: x_display_ptr; drawable: glx_drawable; mask: IntPtr) :=
      ntv_GetSelectedEventSGIX_2(dpy, drawable, mask);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxSwapBarrierSGIX = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_SGIX_swap_barrier';
    
    private BindSwapBarrierSGIX_adr := GetProcAddress('glXBindSwapBarrierSGIX');
    private ntv_BindSwapBarrierSGIX_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; drawable: glx_drawable; barrier: Int32)>(BindSwapBarrierSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSwapBarrierSGIX(dpy: x_display_ptr; drawable: glx_drawable; barrier: Int32) :=
      ntv_BindSwapBarrierSGIX_1(dpy, drawable, barrier);
    
    private QueryMaxSwapBarriersSGIX_adr := GetProcAddress('glXQueryMaxSwapBarriersSGIX');
    private ntv_QueryMaxSwapBarriersSGIX_1 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; var max: Int32): glBool8>(QueryMaxSwapBarriersSGIX_adr);
    private ntv_QueryMaxSwapBarriersSGIX_2 := GetProcOrNil&<function(dpy: x_display_ptr; screen: Int32; max: IntPtr): glBool8>(QueryMaxSwapBarriersSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapBarriersSGIX(dpy: x_display_ptr; screen: Int32; max: array of Int32): glBool8;
    type PInt32 = ^Int32;
    begin
      Result := if (max<>nil) and (max.Length<>0) then
        ntv_QueryMaxSwapBarriersSGIX_1(dpy, screen, max[0]) else
        ntv_QueryMaxSwapBarriersSGIX_1(dpy, screen, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapBarriersSGIX(dpy: x_display_ptr; screen: Int32; var max: Int32): glBool8 :=
      ntv_QueryMaxSwapBarriersSGIX_1(dpy, screen, max);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapBarriersSGIX(dpy: x_display_ptr; screen: Int32; max: IntPtr): glBool8 :=
      ntv_QueryMaxSwapBarriersSGIX_2(dpy, screen, max);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxSwapGroupSGIX = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_SGIX_swap_group';
    
    private JoinSwapGroupSGIX_adr := GetProcAddress('glXJoinSwapGroupSGIX');
    private ntv_JoinSwapGroupSGIX_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; drawable: glx_drawable; member: glx_drawable)>(JoinSwapGroupSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure JoinSwapGroupSGIX(dpy: x_display_ptr; drawable: glx_drawable; member: glx_drawable) :=
      ntv_JoinSwapGroupSGIX_1(dpy, drawable, member);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxVideoResizeSGIX = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_SGIX_video_resize';
    
    private BindChannelToWindowSGIX_adr := GetProcAddress('glXBindChannelToWindowSGIX');
    private ntv_BindChannelToWindowSGIX_1 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; window: x_window): Int32>(BindChannelToWindowSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindChannelToWindowSGIX(display: x_display_ptr; screen: Int32; channel: Int32; window: x_window): Int32 :=
      ntv_BindChannelToWindowSGIX_1(display, screen, channel, window);
    
    private ChannelRectSGIX_adr := GetProcAddress('glXChannelRectSGIX');
    private ntv_ChannelRectSGIX_1 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; x: Int32; y: Int32; w: Int32; h: Int32): Int32>(ChannelRectSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; x: Int32; y: Int32; w: Int32; h: Int32): Int32 :=
      ntv_ChannelRectSGIX_1(display, screen, channel, x, y, w, h);
    
    private QueryChannelRectSGIX_adr := GetProcAddress('glXQueryChannelRectSGIX');
    private ntv_QueryChannelRectSGIX_1 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; var dw: Int32; var dh: Int32): Int32>(QueryChannelRectSGIX_adr);
    private ntv_QueryChannelRectSGIX_2 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; var dw: Int32; dh: IntPtr): Int32>(QueryChannelRectSGIX_adr);
    private ntv_QueryChannelRectSGIX_3 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: IntPtr; var dh: Int32): Int32>(QueryChannelRectSGIX_adr);
    private ntv_QueryChannelRectSGIX_4 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: IntPtr; dh: IntPtr): Int32>(QueryChannelRectSGIX_adr);
    private ntv_QueryChannelRectSGIX_5 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; var dx: Int32; dy: IntPtr; var dw: Int32; var dh: Int32): Int32>(QueryChannelRectSGIX_adr);
    private ntv_QueryChannelRectSGIX_6 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; var dx: Int32; dy: IntPtr; var dw: Int32; dh: IntPtr): Int32>(QueryChannelRectSGIX_adr);
    private ntv_QueryChannelRectSGIX_7 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; var dx: Int32; dy: IntPtr; dw: IntPtr; var dh: Int32): Int32>(QueryChannelRectSGIX_adr);
    private ntv_QueryChannelRectSGIX_8 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; var dx: Int32; dy: IntPtr; dw: IntPtr; dh: IntPtr): Int32>(QueryChannelRectSGIX_adr);
    private ntv_QueryChannelRectSGIX_9 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; dx: IntPtr; var dy: Int32; var dw: Int32; var dh: Int32): Int32>(QueryChannelRectSGIX_adr);
    private ntv_QueryChannelRectSGIX_10 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; dx: IntPtr; var dy: Int32; var dw: Int32; dh: IntPtr): Int32>(QueryChannelRectSGIX_adr);
    private ntv_QueryChannelRectSGIX_11 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; dx: IntPtr; var dy: Int32; dw: IntPtr; var dh: Int32): Int32>(QueryChannelRectSGIX_adr);
    private ntv_QueryChannelRectSGIX_12 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; dx: IntPtr; var dy: Int32; dw: IntPtr; dh: IntPtr): Int32>(QueryChannelRectSGIX_adr);
    private ntv_QueryChannelRectSGIX_13 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; dx: IntPtr; dy: IntPtr; var dw: Int32; var dh: Int32): Int32>(QueryChannelRectSGIX_adr);
    private ntv_QueryChannelRectSGIX_14 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; dx: IntPtr; dy: IntPtr; var dw: Int32; dh: IntPtr): Int32>(QueryChannelRectSGIX_adr);
    private ntv_QueryChannelRectSGIX_15 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; dx: IntPtr; dy: IntPtr; dw: IntPtr; var dh: Int32): Int32>(QueryChannelRectSGIX_adr);
    private ntv_QueryChannelRectSGIX_16 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; dx: IntPtr; dy: IntPtr; dw: IntPtr; dh: IntPtr): Int32>(QueryChannelRectSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; dw: array of Int32; dh: array of Int32): Int32;
    type PInt32 = ^Int32;
    begin
      Result := if (dx<>nil) and (dx.Length<>0) then
        if (dh<>nil) and (dh.Length<>0) then
          if (dw<>nil) and (dw.Length<>0) then
            if (dy<>nil) and (dy.Length<>0) then
              ntv_QueryChannelRectSGIX_1(display, screen, channel, dx[0], dy[0], dw[0], dh[0]) else
              ntv_QueryChannelRectSGIX_1(display, screen, channel, dx[0], PInt32(nil)^, dw[0], dh[0]) else
            if (dy<>nil) and (dy.Length<>0) then
              ntv_QueryChannelRectSGIX_1(display, screen, channel, dx[0], dy[0], PInt32(nil)^, dh[0]) else
              ntv_QueryChannelRectSGIX_1(display, screen, channel, dx[0], PInt32(nil)^, PInt32(nil)^, dh[0]) else
          if (dw<>nil) and (dw.Length<>0) then
            if (dy<>nil) and (dy.Length<>0) then
              ntv_QueryChannelRectSGIX_1(display, screen, channel, dx[0], dy[0], dw[0], PInt32(nil)^) else
              ntv_QueryChannelRectSGIX_1(display, screen, channel, dx[0], PInt32(nil)^, dw[0], PInt32(nil)^) else
            if (dy<>nil) and (dy.Length<>0) then
              ntv_QueryChannelRectSGIX_1(display, screen, channel, dx[0], dy[0], PInt32(nil)^, PInt32(nil)^) else
              ntv_QueryChannelRectSGIX_1(display, screen, channel, dx[0], PInt32(nil)^, PInt32(nil)^, PInt32(nil)^) else
        if (dh<>nil) and (dh.Length<>0) then
          if (dw<>nil) and (dw.Length<>0) then
            if (dy<>nil) and (dy.Length<>0) then
              ntv_QueryChannelRectSGIX_1(display, screen, channel, PInt32(nil)^, dy[0], dw[0], dh[0]) else
              ntv_QueryChannelRectSGIX_1(display, screen, channel, PInt32(nil)^, PInt32(nil)^, dw[0], dh[0]) else
            if (dy<>nil) and (dy.Length<>0) then
              ntv_QueryChannelRectSGIX_1(display, screen, channel, PInt32(nil)^, dy[0], PInt32(nil)^, dh[0]) else
              ntv_QueryChannelRectSGIX_1(display, screen, channel, PInt32(nil)^, PInt32(nil)^, PInt32(nil)^, dh[0]) else
          if (dw<>nil) and (dw.Length<>0) then
            if (dy<>nil) and (dy.Length<>0) then
              ntv_QueryChannelRectSGIX_1(display, screen, channel, PInt32(nil)^, dy[0], dw[0], PInt32(nil)^) else
              ntv_QueryChannelRectSGIX_1(display, screen, channel, PInt32(nil)^, PInt32(nil)^, dw[0], PInt32(nil)^) else
            if (dy<>nil) and (dy.Length<>0) then
              ntv_QueryChannelRectSGIX_1(display, screen, channel, PInt32(nil)^, dy[0], PInt32(nil)^, PInt32(nil)^) else
              ntv_QueryChannelRectSGIX_1(display, screen, channel, PInt32(nil)^, PInt32(nil)^, PInt32(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; var dw: Int32; var dh: Int32): Int32 :=
      ntv_QueryChannelRectSGIX_1(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; var dw: Int32; dh: IntPtr): Int32 :=
      ntv_QueryChannelRectSGIX_2(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: IntPtr; var dh: Int32): Int32 :=
      ntv_QueryChannelRectSGIX_3(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: IntPtr; dh: IntPtr): Int32 :=
      ntv_QueryChannelRectSGIX_4(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; var dx: Int32; dy: IntPtr; var dw: Int32; var dh: Int32): Int32 :=
      ntv_QueryChannelRectSGIX_5(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; var dx: Int32; dy: IntPtr; var dw: Int32; dh: IntPtr): Int32 :=
      ntv_QueryChannelRectSGIX_6(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; var dx: Int32; dy: IntPtr; dw: IntPtr; var dh: Int32): Int32 :=
      ntv_QueryChannelRectSGIX_7(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; var dx: Int32; dy: IntPtr; dw: IntPtr; dh: IntPtr): Int32 :=
      ntv_QueryChannelRectSGIX_8(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; dx: IntPtr; var dy: Int32; var dw: Int32; var dh: Int32): Int32 :=
      ntv_QueryChannelRectSGIX_9(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; dx: IntPtr; var dy: Int32; var dw: Int32; dh: IntPtr): Int32 :=
      ntv_QueryChannelRectSGIX_10(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; dx: IntPtr; var dy: Int32; dw: IntPtr; var dh: Int32): Int32 :=
      ntv_QueryChannelRectSGIX_11(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; dx: IntPtr; var dy: Int32; dw: IntPtr; dh: IntPtr): Int32 :=
      ntv_QueryChannelRectSGIX_12(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; dx: IntPtr; dy: IntPtr; var dw: Int32; var dh: Int32): Int32 :=
      ntv_QueryChannelRectSGIX_13(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; dx: IntPtr; dy: IntPtr; var dw: Int32; dh: IntPtr): Int32 :=
      ntv_QueryChannelRectSGIX_14(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; dx: IntPtr; dy: IntPtr; dw: IntPtr; var dh: Int32): Int32 :=
      ntv_QueryChannelRectSGIX_15(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_display_ptr; screen: Int32; channel: Int32; dx: IntPtr; dy: IntPtr; dw: IntPtr; dh: IntPtr): Int32 :=
      ntv_QueryChannelRectSGIX_16(display, screen, channel, dx, dy, dw, dh);
    
    private QueryChannelDeltasSGIX_adr := GetProcAddress('glXQueryChannelDeltasSGIX');
    private ntv_QueryChannelDeltasSGIX_1 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; var x: Int32; var y: Int32; var w: Int32; var h: Int32): Int32>(QueryChannelDeltasSGIX_adr);
    private ntv_QueryChannelDeltasSGIX_2 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; var x: Int32; var y: Int32; var w: Int32; h: IntPtr): Int32>(QueryChannelDeltasSGIX_adr);
    private ntv_QueryChannelDeltasSGIX_3 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: IntPtr; var h: Int32): Int32>(QueryChannelDeltasSGIX_adr);
    private ntv_QueryChannelDeltasSGIX_4 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: IntPtr; h: IntPtr): Int32>(QueryChannelDeltasSGIX_adr);
    private ntv_QueryChannelDeltasSGIX_5 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; var x: Int32; y: IntPtr; var w: Int32; var h: Int32): Int32>(QueryChannelDeltasSGIX_adr);
    private ntv_QueryChannelDeltasSGIX_6 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; var x: Int32; y: IntPtr; var w: Int32; h: IntPtr): Int32>(QueryChannelDeltasSGIX_adr);
    private ntv_QueryChannelDeltasSGIX_7 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; var x: Int32; y: IntPtr; w: IntPtr; var h: Int32): Int32>(QueryChannelDeltasSGIX_adr);
    private ntv_QueryChannelDeltasSGIX_8 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; var x: Int32; y: IntPtr; w: IntPtr; h: IntPtr): Int32>(QueryChannelDeltasSGIX_adr);
    private ntv_QueryChannelDeltasSGIX_9 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; x: IntPtr; var y: Int32; var w: Int32; var h: Int32): Int32>(QueryChannelDeltasSGIX_adr);
    private ntv_QueryChannelDeltasSGIX_10 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; x: IntPtr; var y: Int32; var w: Int32; h: IntPtr): Int32>(QueryChannelDeltasSGIX_adr);
    private ntv_QueryChannelDeltasSGIX_11 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; x: IntPtr; var y: Int32; w: IntPtr; var h: Int32): Int32>(QueryChannelDeltasSGIX_adr);
    private ntv_QueryChannelDeltasSGIX_12 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; x: IntPtr; var y: Int32; w: IntPtr; h: IntPtr): Int32>(QueryChannelDeltasSGIX_adr);
    private ntv_QueryChannelDeltasSGIX_13 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; x: IntPtr; y: IntPtr; var w: Int32; var h: Int32): Int32>(QueryChannelDeltasSGIX_adr);
    private ntv_QueryChannelDeltasSGIX_14 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; x: IntPtr; y: IntPtr; var w: Int32; h: IntPtr): Int32>(QueryChannelDeltasSGIX_adr);
    private ntv_QueryChannelDeltasSGIX_15 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; x: IntPtr; y: IntPtr; w: IntPtr; var h: Int32): Int32>(QueryChannelDeltasSGIX_adr);
    private ntv_QueryChannelDeltasSGIX_16 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; x: IntPtr; y: IntPtr; w: IntPtr; h: IntPtr): Int32>(QueryChannelDeltasSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_display_ptr; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; w: array of Int32; h: array of Int32): Int32;
    type PInt32 = ^Int32;
    begin
      Result := if (x<>nil) and (x.Length<>0) then
        if (h<>nil) and (h.Length<>0) then
          if (w<>nil) and (w.Length<>0) then
            if (y<>nil) and (y.Length<>0) then
              ntv_QueryChannelDeltasSGIX_1(display, screen, channel, x[0], y[0], w[0], h[0]) else
              ntv_QueryChannelDeltasSGIX_1(display, screen, channel, x[0], PInt32(nil)^, w[0], h[0]) else
            if (y<>nil) and (y.Length<>0) then
              ntv_QueryChannelDeltasSGIX_1(display, screen, channel, x[0], y[0], PInt32(nil)^, h[0]) else
              ntv_QueryChannelDeltasSGIX_1(display, screen, channel, x[0], PInt32(nil)^, PInt32(nil)^, h[0]) else
          if (w<>nil) and (w.Length<>0) then
            if (y<>nil) and (y.Length<>0) then
              ntv_QueryChannelDeltasSGIX_1(display, screen, channel, x[0], y[0], w[0], PInt32(nil)^) else
              ntv_QueryChannelDeltasSGIX_1(display, screen, channel, x[0], PInt32(nil)^, w[0], PInt32(nil)^) else
            if (y<>nil) and (y.Length<>0) then
              ntv_QueryChannelDeltasSGIX_1(display, screen, channel, x[0], y[0], PInt32(nil)^, PInt32(nil)^) else
              ntv_QueryChannelDeltasSGIX_1(display, screen, channel, x[0], PInt32(nil)^, PInt32(nil)^, PInt32(nil)^) else
        if (h<>nil) and (h.Length<>0) then
          if (w<>nil) and (w.Length<>0) then
            if (y<>nil) and (y.Length<>0) then
              ntv_QueryChannelDeltasSGIX_1(display, screen, channel, PInt32(nil)^, y[0], w[0], h[0]) else
              ntv_QueryChannelDeltasSGIX_1(display, screen, channel, PInt32(nil)^, PInt32(nil)^, w[0], h[0]) else
            if (y<>nil) and (y.Length<>0) then
              ntv_QueryChannelDeltasSGIX_1(display, screen, channel, PInt32(nil)^, y[0], PInt32(nil)^, h[0]) else
              ntv_QueryChannelDeltasSGIX_1(display, screen, channel, PInt32(nil)^, PInt32(nil)^, PInt32(nil)^, h[0]) else
          if (w<>nil) and (w.Length<>0) then
            if (y<>nil) and (y.Length<>0) then
              ntv_QueryChannelDeltasSGIX_1(display, screen, channel, PInt32(nil)^, y[0], w[0], PInt32(nil)^) else
              ntv_QueryChannelDeltasSGIX_1(display, screen, channel, PInt32(nil)^, PInt32(nil)^, w[0], PInt32(nil)^) else
            if (y<>nil) and (y.Length<>0) then
              ntv_QueryChannelDeltasSGIX_1(display, screen, channel, PInt32(nil)^, y[0], PInt32(nil)^, PInt32(nil)^) else
              ntv_QueryChannelDeltasSGIX_1(display, screen, channel, PInt32(nil)^, PInt32(nil)^, PInt32(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_display_ptr; screen: Int32; channel: Int32; var x: Int32; var y: Int32; var w: Int32; var h: Int32): Int32 :=
      ntv_QueryChannelDeltasSGIX_1(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_display_ptr; screen: Int32; channel: Int32; var x: Int32; var y: Int32; var w: Int32; h: IntPtr): Int32 :=
      ntv_QueryChannelDeltasSGIX_2(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_display_ptr; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: IntPtr; var h: Int32): Int32 :=
      ntv_QueryChannelDeltasSGIX_3(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_display_ptr; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: IntPtr; h: IntPtr): Int32 :=
      ntv_QueryChannelDeltasSGIX_4(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_display_ptr; screen: Int32; channel: Int32; var x: Int32; y: IntPtr; var w: Int32; var h: Int32): Int32 :=
      ntv_QueryChannelDeltasSGIX_5(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_display_ptr; screen: Int32; channel: Int32; var x: Int32; y: IntPtr; var w: Int32; h: IntPtr): Int32 :=
      ntv_QueryChannelDeltasSGIX_6(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_display_ptr; screen: Int32; channel: Int32; var x: Int32; y: IntPtr; w: IntPtr; var h: Int32): Int32 :=
      ntv_QueryChannelDeltasSGIX_7(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_display_ptr; screen: Int32; channel: Int32; var x: Int32; y: IntPtr; w: IntPtr; h: IntPtr): Int32 :=
      ntv_QueryChannelDeltasSGIX_8(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_display_ptr; screen: Int32; channel: Int32; x: IntPtr; var y: Int32; var w: Int32; var h: Int32): Int32 :=
      ntv_QueryChannelDeltasSGIX_9(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_display_ptr; screen: Int32; channel: Int32; x: IntPtr; var y: Int32; var w: Int32; h: IntPtr): Int32 :=
      ntv_QueryChannelDeltasSGIX_10(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_display_ptr; screen: Int32; channel: Int32; x: IntPtr; var y: Int32; w: IntPtr; var h: Int32): Int32 :=
      ntv_QueryChannelDeltasSGIX_11(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_display_ptr; screen: Int32; channel: Int32; x: IntPtr; var y: Int32; w: IntPtr; h: IntPtr): Int32 :=
      ntv_QueryChannelDeltasSGIX_12(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_display_ptr; screen: Int32; channel: Int32; x: IntPtr; y: IntPtr; var w: Int32; var h: Int32): Int32 :=
      ntv_QueryChannelDeltasSGIX_13(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_display_ptr; screen: Int32; channel: Int32; x: IntPtr; y: IntPtr; var w: Int32; h: IntPtr): Int32 :=
      ntv_QueryChannelDeltasSGIX_14(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_display_ptr; screen: Int32; channel: Int32; x: IntPtr; y: IntPtr; w: IntPtr; var h: Int32): Int32 :=
      ntv_QueryChannelDeltasSGIX_15(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_display_ptr; screen: Int32; channel: Int32; x: IntPtr; y: IntPtr; w: IntPtr; h: IntPtr): Int32 :=
      ntv_QueryChannelDeltasSGIX_16(display, screen, channel, x, y, w, h);
    
    private ChannelRectSyncSGIX_adr := GetProcAddress('glXChannelRectSyncSGIX');
    private ntv_ChannelRectSyncSGIX_1 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; channel: Int32; synctype: DummyEnum): Int32>(ChannelRectSyncSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChannelRectSyncSGIX(display: x_display_ptr; screen: Int32; channel: Int32; synctype: DummyEnum): Int32 :=
      ntv_ChannelRectSyncSGIX_1(display, screen, channel, synctype);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxVideoSourceSGIX = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_SGIX_video_source';
    
    private CreateGLXVideoSourceSGIX_adr := GetProcAddress('glXCreateGLXVideoSourceSGIX');
    private ntv_CreateGLXVideoSourceSGIX_1 := GetProcOrNil&<function(display: x_display_ptr; screen: Int32; server: glx_vl_server; path: glx_vl_path; nodeClass: Int32; drainNode: glx_vl_node): glx_video_source_SGIX>(CreateGLXVideoSourceSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXVideoSourceSGIX(display: x_display_ptr; screen: Int32; server: glx_vl_server; path: glx_vl_path; nodeClass: Int32; drainNode: glx_vl_node): glx_video_source_SGIX :=
      ntv_CreateGLXVideoSourceSGIX_1(display, screen, server, path, nodeClass, drainNode);
    
    private DestroyGLXVideoSourceSGIX_adr := GetProcAddress('glXDestroyGLXVideoSourceSGIX');
    private ntv_DestroyGLXVideoSourceSGIX_1 := GetProcOrNil&<procedure(dpy: x_display_ptr; glxvideosource: glx_video_source_SGIX)>(DestroyGLXVideoSourceSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DestroyGLXVideoSourceSGIX(dpy: x_display_ptr; glxvideosource: glx_video_source_SGIX) :=
      ntv_DestroyGLXVideoSourceSGIX_1(dpy, glxvideosource);
    
  end;
  
  ///
  glxVisualSelectGroupSGIX = static class
    public const _ExtStr = 'GLX_SGIX_visual_select_group';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glxGetTransparentIndexSUN = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'GLX_SUN_get_transparent_index';
    
    private GetTransparentIndexSUN_adr := GetProcAddress('glXGetTransparentIndexSUN');
    private ntv_GetTransparentIndexSUN_1 := GetProcOrNil&<function(dpy: x_display_ptr; overlay: x_window; underlay: x_window; var pTransparentIndex: UInt32): glBool32>(GetTransparentIndexSUN_adr);
    private ntv_GetTransparentIndexSUN_2 := GetProcOrNil&<function(dpy: x_display_ptr; overlay: x_window; underlay: x_window; pTransparentIndex: IntPtr): glBool32>(GetTransparentIndexSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTransparentIndexSUN(dpy: x_display_ptr; overlay: x_window; underlay: x_window; var pTransparentIndex: UInt32): glBool32 :=
      ntv_GetTransparentIndexSUN_1(dpy, overlay, underlay, pTransparentIndex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTransparentIndexSUN(dpy: x_display_ptr; overlay: x_window; underlay: x_window; pTransparentIndex: IntPtr): glBool32 :=
      ntv_GetTransparentIndexSUN_2(dpy, overlay, underlay, pTransparentIndex);
    
  end;
  
  ///
  wglMultisample3DFX = static class
    public const _ExtStr = 'WGL_3DFX_multisample';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglStereoControl3DL = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_3DL_stereo_control';
    
    private SetStereoEmitterState3DL_adr := GetProcAddress('wglSetStereoEmitterState3DL');
    private ntv_SetStereoEmitterState3DL_1 := GetProcOrNil&<function(hDC: gdi_device_context; uState: wglStereoEmitterState): glBool32>(SetStereoEmitterState3DL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetStereoEmitterState3DL(hDC: gdi_device_context; uState: wglStereoEmitterState): glBool32 :=
      ntv_SetStereoEmitterState3DL_1(hDC, uState);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglGpuAssociationAMD = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_AMD_gpu_association';
    
    private GetGPUIDsAMD_adr := GetProcAddress('wglGetGPUIDsAMD');
    private ntv_GetGPUIDsAMD_1 := GetProcOrNil&<function(maxCount: UInt32; var ids: UInt32): UInt32>(GetGPUIDsAMD_adr);
    private ntv_GetGPUIDsAMD_2 := GetProcOrNil&<function(maxCount: UInt32; ids: IntPtr): UInt32>(GetGPUIDsAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUIDsAMD(maxCount: UInt32; var ids: UInt32): UInt32 :=
      ntv_GetGPUIDsAMD_1(maxCount, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUIDsAMD(maxCount: UInt32; ids: IntPtr): UInt32 :=
      ntv_GetGPUIDsAMD_2(maxCount, ids);
    
    private GetGPUInfoAMD_adr := GetProcAddress('wglGetGPUInfoAMD');
    private ntv_GetGPUInfoAMD_1 := GetProcOrNil&<function(id: UInt32; &property: wglGPUProperty; dataType: glScalarType; size: UInt32; data: IntPtr): Int32>(GetGPUInfoAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUInfoAMD(id: UInt32; &property: wglGPUProperty; dataType: glScalarType; size: UInt32; data: IntPtr): Int32 :=
      ntv_GetGPUInfoAMD_1(id, &property, dataType, size, data);
    
    private GetContextGPUIDAMD_adr := GetProcAddress('wglGetContextGPUIDAMD');
    private ntv_GetContextGPUIDAMD_1 := GetProcOrNil&<function(hglrc: gdi_rendering_context): UInt32>(GetContextGPUIDAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetContextGPUIDAMD(hglrc: gdi_rendering_context): UInt32 :=
      ntv_GetContextGPUIDAMD_1(hglrc);
    
    private CreateAssociatedContextAMD_adr := GetProcAddress('wglCreateAssociatedContextAMD');
    private ntv_CreateAssociatedContextAMD_1 := GetProcOrNil&<function(id: UInt32): gdi_rendering_context>(CreateAssociatedContextAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAMD(id: UInt32): gdi_rendering_context :=
      ntv_CreateAssociatedContextAMD_1(id);
    
    private CreateAssociatedContextAttribsAMD_adr := GetProcAddress('wglCreateAssociatedContextAttribsAMD');
    private ntv_CreateAssociatedContextAttribsAMD_1 := GetProcOrNil&<function(id: UInt32; hShareContext: gdi_rendering_context; var attribList: Int32): gdi_rendering_context>(CreateAssociatedContextAttribsAMD_adr);
    private ntv_CreateAssociatedContextAttribsAMD_2 := GetProcOrNil&<function(id: UInt32; hShareContext: gdi_rendering_context; attribList: IntPtr): gdi_rendering_context>(CreateAssociatedContextAttribsAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; hShareContext: gdi_rendering_context; attribList: array of Int32): gdi_rendering_context;
    type PInt32 = ^Int32;
    begin
      Result := if (attribList<>nil) and (attribList.Length<>0) then
        ntv_CreateAssociatedContextAttribsAMD_1(id, hShareContext, attribList[0]) else
        ntv_CreateAssociatedContextAttribsAMD_1(id, hShareContext, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; hShareContext: gdi_rendering_context; var attribList: Int32): gdi_rendering_context :=
      ntv_CreateAssociatedContextAttribsAMD_1(id, hShareContext, attribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; hShareContext: gdi_rendering_context; attribList: IntPtr): gdi_rendering_context :=
      ntv_CreateAssociatedContextAttribsAMD_2(id, hShareContext, attribList);
    
    private DeleteAssociatedContextAMD_adr := GetProcAddress('wglDeleteAssociatedContextAMD');
    private ntv_DeleteAssociatedContextAMD_1 := GetProcOrNil&<function(hglrc: gdi_rendering_context): glBool32>(DeleteAssociatedContextAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DeleteAssociatedContextAMD(hglrc: gdi_rendering_context): glBool32 :=
      ntv_DeleteAssociatedContextAMD_1(hglrc);
    
    private MakeAssociatedContextCurrentAMD_adr := GetProcAddress('wglMakeAssociatedContextCurrentAMD');
    private ntv_MakeAssociatedContextCurrentAMD_1 := GetProcOrNil&<function(hglrc: gdi_rendering_context): glBool32>(MakeAssociatedContextCurrentAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeAssociatedContextCurrentAMD(hglrc: gdi_rendering_context): glBool32 :=
      ntv_MakeAssociatedContextCurrentAMD_1(hglrc);
    
    private GetCurrentAssociatedContextAMD_adr := GetProcAddress('wglGetCurrentAssociatedContextAMD');
    private ntv_GetCurrentAssociatedContextAMD_1 := GetProcOrNil&<function: gdi_rendering_context>(GetCurrentAssociatedContextAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentAssociatedContextAMD: gdi_rendering_context :=
      ntv_GetCurrentAssociatedContextAMD_1;
    
    private BlitContextFramebufferAMD_adr := GetProcAddress('wglBlitContextFramebufferAMD');
    private ntv_BlitContextFramebufferAMD_1 := GetProcOrNil&<procedure(dstCtx: gdi_rendering_context; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: glClearBufferMask; filter: DummyEnum)>(BlitContextFramebufferAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitContextFramebufferAMD(dstCtx: gdi_rendering_context; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: glClearBufferMask; filter: DummyEnum) :=
      ntv_BlitContextFramebufferAMD_1(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglBufferRegionARB = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_ARB_buffer_region';
    
    private CreateBufferRegionARB_adr := GetProcAddress('wglCreateBufferRegionARB');
    private ntv_CreateBufferRegionARB_1 := GetProcOrNil&<function(hDC: gdi_device_context; iLayerPlane: Int32; uType: wglColorBufferMask): IntPtr>(CreateBufferRegionARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateBufferRegionARB(hDC: gdi_device_context; iLayerPlane: Int32; uType: wglColorBufferMask): IntPtr :=
      ntv_CreateBufferRegionARB_1(hDC, iLayerPlane, uType);
    
    private DeleteBufferRegionARB_adr := GetProcAddress('wglDeleteBufferRegionARB');
    private ntv_DeleteBufferRegionARB_1 := GetProcOrNil&<procedure(hRegion: IntPtr)>(DeleteBufferRegionARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBufferRegionARB(hRegion: IntPtr) :=
      ntv_DeleteBufferRegionARB_1(hRegion);
    
    private SaveBufferRegionARB_adr := GetProcAddress('wglSaveBufferRegionARB');
    private ntv_SaveBufferRegionARB_1 := GetProcOrNil&<function(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32): glBool32>(SaveBufferRegionARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SaveBufferRegionARB(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32): glBool32 :=
      ntv_SaveBufferRegionARB_1(hRegion, x, y, width, height);
    
    private RestoreBufferRegionARB_adr := GetProcAddress('wglRestoreBufferRegionARB');
    private ntv_RestoreBufferRegionARB_1 := GetProcOrNil&<function(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32; xSrc: Int32; ySrc: Int32): glBool32>(RestoreBufferRegionARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RestoreBufferRegionARB(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32; xSrc: Int32; ySrc: Int32): glBool32 :=
      ntv_RestoreBufferRegionARB_1(hRegion, x, y, width, height, xSrc, ySrc);
    
  end;
  
  ///
  wglContextFlushControlARB = static class
    public const _ExtStr = 'WGL_ARB_context_flush_control';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglCreateContextARB = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_ARB_create_context';
    
    private CreateContextAttribsARB_adr := GetProcAddress('wglCreateContextAttribsARB');
    private ntv_CreateContextAttribsARB_1 := GetProcOrNil&<function(hDC: gdi_device_context; hShareContext: gdi_rendering_context; var attribList: Int32): gdi_rendering_context>(CreateContextAttribsARB_adr);
    private ntv_CreateContextAttribsARB_2 := GetProcOrNil&<function(hDC: gdi_device_context; hShareContext: gdi_rendering_context; attribList: IntPtr): gdi_rendering_context>(CreateContextAttribsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(hDC: gdi_device_context; hShareContext: gdi_rendering_context; attribList: array of Int32): gdi_rendering_context;
    type PInt32 = ^Int32;
    begin
      Result := if (attribList<>nil) and (attribList.Length<>0) then
        ntv_CreateContextAttribsARB_1(hDC, hShareContext, attribList[0]) else
        ntv_CreateContextAttribsARB_1(hDC, hShareContext, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(hDC: gdi_device_context; hShareContext: gdi_rendering_context; var attribList: Int32): gdi_rendering_context :=
      ntv_CreateContextAttribsARB_1(hDC, hShareContext, attribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(hDC: gdi_device_context; hShareContext: gdi_rendering_context; attribList: IntPtr): gdi_rendering_context :=
      ntv_CreateContextAttribsARB_2(hDC, hShareContext, attribList);
    
  end;
  
  ///
  wglCreateContextNoErrorARB = static class
    public const _ExtStr = 'WGL_ARB_create_context_no_error';
  end;
  
  ///
  wglCreateContextProfileARB = static class
    public const _ExtStr = 'WGL_ARB_create_context_profile';
  end;
  
  ///
  wglCreateContextRobustnessARB = static class
    public const _ExtStr = 'WGL_ARB_create_context_robustness';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglExtensionsStringARB = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_ARB_extensions_string';
    
    private GetExtensionsStringARB_adr := GetProcAddress('wglGetExtensionsStringARB');
    private ntv_GetExtensionsStringARB_1 := GetProcOrNil&<function(hdc: gdi_device_context): IntPtr>(GetExtensionsStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetExtensionsStringARB(hdc: gdi_device_context): string :=
      Marshal.PtrToStringAnsi(ntv_GetExtensionsStringARB_1(hdc));
    
  end;
  
  ///
  wglFramebufferSRGBARB = static class
    public const _ExtStr = 'WGL_ARB_framebuffer_sRGB';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglMakeCurrentReadARB = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_ARB_make_current_read';
    
    private MakeContextCurrentARB_adr := GetProcAddress('wglMakeContextCurrentARB');
    private ntv_MakeContextCurrentARB_1 := GetProcOrNil&<function(hDrawDC: gdi_device_context; hReadDC: gdi_device_context; hglrc: gdi_rendering_context): glBool32>(MakeContextCurrentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeContextCurrentARB(hDrawDC: gdi_device_context; hReadDC: gdi_device_context; hglrc: gdi_rendering_context): glBool32 :=
      ntv_MakeContextCurrentARB_1(hDrawDC, hReadDC, hglrc);
    
    private GetCurrentReadDCARB_adr := GetProcAddress('wglGetCurrentReadDCARB');
    private ntv_GetCurrentReadDCARB_1 := GetProcOrNil&<function: gdi_device_context>(GetCurrentReadDCARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentReadDCARB: gdi_device_context :=
      ntv_GetCurrentReadDCARB_1;
    
  end;
  
  ///
  wglMultisampleARB = static class
    public const _ExtStr = 'WGL_ARB_multisample';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglPbufferARB = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_ARB_pbuffer';
    
    private CreatePbufferARB_adr := GetProcAddress('wglCreatePbufferARB');
    private ntv_CreatePbufferARB_1 := GetProcOrNil&<function(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; var piAttribList: Int32): wgl_pixel_buffer>(CreatePbufferARB_adr);
    private ntv_CreatePbufferARB_2 := GetProcOrNil&<function(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: IntPtr): wgl_pixel_buffer>(CreatePbufferARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferARB(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: array of Int32): wgl_pixel_buffer;
    type PInt32 = ^Int32;
    begin
      Result := if (piAttribList<>nil) and (piAttribList.Length<>0) then
        ntv_CreatePbufferARB_1(hDC, iPixelFormat, iWidth, iHeight, piAttribList[0]) else
        ntv_CreatePbufferARB_1(hDC, iPixelFormat, iWidth, iHeight, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferARB(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; var piAttribList: Int32): wgl_pixel_buffer :=
      ntv_CreatePbufferARB_1(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferARB(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: IntPtr): wgl_pixel_buffer :=
      ntv_CreatePbufferARB_2(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
    
    private GetPbufferDCARB_adr := GetProcAddress('wglGetPbufferDCARB');
    private ntv_GetPbufferDCARB_1 := GetProcOrNil&<function(hPbuffer: wgl_pixel_buffer): gdi_device_context>(GetPbufferDCARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPbufferDCARB(hPbuffer: wgl_pixel_buffer): gdi_device_context :=
      ntv_GetPbufferDCARB_1(hPbuffer);
    
    private ReleasePbufferDCARB_adr := GetProcAddress('wglReleasePbufferDCARB');
    private ntv_ReleasePbufferDCARB_1 := GetProcOrNil&<function(hPbuffer: wgl_pixel_buffer; hDC: gdi_device_context): Int32>(ReleasePbufferDCARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleasePbufferDCARB(hPbuffer: wgl_pixel_buffer; hDC: gdi_device_context): Int32 :=
      ntv_ReleasePbufferDCARB_1(hPbuffer, hDC);
    
    private DestroyPbufferARB_adr := GetProcAddress('wglDestroyPbufferARB');
    private ntv_DestroyPbufferARB_1 := GetProcOrNil&<function(hPbuffer: wgl_pixel_buffer): glBool32>(DestroyPbufferARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DestroyPbufferARB(hPbuffer: wgl_pixel_buffer): glBool32 :=
      ntv_DestroyPbufferARB_1(hPbuffer);
    
    private QueryPbufferARB_adr := GetProcAddress('wglQueryPbufferARB');
    private ntv_QueryPbufferARB_1 := GetProcOrNil&<function(hPbuffer: wgl_pixel_buffer; iAttribute: wglPBufferAttribute; var piValue: Int32): glBool32>(QueryPbufferARB_adr);
    private ntv_QueryPbufferARB_2 := GetProcOrNil&<function(hPbuffer: wgl_pixel_buffer; iAttribute: wglPBufferAttribute; piValue: IntPtr): glBool32>(QueryPbufferARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferARB(hPbuffer: wgl_pixel_buffer; iAttribute: wglPBufferAttribute; piValue: array of Int32): glBool32;
    type PInt32 = ^Int32;
    begin
      Result := if (piValue<>nil) and (piValue.Length<>0) then
        ntv_QueryPbufferARB_1(hPbuffer, iAttribute, piValue[0]) else
        ntv_QueryPbufferARB_1(hPbuffer, iAttribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferARB(hPbuffer: wgl_pixel_buffer; iAttribute: wglPBufferAttribute; var piValue: Int32): glBool32 :=
      ntv_QueryPbufferARB_1(hPbuffer, iAttribute, piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferARB(hPbuffer: wgl_pixel_buffer; iAttribute: wglPBufferAttribute; piValue: IntPtr): glBool32 :=
      ntv_QueryPbufferARB_2(hPbuffer, iAttribute, piValue);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglPixelFormatARB = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_ARB_pixel_format';
    
    private GetPixelFormatAttribivARB_adr := GetProcAddress('wglGetPixelFormatAttribivARB');
    private ntv_GetPixelFormatAttribivARB_1 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: wglPixelFormatAttribute; var piValues: Int32): glBool32>(GetPixelFormatAttribivARB_adr);
    private ntv_GetPixelFormatAttribivARB_2 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: wglPixelFormatAttribute; piValues: IntPtr): glBool32>(GetPixelFormatAttribivARB_adr);
    private ntv_GetPixelFormatAttribivARB_3 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; var piValues: Int32): glBool32>(GetPixelFormatAttribivARB_adr);
    private ntv_GetPixelFormatAttribivARB_4 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; piValues: IntPtr): glBool32>(GetPixelFormatAttribivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of wglPixelFormatAttribute; var piValues: Int32): glBool32;
    type PWglPixelFormatAttribute = ^wglPixelFormatAttribute;
    begin
      Result := if (piAttributes<>nil) and (piAttributes.Length<>0) then
        ntv_GetPixelFormatAttribivARB_1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], piValues) else
        ntv_GetPixelFormatAttribivARB_1(hdc, iPixelFormat, iLayerPlane, nAttributes, PWglPixelFormatAttribute(nil)^, piValues);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of wglPixelFormatAttribute; piValues: IntPtr): glBool32;
    type PWglPixelFormatAttribute = ^wglPixelFormatAttribute;
    begin
      Result := if (piAttributes<>nil) and (piAttributes.Length<>0) then
        ntv_GetPixelFormatAttribivARB_2(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], piValues) else
        ntv_GetPixelFormatAttribivARB_2(hdc, iPixelFormat, iLayerPlane, nAttributes, PWglPixelFormatAttribute(nil)^, piValues);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: wglPixelFormatAttribute; var piValues: Int32): glBool32 :=
      ntv_GetPixelFormatAttribivARB_1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: wglPixelFormatAttribute; piValues: IntPtr): glBool32 :=
      ntv_GetPixelFormatAttribivARB_2(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; var piValues: Int32): glBool32 :=
      ntv_GetPixelFormatAttribivARB_3(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; piValues: IntPtr): glBool32 :=
      ntv_GetPixelFormatAttribivARB_4(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    
    private GetPixelFormatAttribfvARB_adr := GetProcAddress('wglGetPixelFormatAttribfvARB');
    private ntv_GetPixelFormatAttribfvARB_1 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: wglPixelFormatAttribute; var pfValues: single): glBool32>(GetPixelFormatAttribfvARB_adr);
    private ntv_GetPixelFormatAttribfvARB_2 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: wglPixelFormatAttribute; pfValues: IntPtr): glBool32>(GetPixelFormatAttribfvARB_adr);
    private ntv_GetPixelFormatAttribfvARB_3 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; var pfValues: single): glBool32>(GetPixelFormatAttribfvARB_adr);
    private ntv_GetPixelFormatAttribfvARB_4 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; pfValues: IntPtr): glBool32>(GetPixelFormatAttribfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of wglPixelFormatAttribute; var pfValues: single): glBool32;
    type PWglPixelFormatAttribute = ^wglPixelFormatAttribute;
    begin
      Result := if (piAttributes<>nil) and (piAttributes.Length<>0) then
        ntv_GetPixelFormatAttribfvARB_1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], pfValues) else
        ntv_GetPixelFormatAttribfvARB_1(hdc, iPixelFormat, iLayerPlane, nAttributes, PWglPixelFormatAttribute(nil)^, pfValues);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of wglPixelFormatAttribute; pfValues: IntPtr): glBool32;
    type PWglPixelFormatAttribute = ^wglPixelFormatAttribute;
    begin
      Result := if (piAttributes<>nil) and (piAttributes.Length<>0) then
        ntv_GetPixelFormatAttribfvARB_2(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], pfValues) else
        ntv_GetPixelFormatAttribfvARB_2(hdc, iPixelFormat, iLayerPlane, nAttributes, PWglPixelFormatAttribute(nil)^, pfValues);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: wglPixelFormatAttribute; var pfValues: single): glBool32 :=
      ntv_GetPixelFormatAttribfvARB_1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: wglPixelFormatAttribute; pfValues: IntPtr): glBool32 :=
      ntv_GetPixelFormatAttribfvARB_2(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; var pfValues: single): glBool32 :=
      ntv_GetPixelFormatAttribfvARB_3(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; pfValues: IntPtr): glBool32 :=
      ntv_GetPixelFormatAttribfvARB_4(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    
    private ChoosePixelFormatARB_adr := GetProcAddress('wglChoosePixelFormatARB');
    private ntv_ChoosePixelFormatARB_1 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): glBool32>(ChoosePixelFormatARB_adr);
    private ntv_ChoosePixelFormatARB_2 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): glBool32>(ChoosePixelFormatARB_adr);
    private ntv_ChoosePixelFormatARB_3 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): glBool32>(ChoosePixelFormatARB_adr);
    private ntv_ChoosePixelFormatARB_4 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): glBool32>(ChoosePixelFormatARB_adr);
    private ntv_ChoosePixelFormatARB_5 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): glBool32>(ChoosePixelFormatARB_adr);
    private ntv_ChoosePixelFormatARB_6 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): glBool32>(ChoosePixelFormatARB_adr);
    private ntv_ChoosePixelFormatARB_7 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): glBool32>(ChoosePixelFormatARB_adr);
    private ntv_ChoosePixelFormatARB_8 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): glBool32>(ChoosePixelFormatARB_adr);
    private ntv_ChoosePixelFormatARB_9 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): glBool32>(ChoosePixelFormatARB_adr);
    private ntv_ChoosePixelFormatARB_10 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): glBool32>(ChoosePixelFormatARB_adr);
    private ntv_ChoosePixelFormatARB_11 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): glBool32>(ChoosePixelFormatARB_adr);
    private ntv_ChoosePixelFormatARB_12 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): glBool32>(ChoosePixelFormatARB_adr);
    private ntv_ChoosePixelFormatARB_13 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): glBool32>(ChoosePixelFormatARB_adr);
    private ntv_ChoosePixelFormatARB_14 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): glBool32>(ChoosePixelFormatARB_adr);
    private ntv_ChoosePixelFormatARB_15 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): glBool32>(ChoosePixelFormatARB_adr);
    private ntv_ChoosePixelFormatARB_16 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): glBool32>(ChoosePixelFormatARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): glBool32;
    type PInt32 = ^Int32;
    type PSingle = ^single;
    type PUInt32 = ^UInt32;
    begin
      Result := if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
        if (pfAttribFList<>nil) and (pfAttribFList.Length<>0) then
          if (nNumFormats<>nil) and (nNumFormats.Length<>0) then
            if (piFormats<>nil) and (piFormats.Length<>0) then
              ntv_ChoosePixelFormatARB_1(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats[0]) else
              ntv_ChoosePixelFormatARB_1(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, PInt32(nil)^, nNumFormats[0]) else
            if (piFormats<>nil) and (piFormats.Length<>0) then
              ntv_ChoosePixelFormatARB_1(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats[0], PUInt32(nil)^) else
              ntv_ChoosePixelFormatARB_1(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, PInt32(nil)^, PUInt32(nil)^) else
          if (nNumFormats<>nil) and (nNumFormats.Length<>0) then
            if (piFormats<>nil) and (piFormats.Length<>0) then
              ntv_ChoosePixelFormatARB_1(hdc, piAttribIList[0], PSingle(nil)^, nMaxFormats, piFormats[0], nNumFormats[0]) else
              ntv_ChoosePixelFormatARB_1(hdc, piAttribIList[0], PSingle(nil)^, nMaxFormats, PInt32(nil)^, nNumFormats[0]) else
            if (piFormats<>nil) and (piFormats.Length<>0) then
              ntv_ChoosePixelFormatARB_1(hdc, piAttribIList[0], PSingle(nil)^, nMaxFormats, piFormats[0], PUInt32(nil)^) else
              ntv_ChoosePixelFormatARB_1(hdc, piAttribIList[0], PSingle(nil)^, nMaxFormats, PInt32(nil)^, PUInt32(nil)^) else
        if (pfAttribFList<>nil) and (pfAttribFList.Length<>0) then
          if (nNumFormats<>nil) and (nNumFormats.Length<>0) then
            if (piFormats<>nil) and (piFormats.Length<>0) then
              ntv_ChoosePixelFormatARB_1(hdc, PInt32(nil)^, pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats[0]) else
              ntv_ChoosePixelFormatARB_1(hdc, PInt32(nil)^, pfAttribFList[0], nMaxFormats, PInt32(nil)^, nNumFormats[0]) else
            if (piFormats<>nil) and (piFormats.Length<>0) then
              ntv_ChoosePixelFormatARB_1(hdc, PInt32(nil)^, pfAttribFList[0], nMaxFormats, piFormats[0], PUInt32(nil)^) else
              ntv_ChoosePixelFormatARB_1(hdc, PInt32(nil)^, pfAttribFList[0], nMaxFormats, PInt32(nil)^, PUInt32(nil)^) else
          if (nNumFormats<>nil) and (nNumFormats.Length<>0) then
            if (piFormats<>nil) and (piFormats.Length<>0) then
              ntv_ChoosePixelFormatARB_1(hdc, PInt32(nil)^, PSingle(nil)^, nMaxFormats, piFormats[0], nNumFormats[0]) else
              ntv_ChoosePixelFormatARB_1(hdc, PInt32(nil)^, PSingle(nil)^, nMaxFormats, PInt32(nil)^, nNumFormats[0]) else
            if (piFormats<>nil) and (piFormats.Length<>0) then
              ntv_ChoosePixelFormatARB_1(hdc, PInt32(nil)^, PSingle(nil)^, nMaxFormats, piFormats[0], PUInt32(nil)^) else
              ntv_ChoosePixelFormatARB_1(hdc, PInt32(nil)^, PSingle(nil)^, nMaxFormats, PInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): glBool32 :=
      ntv_ChoosePixelFormatARB_1(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): glBool32 :=
      ntv_ChoosePixelFormatARB_2(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): glBool32 :=
      ntv_ChoosePixelFormatARB_3(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): glBool32 :=
      ntv_ChoosePixelFormatARB_4(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): glBool32 :=
      ntv_ChoosePixelFormatARB_5(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): glBool32 :=
      ntv_ChoosePixelFormatARB_6(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): glBool32 :=
      ntv_ChoosePixelFormatARB_7(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): glBool32 :=
      ntv_ChoosePixelFormatARB_8(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): glBool32 :=
      ntv_ChoosePixelFormatARB_9(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): glBool32 :=
      ntv_ChoosePixelFormatARB_10(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): glBool32 :=
      ntv_ChoosePixelFormatARB_11(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): glBool32 :=
      ntv_ChoosePixelFormatARB_12(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): glBool32 :=
      ntv_ChoosePixelFormatARB_13(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): glBool32 :=
      ntv_ChoosePixelFormatARB_14(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): glBool32 :=
      ntv_ChoosePixelFormatARB_15(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): glBool32 :=
      ntv_ChoosePixelFormatARB_16(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    
  end;
  
  ///
  wglPixelFormatFloatARB = static class
    public const _ExtStr = 'WGL_ARB_pixel_format_float';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglRenderTextureARB = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_ARB_render_texture';
    
    private BindTexImageARB_adr := GetProcAddress('wglBindTexImageARB');
    private ntv_BindTexImageARB_1 := GetProcOrNil&<function(hPbuffer: wgl_pixel_buffer; iBuffer: wglColorBuffer): glBool32>(BindTexImageARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindTexImageARB(hPbuffer: wgl_pixel_buffer; iBuffer: wglColorBuffer): glBool32 :=
      ntv_BindTexImageARB_1(hPbuffer, iBuffer);
    
    private ReleaseTexImageARB_adr := GetProcAddress('wglReleaseTexImageARB');
    private ntv_ReleaseTexImageARB_1 := GetProcOrNil&<function(hPbuffer: wgl_pixel_buffer; iBuffer: wglColorBuffer): glBool32>(ReleaseTexImageARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseTexImageARB(hPbuffer: wgl_pixel_buffer; iBuffer: wglColorBuffer): glBool32 :=
      ntv_ReleaseTexImageARB_1(hPbuffer, iBuffer);
    
    private SetPbufferAttribARB_adr := GetProcAddress('wglSetPbufferAttribARB');
    private ntv_SetPbufferAttribARB_1 := GetProcOrNil&<function(hPbuffer: wgl_pixel_buffer; var piAttribList: Int32): glBool32>(SetPbufferAttribARB_adr);
    private ntv_SetPbufferAttribARB_2 := GetProcOrNil&<function(hPbuffer: wgl_pixel_buffer; piAttribList: IntPtr): glBool32>(SetPbufferAttribARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetPbufferAttribARB(hPbuffer: wgl_pixel_buffer; piAttribList: array of Int32): glBool32;
    type PInt32 = ^Int32;
    begin
      Result := if (piAttribList<>nil) and (piAttribList.Length<>0) then
        ntv_SetPbufferAttribARB_1(hPbuffer, piAttribList[0]) else
        ntv_SetPbufferAttribARB_1(hPbuffer, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetPbufferAttribARB(hPbuffer: wgl_pixel_buffer; var piAttribList: Int32): glBool32 :=
      ntv_SetPbufferAttribARB_1(hPbuffer, piAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetPbufferAttribARB(hPbuffer: wgl_pixel_buffer; piAttribList: IntPtr): glBool32 :=
      ntv_SetPbufferAttribARB_2(hPbuffer, piAttribList);
    
  end;
  
  ///
  wglRobustnessApplicationIsolationARB = static class
    public const _ExtStr = 'WGL_ARB_robustness_application_isolation';
  end;
  
  ///
  wglRobustnessShareGroupIsolationARB = static class
    public const _ExtStr = 'WGL_ARB_robustness_share_group_isolation';
  end;
  
  ///
  wglPixelFormatFloatATI = static class
    public const _ExtStr = 'WGL_ATI_pixel_format_float';
  end;
  
  ///
  wglRenderTextureRectangleATI = static class
    public const _ExtStr = 'WGL_ATI_render_texture_rectangle';
  end;
  
  ///
  wglColorspaceEXT = static class
    public const _ExtStr = 'WGL_EXT_colorspace';
  end;
  
  ///
  wglCreateContextEsProfileEXT = static class
    public const _ExtStr = 'WGL_EXT_create_context_es_profile';
  end;
  
  ///
  wglCreateContextEs2ProfileEXT = static class
    public const _ExtStr = 'WGL_EXT_create_context_es2_profile';
  end;
  
  ///
  wglDepthFloatEXT = static class
    public const _ExtStr = 'WGL_EXT_depth_float';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglDisplayColorTableEXT = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_EXT_display_color_table';
    
    private CreateDisplayColorTableEXT_adr := GetProcAddress('wglCreateDisplayColorTableEXT');
    private ntv_CreateDisplayColorTableEXT_1 := GetProcOrNil&<function(id: UInt16): glBool8>(CreateDisplayColorTableEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateDisplayColorTableEXT(id: UInt16): glBool8 :=
      ntv_CreateDisplayColorTableEXT_1(id);
    
    private LoadDisplayColorTableEXT_adr := GetProcAddress('wglLoadDisplayColorTableEXT');
    private ntv_LoadDisplayColorTableEXT_1 := GetProcOrNil&<function(var table: UInt16; length: UInt32): glBool8>(LoadDisplayColorTableEXT_adr);
    private ntv_LoadDisplayColorTableEXT_2 := GetProcOrNil&<function(table: IntPtr; length: UInt32): glBool8>(LoadDisplayColorTableEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function LoadDisplayColorTableEXT(table: array of UInt16; length: UInt32): glBool8;
    type PUInt16 = ^UInt16;
    begin
      Result := if (table<>nil) and (table.Length<>0) then
        ntv_LoadDisplayColorTableEXT_1(table[0], length) else
        ntv_LoadDisplayColorTableEXT_1(PUInt16(nil)^, length);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function LoadDisplayColorTableEXT(var table: UInt16; length: UInt32): glBool8 :=
      ntv_LoadDisplayColorTableEXT_1(table, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function LoadDisplayColorTableEXT(table: IntPtr; length: UInt32): glBool8 :=
      ntv_LoadDisplayColorTableEXT_2(table, length);
    
    private BindDisplayColorTableEXT_adr := GetProcAddress('wglBindDisplayColorTableEXT');
    private ntv_BindDisplayColorTableEXT_1 := GetProcOrNil&<function(id: UInt16): glBool8>(BindDisplayColorTableEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindDisplayColorTableEXT(id: UInt16): glBool8 :=
      ntv_BindDisplayColorTableEXT_1(id);
    
    private DestroyDisplayColorTableEXT_adr := GetProcAddress('wglDestroyDisplayColorTableEXT');
    private ntv_DestroyDisplayColorTableEXT_1 := GetProcOrNil&<procedure(id: UInt16)>(DestroyDisplayColorTableEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DestroyDisplayColorTableEXT(id: UInt16) :=
      ntv_DestroyDisplayColorTableEXT_1(id);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglExtensionsStringEXT = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_EXT_extensions_string';
    
    private GetExtensionsStringEXT_adr := GetProcAddress('wglGetExtensionsStringEXT');
    private ntv_GetExtensionsStringEXT_1 := GetProcOrNil&<function: IntPtr>(GetExtensionsStringEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetExtensionsStringEXT: string :=
      Marshal.PtrToStringAnsi(ntv_GetExtensionsStringEXT_1);
    
  end;
  
  ///
  wglFramebufferSRGBEXT = static class
    public const _ExtStr = 'WGL_EXT_framebuffer_sRGB';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglMakeCurrentReadEXT = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_EXT_make_current_read';
    
    private MakeContextCurrentEXT_adr := GetProcAddress('wglMakeContextCurrentEXT');
    private ntv_MakeContextCurrentEXT_1 := GetProcOrNil&<function(hDrawDC: gdi_device_context; hReadDC: gdi_device_context; hglrc: gdi_rendering_context): glBool32>(MakeContextCurrentEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeContextCurrentEXT(hDrawDC: gdi_device_context; hReadDC: gdi_device_context; hglrc: gdi_rendering_context): glBool32 :=
      ntv_MakeContextCurrentEXT_1(hDrawDC, hReadDC, hglrc);
    
    private GetCurrentReadDCEXT_adr := GetProcAddress('wglGetCurrentReadDCEXT');
    private ntv_GetCurrentReadDCEXT_1 := GetProcOrNil&<function: gdi_device_context>(GetCurrentReadDCEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentReadDCEXT: gdi_device_context :=
      ntv_GetCurrentReadDCEXT_1;
    
  end;
  
  ///
  wglMultisampleEXT = static class
    public const _ExtStr = 'WGL_EXT_multisample';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglPbufferEXT = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_EXT_pbuffer';
    
    private CreatePbufferEXT_adr := GetProcAddress('wglCreatePbufferEXT');
    private ntv_CreatePbufferEXT_1 := GetProcOrNil&<function(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; var piAttribList: Int32): wgl_pixel_buffer>(CreatePbufferEXT_adr);
    private ntv_CreatePbufferEXT_2 := GetProcOrNil&<function(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: IntPtr): wgl_pixel_buffer>(CreatePbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferEXT(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: array of Int32): wgl_pixel_buffer;
    type PInt32 = ^Int32;
    begin
      Result := if (piAttribList<>nil) and (piAttribList.Length<>0) then
        ntv_CreatePbufferEXT_1(hDC, iPixelFormat, iWidth, iHeight, piAttribList[0]) else
        ntv_CreatePbufferEXT_1(hDC, iPixelFormat, iWidth, iHeight, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferEXT(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; var piAttribList: Int32): wgl_pixel_buffer :=
      ntv_CreatePbufferEXT_1(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferEXT(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: IntPtr): wgl_pixel_buffer :=
      ntv_CreatePbufferEXT_2(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
    
    private GetPbufferDCEXT_adr := GetProcAddress('wglGetPbufferDCEXT');
    private ntv_GetPbufferDCEXT_1 := GetProcOrNil&<function(hPbuffer: wgl_pixel_buffer): gdi_device_context>(GetPbufferDCEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPbufferDCEXT(hPbuffer: wgl_pixel_buffer): gdi_device_context :=
      ntv_GetPbufferDCEXT_1(hPbuffer);
    
    private ReleasePbufferDCEXT_adr := GetProcAddress('wglReleasePbufferDCEXT');
    private ntv_ReleasePbufferDCEXT_1 := GetProcOrNil&<function(hPbuffer: wgl_pixel_buffer; hDC: gdi_device_context): Int32>(ReleasePbufferDCEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleasePbufferDCEXT(hPbuffer: wgl_pixel_buffer; hDC: gdi_device_context): Int32 :=
      ntv_ReleasePbufferDCEXT_1(hPbuffer, hDC);
    
    private DestroyPbufferEXT_adr := GetProcAddress('wglDestroyPbufferEXT');
    private ntv_DestroyPbufferEXT_1 := GetProcOrNil&<function(hPbuffer: wgl_pixel_buffer): glBool32>(DestroyPbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DestroyPbufferEXT(hPbuffer: wgl_pixel_buffer): glBool32 :=
      ntv_DestroyPbufferEXT_1(hPbuffer);
    
    private QueryPbufferEXT_adr := GetProcAddress('wglQueryPbufferEXT');
    private ntv_QueryPbufferEXT_1 := GetProcOrNil&<function(hPbuffer: wgl_pixel_buffer; iAttribute: wglPBufferAttribute; var piValue: Int32): glBool32>(QueryPbufferEXT_adr);
    private ntv_QueryPbufferEXT_2 := GetProcOrNil&<function(hPbuffer: wgl_pixel_buffer; iAttribute: wglPBufferAttribute; piValue: IntPtr): glBool32>(QueryPbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferEXT(hPbuffer: wgl_pixel_buffer; iAttribute: wglPBufferAttribute; piValue: array of Int32): glBool32;
    type PInt32 = ^Int32;
    begin
      Result := if (piValue<>nil) and (piValue.Length<>0) then
        ntv_QueryPbufferEXT_1(hPbuffer, iAttribute, piValue[0]) else
        ntv_QueryPbufferEXT_1(hPbuffer, iAttribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferEXT(hPbuffer: wgl_pixel_buffer; iAttribute: wglPBufferAttribute; var piValue: Int32): glBool32 :=
      ntv_QueryPbufferEXT_1(hPbuffer, iAttribute, piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferEXT(hPbuffer: wgl_pixel_buffer; iAttribute: wglPBufferAttribute; piValue: IntPtr): glBool32 :=
      ntv_QueryPbufferEXT_2(hPbuffer, iAttribute, piValue);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglPixelFormatEXT = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_EXT_pixel_format';
    
    private GetPixelFormatAttribivEXT_adr := GetProcAddress('wglGetPixelFormatAttribivEXT');
    private ntv_GetPixelFormatAttribivEXT_1 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: wglPixelFormatAttribute; var piValues: Int32): glBool32>(GetPixelFormatAttribivEXT_adr);
    private ntv_GetPixelFormatAttribivEXT_2 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: wglPixelFormatAttribute; piValues: IntPtr): glBool32>(GetPixelFormatAttribivEXT_adr);
    private ntv_GetPixelFormatAttribivEXT_3 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; var piValues: Int32): glBool32>(GetPixelFormatAttribivEXT_adr);
    private ntv_GetPixelFormatAttribivEXT_4 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; piValues: IntPtr): glBool32>(GetPixelFormatAttribivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivEXT(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: wglPixelFormatAttribute; var piValues: Int32): glBool32 :=
      ntv_GetPixelFormatAttribivEXT_1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivEXT(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: wglPixelFormatAttribute; piValues: IntPtr): glBool32 :=
      ntv_GetPixelFormatAttribivEXT_2(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivEXT(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; var piValues: Int32): glBool32 :=
      ntv_GetPixelFormatAttribivEXT_3(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivEXT(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; piValues: IntPtr): glBool32 :=
      ntv_GetPixelFormatAttribivEXT_4(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    
    private GetPixelFormatAttribfvEXT_adr := GetProcAddress('wglGetPixelFormatAttribfvEXT');
    private ntv_GetPixelFormatAttribfvEXT_1 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: wglPixelFormatAttribute; var pfValues: single): glBool32>(GetPixelFormatAttribfvEXT_adr);
    private ntv_GetPixelFormatAttribfvEXT_2 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: wglPixelFormatAttribute; pfValues: IntPtr): glBool32>(GetPixelFormatAttribfvEXT_adr);
    private ntv_GetPixelFormatAttribfvEXT_3 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; var pfValues: single): glBool32>(GetPixelFormatAttribfvEXT_adr);
    private ntv_GetPixelFormatAttribfvEXT_4 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; pfValues: IntPtr): glBool32>(GetPixelFormatAttribfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvEXT(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: wglPixelFormatAttribute; var pfValues: single): glBool32 :=
      ntv_GetPixelFormatAttribfvEXT_1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvEXT(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: wglPixelFormatAttribute; pfValues: IntPtr): glBool32 :=
      ntv_GetPixelFormatAttribfvEXT_2(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvEXT(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; var pfValues: single): glBool32 :=
      ntv_GetPixelFormatAttribfvEXT_3(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvEXT(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; pfValues: IntPtr): glBool32 :=
      ntv_GetPixelFormatAttribfvEXT_4(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    
    private ChoosePixelFormatEXT_adr := GetProcAddress('wglChoosePixelFormatEXT');
    private ntv_ChoosePixelFormatEXT_1 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): glBool32>(ChoosePixelFormatEXT_adr);
    private ntv_ChoosePixelFormatEXT_2 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): glBool32>(ChoosePixelFormatEXT_adr);
    private ntv_ChoosePixelFormatEXT_3 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): glBool32>(ChoosePixelFormatEXT_adr);
    private ntv_ChoosePixelFormatEXT_4 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): glBool32>(ChoosePixelFormatEXT_adr);
    private ntv_ChoosePixelFormatEXT_5 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): glBool32>(ChoosePixelFormatEXT_adr);
    private ntv_ChoosePixelFormatEXT_6 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): glBool32>(ChoosePixelFormatEXT_adr);
    private ntv_ChoosePixelFormatEXT_7 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): glBool32>(ChoosePixelFormatEXT_adr);
    private ntv_ChoosePixelFormatEXT_8 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): glBool32>(ChoosePixelFormatEXT_adr);
    private ntv_ChoosePixelFormatEXT_9 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): glBool32>(ChoosePixelFormatEXT_adr);
    private ntv_ChoosePixelFormatEXT_10 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): glBool32>(ChoosePixelFormatEXT_adr);
    private ntv_ChoosePixelFormatEXT_11 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): glBool32>(ChoosePixelFormatEXT_adr);
    private ntv_ChoosePixelFormatEXT_12 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): glBool32>(ChoosePixelFormatEXT_adr);
    private ntv_ChoosePixelFormatEXT_13 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): glBool32>(ChoosePixelFormatEXT_adr);
    private ntv_ChoosePixelFormatEXT_14 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): glBool32>(ChoosePixelFormatEXT_adr);
    private ntv_ChoosePixelFormatEXT_15 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): glBool32>(ChoosePixelFormatEXT_adr);
    private ntv_ChoosePixelFormatEXT_16 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): glBool32>(ChoosePixelFormatEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): glBool32;
    type PInt32 = ^Int32;
    type PSingle = ^single;
    type PUInt32 = ^UInt32;
    begin
      Result := if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
        if (pfAttribFList<>nil) and (pfAttribFList.Length<>0) then
          if (nNumFormats<>nil) and (nNumFormats.Length<>0) then
            if (piFormats<>nil) and (piFormats.Length<>0) then
              ntv_ChoosePixelFormatEXT_1(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats[0]) else
              ntv_ChoosePixelFormatEXT_1(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, PInt32(nil)^, nNumFormats[0]) else
            if (piFormats<>nil) and (piFormats.Length<>0) then
              ntv_ChoosePixelFormatEXT_1(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats[0], PUInt32(nil)^) else
              ntv_ChoosePixelFormatEXT_1(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, PInt32(nil)^, PUInt32(nil)^) else
          if (nNumFormats<>nil) and (nNumFormats.Length<>0) then
            if (piFormats<>nil) and (piFormats.Length<>0) then
              ntv_ChoosePixelFormatEXT_1(hdc, piAttribIList[0], PSingle(nil)^, nMaxFormats, piFormats[0], nNumFormats[0]) else
              ntv_ChoosePixelFormatEXT_1(hdc, piAttribIList[0], PSingle(nil)^, nMaxFormats, PInt32(nil)^, nNumFormats[0]) else
            if (piFormats<>nil) and (piFormats.Length<>0) then
              ntv_ChoosePixelFormatEXT_1(hdc, piAttribIList[0], PSingle(nil)^, nMaxFormats, piFormats[0], PUInt32(nil)^) else
              ntv_ChoosePixelFormatEXT_1(hdc, piAttribIList[0], PSingle(nil)^, nMaxFormats, PInt32(nil)^, PUInt32(nil)^) else
        if (pfAttribFList<>nil) and (pfAttribFList.Length<>0) then
          if (nNumFormats<>nil) and (nNumFormats.Length<>0) then
            if (piFormats<>nil) and (piFormats.Length<>0) then
              ntv_ChoosePixelFormatEXT_1(hdc, PInt32(nil)^, pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats[0]) else
              ntv_ChoosePixelFormatEXT_1(hdc, PInt32(nil)^, pfAttribFList[0], nMaxFormats, PInt32(nil)^, nNumFormats[0]) else
            if (piFormats<>nil) and (piFormats.Length<>0) then
              ntv_ChoosePixelFormatEXT_1(hdc, PInt32(nil)^, pfAttribFList[0], nMaxFormats, piFormats[0], PUInt32(nil)^) else
              ntv_ChoosePixelFormatEXT_1(hdc, PInt32(nil)^, pfAttribFList[0], nMaxFormats, PInt32(nil)^, PUInt32(nil)^) else
          if (nNumFormats<>nil) and (nNumFormats.Length<>0) then
            if (piFormats<>nil) and (piFormats.Length<>0) then
              ntv_ChoosePixelFormatEXT_1(hdc, PInt32(nil)^, PSingle(nil)^, nMaxFormats, piFormats[0], nNumFormats[0]) else
              ntv_ChoosePixelFormatEXT_1(hdc, PInt32(nil)^, PSingle(nil)^, nMaxFormats, PInt32(nil)^, nNumFormats[0]) else
            if (piFormats<>nil) and (piFormats.Length<>0) then
              ntv_ChoosePixelFormatEXT_1(hdc, PInt32(nil)^, PSingle(nil)^, nMaxFormats, piFormats[0], PUInt32(nil)^) else
              ntv_ChoosePixelFormatEXT_1(hdc, PInt32(nil)^, PSingle(nil)^, nMaxFormats, PInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): glBool32 :=
      ntv_ChoosePixelFormatEXT_1(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): glBool32 :=
      ntv_ChoosePixelFormatEXT_2(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): glBool32 :=
      ntv_ChoosePixelFormatEXT_3(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): glBool32 :=
      ntv_ChoosePixelFormatEXT_4(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): glBool32 :=
      ntv_ChoosePixelFormatEXT_5(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): glBool32 :=
      ntv_ChoosePixelFormatEXT_6(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): glBool32 :=
      ntv_ChoosePixelFormatEXT_7(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): glBool32 :=
      ntv_ChoosePixelFormatEXT_8(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): glBool32 :=
      ntv_ChoosePixelFormatEXT_9(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): glBool32 :=
      ntv_ChoosePixelFormatEXT_10(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): glBool32 :=
      ntv_ChoosePixelFormatEXT_11(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): glBool32 :=
      ntv_ChoosePixelFormatEXT_12(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): glBool32 :=
      ntv_ChoosePixelFormatEXT_13(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): glBool32 :=
      ntv_ChoosePixelFormatEXT_14(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): glBool32 :=
      ntv_ChoosePixelFormatEXT_15(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): glBool32 :=
      ntv_ChoosePixelFormatEXT_16(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    
  end;
  
  ///
  wglPixelFormatPackedFloatEXT = static class
    public const _ExtStr = 'WGL_EXT_pixel_format_packed_float';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglSwapControlEXT = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_EXT_swap_control';
    
    private SwapIntervalEXT_adr := GetProcAddress('wglSwapIntervalEXT');
    private ntv_SwapIntervalEXT_1 := GetProcOrNil&<function(interval: Int32): glBool32>(SwapIntervalEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapIntervalEXT(interval: Int32): glBool32 :=
      ntv_SwapIntervalEXT_1(interval);
    
    private GetSwapIntervalEXT_adr := GetProcAddress('wglGetSwapIntervalEXT');
    private ntv_GetSwapIntervalEXT_1 := GetProcOrNil&<function: Int32>(GetSwapIntervalEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSwapIntervalEXT: Int32 :=
      ntv_GetSwapIntervalEXT_1;
    
  end;
  
  ///
  wglSwapControlTearEXT = static class
    public const _ExtStr = 'WGL_EXT_swap_control_tear';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglDigitalVideoControlI3D = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_I3D_digital_video_control';
    
    private GetDigitalVideoParametersI3D_adr := GetProcAddress('wglGetDigitalVideoParametersI3D');
    private ntv_GetDigitalVideoParametersI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; iAttribute: wglDigitalVideoAttribute; var piValue: Int32): glBool32>(GetDigitalVideoParametersI3D_adr);
    private ntv_GetDigitalVideoParametersI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; iAttribute: wglDigitalVideoAttribute; piValue: IntPtr): glBool32>(GetDigitalVideoParametersI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDigitalVideoParametersI3D(hDC: gdi_device_context; iAttribute: wglDigitalVideoAttribute; var piValue: Int32): glBool32 :=
      ntv_GetDigitalVideoParametersI3D_1(hDC, iAttribute, piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDigitalVideoParametersI3D(hDC: gdi_device_context; iAttribute: wglDigitalVideoAttribute; piValue: IntPtr): glBool32 :=
      ntv_GetDigitalVideoParametersI3D_2(hDC, iAttribute, piValue);
    
    private SetDigitalVideoParametersI3D_adr := GetProcAddress('wglSetDigitalVideoParametersI3D');
    private ntv_SetDigitalVideoParametersI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; iAttribute: wglDigitalVideoAttribute; var piValue: Int32): glBool32>(SetDigitalVideoParametersI3D_adr);
    private ntv_SetDigitalVideoParametersI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; iAttribute: wglDigitalVideoAttribute; piValue: IntPtr): glBool32>(SetDigitalVideoParametersI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetDigitalVideoParametersI3D(hDC: gdi_device_context; iAttribute: wglDigitalVideoAttribute; piValue: array of Int32): glBool32;
    type PInt32 = ^Int32;
    begin
      Result := if (piValue<>nil) and (piValue.Length<>0) then
        ntv_SetDigitalVideoParametersI3D_1(hDC, iAttribute, piValue[0]) else
        ntv_SetDigitalVideoParametersI3D_1(hDC, iAttribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetDigitalVideoParametersI3D(hDC: gdi_device_context; iAttribute: wglDigitalVideoAttribute; var piValue: Int32): glBool32 :=
      ntv_SetDigitalVideoParametersI3D_1(hDC, iAttribute, piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetDigitalVideoParametersI3D(hDC: gdi_device_context; iAttribute: wglDigitalVideoAttribute; piValue: IntPtr): glBool32 :=
      ntv_SetDigitalVideoParametersI3D_2(hDC, iAttribute, piValue);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglGammaI3D = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_I3D_gamma';
    
    private GetGammaTableParametersI3D_adr := GetProcAddress('wglGetGammaTableParametersI3D');
    private ntv_GetGammaTableParametersI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; iAttribute: wglGammaTableAttribute; var piValue: Int32): glBool32>(GetGammaTableParametersI3D_adr);
    private ntv_GetGammaTableParametersI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; iAttribute: wglGammaTableAttribute; piValue: IntPtr): glBool32>(GetGammaTableParametersI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableParametersI3D(hDC: gdi_device_context; iAttribute: wglGammaTableAttribute; var piValue: Int32): glBool32 :=
      ntv_GetGammaTableParametersI3D_1(hDC, iAttribute, piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableParametersI3D(hDC: gdi_device_context; iAttribute: wglGammaTableAttribute; piValue: IntPtr): glBool32 :=
      ntv_GetGammaTableParametersI3D_2(hDC, iAttribute, piValue);
    
    private SetGammaTableParametersI3D_adr := GetProcAddress('wglSetGammaTableParametersI3D');
    private ntv_SetGammaTableParametersI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; iAttribute: wglGammaTableAttribute; var piValue: Int32): glBool32>(SetGammaTableParametersI3D_adr);
    private ntv_SetGammaTableParametersI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; iAttribute: wglGammaTableAttribute; piValue: IntPtr): glBool32>(SetGammaTableParametersI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableParametersI3D(hDC: gdi_device_context; iAttribute: wglGammaTableAttribute; piValue: array of Int32): glBool32;
    type PInt32 = ^Int32;
    begin
      Result := if (piValue<>nil) and (piValue.Length<>0) then
        ntv_SetGammaTableParametersI3D_1(hDC, iAttribute, piValue[0]) else
        ntv_SetGammaTableParametersI3D_1(hDC, iAttribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableParametersI3D(hDC: gdi_device_context; iAttribute: wglGammaTableAttribute; var piValue: Int32): glBool32 :=
      ntv_SetGammaTableParametersI3D_1(hDC, iAttribute, piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableParametersI3D(hDC: gdi_device_context; iAttribute: wglGammaTableAttribute; piValue: IntPtr): glBool32 :=
      ntv_SetGammaTableParametersI3D_2(hDC, iAttribute, piValue);
    
    private GetGammaTableI3D_adr := GetProcAddress('wglGetGammaTableI3D');
    private ntv_GetGammaTableI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; var puBlue: UInt16): glBool32>(GetGammaTableI3D_adr);
    private ntv_GetGammaTableI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; puBlue: IntPtr): glBool32>(GetGammaTableI3D_adr);
    private ntv_GetGammaTableI3D_3 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; puGreen: IntPtr; var puBlue: UInt16): glBool32>(GetGammaTableI3D_adr);
    private ntv_GetGammaTableI3D_4 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; puGreen: IntPtr; puBlue: IntPtr): glBool32>(GetGammaTableI3D_adr);
    private ntv_GetGammaTableI3D_5 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; var puGreen: UInt16; var puBlue: UInt16): glBool32>(GetGammaTableI3D_adr);
    private ntv_GetGammaTableI3D_6 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; var puGreen: UInt16; puBlue: IntPtr): glBool32>(GetGammaTableI3D_adr);
    private ntv_GetGammaTableI3D_7 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; puGreen: IntPtr; var puBlue: UInt16): glBool32>(GetGammaTableI3D_adr);
    private ntv_GetGammaTableI3D_8 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; puGreen: IntPtr; puBlue: IntPtr): glBool32>(GetGammaTableI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; var puBlue: UInt16): glBool32 :=
      ntv_GetGammaTableI3D_1(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; puBlue: IntPtr): glBool32 :=
      ntv_GetGammaTableI3D_2(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; puGreen: IntPtr; var puBlue: UInt16): glBool32 :=
      ntv_GetGammaTableI3D_3(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; puGreen: IntPtr; puBlue: IntPtr): glBool32 :=
      ntv_GetGammaTableI3D_4(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; var puGreen: UInt16; var puBlue: UInt16): glBool32 :=
      ntv_GetGammaTableI3D_5(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; var puGreen: UInt16; puBlue: IntPtr): glBool32 :=
      ntv_GetGammaTableI3D_6(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; puGreen: IntPtr; var puBlue: UInt16): glBool32 :=
      ntv_GetGammaTableI3D_7(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; puGreen: IntPtr; puBlue: IntPtr): glBool32 :=
      ntv_GetGammaTableI3D_8(hDC, iEntries, puRed, puGreen, puBlue);
    
    private SetGammaTableI3D_adr := GetProcAddress('wglSetGammaTableI3D');
    private ntv_SetGammaTableI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; var puBlue: UInt16): glBool32>(SetGammaTableI3D_adr);
    private ntv_SetGammaTableI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; puBlue: IntPtr): glBool32>(SetGammaTableI3D_adr);
    private ntv_SetGammaTableI3D_3 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; puGreen: IntPtr; var puBlue: UInt16): glBool32>(SetGammaTableI3D_adr);
    private ntv_SetGammaTableI3D_4 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; puGreen: IntPtr; puBlue: IntPtr): glBool32>(SetGammaTableI3D_adr);
    private ntv_SetGammaTableI3D_5 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; var puGreen: UInt16; var puBlue: UInt16): glBool32>(SetGammaTableI3D_adr);
    private ntv_SetGammaTableI3D_6 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; var puGreen: UInt16; puBlue: IntPtr): glBool32>(SetGammaTableI3D_adr);
    private ntv_SetGammaTableI3D_7 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; puGreen: IntPtr; var puBlue: UInt16): glBool32>(SetGammaTableI3D_adr);
    private ntv_SetGammaTableI3D_8 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; puGreen: IntPtr; puBlue: IntPtr): glBool32>(SetGammaTableI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: array of UInt16; puGreen: array of UInt16; puBlue: array of UInt16): glBool32;
    type PUInt16 = ^UInt16;
    begin
      Result := if (puBlue<>nil) and (puBlue.Length<>0) then
        if (puRed<>nil) and (puRed.Length<>0) then
          if (puGreen<>nil) and (puGreen.Length<>0) then
            ntv_SetGammaTableI3D_1(hDC, iEntries, puRed[0], puGreen[0], puBlue[0]) else
            ntv_SetGammaTableI3D_1(hDC, iEntries, puRed[0], PUInt16(nil)^, puBlue[0]) else
          if (puGreen<>nil) and (puGreen.Length<>0) then
            ntv_SetGammaTableI3D_1(hDC, iEntries, PUInt16(nil)^, puGreen[0], puBlue[0]) else
            ntv_SetGammaTableI3D_1(hDC, iEntries, PUInt16(nil)^, PUInt16(nil)^, puBlue[0]) else
        if (puRed<>nil) and (puRed.Length<>0) then
          if (puGreen<>nil) and (puGreen.Length<>0) then
            ntv_SetGammaTableI3D_1(hDC, iEntries, puRed[0], puGreen[0], PUInt16(nil)^) else
            ntv_SetGammaTableI3D_1(hDC, iEntries, puRed[0], PUInt16(nil)^, PUInt16(nil)^) else
          if (puGreen<>nil) and (puGreen.Length<>0) then
            ntv_SetGammaTableI3D_1(hDC, iEntries, PUInt16(nil)^, puGreen[0], PUInt16(nil)^) else
            ntv_SetGammaTableI3D_1(hDC, iEntries, PUInt16(nil)^, PUInt16(nil)^, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; var puBlue: UInt16): glBool32 :=
      ntv_SetGammaTableI3D_1(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; puBlue: IntPtr): glBool32 :=
      ntv_SetGammaTableI3D_2(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; puGreen: IntPtr; var puBlue: UInt16): glBool32 :=
      ntv_SetGammaTableI3D_3(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; puGreen: IntPtr; puBlue: IntPtr): glBool32 :=
      ntv_SetGammaTableI3D_4(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; var puGreen: UInt16; var puBlue: UInt16): glBool32 :=
      ntv_SetGammaTableI3D_5(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; var puGreen: UInt16; puBlue: IntPtr): glBool32 :=
      ntv_SetGammaTableI3D_6(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; puGreen: IntPtr; var puBlue: UInt16): glBool32 :=
      ntv_SetGammaTableI3D_7(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; puGreen: IntPtr; puBlue: IntPtr): glBool32 :=
      ntv_SetGammaTableI3D_8(hDC, iEntries, puRed, puGreen, puBlue);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglGenlockI3D = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_I3D_genlock';
    
    private EnableGenlockI3D_adr := GetProcAddress('wglEnableGenlockI3D');
    private ntv_EnableGenlockI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context): glBool32>(EnableGenlockI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnableGenlockI3D(hDC: gdi_device_context): glBool32 :=
      ntv_EnableGenlockI3D_1(hDC);
    
    private DisableGenlockI3D_adr := GetProcAddress('wglDisableGenlockI3D');
    private ntv_DisableGenlockI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context): glBool32>(DisableGenlockI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DisableGenlockI3D(hDC: gdi_device_context): glBool32 :=
      ntv_DisableGenlockI3D_1(hDC);
    
    private IsEnabledGenlockI3D_adr := GetProcAddress('wglIsEnabledGenlockI3D');
    private ntv_IsEnabledGenlockI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; var pFlag: glBool32): glBool32>(IsEnabledGenlockI3D_adr);
    private ntv_IsEnabledGenlockI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; pFlag: IntPtr): glBool32>(IsEnabledGenlockI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledGenlockI3D(hDC: gdi_device_context; pFlag: array of glBool32): glBool32;
    type PGlBool32 = ^glBool32;
    begin
      Result := if (pFlag<>nil) and (pFlag.Length<>0) then
        ntv_IsEnabledGenlockI3D_1(hDC, pFlag[0]) else
        ntv_IsEnabledGenlockI3D_1(hDC, PGlBool32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledGenlockI3D(hDC: gdi_device_context; var pFlag: glBool32): glBool32 :=
      ntv_IsEnabledGenlockI3D_1(hDC, pFlag);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledGenlockI3D(hDC: gdi_device_context; pFlag: IntPtr): glBool32 :=
      ntv_IsEnabledGenlockI3D_2(hDC, pFlag);
    
    private GenlockSourceI3D_adr := GetProcAddress('wglGenlockSourceI3D');
    private ntv_GenlockSourceI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; uSource: UInt32): glBool32>(GenlockSourceI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenlockSourceI3D(hDC: gdi_device_context; uSource: UInt32): glBool32 :=
      ntv_GenlockSourceI3D_1(hDC, uSource);
    
    private GetGenlockSourceI3D_adr := GetProcAddress('wglGetGenlockSourceI3D');
    private ntv_GetGenlockSourceI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; var uSource: UInt32): glBool32>(GetGenlockSourceI3D_adr);
    private ntv_GetGenlockSourceI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; uSource: IntPtr): glBool32>(GetGenlockSourceI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceI3D(hDC: gdi_device_context; var uSource: UInt32): glBool32 :=
      ntv_GetGenlockSourceI3D_1(hDC, uSource);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceI3D(hDC: gdi_device_context; uSource: IntPtr): glBool32 :=
      ntv_GetGenlockSourceI3D_2(hDC, uSource);
    
    private GenlockSourceEdgeI3D_adr := GetProcAddress('wglGenlockSourceEdgeI3D');
    private ntv_GenlockSourceEdgeI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; uEdge: UInt32): glBool32>(GenlockSourceEdgeI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenlockSourceEdgeI3D(hDC: gdi_device_context; uEdge: UInt32): glBool32 :=
      ntv_GenlockSourceEdgeI3D_1(hDC, uEdge);
    
    private GetGenlockSourceEdgeI3D_adr := GetProcAddress('wglGetGenlockSourceEdgeI3D');
    private ntv_GetGenlockSourceEdgeI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; var uEdge: UInt32): glBool32>(GetGenlockSourceEdgeI3D_adr);
    private ntv_GetGenlockSourceEdgeI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; uEdge: IntPtr): glBool32>(GetGenlockSourceEdgeI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceEdgeI3D(hDC: gdi_device_context; var uEdge: UInt32): glBool32 :=
      ntv_GetGenlockSourceEdgeI3D_1(hDC, uEdge);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceEdgeI3D(hDC: gdi_device_context; uEdge: IntPtr): glBool32 :=
      ntv_GetGenlockSourceEdgeI3D_2(hDC, uEdge);
    
    private GenlockSampleRateI3D_adr := GetProcAddress('wglGenlockSampleRateI3D');
    private ntv_GenlockSampleRateI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; uRate: UInt32): glBool32>(GenlockSampleRateI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenlockSampleRateI3D(hDC: gdi_device_context; uRate: UInt32): glBool32 :=
      ntv_GenlockSampleRateI3D_1(hDC, uRate);
    
    private GetGenlockSampleRateI3D_adr := GetProcAddress('wglGetGenlockSampleRateI3D');
    private ntv_GetGenlockSampleRateI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; var uRate: UInt32): glBool32>(GetGenlockSampleRateI3D_adr);
    private ntv_GetGenlockSampleRateI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; uRate: IntPtr): glBool32>(GetGenlockSampleRateI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSampleRateI3D(hDC: gdi_device_context; var uRate: UInt32): glBool32 :=
      ntv_GetGenlockSampleRateI3D_1(hDC, uRate);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSampleRateI3D(hDC: gdi_device_context; uRate: IntPtr): glBool32 :=
      ntv_GetGenlockSampleRateI3D_2(hDC, uRate);
    
    private GenlockSourceDelayI3D_adr := GetProcAddress('wglGenlockSourceDelayI3D');
    private ntv_GenlockSourceDelayI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; uDelay: UInt32): glBool32>(GenlockSourceDelayI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenlockSourceDelayI3D(hDC: gdi_device_context; uDelay: UInt32): glBool32 :=
      ntv_GenlockSourceDelayI3D_1(hDC, uDelay);
    
    private GetGenlockSourceDelayI3D_adr := GetProcAddress('wglGetGenlockSourceDelayI3D');
    private ntv_GetGenlockSourceDelayI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; var uDelay: UInt32): glBool32>(GetGenlockSourceDelayI3D_adr);
    private ntv_GetGenlockSourceDelayI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; uDelay: IntPtr): glBool32>(GetGenlockSourceDelayI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceDelayI3D(hDC: gdi_device_context; var uDelay: UInt32): glBool32 :=
      ntv_GetGenlockSourceDelayI3D_1(hDC, uDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceDelayI3D(hDC: gdi_device_context; uDelay: IntPtr): glBool32 :=
      ntv_GetGenlockSourceDelayI3D_2(hDC, uDelay);
    
    private QueryGenlockMaxSourceDelayI3D_adr := GetProcAddress('wglQueryGenlockMaxSourceDelayI3D');
    private ntv_QueryGenlockMaxSourceDelayI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; var uMaxLineDelay: UInt32; var uMaxPixelDelay: UInt32): glBool32>(QueryGenlockMaxSourceDelayI3D_adr);
    private ntv_QueryGenlockMaxSourceDelayI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; var uMaxLineDelay: UInt32; uMaxPixelDelay: IntPtr): glBool32>(QueryGenlockMaxSourceDelayI3D_adr);
    private ntv_QueryGenlockMaxSourceDelayI3D_3 := GetProcOrNil&<function(hDC: gdi_device_context; uMaxLineDelay: IntPtr; var uMaxPixelDelay: UInt32): glBool32>(QueryGenlockMaxSourceDelayI3D_adr);
    private ntv_QueryGenlockMaxSourceDelayI3D_4 := GetProcOrNil&<function(hDC: gdi_device_context; uMaxLineDelay: IntPtr; uMaxPixelDelay: IntPtr): glBool32>(QueryGenlockMaxSourceDelayI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: gdi_device_context; uMaxLineDelay: array of UInt32; uMaxPixelDelay: array of UInt32): glBool32;
    type PUInt32 = ^UInt32;
    begin
      Result := if (uMaxPixelDelay<>nil) and (uMaxPixelDelay.Length<>0) then
        if (uMaxLineDelay<>nil) and (uMaxLineDelay.Length<>0) then
          ntv_QueryGenlockMaxSourceDelayI3D_1(hDC, uMaxLineDelay[0], uMaxPixelDelay[0]) else
          ntv_QueryGenlockMaxSourceDelayI3D_1(hDC, PUInt32(nil)^, uMaxPixelDelay[0]) else
        if (uMaxLineDelay<>nil) and (uMaxLineDelay.Length<>0) then
          ntv_QueryGenlockMaxSourceDelayI3D_1(hDC, uMaxLineDelay[0], PUInt32(nil)^) else
          ntv_QueryGenlockMaxSourceDelayI3D_1(hDC, PUInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: gdi_device_context; var uMaxLineDelay: UInt32; var uMaxPixelDelay: UInt32): glBool32 :=
      ntv_QueryGenlockMaxSourceDelayI3D_1(hDC, uMaxLineDelay, uMaxPixelDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: gdi_device_context; var uMaxLineDelay: UInt32; uMaxPixelDelay: IntPtr): glBool32 :=
      ntv_QueryGenlockMaxSourceDelayI3D_2(hDC, uMaxLineDelay, uMaxPixelDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: gdi_device_context; uMaxLineDelay: IntPtr; var uMaxPixelDelay: UInt32): glBool32 :=
      ntv_QueryGenlockMaxSourceDelayI3D_3(hDC, uMaxLineDelay, uMaxPixelDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: gdi_device_context; uMaxLineDelay: IntPtr; uMaxPixelDelay: IntPtr): glBool32 :=
      ntv_QueryGenlockMaxSourceDelayI3D_4(hDC, uMaxLineDelay, uMaxPixelDelay);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglImageBufferI3D = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_I3D_image_buffer';
    
    private CreateImageBufferI3D_adr := GetProcAddress('wglCreateImageBufferI3D');
    private ntv_CreateImageBufferI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; dwSize: UInt32; uFlags: wglImageBufferMask): IntPtr>(CreateImageBufferI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateImageBufferI3D(hDC: gdi_device_context; dwSize: UInt32; uFlags: wglImageBufferMask): IntPtr :=
      ntv_CreateImageBufferI3D_1(hDC, dwSize, uFlags);
    
    private DestroyImageBufferI3D_adr := GetProcAddress('wglDestroyImageBufferI3D');
    private ntv_DestroyImageBufferI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; pAddress: IntPtr): glBool32>(DestroyImageBufferI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DestroyImageBufferI3D(hDC: gdi_device_context; pAddress: IntPtr): glBool32 :=
      ntv_DestroyImageBufferI3D_1(hDC, pAddress);
    
    private AssociateImageBufferEventsI3D_adr := GetProcAddress('wglAssociateImageBufferEventsI3D');
    private ntv_AssociateImageBufferEventsI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; var pEvent: IntPtr; var pAddress: IntPtr; var pSize: UInt32; count: UInt32): glBool32>(AssociateImageBufferEventsI3D_adr);
    private ntv_AssociateImageBufferEventsI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; var pEvent: IntPtr; var pAddress: IntPtr; pSize: IntPtr; count: UInt32): glBool32>(AssociateImageBufferEventsI3D_adr);
    private ntv_AssociateImageBufferEventsI3D_3 := GetProcOrNil&<function(hDC: gdi_device_context; var pEvent: IntPtr; pAddress: pointer; var pSize: UInt32; count: UInt32): glBool32>(AssociateImageBufferEventsI3D_adr);
    private ntv_AssociateImageBufferEventsI3D_4 := GetProcOrNil&<function(hDC: gdi_device_context; var pEvent: IntPtr; pAddress: pointer; pSize: IntPtr; count: UInt32): glBool32>(AssociateImageBufferEventsI3D_adr);
    private ntv_AssociateImageBufferEventsI3D_5 := GetProcOrNil&<function(hDC: gdi_device_context; pEvent: pointer; var pAddress: IntPtr; var pSize: UInt32; count: UInt32): glBool32>(AssociateImageBufferEventsI3D_adr);
    private ntv_AssociateImageBufferEventsI3D_6 := GetProcOrNil&<function(hDC: gdi_device_context; pEvent: pointer; var pAddress: IntPtr; pSize: IntPtr; count: UInt32): glBool32>(AssociateImageBufferEventsI3D_adr);
    private ntv_AssociateImageBufferEventsI3D_7 := GetProcOrNil&<function(hDC: gdi_device_context; pEvent: pointer; pAddress: pointer; var pSize: UInt32; count: UInt32): glBool32>(AssociateImageBufferEventsI3D_adr);
    private ntv_AssociateImageBufferEventsI3D_8 := GetProcOrNil&<function(hDC: gdi_device_context; pEvent: pointer; pAddress: pointer; pSize: IntPtr; count: UInt32): glBool32>(AssociateImageBufferEventsI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; pEvent: array of IntPtr; pAddress: array of IntPtr; pSize: array of UInt32; count: UInt32): glBool32;
    type PIntPtr = ^IntPtr;
    type PUInt32 = ^UInt32;
    begin
      Result := if (pEvent<>nil) and (pEvent.Length<>0) then
        if (pAddress<>nil) and (pAddress.Length<>0) then
          if (pSize<>nil) and (pSize.Length<>0) then
            ntv_AssociateImageBufferEventsI3D_1(hDC, pEvent[0], pAddress[0], pSize[0], count) else
            ntv_AssociateImageBufferEventsI3D_1(hDC, pEvent[0], pAddress[0], PUInt32(nil)^, count) else
          if (pSize<>nil) and (pSize.Length<>0) then
            ntv_AssociateImageBufferEventsI3D_1(hDC, pEvent[0], PIntPtr(nil)^, pSize[0], count) else
            ntv_AssociateImageBufferEventsI3D_1(hDC, pEvent[0], PIntPtr(nil)^, PUInt32(nil)^, count) else
        if (pAddress<>nil) and (pAddress.Length<>0) then
          if (pSize<>nil) and (pSize.Length<>0) then
            ntv_AssociateImageBufferEventsI3D_1(hDC, PIntPtr(nil)^, pAddress[0], pSize[0], count) else
            ntv_AssociateImageBufferEventsI3D_1(hDC, PIntPtr(nil)^, pAddress[0], PUInt32(nil)^, count) else
          if (pSize<>nil) and (pSize.Length<>0) then
            ntv_AssociateImageBufferEventsI3D_1(hDC, PIntPtr(nil)^, PIntPtr(nil)^, pSize[0], count) else
            ntv_AssociateImageBufferEventsI3D_1(hDC, PIntPtr(nil)^, PIntPtr(nil)^, PUInt32(nil)^, count);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; var pEvent: IntPtr; var pAddress: IntPtr; var pSize: UInt32; count: UInt32): glBool32 :=
      ntv_AssociateImageBufferEventsI3D_1(hDC, pEvent, pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; var pEvent: IntPtr; var pAddress: IntPtr; pSize: IntPtr; count: UInt32): glBool32 :=
      ntv_AssociateImageBufferEventsI3D_2(hDC, pEvent, pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; var pEvent: IntPtr; pAddress: pointer; var pSize: UInt32; count: UInt32): glBool32 :=
      ntv_AssociateImageBufferEventsI3D_3(hDC, pEvent, pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; var pEvent: IntPtr; pAddress: pointer; pSize: IntPtr; count: UInt32): glBool32 :=
      ntv_AssociateImageBufferEventsI3D_4(hDC, pEvent, pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; pEvent: pointer; var pAddress: IntPtr; var pSize: UInt32; count: UInt32): glBool32 :=
      ntv_AssociateImageBufferEventsI3D_5(hDC, pEvent, pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; pEvent: pointer; var pAddress: IntPtr; pSize: IntPtr; count: UInt32): glBool32 :=
      ntv_AssociateImageBufferEventsI3D_6(hDC, pEvent, pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; pEvent: pointer; pAddress: pointer; var pSize: UInt32; count: UInt32): glBool32 :=
      ntv_AssociateImageBufferEventsI3D_7(hDC, pEvent, pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; pEvent: pointer; pAddress: pointer; pSize: IntPtr; count: UInt32): glBool32 :=
      ntv_AssociateImageBufferEventsI3D_8(hDC, pEvent, pAddress, pSize, count);
    
    private ReleaseImageBufferEventsI3D_adr := GetProcAddress('wglReleaseImageBufferEventsI3D');
    private ntv_ReleaseImageBufferEventsI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; var pAddress: IntPtr; count: UInt32): glBool32>(ReleaseImageBufferEventsI3D_adr);
    private ntv_ReleaseImageBufferEventsI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; pAddress: pointer; count: UInt32): glBool32>(ReleaseImageBufferEventsI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseImageBufferEventsI3D(hDC: gdi_device_context; pAddress: array of IntPtr; count: UInt32): glBool32;
    type PIntPtr = ^IntPtr;
    begin
      Result := if (pAddress<>nil) and (pAddress.Length<>0) then
        ntv_ReleaseImageBufferEventsI3D_1(hDC, pAddress[0], count) else
        ntv_ReleaseImageBufferEventsI3D_1(hDC, PIntPtr(nil)^, count);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseImageBufferEventsI3D(hDC: gdi_device_context; var pAddress: IntPtr; count: UInt32): glBool32 :=
      ntv_ReleaseImageBufferEventsI3D_1(hDC, pAddress, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseImageBufferEventsI3D(hDC: gdi_device_context; pAddress: pointer; count: UInt32): glBool32 :=
      ntv_ReleaseImageBufferEventsI3D_2(hDC, pAddress, count);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglSwapFrameLockI3D = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_I3D_swap_frame_lock';
    
    private EnableFrameLockI3D_adr := GetProcAddress('wglEnableFrameLockI3D');
    private ntv_EnableFrameLockI3D_1 := GetProcOrNil&<function: glBool32>(EnableFrameLockI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnableFrameLockI3D: glBool32 :=
      ntv_EnableFrameLockI3D_1;
    
    private DisableFrameLockI3D_adr := GetProcAddress('wglDisableFrameLockI3D');
    private ntv_DisableFrameLockI3D_1 := GetProcOrNil&<function: glBool32>(DisableFrameLockI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DisableFrameLockI3D: glBool32 :=
      ntv_DisableFrameLockI3D_1;
    
    private IsEnabledFrameLockI3D_adr := GetProcAddress('wglIsEnabledFrameLockI3D');
    private ntv_IsEnabledFrameLockI3D_1 := GetProcOrNil&<function(var pFlag: glBool32): glBool32>(IsEnabledFrameLockI3D_adr);
    private ntv_IsEnabledFrameLockI3D_2 := GetProcOrNil&<function(pFlag: IntPtr): glBool32>(IsEnabledFrameLockI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledFrameLockI3D(pFlag: array of glBool32): glBool32;
    type PGlBool32 = ^glBool32;
    begin
      Result := if (pFlag<>nil) and (pFlag.Length<>0) then
        ntv_IsEnabledFrameLockI3D_1(pFlag[0]) else
        ntv_IsEnabledFrameLockI3D_1(PGlBool32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledFrameLockI3D(var pFlag: glBool32): glBool32 :=
      ntv_IsEnabledFrameLockI3D_1(pFlag);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledFrameLockI3D(pFlag: IntPtr): glBool32 :=
      ntv_IsEnabledFrameLockI3D_2(pFlag);
    
    private QueryFrameLockMasterI3D_adr := GetProcAddress('wglQueryFrameLockMasterI3D');
    private ntv_QueryFrameLockMasterI3D_1 := GetProcOrNil&<function(var pFlag: glBool32): glBool32>(QueryFrameLockMasterI3D_adr);
    private ntv_QueryFrameLockMasterI3D_2 := GetProcOrNil&<function(pFlag: IntPtr): glBool32>(QueryFrameLockMasterI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameLockMasterI3D(pFlag: array of glBool32): glBool32;
    type PGlBool32 = ^glBool32;
    begin
      Result := if (pFlag<>nil) and (pFlag.Length<>0) then
        ntv_QueryFrameLockMasterI3D_1(pFlag[0]) else
        ntv_QueryFrameLockMasterI3D_1(PGlBool32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameLockMasterI3D(var pFlag: glBool32): glBool32 :=
      ntv_QueryFrameLockMasterI3D_1(pFlag);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameLockMasterI3D(pFlag: IntPtr): glBool32 :=
      ntv_QueryFrameLockMasterI3D_2(pFlag);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglSwapFrameUsageI3D = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_I3D_swap_frame_usage';
    
    private GetFrameUsageI3D_adr := GetProcAddress('wglGetFrameUsageI3D');
    private ntv_GetFrameUsageI3D_1 := GetProcOrNil&<function(var pUsage: single): glBool32>(GetFrameUsageI3D_adr);
    private ntv_GetFrameUsageI3D_2 := GetProcOrNil&<function(pUsage: IntPtr): glBool32>(GetFrameUsageI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFrameUsageI3D(var pUsage: single): glBool32 :=
      ntv_GetFrameUsageI3D_1(pUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFrameUsageI3D(pUsage: IntPtr): glBool32 :=
      ntv_GetFrameUsageI3D_2(pUsage);
    
    private BeginFrameTrackingI3D_adr := GetProcAddress('wglBeginFrameTrackingI3D');
    private ntv_BeginFrameTrackingI3D_1 := GetProcOrNil&<function: glBool32>(BeginFrameTrackingI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BeginFrameTrackingI3D: glBool32 :=
      ntv_BeginFrameTrackingI3D_1;
    
    private EndFrameTrackingI3D_adr := GetProcAddress('wglEndFrameTrackingI3D');
    private ntv_EndFrameTrackingI3D_1 := GetProcOrNil&<function: glBool32>(EndFrameTrackingI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EndFrameTrackingI3D: glBool32 :=
      ntv_EndFrameTrackingI3D_1;
    
    private QueryFrameTrackingI3D_adr := GetProcAddress('wglQueryFrameTrackingI3D');
    private ntv_QueryFrameTrackingI3D_1 := GetProcOrNil&<function(var pFrameCount: UInt32; var pMissedFrames: UInt32; var pLastMissedUsage: single): glBool32>(QueryFrameTrackingI3D_adr);
    private ntv_QueryFrameTrackingI3D_2 := GetProcOrNil&<function(var pFrameCount: UInt32; var pMissedFrames: UInt32; pLastMissedUsage: IntPtr): glBool32>(QueryFrameTrackingI3D_adr);
    private ntv_QueryFrameTrackingI3D_3 := GetProcOrNil&<function(var pFrameCount: UInt32; pMissedFrames: IntPtr; var pLastMissedUsage: single): glBool32>(QueryFrameTrackingI3D_adr);
    private ntv_QueryFrameTrackingI3D_4 := GetProcOrNil&<function(var pFrameCount: UInt32; pMissedFrames: IntPtr; pLastMissedUsage: IntPtr): glBool32>(QueryFrameTrackingI3D_adr);
    private ntv_QueryFrameTrackingI3D_5 := GetProcOrNil&<function(pFrameCount: IntPtr; var pMissedFrames: UInt32; var pLastMissedUsage: single): glBool32>(QueryFrameTrackingI3D_adr);
    private ntv_QueryFrameTrackingI3D_6 := GetProcOrNil&<function(pFrameCount: IntPtr; var pMissedFrames: UInt32; pLastMissedUsage: IntPtr): glBool32>(QueryFrameTrackingI3D_adr);
    private ntv_QueryFrameTrackingI3D_7 := GetProcOrNil&<function(pFrameCount: IntPtr; pMissedFrames: IntPtr; var pLastMissedUsage: single): glBool32>(QueryFrameTrackingI3D_adr);
    private ntv_QueryFrameTrackingI3D_8 := GetProcOrNil&<function(pFrameCount: IntPtr; pMissedFrames: IntPtr; pLastMissedUsage: IntPtr): glBool32>(QueryFrameTrackingI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; pMissedFrames: array of UInt32; pLastMissedUsage: array of single): glBool32;
    type PUInt32 = ^UInt32;
    type PSingle = ^single;
    begin
      Result := if (pFrameCount<>nil) and (pFrameCount.Length<>0) then
        if (pLastMissedUsage<>nil) and (pLastMissedUsage.Length<>0) then
          if (pMissedFrames<>nil) and (pMissedFrames.Length<>0) then
            ntv_QueryFrameTrackingI3D_1(pFrameCount[0], pMissedFrames[0], pLastMissedUsage[0]) else
            ntv_QueryFrameTrackingI3D_1(pFrameCount[0], PUInt32(nil)^, pLastMissedUsage[0]) else
          if (pMissedFrames<>nil) and (pMissedFrames.Length<>0) then
            ntv_QueryFrameTrackingI3D_1(pFrameCount[0], pMissedFrames[0], PSingle(nil)^) else
            ntv_QueryFrameTrackingI3D_1(pFrameCount[0], PUInt32(nil)^, PSingle(nil)^) else
        if (pLastMissedUsage<>nil) and (pLastMissedUsage.Length<>0) then
          if (pMissedFrames<>nil) and (pMissedFrames.Length<>0) then
            ntv_QueryFrameTrackingI3D_1(PUInt32(nil)^, pMissedFrames[0], pLastMissedUsage[0]) else
            ntv_QueryFrameTrackingI3D_1(PUInt32(nil)^, PUInt32(nil)^, pLastMissedUsage[0]) else
          if (pMissedFrames<>nil) and (pMissedFrames.Length<>0) then
            ntv_QueryFrameTrackingI3D_1(PUInt32(nil)^, pMissedFrames[0], PSingle(nil)^) else
            ntv_QueryFrameTrackingI3D_1(PUInt32(nil)^, PUInt32(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; var pMissedFrames: UInt32; var pLastMissedUsage: single): glBool32 :=
      ntv_QueryFrameTrackingI3D_1(pFrameCount, pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; var pMissedFrames: UInt32; pLastMissedUsage: IntPtr): glBool32 :=
      ntv_QueryFrameTrackingI3D_2(pFrameCount, pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; pMissedFrames: IntPtr; var pLastMissedUsage: single): glBool32 :=
      ntv_QueryFrameTrackingI3D_3(pFrameCount, pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; pMissedFrames: IntPtr; pLastMissedUsage: IntPtr): glBool32 :=
      ntv_QueryFrameTrackingI3D_4(pFrameCount, pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: IntPtr; var pMissedFrames: UInt32; var pLastMissedUsage: single): glBool32 :=
      ntv_QueryFrameTrackingI3D_5(pFrameCount, pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: IntPtr; var pMissedFrames: UInt32; pLastMissedUsage: IntPtr): glBool32 :=
      ntv_QueryFrameTrackingI3D_6(pFrameCount, pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: IntPtr; pMissedFrames: IntPtr; var pLastMissedUsage: single): glBool32 :=
      ntv_QueryFrameTrackingI3D_7(pFrameCount, pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: IntPtr; pMissedFrames: IntPtr; pLastMissedUsage: IntPtr): glBool32 :=
      ntv_QueryFrameTrackingI3D_8(pFrameCount, pMissedFrames, pLastMissedUsage);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglCopyImageNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_NV_copy_image';
    
    private CopyImageSubDataNV_adr := GetProcAddress('wglCopyImageSubDataNV');
    private ntv_CopyImageSubDataNV_1 := GetProcOrNil&<function(hSrcRC: gdi_rendering_context; srcName: UInt32; srcTarget: glTextureTarget; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; hDstRC: gdi_rendering_context; dstName: UInt32; dstTarget: glTextureTarget; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32): glBool32>(CopyImageSubDataNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CopyImageSubDataNV(hSrcRC: gdi_rendering_context; srcName: UInt32; srcTarget: glTextureTarget; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; hDstRC: gdi_rendering_context; dstName: UInt32; dstTarget: glTextureTarget; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32): glBool32 :=
      ntv_CopyImageSubDataNV_1(hSrcRC, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, hDstRC, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglDelayBeforeSwapNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_NV_delay_before_swap';
    
    private DelayBeforeSwapNV_adr := GetProcAddress('wglDelayBeforeSwapNV');
    private ntv_DelayBeforeSwapNV_1 := GetProcOrNil&<function(hDC: gdi_device_context; seconds: single): glBool32>(DelayBeforeSwapNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DelayBeforeSwapNV(hDC: gdi_device_context; seconds: single): glBool32 :=
      ntv_DelayBeforeSwapNV_1(hDC, seconds);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglDXInteropNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_NV_DX_interop';
    
    private DXSetResourceShareHandleNV_adr := GetProcAddress('wglDXSetResourceShareHandleNV');
    private ntv_DXSetResourceShareHandleNV_1 := GetProcOrNil&<function(dxObject: IntPtr; shareHandle: IntPtr): glBool32>(DXSetResourceShareHandleNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXSetResourceShareHandleNV(dxObject: IntPtr; shareHandle: IntPtr): glBool32 :=
      ntv_DXSetResourceShareHandleNV_1(dxObject, shareHandle);
    
    private DXOpenDeviceNV_adr := GetProcAddress('wglDXOpenDeviceNV');
    private ntv_DXOpenDeviceNV_1 := GetProcOrNil&<function(dxDevice: IntPtr): IntPtr>(DXOpenDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXOpenDeviceNV(dxDevice: IntPtr): IntPtr :=
      ntv_DXOpenDeviceNV_1(dxDevice);
    
    private DXCloseDeviceNV_adr := GetProcAddress('wglDXCloseDeviceNV');
    private ntv_DXCloseDeviceNV_1 := GetProcOrNil&<function(hDevice: IntPtr): glBool32>(DXCloseDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXCloseDeviceNV(hDevice: IntPtr): glBool32 :=
      ntv_DXCloseDeviceNV_1(hDevice);
    
    private DXRegisterObjectNV_adr := GetProcAddress('wglDXRegisterObjectNV');
    private ntv_DXRegisterObjectNV_1 := GetProcOrNil&<function(hDevice: IntPtr; dxObject: IntPtr; name: UInt32; &type: wglObjectTypeDX; access: wglDXInteropMask): IntPtr>(DXRegisterObjectNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXRegisterObjectNV(hDevice: IntPtr; dxObject: IntPtr; name: UInt32; &type: wglObjectTypeDX; access: wglDXInteropMask): IntPtr :=
      ntv_DXRegisterObjectNV_1(hDevice, dxObject, name, &type, access);
    
    private DXUnregisterObjectNV_adr := GetProcAddress('wglDXUnregisterObjectNV');
    private ntv_DXUnregisterObjectNV_1 := GetProcOrNil&<function(hDevice: IntPtr; hObject: IntPtr): glBool32>(DXUnregisterObjectNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXUnregisterObjectNV(hDevice: IntPtr; hObject: IntPtr): glBool32 :=
      ntv_DXUnregisterObjectNV_1(hDevice, hObject);
    
    private DXObjectAccessNV_adr := GetProcAddress('wglDXObjectAccessNV');
    private ntv_DXObjectAccessNV_1 := GetProcOrNil&<function(hObject: IntPtr; access: wglDXInteropMask): glBool32>(DXObjectAccessNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXObjectAccessNV(hObject: IntPtr; access: wglDXInteropMask): glBool32 :=
      ntv_DXObjectAccessNV_1(hObject, access);
    
    private DXLockObjectsNV_adr := GetProcAddress('wglDXLockObjectsNV');
    private ntv_DXLockObjectsNV_1 := GetProcOrNil&<function(hDevice: IntPtr; count: Int32; var hObjects: IntPtr): glBool32>(DXLockObjectsNV_adr);
    private ntv_DXLockObjectsNV_2 := GetProcOrNil&<function(hDevice: IntPtr; count: Int32; hObjects: pointer): glBool32>(DXLockObjectsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXLockObjectsNV(hDevice: IntPtr; count: Int32; hObjects: array of IntPtr): glBool32;
    type PIntPtr = ^IntPtr;
    begin
      Result := if (hObjects<>nil) and (hObjects.Length<>0) then
        ntv_DXLockObjectsNV_1(hDevice, count, hObjects[0]) else
        ntv_DXLockObjectsNV_1(hDevice, count, PIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXLockObjectsNV(hDevice: IntPtr; count: Int32; var hObjects: IntPtr): glBool32 :=
      ntv_DXLockObjectsNV_1(hDevice, count, hObjects);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXLockObjectsNV(hDevice: IntPtr; count: Int32; hObjects: pointer): glBool32 :=
      ntv_DXLockObjectsNV_2(hDevice, count, hObjects);
    
    private DXUnlockObjectsNV_adr := GetProcAddress('wglDXUnlockObjectsNV');
    private ntv_DXUnlockObjectsNV_1 := GetProcOrNil&<function(hDevice: IntPtr; count: Int32; var hObjects: IntPtr): glBool32>(DXUnlockObjectsNV_adr);
    private ntv_DXUnlockObjectsNV_2 := GetProcOrNil&<function(hDevice: IntPtr; count: Int32; hObjects: pointer): glBool32>(DXUnlockObjectsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXUnlockObjectsNV(hDevice: IntPtr; count: Int32; hObjects: array of IntPtr): glBool32;
    type PIntPtr = ^IntPtr;
    begin
      Result := if (hObjects<>nil) and (hObjects.Length<>0) then
        ntv_DXUnlockObjectsNV_1(hDevice, count, hObjects[0]) else
        ntv_DXUnlockObjectsNV_1(hDevice, count, PIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXUnlockObjectsNV(hDevice: IntPtr; count: Int32; var hObjects: IntPtr): glBool32 :=
      ntv_DXUnlockObjectsNV_1(hDevice, count, hObjects);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXUnlockObjectsNV(hDevice: IntPtr; count: Int32; hObjects: pointer): glBool32 :=
      ntv_DXUnlockObjectsNV_2(hDevice, count, hObjects);
    
  end;
  
  ///
  wglDXInterop2NV = static class
    public const _ExtStr = 'WGL_NV_DX_interop2';
  end;
  
  ///
  wglFloatBufferNV = static class
    public const _ExtStr = 'WGL_NV_float_buffer';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglGpuAffinityNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_NV_gpu_affinity';
    
    private EnumGpusNV_adr := GetProcAddress('wglEnumGpusNV');
    private ntv_EnumGpusNV_1 := GetProcOrNil&<function(iGpuIndex: UInt32; var phGpu: wgl_gpu_NV): glBool32>(EnumGpusNV_adr);
    private ntv_EnumGpusNV_2 := GetProcOrNil&<function(iGpuIndex: UInt32; phGpu: IntPtr): glBool32>(EnumGpusNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusNV(iGpuIndex: UInt32; phGpu: array of wgl_gpu_NV): glBool32;
    type PWgl_gpu_NV = ^wgl_gpu_NV;
    begin
      Result := if (phGpu<>nil) and (phGpu.Length<>0) then
        ntv_EnumGpusNV_1(iGpuIndex, phGpu[0]) else
        ntv_EnumGpusNV_1(iGpuIndex, PWgl_gpu_NV(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusNV(iGpuIndex: UInt32; var phGpu: wgl_gpu_NV): glBool32 :=
      ntv_EnumGpusNV_1(iGpuIndex, phGpu);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusNV(iGpuIndex: UInt32; phGpu: IntPtr): glBool32 :=
      ntv_EnumGpusNV_2(iGpuIndex, phGpu);
    
    private EnumGpuDevicesNV_adr := GetProcAddress('wglEnumGpuDevicesNV');
    private ntv_EnumGpuDevicesNV_1 := GetProcOrNil&<function(hGpu: wgl_gpu_NV; iDeviceIndex: UInt32; var lpGpuDevice: wgl_gpu_device_NV): glBool32>(EnumGpuDevicesNV_adr);
    private ntv_EnumGpuDevicesNV_2 := GetProcOrNil&<function(hGpu: wgl_gpu_NV; iDeviceIndex: UInt32; lpGpuDevice: IntPtr): glBool32>(EnumGpuDevicesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpuDevicesNV(hGpu: wgl_gpu_NV; iDeviceIndex: UInt32; lpGpuDevice: array of wgl_gpu_device_NV): glBool32;
    type PWgl_gpu_device_NV = ^wgl_gpu_device_NV;
    begin
      Result := if (lpGpuDevice<>nil) and (lpGpuDevice.Length<>0) then
        ntv_EnumGpuDevicesNV_1(hGpu, iDeviceIndex, lpGpuDevice[0]) else
        ntv_EnumGpuDevicesNV_1(hGpu, iDeviceIndex, PWgl_gpu_device_NV(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpuDevicesNV(hGpu: wgl_gpu_NV; iDeviceIndex: UInt32; var lpGpuDevice: wgl_gpu_device_NV): glBool32 :=
      ntv_EnumGpuDevicesNV_1(hGpu, iDeviceIndex, lpGpuDevice);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpuDevicesNV(hGpu: wgl_gpu_NV; iDeviceIndex: UInt32; lpGpuDevice: IntPtr): glBool32 :=
      ntv_EnumGpuDevicesNV_2(hGpu, iDeviceIndex, lpGpuDevice);
    
    private CreateAffinityDCNV_adr := GetProcAddress('wglCreateAffinityDCNV');
    private ntv_CreateAffinityDCNV_1 := GetProcOrNil&<function(var phGpuList: wgl_gpu_NV): gdi_device_context>(CreateAffinityDCNV_adr);
    private ntv_CreateAffinityDCNV_2 := GetProcOrNil&<function(phGpuList: IntPtr): gdi_device_context>(CreateAffinityDCNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAffinityDCNV(phGpuList: array of wgl_gpu_NV): gdi_device_context;
    type PWgl_gpu_NV = ^wgl_gpu_NV;
    begin
      Result := if (phGpuList<>nil) and (phGpuList.Length<>0) then
        ntv_CreateAffinityDCNV_1(phGpuList[0]) else
        ntv_CreateAffinityDCNV_1(PWgl_gpu_NV(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAffinityDCNV(var phGpuList: wgl_gpu_NV): gdi_device_context :=
      ntv_CreateAffinityDCNV_1(phGpuList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAffinityDCNV(phGpuList: IntPtr): gdi_device_context :=
      ntv_CreateAffinityDCNV_2(phGpuList);
    
    private EnumGpusFromAffinityDCNV_adr := GetProcAddress('wglEnumGpusFromAffinityDCNV');
    private ntv_EnumGpusFromAffinityDCNV_1 := GetProcOrNil&<function(hAffinityDC: gdi_device_context; iGpuIndex: UInt32; var hGpu: wgl_gpu_NV): glBool32>(EnumGpusFromAffinityDCNV_adr);
    private ntv_EnumGpusFromAffinityDCNV_2 := GetProcOrNil&<function(hAffinityDC: gdi_device_context; iGpuIndex: UInt32; hGpu: IntPtr): glBool32>(EnumGpusFromAffinityDCNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusFromAffinityDCNV(hAffinityDC: gdi_device_context; iGpuIndex: UInt32; hGpu: array of wgl_gpu_NV): glBool32;
    type PWgl_gpu_NV = ^wgl_gpu_NV;
    begin
      Result := if (hGpu<>nil) and (hGpu.Length<>0) then
        ntv_EnumGpusFromAffinityDCNV_1(hAffinityDC, iGpuIndex, hGpu[0]) else
        ntv_EnumGpusFromAffinityDCNV_1(hAffinityDC, iGpuIndex, PWgl_gpu_NV(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusFromAffinityDCNV(hAffinityDC: gdi_device_context; iGpuIndex: UInt32; var hGpu: wgl_gpu_NV): glBool32 :=
      ntv_EnumGpusFromAffinityDCNV_1(hAffinityDC, iGpuIndex, hGpu);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusFromAffinityDCNV(hAffinityDC: gdi_device_context; iGpuIndex: UInt32; hGpu: IntPtr): glBool32 :=
      ntv_EnumGpusFromAffinityDCNV_2(hAffinityDC, iGpuIndex, hGpu);
    
    private DeleteDCNV_adr := GetProcAddress('wglDeleteDCNV');
    private ntv_DeleteDCNV_1 := GetProcOrNil&<function(hdc: gdi_device_context): glBool32>(DeleteDCNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DeleteDCNV(hdc: gdi_device_context): glBool32 :=
      ntv_DeleteDCNV_1(hdc);
    
  end;
  
  ///
  wglMultigpuContextNV = static class
    public const _ExtStr = 'WGL_NV_multigpu_context';
  end;
  
  ///
  wglMultisampleCoverageNV = static class
    public const _ExtStr = 'WGL_NV_multisample_coverage';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglPresentVideoNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_NV_present_video';
    
    private EnumerateVideoDevicesNV_adr := GetProcAddress('wglEnumerateVideoDevicesNV');
    private ntv_EnumerateVideoDevicesNV_1 := GetProcOrNil&<function(hDc: gdi_device_context; var phDeviceList: wgl_video_output_device_handle_NV): Int32>(EnumerateVideoDevicesNV_adr);
    private ntv_EnumerateVideoDevicesNV_2 := GetProcOrNil&<function(hDc: gdi_device_context; phDeviceList: IntPtr): Int32>(EnumerateVideoDevicesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(hDc: gdi_device_context; phDeviceList: array of wgl_video_output_device_handle_NV): Int32;
    type PWgl_video_output_device_handle_NV = ^wgl_video_output_device_handle_NV;
    begin
      Result := if (phDeviceList<>nil) and (phDeviceList.Length<>0) then
        ntv_EnumerateVideoDevicesNV_1(hDc, phDeviceList[0]) else
        ntv_EnumerateVideoDevicesNV_1(hDc, PWgl_video_output_device_handle_NV(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(hDc: gdi_device_context; var phDeviceList: wgl_video_output_device_handle_NV): Int32 :=
      ntv_EnumerateVideoDevicesNV_1(hDc, phDeviceList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(hDc: gdi_device_context; phDeviceList: IntPtr): Int32 :=
      ntv_EnumerateVideoDevicesNV_2(hDc, phDeviceList);
    
    private BindVideoDeviceNV_adr := GetProcAddress('wglBindVideoDeviceNV');
    private ntv_BindVideoDeviceNV_1 := GetProcOrNil&<function(hDc: gdi_device_context; uVideoSlot: UInt32; hVideoDevice: wgl_video_output_device_handle_NV; var piAttribList: Int32): glBool32>(BindVideoDeviceNV_adr);
    private ntv_BindVideoDeviceNV_2 := GetProcOrNil&<function(hDc: gdi_device_context; uVideoSlot: UInt32; hVideoDevice: wgl_video_output_device_handle_NV; piAttribList: IntPtr): glBool32>(BindVideoDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(hDc: gdi_device_context; uVideoSlot: UInt32; hVideoDevice: wgl_video_output_device_handle_NV; piAttribList: array of Int32): glBool32;
    type PInt32 = ^Int32;
    begin
      Result := if (piAttribList<>nil) and (piAttribList.Length<>0) then
        ntv_BindVideoDeviceNV_1(hDc, uVideoSlot, hVideoDevice, piAttribList[0]) else
        ntv_BindVideoDeviceNV_1(hDc, uVideoSlot, hVideoDevice, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(hDc: gdi_device_context; uVideoSlot: UInt32; hVideoDevice: wgl_video_output_device_handle_NV; var piAttribList: Int32): glBool32 :=
      ntv_BindVideoDeviceNV_1(hDc, uVideoSlot, hVideoDevice, piAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(hDc: gdi_device_context; uVideoSlot: UInt32; hVideoDevice: wgl_video_output_device_handle_NV; piAttribList: IntPtr): glBool32 :=
      ntv_BindVideoDeviceNV_2(hDc, uVideoSlot, hVideoDevice, piAttribList);
    
    private QueryCurrentContextNV_adr := GetProcAddress('wglQueryCurrentContextNV');
    private ntv_QueryCurrentContextNV_1 := GetProcOrNil&<function(iAttribute: wglContextAttribute; var piValue: Int32): glBool32>(QueryCurrentContextNV_adr);
    private ntv_QueryCurrentContextNV_2 := GetProcOrNil&<function(iAttribute: wglContextAttribute; piValue: IntPtr): glBool32>(QueryCurrentContextNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentContextNV(iAttribute: wglContextAttribute; piValue: array of Int32): glBool32;
    type PInt32 = ^Int32;
    begin
      Result := if (piValue<>nil) and (piValue.Length<>0) then
        ntv_QueryCurrentContextNV_1(iAttribute, piValue[0]) else
        ntv_QueryCurrentContextNV_1(iAttribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentContextNV(iAttribute: wglContextAttribute; var piValue: Int32): glBool32 :=
      ntv_QueryCurrentContextNV_1(iAttribute, piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentContextNV(iAttribute: wglContextAttribute; piValue: IntPtr): glBool32 :=
      ntv_QueryCurrentContextNV_2(iAttribute, piValue);
    
  end;
  
  ///
  wglRenderDepthTextureNV = static class
    public const _ExtStr = 'WGL_NV_render_depth_texture';
  end;
  
  ///
  wglRenderTextureRectangleNV = static class
    public const _ExtStr = 'WGL_NV_render_texture_rectangle';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglSwapGroupNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_NV_swap_group';
    
    private JoinSwapGroupNV_adr := GetProcAddress('wglJoinSwapGroupNV');
    private ntv_JoinSwapGroupNV_1 := GetProcOrNil&<function(hDC: gdi_device_context; group: UInt32): glBool32>(JoinSwapGroupNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function JoinSwapGroupNV(hDC: gdi_device_context; group: UInt32): glBool32 :=
      ntv_JoinSwapGroupNV_1(hDC, group);
    
    private BindSwapBarrierNV_adr := GetProcAddress('wglBindSwapBarrierNV');
    private ntv_BindSwapBarrierNV_1 := GetProcOrNil&<function(group: UInt32; barrier: UInt32): glBool32>(BindSwapBarrierNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindSwapBarrierNV(group: UInt32; barrier: UInt32): glBool32 :=
      ntv_BindSwapBarrierNV_1(group, barrier);
    
    private QuerySwapGroupNV_adr := GetProcAddress('wglQuerySwapGroupNV');
    private ntv_QuerySwapGroupNV_1 := GetProcOrNil&<function(hDC: gdi_device_context; var group: UInt32; var barrier: UInt32): glBool32>(QuerySwapGroupNV_adr);
    private ntv_QuerySwapGroupNV_2 := GetProcOrNil&<function(hDC: gdi_device_context; var group: UInt32; barrier: IntPtr): glBool32>(QuerySwapGroupNV_adr);
    private ntv_QuerySwapGroupNV_3 := GetProcOrNil&<function(hDC: gdi_device_context; group: IntPtr; var barrier: UInt32): glBool32>(QuerySwapGroupNV_adr);
    private ntv_QuerySwapGroupNV_4 := GetProcOrNil&<function(hDC: gdi_device_context; group: IntPtr; barrier: IntPtr): glBool32>(QuerySwapGroupNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: gdi_device_context; group: array of UInt32; barrier: array of UInt32): glBool32;
    type PUInt32 = ^UInt32;
    begin
      Result := if (barrier<>nil) and (barrier.Length<>0) then
        if (group<>nil) and (group.Length<>0) then
          ntv_QuerySwapGroupNV_1(hDC, group[0], barrier[0]) else
          ntv_QuerySwapGroupNV_1(hDC, PUInt32(nil)^, barrier[0]) else
        if (group<>nil) and (group.Length<>0) then
          ntv_QuerySwapGroupNV_1(hDC, group[0], PUInt32(nil)^) else
          ntv_QuerySwapGroupNV_1(hDC, PUInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: gdi_device_context; var group: UInt32; var barrier: UInt32): glBool32 :=
      ntv_QuerySwapGroupNV_1(hDC, group, barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: gdi_device_context; var group: UInt32; barrier: IntPtr): glBool32 :=
      ntv_QuerySwapGroupNV_2(hDC, group, barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: gdi_device_context; group: IntPtr; var barrier: UInt32): glBool32 :=
      ntv_QuerySwapGroupNV_3(hDC, group, barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: gdi_device_context; group: IntPtr; barrier: IntPtr): glBool32 :=
      ntv_QuerySwapGroupNV_4(hDC, group, barrier);
    
    private QueryMaxSwapGroupsNV_adr := GetProcAddress('wglQueryMaxSwapGroupsNV');
    private ntv_QueryMaxSwapGroupsNV_1 := GetProcOrNil&<function(hDC: gdi_device_context; var maxGroups: UInt32; var maxBarriers: UInt32): glBool32>(QueryMaxSwapGroupsNV_adr);
    private ntv_QueryMaxSwapGroupsNV_2 := GetProcOrNil&<function(hDC: gdi_device_context; var maxGroups: UInt32; maxBarriers: IntPtr): glBool32>(QueryMaxSwapGroupsNV_adr);
    private ntv_QueryMaxSwapGroupsNV_3 := GetProcOrNil&<function(hDC: gdi_device_context; maxGroups: IntPtr; var maxBarriers: UInt32): glBool32>(QueryMaxSwapGroupsNV_adr);
    private ntv_QueryMaxSwapGroupsNV_4 := GetProcOrNil&<function(hDC: gdi_device_context; maxGroups: IntPtr; maxBarriers: IntPtr): glBool32>(QueryMaxSwapGroupsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: gdi_device_context; maxGroups: array of UInt32; maxBarriers: array of UInt32): glBool32;
    type PUInt32 = ^UInt32;
    begin
      Result := if (maxBarriers<>nil) and (maxBarriers.Length<>0) then
        if (maxGroups<>nil) and (maxGroups.Length<>0) then
          ntv_QueryMaxSwapGroupsNV_1(hDC, maxGroups[0], maxBarriers[0]) else
          ntv_QueryMaxSwapGroupsNV_1(hDC, PUInt32(nil)^, maxBarriers[0]) else
        if (maxGroups<>nil) and (maxGroups.Length<>0) then
          ntv_QueryMaxSwapGroupsNV_1(hDC, maxGroups[0], PUInt32(nil)^) else
          ntv_QueryMaxSwapGroupsNV_1(hDC, PUInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: gdi_device_context; var maxGroups: UInt32; var maxBarriers: UInt32): glBool32 :=
      ntv_QueryMaxSwapGroupsNV_1(hDC, maxGroups, maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: gdi_device_context; var maxGroups: UInt32; maxBarriers: IntPtr): glBool32 :=
      ntv_QueryMaxSwapGroupsNV_2(hDC, maxGroups, maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: gdi_device_context; maxGroups: IntPtr; var maxBarriers: UInt32): glBool32 :=
      ntv_QueryMaxSwapGroupsNV_3(hDC, maxGroups, maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: gdi_device_context; maxGroups: IntPtr; maxBarriers: IntPtr): glBool32 :=
      ntv_QueryMaxSwapGroupsNV_4(hDC, maxGroups, maxBarriers);
    
    private QueryFrameCountNV_adr := GetProcAddress('wglQueryFrameCountNV');
    private ntv_QueryFrameCountNV_1 := GetProcOrNil&<function(hDC: gdi_device_context; var count: UInt32): glBool32>(QueryFrameCountNV_adr);
    private ntv_QueryFrameCountNV_2 := GetProcOrNil&<function(hDC: gdi_device_context; count: IntPtr): glBool32>(QueryFrameCountNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(hDC: gdi_device_context; count: array of UInt32): glBool32;
    type PUInt32 = ^UInt32;
    begin
      Result := if (count<>nil) and (count.Length<>0) then
        ntv_QueryFrameCountNV_1(hDC, count[0]) else
        ntv_QueryFrameCountNV_1(hDC, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(hDC: gdi_device_context; var count: UInt32): glBool32 :=
      ntv_QueryFrameCountNV_1(hDC, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(hDC: gdi_device_context; count: IntPtr): glBool32 :=
      ntv_QueryFrameCountNV_2(hDC, count);
    
    private ResetFrameCountNV_adr := GetProcAddress('wglResetFrameCountNV');
    private ntv_ResetFrameCountNV_1 := GetProcOrNil&<function(hDC: gdi_device_context): glBool32>(ResetFrameCountNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ResetFrameCountNV(hDC: gdi_device_context): glBool32 :=
      ntv_ResetFrameCountNV_1(hDC);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglVertexArrayRangeNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_NV_vertex_array_range';
    
    private AllocateMemoryNV_adr := GetProcAddress('wglAllocateMemoryNV');
    private ntv_AllocateMemoryNV_1 := GetProcOrNil&<function(size: Int32; readfreq: single; writefreq: single; priority: single): IntPtr>(AllocateMemoryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AllocateMemoryNV(size: Int32; readfreq: single; writefreq: single; priority: single): IntPtr :=
      ntv_AllocateMemoryNV_1(size, readfreq, writefreq, priority);
    
    private FreeMemoryNV_adr := GetProcAddress('wglFreeMemoryNV');
    private ntv_FreeMemoryNV_1 := GetProcOrNil&<procedure(pointer: IntPtr)>(FreeMemoryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FreeMemoryNV(pointer: IntPtr) :=
      ntv_FreeMemoryNV_1(pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglVideoCaptureNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_NV_video_capture';
    
    private BindVideoCaptureDeviceNV_adr := GetProcAddress('wglBindVideoCaptureDeviceNV');
    private ntv_BindVideoCaptureDeviceNV_1 := GetProcOrNil&<function(uVideoSlot: UInt32; hDevice: wgl_video_input_device_handle_NV): glBool32>(BindVideoCaptureDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoCaptureDeviceNV(uVideoSlot: UInt32; hDevice: wgl_video_input_device_handle_NV): glBool32 :=
      ntv_BindVideoCaptureDeviceNV_1(uVideoSlot, hDevice);
    
    private EnumerateVideoCaptureDevicesNV_adr := GetProcAddress('wglEnumerateVideoCaptureDevicesNV');
    private ntv_EnumerateVideoCaptureDevicesNV_1 := GetProcOrNil&<function(hDc: gdi_device_context; var phDeviceList: wgl_video_input_device_handle_NV): UInt32>(EnumerateVideoCaptureDevicesNV_adr);
    private ntv_EnumerateVideoCaptureDevicesNV_2 := GetProcOrNil&<function(hDc: gdi_device_context; phDeviceList: IntPtr): UInt32>(EnumerateVideoCaptureDevicesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(hDc: gdi_device_context; phDeviceList: array of wgl_video_input_device_handle_NV): UInt32;
    type PWgl_video_input_device_handle_NV = ^wgl_video_input_device_handle_NV;
    begin
      Result := if (phDeviceList<>nil) and (phDeviceList.Length<>0) then
        ntv_EnumerateVideoCaptureDevicesNV_1(hDc, phDeviceList[0]) else
        ntv_EnumerateVideoCaptureDevicesNV_1(hDc, PWgl_video_input_device_handle_NV(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(hDc: gdi_device_context; var phDeviceList: wgl_video_input_device_handle_NV): UInt32 :=
      ntv_EnumerateVideoCaptureDevicesNV_1(hDc, phDeviceList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(hDc: gdi_device_context; phDeviceList: IntPtr): UInt32 :=
      ntv_EnumerateVideoCaptureDevicesNV_2(hDc, phDeviceList);
    
    private LockVideoCaptureDeviceNV_adr := GetProcAddress('wglLockVideoCaptureDeviceNV');
    private ntv_LockVideoCaptureDeviceNV_1 := GetProcOrNil&<function(hDc: gdi_device_context; hDevice: wgl_video_input_device_handle_NV): glBool32>(LockVideoCaptureDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function LockVideoCaptureDeviceNV(hDc: gdi_device_context; hDevice: wgl_video_input_device_handle_NV): glBool32 :=
      ntv_LockVideoCaptureDeviceNV_1(hDc, hDevice);
    
    private QueryVideoCaptureDeviceNV_adr := GetProcAddress('wglQueryVideoCaptureDeviceNV');
    private ntv_QueryVideoCaptureDeviceNV_1 := GetProcOrNil&<function(hDc: gdi_device_context; hDevice: wgl_video_input_device_handle_NV; iAttribute: wglVideoCaptureDeviceAttribute; var piValue: Int32): glBool32>(QueryVideoCaptureDeviceNV_adr);
    private ntv_QueryVideoCaptureDeviceNV_2 := GetProcOrNil&<function(hDc: gdi_device_context; hDevice: wgl_video_input_device_handle_NV; iAttribute: wglVideoCaptureDeviceAttribute; piValue: IntPtr): glBool32>(QueryVideoCaptureDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(hDc: gdi_device_context; hDevice: wgl_video_input_device_handle_NV; iAttribute: wglVideoCaptureDeviceAttribute; piValue: array of Int32): glBool32;
    type PInt32 = ^Int32;
    begin
      Result := if (piValue<>nil) and (piValue.Length<>0) then
        ntv_QueryVideoCaptureDeviceNV_1(hDc, hDevice, iAttribute, piValue[0]) else
        ntv_QueryVideoCaptureDeviceNV_1(hDc, hDevice, iAttribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(hDc: gdi_device_context; hDevice: wgl_video_input_device_handle_NV; iAttribute: wglVideoCaptureDeviceAttribute; var piValue: Int32): glBool32 :=
      ntv_QueryVideoCaptureDeviceNV_1(hDc, hDevice, iAttribute, piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(hDc: gdi_device_context; hDevice: wgl_video_input_device_handle_NV; iAttribute: wglVideoCaptureDeviceAttribute; piValue: IntPtr): glBool32 :=
      ntv_QueryVideoCaptureDeviceNV_2(hDc, hDevice, iAttribute, piValue);
    
    private ReleaseVideoCaptureDeviceNV_adr := GetProcAddress('wglReleaseVideoCaptureDeviceNV');
    private ntv_ReleaseVideoCaptureDeviceNV_1 := GetProcOrNil&<function(hDc: gdi_device_context; hDevice: wgl_video_input_device_handle_NV): glBool32>(ReleaseVideoCaptureDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseVideoCaptureDeviceNV(hDc: gdi_device_context; hDevice: wgl_video_input_device_handle_NV): glBool32 :=
      ntv_ReleaseVideoCaptureDeviceNV_1(hDc, hDevice);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglVideoOutputNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_NV_video_output';
    
    private GetVideoDeviceNV_adr := GetProcAddress('wglGetVideoDeviceNV');
    private ntv_GetVideoDeviceNV_1 := GetProcOrNil&<function(hDC: gdi_device_context; numDevices: Int32; var hVideoDevice: wgl_video_device_NV): glBool32>(GetVideoDeviceNV_adr);
    private ntv_GetVideoDeviceNV_2 := GetProcOrNil&<function(hDC: gdi_device_context; numDevices: Int32; hVideoDevice: IntPtr): glBool32>(GetVideoDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoDeviceNV(hDC: gdi_device_context; numDevices: Int32; var hVideoDevice: wgl_video_device_NV): glBool32 :=
      ntv_GetVideoDeviceNV_1(hDC, numDevices, hVideoDevice);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoDeviceNV(hDC: gdi_device_context; numDevices: Int32; hVideoDevice: IntPtr): glBool32 :=
      ntv_GetVideoDeviceNV_2(hDC, numDevices, hVideoDevice);
    
    private ReleaseVideoDeviceNV_adr := GetProcAddress('wglReleaseVideoDeviceNV');
    private ntv_ReleaseVideoDeviceNV_1 := GetProcOrNil&<function(hVideoDevice: wgl_video_device_NV): glBool32>(ReleaseVideoDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseVideoDeviceNV(hVideoDevice: wgl_video_device_NV): glBool32 :=
      ntv_ReleaseVideoDeviceNV_1(hVideoDevice);
    
    private BindVideoImageNV_adr := GetProcAddress('wglBindVideoImageNV');
    private ntv_BindVideoImageNV_1 := GetProcOrNil&<function(hVideoDevice: wgl_video_device_NV; hPbuffer: wgl_pixel_buffer; iVideoBuffer: wglVideoOutputBuffer): glBool32>(BindVideoImageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoImageNV(hVideoDevice: wgl_video_device_NV; hPbuffer: wgl_pixel_buffer; iVideoBuffer: wglVideoOutputBuffer): glBool32 :=
      ntv_BindVideoImageNV_1(hVideoDevice, hPbuffer, iVideoBuffer);
    
    private ReleaseVideoImageNV_adr := GetProcAddress('wglReleaseVideoImageNV');
    private ntv_ReleaseVideoImageNV_1 := GetProcOrNil&<function(hPbuffer: wgl_pixel_buffer; iVideoBuffer: wglVideoOutputBuffer): glBool32>(ReleaseVideoImageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseVideoImageNV(hPbuffer: wgl_pixel_buffer; iVideoBuffer: wglVideoOutputBuffer): glBool32 :=
      ntv_ReleaseVideoImageNV_1(hPbuffer, iVideoBuffer);
    
    private SendPbufferToVideoNV_adr := GetProcAddress('wglSendPbufferToVideoNV');
    private ntv_SendPbufferToVideoNV_1 := GetProcOrNil&<function(hPbuffer: wgl_pixel_buffer; iBufferType: wglVideoOutputBufferType; var pulCounterPbuffer: UInt32; bBlock: glBool32): glBool32>(SendPbufferToVideoNV_adr);
    private ntv_SendPbufferToVideoNV_2 := GetProcOrNil&<function(hPbuffer: wgl_pixel_buffer; iBufferType: wglVideoOutputBufferType; pulCounterPbuffer: IntPtr; bBlock: glBool32): glBool32>(SendPbufferToVideoNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(hPbuffer: wgl_pixel_buffer; iBufferType: wglVideoOutputBufferType; pulCounterPbuffer: array of UInt32; bBlock: glBool32): glBool32;
    type PUInt32 = ^UInt32;
    begin
      Result := if (pulCounterPbuffer<>nil) and (pulCounterPbuffer.Length<>0) then
        ntv_SendPbufferToVideoNV_1(hPbuffer, iBufferType, pulCounterPbuffer[0], bBlock) else
        ntv_SendPbufferToVideoNV_1(hPbuffer, iBufferType, PUInt32(nil)^, bBlock);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(hPbuffer: wgl_pixel_buffer; iBufferType: wglVideoOutputBufferType; var pulCounterPbuffer: UInt32; bBlock: glBool32): glBool32 :=
      ntv_SendPbufferToVideoNV_1(hPbuffer, iBufferType, pulCounterPbuffer, bBlock);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(hPbuffer: wgl_pixel_buffer; iBufferType: wglVideoOutputBufferType; pulCounterPbuffer: IntPtr; bBlock: glBool32): glBool32 :=
      ntv_SendPbufferToVideoNV_2(hPbuffer, iBufferType, pulCounterPbuffer, bBlock);
    
    private GetVideoInfoNV_adr := GetProcAddress('wglGetVideoInfoNV');
    private ntv_GetVideoInfoNV_1 := GetProcOrNil&<function(hpVideoDevice: wgl_video_device_NV; var pulCounterOutputPbuffer: UInt32; var pulCounterOutputVideo: UInt32): glBool32>(GetVideoInfoNV_adr);
    private ntv_GetVideoInfoNV_2 := GetProcOrNil&<function(hpVideoDevice: wgl_video_device_NV; var pulCounterOutputPbuffer: UInt32; pulCounterOutputVideo: IntPtr): glBool32>(GetVideoInfoNV_adr);
    private ntv_GetVideoInfoNV_3 := GetProcOrNil&<function(hpVideoDevice: wgl_video_device_NV; pulCounterOutputPbuffer: IntPtr; var pulCounterOutputVideo: UInt32): glBool32>(GetVideoInfoNV_adr);
    private ntv_GetVideoInfoNV_4 := GetProcOrNil&<function(hpVideoDevice: wgl_video_device_NV; pulCounterOutputPbuffer: IntPtr; pulCounterOutputVideo: IntPtr): glBool32>(GetVideoInfoNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(hpVideoDevice: wgl_video_device_NV; var pulCounterOutputPbuffer: UInt32; var pulCounterOutputVideo: UInt32): glBool32 :=
      ntv_GetVideoInfoNV_1(hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(hpVideoDevice: wgl_video_device_NV; var pulCounterOutputPbuffer: UInt32; pulCounterOutputVideo: IntPtr): glBool32 :=
      ntv_GetVideoInfoNV_2(hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(hpVideoDevice: wgl_video_device_NV; pulCounterOutputPbuffer: IntPtr; var pulCounterOutputVideo: UInt32): glBool32 :=
      ntv_GetVideoInfoNV_3(hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(hpVideoDevice: wgl_video_device_NV; pulCounterOutputPbuffer: IntPtr; pulCounterOutputVideo: IntPtr): glBool32 :=
      ntv_GetVideoInfoNV_4(hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wglSyncControlOML = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'WGL_OML_sync_control';
    
    private GetSyncValuesOML_adr := GetProcAddress('wglGetSyncValuesOML');
    private ntv_GetSyncValuesOML_1 := GetProcOrNil&<function(hdc: gdi_device_context; var ust: Int64; var msc: Int64; var sbc: Int64): glBool32>(GetSyncValuesOML_adr);
    private ntv_GetSyncValuesOML_2 := GetProcOrNil&<function(hdc: gdi_device_context; var ust: Int64; var msc: Int64; sbc: IntPtr): glBool32>(GetSyncValuesOML_adr);
    private ntv_GetSyncValuesOML_3 := GetProcOrNil&<function(hdc: gdi_device_context; var ust: Int64; msc: IntPtr; var sbc: Int64): glBool32>(GetSyncValuesOML_adr);
    private ntv_GetSyncValuesOML_4 := GetProcOrNil&<function(hdc: gdi_device_context; var ust: Int64; msc: IntPtr; sbc: IntPtr): glBool32>(GetSyncValuesOML_adr);
    private ntv_GetSyncValuesOML_5 := GetProcOrNil&<function(hdc: gdi_device_context; ust: IntPtr; var msc: Int64; var sbc: Int64): glBool32>(GetSyncValuesOML_adr);
    private ntv_GetSyncValuesOML_6 := GetProcOrNil&<function(hdc: gdi_device_context; ust: IntPtr; var msc: Int64; sbc: IntPtr): glBool32>(GetSyncValuesOML_adr);
    private ntv_GetSyncValuesOML_7 := GetProcOrNil&<function(hdc: gdi_device_context; ust: IntPtr; msc: IntPtr; var sbc: Int64): glBool32>(GetSyncValuesOML_adr);
    private ntv_GetSyncValuesOML_8 := GetProcOrNil&<function(hdc: gdi_device_context; ust: IntPtr; msc: IntPtr; sbc: IntPtr): glBool32>(GetSyncValuesOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: gdi_device_context; var ust: Int64; var msc: Int64; var sbc: Int64): glBool32 :=
      ntv_GetSyncValuesOML_1(hdc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: gdi_device_context; var ust: Int64; var msc: Int64; sbc: IntPtr): glBool32 :=
      ntv_GetSyncValuesOML_2(hdc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: gdi_device_context; var ust: Int64; msc: IntPtr; var sbc: Int64): glBool32 :=
      ntv_GetSyncValuesOML_3(hdc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: gdi_device_context; var ust: Int64; msc: IntPtr; sbc: IntPtr): glBool32 :=
      ntv_GetSyncValuesOML_4(hdc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: gdi_device_context; ust: IntPtr; var msc: Int64; var sbc: Int64): glBool32 :=
      ntv_GetSyncValuesOML_5(hdc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: gdi_device_context; ust: IntPtr; var msc: Int64; sbc: IntPtr): glBool32 :=
      ntv_GetSyncValuesOML_6(hdc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: gdi_device_context; ust: IntPtr; msc: IntPtr; var sbc: Int64): glBool32 :=
      ntv_GetSyncValuesOML_7(hdc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: gdi_device_context; ust: IntPtr; msc: IntPtr; sbc: IntPtr): glBool32 :=
      ntv_GetSyncValuesOML_8(hdc, ust, msc, sbc);
    
    private GetMscRateOML_adr := GetProcAddress('wglGetMscRateOML');
    private ntv_GetMscRateOML_1 := GetProcOrNil&<function(hdc: gdi_device_context; var numerator: Int32; var denominator: Int32): glBool32>(GetMscRateOML_adr);
    private ntv_GetMscRateOML_2 := GetProcOrNil&<function(hdc: gdi_device_context; var numerator: Int32; denominator: IntPtr): glBool32>(GetMscRateOML_adr);
    private ntv_GetMscRateOML_3 := GetProcOrNil&<function(hdc: gdi_device_context; numerator: IntPtr; var denominator: Int32): glBool32>(GetMscRateOML_adr);
    private ntv_GetMscRateOML_4 := GetProcOrNil&<function(hdc: gdi_device_context; numerator: IntPtr; denominator: IntPtr): glBool32>(GetMscRateOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(hdc: gdi_device_context; var numerator: Int32; var denominator: Int32): glBool32 :=
      ntv_GetMscRateOML_1(hdc, numerator, denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(hdc: gdi_device_context; var numerator: Int32; denominator: IntPtr): glBool32 :=
      ntv_GetMscRateOML_2(hdc, numerator, denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(hdc: gdi_device_context; numerator: IntPtr; var denominator: Int32): glBool32 :=
      ntv_GetMscRateOML_3(hdc, numerator, denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(hdc: gdi_device_context; numerator: IntPtr; denominator: IntPtr): glBool32 :=
      ntv_GetMscRateOML_4(hdc, numerator, denominator);
    
    private SwapBuffersMscOML_adr := GetProcAddress('wglSwapBuffersMscOML');
    private ntv_SwapBuffersMscOML_1 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64): Int64>(SwapBuffersMscOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapBuffersMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64): Int64 :=
      ntv_SwapBuffersMscOML_1(hdc, target_msc, divisor, remainder);
    
    private SwapLayerBuffersMscOML_adr := GetProcAddress('wglSwapLayerBuffersMscOML');
    private ntv_SwapLayerBuffersMscOML_1 := GetProcOrNil&<function(hdc: gdi_device_context; fuPlanes: wglLayerPlaneMask; target_msc: Int64; divisor: Int64; remainder: Int64): Int64>(SwapLayerBuffersMscOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapLayerBuffersMscOML(hdc: gdi_device_context; fuPlanes: wglLayerPlaneMask; target_msc: Int64; divisor: Int64; remainder: Int64): Int64 :=
      ntv_SwapLayerBuffersMscOML_1(hdc, fuPlanes, target_msc, divisor, remainder);
    
    private WaitForMscOML_adr := GetProcAddress('wglWaitForMscOML');
    private ntv_WaitForMscOML_1 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): glBool32>(WaitForMscOML_adr);
    private ntv_WaitForMscOML_2 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; sbc: IntPtr): glBool32>(WaitForMscOML_adr);
    private ntv_WaitForMscOML_3 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: IntPtr; var sbc: Int64): glBool32>(WaitForMscOML_adr);
    private ntv_WaitForMscOML_4 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: IntPtr; sbc: IntPtr): glBool32>(WaitForMscOML_adr);
    private ntv_WaitForMscOML_5 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; var msc: Int64; var sbc: Int64): glBool32>(WaitForMscOML_adr);
    private ntv_WaitForMscOML_6 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; var msc: Int64; sbc: IntPtr): glBool32>(WaitForMscOML_adr);
    private ntv_WaitForMscOML_7 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; msc: IntPtr; var sbc: Int64): glBool32>(WaitForMscOML_adr);
    private ntv_WaitForMscOML_8 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; msc: IntPtr; sbc: IntPtr): glBool32>(WaitForMscOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: array of Int64; sbc: array of Int64): glBool32;
    type PInt64 = ^Int64;
    begin
      Result := if (sbc<>nil) and (sbc.Length<>0) then
        if (ust<>nil) and (ust.Length<>0) then
          if (msc<>nil) and (msc.Length<>0) then
            ntv_WaitForMscOML_1(hdc, target_msc, divisor, remainder, ust[0], msc[0], sbc[0]) else
            ntv_WaitForMscOML_1(hdc, target_msc, divisor, remainder, ust[0], PInt64(nil)^, sbc[0]) else
          if (msc<>nil) and (msc.Length<>0) then
            ntv_WaitForMscOML_1(hdc, target_msc, divisor, remainder, PInt64(nil)^, msc[0], sbc[0]) else
            ntv_WaitForMscOML_1(hdc, target_msc, divisor, remainder, PInt64(nil)^, PInt64(nil)^, sbc[0]) else
        if (ust<>nil) and (ust.Length<>0) then
          if (msc<>nil) and (msc.Length<>0) then
            ntv_WaitForMscOML_1(hdc, target_msc, divisor, remainder, ust[0], msc[0], PInt64(nil)^) else
            ntv_WaitForMscOML_1(hdc, target_msc, divisor, remainder, ust[0], PInt64(nil)^, PInt64(nil)^) else
          if (msc<>nil) and (msc.Length<>0) then
            ntv_WaitForMscOML_1(hdc, target_msc, divisor, remainder, PInt64(nil)^, msc[0], PInt64(nil)^) else
            ntv_WaitForMscOML_1(hdc, target_msc, divisor, remainder, PInt64(nil)^, PInt64(nil)^, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): glBool32 :=
      ntv_WaitForMscOML_1(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; sbc: IntPtr): glBool32 :=
      ntv_WaitForMscOML_2(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: IntPtr; var sbc: Int64): glBool32 :=
      ntv_WaitForMscOML_3(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: IntPtr; sbc: IntPtr): glBool32 :=
      ntv_WaitForMscOML_4(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; var msc: Int64; var sbc: Int64): glBool32 :=
      ntv_WaitForMscOML_5(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; var msc: Int64; sbc: IntPtr): glBool32 :=
      ntv_WaitForMscOML_6(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; msc: IntPtr; var sbc: Int64): glBool32 :=
      ntv_WaitForMscOML_7(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; msc: IntPtr; sbc: IntPtr): glBool32 :=
      ntv_WaitForMscOML_8(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    
    private WaitForSbcOML_adr := GetProcAddress('wglWaitForSbcOML');
    private ntv_WaitForSbcOML_1 := GetProcOrNil&<function(hdc: gdi_device_context; target_sbc: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): glBool32>(WaitForSbcOML_adr);
    private ntv_WaitForSbcOML_2 := GetProcOrNil&<function(hdc: gdi_device_context; target_sbc: Int64; var ust: Int64; var msc: Int64; sbc: IntPtr): glBool32>(WaitForSbcOML_adr);
    private ntv_WaitForSbcOML_3 := GetProcOrNil&<function(hdc: gdi_device_context; target_sbc: Int64; var ust: Int64; msc: IntPtr; var sbc: Int64): glBool32>(WaitForSbcOML_adr);
    private ntv_WaitForSbcOML_4 := GetProcOrNil&<function(hdc: gdi_device_context; target_sbc: Int64; var ust: Int64; msc: IntPtr; sbc: IntPtr): glBool32>(WaitForSbcOML_adr);
    private ntv_WaitForSbcOML_5 := GetProcOrNil&<function(hdc: gdi_device_context; target_sbc: Int64; ust: IntPtr; var msc: Int64; var sbc: Int64): glBool32>(WaitForSbcOML_adr);
    private ntv_WaitForSbcOML_6 := GetProcOrNil&<function(hdc: gdi_device_context; target_sbc: Int64; ust: IntPtr; var msc: Int64; sbc: IntPtr): glBool32>(WaitForSbcOML_adr);
    private ntv_WaitForSbcOML_7 := GetProcOrNil&<function(hdc: gdi_device_context; target_sbc: Int64; ust: IntPtr; msc: IntPtr; var sbc: Int64): glBool32>(WaitForSbcOML_adr);
    private ntv_WaitForSbcOML_8 := GetProcOrNil&<function(hdc: gdi_device_context; target_sbc: Int64; ust: IntPtr; msc: IntPtr; sbc: IntPtr): glBool32>(WaitForSbcOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; ust: array of Int64; msc: array of Int64; sbc: array of Int64): glBool32;
    type PInt64 = ^Int64;
    begin
      Result := if (sbc<>nil) and (sbc.Length<>0) then
        if (ust<>nil) and (ust.Length<>0) then
          if (msc<>nil) and (msc.Length<>0) then
            ntv_WaitForSbcOML_1(hdc, target_sbc, ust[0], msc[0], sbc[0]) else
            ntv_WaitForSbcOML_1(hdc, target_sbc, ust[0], PInt64(nil)^, sbc[0]) else
          if (msc<>nil) and (msc.Length<>0) then
            ntv_WaitForSbcOML_1(hdc, target_sbc, PInt64(nil)^, msc[0], sbc[0]) else
            ntv_WaitForSbcOML_1(hdc, target_sbc, PInt64(nil)^, PInt64(nil)^, sbc[0]) else
        if (ust<>nil) and (ust.Length<>0) then
          if (msc<>nil) and (msc.Length<>0) then
            ntv_WaitForSbcOML_1(hdc, target_sbc, ust[0], msc[0], PInt64(nil)^) else
            ntv_WaitForSbcOML_1(hdc, target_sbc, ust[0], PInt64(nil)^, PInt64(nil)^) else
          if (msc<>nil) and (msc.Length<>0) then
            ntv_WaitForSbcOML_1(hdc, target_sbc, PInt64(nil)^, msc[0], PInt64(nil)^) else
            ntv_WaitForSbcOML_1(hdc, target_sbc, PInt64(nil)^, PInt64(nil)^, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): glBool32 :=
      ntv_WaitForSbcOML_1(hdc, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; var ust: Int64; var msc: Int64; sbc: IntPtr): glBool32 :=
      ntv_WaitForSbcOML_2(hdc, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; var ust: Int64; msc: IntPtr; var sbc: Int64): glBool32 :=
      ntv_WaitForSbcOML_3(hdc, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; var ust: Int64; msc: IntPtr; sbc: IntPtr): glBool32 :=
      ntv_WaitForSbcOML_4(hdc, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; ust: IntPtr; var msc: Int64; var sbc: Int64): glBool32 :=
      ntv_WaitForSbcOML_5(hdc, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; ust: IntPtr; var msc: Int64; sbc: IntPtr): glBool32 :=
      ntv_WaitForSbcOML_6(hdc, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; ust: IntPtr; msc: IntPtr; var sbc: Int64): glBool32 :=
      ntv_WaitForSbcOML_7(hdc, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; ust: IntPtr; msc: IntPtr; sbc: IntPtr): glBool32 :=
      ntv_WaitForSbcOML_8(hdc, target_sbc, ust, msc, sbc);
    
  end;
  
  
  