  
  
  
  Vec2b = record
    public val0: SByte;
    public val1: SByte;
    
    public constructor(val0, val1: SByte);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    public static function operator implicit(vt: ValueTuple<SByte, SByte>): Vec2b := new Vec2b(vt.Item1, vt.Item2);
    public static function operator implicit(v: Vec2b): ValueTuple<SByte, SByte> := ValueTuple.Create(v.val0, v.val1);
    
    public static function Generate(gen: function(i: integer): SByte): Vec2b :=
      new Vec2b(gen(0), gen(1));
    
    public static function Read(prompt: string := nil): Vec2b;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec2b;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1);
    end;
    
    public static function Random(a, b: SByte): Vec2b;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec2b(a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1: SByte);
    begin
      val0 := self.val0;
      val1 := self.val1;
    end;
    
    private static function ValStr(val: SByte): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec2b;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec2b;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): SByte;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..1');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: SByte; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..1');
      end;
    public property ValAt[i: integer]: SByte read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec2b) := new Vec2b(-v.val0, -v.val1);
    public static function operator+(v: Vec2b) := v;
    
    public static function operator*(v: Vec2b; k: SByte) := new Vec2b(v.val0 * k, v.val1 * k);
    public static function operator div(v: Vec2b; k: SByte) := new Vec2b(v.val0 div k, v.val1 div k);
    
    public static function operator+(v1, v2: Vec2b) := new Vec2b(v1.val0 + v2.val0, v1.val1 + v2.val1);
    public static function operator-(v1, v2: Vec2b) := new Vec2b(v1.val0 - v2.val0, v1.val1 - v2.val1);
    public static function operator*(v1, v2: Vec2b) := v1.val0 * v2.val0 + v1.val1 * v2.val1;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec2b = ^Vec2b;
  
  Vec2d = record
    public val0: double;
    public val1: double;
    
    public constructor(val0, val1: double);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    public static function operator implicit(vt: ValueTuple<double, double>): Vec2d := new Vec2d(vt.Item1, vt.Item2);
    public static function operator implicit(v: Vec2d): ValueTuple<double, double> := ValueTuple.Create(v.val0, v.val1);
    
    public static function Generate(gen: function(i: integer): double): Vec2d :=
      new Vec2d(gen(0), gen(1));
    
    public static function Read(prompt: string := nil): Vec2d;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec2d;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1);
    end;
    
    public static function Random(a, b: double): Vec2d;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Vec2d(a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1: double);
    begin
      val0 := self.val0;
      val1 := self.val1;
    end;
    
    private static function ValStr(val: double): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec2d;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec2d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): double;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..1');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: double; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..1');
      end;
    public property ValAt[i: integer]: double read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec2d) := new Vec2d(-v.val0, -v.val1);
    public static function operator+(v: Vec2d) := v;
    
    public static function operator*(v: Vec2d; k: double) := new Vec2d(v.val0 * k, v.val1 * k);
    public static function operator/(v: Vec2d; k: double) := new Vec2d(v.val0 / k, v.val1 / k);
    
    public static function operator+(v1, v2: Vec2d) := new Vec2d(v1.val0 + v2.val0, v1.val1 + v2.val1);
    public static function operator-(v1, v2: Vec2d) := new Vec2d(v1.val0 - v2.val0, v1.val1 - v2.val1);
    public static function operator*(v1, v2: Vec2d) := v1.val0 * v2.val0 + v1.val1 * v2.val1;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
    public function Normalized := self / Length;
    
  end;
  PVec2d = ^Vec2d;
  UseVec2dCallback = procedure(v: Vec2d);
  ConvVec2dCallback<T> = function(v: Vec2d): T;
  UseVec2dSafePtrCallback = procedure(var v: Vec2d);
  ConvVec2dSafePtrCallback<T> = function(var v: Vec2d): T;
  
  Vec2f = record
    public val0: single;
    public val1: single;
    
    public constructor(val0, val1: single);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    public static function operator implicit(vt: ValueTuple<single, single>): Vec2f := new Vec2f(vt.Item1, vt.Item2);
    public static function operator implicit(v: Vec2f): ValueTuple<single, single> := ValueTuple.Create(v.val0, v.val1);
    
    public static function Generate(gen: function(i: integer): single): Vec2f :=
      new Vec2f(gen(0), gen(1));
    
    public static function Read(prompt: string := nil): Vec2f;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec2f;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1);
    end;
    
    public static function Random(a, b: single): Vec2f;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Vec2f(a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1: single);
    begin
      val0 := self.val0;
      val1 := self.val1;
    end;
    
    private static function ValStr(val: single): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec2f;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec2f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): single;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..1');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: single; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..1');
      end;
    public property ValAt[i: integer]: single read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec2f) := new Vec2f(-v.val0, -v.val1);
    public static function operator+(v: Vec2f) := v;
    
    public static function operator*(v: Vec2f; k: single) := new Vec2f(v.val0 * k, v.val1 * k);
    public static function operator/(v: Vec2f; k: single) := new Vec2f(v.val0 / k, v.val1 / k);
    
    public static function operator+(v1, v2: Vec2f) := new Vec2f(v1.val0 + v2.val0, v1.val1 + v2.val1);
    public static function operator-(v1, v2: Vec2f) := new Vec2f(v1.val0 - v2.val0, v1.val1 - v2.val1);
    public static function operator*(v1, v2: Vec2f) := v1.val0 * v2.val0 + v1.val1 * v2.val1;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
    public function Normalized := self / single(Length);
    
  end;
  PVec2f = ^Vec2f;
  UseVec2fCallback = procedure(v: Vec2f);
  ConvVec2fCallback<T> = function(v: Vec2f): T;
  UseVec2fSafePtrCallback = procedure(var v: Vec2f);
  ConvVec2fSafePtrCallback<T> = function(var v: Vec2f): T;
  
  Vec2i = record
    public val0: Int32;
    public val1: Int32;
    
    public constructor(val0, val1: Int32);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    public static function operator implicit(vt: ValueTuple<Int32, Int32>): Vec2i := new Vec2i(vt.Item1, vt.Item2);
    public static function operator implicit(v: Vec2i): ValueTuple<Int32, Int32> := ValueTuple.Create(v.val0, v.val1);
    
    public static function Generate(gen: function(i: integer): Int32): Vec2i :=
      new Vec2i(gen(0), gen(1));
    
    public static function Read(prompt: string := nil): Vec2i;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec2i;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1);
    end;
    
    public static function Random(a, b: Int32): Vec2i;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec2i(a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1: Int32);
    begin
      val0 := self.val0;
      val1 := self.val1;
    end;
    
    private static function ValStr(val: Int32): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec2i;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec2i;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): Int32;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..1');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: Int32; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..1');
      end;
    public property ValAt[i: integer]: Int32 read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec2i) := new Vec2i(-v.val0, -v.val1);
    public static function operator+(v: Vec2i) := v;
    
    public static function operator*(v: Vec2i; k: Int32) := new Vec2i(v.val0 * k, v.val1 * k);
    public static function operator div(v: Vec2i; k: Int32) := new Vec2i(v.val0 div k, v.val1 div k);
    
    public static function operator+(v1, v2: Vec2i) := new Vec2i(v1.val0 + v2.val0, v1.val1 + v2.val1);
    public static function operator-(v1, v2: Vec2i) := new Vec2i(v1.val0 - v2.val0, v1.val1 - v2.val1);
    public static function operator*(v1, v2: Vec2i) := v1.val0 * v2.val0 + v1.val1 * v2.val1;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec2i = ^Vec2i;
  
  Vec2i64 = record
    public val0: Int64;
    public val1: Int64;
    
    public constructor(val0, val1: Int64);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    public static function operator implicit(vt: ValueTuple<Int64, Int64>): Vec2i64 := new Vec2i64(vt.Item1, vt.Item2);
    public static function operator implicit(v: Vec2i64): ValueTuple<Int64, Int64> := ValueTuple.Create(v.val0, v.val1);
    
    public static function Generate(gen: function(i: integer): Int64): Vec2i64 :=
      new Vec2i64(gen(0), gen(1));
    
    public static function Read(prompt: string := nil): Vec2i64;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec2i64;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1);
    end;
    
    public static function Random(a, b: Int64): Vec2i64;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec2i64(a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1: Int64);
    begin
      val0 := self.val0;
      val1 := self.val1;
    end;
    
    private static function ValStr(val: Int64): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec2i64;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec2i64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): Int64;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..1');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: Int64; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..1');
      end;
    public property ValAt[i: integer]: Int64 read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec2i64) := new Vec2i64(-v.val0, -v.val1);
    public static function operator+(v: Vec2i64) := v;
    
    public static function operator*(v: Vec2i64; k: Int64) := new Vec2i64(v.val0 * k, v.val1 * k);
    public static function operator div(v: Vec2i64; k: Int64) := new Vec2i64(v.val0 div k, v.val1 div k);
    
    public static function operator+(v1, v2: Vec2i64) := new Vec2i64(v1.val0 + v2.val0, v1.val1 + v2.val1);
    public static function operator-(v1, v2: Vec2i64) := new Vec2i64(v1.val0 - v2.val0, v1.val1 - v2.val1);
    public static function operator*(v1, v2: Vec2i64) := v1.val0 * v2.val0 + v1.val1 * v2.val1;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec2i64 = ^Vec2i64;
  
  Vec2s = record
    public val0: Int16;
    public val1: Int16;
    
    public constructor(val0, val1: Int16);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    public static function operator implicit(vt: ValueTuple<Int16, Int16>): Vec2s := new Vec2s(vt.Item1, vt.Item2);
    public static function operator implicit(v: Vec2s): ValueTuple<Int16, Int16> := ValueTuple.Create(v.val0, v.val1);
    
    public static function Generate(gen: function(i: integer): Int16): Vec2s :=
      new Vec2s(gen(0), gen(1));
    
    public static function Read(prompt: string := nil): Vec2s;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec2s;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1);
    end;
    
    public static function Random(a, b: Int16): Vec2s;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec2s(a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1: Int16);
    begin
      val0 := self.val0;
      val1 := self.val1;
    end;
    
    private static function ValStr(val: Int16): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec2s;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec2s;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): Int16;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..1');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: Int16; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..1');
      end;
    public property ValAt[i: integer]: Int16 read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec2s) := new Vec2s(-v.val0, -v.val1);
    public static function operator+(v: Vec2s) := v;
    
    public static function operator*(v: Vec2s; k: Int16) := new Vec2s(v.val0 * k, v.val1 * k);
    public static function operator div(v: Vec2s; k: Int16) := new Vec2s(v.val0 div k, v.val1 div k);
    
    public static function operator+(v1, v2: Vec2s) := new Vec2s(v1.val0 + v2.val0, v1.val1 + v2.val1);
    public static function operator-(v1, v2: Vec2s) := new Vec2s(v1.val0 - v2.val0, v1.val1 - v2.val1);
    public static function operator*(v1, v2: Vec2s) := v1.val0 * v2.val0 + v1.val1 * v2.val1;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec2s = ^Vec2s;
  
  Vec2ui = record
    public val0: UInt32;
    public val1: UInt32;
    
    public constructor(val0, val1: UInt32);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    public static function operator implicit(vt: ValueTuple<UInt32, UInt32>): Vec2ui := new Vec2ui(vt.Item1, vt.Item2);
    public static function operator implicit(v: Vec2ui): ValueTuple<UInt32, UInt32> := ValueTuple.Create(v.val0, v.val1);
    
    public static function Generate(gen: function(i: integer): UInt32): Vec2ui :=
      new Vec2ui(gen(0), gen(1));
    
    public static function Read(prompt: string := nil): Vec2ui;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec2ui;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1);
    end;
    
    public static function Random(a, b: UInt32): Vec2ui;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec2ui(a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1: UInt32);
    begin
      val0 := self.val0;
      val1 := self.val1;
    end;
    
    private static function ValStr(val: UInt32): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec2ui;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec2ui;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): UInt32;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..1');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: UInt32; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..1');
      end;
    public property ValAt[i: integer]: UInt32 read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator+(v: Vec2ui) := v;
    
    public static function operator*(v: Vec2ui; k: UInt32) := new Vec2ui(v.val0 * k, v.val1 * k);
    public static function operator div(v: Vec2ui; k: UInt32) := new Vec2ui(v.val0 div k, v.val1 div k);
    
    public static function operator+(v1, v2: Vec2ui) := new Vec2ui(v1.val0 + v2.val0, v1.val1 + v2.val1);
    public static function operator-(v1, v2: Vec2ui) := new Vec2ui(v1.val0 - v2.val0, v1.val1 - v2.val1);
    public static function operator*(v1, v2: Vec2ui) := v1.val0 * v2.val0 + v1.val1 * v2.val1;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec2ui = ^Vec2ui;
  
  Vec2ui64 = record
    public val0: UInt64;
    public val1: UInt64;
    
    public constructor(val0, val1: UInt64);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    public static function operator implicit(vt: ValueTuple<UInt64, UInt64>): Vec2ui64 := new Vec2ui64(vt.Item1, vt.Item2);
    public static function operator implicit(v: Vec2ui64): ValueTuple<UInt64, UInt64> := ValueTuple.Create(v.val0, v.val1);
    
    public static function Generate(gen: function(i: integer): UInt64): Vec2ui64 :=
      new Vec2ui64(gen(0), gen(1));
    
    public static function Read(prompt: string := nil): Vec2ui64;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec2ui64;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1);
    end;
    
    public static function Random(a, b: UInt64): Vec2ui64;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec2ui64(a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1: UInt64);
    begin
      val0 := self.val0;
      val1 := self.val1;
    end;
    
    private static function ValStr(val: UInt64): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec2ui64;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec2ui64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): UInt64;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..1');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: UInt64; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..1');
      end;
    public property ValAt[i: integer]: UInt64 read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator+(v: Vec2ui64) := v;
    
    public static function operator*(v: Vec2ui64; k: UInt64) := new Vec2ui64(v.val0 * k, v.val1 * k);
    public static function operator div(v: Vec2ui64; k: UInt64) := new Vec2ui64(v.val0 div k, v.val1 div k);
    
    public static function operator+(v1, v2: Vec2ui64) := new Vec2ui64(v1.val0 + v2.val0, v1.val1 + v2.val1);
    public static function operator-(v1, v2: Vec2ui64) := new Vec2ui64(v1.val0 - v2.val0, v1.val1 - v2.val1);
    public static function operator*(v1, v2: Vec2ui64) := v1.val0 * v2.val0 + v1.val1 * v2.val1;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec2ui64 = ^Vec2ui64;
  
  Vec3b = record
    public val0: SByte;
    public val1: SByte;
    public val2: SByte;
    
    public constructor(val0, val1, val2: SByte);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    public static function operator implicit(vt: ValueTuple<SByte, SByte, SByte>): Vec3b := new Vec3b(vt.Item1, vt.Item2, vt.Item3);
    public static function operator implicit(v: Vec3b): ValueTuple<SByte, SByte, SByte> := ValueTuple.Create(v.val0, v.val1, v.val2);
    
    public static function Generate(gen: function(i: integer): SByte): Vec3b :=
      new Vec3b(gen(0), gen(1), gen(2));
    
    public static function Read(prompt: string := nil): Vec3b;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec3b;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function Random(a, b: SByte): Vec3b;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec3b(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2: SByte);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
    end;
    
    private static function ValStr(val: SByte): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec3b;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec3b;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): SByte;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: SByte; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    public property ValAt[i: integer]: SByte read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec3b) := new Vec3b(-v.val0, -v.val1, -v.val2);
    public static function operator+(v: Vec3b) := v;
    
    public static function operator*(v: Vec3b; k: SByte) := new Vec3b(v.val0 * k, v.val1 * k, v.val2 * k);
    public static function operator div(v: Vec3b; k: SByte) := new Vec3b(v.val0 div k, v.val1 div k, v.val2 div k);
    
    public static function operator+(v1, v2: Vec3b) := new Vec3b(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2);
    public static function operator-(v1, v2: Vec3b) := new Vec3b(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2);
    public static function operator*(v1, v2: Vec3b) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
    public static function CrossCW(v1, v2: Vec3b) :=
      new Vec3b(v1.val1*v2.val2 - v2.val1*v1.val2, v1.val2*v2.val0 - v2.val2*v1.val0, v1.val0*v2.val1 - v2.val0*v1.val1);
    public static function CrossCCW(v1, v2: Vec3b) := CrossCW(v2, v1);
    
  end;
  PVec3b = ^Vec3b;
  
  Vec3d = record
    public val0: double;
    public val1: double;
    public val2: double;
    
    public constructor(val0, val1, val2: double);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    public static function operator implicit(vt: ValueTuple<double, double, double>): Vec3d := new Vec3d(vt.Item1, vt.Item2, vt.Item3);
    public static function operator implicit(v: Vec3d): ValueTuple<double, double, double> := ValueTuple.Create(v.val0, v.val1, v.val2);
    
    public static function Generate(gen: function(i: integer): double): Vec3d :=
      new Vec3d(gen(0), gen(1), gen(2));
    
    public static function Read(prompt: string := nil): Vec3d;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec3d;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function Random(a, b: double): Vec3d;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Vec3d(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2: double);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
    end;
    
    private static function ValStr(val: double): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec3d;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec3d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): double;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: double; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    public property ValAt[i: integer]: double read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec3d) := new Vec3d(-v.val0, -v.val1, -v.val2);
    public static function operator+(v: Vec3d) := v;
    
    public static function operator*(v: Vec3d; k: double) := new Vec3d(v.val0 * k, v.val1 * k, v.val2 * k);
    public static function operator/(v: Vec3d; k: double) := new Vec3d(v.val0 / k, v.val1 / k, v.val2 / k);
    
    public static function operator+(v1, v2: Vec3d) := new Vec3d(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2);
    public static function operator-(v1, v2: Vec3d) := new Vec3d(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2);
    public static function operator*(v1, v2: Vec3d) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
    public function Normalized := self / Length;
    
    public static function CrossCW(v1, v2: Vec3d) :=
      new Vec3d(v1.val1*v2.val2 - v2.val1*v1.val2, v1.val2*v2.val0 - v2.val2*v1.val0, v1.val0*v2.val1 - v2.val0*v1.val1);
    public static function CrossCCW(v1, v2: Vec3d) := CrossCW(v2, v1);
    
  end;
  PVec3d = ^Vec3d;
  UseVec3dCallback = procedure(v: Vec3d);
  ConvVec3dCallback<T> = function(v: Vec3d): T;
  UseVec3dSafePtrCallback = procedure(var v: Vec3d);
  ConvVec3dSafePtrCallback<T> = function(var v: Vec3d): T;
  
  Vec3f = record
    public val0: single;
    public val1: single;
    public val2: single;
    
    public constructor(val0, val1, val2: single);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    public static function operator implicit(vt: ValueTuple<single, single, single>): Vec3f := new Vec3f(vt.Item1, vt.Item2, vt.Item3);
    public static function operator implicit(v: Vec3f): ValueTuple<single, single, single> := ValueTuple.Create(v.val0, v.val1, v.val2);
    
    public static function Generate(gen: function(i: integer): single): Vec3f :=
      new Vec3f(gen(0), gen(1), gen(2));
    
    public static function Read(prompt: string := nil): Vec3f;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec3f;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function Random(a, b: single): Vec3f;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Vec3f(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2: single);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
    end;
    
    private static function ValStr(val: single): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec3f;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec3f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): single;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: single; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    public property ValAt[i: integer]: single read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec3f) := new Vec3f(-v.val0, -v.val1, -v.val2);
    public static function operator+(v: Vec3f) := v;
    
    public static function operator*(v: Vec3f; k: single) := new Vec3f(v.val0 * k, v.val1 * k, v.val2 * k);
    public static function operator/(v: Vec3f; k: single) := new Vec3f(v.val0 / k, v.val1 / k, v.val2 / k);
    
    public static function operator+(v1, v2: Vec3f) := new Vec3f(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2);
    public static function operator-(v1, v2: Vec3f) := new Vec3f(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2);
    public static function operator*(v1, v2: Vec3f) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
    public function Normalized := self / single(Length);
    
    public static function CrossCW(v1, v2: Vec3f) :=
      new Vec3f(v1.val1*v2.val2 - v2.val1*v1.val2, v1.val2*v2.val0 - v2.val2*v1.val0, v1.val0*v2.val1 - v2.val0*v1.val1);
    public static function CrossCCW(v1, v2: Vec3f) := CrossCW(v2, v1);
    
  end;
  PVec3f = ^Vec3f;
  UseVec3fCallback = procedure(v: Vec3f);
  ConvVec3fCallback<T> = function(v: Vec3f): T;
  UseVec3fSafePtrCallback = procedure(var v: Vec3f);
  ConvVec3fSafePtrCallback<T> = function(var v: Vec3f): T;
  
  Vec3i = record
    public val0: Int32;
    public val1: Int32;
    public val2: Int32;
    
    public constructor(val0, val1, val2: Int32);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    public static function operator implicit(vt: ValueTuple<Int32, Int32, Int32>): Vec3i := new Vec3i(vt.Item1, vt.Item2, vt.Item3);
    public static function operator implicit(v: Vec3i): ValueTuple<Int32, Int32, Int32> := ValueTuple.Create(v.val0, v.val1, v.val2);
    
    public static function Generate(gen: function(i: integer): Int32): Vec3i :=
      new Vec3i(gen(0), gen(1), gen(2));
    
    public static function Read(prompt: string := nil): Vec3i;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec3i;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function Random(a, b: Int32): Vec3i;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec3i(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2: Int32);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
    end;
    
    private static function ValStr(val: Int32): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec3i;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec3i;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): Int32;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: Int32; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    public property ValAt[i: integer]: Int32 read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec3i) := new Vec3i(-v.val0, -v.val1, -v.val2);
    public static function operator+(v: Vec3i) := v;
    
    public static function operator*(v: Vec3i; k: Int32) := new Vec3i(v.val0 * k, v.val1 * k, v.val2 * k);
    public static function operator div(v: Vec3i; k: Int32) := new Vec3i(v.val0 div k, v.val1 div k, v.val2 div k);
    
    public static function operator+(v1, v2: Vec3i) := new Vec3i(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2);
    public static function operator-(v1, v2: Vec3i) := new Vec3i(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2);
    public static function operator*(v1, v2: Vec3i) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
    public static function CrossCW(v1, v2: Vec3i) :=
      new Vec3i(v1.val1*v2.val2 - v2.val1*v1.val2, v1.val2*v2.val0 - v2.val2*v1.val0, v1.val0*v2.val1 - v2.val0*v1.val1);
    public static function CrossCCW(v1, v2: Vec3i) := CrossCW(v2, v1);
    
  end;
  PVec3i = ^Vec3i;
  
  Vec3i64 = record
    public val0: Int64;
    public val1: Int64;
    public val2: Int64;
    
    public constructor(val0, val1, val2: Int64);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    public static function operator implicit(vt: ValueTuple<Int64, Int64, Int64>): Vec3i64 := new Vec3i64(vt.Item1, vt.Item2, vt.Item3);
    public static function operator implicit(v: Vec3i64): ValueTuple<Int64, Int64, Int64> := ValueTuple.Create(v.val0, v.val1, v.val2);
    
    public static function Generate(gen: function(i: integer): Int64): Vec3i64 :=
      new Vec3i64(gen(0), gen(1), gen(2));
    
    public static function Read(prompt: string := nil): Vec3i64;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec3i64;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function Random(a, b: Int64): Vec3i64;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec3i64(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2: Int64);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
    end;
    
    private static function ValStr(val: Int64): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec3i64;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec3i64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): Int64;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: Int64; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    public property ValAt[i: integer]: Int64 read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec3i64) := new Vec3i64(-v.val0, -v.val1, -v.val2);
    public static function operator+(v: Vec3i64) := v;
    
    public static function operator*(v: Vec3i64; k: Int64) := new Vec3i64(v.val0 * k, v.val1 * k, v.val2 * k);
    public static function operator div(v: Vec3i64; k: Int64) := new Vec3i64(v.val0 div k, v.val1 div k, v.val2 div k);
    
    public static function operator+(v1, v2: Vec3i64) := new Vec3i64(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2);
    public static function operator-(v1, v2: Vec3i64) := new Vec3i64(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2);
    public static function operator*(v1, v2: Vec3i64) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
    public static function CrossCW(v1, v2: Vec3i64) :=
      new Vec3i64(v1.val1*v2.val2 - v2.val1*v1.val2, v1.val2*v2.val0 - v2.val2*v1.val0, v1.val0*v2.val1 - v2.val0*v1.val1);
    public static function CrossCCW(v1, v2: Vec3i64) := CrossCW(v2, v1);
    
  end;
  PVec3i64 = ^Vec3i64;
  
  Vec3s = record
    public val0: Int16;
    public val1: Int16;
    public val2: Int16;
    
    public constructor(val0, val1, val2: Int16);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    public static function operator implicit(vt: ValueTuple<Int16, Int16, Int16>): Vec3s := new Vec3s(vt.Item1, vt.Item2, vt.Item3);
    public static function operator implicit(v: Vec3s): ValueTuple<Int16, Int16, Int16> := ValueTuple.Create(v.val0, v.val1, v.val2);
    
    public static function Generate(gen: function(i: integer): Int16): Vec3s :=
      new Vec3s(gen(0), gen(1), gen(2));
    
    public static function Read(prompt: string := nil): Vec3s;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec3s;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function Random(a, b: Int16): Vec3s;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec3s(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2: Int16);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
    end;
    
    private static function ValStr(val: Int16): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec3s;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec3s;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): Int16;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: Int16; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    public property ValAt[i: integer]: Int16 read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec3s) := new Vec3s(-v.val0, -v.val1, -v.val2);
    public static function operator+(v: Vec3s) := v;
    
    public static function operator*(v: Vec3s; k: Int16) := new Vec3s(v.val0 * k, v.val1 * k, v.val2 * k);
    public static function operator div(v: Vec3s; k: Int16) := new Vec3s(v.val0 div k, v.val1 div k, v.val2 div k);
    
    public static function operator+(v1, v2: Vec3s) := new Vec3s(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2);
    public static function operator-(v1, v2: Vec3s) := new Vec3s(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2);
    public static function operator*(v1, v2: Vec3s) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
    public static function CrossCW(v1, v2: Vec3s) :=
      new Vec3s(v1.val1*v2.val2 - v2.val1*v1.val2, v1.val2*v2.val0 - v2.val2*v1.val0, v1.val0*v2.val1 - v2.val0*v1.val1);
    public static function CrossCCW(v1, v2: Vec3s) := CrossCW(v2, v1);
    
  end;
  PVec3s = ^Vec3s;
  
  Vec3ub = record
    public val0: Byte;
    public val1: Byte;
    public val2: Byte;
    
    public constructor(val0, val1, val2: Byte);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    public static function operator implicit(vt: ValueTuple<Byte, Byte, Byte>): Vec3ub := new Vec3ub(vt.Item1, vt.Item2, vt.Item3);
    public static function operator implicit(v: Vec3ub): ValueTuple<Byte, Byte, Byte> := ValueTuple.Create(v.val0, v.val1, v.val2);
    
    public static function Generate(gen: function(i: integer): Byte): Vec3ub :=
      new Vec3ub(gen(0), gen(1), gen(2));
    
    public static function Read(prompt: string := nil): Vec3ub;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec3ub;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function Random(a, b: Byte): Vec3ub;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec3ub(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2: Byte);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
    end;
    
    private static function ValStr(val: Byte): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec3ub;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec3ub;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): Byte;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: Byte; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    public property ValAt[i: integer]: Byte read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator+(v: Vec3ub) := v;
    
    public static function operator*(v: Vec3ub; k: Byte) := new Vec3ub(v.val0 * k, v.val1 * k, v.val2 * k);
    public static function operator div(v: Vec3ub; k: Byte) := new Vec3ub(v.val0 div k, v.val1 div k, v.val2 div k);
    
    public static function operator+(v1, v2: Vec3ub) := new Vec3ub(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2);
    public static function operator-(v1, v2: Vec3ub) := new Vec3ub(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2);
    public static function operator*(v1, v2: Vec3ub) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec3ub = ^Vec3ub;
  
  Vec3ui = record
    public val0: UInt32;
    public val1: UInt32;
    public val2: UInt32;
    
    public constructor(val0, val1, val2: UInt32);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    public static function operator implicit(vt: ValueTuple<UInt32, UInt32, UInt32>): Vec3ui := new Vec3ui(vt.Item1, vt.Item2, vt.Item3);
    public static function operator implicit(v: Vec3ui): ValueTuple<UInt32, UInt32, UInt32> := ValueTuple.Create(v.val0, v.val1, v.val2);
    
    public static function Generate(gen: function(i: integer): UInt32): Vec3ui :=
      new Vec3ui(gen(0), gen(1), gen(2));
    
    public static function Read(prompt: string := nil): Vec3ui;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec3ui;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function Random(a, b: UInt32): Vec3ui;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec3ui(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2: UInt32);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
    end;
    
    private static function ValStr(val: UInt32): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec3ui;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec3ui;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): UInt32;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: UInt32; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    public property ValAt[i: integer]: UInt32 read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator+(v: Vec3ui) := v;
    
    public static function operator*(v: Vec3ui; k: UInt32) := new Vec3ui(v.val0 * k, v.val1 * k, v.val2 * k);
    public static function operator div(v: Vec3ui; k: UInt32) := new Vec3ui(v.val0 div k, v.val1 div k, v.val2 div k);
    
    public static function operator+(v1, v2: Vec3ui) := new Vec3ui(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2);
    public static function operator-(v1, v2: Vec3ui) := new Vec3ui(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2);
    public static function operator*(v1, v2: Vec3ui) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec3ui = ^Vec3ui;
  
  Vec3ui64 = record
    public val0: UInt64;
    public val1: UInt64;
    public val2: UInt64;
    
    public constructor(val0, val1, val2: UInt64);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    public static function operator implicit(vt: ValueTuple<UInt64, UInt64, UInt64>): Vec3ui64 := new Vec3ui64(vt.Item1, vt.Item2, vt.Item3);
    public static function operator implicit(v: Vec3ui64): ValueTuple<UInt64, UInt64, UInt64> := ValueTuple.Create(v.val0, v.val1, v.val2);
    
    public static function Generate(gen: function(i: integer): UInt64): Vec3ui64 :=
      new Vec3ui64(gen(0), gen(1), gen(2));
    
    public static function Read(prompt: string := nil): Vec3ui64;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec3ui64;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function Random(a, b: UInt64): Vec3ui64;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec3ui64(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2: UInt64);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
    end;
    
    private static function ValStr(val: UInt64): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec3ui64;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec3ui64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): UInt64;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: UInt64; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    public property ValAt[i: integer]: UInt64 read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator+(v: Vec3ui64) := v;
    
    public static function operator*(v: Vec3ui64; k: UInt64) := new Vec3ui64(v.val0 * k, v.val1 * k, v.val2 * k);
    public static function operator div(v: Vec3ui64; k: UInt64) := new Vec3ui64(v.val0 div k, v.val1 div k, v.val2 div k);
    
    public static function operator+(v1, v2: Vec3ui64) := new Vec3ui64(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2);
    public static function operator-(v1, v2: Vec3ui64) := new Vec3ui64(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2);
    public static function operator*(v1, v2: Vec3ui64) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec3ui64 = ^Vec3ui64;
  
  Vec3us = record
    public val0: UInt16;
    public val1: UInt16;
    public val2: UInt16;
    
    public constructor(val0, val1, val2: UInt16);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    public static function operator implicit(vt: ValueTuple<UInt16, UInt16, UInt16>): Vec3us := new Vec3us(vt.Item1, vt.Item2, vt.Item3);
    public static function operator implicit(v: Vec3us): ValueTuple<UInt16, UInt16, UInt16> := ValueTuple.Create(v.val0, v.val1, v.val2);
    
    public static function Generate(gen: function(i: integer): UInt16): Vec3us :=
      new Vec3us(gen(0), gen(1), gen(2));
    
    public static function Read(prompt: string := nil): Vec3us;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec3us;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2);
    end;
    
    public static function Random(a, b: UInt16): Vec3us;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec3us(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2: UInt16);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
    end;
    
    private static function ValStr(val: UInt16): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec3us;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec3us;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): UInt16;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: UInt16; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..2');
      end;
    public property ValAt[i: integer]: UInt16 read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator+(v: Vec3us) := v;
    
    public static function operator*(v: Vec3us; k: UInt16) := new Vec3us(v.val0 * k, v.val1 * k, v.val2 * k);
    public static function operator div(v: Vec3us; k: UInt16) := new Vec3us(v.val0 div k, v.val1 div k, v.val2 div k);
    
    public static function operator+(v1, v2: Vec3us) := new Vec3us(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2);
    public static function operator-(v1, v2: Vec3us) := new Vec3us(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2);
    public static function operator*(v1, v2: Vec3us) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec3us = ^Vec3us;
  
  Vec4b = record
    public val0: SByte;
    public val1: SByte;
    public val2: SByte;
    public val3: SByte;
    
    public constructor(val0, val1, val2, val3: SByte);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    public static function operator implicit(vt: ValueTuple<SByte, SByte, SByte, SByte>): Vec4b := new Vec4b(vt.Item1, vt.Item2, vt.Item3, vt.Item4);
    public static function operator implicit(v: Vec4b): ValueTuple<SByte, SByte, SByte, SByte> := ValueTuple.Create(v.val0, v.val1, v.val2, v.val3);
    
    public static function Generate(gen: function(i: integer): SByte): Vec4b :=
      new Vec4b(gen(0), gen(1), gen(2), gen(3));
    
    public static function Read(prompt: string := nil): Vec4b;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec4b;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function Random(a, b: SByte): Vec4b;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec4b(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2, val3: SByte);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
      val3 := self.val3;
    end;
    
    private static function ValStr(val: SByte): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2); res += ', ';
      res += ValStr(val3);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec4b;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec4b;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): SByte;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        3: Result := self.val3;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: SByte; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        3: self.val3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    public property ValAt[i: integer]: SByte read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec4b) := new Vec4b(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator+(v: Vec4b) := v;
    
    public static function operator*(v: Vec4b; k: SByte) := new Vec4b(v.val0 * k, v.val1 * k, v.val2 * k, v.val3 * k);
    public static function operator div(v: Vec4b; k: SByte) := new Vec4b(v.val0 div k, v.val1 div k, v.val2 div k, v.val3 div k);
    
    public static function operator+(v1, v2: Vec4b) := new Vec4b(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2, v1.val3 + v2.val3);
    public static function operator-(v1, v2: Vec4b) := new Vec4b(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2, v1.val3 - v2.val3);
    public static function operator*(v1, v2: Vec4b) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2 + v1.val3 * v2.val3;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec4b = ^Vec4b;
  
  Vec4d = record
    public val0: double;
    public val1: double;
    public val2: double;
    public val3: double;
    
    public constructor(val0, val1, val2, val3: double);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    public static function operator implicit(vt: ValueTuple<double, double, double, double>): Vec4d := new Vec4d(vt.Item1, vt.Item2, vt.Item3, vt.Item4);
    public static function operator implicit(v: Vec4d): ValueTuple<double, double, double, double> := ValueTuple.Create(v.val0, v.val1, v.val2, v.val3);
    
    public static function Generate(gen: function(i: integer): double): Vec4d :=
      new Vec4d(gen(0), gen(1), gen(2), gen(3));
    
    public static function Read(prompt: string := nil): Vec4d;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec4d;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function Random(a, b: double): Vec4d;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Vec4d(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2, val3: double);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
      val3 := self.val3;
    end;
    
    private static function ValStr(val: double): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2); res += ', ';
      res += ValStr(val3);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec4d;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec4d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): double;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        3: Result := self.val3;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: double; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        3: self.val3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    public property ValAt[i: integer]: double read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec4d) := new Vec4d(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator+(v: Vec4d) := v;
    
    public static function operator*(v: Vec4d; k: double) := new Vec4d(v.val0 * k, v.val1 * k, v.val2 * k, v.val3 * k);
    public static function operator/(v: Vec4d; k: double) := new Vec4d(v.val0 / k, v.val1 / k, v.val2 / k, v.val3 / k);
    
    public static function operator+(v1, v2: Vec4d) := new Vec4d(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2, v1.val3 + v2.val3);
    public static function operator-(v1, v2: Vec4d) := new Vec4d(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2, v1.val3 - v2.val3);
    public static function operator*(v1, v2: Vec4d) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2 + v1.val3 * v2.val3;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
    public function Normalized := self / Length;
    
  end;
  PVec4d = ^Vec4d;
  UseVec4dCallback = procedure(v: Vec4d);
  ConvVec4dCallback<T> = function(v: Vec4d): T;
  UseVec4dSafePtrCallback = procedure(var v: Vec4d);
  ConvVec4dSafePtrCallback<T> = function(var v: Vec4d): T;
  
  Vec4f = record
    public val0: single;
    public val1: single;
    public val2: single;
    public val3: single;
    
    public constructor(val0, val1, val2, val3: single);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    public static function operator implicit(vt: ValueTuple<single, single, single, single>): Vec4f := new Vec4f(vt.Item1, vt.Item2, vt.Item3, vt.Item4);
    public static function operator implicit(v: Vec4f): ValueTuple<single, single, single, single> := ValueTuple.Create(v.val0, v.val1, v.val2, v.val3);
    
    public static function Generate(gen: function(i: integer): single): Vec4f :=
      new Vec4f(gen(0), gen(1), gen(2), gen(3));
    
    public static function Read(prompt: string := nil): Vec4f;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec4f;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function Random(a, b: single): Vec4f;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Vec4f(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2, val3: single);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
      val3 := self.val3;
    end;
    
    private static function ValStr(val: single): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2); res += ', ';
      res += ValStr(val3);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec4f;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec4f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): single;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        3: Result := self.val3;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: single; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        3: self.val3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    public property ValAt[i: integer]: single read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec4f) := new Vec4f(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator+(v: Vec4f) := v;
    
    public static function operator*(v: Vec4f; k: single) := new Vec4f(v.val0 * k, v.val1 * k, v.val2 * k, v.val3 * k);
    public static function operator/(v: Vec4f; k: single) := new Vec4f(v.val0 / k, v.val1 / k, v.val2 / k, v.val3 / k);
    
    public static function operator+(v1, v2: Vec4f) := new Vec4f(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2, v1.val3 + v2.val3);
    public static function operator-(v1, v2: Vec4f) := new Vec4f(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2, v1.val3 - v2.val3);
    public static function operator*(v1, v2: Vec4f) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2 + v1.val3 * v2.val3;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
    public function Normalized := self / single(Length);
    
  end;
  PVec4f = ^Vec4f;
  UseVec4fCallback = procedure(v: Vec4f);
  ConvVec4fCallback<T> = function(v: Vec4f): T;
  UseVec4fSafePtrCallback = procedure(var v: Vec4f);
  ConvVec4fSafePtrCallback<T> = function(var v: Vec4f): T;
  
  Vec4i = record
    public val0: Int32;
    public val1: Int32;
    public val2: Int32;
    public val3: Int32;
    
    public constructor(val0, val1, val2, val3: Int32);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    public static function operator implicit(vt: ValueTuple<Int32, Int32, Int32, Int32>): Vec4i := new Vec4i(vt.Item1, vt.Item2, vt.Item3, vt.Item4);
    public static function operator implicit(v: Vec4i): ValueTuple<Int32, Int32, Int32, Int32> := ValueTuple.Create(v.val0, v.val1, v.val2, v.val3);
    
    public static function Generate(gen: function(i: integer): Int32): Vec4i :=
      new Vec4i(gen(0), gen(1), gen(2), gen(3));
    
    public static function Read(prompt: string := nil): Vec4i;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec4i;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function Random(a, b: Int32): Vec4i;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec4i(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2, val3: Int32);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
      val3 := self.val3;
    end;
    
    private static function ValStr(val: Int32): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2); res += ', ';
      res += ValStr(val3);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec4i;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec4i;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): Int32;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        3: Result := self.val3;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: Int32; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        3: self.val3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    public property ValAt[i: integer]: Int32 read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec4i) := new Vec4i(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator+(v: Vec4i) := v;
    
    public static function operator*(v: Vec4i; k: Int32) := new Vec4i(v.val0 * k, v.val1 * k, v.val2 * k, v.val3 * k);
    public static function operator div(v: Vec4i; k: Int32) := new Vec4i(v.val0 div k, v.val1 div k, v.val2 div k, v.val3 div k);
    
    public static function operator+(v1, v2: Vec4i) := new Vec4i(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2, v1.val3 + v2.val3);
    public static function operator-(v1, v2: Vec4i) := new Vec4i(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2, v1.val3 - v2.val3);
    public static function operator*(v1, v2: Vec4i) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2 + v1.val3 * v2.val3;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec4i = ^Vec4i;
  
  Vec4i64 = record
    public val0: Int64;
    public val1: Int64;
    public val2: Int64;
    public val3: Int64;
    
    public constructor(val0, val1, val2, val3: Int64);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    public static function operator implicit(vt: ValueTuple<Int64, Int64, Int64, Int64>): Vec4i64 := new Vec4i64(vt.Item1, vt.Item2, vt.Item3, vt.Item4);
    public static function operator implicit(v: Vec4i64): ValueTuple<Int64, Int64, Int64, Int64> := ValueTuple.Create(v.val0, v.val1, v.val2, v.val3);
    
    public static function Generate(gen: function(i: integer): Int64): Vec4i64 :=
      new Vec4i64(gen(0), gen(1), gen(2), gen(3));
    
    public static function Read(prompt: string := nil): Vec4i64;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec4i64;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function Random(a, b: Int64): Vec4i64;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec4i64(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2, val3: Int64);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
      val3 := self.val3;
    end;
    
    private static function ValStr(val: Int64): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2); res += ', ';
      res += ValStr(val3);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec4i64;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec4i64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): Int64;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        3: Result := self.val3;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: Int64; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        3: self.val3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    public property ValAt[i: integer]: Int64 read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec4i64) := new Vec4i64(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator+(v: Vec4i64) := v;
    
    public static function operator*(v: Vec4i64; k: Int64) := new Vec4i64(v.val0 * k, v.val1 * k, v.val2 * k, v.val3 * k);
    public static function operator div(v: Vec4i64; k: Int64) := new Vec4i64(v.val0 div k, v.val1 div k, v.val2 div k, v.val3 div k);
    
    public static function operator+(v1, v2: Vec4i64) := new Vec4i64(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2, v1.val3 + v2.val3);
    public static function operator-(v1, v2: Vec4i64) := new Vec4i64(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2, v1.val3 - v2.val3);
    public static function operator*(v1, v2: Vec4i64) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2 + v1.val3 * v2.val3;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec4i64 = ^Vec4i64;
  
  Vec4s = record
    public val0: Int16;
    public val1: Int16;
    public val2: Int16;
    public val3: Int16;
    
    public constructor(val0, val1, val2, val3: Int16);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    public static function operator implicit(vt: ValueTuple<Int16, Int16, Int16, Int16>): Vec4s := new Vec4s(vt.Item1, vt.Item2, vt.Item3, vt.Item4);
    public static function operator implicit(v: Vec4s): ValueTuple<Int16, Int16, Int16, Int16> := ValueTuple.Create(v.val0, v.val1, v.val2, v.val3);
    
    public static function Generate(gen: function(i: integer): Int16): Vec4s :=
      new Vec4s(gen(0), gen(1), gen(2), gen(3));
    
    public static function Read(prompt: string := nil): Vec4s;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec4s;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function Random(a, b: Int16): Vec4s;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec4s(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2, val3: Int16);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
      val3 := self.val3;
    end;
    
    private static function ValStr(val: Int16): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2); res += ', ';
      res += ValStr(val3);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec4s;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec4s;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): Int16;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        3: Result := self.val3;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: Int16; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        3: self.val3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    public property ValAt[i: integer]: Int16 read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator-(v: Vec4s) := new Vec4s(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator+(v: Vec4s) := v;
    
    public static function operator*(v: Vec4s; k: Int16) := new Vec4s(v.val0 * k, v.val1 * k, v.val2 * k, v.val3 * k);
    public static function operator div(v: Vec4s; k: Int16) := new Vec4s(v.val0 div k, v.val1 div k, v.val2 div k, v.val3 div k);
    
    public static function operator+(v1, v2: Vec4s) := new Vec4s(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2, v1.val3 + v2.val3);
    public static function operator-(v1, v2: Vec4s) := new Vec4s(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2, v1.val3 - v2.val3);
    public static function operator*(v1, v2: Vec4s) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2 + v1.val3 * v2.val3;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec4s = ^Vec4s;
  
  Vec4ub = record
    public val0: Byte;
    public val1: Byte;
    public val2: Byte;
    public val3: Byte;
    
    public constructor(val0, val1, val2, val3: Byte);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    public static function operator implicit(vt: ValueTuple<Byte, Byte, Byte, Byte>): Vec4ub := new Vec4ub(vt.Item1, vt.Item2, vt.Item3, vt.Item4);
    public static function operator implicit(v: Vec4ub): ValueTuple<Byte, Byte, Byte, Byte> := ValueTuple.Create(v.val0, v.val1, v.val2, v.val3);
    
    public static function Generate(gen: function(i: integer): Byte): Vec4ub :=
      new Vec4ub(gen(0), gen(1), gen(2), gen(3));
    
    public static function Read(prompt: string := nil): Vec4ub;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec4ub;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function Random(a, b: Byte): Vec4ub;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec4ub(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2, val3: Byte);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
      val3 := self.val3;
    end;
    
    private static function ValStr(val: Byte): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2); res += ', ';
      res += ValStr(val3);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec4ub;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec4ub;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): Byte;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        3: Result := self.val3;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: Byte; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        3: self.val3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    public property ValAt[i: integer]: Byte read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator+(v: Vec4ub) := v;
    
    public static function operator*(v: Vec4ub; k: Byte) := new Vec4ub(v.val0 * k, v.val1 * k, v.val2 * k, v.val3 * k);
    public static function operator div(v: Vec4ub; k: Byte) := new Vec4ub(v.val0 div k, v.val1 div k, v.val2 div k, v.val3 div k);
    
    public static function operator+(v1, v2: Vec4ub) := new Vec4ub(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2, v1.val3 + v2.val3);
    public static function operator-(v1, v2: Vec4ub) := new Vec4ub(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2, v1.val3 - v2.val3);
    public static function operator*(v1, v2: Vec4ub) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2 + v1.val3 * v2.val3;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec4ub = ^Vec4ub;
  
  Vec4ui = record
    public val0: UInt32;
    public val1: UInt32;
    public val2: UInt32;
    public val3: UInt32;
    
    public constructor(val0, val1, val2, val3: UInt32);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    public static function operator implicit(vt: ValueTuple<UInt32, UInt32, UInt32, UInt32>): Vec4ui := new Vec4ui(vt.Item1, vt.Item2, vt.Item3, vt.Item4);
    public static function operator implicit(v: Vec4ui): ValueTuple<UInt32, UInt32, UInt32, UInt32> := ValueTuple.Create(v.val0, v.val1, v.val2, v.val3);
    
    public static function Generate(gen: function(i: integer): UInt32): Vec4ui :=
      new Vec4ui(gen(0), gen(1), gen(2), gen(3));
    
    public static function Read(prompt: string := nil): Vec4ui;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec4ui;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function Random(a, b: UInt32): Vec4ui;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec4ui(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2, val3: UInt32);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
      val3 := self.val3;
    end;
    
    private static function ValStr(val: UInt32): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2); res += ', ';
      res += ValStr(val3);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec4ui;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec4ui;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): UInt32;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        3: Result := self.val3;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: UInt32; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        3: self.val3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    public property ValAt[i: integer]: UInt32 read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator+(v: Vec4ui) := v;
    
    public static function operator*(v: Vec4ui; k: UInt32) := new Vec4ui(v.val0 * k, v.val1 * k, v.val2 * k, v.val3 * k);
    public static function operator div(v: Vec4ui; k: UInt32) := new Vec4ui(v.val0 div k, v.val1 div k, v.val2 div k, v.val3 div k);
    
    public static function operator+(v1, v2: Vec4ui) := new Vec4ui(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2, v1.val3 + v2.val3);
    public static function operator-(v1, v2: Vec4ui) := new Vec4ui(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2, v1.val3 - v2.val3);
    public static function operator*(v1, v2: Vec4ui) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2 + v1.val3 * v2.val3;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec4ui = ^Vec4ui;
  
  Vec4ui64 = record
    public val0: UInt64;
    public val1: UInt64;
    public val2: UInt64;
    public val3: UInt64;
    
    public constructor(val0, val1, val2, val3: UInt64);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    public static function operator implicit(vt: ValueTuple<UInt64, UInt64, UInt64, UInt64>): Vec4ui64 := new Vec4ui64(vt.Item1, vt.Item2, vt.Item3, vt.Item4);
    public static function operator implicit(v: Vec4ui64): ValueTuple<UInt64, UInt64, UInt64, UInt64> := ValueTuple.Create(v.val0, v.val1, v.val2, v.val3);
    
    public static function Generate(gen: function(i: integer): UInt64): Vec4ui64 :=
      new Vec4ui64(gen(0), gen(1), gen(2), gen(3));
    
    public static function Read(prompt: string := nil): Vec4ui64;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec4ui64;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function Random(a, b: UInt64): Vec4ui64;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec4ui64(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2, val3: UInt64);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
      val3 := self.val3;
    end;
    
    private static function ValStr(val: UInt64): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2); res += ', ';
      res += ValStr(val3);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec4ui64;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec4ui64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): UInt64;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        3: Result := self.val3;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: UInt64; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        3: self.val3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    public property ValAt[i: integer]: UInt64 read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator+(v: Vec4ui64) := v;
    
    public static function operator*(v: Vec4ui64; k: UInt64) := new Vec4ui64(v.val0 * k, v.val1 * k, v.val2 * k, v.val3 * k);
    public static function operator div(v: Vec4ui64; k: UInt64) := new Vec4ui64(v.val0 div k, v.val1 div k, v.val2 div k, v.val3 div k);
    
    public static function operator+(v1, v2: Vec4ui64) := new Vec4ui64(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2, v1.val3 + v2.val3);
    public static function operator-(v1, v2: Vec4ui64) := new Vec4ui64(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2, v1.val3 - v2.val3);
    public static function operator*(v1, v2: Vec4ui64) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2 + v1.val3 * v2.val3;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec4ui64 = ^Vec4ui64;
  
  Vec4us = record
    public val0: UInt16;
    public val1: UInt16;
    public val2: UInt16;
    public val3: UInt16;
    
    public constructor(val0, val1, val2, val3: UInt16);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    public static function operator implicit(vt: ValueTuple<UInt16, UInt16, UInt16, UInt16>): Vec4us := new Vec4us(vt.Item1, vt.Item2, vt.Item3, vt.Item4);
    public static function operator implicit(v: Vec4us): ValueTuple<UInt16, UInt16, UInt16, UInt16> := ValueTuple.Create(v.val0, v.val1, v.val2, v.val3);
    
    public static function Generate(gen: function(i: integer): UInt16): Vec4us :=
      new Vec4us(gen(0), gen(1), gen(2), gen(3));
    
    public static function Read(prompt: string := nil): Vec4us;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.Read(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function ReadLn(prompt: string := nil): Vec4us;
    begin
      if prompt<>nil then
        prompt.Print;
      PABCSystem.ReadLn(Result.val0, Result.val1, Result.val2, Result.val3);
    end;
    
    public static function Random(a, b: UInt16): Vec4us;
    begin
      if a>b then Swap(a,b);
      var r := b-a+1;
      Result := new Vec4us(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val0, val1, val2, val3: UInt16);
    begin
      val0 := self.val0;
      val1 := self.val1;
      val2 := self.val2;
      val3 := self.val3;
    end;
    
    private static function ValStr(val: UInt16): string;
    begin
      Result := val.ToString;
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += ValStr(val0); res += ', ';
      res += ValStr(val1); res += ', ';
      res += ValStr(val2); res += ', ';
      res += ValStr(val3);
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Print: Vec4us;
    begin
      PABCSystem.Print(self.ToString);
      Result := self;
    end;
    
    public function PrintLn: Vec4us;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    private function GetValAt(i: integer; ind_name: string): UInt16;
    begin
      case i of
        0: Result := self.val0;
        1: Result := self.val1;
        2: Result := self.val2;
        3: Result := self.val3;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    end;
    private procedure SetValAt(i: integer; new_val: UInt16; ind_name: string) :=
      case i of
        0: self.val0 := new_val;
        1: self.val1 := new_val;
        2: self.val2 := new_val;
        3: self.val3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "{ind_name}" должен иметь значение 0..3');
      end;
    public property ValAt[i: integer]: UInt16 read GetValAt(i, 'i') write SetValAt(i, value, 'i');
    
    public static function operator+(v: Vec4us) := v;
    
    public static function operator*(v: Vec4us; k: UInt16) := new Vec4us(v.val0 * k, v.val1 * k, v.val2 * k, v.val3 * k);
    public static function operator div(v: Vec4us; k: UInt16) := new Vec4us(v.val0 div k, v.val1 div k, v.val2 div k, v.val3 div k);
    
    public static function operator+(v1, v2: Vec4us) := new Vec4us(v1.val0 + v2.val0, v1.val1 + v2.val1, v1.val2 + v2.val2, v1.val3 + v2.val3);
    public static function operator-(v1, v2: Vec4us) := new Vec4us(v1.val0 - v2.val0, v1.val1 - v2.val1, v1.val2 - v2.val2, v1.val3 - v2.val3);
    public static function operator*(v1, v2: Vec4us) := v1.val0 * v2.val0 + v1.val1 * v2.val1 + v1.val2 * v2.val2 + v1.val3 * v2.val3;
    
    public function SqrLength := self*self;
    public function Length := Sqrt(SqrLength);
    
  end;
  PVec4us = ^Vec4us;
  
  Mtr2x2d = record
    public val00, val10: double;
    public val01, val11: double;
    
    public constructor(val00, val01, val10, val11: double);
    begin
      self.val00 := val00; self.val01 := val01;
      self.val10 := val10; self.val11 := val11;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): double): Mtr2x2d :=
      Mtr2x2d.FromCols(new Vec2d(gen(0,0), gen(1,0)), new Vec2d(gen(0,1), gen(1,1)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec2d): Mtr2x2d :=
      Mtr2x2d.FromRows(gen(0), gen(1));
    public static function GenerateByCol(gen: function(col_i: integer): Vec2d): Mtr2x2d :=
      Mtr2x2d.FromCols(gen(0), gen(1));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec2d.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec2d.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec2d.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec2d.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: double): Mtr2x2d;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr2x2d(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val10, val11: double);
    begin
      val00 := self.val00; val01 := self.val01;
      val10 := self.val10; val11 := self.val11;
    end;
    
    public procedure DeconstructRows(var row0, row1: Vec2d);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
    end;
    public procedure Deconstruct(var row0, row1: Vec2d) := DeconstructRows(row0, row1);
    
    public procedure DeconstructCols(var col0, col1: Vec2d);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
    end;
    
    private static function ValStr(val: double): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var col_sz0 := s00.Length.ClampBottom(s10.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var col_sz1 := s01.Length.ClampBottom(s11.Length);
      var total_w := 4; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr2x2d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr2x2d read
      new Mtr2x2d(1, 0, 0, 1);
    
    public static function FromRows(row0, row1: Vec2d): Mtr2x2d;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
    end;
    
    public property Row0: Vec2d
      read new Vec2d(val00, val01)
      write value.Deconstruct(val00, val01);
    
    public property Row1: Vec2d
      read new Vec2d(val10, val11)
      write value.Deconstruct(val10, val11);
    
    private function GetRowAt(row_i: integer): Vec2d;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec2d) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..1');
      end;
    public property RowAt[row_i: integer]: Vec2d read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec2dCallback);
    begin
      use(Row0);
      use(Row1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec2dCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
    end;
    
    public static function FromCols(col0, col1: Vec2d): Mtr2x2d;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
    end;
    
    public property Col0: Vec2d
      read PVec2d(pointer(@val00))^
      write PVec2d(pointer(@val00))^ := value;
    
    public property Col1: Vec2d
      read PVec2d(pointer(@val01))^
      write PVec2d(pointer(@val01))^ := value;
    
    private function GetColAt(col_i: integer): Vec2d;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec2d) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    public property ColAt[col_i: integer]: Vec2d read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec2d := pointer(@val00);
    public function GetColUnsafePtr1: PVec2d := pointer(@val01);
    public function GetColUnsafePtrAt(col_i: integer): PVec2d;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec2dSafePtrCallback) := use(PVec2d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec2dSafePtrCallback) := use(PVec2d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec2dSafePtrCallback<T>) := conv(PVec2d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec2dSafePtrCallback<T>) := conv(PVec2d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec2dSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec2dSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec2dCallback);
    begin
      use(Col0);
      use(Col1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec2dCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec2dSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec2dSafePtrCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): double;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: double) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    public property ValAt[row_i, col_i: integer]: double read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
    public static function Scale(k: double) :=
      new Mtr2x2d(k, 0, 0, k);
    
    public static function TranslatePrefix(ΔX: double) :=
      new Mtr2x2d(1, ΔX, 0, 1);
    
    public static function TranslatePostfix(ΔX: double) :=
      new Mtr2x2d(1, 0, ΔX, 1);
    
    public static function RotatePrefixXY(radians: real): Mtr2x2d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec2d(+a_cos, +a_sin);
      Result.Col1 := new Vec2d(-a_sin, +a_cos);
    end;
    public static function RotatePostfixXY(radians: real): Mtr2x2d := RotatePrefixYX(radians);
    
    public static function RotatePrefixYX(radians: real): Mtr2x2d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec2d(+a_cos, -a_sin);
      Result.Col1 := new Vec2d(+a_sin, +a_cos);
    end;
    public static function RotatePostfixYX(radians: real): Mtr2x2d := RotatePrefixXY(radians);
    
    public function Determinant: double;
    begin
      Result := self.val00*self.val11 - self.val01*self.val10;
    end;
    
  end;
  Mtr2d = Mtr2x2d;
  
  Mtr2x2f = record
    public val00, val10: single;
    public val01, val11: single;
    
    public constructor(val00, val01, val10, val11: single);
    begin
      self.val00 := val00; self.val01 := val01;
      self.val10 := val10; self.val11 := val11;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): single): Mtr2x2f :=
      Mtr2x2f.FromCols(new Vec2f(gen(0,0), gen(1,0)), new Vec2f(gen(0,1), gen(1,1)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec2f): Mtr2x2f :=
      Mtr2x2f.FromRows(gen(0), gen(1));
    public static function GenerateByCol(gen: function(col_i: integer): Vec2f): Mtr2x2f :=
      Mtr2x2f.FromCols(gen(0), gen(1));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec2f.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec2f.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec2f.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec2f.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: single): Mtr2x2f;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr2x2f(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val10, val11: single);
    begin
      val00 := self.val00; val01 := self.val01;
      val10 := self.val10; val11 := self.val11;
    end;
    
    public procedure DeconstructRows(var row0, row1: Vec2f);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
    end;
    public procedure Deconstruct(var row0, row1: Vec2f) := DeconstructRows(row0, row1);
    
    public procedure DeconstructCols(var col0, col1: Vec2f);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
    end;
    
    private static function ValStr(val: single): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var col_sz0 := s00.Length.ClampBottom(s10.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var col_sz1 := s01.Length.ClampBottom(s11.Length);
      var total_w := 4; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr2x2f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr2x2f read
      new Mtr2x2f(1, 0, 0, 1);
    
    public static function FromRows(row0, row1: Vec2f): Mtr2x2f;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
    end;
    
    public property Row0: Vec2f
      read new Vec2f(val00, val01)
      write value.Deconstruct(val00, val01);
    
    public property Row1: Vec2f
      read new Vec2f(val10, val11)
      write value.Deconstruct(val10, val11);
    
    private function GetRowAt(row_i: integer): Vec2f;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec2f) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..1');
      end;
    public property RowAt[row_i: integer]: Vec2f read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec2fCallback);
    begin
      use(Row0);
      use(Row1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec2fCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
    end;
    
    public static function FromCols(col0, col1: Vec2f): Mtr2x2f;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
    end;
    
    public property Col0: Vec2f
      read PVec2f(pointer(@val00))^
      write PVec2f(pointer(@val00))^ := value;
    
    public property Col1: Vec2f
      read PVec2f(pointer(@val01))^
      write PVec2f(pointer(@val01))^ := value;
    
    private function GetColAt(col_i: integer): Vec2f;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec2f) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    public property ColAt[col_i: integer]: Vec2f read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec2f := pointer(@val00);
    public function GetColUnsafePtr1: PVec2f := pointer(@val01);
    public function GetColUnsafePtrAt(col_i: integer): PVec2f;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec2fSafePtrCallback) := use(PVec2f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec2fSafePtrCallback) := use(PVec2f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec2fSafePtrCallback<T>) := conv(PVec2f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec2fSafePtrCallback<T>) := conv(PVec2f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec2fSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec2fSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec2fCallback);
    begin
      use(Col0);
      use(Col1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec2fCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec2fSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec2fSafePtrCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): single;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: single) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    public property ValAt[row_i, col_i: integer]: single read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
    public static function Scale(k: single) :=
      new Mtr2x2f(k, 0, 0, k);
    
    public static function TranslatePrefix(ΔX: single) :=
      new Mtr2x2f(1, ΔX, 0, 1);
    
    public static function TranslatePostfix(ΔX: single) :=
      new Mtr2x2f(1, 0, ΔX, 1);
    
    public static function RotatePrefixXY(radians: real): Mtr2x2f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec2f(+a_cos, +a_sin);
      Result.Col1 := new Vec2f(-a_sin, +a_cos);
    end;
    public static function RotatePostfixXY(radians: real): Mtr2x2f := RotatePrefixYX(radians);
    
    public static function RotatePrefixYX(radians: real): Mtr2x2f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec2f(+a_cos, -a_sin);
      Result.Col1 := new Vec2f(+a_sin, +a_cos);
    end;
    public static function RotatePostfixYX(radians: real): Mtr2x2f := RotatePrefixXY(radians);
    
    public function Determinant: single;
    begin
      Result := self.val00*self.val11 - self.val01*self.val10;
    end;
    
  end;
  Mtr2f = Mtr2x2f;
  
  Mtr2x3d = record
    public val00, val10: double;
    public val01, val11: double;
    public val02, val12: double;
    
    public constructor(val00, val01, val02, val10, val11, val12: double);
    begin
      self.val00 := val00; self.val01 := val01; self.val02 := val02;
      self.val10 := val10; self.val11 := val11; self.val12 := val12;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): double): Mtr2x3d :=
      Mtr2x3d.FromCols(new Vec2d(gen(0,0), gen(1,0)), new Vec2d(gen(0,1), gen(1,1)), new Vec2d(gen(0,2), gen(1,2)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec3d): Mtr2x3d :=
      Mtr2x3d.FromRows(gen(0), gen(1));
    public static function GenerateByCol(gen: function(col_i: integer): Vec2d): Mtr2x3d :=
      Mtr2x3d.FromCols(gen(0), gen(1), gen(2));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec3d.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec2d.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec3d.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec2d.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: double): Mtr2x3d;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr2x3d(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val02, val10, val11, val12: double);
    begin
      val00 := self.val00; val01 := self.val01; val02 := self.val02;
      val10 := self.val10; val11 := self.val11; val12 := self.val12;
    end;
    
    public procedure DeconstructRows(var row0, row1: Vec3d);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
    end;
    public procedure Deconstruct(var row0, row1: Vec3d) := DeconstructRows(row0, row1);
    
    public procedure DeconstructCols(var col0, col1, col2: Vec2d);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
      col2 := self.Col2;
    end;
    public procedure Deconstruct(var col0, col1, col2: Vec2d) := DeconstructCols(col0, col1, col2);
    
    private static function ValStr(val: double): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var col_sz0 := s00.Length.ClampBottom(s10.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var col_sz1 := s01.Length.ClampBottom(s11.Length);
      var s02 := ValStr(val02); var s12 := ValStr(val12); var col_sz2 := s02.Length.ClampBottom(s12.Length);
      var total_w := 6; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      total_w += col_sz2;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01; res += ', ';
      res.Append(' ', col_sz2 - s02.Length); res += s02;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11; res += ', ';
      res.Append(' ', col_sz2 - s12.Length); res += s12;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr2x3d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr2x3d read
      new Mtr2x3d(1, 0, 0, 0, 1, 0);
    public static property IdentityKeepLast: Mtr2x3d read
      new Mtr2x3d(1, 0, 0, 0, 0, 1);
    
    public static function FromRows(row0, row1: Vec3d): Mtr2x3d;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
    end;
    
    public property Row0: Vec3d
      read new Vec3d(val00, val01, val02)
      write value.Deconstruct(val00, val01, val02);
    
    public property Row1: Vec3d
      read new Vec3d(val10, val11, val12)
      write value.Deconstruct(val10, val11, val12);
    
    private function GetRowAt(row_i: integer): Vec3d;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec3d) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..1');
      end;
    public property RowAt[row_i: integer]: Vec3d read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec3dCallback);
    begin
      use(Row0);
      use(Row1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec3dCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
    end;
    
    public static function FromCols(col0, col1, col2: Vec2d): Mtr2x3d;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
      Result.Col2 := col2;
    end;
    
    public property Col0: Vec2d
      read PVec2d(pointer(@val00))^
      write PVec2d(pointer(@val00))^ := value;
    
    public property Col1: Vec2d
      read PVec2d(pointer(@val01))^
      write PVec2d(pointer(@val01))^ := value;
    
    public property Col2: Vec2d
      read PVec2d(pointer(@val02))^
      write PVec2d(pointer(@val02))^ := value;
    
    private function GetColAt(col_i: integer): Vec2d;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        2: Result := Col2;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec2d) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        2: Col2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    public property ColAt[col_i: integer]: Vec2d read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec2d := pointer(@val00);
    public function GetColUnsafePtr1: PVec2d := pointer(@val01);
    public function GetColUnsafePtr2: PVec2d := pointer(@val02);
    public function GetColUnsafePtrAt(col_i: integer): PVec2d;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        2: Result := GetColUnsafePtr2;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec2dSafePtrCallback) := use(PVec2d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec2dSafePtrCallback) := use(PVec2d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol2SafePtr(use: UseVec2dSafePtrCallback) := use(PVec2d(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec2dSafePtrCallback<T>) := conv(PVec2d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec2dSafePtrCallback<T>) := conv(PVec2d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol2SafePtr<T>(conv: ConvVec2dSafePtrCallback<T>) := conv(PVec2d(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec2dSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        2: UseCol2SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec2dSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        2: Result := ConvCol2SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec2dCallback);
    begin
      use(Col0);
      use(Col1);
      use(Col2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec2dCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
      Result.Item3 := conv(Col2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec2dSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
      UseCol2SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec2dSafePtrCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
      Result.Item3 := ConvCol2SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): double;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        2: Result := self.Col2.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: double) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        2: begin var col := self.Col2; col.SetValAt(row_i, new_val, 'row_i'); self.Col2 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    public property ValAt[row_i, col_i: integer]: double read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
  end;
  
  Mtr2x3f = record
    public val00, val10: single;
    public val01, val11: single;
    public val02, val12: single;
    
    public constructor(val00, val01, val02, val10, val11, val12: single);
    begin
      self.val00 := val00; self.val01 := val01; self.val02 := val02;
      self.val10 := val10; self.val11 := val11; self.val12 := val12;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): single): Mtr2x3f :=
      Mtr2x3f.FromCols(new Vec2f(gen(0,0), gen(1,0)), new Vec2f(gen(0,1), gen(1,1)), new Vec2f(gen(0,2), gen(1,2)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec3f): Mtr2x3f :=
      Mtr2x3f.FromRows(gen(0), gen(1));
    public static function GenerateByCol(gen: function(col_i: integer): Vec2f): Mtr2x3f :=
      Mtr2x3f.FromCols(gen(0), gen(1), gen(2));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec3f.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec2f.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec3f.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec2f.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: single): Mtr2x3f;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr2x3f(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val02, val10, val11, val12: single);
    begin
      val00 := self.val00; val01 := self.val01; val02 := self.val02;
      val10 := self.val10; val11 := self.val11; val12 := self.val12;
    end;
    
    public procedure DeconstructRows(var row0, row1: Vec3f);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
    end;
    public procedure Deconstruct(var row0, row1: Vec3f) := DeconstructRows(row0, row1);
    
    public procedure DeconstructCols(var col0, col1, col2: Vec2f);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
      col2 := self.Col2;
    end;
    public procedure Deconstruct(var col0, col1, col2: Vec2f) := DeconstructCols(col0, col1, col2);
    
    private static function ValStr(val: single): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var col_sz0 := s00.Length.ClampBottom(s10.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var col_sz1 := s01.Length.ClampBottom(s11.Length);
      var s02 := ValStr(val02); var s12 := ValStr(val12); var col_sz2 := s02.Length.ClampBottom(s12.Length);
      var total_w := 6; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      total_w += col_sz2;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01; res += ', ';
      res.Append(' ', col_sz2 - s02.Length); res += s02;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11; res += ', ';
      res.Append(' ', col_sz2 - s12.Length); res += s12;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr2x3f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr2x3f read
      new Mtr2x3f(1, 0, 0, 0, 1, 0);
    public static property IdentityKeepLast: Mtr2x3f read
      new Mtr2x3f(1, 0, 0, 0, 0, 1);
    
    public static function FromRows(row0, row1: Vec3f): Mtr2x3f;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
    end;
    
    public property Row0: Vec3f
      read new Vec3f(val00, val01, val02)
      write value.Deconstruct(val00, val01, val02);
    
    public property Row1: Vec3f
      read new Vec3f(val10, val11, val12)
      write value.Deconstruct(val10, val11, val12);
    
    private function GetRowAt(row_i: integer): Vec3f;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec3f) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..1');
      end;
    public property RowAt[row_i: integer]: Vec3f read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec3fCallback);
    begin
      use(Row0);
      use(Row1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec3fCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
    end;
    
    public static function FromCols(col0, col1, col2: Vec2f): Mtr2x3f;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
      Result.Col2 := col2;
    end;
    
    public property Col0: Vec2f
      read PVec2f(pointer(@val00))^
      write PVec2f(pointer(@val00))^ := value;
    
    public property Col1: Vec2f
      read PVec2f(pointer(@val01))^
      write PVec2f(pointer(@val01))^ := value;
    
    public property Col2: Vec2f
      read PVec2f(pointer(@val02))^
      write PVec2f(pointer(@val02))^ := value;
    
    private function GetColAt(col_i: integer): Vec2f;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        2: Result := Col2;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec2f) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        2: Col2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    public property ColAt[col_i: integer]: Vec2f read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec2f := pointer(@val00);
    public function GetColUnsafePtr1: PVec2f := pointer(@val01);
    public function GetColUnsafePtr2: PVec2f := pointer(@val02);
    public function GetColUnsafePtrAt(col_i: integer): PVec2f;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        2: Result := GetColUnsafePtr2;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec2fSafePtrCallback) := use(PVec2f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec2fSafePtrCallback) := use(PVec2f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol2SafePtr(use: UseVec2fSafePtrCallback) := use(PVec2f(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec2fSafePtrCallback<T>) := conv(PVec2f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec2fSafePtrCallback<T>) := conv(PVec2f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol2SafePtr<T>(conv: ConvVec2fSafePtrCallback<T>) := conv(PVec2f(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec2fSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        2: UseCol2SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec2fSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        2: Result := ConvCol2SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec2fCallback);
    begin
      use(Col0);
      use(Col1);
      use(Col2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec2fCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
      Result.Item3 := conv(Col2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec2fSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
      UseCol2SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec2fSafePtrCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
      Result.Item3 := ConvCol2SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): single;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        2: Result := self.Col2.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: single) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        2: begin var col := self.Col2; col.SetValAt(row_i, new_val, 'row_i'); self.Col2 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    public property ValAt[row_i, col_i: integer]: single read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
  end;
  
  Mtr2x4d = record
    public val00, val10: double;
    public val01, val11: double;
    public val02, val12: double;
    public val03, val13: double;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13: double);
    begin
      self.val00 := val00; self.val01 := val01; self.val02 := val02; self.val03 := val03;
      self.val10 := val10; self.val11 := val11; self.val12 := val12; self.val13 := val13;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): double): Mtr2x4d :=
      Mtr2x4d.FromCols(new Vec2d(gen(0,0), gen(1,0)), new Vec2d(gen(0,1), gen(1,1)), new Vec2d(gen(0,2), gen(1,2)), new Vec2d(gen(0,3), gen(1,3)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec4d): Mtr2x4d :=
      Mtr2x4d.FromRows(gen(0), gen(1));
    public static function GenerateByCol(gen: function(col_i: integer): Vec2d): Mtr2x4d :=
      Mtr2x4d.FromCols(gen(0), gen(1), gen(2), gen(3));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec4d.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec2d.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec4d.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec2d.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: double): Mtr2x4d;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr2x4d(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val02, val03, val10, val11, val12, val13: double);
    begin
      val00 := self.val00; val01 := self.val01; val02 := self.val02; val03 := self.val03;
      val10 := self.val10; val11 := self.val11; val12 := self.val12; val13 := self.val13;
    end;
    
    public procedure DeconstructRows(var row0, row1: Vec4d);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
    end;
    public procedure Deconstruct(var row0, row1: Vec4d) := DeconstructRows(row0, row1);
    
    public procedure DeconstructCols(var col0, col1, col2, col3: Vec2d);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
      col2 := self.Col2;
      col3 := self.Col3;
    end;
    public procedure Deconstruct(var col0, col1, col2, col3: Vec2d) := DeconstructCols(col0, col1, col2, col3);
    
    private static function ValStr(val: double): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var col_sz0 := s00.Length.ClampBottom(s10.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var col_sz1 := s01.Length.ClampBottom(s11.Length);
      var s02 := ValStr(val02); var s12 := ValStr(val12); var col_sz2 := s02.Length.ClampBottom(s12.Length);
      var s03 := ValStr(val03); var s13 := ValStr(val13); var col_sz3 := s03.Length.ClampBottom(s13.Length);
      var total_w := 8; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      total_w += col_sz2;
      total_w += col_sz3;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01; res += ', ';
      res.Append(' ', col_sz2 - s02.Length); res += s02; res += ', ';
      res.Append(' ', col_sz3 - s03.Length); res += s03;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11; res += ', ';
      res.Append(' ', col_sz2 - s12.Length); res += s12; res += ', ';
      res.Append(' ', col_sz3 - s13.Length); res += s13;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr2x4d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr2x4d read
      new Mtr2x4d(1, 0, 0, 0, 0, 1, 0, 0);
    public static property IdentityKeepLast: Mtr2x4d read
      new Mtr2x4d(1, 0, 0, 0, 0, 0, 0, 1);
    
    public static function FromRows(row0, row1: Vec4d): Mtr2x4d;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
    end;
    
    public property Row0: Vec4d
      read new Vec4d(val00, val01, val02, val03)
      write value.Deconstruct(val00, val01, val02, val03);
    
    public property Row1: Vec4d
      read new Vec4d(val10, val11, val12, val13)
      write value.Deconstruct(val10, val11, val12, val13);
    
    private function GetRowAt(row_i: integer): Vec4d;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec4d) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..1');
      end;
    public property RowAt[row_i: integer]: Vec4d read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec4dCallback);
    begin
      use(Row0);
      use(Row1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec4dCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
    end;
    
    public static function FromCols(col0, col1, col2, col3: Vec2d): Mtr2x4d;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
      Result.Col2 := col2;
      Result.Col3 := col3;
    end;
    
    public property Col0: Vec2d
      read PVec2d(pointer(@val00))^
      write PVec2d(pointer(@val00))^ := value;
    
    public property Col1: Vec2d
      read PVec2d(pointer(@val01))^
      write PVec2d(pointer(@val01))^ := value;
    
    public property Col2: Vec2d
      read PVec2d(pointer(@val02))^
      write PVec2d(pointer(@val02))^ := value;
    
    public property Col3: Vec2d
      read PVec2d(pointer(@val03))^
      write PVec2d(pointer(@val03))^ := value;
    
    private function GetColAt(col_i: integer): Vec2d;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        2: Result := Col2;
        3: Result := Col3;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec2d) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        2: Col2 := new_val;
        3: Col3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    public property ColAt[col_i: integer]: Vec2d read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec2d := pointer(@val00);
    public function GetColUnsafePtr1: PVec2d := pointer(@val01);
    public function GetColUnsafePtr2: PVec2d := pointer(@val02);
    public function GetColUnsafePtr3: PVec2d := pointer(@val03);
    public function GetColUnsafePtrAt(col_i: integer): PVec2d;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        2: Result := GetColUnsafePtr2;
        3: Result := GetColUnsafePtr3;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec2dSafePtrCallback) := use(PVec2d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec2dSafePtrCallback) := use(PVec2d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol2SafePtr(use: UseVec2dSafePtrCallback) := use(PVec2d(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol3SafePtr(use: UseVec2dSafePtrCallback) := use(PVec2d(pointer(@val03))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec2dSafePtrCallback<T>) := conv(PVec2d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec2dSafePtrCallback<T>) := conv(PVec2d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol2SafePtr<T>(conv: ConvVec2dSafePtrCallback<T>) := conv(PVec2d(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol3SafePtr<T>(conv: ConvVec2dSafePtrCallback<T>) := conv(PVec2d(pointer(@val03))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec2dSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        2: UseCol2SafePtr(use);
        3: UseCol3SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec2dSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        2: Result := ConvCol2SafePtr(conv);
        3: Result := ConvCol3SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec2dCallback);
    begin
      use(Col0);
      use(Col1);
      use(Col2);
      use(Col3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec2dCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
      Result.Item3 := conv(Col2);
      Result.Item4 := conv(Col3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec2dSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
      UseCol2SafePtr(use);
      UseCol3SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec2dSafePtrCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
      Result.Item3 := ConvCol2SafePtr(conv);
      Result.Item4 := ConvCol3SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): double;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        2: Result := self.Col2.GetValAt(row_i, 'row_i');
        3: Result := self.Col3.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: double) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        2: begin var col := self.Col2; col.SetValAt(row_i, new_val, 'row_i'); self.Col2 := col; end;
        3: begin var col := self.Col3; col.SetValAt(row_i, new_val, 'row_i'); self.Col3 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    public property ValAt[row_i, col_i: integer]: double read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
  end;
  
  Mtr2x4f = record
    public val00, val10: single;
    public val01, val11: single;
    public val02, val12: single;
    public val03, val13: single;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13: single);
    begin
      self.val00 := val00; self.val01 := val01; self.val02 := val02; self.val03 := val03;
      self.val10 := val10; self.val11 := val11; self.val12 := val12; self.val13 := val13;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): single): Mtr2x4f :=
      Mtr2x4f.FromCols(new Vec2f(gen(0,0), gen(1,0)), new Vec2f(gen(0,1), gen(1,1)), new Vec2f(gen(0,2), gen(1,2)), new Vec2f(gen(0,3), gen(1,3)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec4f): Mtr2x4f :=
      Mtr2x4f.FromRows(gen(0), gen(1));
    public static function GenerateByCol(gen: function(col_i: integer): Vec2f): Mtr2x4f :=
      Mtr2x4f.FromCols(gen(0), gen(1), gen(2), gen(3));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec4f.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec2f.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec4f.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec2f.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: single): Mtr2x4f;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr2x4f(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val02, val03, val10, val11, val12, val13: single);
    begin
      val00 := self.val00; val01 := self.val01; val02 := self.val02; val03 := self.val03;
      val10 := self.val10; val11 := self.val11; val12 := self.val12; val13 := self.val13;
    end;
    
    public procedure DeconstructRows(var row0, row1: Vec4f);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
    end;
    public procedure Deconstruct(var row0, row1: Vec4f) := DeconstructRows(row0, row1);
    
    public procedure DeconstructCols(var col0, col1, col2, col3: Vec2f);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
      col2 := self.Col2;
      col3 := self.Col3;
    end;
    public procedure Deconstruct(var col0, col1, col2, col3: Vec2f) := DeconstructCols(col0, col1, col2, col3);
    
    private static function ValStr(val: single): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var col_sz0 := s00.Length.ClampBottom(s10.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var col_sz1 := s01.Length.ClampBottom(s11.Length);
      var s02 := ValStr(val02); var s12 := ValStr(val12); var col_sz2 := s02.Length.ClampBottom(s12.Length);
      var s03 := ValStr(val03); var s13 := ValStr(val13); var col_sz3 := s03.Length.ClampBottom(s13.Length);
      var total_w := 8; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      total_w += col_sz2;
      total_w += col_sz3;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01; res += ', ';
      res.Append(' ', col_sz2 - s02.Length); res += s02; res += ', ';
      res.Append(' ', col_sz3 - s03.Length); res += s03;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11; res += ', ';
      res.Append(' ', col_sz2 - s12.Length); res += s12; res += ', ';
      res.Append(' ', col_sz3 - s13.Length); res += s13;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr2x4f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr2x4f read
      new Mtr2x4f(1, 0, 0, 0, 0, 1, 0, 0);
    public static property IdentityKeepLast: Mtr2x4f read
      new Mtr2x4f(1, 0, 0, 0, 0, 0, 0, 1);
    
    public static function FromRows(row0, row1: Vec4f): Mtr2x4f;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
    end;
    
    public property Row0: Vec4f
      read new Vec4f(val00, val01, val02, val03)
      write value.Deconstruct(val00, val01, val02, val03);
    
    public property Row1: Vec4f
      read new Vec4f(val10, val11, val12, val13)
      write value.Deconstruct(val10, val11, val12, val13);
    
    private function GetRowAt(row_i: integer): Vec4f;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec4f) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..1');
      end;
    public property RowAt[row_i: integer]: Vec4f read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec4fCallback);
    begin
      use(Row0);
      use(Row1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec4fCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
    end;
    
    public static function FromCols(col0, col1, col2, col3: Vec2f): Mtr2x4f;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
      Result.Col2 := col2;
      Result.Col3 := col3;
    end;
    
    public property Col0: Vec2f
      read PVec2f(pointer(@val00))^
      write PVec2f(pointer(@val00))^ := value;
    
    public property Col1: Vec2f
      read PVec2f(pointer(@val01))^
      write PVec2f(pointer(@val01))^ := value;
    
    public property Col2: Vec2f
      read PVec2f(pointer(@val02))^
      write PVec2f(pointer(@val02))^ := value;
    
    public property Col3: Vec2f
      read PVec2f(pointer(@val03))^
      write PVec2f(pointer(@val03))^ := value;
    
    private function GetColAt(col_i: integer): Vec2f;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        2: Result := Col2;
        3: Result := Col3;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec2f) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        2: Col2 := new_val;
        3: Col3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    public property ColAt[col_i: integer]: Vec2f read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec2f := pointer(@val00);
    public function GetColUnsafePtr1: PVec2f := pointer(@val01);
    public function GetColUnsafePtr2: PVec2f := pointer(@val02);
    public function GetColUnsafePtr3: PVec2f := pointer(@val03);
    public function GetColUnsafePtrAt(col_i: integer): PVec2f;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        2: Result := GetColUnsafePtr2;
        3: Result := GetColUnsafePtr3;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec2fSafePtrCallback) := use(PVec2f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec2fSafePtrCallback) := use(PVec2f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol2SafePtr(use: UseVec2fSafePtrCallback) := use(PVec2f(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol3SafePtr(use: UseVec2fSafePtrCallback) := use(PVec2f(pointer(@val03))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec2fSafePtrCallback<T>) := conv(PVec2f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec2fSafePtrCallback<T>) := conv(PVec2f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol2SafePtr<T>(conv: ConvVec2fSafePtrCallback<T>) := conv(PVec2f(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol3SafePtr<T>(conv: ConvVec2fSafePtrCallback<T>) := conv(PVec2f(pointer(@val03))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec2fSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        2: UseCol2SafePtr(use);
        3: UseCol3SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec2fSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        2: Result := ConvCol2SafePtr(conv);
        3: Result := ConvCol3SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec2fCallback);
    begin
      use(Col0);
      use(Col1);
      use(Col2);
      use(Col3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec2fCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
      Result.Item3 := conv(Col2);
      Result.Item4 := conv(Col3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec2fSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
      UseCol2SafePtr(use);
      UseCol3SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec2fSafePtrCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
      Result.Item3 := ConvCol2SafePtr(conv);
      Result.Item4 := ConvCol3SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): single;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        2: Result := self.Col2.GetValAt(row_i, 'row_i');
        3: Result := self.Col3.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: single) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        2: begin var col := self.Col2; col.SetValAt(row_i, new_val, 'row_i'); self.Col2 := col; end;
        3: begin var col := self.Col3; col.SetValAt(row_i, new_val, 'row_i'); self.Col3 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    public property ValAt[row_i, col_i: integer]: single read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
  end;
  
  Mtr3x2d = record
    public val00, val10, val20: double;
    public val01, val11, val21: double;
    
    public constructor(val00, val01, val10, val11, val20, val21: double);
    begin
      self.val00 := val00; self.val01 := val01;
      self.val10 := val10; self.val11 := val11;
      self.val20 := val20; self.val21 := val21;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): double): Mtr3x2d :=
      Mtr3x2d.FromCols(new Vec3d(gen(0,0), gen(1,0), gen(2,0)), new Vec3d(gen(0,1), gen(1,1), gen(2,1)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec2d): Mtr3x2d :=
      Mtr3x2d.FromRows(gen(0), gen(1), gen(2));
    public static function GenerateByCol(gen: function(col_i: integer): Vec3d): Mtr3x2d :=
      Mtr3x2d.FromCols(gen(0), gen(1));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec2d.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec3d.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec2d.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec3d.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: double): Mtr3x2d;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr3x2d(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val10, val11, val20, val21: double);
    begin
      val00 := self.val00; val01 := self.val01;
      val10 := self.val10; val11 := self.val11;
      val20 := self.val20; val21 := self.val21;
    end;
    
    public procedure DeconstructRows(var row0, row1, row2: Vec2d);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
      row2 := self.Row2;
    end;
    public procedure Deconstruct(var row0, row1, row2: Vec2d) := DeconstructRows(row0, row1, row2);
    
    public procedure DeconstructCols(var col0, col1: Vec3d);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
    end;
    public procedure Deconstruct(var col0, col1: Vec3d) := DeconstructCols(col0, col1);
    
    private static function ValStr(val: double): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var s20 := ValStr(val20); var col_sz0 := s00.Length.ClampBottom(s10.Length).ClampBottom(s20.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var s21 := ValStr(val21); var col_sz1 := s01.Length.ClampBottom(s11.Length).ClampBottom(s21.Length);
      var total_w := 4; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s20.Length); res += s20; res += ', ';
      res.Append(' ', col_sz1 - s21.Length); res += s21;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr3x2d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr3x2d read
      new Mtr3x2d(1, 0, 0, 1, 0, 0);
    public static property IdentityKeepLast: Mtr3x2d read
      new Mtr3x2d(1, 0, 0, 0, 0, 1);
    
    public static function FromRows(row0, row1, row2: Vec2d): Mtr3x2d;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
      Result.Row2 := row2;
    end;
    
    public property Row0: Vec2d
      read new Vec2d(val00, val01)
      write value.Deconstruct(val00, val01);
    
    public property Row1: Vec2d
      read new Vec2d(val10, val11)
      write value.Deconstruct(val10, val11);
    
    public property Row2: Vec2d
      read new Vec2d(val20, val21)
      write value.Deconstruct(val20, val21);
    
    private function GetRowAt(row_i: integer): Vec2d;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        2: Result := Row2;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec2d) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        2: Row2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..2');
      end;
    public property RowAt[row_i: integer]: Vec2d read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec2dCallback);
    begin
      use(Row0);
      use(Row1);
      use(Row2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec2dCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
      Result.Item3 := conv(Row2);
    end;
    
    public static function FromCols(col0, col1: Vec3d): Mtr3x2d;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
    end;
    
    public property Col0: Vec3d
      read PVec3d(pointer(@val00))^
      write PVec3d(pointer(@val00))^ := value;
    
    public property Col1: Vec3d
      read PVec3d(pointer(@val01))^
      write PVec3d(pointer(@val01))^ := value;
    
    private function GetColAt(col_i: integer): Vec3d;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec3d) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    public property ColAt[col_i: integer]: Vec3d read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec3d := pointer(@val00);
    public function GetColUnsafePtr1: PVec3d := pointer(@val01);
    public function GetColUnsafePtrAt(col_i: integer): PVec3d;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec3dSafePtrCallback) := use(PVec3d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec3dSafePtrCallback) := use(PVec3d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec3dSafePtrCallback<T>) := conv(PVec3d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec3dSafePtrCallback<T>) := conv(PVec3d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec3dSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec3dSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec3dCallback);
    begin
      use(Col0);
      use(Col1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec3dCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec3dSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec3dSafePtrCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): double;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: double) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    public property ValAt[row_i, col_i: integer]: double read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
  end;
  
  Mtr3x2f = record
    public val00, val10, val20: single;
    public val01, val11, val21: single;
    
    public constructor(val00, val01, val10, val11, val20, val21: single);
    begin
      self.val00 := val00; self.val01 := val01;
      self.val10 := val10; self.val11 := val11;
      self.val20 := val20; self.val21 := val21;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): single): Mtr3x2f :=
      Mtr3x2f.FromCols(new Vec3f(gen(0,0), gen(1,0), gen(2,0)), new Vec3f(gen(0,1), gen(1,1), gen(2,1)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec2f): Mtr3x2f :=
      Mtr3x2f.FromRows(gen(0), gen(1), gen(2));
    public static function GenerateByCol(gen: function(col_i: integer): Vec3f): Mtr3x2f :=
      Mtr3x2f.FromCols(gen(0), gen(1));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec2f.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec3f.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec2f.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec3f.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: single): Mtr3x2f;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr3x2f(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val10, val11, val20, val21: single);
    begin
      val00 := self.val00; val01 := self.val01;
      val10 := self.val10; val11 := self.val11;
      val20 := self.val20; val21 := self.val21;
    end;
    
    public procedure DeconstructRows(var row0, row1, row2: Vec2f);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
      row2 := self.Row2;
    end;
    public procedure Deconstruct(var row0, row1, row2: Vec2f) := DeconstructRows(row0, row1, row2);
    
    public procedure DeconstructCols(var col0, col1: Vec3f);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
    end;
    public procedure Deconstruct(var col0, col1: Vec3f) := DeconstructCols(col0, col1);
    
    private static function ValStr(val: single): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var s20 := ValStr(val20); var col_sz0 := s00.Length.ClampBottom(s10.Length).ClampBottom(s20.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var s21 := ValStr(val21); var col_sz1 := s01.Length.ClampBottom(s11.Length).ClampBottom(s21.Length);
      var total_w := 4; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s20.Length); res += s20; res += ', ';
      res.Append(' ', col_sz1 - s21.Length); res += s21;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr3x2f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr3x2f read
      new Mtr3x2f(1, 0, 0, 1, 0, 0);
    public static property IdentityKeepLast: Mtr3x2f read
      new Mtr3x2f(1, 0, 0, 0, 0, 1);
    
    public static function FromRows(row0, row1, row2: Vec2f): Mtr3x2f;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
      Result.Row2 := row2;
    end;
    
    public property Row0: Vec2f
      read new Vec2f(val00, val01)
      write value.Deconstruct(val00, val01);
    
    public property Row1: Vec2f
      read new Vec2f(val10, val11)
      write value.Deconstruct(val10, val11);
    
    public property Row2: Vec2f
      read new Vec2f(val20, val21)
      write value.Deconstruct(val20, val21);
    
    private function GetRowAt(row_i: integer): Vec2f;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        2: Result := Row2;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec2f) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        2: Row2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..2');
      end;
    public property RowAt[row_i: integer]: Vec2f read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec2fCallback);
    begin
      use(Row0);
      use(Row1);
      use(Row2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec2fCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
      Result.Item3 := conv(Row2);
    end;
    
    public static function FromCols(col0, col1: Vec3f): Mtr3x2f;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
    end;
    
    public property Col0: Vec3f
      read PVec3f(pointer(@val00))^
      write PVec3f(pointer(@val00))^ := value;
    
    public property Col1: Vec3f
      read PVec3f(pointer(@val01))^
      write PVec3f(pointer(@val01))^ := value;
    
    private function GetColAt(col_i: integer): Vec3f;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec3f) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    public property ColAt[col_i: integer]: Vec3f read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec3f := pointer(@val00);
    public function GetColUnsafePtr1: PVec3f := pointer(@val01);
    public function GetColUnsafePtrAt(col_i: integer): PVec3f;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec3fSafePtrCallback) := use(PVec3f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec3fSafePtrCallback) := use(PVec3f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec3fSafePtrCallback<T>) := conv(PVec3f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec3fSafePtrCallback<T>) := conv(PVec3f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec3fSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec3fSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec3fCallback);
    begin
      use(Col0);
      use(Col1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec3fCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec3fSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec3fSafePtrCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): single;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: single) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    public property ValAt[row_i, col_i: integer]: single read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
  end;
  
  Mtr3x3d = record
    public val00, val10, val20: double;
    public val01, val11, val21: double;
    public val02, val12, val22: double;
    
    public constructor(val00, val01, val02, val10, val11, val12, val20, val21, val22: double);
    begin
      self.val00 := val00; self.val01 := val01; self.val02 := val02;
      self.val10 := val10; self.val11 := val11; self.val12 := val12;
      self.val20 := val20; self.val21 := val21; self.val22 := val22;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): double): Mtr3x3d :=
      Mtr3x3d.FromCols(new Vec3d(gen(0,0), gen(1,0), gen(2,0)), new Vec3d(gen(0,1), gen(1,1), gen(2,1)), new Vec3d(gen(0,2), gen(1,2), gen(2,2)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec3d): Mtr3x3d :=
      Mtr3x3d.FromRows(gen(0), gen(1), gen(2));
    public static function GenerateByCol(gen: function(col_i: integer): Vec3d): Mtr3x3d :=
      Mtr3x3d.FromCols(gen(0), gen(1), gen(2));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec3d.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec3d.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec3d.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec3d.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: double): Mtr3x3d;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr3x3d(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val02, val10, val11, val12, val20, val21, val22: double);
    begin
      val00 := self.val00; val01 := self.val01; val02 := self.val02;
      val10 := self.val10; val11 := self.val11; val12 := self.val12;
      val20 := self.val20; val21 := self.val21; val22 := self.val22;
    end;
    
    public procedure DeconstructRows(var row0, row1, row2: Vec3d);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
      row2 := self.Row2;
    end;
    public procedure Deconstruct(var row0, row1, row2: Vec3d) := DeconstructRows(row0, row1, row2);
    
    public procedure DeconstructCols(var col0, col1, col2: Vec3d);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
      col2 := self.Col2;
    end;
    
    private static function ValStr(val: double): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var s20 := ValStr(val20); var col_sz0 := s00.Length.ClampBottom(s10.Length).ClampBottom(s20.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var s21 := ValStr(val21); var col_sz1 := s01.Length.ClampBottom(s11.Length).ClampBottom(s21.Length);
      var s02 := ValStr(val02); var s12 := ValStr(val12); var s22 := ValStr(val22); var col_sz2 := s02.Length.ClampBottom(s12.Length).ClampBottom(s22.Length);
      var total_w := 6; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      total_w += col_sz2;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01; res += ', ';
      res.Append(' ', col_sz2 - s02.Length); res += s02;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11; res += ', ';
      res.Append(' ', col_sz2 - s12.Length); res += s12;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s20.Length); res += s20; res += ', ';
      res.Append(' ', col_sz1 - s21.Length); res += s21; res += ', ';
      res.Append(' ', col_sz2 - s22.Length); res += s22;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr3x3d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr3x3d read
      new Mtr3x3d(1, 0, 0, 0, 1, 0, 0, 0, 1);
    
    public static function FromRows(row0, row1, row2: Vec3d): Mtr3x3d;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
      Result.Row2 := row2;
    end;
    
    public property Row0: Vec3d
      read new Vec3d(val00, val01, val02)
      write value.Deconstruct(val00, val01, val02);
    
    public property Row1: Vec3d
      read new Vec3d(val10, val11, val12)
      write value.Deconstruct(val10, val11, val12);
    
    public property Row2: Vec3d
      read new Vec3d(val20, val21, val22)
      write value.Deconstruct(val20, val21, val22);
    
    private function GetRowAt(row_i: integer): Vec3d;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        2: Result := Row2;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec3d) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        2: Row2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..2');
      end;
    public property RowAt[row_i: integer]: Vec3d read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec3dCallback);
    begin
      use(Row0);
      use(Row1);
      use(Row2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec3dCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
      Result.Item3 := conv(Row2);
    end;
    
    public static function FromCols(col0, col1, col2: Vec3d): Mtr3x3d;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
      Result.Col2 := col2;
    end;
    
    public property Col0: Vec3d
      read PVec3d(pointer(@val00))^
      write PVec3d(pointer(@val00))^ := value;
    
    public property Col1: Vec3d
      read PVec3d(pointer(@val01))^
      write PVec3d(pointer(@val01))^ := value;
    
    public property Col2: Vec3d
      read PVec3d(pointer(@val02))^
      write PVec3d(pointer(@val02))^ := value;
    
    private function GetColAt(col_i: integer): Vec3d;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        2: Result := Col2;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec3d) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        2: Col2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    public property ColAt[col_i: integer]: Vec3d read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec3d := pointer(@val00);
    public function GetColUnsafePtr1: PVec3d := pointer(@val01);
    public function GetColUnsafePtr2: PVec3d := pointer(@val02);
    public function GetColUnsafePtrAt(col_i: integer): PVec3d;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        2: Result := GetColUnsafePtr2;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec3dSafePtrCallback) := use(PVec3d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec3dSafePtrCallback) := use(PVec3d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol2SafePtr(use: UseVec3dSafePtrCallback) := use(PVec3d(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec3dSafePtrCallback<T>) := conv(PVec3d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec3dSafePtrCallback<T>) := conv(PVec3d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol2SafePtr<T>(conv: ConvVec3dSafePtrCallback<T>) := conv(PVec3d(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec3dSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        2: UseCol2SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec3dSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        2: Result := ConvCol2SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec3dCallback);
    begin
      use(Col0);
      use(Col1);
      use(Col2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec3dCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
      Result.Item3 := conv(Col2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec3dSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
      UseCol2SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec3dSafePtrCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
      Result.Item3 := ConvCol2SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): double;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        2: Result := self.Col2.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: double) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        2: begin var col := self.Col2; col.SetValAt(row_i, new_val, 'row_i'); self.Col2 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    public property ValAt[row_i, col_i: integer]: double read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
    public static function Scale(k: double) :=
      new Mtr3x3d(k, 0, 0, 0, k, 0, 0, 0, k);
    
    public static function TranslatePrefix(ΔX, ΔY: double) :=
      new Mtr3x3d(1, 0, ΔX, 0, 1, ΔY, 0, 0, 1);
    
    public static function TranslatePostfix(ΔX, ΔY: double) :=
      new Mtr3x3d(1, 0, 0, 0, 1, 0, ΔX, ΔY, 1);
    
    public static function RotatePrefixXY(radians: real): Mtr3x3d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec3d(+a_cos, +a_sin, 0);
      Result.Col1 := new Vec3d(-a_sin, +a_cos, 0);
      Result.Col2 := new Vec3d(0, 0, 1);
    end;
    public static function RotatePostfixXY(radians: real): Mtr3x3d := RotatePrefixYX(radians);
    
    public static function RotatePrefixYX(radians: real): Mtr3x3d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec3d(+a_cos, -a_sin, 0);
      Result.Col1 := new Vec3d(+a_sin, +a_cos, 0);
      Result.Col2 := new Vec3d(0, 0, 1);
    end;
    public static function RotatePostfixYX(radians: real): Mtr3x3d := RotatePrefixXY(radians);
    
    public static function RotatePrefixXZ(radians: real): Mtr3x3d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec3d(+a_cos, 0, +a_sin);
      Result.Col1 := new Vec3d(0, 1, 0);
      Result.Col2 := new Vec3d(-a_sin, 0, +a_cos);
    end;
    public static function RotatePostfixXZ(radians: real): Mtr3x3d := RotatePrefixZX(radians);
    
    public static function RotatePrefixZX(radians: real): Mtr3x3d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec3d(+a_cos, 0, -a_sin);
      Result.Col1 := new Vec3d(0, 1, 0);
      Result.Col2 := new Vec3d(+a_sin, 0, +a_cos);
    end;
    public static function RotatePostfixZX(radians: real): Mtr3x3d := RotatePrefixXZ(radians);
    
    public static function RotatePrefixYZ(radians: real): Mtr3x3d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec3d(1, 0, 0);
      Result.Col1 := new Vec3d(0, +a_cos, +a_sin);
      Result.Col2 := new Vec3d(0, -a_sin, +a_cos);
    end;
    public static function RotatePostfixYZ(radians: real): Mtr3x3d := RotatePrefixZY(radians);
    
    public static function RotatePrefixZY(radians: real): Mtr3x3d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec3d(1, 0, 0);
      Result.Col1 := new Vec3d(0, +a_cos, -a_sin);
      Result.Col2 := new Vec3d(0, +a_sin, +a_cos);
    end;
    public static function RotatePostfixZY(radians: real): Mtr3x3d := RotatePrefixYZ(radians);
    
    public static function RotatePrefixXYZ(radians: real; u: Vec3d): Mtr3x3d;
    begin
      var k1 := Sin(radians);
      var k2 := 2*Sqr(Sin(radians/2));
      Result.val00 :=          1 + k2*(              -u.val2*u.val2-u.val1*u.val1);
      Result.val10 := +k1*u.val2 + k2*(                            +u.val1*u.val0);
      Result.val20 := -k1*u.val1 + k2*(              +u.val2*u.val0              );
      Result.val01 := -k1*u.val2 + k2*(                            +u.val0*u.val1);
      Result.val11 :=          1 + k2*(-u.val2*u.val2              -u.val0*u.val0);
      Result.val21 := +k1*u.val0 + k2*(+u.val2*u.val1                            );
      Result.val02 := +k1*u.val1 + k2*(              +u.val0*u.val2              );
      Result.val12 := -k1*u.val0 + k2*(+u.val1*u.val2                            );
      Result.val22 :=          1 + k2*(-u.val1*u.val1-u.val0*u.val0              );
    end;
    public static function RotatePrefixXZY(radians: real; u: Vec3d): Mtr3x3d := RotatePrefixZYX(radians, u);
    public static function RotatePrefixYXZ(radians: real; u: Vec3d): Mtr3x3d := RotatePrefixZYX(radians, u);
    public static function RotatePrefixYZX(radians: real; u: Vec3d): Mtr3x3d := RotatePrefixXYZ(radians, u);
    public static function RotatePrefixZXY(radians: real; u: Vec3d): Mtr3x3d := RotatePrefixXYZ(radians, u);
    public static function RotatePrefixZYX(radians: real; u: Vec3d): Mtr3x3d;
    begin
      var k1 := Sin(radians);
      var k2 := 2*Sqr(Sin(radians/2));
      Result.val00 :=          1 + k2*(-u.val1*u.val1-u.val0*u.val0              );
      Result.val10 := -k1*u.val0 + k2*(+u.val1*u.val2                            );
      Result.val20 := +k1*u.val1 + k2*(              +u.val0*u.val2              );
      Result.val01 := +k1*u.val0 + k2*(+u.val2*u.val1                            );
      Result.val11 :=          1 + k2*(-u.val2*u.val2              -u.val0*u.val0);
      Result.val21 := -k1*u.val2 + k2*(                            +u.val0*u.val1);
      Result.val02 := -k1*u.val1 + k2*(              +u.val2*u.val0              );
      Result.val12 := +k1*u.val2 + k2*(                            +u.val1*u.val0);
      Result.val22 :=          1 + k2*(              -u.val2*u.val2-u.val1*u.val1);
    end;
    
    public static function RotatePostfixXYZ(radians: real; u: Vec3d): Mtr3x3d := RotatePrefixZYX(radians, u);
    public static function RotatePostfixXZY(radians: real; u: Vec3d): Mtr3x3d := RotatePrefixYZX(radians, u);
    public static function RotatePostfixYXZ(radians: real; u: Vec3d): Mtr3x3d := RotatePrefixZXY(radians, u);
    public static function RotatePostfixYZX(radians: real; u: Vec3d): Mtr3x3d := RotatePrefixXZY(radians, u);
    public static function RotatePostfixZXY(radians: real; u: Vec3d): Mtr3x3d := RotatePrefixYXZ(radians, u);
    public static function RotatePostfixZYX(radians: real; u: Vec3d): Mtr3x3d := RotatePrefixXYZ(radians, u);
    
    public function Determinant: double;
    begin
      var det01 := self.val10*self.val21 - self.val11*self.val20;
      var det02 := self.val10*self.val22 - self.val12*self.val20;
      var det12 := self.val11*self.val22 - self.val12*self.val21;
      Result := self.val00*det12 - self.val01*det02 + self.val02*det01;
    end;
    
  end;
  Mtr3d = Mtr3x3d;
  
  Mtr3x3f = record
    public val00, val10, val20: single;
    public val01, val11, val21: single;
    public val02, val12, val22: single;
    
    public constructor(val00, val01, val02, val10, val11, val12, val20, val21, val22: single);
    begin
      self.val00 := val00; self.val01 := val01; self.val02 := val02;
      self.val10 := val10; self.val11 := val11; self.val12 := val12;
      self.val20 := val20; self.val21 := val21; self.val22 := val22;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): single): Mtr3x3f :=
      Mtr3x3f.FromCols(new Vec3f(gen(0,0), gen(1,0), gen(2,0)), new Vec3f(gen(0,1), gen(1,1), gen(2,1)), new Vec3f(gen(0,2), gen(1,2), gen(2,2)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec3f): Mtr3x3f :=
      Mtr3x3f.FromRows(gen(0), gen(1), gen(2));
    public static function GenerateByCol(gen: function(col_i: integer): Vec3f): Mtr3x3f :=
      Mtr3x3f.FromCols(gen(0), gen(1), gen(2));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec3f.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec3f.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec3f.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec3f.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: single): Mtr3x3f;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr3x3f(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val02, val10, val11, val12, val20, val21, val22: single);
    begin
      val00 := self.val00; val01 := self.val01; val02 := self.val02;
      val10 := self.val10; val11 := self.val11; val12 := self.val12;
      val20 := self.val20; val21 := self.val21; val22 := self.val22;
    end;
    
    public procedure DeconstructRows(var row0, row1, row2: Vec3f);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
      row2 := self.Row2;
    end;
    public procedure Deconstruct(var row0, row1, row2: Vec3f) := DeconstructRows(row0, row1, row2);
    
    public procedure DeconstructCols(var col0, col1, col2: Vec3f);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
      col2 := self.Col2;
    end;
    
    private static function ValStr(val: single): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var s20 := ValStr(val20); var col_sz0 := s00.Length.ClampBottom(s10.Length).ClampBottom(s20.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var s21 := ValStr(val21); var col_sz1 := s01.Length.ClampBottom(s11.Length).ClampBottom(s21.Length);
      var s02 := ValStr(val02); var s12 := ValStr(val12); var s22 := ValStr(val22); var col_sz2 := s02.Length.ClampBottom(s12.Length).ClampBottom(s22.Length);
      var total_w := 6; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      total_w += col_sz2;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01; res += ', ';
      res.Append(' ', col_sz2 - s02.Length); res += s02;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11; res += ', ';
      res.Append(' ', col_sz2 - s12.Length); res += s12;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s20.Length); res += s20; res += ', ';
      res.Append(' ', col_sz1 - s21.Length); res += s21; res += ', ';
      res.Append(' ', col_sz2 - s22.Length); res += s22;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr3x3f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr3x3f read
      new Mtr3x3f(1, 0, 0, 0, 1, 0, 0, 0, 1);
    
    public static function FromRows(row0, row1, row2: Vec3f): Mtr3x3f;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
      Result.Row2 := row2;
    end;
    
    public property Row0: Vec3f
      read new Vec3f(val00, val01, val02)
      write value.Deconstruct(val00, val01, val02);
    
    public property Row1: Vec3f
      read new Vec3f(val10, val11, val12)
      write value.Deconstruct(val10, val11, val12);
    
    public property Row2: Vec3f
      read new Vec3f(val20, val21, val22)
      write value.Deconstruct(val20, val21, val22);
    
    private function GetRowAt(row_i: integer): Vec3f;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        2: Result := Row2;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec3f) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        2: Row2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..2');
      end;
    public property RowAt[row_i: integer]: Vec3f read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec3fCallback);
    begin
      use(Row0);
      use(Row1);
      use(Row2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec3fCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
      Result.Item3 := conv(Row2);
    end;
    
    public static function FromCols(col0, col1, col2: Vec3f): Mtr3x3f;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
      Result.Col2 := col2;
    end;
    
    public property Col0: Vec3f
      read PVec3f(pointer(@val00))^
      write PVec3f(pointer(@val00))^ := value;
    
    public property Col1: Vec3f
      read PVec3f(pointer(@val01))^
      write PVec3f(pointer(@val01))^ := value;
    
    public property Col2: Vec3f
      read PVec3f(pointer(@val02))^
      write PVec3f(pointer(@val02))^ := value;
    
    private function GetColAt(col_i: integer): Vec3f;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        2: Result := Col2;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec3f) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        2: Col2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    public property ColAt[col_i: integer]: Vec3f read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec3f := pointer(@val00);
    public function GetColUnsafePtr1: PVec3f := pointer(@val01);
    public function GetColUnsafePtr2: PVec3f := pointer(@val02);
    public function GetColUnsafePtrAt(col_i: integer): PVec3f;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        2: Result := GetColUnsafePtr2;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec3fSafePtrCallback) := use(PVec3f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec3fSafePtrCallback) := use(PVec3f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol2SafePtr(use: UseVec3fSafePtrCallback) := use(PVec3f(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec3fSafePtrCallback<T>) := conv(PVec3f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec3fSafePtrCallback<T>) := conv(PVec3f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol2SafePtr<T>(conv: ConvVec3fSafePtrCallback<T>) := conv(PVec3f(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec3fSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        2: UseCol2SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec3fSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        2: Result := ConvCol2SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec3fCallback);
    begin
      use(Col0);
      use(Col1);
      use(Col2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec3fCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
      Result.Item3 := conv(Col2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec3fSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
      UseCol2SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec3fSafePtrCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
      Result.Item3 := ConvCol2SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): single;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        2: Result := self.Col2.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: single) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        2: begin var col := self.Col2; col.SetValAt(row_i, new_val, 'row_i'); self.Col2 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    public property ValAt[row_i, col_i: integer]: single read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
    public static function Scale(k: single) :=
      new Mtr3x3f(k, 0, 0, 0, k, 0, 0, 0, k);
    
    public static function TranslatePrefix(ΔX, ΔY: single) :=
      new Mtr3x3f(1, 0, ΔX, 0, 1, ΔY, 0, 0, 1);
    
    public static function TranslatePostfix(ΔX, ΔY: single) :=
      new Mtr3x3f(1, 0, 0, 0, 1, 0, ΔX, ΔY, 1);
    
    public static function RotatePrefixXY(radians: real): Mtr3x3f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec3f(+a_cos, +a_sin, 0);
      Result.Col1 := new Vec3f(-a_sin, +a_cos, 0);
      Result.Col2 := new Vec3f(0, 0, 1);
    end;
    public static function RotatePostfixXY(radians: real): Mtr3x3f := RotatePrefixYX(radians);
    
    public static function RotatePrefixYX(radians: real): Mtr3x3f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec3f(+a_cos, -a_sin, 0);
      Result.Col1 := new Vec3f(+a_sin, +a_cos, 0);
      Result.Col2 := new Vec3f(0, 0, 1);
    end;
    public static function RotatePostfixYX(radians: real): Mtr3x3f := RotatePrefixXY(radians);
    
    public static function RotatePrefixXZ(radians: real): Mtr3x3f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec3f(+a_cos, 0, +a_sin);
      Result.Col1 := new Vec3f(0, 1, 0);
      Result.Col2 := new Vec3f(-a_sin, 0, +a_cos);
    end;
    public static function RotatePostfixXZ(radians: real): Mtr3x3f := RotatePrefixZX(radians);
    
    public static function RotatePrefixZX(radians: real): Mtr3x3f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec3f(+a_cos, 0, -a_sin);
      Result.Col1 := new Vec3f(0, 1, 0);
      Result.Col2 := new Vec3f(+a_sin, 0, +a_cos);
    end;
    public static function RotatePostfixZX(radians: real): Mtr3x3f := RotatePrefixXZ(radians);
    
    public static function RotatePrefixYZ(radians: real): Mtr3x3f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec3f(1, 0, 0);
      Result.Col1 := new Vec3f(0, +a_cos, +a_sin);
      Result.Col2 := new Vec3f(0, -a_sin, +a_cos);
    end;
    public static function RotatePostfixYZ(radians: real): Mtr3x3f := RotatePrefixZY(radians);
    
    public static function RotatePrefixZY(radians: real): Mtr3x3f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec3f(1, 0, 0);
      Result.Col1 := new Vec3f(0, +a_cos, -a_sin);
      Result.Col2 := new Vec3f(0, +a_sin, +a_cos);
    end;
    public static function RotatePostfixZY(radians: real): Mtr3x3f := RotatePrefixYZ(radians);
    
    public static function RotatePrefixXYZ(radians: real; u: Vec3f): Mtr3x3f;
    begin
      var k1 := Sin(radians);
      var k2 := 2*Sqr(Sin(radians/2));
      Result.val00 :=          1 + k2*(              -u.val2*u.val2-u.val1*u.val1);
      Result.val10 := +k1*u.val2 + k2*(                            +u.val1*u.val0);
      Result.val20 := -k1*u.val1 + k2*(              +u.val2*u.val0              );
      Result.val01 := -k1*u.val2 + k2*(                            +u.val0*u.val1);
      Result.val11 :=          1 + k2*(-u.val2*u.val2              -u.val0*u.val0);
      Result.val21 := +k1*u.val0 + k2*(+u.val2*u.val1                            );
      Result.val02 := +k1*u.val1 + k2*(              +u.val0*u.val2              );
      Result.val12 := -k1*u.val0 + k2*(+u.val1*u.val2                            );
      Result.val22 :=          1 + k2*(-u.val1*u.val1-u.val0*u.val0              );
    end;
    public static function RotatePrefixXZY(radians: real; u: Vec3f): Mtr3x3f := RotatePrefixZYX(radians, u);
    public static function RotatePrefixYXZ(radians: real; u: Vec3f): Mtr3x3f := RotatePrefixZYX(radians, u);
    public static function RotatePrefixYZX(radians: real; u: Vec3f): Mtr3x3f := RotatePrefixXYZ(radians, u);
    public static function RotatePrefixZXY(radians: real; u: Vec3f): Mtr3x3f := RotatePrefixXYZ(radians, u);
    public static function RotatePrefixZYX(radians: real; u: Vec3f): Mtr3x3f;
    begin
      var k1 := Sin(radians);
      var k2 := 2*Sqr(Sin(radians/2));
      Result.val00 :=          1 + k2*(-u.val1*u.val1-u.val0*u.val0              );
      Result.val10 := -k1*u.val0 + k2*(+u.val1*u.val2                            );
      Result.val20 := +k1*u.val1 + k2*(              +u.val0*u.val2              );
      Result.val01 := +k1*u.val0 + k2*(+u.val2*u.val1                            );
      Result.val11 :=          1 + k2*(-u.val2*u.val2              -u.val0*u.val0);
      Result.val21 := -k1*u.val2 + k2*(                            +u.val0*u.val1);
      Result.val02 := -k1*u.val1 + k2*(              +u.val2*u.val0              );
      Result.val12 := +k1*u.val2 + k2*(                            +u.val1*u.val0);
      Result.val22 :=          1 + k2*(              -u.val2*u.val2-u.val1*u.val1);
    end;
    
    public static function RotatePostfixXYZ(radians: real; u: Vec3f): Mtr3x3f := RotatePrefixZYX(radians, u);
    public static function RotatePostfixXZY(radians: real; u: Vec3f): Mtr3x3f := RotatePrefixYZX(radians, u);
    public static function RotatePostfixYXZ(radians: real; u: Vec3f): Mtr3x3f := RotatePrefixZXY(radians, u);
    public static function RotatePostfixYZX(radians: real; u: Vec3f): Mtr3x3f := RotatePrefixXZY(radians, u);
    public static function RotatePostfixZXY(radians: real; u: Vec3f): Mtr3x3f := RotatePrefixYXZ(radians, u);
    public static function RotatePostfixZYX(radians: real; u: Vec3f): Mtr3x3f := RotatePrefixXYZ(radians, u);
    
    public function Determinant: single;
    begin
      var det01 := self.val10*self.val21 - self.val11*self.val20;
      var det02 := self.val10*self.val22 - self.val12*self.val20;
      var det12 := self.val11*self.val22 - self.val12*self.val21;
      Result := self.val00*det12 - self.val01*det02 + self.val02*det01;
    end;
    
  end;
  Mtr3f = Mtr3x3f;
  
  Mtr3x4d = record
    public val00, val10, val20: double;
    public val01, val11, val21: double;
    public val02, val12, val22: double;
    public val03, val13, val23: double;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23: double);
    begin
      self.val00 := val00; self.val01 := val01; self.val02 := val02; self.val03 := val03;
      self.val10 := val10; self.val11 := val11; self.val12 := val12; self.val13 := val13;
      self.val20 := val20; self.val21 := val21; self.val22 := val22; self.val23 := val23;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): double): Mtr3x4d :=
      Mtr3x4d.FromCols(new Vec3d(gen(0,0), gen(1,0), gen(2,0)), new Vec3d(gen(0,1), gen(1,1), gen(2,1)), new Vec3d(gen(0,2), gen(1,2), gen(2,2)), new Vec3d(gen(0,3), gen(1,3), gen(2,3)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec4d): Mtr3x4d :=
      Mtr3x4d.FromRows(gen(0), gen(1), gen(2));
    public static function GenerateByCol(gen: function(col_i: integer): Vec3d): Mtr3x4d :=
      Mtr3x4d.FromCols(gen(0), gen(1), gen(2), gen(3));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec4d.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec3d.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec4d.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec3d.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: double): Mtr3x4d;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr3x4d(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23: double);
    begin
      val00 := self.val00; val01 := self.val01; val02 := self.val02; val03 := self.val03;
      val10 := self.val10; val11 := self.val11; val12 := self.val12; val13 := self.val13;
      val20 := self.val20; val21 := self.val21; val22 := self.val22; val23 := self.val23;
    end;
    
    public procedure DeconstructRows(var row0, row1, row2: Vec4d);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
      row2 := self.Row2;
    end;
    public procedure Deconstruct(var row0, row1, row2: Vec4d) := DeconstructRows(row0, row1, row2);
    
    public procedure DeconstructCols(var col0, col1, col2, col3: Vec3d);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
      col2 := self.Col2;
      col3 := self.Col3;
    end;
    public procedure Deconstruct(var col0, col1, col2, col3: Vec3d) := DeconstructCols(col0, col1, col2, col3);
    
    private static function ValStr(val: double): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var s20 := ValStr(val20); var col_sz0 := s00.Length.ClampBottom(s10.Length).ClampBottom(s20.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var s21 := ValStr(val21); var col_sz1 := s01.Length.ClampBottom(s11.Length).ClampBottom(s21.Length);
      var s02 := ValStr(val02); var s12 := ValStr(val12); var s22 := ValStr(val22); var col_sz2 := s02.Length.ClampBottom(s12.Length).ClampBottom(s22.Length);
      var s03 := ValStr(val03); var s13 := ValStr(val13); var s23 := ValStr(val23); var col_sz3 := s03.Length.ClampBottom(s13.Length).ClampBottom(s23.Length);
      var total_w := 8; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      total_w += col_sz2;
      total_w += col_sz3;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01; res += ', ';
      res.Append(' ', col_sz2 - s02.Length); res += s02; res += ', ';
      res.Append(' ', col_sz3 - s03.Length); res += s03;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11; res += ', ';
      res.Append(' ', col_sz2 - s12.Length); res += s12; res += ', ';
      res.Append(' ', col_sz3 - s13.Length); res += s13;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s20.Length); res += s20; res += ', ';
      res.Append(' ', col_sz1 - s21.Length); res += s21; res += ', ';
      res.Append(' ', col_sz2 - s22.Length); res += s22; res += ', ';
      res.Append(' ', col_sz3 - s23.Length); res += s23;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr3x4d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr3x4d read
      new Mtr3x4d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0);
    public static property IdentityKeepLast: Mtr3x4d read
      new Mtr3x4d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1);
    
    public static function FromRows(row0, row1, row2: Vec4d): Mtr3x4d;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
      Result.Row2 := row2;
    end;
    
    public property Row0: Vec4d
      read new Vec4d(val00, val01, val02, val03)
      write value.Deconstruct(val00, val01, val02, val03);
    
    public property Row1: Vec4d
      read new Vec4d(val10, val11, val12, val13)
      write value.Deconstruct(val10, val11, val12, val13);
    
    public property Row2: Vec4d
      read new Vec4d(val20, val21, val22, val23)
      write value.Deconstruct(val20, val21, val22, val23);
    
    private function GetRowAt(row_i: integer): Vec4d;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        2: Result := Row2;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec4d) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        2: Row2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..2');
      end;
    public property RowAt[row_i: integer]: Vec4d read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec4dCallback);
    begin
      use(Row0);
      use(Row1);
      use(Row2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec4dCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
      Result.Item3 := conv(Row2);
    end;
    
    public static function FromCols(col0, col1, col2, col3: Vec3d): Mtr3x4d;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
      Result.Col2 := col2;
      Result.Col3 := col3;
    end;
    
    public property Col0: Vec3d
      read PVec3d(pointer(@val00))^
      write PVec3d(pointer(@val00))^ := value;
    
    public property Col1: Vec3d
      read PVec3d(pointer(@val01))^
      write PVec3d(pointer(@val01))^ := value;
    
    public property Col2: Vec3d
      read PVec3d(pointer(@val02))^
      write PVec3d(pointer(@val02))^ := value;
    
    public property Col3: Vec3d
      read PVec3d(pointer(@val03))^
      write PVec3d(pointer(@val03))^ := value;
    
    private function GetColAt(col_i: integer): Vec3d;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        2: Result := Col2;
        3: Result := Col3;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec3d) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        2: Col2 := new_val;
        3: Col3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    public property ColAt[col_i: integer]: Vec3d read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec3d := pointer(@val00);
    public function GetColUnsafePtr1: PVec3d := pointer(@val01);
    public function GetColUnsafePtr2: PVec3d := pointer(@val02);
    public function GetColUnsafePtr3: PVec3d := pointer(@val03);
    public function GetColUnsafePtrAt(col_i: integer): PVec3d;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        2: Result := GetColUnsafePtr2;
        3: Result := GetColUnsafePtr3;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec3dSafePtrCallback) := use(PVec3d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec3dSafePtrCallback) := use(PVec3d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol2SafePtr(use: UseVec3dSafePtrCallback) := use(PVec3d(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol3SafePtr(use: UseVec3dSafePtrCallback) := use(PVec3d(pointer(@val03))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec3dSafePtrCallback<T>) := conv(PVec3d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec3dSafePtrCallback<T>) := conv(PVec3d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol2SafePtr<T>(conv: ConvVec3dSafePtrCallback<T>) := conv(PVec3d(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol3SafePtr<T>(conv: ConvVec3dSafePtrCallback<T>) := conv(PVec3d(pointer(@val03))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec3dSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        2: UseCol2SafePtr(use);
        3: UseCol3SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec3dSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        2: Result := ConvCol2SafePtr(conv);
        3: Result := ConvCol3SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec3dCallback);
    begin
      use(Col0);
      use(Col1);
      use(Col2);
      use(Col3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec3dCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
      Result.Item3 := conv(Col2);
      Result.Item4 := conv(Col3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec3dSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
      UseCol2SafePtr(use);
      UseCol3SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec3dSafePtrCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
      Result.Item3 := ConvCol2SafePtr(conv);
      Result.Item4 := ConvCol3SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): double;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        2: Result := self.Col2.GetValAt(row_i, 'row_i');
        3: Result := self.Col3.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: double) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        2: begin var col := self.Col2; col.SetValAt(row_i, new_val, 'row_i'); self.Col2 := col; end;
        3: begin var col := self.Col3; col.SetValAt(row_i, new_val, 'row_i'); self.Col3 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    public property ValAt[row_i, col_i: integer]: double read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
  end;
  
  Mtr3x4f = record
    public val00, val10, val20: single;
    public val01, val11, val21: single;
    public val02, val12, val22: single;
    public val03, val13, val23: single;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23: single);
    begin
      self.val00 := val00; self.val01 := val01; self.val02 := val02; self.val03 := val03;
      self.val10 := val10; self.val11 := val11; self.val12 := val12; self.val13 := val13;
      self.val20 := val20; self.val21 := val21; self.val22 := val22; self.val23 := val23;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): single): Mtr3x4f :=
      Mtr3x4f.FromCols(new Vec3f(gen(0,0), gen(1,0), gen(2,0)), new Vec3f(gen(0,1), gen(1,1), gen(2,1)), new Vec3f(gen(0,2), gen(1,2), gen(2,2)), new Vec3f(gen(0,3), gen(1,3), gen(2,3)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec4f): Mtr3x4f :=
      Mtr3x4f.FromRows(gen(0), gen(1), gen(2));
    public static function GenerateByCol(gen: function(col_i: integer): Vec3f): Mtr3x4f :=
      Mtr3x4f.FromCols(gen(0), gen(1), gen(2), gen(3));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec4f.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec3f.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec4f.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec3f.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: single): Mtr3x4f;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr3x4f(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23: single);
    begin
      val00 := self.val00; val01 := self.val01; val02 := self.val02; val03 := self.val03;
      val10 := self.val10; val11 := self.val11; val12 := self.val12; val13 := self.val13;
      val20 := self.val20; val21 := self.val21; val22 := self.val22; val23 := self.val23;
    end;
    
    public procedure DeconstructRows(var row0, row1, row2: Vec4f);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
      row2 := self.Row2;
    end;
    public procedure Deconstruct(var row0, row1, row2: Vec4f) := DeconstructRows(row0, row1, row2);
    
    public procedure DeconstructCols(var col0, col1, col2, col3: Vec3f);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
      col2 := self.Col2;
      col3 := self.Col3;
    end;
    public procedure Deconstruct(var col0, col1, col2, col3: Vec3f) := DeconstructCols(col0, col1, col2, col3);
    
    private static function ValStr(val: single): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var s20 := ValStr(val20); var col_sz0 := s00.Length.ClampBottom(s10.Length).ClampBottom(s20.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var s21 := ValStr(val21); var col_sz1 := s01.Length.ClampBottom(s11.Length).ClampBottom(s21.Length);
      var s02 := ValStr(val02); var s12 := ValStr(val12); var s22 := ValStr(val22); var col_sz2 := s02.Length.ClampBottom(s12.Length).ClampBottom(s22.Length);
      var s03 := ValStr(val03); var s13 := ValStr(val13); var s23 := ValStr(val23); var col_sz3 := s03.Length.ClampBottom(s13.Length).ClampBottom(s23.Length);
      var total_w := 8; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      total_w += col_sz2;
      total_w += col_sz3;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01; res += ', ';
      res.Append(' ', col_sz2 - s02.Length); res += s02; res += ', ';
      res.Append(' ', col_sz3 - s03.Length); res += s03;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11; res += ', ';
      res.Append(' ', col_sz2 - s12.Length); res += s12; res += ', ';
      res.Append(' ', col_sz3 - s13.Length); res += s13;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s20.Length); res += s20; res += ', ';
      res.Append(' ', col_sz1 - s21.Length); res += s21; res += ', ';
      res.Append(' ', col_sz2 - s22.Length); res += s22; res += ', ';
      res.Append(' ', col_sz3 - s23.Length); res += s23;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr3x4f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr3x4f read
      new Mtr3x4f(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0);
    public static property IdentityKeepLast: Mtr3x4f read
      new Mtr3x4f(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1);
    
    public static function FromRows(row0, row1, row2: Vec4f): Mtr3x4f;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
      Result.Row2 := row2;
    end;
    
    public property Row0: Vec4f
      read new Vec4f(val00, val01, val02, val03)
      write value.Deconstruct(val00, val01, val02, val03);
    
    public property Row1: Vec4f
      read new Vec4f(val10, val11, val12, val13)
      write value.Deconstruct(val10, val11, val12, val13);
    
    public property Row2: Vec4f
      read new Vec4f(val20, val21, val22, val23)
      write value.Deconstruct(val20, val21, val22, val23);
    
    private function GetRowAt(row_i: integer): Vec4f;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        2: Result := Row2;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec4f) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        2: Row2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..2');
      end;
    public property RowAt[row_i: integer]: Vec4f read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec4fCallback);
    begin
      use(Row0);
      use(Row1);
      use(Row2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec4fCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
      Result.Item3 := conv(Row2);
    end;
    
    public static function FromCols(col0, col1, col2, col3: Vec3f): Mtr3x4f;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
      Result.Col2 := col2;
      Result.Col3 := col3;
    end;
    
    public property Col0: Vec3f
      read PVec3f(pointer(@val00))^
      write PVec3f(pointer(@val00))^ := value;
    
    public property Col1: Vec3f
      read PVec3f(pointer(@val01))^
      write PVec3f(pointer(@val01))^ := value;
    
    public property Col2: Vec3f
      read PVec3f(pointer(@val02))^
      write PVec3f(pointer(@val02))^ := value;
    
    public property Col3: Vec3f
      read PVec3f(pointer(@val03))^
      write PVec3f(pointer(@val03))^ := value;
    
    private function GetColAt(col_i: integer): Vec3f;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        2: Result := Col2;
        3: Result := Col3;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec3f) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        2: Col2 := new_val;
        3: Col3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    public property ColAt[col_i: integer]: Vec3f read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec3f := pointer(@val00);
    public function GetColUnsafePtr1: PVec3f := pointer(@val01);
    public function GetColUnsafePtr2: PVec3f := pointer(@val02);
    public function GetColUnsafePtr3: PVec3f := pointer(@val03);
    public function GetColUnsafePtrAt(col_i: integer): PVec3f;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        2: Result := GetColUnsafePtr2;
        3: Result := GetColUnsafePtr3;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec3fSafePtrCallback) := use(PVec3f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec3fSafePtrCallback) := use(PVec3f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol2SafePtr(use: UseVec3fSafePtrCallback) := use(PVec3f(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol3SafePtr(use: UseVec3fSafePtrCallback) := use(PVec3f(pointer(@val03))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec3fSafePtrCallback<T>) := conv(PVec3f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec3fSafePtrCallback<T>) := conv(PVec3f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol2SafePtr<T>(conv: ConvVec3fSafePtrCallback<T>) := conv(PVec3f(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol3SafePtr<T>(conv: ConvVec3fSafePtrCallback<T>) := conv(PVec3f(pointer(@val03))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec3fSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        2: UseCol2SafePtr(use);
        3: UseCol3SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec3fSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        2: Result := ConvCol2SafePtr(conv);
        3: Result := ConvCol3SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec3fCallback);
    begin
      use(Col0);
      use(Col1);
      use(Col2);
      use(Col3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec3fCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
      Result.Item3 := conv(Col2);
      Result.Item4 := conv(Col3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec3fSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
      UseCol2SafePtr(use);
      UseCol3SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec3fSafePtrCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
      Result.Item3 := ConvCol2SafePtr(conv);
      Result.Item4 := ConvCol3SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): single;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        2: Result := self.Col2.GetValAt(row_i, 'row_i');
        3: Result := self.Col3.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: single) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        2: begin var col := self.Col2; col.SetValAt(row_i, new_val, 'row_i'); self.Col2 := col; end;
        3: begin var col := self.Col3; col.SetValAt(row_i, new_val, 'row_i'); self.Col3 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    public property ValAt[row_i, col_i: integer]: single read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
  end;
  
  Mtr4x2d = record
    public val00, val10, val20, val30: double;
    public val01, val11, val21, val31: double;
    
    public constructor(val00, val01, val10, val11, val20, val21, val30, val31: double);
    begin
      self.val00 := val00; self.val01 := val01;
      self.val10 := val10; self.val11 := val11;
      self.val20 := val20; self.val21 := val21;
      self.val30 := val30; self.val31 := val31;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): double): Mtr4x2d :=
      Mtr4x2d.FromCols(new Vec4d(gen(0,0), gen(1,0), gen(2,0), gen(3,0)), new Vec4d(gen(0,1), gen(1,1), gen(2,1), gen(3,1)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec2d): Mtr4x2d :=
      Mtr4x2d.FromRows(gen(0), gen(1), gen(2), gen(3));
    public static function GenerateByCol(gen: function(col_i: integer): Vec4d): Mtr4x2d :=
      Mtr4x2d.FromCols(gen(0), gen(1));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec2d.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec4d.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec2d.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec4d.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: double): Mtr4x2d;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr4x2d(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val10, val11, val20, val21, val30, val31: double);
    begin
      val00 := self.val00; val01 := self.val01;
      val10 := self.val10; val11 := self.val11;
      val20 := self.val20; val21 := self.val21;
      val30 := self.val30; val31 := self.val31;
    end;
    
    public procedure DeconstructRows(var row0, row1, row2, row3: Vec2d);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
      row2 := self.Row2;
      row3 := self.Row3;
    end;
    public procedure Deconstruct(var row0, row1, row2, row3: Vec2d) := DeconstructRows(row0, row1, row2, row3);
    
    public procedure DeconstructCols(var col0, col1: Vec4d);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
    end;
    public procedure Deconstruct(var col0, col1: Vec4d) := DeconstructCols(col0, col1);
    
    private static function ValStr(val: double): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var s20 := ValStr(val20); var s30 := ValStr(val30); var col_sz0 := s00.Length.ClampBottom(s10.Length).ClampBottom(s20.Length).ClampBottom(s30.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var s21 := ValStr(val21); var s31 := ValStr(val31); var col_sz1 := s01.Length.ClampBottom(s11.Length).ClampBottom(s21.Length).ClampBottom(s31.Length);
      var total_w := 4; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s20.Length); res += s20; res += ', ';
      res.Append(' ', col_sz1 - s21.Length); res += s21;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s30.Length); res += s30; res += ', ';
      res.Append(' ', col_sz1 - s31.Length); res += s31;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr4x2d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr4x2d read
      new Mtr4x2d(1, 0, 0, 1, 0, 0, 0, 0);
    public static property IdentityKeepLast: Mtr4x2d read
      new Mtr4x2d(1, 0, 0, 0, 0, 0, 0, 1);
    
    public static function FromRows(row0, row1, row2, row3: Vec2d): Mtr4x2d;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
      Result.Row2 := row2;
      Result.Row3 := row3;
    end;
    
    public property Row0: Vec2d
      read new Vec2d(val00, val01)
      write value.Deconstruct(val00, val01);
    
    public property Row1: Vec2d
      read new Vec2d(val10, val11)
      write value.Deconstruct(val10, val11);
    
    public property Row2: Vec2d
      read new Vec2d(val20, val21)
      write value.Deconstruct(val20, val21);
    
    public property Row3: Vec2d
      read new Vec2d(val30, val31)
      write value.Deconstruct(val30, val31);
    
    private function GetRowAt(row_i: integer): Vec2d;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        2: Result := Row2;
        3: Result := Row3;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec2d) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        2: Row2 := new_val;
        3: Row3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..3');
      end;
    public property RowAt[row_i: integer]: Vec2d read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec2dCallback);
    begin
      use(Row0);
      use(Row1);
      use(Row2);
      use(Row3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec2dCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
      Result.Item3 := conv(Row2);
      Result.Item4 := conv(Row3);
    end;
    
    public static function FromCols(col0, col1: Vec4d): Mtr4x2d;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
    end;
    
    public property Col0: Vec4d
      read PVec4d(pointer(@val00))^
      write PVec4d(pointer(@val00))^ := value;
    
    public property Col1: Vec4d
      read PVec4d(pointer(@val01))^
      write PVec4d(pointer(@val01))^ := value;
    
    private function GetColAt(col_i: integer): Vec4d;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec4d) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    public property ColAt[col_i: integer]: Vec4d read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec4d := pointer(@val00);
    public function GetColUnsafePtr1: PVec4d := pointer(@val01);
    public function GetColUnsafePtrAt(col_i: integer): PVec4d;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec4dSafePtrCallback) := use(PVec4d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec4dSafePtrCallback) := use(PVec4d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec4dSafePtrCallback<T>) := conv(PVec4d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec4dSafePtrCallback<T>) := conv(PVec4d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec4dSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec4dSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec4dCallback);
    begin
      use(Col0);
      use(Col1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec4dCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec4dSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec4dSafePtrCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): double;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: double) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    public property ValAt[row_i, col_i: integer]: double read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
  end;
  
  Mtr4x2f = record
    public val00, val10, val20, val30: single;
    public val01, val11, val21, val31: single;
    
    public constructor(val00, val01, val10, val11, val20, val21, val30, val31: single);
    begin
      self.val00 := val00; self.val01 := val01;
      self.val10 := val10; self.val11 := val11;
      self.val20 := val20; self.val21 := val21;
      self.val30 := val30; self.val31 := val31;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): single): Mtr4x2f :=
      Mtr4x2f.FromCols(new Vec4f(gen(0,0), gen(1,0), gen(2,0), gen(3,0)), new Vec4f(gen(0,1), gen(1,1), gen(2,1), gen(3,1)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec2f): Mtr4x2f :=
      Mtr4x2f.FromRows(gen(0), gen(1), gen(2), gen(3));
    public static function GenerateByCol(gen: function(col_i: integer): Vec4f): Mtr4x2f :=
      Mtr4x2f.FromCols(gen(0), gen(1));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec2f.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec4f.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec2f.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec4f.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: single): Mtr4x2f;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr4x2f(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val10, val11, val20, val21, val30, val31: single);
    begin
      val00 := self.val00; val01 := self.val01;
      val10 := self.val10; val11 := self.val11;
      val20 := self.val20; val21 := self.val21;
      val30 := self.val30; val31 := self.val31;
    end;
    
    public procedure DeconstructRows(var row0, row1, row2, row3: Vec2f);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
      row2 := self.Row2;
      row3 := self.Row3;
    end;
    public procedure Deconstruct(var row0, row1, row2, row3: Vec2f) := DeconstructRows(row0, row1, row2, row3);
    
    public procedure DeconstructCols(var col0, col1: Vec4f);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
    end;
    public procedure Deconstruct(var col0, col1: Vec4f) := DeconstructCols(col0, col1);
    
    private static function ValStr(val: single): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var s20 := ValStr(val20); var s30 := ValStr(val30); var col_sz0 := s00.Length.ClampBottom(s10.Length).ClampBottom(s20.Length).ClampBottom(s30.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var s21 := ValStr(val21); var s31 := ValStr(val31); var col_sz1 := s01.Length.ClampBottom(s11.Length).ClampBottom(s21.Length).ClampBottom(s31.Length);
      var total_w := 4; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s20.Length); res += s20; res += ', ';
      res.Append(' ', col_sz1 - s21.Length); res += s21;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s30.Length); res += s30; res += ', ';
      res.Append(' ', col_sz1 - s31.Length); res += s31;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr4x2f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr4x2f read
      new Mtr4x2f(1, 0, 0, 1, 0, 0, 0, 0);
    public static property IdentityKeepLast: Mtr4x2f read
      new Mtr4x2f(1, 0, 0, 0, 0, 0, 0, 1);
    
    public static function FromRows(row0, row1, row2, row3: Vec2f): Mtr4x2f;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
      Result.Row2 := row2;
      Result.Row3 := row3;
    end;
    
    public property Row0: Vec2f
      read new Vec2f(val00, val01)
      write value.Deconstruct(val00, val01);
    
    public property Row1: Vec2f
      read new Vec2f(val10, val11)
      write value.Deconstruct(val10, val11);
    
    public property Row2: Vec2f
      read new Vec2f(val20, val21)
      write value.Deconstruct(val20, val21);
    
    public property Row3: Vec2f
      read new Vec2f(val30, val31)
      write value.Deconstruct(val30, val31);
    
    private function GetRowAt(row_i: integer): Vec2f;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        2: Result := Row2;
        3: Result := Row3;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec2f) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        2: Row2 := new_val;
        3: Row3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..3');
      end;
    public property RowAt[row_i: integer]: Vec2f read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec2fCallback);
    begin
      use(Row0);
      use(Row1);
      use(Row2);
      use(Row3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec2fCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
      Result.Item3 := conv(Row2);
      Result.Item4 := conv(Row3);
    end;
    
    public static function FromCols(col0, col1: Vec4f): Mtr4x2f;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
    end;
    
    public property Col0: Vec4f
      read PVec4f(pointer(@val00))^
      write PVec4f(pointer(@val00))^ := value;
    
    public property Col1: Vec4f
      read PVec4f(pointer(@val01))^
      write PVec4f(pointer(@val01))^ := value;
    
    private function GetColAt(col_i: integer): Vec4f;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec4f) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    public property ColAt[col_i: integer]: Vec4f read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec4f := pointer(@val00);
    public function GetColUnsafePtr1: PVec4f := pointer(@val01);
    public function GetColUnsafePtrAt(col_i: integer): PVec4f;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec4fSafePtrCallback) := use(PVec4f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec4fSafePtrCallback) := use(PVec4f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec4fSafePtrCallback<T>) := conv(PVec4f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec4fSafePtrCallback<T>) := conv(PVec4f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec4fSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec4fSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec4fCallback);
    begin
      use(Col0);
      use(Col1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec4fCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec4fSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec4fSafePtrCallback<T>): ValueTuple<T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): single;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: single) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..1');
      end;
    public property ValAt[row_i, col_i: integer]: single read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
  end;
  
  Mtr4x3d = record
    public val00, val10, val20, val30: double;
    public val01, val11, val21, val31: double;
    public val02, val12, val22, val32: double;
    
    public constructor(val00, val01, val02, val10, val11, val12, val20, val21, val22, val30, val31, val32: double);
    begin
      self.val00 := val00; self.val01 := val01; self.val02 := val02;
      self.val10 := val10; self.val11 := val11; self.val12 := val12;
      self.val20 := val20; self.val21 := val21; self.val22 := val22;
      self.val30 := val30; self.val31 := val31; self.val32 := val32;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): double): Mtr4x3d :=
      Mtr4x3d.FromCols(new Vec4d(gen(0,0), gen(1,0), gen(2,0), gen(3,0)), new Vec4d(gen(0,1), gen(1,1), gen(2,1), gen(3,1)), new Vec4d(gen(0,2), gen(1,2), gen(2,2), gen(3,2)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec3d): Mtr4x3d :=
      Mtr4x3d.FromRows(gen(0), gen(1), gen(2), gen(3));
    public static function GenerateByCol(gen: function(col_i: integer): Vec4d): Mtr4x3d :=
      Mtr4x3d.FromCols(gen(0), gen(1), gen(2));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec3d.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec4d.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec3d.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec4d.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: double): Mtr4x3d;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr4x3d(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val02, val10, val11, val12, val20, val21, val22, val30, val31, val32: double);
    begin
      val00 := self.val00; val01 := self.val01; val02 := self.val02;
      val10 := self.val10; val11 := self.val11; val12 := self.val12;
      val20 := self.val20; val21 := self.val21; val22 := self.val22;
      val30 := self.val30; val31 := self.val31; val32 := self.val32;
    end;
    
    public procedure DeconstructRows(var row0, row1, row2, row3: Vec3d);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
      row2 := self.Row2;
      row3 := self.Row3;
    end;
    public procedure Deconstruct(var row0, row1, row2, row3: Vec3d) := DeconstructRows(row0, row1, row2, row3);
    
    public procedure DeconstructCols(var col0, col1, col2: Vec4d);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
      col2 := self.Col2;
    end;
    public procedure Deconstruct(var col0, col1, col2: Vec4d) := DeconstructCols(col0, col1, col2);
    
    private static function ValStr(val: double): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var s20 := ValStr(val20); var s30 := ValStr(val30); var col_sz0 := s00.Length.ClampBottom(s10.Length).ClampBottom(s20.Length).ClampBottom(s30.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var s21 := ValStr(val21); var s31 := ValStr(val31); var col_sz1 := s01.Length.ClampBottom(s11.Length).ClampBottom(s21.Length).ClampBottom(s31.Length);
      var s02 := ValStr(val02); var s12 := ValStr(val12); var s22 := ValStr(val22); var s32 := ValStr(val32); var col_sz2 := s02.Length.ClampBottom(s12.Length).ClampBottom(s22.Length).ClampBottom(s32.Length);
      var total_w := 6; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      total_w += col_sz2;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01; res += ', ';
      res.Append(' ', col_sz2 - s02.Length); res += s02;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11; res += ', ';
      res.Append(' ', col_sz2 - s12.Length); res += s12;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s20.Length); res += s20; res += ', ';
      res.Append(' ', col_sz1 - s21.Length); res += s21; res += ', ';
      res.Append(' ', col_sz2 - s22.Length); res += s22;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s30.Length); res += s30; res += ', ';
      res.Append(' ', col_sz1 - s31.Length); res += s31; res += ', ';
      res.Append(' ', col_sz2 - s32.Length); res += s32;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr4x3d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr4x3d read
      new Mtr4x3d(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0);
    public static property IdentityKeepLast: Mtr4x3d read
      new Mtr4x3d(1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1);
    
    public static function FromRows(row0, row1, row2, row3: Vec3d): Mtr4x3d;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
      Result.Row2 := row2;
      Result.Row3 := row3;
    end;
    
    public property Row0: Vec3d
      read new Vec3d(val00, val01, val02)
      write value.Deconstruct(val00, val01, val02);
    
    public property Row1: Vec3d
      read new Vec3d(val10, val11, val12)
      write value.Deconstruct(val10, val11, val12);
    
    public property Row2: Vec3d
      read new Vec3d(val20, val21, val22)
      write value.Deconstruct(val20, val21, val22);
    
    public property Row3: Vec3d
      read new Vec3d(val30, val31, val32)
      write value.Deconstruct(val30, val31, val32);
    
    private function GetRowAt(row_i: integer): Vec3d;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        2: Result := Row2;
        3: Result := Row3;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec3d) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        2: Row2 := new_val;
        3: Row3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..3');
      end;
    public property RowAt[row_i: integer]: Vec3d read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec3dCallback);
    begin
      use(Row0);
      use(Row1);
      use(Row2);
      use(Row3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec3dCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
      Result.Item3 := conv(Row2);
      Result.Item4 := conv(Row3);
    end;
    
    public static function FromCols(col0, col1, col2: Vec4d): Mtr4x3d;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
      Result.Col2 := col2;
    end;
    
    public property Col0: Vec4d
      read PVec4d(pointer(@val00))^
      write PVec4d(pointer(@val00))^ := value;
    
    public property Col1: Vec4d
      read PVec4d(pointer(@val01))^
      write PVec4d(pointer(@val01))^ := value;
    
    public property Col2: Vec4d
      read PVec4d(pointer(@val02))^
      write PVec4d(pointer(@val02))^ := value;
    
    private function GetColAt(col_i: integer): Vec4d;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        2: Result := Col2;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec4d) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        2: Col2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    public property ColAt[col_i: integer]: Vec4d read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec4d := pointer(@val00);
    public function GetColUnsafePtr1: PVec4d := pointer(@val01);
    public function GetColUnsafePtr2: PVec4d := pointer(@val02);
    public function GetColUnsafePtrAt(col_i: integer): PVec4d;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        2: Result := GetColUnsafePtr2;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec4dSafePtrCallback) := use(PVec4d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec4dSafePtrCallback) := use(PVec4d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol2SafePtr(use: UseVec4dSafePtrCallback) := use(PVec4d(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec4dSafePtrCallback<T>) := conv(PVec4d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec4dSafePtrCallback<T>) := conv(PVec4d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol2SafePtr<T>(conv: ConvVec4dSafePtrCallback<T>) := conv(PVec4d(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec4dSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        2: UseCol2SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec4dSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        2: Result := ConvCol2SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec4dCallback);
    begin
      use(Col0);
      use(Col1);
      use(Col2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec4dCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
      Result.Item3 := conv(Col2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec4dSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
      UseCol2SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec4dSafePtrCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
      Result.Item3 := ConvCol2SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): double;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        2: Result := self.Col2.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: double) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        2: begin var col := self.Col2; col.SetValAt(row_i, new_val, 'row_i'); self.Col2 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    public property ValAt[row_i, col_i: integer]: double read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
  end;
  
  Mtr4x3f = record
    public val00, val10, val20, val30: single;
    public val01, val11, val21, val31: single;
    public val02, val12, val22, val32: single;
    
    public constructor(val00, val01, val02, val10, val11, val12, val20, val21, val22, val30, val31, val32: single);
    begin
      self.val00 := val00; self.val01 := val01; self.val02 := val02;
      self.val10 := val10; self.val11 := val11; self.val12 := val12;
      self.val20 := val20; self.val21 := val21; self.val22 := val22;
      self.val30 := val30; self.val31 := val31; self.val32 := val32;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): single): Mtr4x3f :=
      Mtr4x3f.FromCols(new Vec4f(gen(0,0), gen(1,0), gen(2,0), gen(3,0)), new Vec4f(gen(0,1), gen(1,1), gen(2,1), gen(3,1)), new Vec4f(gen(0,2), gen(1,2), gen(2,2), gen(3,2)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec3f): Mtr4x3f :=
      Mtr4x3f.FromRows(gen(0), gen(1), gen(2), gen(3));
    public static function GenerateByCol(gen: function(col_i: integer): Vec4f): Mtr4x3f :=
      Mtr4x3f.FromCols(gen(0), gen(1), gen(2));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec3f.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec4f.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec3f.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec4f.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: single): Mtr4x3f;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr4x3f(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val02, val10, val11, val12, val20, val21, val22, val30, val31, val32: single);
    begin
      val00 := self.val00; val01 := self.val01; val02 := self.val02;
      val10 := self.val10; val11 := self.val11; val12 := self.val12;
      val20 := self.val20; val21 := self.val21; val22 := self.val22;
      val30 := self.val30; val31 := self.val31; val32 := self.val32;
    end;
    
    public procedure DeconstructRows(var row0, row1, row2, row3: Vec3f);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
      row2 := self.Row2;
      row3 := self.Row3;
    end;
    public procedure Deconstruct(var row0, row1, row2, row3: Vec3f) := DeconstructRows(row0, row1, row2, row3);
    
    public procedure DeconstructCols(var col0, col1, col2: Vec4f);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
      col2 := self.Col2;
    end;
    public procedure Deconstruct(var col0, col1, col2: Vec4f) := DeconstructCols(col0, col1, col2);
    
    private static function ValStr(val: single): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var s20 := ValStr(val20); var s30 := ValStr(val30); var col_sz0 := s00.Length.ClampBottom(s10.Length).ClampBottom(s20.Length).ClampBottom(s30.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var s21 := ValStr(val21); var s31 := ValStr(val31); var col_sz1 := s01.Length.ClampBottom(s11.Length).ClampBottom(s21.Length).ClampBottom(s31.Length);
      var s02 := ValStr(val02); var s12 := ValStr(val12); var s22 := ValStr(val22); var s32 := ValStr(val32); var col_sz2 := s02.Length.ClampBottom(s12.Length).ClampBottom(s22.Length).ClampBottom(s32.Length);
      var total_w := 6; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      total_w += col_sz2;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01; res += ', ';
      res.Append(' ', col_sz2 - s02.Length); res += s02;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11; res += ', ';
      res.Append(' ', col_sz2 - s12.Length); res += s12;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s20.Length); res += s20; res += ', ';
      res.Append(' ', col_sz1 - s21.Length); res += s21; res += ', ';
      res.Append(' ', col_sz2 - s22.Length); res += s22;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s30.Length); res += s30; res += ', ';
      res.Append(' ', col_sz1 - s31.Length); res += s31; res += ', ';
      res.Append(' ', col_sz2 - s32.Length); res += s32;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr4x3f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr4x3f read
      new Mtr4x3f(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0);
    public static property IdentityKeepLast: Mtr4x3f read
      new Mtr4x3f(1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1);
    
    public static function FromRows(row0, row1, row2, row3: Vec3f): Mtr4x3f;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
      Result.Row2 := row2;
      Result.Row3 := row3;
    end;
    
    public property Row0: Vec3f
      read new Vec3f(val00, val01, val02)
      write value.Deconstruct(val00, val01, val02);
    
    public property Row1: Vec3f
      read new Vec3f(val10, val11, val12)
      write value.Deconstruct(val10, val11, val12);
    
    public property Row2: Vec3f
      read new Vec3f(val20, val21, val22)
      write value.Deconstruct(val20, val21, val22);
    
    public property Row3: Vec3f
      read new Vec3f(val30, val31, val32)
      write value.Deconstruct(val30, val31, val32);
    
    private function GetRowAt(row_i: integer): Vec3f;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        2: Result := Row2;
        3: Result := Row3;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec3f) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        2: Row2 := new_val;
        3: Row3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..3');
      end;
    public property RowAt[row_i: integer]: Vec3f read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec3fCallback);
    begin
      use(Row0);
      use(Row1);
      use(Row2);
      use(Row3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec3fCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
      Result.Item3 := conv(Row2);
      Result.Item4 := conv(Row3);
    end;
    
    public static function FromCols(col0, col1, col2: Vec4f): Mtr4x3f;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
      Result.Col2 := col2;
    end;
    
    public property Col0: Vec4f
      read PVec4f(pointer(@val00))^
      write PVec4f(pointer(@val00))^ := value;
    
    public property Col1: Vec4f
      read PVec4f(pointer(@val01))^
      write PVec4f(pointer(@val01))^ := value;
    
    public property Col2: Vec4f
      read PVec4f(pointer(@val02))^
      write PVec4f(pointer(@val02))^ := value;
    
    private function GetColAt(col_i: integer): Vec4f;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        2: Result := Col2;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec4f) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        2: Col2 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    public property ColAt[col_i: integer]: Vec4f read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec4f := pointer(@val00);
    public function GetColUnsafePtr1: PVec4f := pointer(@val01);
    public function GetColUnsafePtr2: PVec4f := pointer(@val02);
    public function GetColUnsafePtrAt(col_i: integer): PVec4f;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        2: Result := GetColUnsafePtr2;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec4fSafePtrCallback) := use(PVec4f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec4fSafePtrCallback) := use(PVec4f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol2SafePtr(use: UseVec4fSafePtrCallback) := use(PVec4f(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec4fSafePtrCallback<T>) := conv(PVec4f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec4fSafePtrCallback<T>) := conv(PVec4f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol2SafePtr<T>(conv: ConvVec4fSafePtrCallback<T>) := conv(PVec4f(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec4fSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        2: UseCol2SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec4fSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        2: Result := ConvCol2SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec4fCallback);
    begin
      use(Col0);
      use(Col1);
      use(Col2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec4fCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
      Result.Item3 := conv(Col2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec4fSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
      UseCol2SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec4fSafePtrCallback<T>): ValueTuple<T, T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
      Result.Item3 := ConvCol2SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): single;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        2: Result := self.Col2.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: single) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        2: begin var col := self.Col2; col.SetValAt(row_i, new_val, 'row_i'); self.Col2 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..2');
      end;
    public property ValAt[row_i, col_i: integer]: single read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
  end;
  
  Mtr4x4d = record
    public val00, val10, val20, val30: double;
    public val01, val11, val21, val31: double;
    public val02, val12, val22, val32: double;
    public val03, val13, val23, val33: double;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23, val30, val31, val32, val33: double);
    begin
      self.val00 := val00; self.val01 := val01; self.val02 := val02; self.val03 := val03;
      self.val10 := val10; self.val11 := val11; self.val12 := val12; self.val13 := val13;
      self.val20 := val20; self.val21 := val21; self.val22 := val22; self.val23 := val23;
      self.val30 := val30; self.val31 := val31; self.val32 := val32; self.val33 := val33;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): double): Mtr4x4d :=
      Mtr4x4d.FromCols(new Vec4d(gen(0,0), gen(1,0), gen(2,0), gen(3,0)), new Vec4d(gen(0,1), gen(1,1), gen(2,1), gen(3,1)), new Vec4d(gen(0,2), gen(1,2), gen(2,2), gen(3,2)), new Vec4d(gen(0,3), gen(1,3), gen(2,3), gen(3,3)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec4d): Mtr4x4d :=
      Mtr4x4d.FromRows(gen(0), gen(1), gen(2), gen(3));
    public static function GenerateByCol(gen: function(col_i: integer): Vec4d): Mtr4x4d :=
      Mtr4x4d.FromCols(gen(0), gen(1), gen(2), gen(3));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec4d.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec4d.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec4d.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec4d.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: double): Mtr4x4d;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr4x4d(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23, val30, val31, val32, val33: double);
    begin
      val00 := self.val00; val01 := self.val01; val02 := self.val02; val03 := self.val03;
      val10 := self.val10; val11 := self.val11; val12 := self.val12; val13 := self.val13;
      val20 := self.val20; val21 := self.val21; val22 := self.val22; val23 := self.val23;
      val30 := self.val30; val31 := self.val31; val32 := self.val32; val33 := self.val33;
    end;
    
    public procedure DeconstructRows(var row0, row1, row2, row3: Vec4d);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
      row2 := self.Row2;
      row3 := self.Row3;
    end;
    public procedure Deconstruct(var row0, row1, row2, row3: Vec4d) := DeconstructRows(row0, row1, row2, row3);
    
    public procedure DeconstructCols(var col0, col1, col2, col3: Vec4d);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
      col2 := self.Col2;
      col3 := self.Col3;
    end;
    
    private static function ValStr(val: double): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var s20 := ValStr(val20); var s30 := ValStr(val30); var col_sz0 := s00.Length.ClampBottom(s10.Length).ClampBottom(s20.Length).ClampBottom(s30.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var s21 := ValStr(val21); var s31 := ValStr(val31); var col_sz1 := s01.Length.ClampBottom(s11.Length).ClampBottom(s21.Length).ClampBottom(s31.Length);
      var s02 := ValStr(val02); var s12 := ValStr(val12); var s22 := ValStr(val22); var s32 := ValStr(val32); var col_sz2 := s02.Length.ClampBottom(s12.Length).ClampBottom(s22.Length).ClampBottom(s32.Length);
      var s03 := ValStr(val03); var s13 := ValStr(val13); var s23 := ValStr(val23); var s33 := ValStr(val33); var col_sz3 := s03.Length.ClampBottom(s13.Length).ClampBottom(s23.Length).ClampBottom(s33.Length);
      var total_w := 8; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      total_w += col_sz2;
      total_w += col_sz3;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01; res += ', ';
      res.Append(' ', col_sz2 - s02.Length); res += s02; res += ', ';
      res.Append(' ', col_sz3 - s03.Length); res += s03;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11; res += ', ';
      res.Append(' ', col_sz2 - s12.Length); res += s12; res += ', ';
      res.Append(' ', col_sz3 - s13.Length); res += s13;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s20.Length); res += s20; res += ', ';
      res.Append(' ', col_sz1 - s21.Length); res += s21; res += ', ';
      res.Append(' ', col_sz2 - s22.Length); res += s22; res += ', ';
      res.Append(' ', col_sz3 - s23.Length); res += s23;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s30.Length); res += s30; res += ', ';
      res.Append(' ', col_sz1 - s31.Length); res += s31; res += ', ';
      res.Append(' ', col_sz2 - s32.Length); res += s32; res += ', ';
      res.Append(' ', col_sz3 - s33.Length); res += s33;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr4x4d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr4x4d read
      new Mtr4x4d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    
    public static function FromRows(row0, row1, row2, row3: Vec4d): Mtr4x4d;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
      Result.Row2 := row2;
      Result.Row3 := row3;
    end;
    
    public property Row0: Vec4d
      read new Vec4d(val00, val01, val02, val03)
      write value.Deconstruct(val00, val01, val02, val03);
    
    public property Row1: Vec4d
      read new Vec4d(val10, val11, val12, val13)
      write value.Deconstruct(val10, val11, val12, val13);
    
    public property Row2: Vec4d
      read new Vec4d(val20, val21, val22, val23)
      write value.Deconstruct(val20, val21, val22, val23);
    
    public property Row3: Vec4d
      read new Vec4d(val30, val31, val32, val33)
      write value.Deconstruct(val30, val31, val32, val33);
    
    private function GetRowAt(row_i: integer): Vec4d;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        2: Result := Row2;
        3: Result := Row3;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec4d) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        2: Row2 := new_val;
        3: Row3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..3');
      end;
    public property RowAt[row_i: integer]: Vec4d read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec4dCallback);
    begin
      use(Row0);
      use(Row1);
      use(Row2);
      use(Row3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec4dCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
      Result.Item3 := conv(Row2);
      Result.Item4 := conv(Row3);
    end;
    
    public static function FromCols(col0, col1, col2, col3: Vec4d): Mtr4x4d;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
      Result.Col2 := col2;
      Result.Col3 := col3;
    end;
    
    public property Col0: Vec4d
      read PVec4d(pointer(@val00))^
      write PVec4d(pointer(@val00))^ := value;
    
    public property Col1: Vec4d
      read PVec4d(pointer(@val01))^
      write PVec4d(pointer(@val01))^ := value;
    
    public property Col2: Vec4d
      read PVec4d(pointer(@val02))^
      write PVec4d(pointer(@val02))^ := value;
    
    public property Col3: Vec4d
      read PVec4d(pointer(@val03))^
      write PVec4d(pointer(@val03))^ := value;
    
    private function GetColAt(col_i: integer): Vec4d;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        2: Result := Col2;
        3: Result := Col3;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec4d) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        2: Col2 := new_val;
        3: Col3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    public property ColAt[col_i: integer]: Vec4d read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec4d := pointer(@val00);
    public function GetColUnsafePtr1: PVec4d := pointer(@val01);
    public function GetColUnsafePtr2: PVec4d := pointer(@val02);
    public function GetColUnsafePtr3: PVec4d := pointer(@val03);
    public function GetColUnsafePtrAt(col_i: integer): PVec4d;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        2: Result := GetColUnsafePtr2;
        3: Result := GetColUnsafePtr3;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec4dSafePtrCallback) := use(PVec4d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec4dSafePtrCallback) := use(PVec4d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol2SafePtr(use: UseVec4dSafePtrCallback) := use(PVec4d(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol3SafePtr(use: UseVec4dSafePtrCallback) := use(PVec4d(pointer(@val03))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec4dSafePtrCallback<T>) := conv(PVec4d(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec4dSafePtrCallback<T>) := conv(PVec4d(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol2SafePtr<T>(conv: ConvVec4dSafePtrCallback<T>) := conv(PVec4d(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol3SafePtr<T>(conv: ConvVec4dSafePtrCallback<T>) := conv(PVec4d(pointer(@val03))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec4dSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        2: UseCol2SafePtr(use);
        3: UseCol3SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec4dSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        2: Result := ConvCol2SafePtr(conv);
        3: Result := ConvCol3SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec4dCallback);
    begin
      use(Col0);
      use(Col1);
      use(Col2);
      use(Col3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec4dCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
      Result.Item3 := conv(Col2);
      Result.Item4 := conv(Col3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec4dSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
      UseCol2SafePtr(use);
      UseCol3SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec4dSafePtrCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
      Result.Item3 := ConvCol2SafePtr(conv);
      Result.Item4 := ConvCol3SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): double;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        2: Result := self.Col2.GetValAt(row_i, 'row_i');
        3: Result := self.Col3.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: double) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        2: begin var col := self.Col2; col.SetValAt(row_i, new_val, 'row_i'); self.Col2 := col; end;
        3: begin var col := self.Col3; col.SetValAt(row_i, new_val, 'row_i'); self.Col3 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    public property ValAt[row_i, col_i: integer]: double read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
    public static function Scale(k: double) :=
      new Mtr4x4d(k, 0, 0, 0, 0, k, 0, 0, 0, 0, k, 0, 0, 0, 0, k);
    
    public static function TranslatePrefix(ΔX, ΔY, ΔZ: double) :=
      new Mtr4x4d(1, 0, 0, ΔX, 0, 1, 0, ΔY, 0, 0, 1, ΔZ, 0, 0, 0, 1);
    
    public static function TranslatePostfix(ΔX, ΔY, ΔZ: double) :=
      new Mtr4x4d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ΔX, ΔY, ΔZ, 1);
    
    public static function RotatePrefixXY(radians: real): Mtr4x4d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec4d(+a_cos, +a_sin, 0, 0);
      Result.Col1 := new Vec4d(-a_sin, +a_cos, 0, 0);
      Result.Col2 := new Vec4d(0, 0, 1, 0);
      Result.Col3 := new Vec4d(0, 0, 0, 1);
    end;
    public static function RotatePostfixXY(radians: real): Mtr4x4d := RotatePrefixYX(radians);
    
    public static function RotatePrefixYX(radians: real): Mtr4x4d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec4d(+a_cos, -a_sin, 0, 0);
      Result.Col1 := new Vec4d(+a_sin, +a_cos, 0, 0);
      Result.Col2 := new Vec4d(0, 0, 1, 0);
      Result.Col3 := new Vec4d(0, 0, 0, 1);
    end;
    public static function RotatePostfixYX(radians: real): Mtr4x4d := RotatePrefixXY(radians);
    
    public static function RotatePrefixXZ(radians: real): Mtr4x4d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec4d(+a_cos, 0, +a_sin, 0);
      Result.Col1 := new Vec4d(0, 1, 0, 0);
      Result.Col2 := new Vec4d(-a_sin, 0, +a_cos, 0);
      Result.Col3 := new Vec4d(0, 0, 0, 1);
    end;
    public static function RotatePostfixXZ(radians: real): Mtr4x4d := RotatePrefixZX(radians);
    
    public static function RotatePrefixZX(radians: real): Mtr4x4d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec4d(+a_cos, 0, -a_sin, 0);
      Result.Col1 := new Vec4d(0, 1, 0, 0);
      Result.Col2 := new Vec4d(+a_sin, 0, +a_cos, 0);
      Result.Col3 := new Vec4d(0, 0, 0, 1);
    end;
    public static function RotatePostfixZX(radians: real): Mtr4x4d := RotatePrefixXZ(radians);
    
    public static function RotatePrefixXW(radians: real): Mtr4x4d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec4d(+a_cos, 0, 0, +a_sin);
      Result.Col1 := new Vec4d(0, 1, 0, 0);
      Result.Col2 := new Vec4d(0, 0, 1, 0);
      Result.Col3 := new Vec4d(-a_sin, 0, 0, +a_cos);
    end;
    public static function RotatePostfixXW(radians: real): Mtr4x4d := RotatePrefixWX(radians);
    
    public static function RotatePrefixWX(radians: real): Mtr4x4d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec4d(+a_cos, 0, 0, -a_sin);
      Result.Col1 := new Vec4d(0, 1, 0, 0);
      Result.Col2 := new Vec4d(0, 0, 1, 0);
      Result.Col3 := new Vec4d(+a_sin, 0, 0, +a_cos);
    end;
    public static function RotatePostfixWX(radians: real): Mtr4x4d := RotatePrefixXW(radians);
    
    public static function RotatePrefixYZ(radians: real): Mtr4x4d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec4d(1, 0, 0, 0);
      Result.Col1 := new Vec4d(0, +a_cos, +a_sin, 0);
      Result.Col2 := new Vec4d(0, -a_sin, +a_cos, 0);
      Result.Col3 := new Vec4d(0, 0, 0, 1);
    end;
    public static function RotatePostfixYZ(radians: real): Mtr4x4d := RotatePrefixZY(radians);
    
    public static function RotatePrefixZY(radians: real): Mtr4x4d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec4d(1, 0, 0, 0);
      Result.Col1 := new Vec4d(0, +a_cos, -a_sin, 0);
      Result.Col2 := new Vec4d(0, +a_sin, +a_cos, 0);
      Result.Col3 := new Vec4d(0, 0, 0, 1);
    end;
    public static function RotatePostfixZY(radians: real): Mtr4x4d := RotatePrefixYZ(radians);
    
    public static function RotatePrefixYW(radians: real): Mtr4x4d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec4d(1, 0, 0, 0);
      Result.Col1 := new Vec4d(0, +a_cos, 0, +a_sin);
      Result.Col2 := new Vec4d(0, 0, 1, 0);
      Result.Col3 := new Vec4d(0, -a_sin, 0, +a_cos);
    end;
    public static function RotatePostfixYW(radians: real): Mtr4x4d := RotatePrefixWY(radians);
    
    public static function RotatePrefixWY(radians: real): Mtr4x4d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec4d(1, 0, 0, 0);
      Result.Col1 := new Vec4d(0, +a_cos, 0, -a_sin);
      Result.Col2 := new Vec4d(0, 0, 1, 0);
      Result.Col3 := new Vec4d(0, +a_sin, 0, +a_cos);
    end;
    public static function RotatePostfixWY(radians: real): Mtr4x4d := RotatePrefixYW(radians);
    
    public static function RotatePrefixZW(radians: real): Mtr4x4d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec4d(1, 0, 0, 0);
      Result.Col1 := new Vec4d(0, 1, 0, 0);
      Result.Col2 := new Vec4d(0, 0, +a_cos, +a_sin);
      Result.Col3 := new Vec4d(0, 0, -a_sin, +a_cos);
    end;
    public static function RotatePostfixZW(radians: real): Mtr4x4d := RotatePrefixWZ(radians);
    
    public static function RotatePrefixWZ(radians: real): Mtr4x4d;
    begin
      var a_sin: double := Sin(radians);
      var a_cos: double := Cos(radians);
      Result.Col0 := new Vec4d(1, 0, 0, 0);
      Result.Col1 := new Vec4d(0, 1, 0, 0);
      Result.Col2 := new Vec4d(0, 0, +a_cos, -a_sin);
      Result.Col3 := new Vec4d(0, 0, +a_sin, +a_cos);
    end;
    public static function RotatePostfixWZ(radians: real): Mtr4x4d := RotatePrefixZW(radians);
    
    public static function RotatePrefixXYZ(radians: real; u: Vec4d): Mtr4x4d;
    begin
      var k1 := Sin(radians);
      var k2 := 2*Sqr(Sin(radians/2));
      Result.val00 :=          1 + k2*(              -u.val2*u.val2-u.val1*u.val1);
      Result.val10 := +k1*u.val2 + k2*(                            +u.val1*u.val0);
      Result.val20 := -k1*u.val1 + k2*(              +u.val2*u.val0              );
      Result.val30 := 0;
      Result.val01 := -k1*u.val2 + k2*(                            +u.val0*u.val1);
      Result.val11 :=          1 + k2*(-u.val2*u.val2              -u.val0*u.val0);
      Result.val21 := +k1*u.val0 + k2*(+u.val2*u.val1                            );
      Result.val31 := 0;
      Result.val02 := +k1*u.val1 + k2*(              +u.val0*u.val2              );
      Result.val12 := -k1*u.val0 + k2*(+u.val1*u.val2                            );
      Result.val22 :=          1 + k2*(-u.val1*u.val1-u.val0*u.val0              );
      Result.val32 := 0;
      Result.val03 := 0;
      Result.val13 := 0;
      Result.val23 := 0;
      Result.val33 := 1;
    end;
    public static function RotatePrefixXZY(radians: real; u: Vec4d): Mtr4x4d := RotatePrefixZYX(radians, u);
    public static function RotatePrefixYXZ(radians: real; u: Vec4d): Mtr4x4d := RotatePrefixZYX(radians, u);
    public static function RotatePrefixYZX(radians: real; u: Vec4d): Mtr4x4d := RotatePrefixXYZ(radians, u);
    public static function RotatePrefixZXY(radians: real; u: Vec4d): Mtr4x4d := RotatePrefixXYZ(radians, u);
    public static function RotatePrefixZYX(radians: real; u: Vec4d): Mtr4x4d;
    begin
      var k1 := Sin(radians);
      var k2 := 2*Sqr(Sin(radians/2));
      Result.val00 :=          1 + k2*(-u.val1*u.val1-u.val0*u.val0              );
      Result.val10 := -k1*u.val0 + k2*(+u.val1*u.val2                            );
      Result.val20 := +k1*u.val1 + k2*(              +u.val0*u.val2              );
      Result.val30 := 0;
      Result.val01 := +k1*u.val0 + k2*(+u.val2*u.val1                            );
      Result.val11 :=          1 + k2*(-u.val2*u.val2              -u.val0*u.val0);
      Result.val21 := -k1*u.val2 + k2*(                            +u.val0*u.val1);
      Result.val31 := 0;
      Result.val02 := -k1*u.val1 + k2*(              +u.val2*u.val0              );
      Result.val12 := +k1*u.val2 + k2*(                            +u.val1*u.val0);
      Result.val22 :=          1 + k2*(              -u.val2*u.val2-u.val1*u.val1);
      Result.val32 := 0;
      Result.val03 := 0;
      Result.val13 := 0;
      Result.val23 := 0;
      Result.val33 := 1;
    end;
    
    public static function RotatePostfixXYZ(radians: real; u: Vec4d): Mtr4x4d := RotatePrefixZYX(radians, u);
    public static function RotatePostfixXZY(radians: real; u: Vec4d): Mtr4x4d := RotatePrefixYZX(radians, u);
    public static function RotatePostfixYXZ(radians: real; u: Vec4d): Mtr4x4d := RotatePrefixZXY(radians, u);
    public static function RotatePostfixYZX(radians: real; u: Vec4d): Mtr4x4d := RotatePrefixXZY(radians, u);
    public static function RotatePostfixZXY(radians: real; u: Vec4d): Mtr4x4d := RotatePrefixYXZ(radians, u);
    public static function RotatePostfixZYX(radians: real; u: Vec4d): Mtr4x4d := RotatePrefixXYZ(radians, u);
    
    public function Determinant: double;
    begin
      var det01 := self.val20*self.val31 - self.val21*self.val30;
      var det02 := self.val20*self.val32 - self.val22*self.val30;
      var det03 := self.val20*self.val33 - self.val23*self.val30;
      var det12 := self.val21*self.val32 - self.val22*self.val31;
      var det13 := self.val21*self.val33 - self.val23*self.val31;
      var det23 := self.val22*self.val33 - self.val23*self.val32;
      var det012 := self.val10*det12 - self.val11*det02 + self.val12*det01;
      var det013 := self.val10*det13 - self.val11*det03 + self.val13*det01;
      var det023 := self.val10*det23 - self.val12*det03 + self.val13*det02;
      var det123 := self.val11*det23 - self.val12*det13 + self.val13*det12;
      Result := self.val00*det123 - self.val01*det023 + self.val02*det013 - self.val03*det012;
    end;
    
  end;
  Mtr4d = Mtr4x4d;
  
  Mtr4x4f = record
    public val00, val10, val20, val30: single;
    public val01, val11, val21, val31: single;
    public val02, val12, val22, val32: single;
    public val03, val13, val23, val33: single;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23, val30, val31, val32, val33: single);
    begin
      self.val00 := val00; self.val01 := val01; self.val02 := val02; self.val03 := val03;
      self.val10 := val10; self.val11 := val11; self.val12 := val12; self.val13 := val13;
      self.val20 := val20; self.val21 := val21; self.val22 := val22; self.val23 := val23;
      self.val30 := val30; self.val31 := val31; self.val32 := val32; self.val33 := val33;
    end;
    
    public static function GenerateUnordered(gen: function(row_i, col_i: integer): single): Mtr4x4f :=
      Mtr4x4f.FromCols(new Vec4f(gen(0,0), gen(1,0), gen(2,0), gen(3,0)), new Vec4f(gen(0,1), gen(1,1), gen(2,1), gen(3,1)), new Vec4f(gen(0,2), gen(1,2), gen(2,2), gen(3,2)), new Vec4f(gen(0,3), gen(1,3), gen(2,3), gen(3,3)));
    public static function GenerateByRow(gen: function(row_i: integer): Vec4f): Mtr4x4f :=
      Mtr4x4f.FromRows(gen(0), gen(1), gen(2), gen(3));
    public static function GenerateByCol(gen: function(col_i: integer): Vec4f): Mtr4x4f :=
      Mtr4x4f.FromCols(gen(0), gen(1), gen(2), gen(3));
    
    public static function ReadByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec4f.Read(prompt_by_row?.Invoke(row_i)));
    public static function ReadByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec4f.Read(prompt_by_col?.Invoke(col_i)));
    
    public static function ReadLnByRow(prompt_by_row: function(row_i: integer): string := nil) :=
      GenerateByRow(row_i->Vec4f.ReadLn(prompt_by_row?.Invoke(row_i)));
    public static function ReadLnByCol(prompt_by_col: function(col_i: integer): string := nil) :=
      GenerateByCol(col_i->Vec4f.ReadLn(prompt_by_col?.Invoke(col_i)));
    
    public static function Random(a, b: single): Mtr4x4f;
    begin
      if a>b then Swap(a,b);
      var r := b-a;
      Result := new Mtr4x4f(a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r), a+PABCSystem.Random(r));
    end;
    
    public procedure Deconstruct(var val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23, val30, val31, val32, val33: single);
    begin
      val00 := self.val00; val01 := self.val01; val02 := self.val02; val03 := self.val03;
      val10 := self.val10; val11 := self.val11; val12 := self.val12; val13 := self.val13;
      val20 := self.val20; val21 := self.val21; val22 := self.val22; val23 := self.val23;
      val30 := self.val30; val31 := self.val31; val32 := self.val32; val33 := self.val33;
    end;
    
    public procedure DeconstructRows(var row0, row1, row2, row3: Vec4f);
    begin
      row0 := self.Row0;
      row1 := self.Row1;
      row2 := self.Row2;
      row3 := self.Row3;
    end;
    public procedure Deconstruct(var row0, row1, row2, row3: Vec4f) := DeconstructRows(row0, row1, row2, row3);
    
    public procedure DeconstructCols(var col0, col1, col2, col3: Vec4f);
    begin
      col0 := self.Col0;
      col1 := self.Col1;
      col2 := self.Col2;
      col3 := self.Col3;
    end;
    
    private static function ValStr(val: single): string;
    begin
      Result := val.ToString('f2');
      if Result.First<>'-' then
        Result := '+'+Result;
    end;
    public function ToString: string; override;
    begin
      var s00 := ValStr(val00); var s10 := ValStr(val10); var s20 := ValStr(val20); var s30 := ValStr(val30); var col_sz0 := s00.Length.ClampBottom(s10.Length).ClampBottom(s20.Length).ClampBottom(s30.Length);
      var s01 := ValStr(val01); var s11 := ValStr(val11); var s21 := ValStr(val21); var s31 := ValStr(val31); var col_sz1 := s01.Length.ClampBottom(s11.Length).ClampBottom(s21.Length).ClampBottom(s31.Length);
      var s02 := ValStr(val02); var s12 := ValStr(val12); var s22 := ValStr(val22); var s32 := ValStr(val32); var col_sz2 := s02.Length.ClampBottom(s12.Length).ClampBottom(s22.Length).ClampBottom(s32.Length);
      var s03 := ValStr(val03); var s13 := ValStr(val13); var s23 := ValStr(val23); var s33 := ValStr(val33); var col_sz3 := s03.Length.ClampBottom(s13.Length).ClampBottom(s23.Length).ClampBottom(s33.Length);
      var total_w := 8; // 2*(ColCount-1) + 2
      total_w += col_sz0;
      total_w += col_sz1;
      total_w += col_sz2;
      total_w += col_sz3;
      var res := new StringBuilder;
      res += '╓';
      res.Append(' ', total_w);
      res += '╖'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s00.Length); res += s00; res += ', ';
      res.Append(' ', col_sz1 - s01.Length); res += s01; res += ', ';
      res.Append(' ', col_sz2 - s02.Length); res += s02; res += ', ';
      res.Append(' ', col_sz3 - s03.Length); res += s03;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s10.Length); res += s10; res += ', ';
      res.Append(' ', col_sz1 - s11.Length); res += s11; res += ', ';
      res.Append(' ', col_sz2 - s12.Length); res += s12; res += ', ';
      res.Append(' ', col_sz3 - s13.Length); res += s13;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s20.Length); res += s20; res += ', ';
      res.Append(' ', col_sz1 - s21.Length); res += s21; res += ', ';
      res.Append(' ', col_sz2 - s22.Length); res += s22; res += ', ';
      res.Append(' ', col_sz3 - s23.Length); res += s23;
      res += ' ║'#10;
      res += '║ ';
      res.Append(' ', col_sz0 - s30.Length); res += s30; res += ', ';
      res.Append(' ', col_sz1 - s31.Length); res += s31; res += ', ';
      res.Append(' ', col_sz2 - s32.Length); res += s32; res += ', ';
      res.Append(' ', col_sz3 - s33.Length); res += s33;
      res += ' ║'#10;
      res += '╙';
      res.Append(' ', total_w);
      res += '╜';
      Result := res.ToString;
    end;
    
    public function PrintLn: Mtr4x4f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static property Identity: Mtr4x4f read
      new Mtr4x4f(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    
    public static function FromRows(row0, row1, row2, row3: Vec4f): Mtr4x4f;
    begin
      Result.Row0 := row0;
      Result.Row1 := row1;
      Result.Row2 := row2;
      Result.Row3 := row3;
    end;
    
    public property Row0: Vec4f
      read new Vec4f(val00, val01, val02, val03)
      write value.Deconstruct(val00, val01, val02, val03);
    
    public property Row1: Vec4f
      read new Vec4f(val10, val11, val12, val13)
      write value.Deconstruct(val10, val11, val12, val13);
    
    public property Row2: Vec4f
      read new Vec4f(val20, val21, val22, val23)
      write value.Deconstruct(val20, val21, val22, val23);
    
    public property Row3: Vec4f
      read new Vec4f(val30, val31, val32, val33)
      write value.Deconstruct(val30, val31, val32, val33);
    
    private function GetRowAt(row_i: integer): Vec4f;
    begin
      case row_i of
        0: Result := Row0;
        1: Result := Row1;
        2: Result := Row2;
        3: Result := Row3;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetRowAt(row_i: integer; new_val: Vec4f) :=
      case row_i of
        0: Row0 := new_val;
        1: Row1 := new_val;
        2: Row2 := new_val;
        3: Row3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "row_i" должен иметь значение 0..3');
      end;
    public property RowAt[row_i: integer]: Vec4f read GetRowAt write SetRowAt;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachRow(use: UseVec4fCallback);
    begin
      use(Row0);
      use(Row1);
      use(Row2);
      use(Row3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachRow<T>(conv: ConvVec4fCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := conv(Row0);
      Result.Item2 := conv(Row1);
      Result.Item3 := conv(Row2);
      Result.Item4 := conv(Row3);
    end;
    
    public static function FromCols(col0, col1, col2, col3: Vec4f): Mtr4x4f;
    begin
      Result.Col0 := col0;
      Result.Col1 := col1;
      Result.Col2 := col2;
      Result.Col3 := col3;
    end;
    
    public property Col0: Vec4f
      read PVec4f(pointer(@val00))^
      write PVec4f(pointer(@val00))^ := value;
    
    public property Col1: Vec4f
      read PVec4f(pointer(@val01))^
      write PVec4f(pointer(@val01))^ := value;
    
    public property Col2: Vec4f
      read PVec4f(pointer(@val02))^
      write PVec4f(pointer(@val02))^ := value;
    
    public property Col3: Vec4f
      read PVec4f(pointer(@val03))^
      write PVec4f(pointer(@val03))^ := value;
    
    private function GetColAt(col_i: integer): Vec4f;
    begin
      case col_i of
        0: Result := Col0;
        1: Result := Col1;
        2: Result := Col2;
        3: Result := Col3;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetColAt(col_i: integer; new_val: Vec4f) :=
      case col_i of
        0: Col0 := new_val;
        1: Col1 := new_val;
        2: Col2 := new_val;
        3: Col3 := new_val;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    public property ColAt[col_i: integer]: Vec4f read GetColAt write SetColAt;
    
    public function GetColUnsafePtr0: PVec4f := pointer(@val00);
    public function GetColUnsafePtr1: PVec4f := pointer(@val01);
    public function GetColUnsafePtr2: PVec4f := pointer(@val02);
    public function GetColUnsafePtr3: PVec4f := pointer(@val03);
    public function GetColUnsafePtrAt(col_i: integer): PVec4f;
    begin
      case col_i of
        0: Result := GetColUnsafePtr0;
        1: Result := GetColUnsafePtr1;
        2: Result := GetColUnsafePtr2;
        3: Result := GetColUnsafePtr3;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol0SafePtr(use: UseVec4fSafePtrCallback) := use(PVec4f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol1SafePtr(use: UseVec4fSafePtrCallback) := use(PVec4f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol2SafePtr(use: UseVec4fSafePtrCallback) := use(PVec4f(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseCol3SafePtr(use: UseVec4fSafePtrCallback) := use(PVec4f(pointer(@val03))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol0SafePtr<T>(conv: ConvVec4fSafePtrCallback<T>) := conv(PVec4f(pointer(@val00))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol1SafePtr<T>(conv: ConvVec4fSafePtrCallback<T>) := conv(PVec4f(pointer(@val01))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol2SafePtr<T>(conv: ConvVec4fSafePtrCallback<T>) := conv(PVec4f(pointer(@val02))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvCol3SafePtr<T>(conv: ConvVec4fSafePtrCallback<T>) := conv(PVec4f(pointer(@val03))^);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseColSafePtrAt(col_i: integer; use: UseVec4fSafePtrCallback);
    begin
      case col_i of
        0: UseCol0SafePtr(use);
        1: UseCol1SafePtr(use);
        2: UseCol2SafePtr(use);
        3: UseCol3SafePtr(use);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvColSafePtrAt<T>(col_i: integer; conv: ConvVec4fSafePtrCallback<T>): T;
    begin
      case col_i of
        0: Result := ConvCol0SafePtr(conv);
        1: Result := ConvCol1SafePtr(conv);
        2: Result := ConvCol2SafePtr(conv);
        3: Result := ConvCol3SafePtr(conv);
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachCol(use: UseVec4fCallback);
    begin
      use(Col0);
      use(Col1);
      use(Col2);
      use(Col3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachCol<T>(conv: ConvVec4fCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := conv(Col0);
      Result.Item2 := conv(Col1);
      Result.Item3 := conv(Col2);
      Result.Item4 := conv(Col3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseEachColSafePtr(use: UseVec4fSafePtrCallback);
    begin
      UseCol0SafePtr(use);
      UseCol1SafePtr(use);
      UseCol2SafePtr(use);
      UseCol3SafePtr(use);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ConvEachColSafePtr<T>(conv: ConvVec4fSafePtrCallback<T>): ValueTuple<T, T, T, T>;
    begin
      Result.Item1 := ConvCol0SafePtr(conv);
      Result.Item2 := ConvCol1SafePtr(conv);
      Result.Item3 := ConvCol2SafePtr(conv);
      Result.Item4 := ConvCol3SafePtr(conv);
    end;
    
    private function GetValAt(row_i, col_i: integer): single;
    begin
      case col_i of
        0: Result := self.Col0.GetValAt(row_i, 'row_i');
        1: Result := self.Col1.GetValAt(row_i, 'row_i');
        2: Result := self.Col2.GetValAt(row_i, 'row_i');
        3: Result := self.Col3.GetValAt(row_i, 'row_i');
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    end;
    private procedure SetValAt(row_i, col_i: integer; new_val: single) :=
      case col_i of
        0: begin var col := self.Col0; col.SetValAt(row_i, new_val, 'row_i'); self.Col0 := col; end;
        1: begin var col := self.Col1; col.SetValAt(row_i, new_val, 'row_i'); self.Col1 := col; end;
        2: begin var col := self.Col2; col.SetValAt(row_i, new_val, 'row_i'); self.Col2 := col; end;
        3: begin var col := self.Col3; col.SetValAt(row_i, new_val, 'row_i'); self.Col3 := col; end;
        else raise new IndexOutOfRangeException($'Индекс "col_i" должен иметь значение 0..3');
      end;
    public property ValAt[row_i, col_i: integer]: single read GetValAt(row_i, col_i) write SetValAt(row_i, col_i, value);
    
    public static function Scale(k: single) :=
      new Mtr4x4f(k, 0, 0, 0, 0, k, 0, 0, 0, 0, k, 0, 0, 0, 0, k);
    
    public static function TranslatePrefix(ΔX, ΔY, ΔZ: single) :=
      new Mtr4x4f(1, 0, 0, ΔX, 0, 1, 0, ΔY, 0, 0, 1, ΔZ, 0, 0, 0, 1);
    
    public static function TranslatePostfix(ΔX, ΔY, ΔZ: single) :=
      new Mtr4x4f(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ΔX, ΔY, ΔZ, 1);
    
    public static function RotatePrefixXY(radians: real): Mtr4x4f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec4f(+a_cos, +a_sin, 0, 0);
      Result.Col1 := new Vec4f(-a_sin, +a_cos, 0, 0);
      Result.Col2 := new Vec4f(0, 0, 1, 0);
      Result.Col3 := new Vec4f(0, 0, 0, 1);
    end;
    public static function RotatePostfixXY(radians: real): Mtr4x4f := RotatePrefixYX(radians);
    
    public static function RotatePrefixYX(radians: real): Mtr4x4f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec4f(+a_cos, -a_sin, 0, 0);
      Result.Col1 := new Vec4f(+a_sin, +a_cos, 0, 0);
      Result.Col2 := new Vec4f(0, 0, 1, 0);
      Result.Col3 := new Vec4f(0, 0, 0, 1);
    end;
    public static function RotatePostfixYX(radians: real): Mtr4x4f := RotatePrefixXY(radians);
    
    public static function RotatePrefixXZ(radians: real): Mtr4x4f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec4f(+a_cos, 0, +a_sin, 0);
      Result.Col1 := new Vec4f(0, 1, 0, 0);
      Result.Col2 := new Vec4f(-a_sin, 0, +a_cos, 0);
      Result.Col3 := new Vec4f(0, 0, 0, 1);
    end;
    public static function RotatePostfixXZ(radians: real): Mtr4x4f := RotatePrefixZX(radians);
    
    public static function RotatePrefixZX(radians: real): Mtr4x4f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec4f(+a_cos, 0, -a_sin, 0);
      Result.Col1 := new Vec4f(0, 1, 0, 0);
      Result.Col2 := new Vec4f(+a_sin, 0, +a_cos, 0);
      Result.Col3 := new Vec4f(0, 0, 0, 1);
    end;
    public static function RotatePostfixZX(radians: real): Mtr4x4f := RotatePrefixXZ(radians);
    
    public static function RotatePrefixXW(radians: real): Mtr4x4f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec4f(+a_cos, 0, 0, +a_sin);
      Result.Col1 := new Vec4f(0, 1, 0, 0);
      Result.Col2 := new Vec4f(0, 0, 1, 0);
      Result.Col3 := new Vec4f(-a_sin, 0, 0, +a_cos);
    end;
    public static function RotatePostfixXW(radians: real): Mtr4x4f := RotatePrefixWX(radians);
    
    public static function RotatePrefixWX(radians: real): Mtr4x4f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec4f(+a_cos, 0, 0, -a_sin);
      Result.Col1 := new Vec4f(0, 1, 0, 0);
      Result.Col2 := new Vec4f(0, 0, 1, 0);
      Result.Col3 := new Vec4f(+a_sin, 0, 0, +a_cos);
    end;
    public static function RotatePostfixWX(radians: real): Mtr4x4f := RotatePrefixXW(radians);
    
    public static function RotatePrefixYZ(radians: real): Mtr4x4f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec4f(1, 0, 0, 0);
      Result.Col1 := new Vec4f(0, +a_cos, +a_sin, 0);
      Result.Col2 := new Vec4f(0, -a_sin, +a_cos, 0);
      Result.Col3 := new Vec4f(0, 0, 0, 1);
    end;
    public static function RotatePostfixYZ(radians: real): Mtr4x4f := RotatePrefixZY(radians);
    
    public static function RotatePrefixZY(radians: real): Mtr4x4f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec4f(1, 0, 0, 0);
      Result.Col1 := new Vec4f(0, +a_cos, -a_sin, 0);
      Result.Col2 := new Vec4f(0, +a_sin, +a_cos, 0);
      Result.Col3 := new Vec4f(0, 0, 0, 1);
    end;
    public static function RotatePostfixZY(radians: real): Mtr4x4f := RotatePrefixYZ(radians);
    
    public static function RotatePrefixYW(radians: real): Mtr4x4f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec4f(1, 0, 0, 0);
      Result.Col1 := new Vec4f(0, +a_cos, 0, +a_sin);
      Result.Col2 := new Vec4f(0, 0, 1, 0);
      Result.Col3 := new Vec4f(0, -a_sin, 0, +a_cos);
    end;
    public static function RotatePostfixYW(radians: real): Mtr4x4f := RotatePrefixWY(radians);
    
    public static function RotatePrefixWY(radians: real): Mtr4x4f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec4f(1, 0, 0, 0);
      Result.Col1 := new Vec4f(0, +a_cos, 0, -a_sin);
      Result.Col2 := new Vec4f(0, 0, 1, 0);
      Result.Col3 := new Vec4f(0, +a_sin, 0, +a_cos);
    end;
    public static function RotatePostfixWY(radians: real): Mtr4x4f := RotatePrefixYW(radians);
    
    public static function RotatePrefixZW(radians: real): Mtr4x4f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec4f(1, 0, 0, 0);
      Result.Col1 := new Vec4f(0, 1, 0, 0);
      Result.Col2 := new Vec4f(0, 0, +a_cos, +a_sin);
      Result.Col3 := new Vec4f(0, 0, -a_sin, +a_cos);
    end;
    public static function RotatePostfixZW(radians: real): Mtr4x4f := RotatePrefixWZ(radians);
    
    public static function RotatePrefixWZ(radians: real): Mtr4x4f;
    begin
      var a_sin: single := Sin(radians);
      var a_cos: single := Cos(radians);
      Result.Col0 := new Vec4f(1, 0, 0, 0);
      Result.Col1 := new Vec4f(0, 1, 0, 0);
      Result.Col2 := new Vec4f(0, 0, +a_cos, -a_sin);
      Result.Col3 := new Vec4f(0, 0, +a_sin, +a_cos);
    end;
    public static function RotatePostfixWZ(radians: real): Mtr4x4f := RotatePrefixZW(radians);
    
    public static function RotatePrefixXYZ(radians: real; u: Vec4f): Mtr4x4f;
    begin
      var k1 := Sin(radians);
      var k2 := 2*Sqr(Sin(radians/2));
      Result.val00 :=          1 + k2*(              -u.val2*u.val2-u.val1*u.val1);
      Result.val10 := +k1*u.val2 + k2*(                            +u.val1*u.val0);
      Result.val20 := -k1*u.val1 + k2*(              +u.val2*u.val0              );
      Result.val30 := 0;
      Result.val01 := -k1*u.val2 + k2*(                            +u.val0*u.val1);
      Result.val11 :=          1 + k2*(-u.val2*u.val2              -u.val0*u.val0);
      Result.val21 := +k1*u.val0 + k2*(+u.val2*u.val1                            );
      Result.val31 := 0;
      Result.val02 := +k1*u.val1 + k2*(              +u.val0*u.val2              );
      Result.val12 := -k1*u.val0 + k2*(+u.val1*u.val2                            );
      Result.val22 :=          1 + k2*(-u.val1*u.val1-u.val0*u.val0              );
      Result.val32 := 0;
      Result.val03 := 0;
      Result.val13 := 0;
      Result.val23 := 0;
      Result.val33 := 1;
    end;
    public static function RotatePrefixXZY(radians: real; u: Vec4f): Mtr4x4f := RotatePrefixZYX(radians, u);
    public static function RotatePrefixYXZ(radians: real; u: Vec4f): Mtr4x4f := RotatePrefixZYX(radians, u);
    public static function RotatePrefixYZX(radians: real; u: Vec4f): Mtr4x4f := RotatePrefixXYZ(radians, u);
    public static function RotatePrefixZXY(radians: real; u: Vec4f): Mtr4x4f := RotatePrefixXYZ(radians, u);
    public static function RotatePrefixZYX(radians: real; u: Vec4f): Mtr4x4f;
    begin
      var k1 := Sin(radians);
      var k2 := 2*Sqr(Sin(radians/2));
      Result.val00 :=          1 + k2*(-u.val1*u.val1-u.val0*u.val0              );
      Result.val10 := -k1*u.val0 + k2*(+u.val1*u.val2                            );
      Result.val20 := +k1*u.val1 + k2*(              +u.val0*u.val2              );
      Result.val30 := 0;
      Result.val01 := +k1*u.val0 + k2*(+u.val2*u.val1                            );
      Result.val11 :=          1 + k2*(-u.val2*u.val2              -u.val0*u.val0);
      Result.val21 := -k1*u.val2 + k2*(                            +u.val0*u.val1);
      Result.val31 := 0;
      Result.val02 := -k1*u.val1 + k2*(              +u.val2*u.val0              );
      Result.val12 := +k1*u.val2 + k2*(                            +u.val1*u.val0);
      Result.val22 :=          1 + k2*(              -u.val2*u.val2-u.val1*u.val1);
      Result.val32 := 0;
      Result.val03 := 0;
      Result.val13 := 0;
      Result.val23 := 0;
      Result.val33 := 1;
    end;
    
    public static function RotatePostfixXYZ(radians: real; u: Vec4f): Mtr4x4f := RotatePrefixZYX(radians, u);
    public static function RotatePostfixXZY(radians: real; u: Vec4f): Mtr4x4f := RotatePrefixYZX(radians, u);
    public static function RotatePostfixYXZ(radians: real; u: Vec4f): Mtr4x4f := RotatePrefixZXY(radians, u);
    public static function RotatePostfixYZX(radians: real; u: Vec4f): Mtr4x4f := RotatePrefixXZY(radians, u);
    public static function RotatePostfixZXY(radians: real; u: Vec4f): Mtr4x4f := RotatePrefixYXZ(radians, u);
    public static function RotatePostfixZYX(radians: real; u: Vec4f): Mtr4x4f := RotatePrefixXYZ(radians, u);
    
    public function Determinant: single;
    begin
      var det01 := self.val20*self.val31 - self.val21*self.val30;
      var det02 := self.val20*self.val32 - self.val22*self.val30;
      var det03 := self.val20*self.val33 - self.val23*self.val30;
      var det12 := self.val21*self.val32 - self.val22*self.val31;
      var det13 := self.val21*self.val33 - self.val23*self.val31;
      var det23 := self.val22*self.val33 - self.val23*self.val32;
      var det012 := self.val10*det12 - self.val11*det02 + self.val12*det01;
      var det013 := self.val10*det13 - self.val11*det03 + self.val13*det01;
      var det023 := self.val10*det23 - self.val12*det03 + self.val13*det02;
      var det123 := self.val11*det23 - self.val12*det13 + self.val13*det12;
      Result := self.val00*det123 - self.val01*det023 + self.val02*det013 - self.val03*det012;
    end;
    
  end;
  Mtr4f = Mtr4x4f;
  
  glAccumOp = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACCUM:  glAccumOp read new glAccumOp($0100);
    public static property LOAD:   glAccumOp read new glAccumOp($0101);
    public static property RETURN: glAccumOp read new glAccumOp($0102);
    public static property MULT:   glAccumOp read new glAccumOp($0103);
    public static property ADD:    glAccumOp read new glAccumOp($0104);
    
    public function ToString: string; override;
    begin
      if ACCUM = self then
        Result := 'ACCUM' else
      if LOAD = self then
        Result := 'LOAD' else
      if RETURN = self then
        Result := 'RETURN' else
      if MULT = self then
        Result := 'MULT' else
      if ADD = self then
        Result := 'ADD' else
        Result := $'glAccumOp[{self.val}]';
    end;
    
  end;
  
  glAlphaFunction = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEVER:    glAlphaFunction read new glAlphaFunction($0200);
    public static property LESS:     glAlphaFunction read new glAlphaFunction($0201);
    public static property EQUAL:    glAlphaFunction read new glAlphaFunction($0202);
    public static property LEQUAL:   glAlphaFunction read new glAlphaFunction($0203);
    public static property GREATER:  glAlphaFunction read new glAlphaFunction($0204);
    public static property NOTEQUAL: glAlphaFunction read new glAlphaFunction($0205);
    public static property GEQUAL:   glAlphaFunction read new glAlphaFunction($0206);
    public static property ALWAYS:   glAlphaFunction read new glAlphaFunction($0207);
    
    public function ToString: string; override;
    begin
      if NEVER = self then
        Result := 'NEVER' else
      if LESS = self then
        Result := 'LESS' else
      if EQUAL = self then
        Result := 'EQUAL' else
      if LEQUAL = self then
        Result := 'LEQUAL' else
      if GREATER = self then
        Result := 'GREATER' else
      if NOTEQUAL = self then
        Result := 'NOTEQUAL' else
      if GEQUAL = self then
        Result := 'GEQUAL' else
      if ALWAYS = self then
        Result := 'ALWAYS' else
        Result := $'glAlphaFunction[{self.val}]';
    end;
    
  end;
  
  glArrayObjectPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property OBJECT_BUFFER_SIZE:  glArrayObjectPName read new glArrayObjectPName($8764);
    public static property OBJECT_BUFFER_USAGE: glArrayObjectPName read new glArrayObjectPName($8765);
    
    public function ToString: string; override;
    begin
      if OBJECT_BUFFER_SIZE = self then
        Result := 'OBJECT_BUFFER_SIZE' else
      if OBJECT_BUFFER_USAGE = self then
        Result := 'OBJECT_BUFFER_USAGE' else
        Result := $'glArrayObjectPName[{self.val}]';
    end;
    
  end;
  
  glArrayObjectUsage = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property &STATIC: glArrayObjectUsage read new glArrayObjectUsage($8760);
    public static property DYNAMIC: glArrayObjectUsage read new glArrayObjectUsage($8761);
    
    public function ToString: string; override;
    begin
      if &STATIC = self then
        Result := 'STATIC' else
      if DYNAMIC = self then
        Result := 'DYNAMIC' else
        Result := $'glArrayObjectUsage[{self.val}]';
    end;
    
  end;
  
  glAtomicCounterBufferPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER:         glAtomicCounterBufferPName read new glAtomicCounterBufferPName($90ED);
    public static property ATOMIC_COUNTER_BUFFER_BINDING:                              glAtomicCounterBufferPName read new glAtomicCounterBufferPName($92C1);
    public static property ATOMIC_COUNTER_BUFFER_DATA_SIZE:                            glAtomicCounterBufferPName read new glAtomicCounterBufferPName($92C4);
    public static property ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS:               glAtomicCounterBufferPName read new glAtomicCounterBufferPName($92C5);
    public static property ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES:        glAtomicCounterBufferPName read new glAtomicCounterBufferPName($92C6);
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER:          glAtomicCounterBufferPName read new glAtomicCounterBufferPName($92C7);
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER:    glAtomicCounterBufferPName read new glAtomicCounterBufferPName($92C8);
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER: glAtomicCounterBufferPName read new glAtomicCounterBufferPName($92C9);
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER:        glAtomicCounterBufferPName read new glAtomicCounterBufferPName($92CA);
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER:        glAtomicCounterBufferPName read new glAtomicCounterBufferPName($92CB);
    
    public function ToString: string; override;
    begin
      if ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER = self then
        Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER' else
      if ATOMIC_COUNTER_BUFFER_BINDING = self then
        Result := 'ATOMIC_COUNTER_BUFFER_BINDING' else
      if ATOMIC_COUNTER_BUFFER_DATA_SIZE = self then
        Result := 'ATOMIC_COUNTER_BUFFER_DATA_SIZE' else
      if ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS = self then
        Result := 'ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS' else
      if ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES = self then
        Result := 'ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES' else
      if ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER = self then
        Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER' else
      if ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER = self then
        Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER' else
      if ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER = self then
        Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER' else
      if ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER = self then
        Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER' else
      if ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER = self then
        Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER' else
        Result := $'glAtomicCounterBufferPName[{self.val}]';
    end;
    
  end;
  
  glAttribMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CURRENT_BIT:         glAttribMask read new glAttribMask(1 shl 0);
    public static property POINT_BIT:           glAttribMask read new glAttribMask(1 shl 1);
    public static property LINE_BIT:            glAttribMask read new glAttribMask(1 shl 2);
    public static property POLYGON_BIT:         glAttribMask read new glAttribMask(1 shl 3);
    public static property POLYGON_STIPPLE_BIT: glAttribMask read new glAttribMask(1 shl 4);
    public static property PIXEL_MODE_BIT:      glAttribMask read new glAttribMask(1 shl 5);
    public static property LIGHTING_BIT:        glAttribMask read new glAttribMask(1 shl 6);
    public static property FOG_BIT:             glAttribMask read new glAttribMask(1 shl 7);
    public static property DEPTH_BUFFER_BIT:    glAttribMask read new glAttribMask(1 shl 8);
    public static property ACCUM_BUFFER_BIT:    glAttribMask read new glAttribMask(1 shl 9);
    public static property STENCIL_BUFFER_BIT:  glAttribMask read new glAttribMask(1 shl 10);
    public static property VIEWPORT_BIT:        glAttribMask read new glAttribMask(1 shl 11);
    public static property TRANSFORM_BIT:       glAttribMask read new glAttribMask(1 shl 12);
    public static property ENABLE_BIT:          glAttribMask read new glAttribMask(1 shl 13);
    public static property COLOR_BUFFER_BIT:    glAttribMask read new glAttribMask(1 shl 14);
    public static property HINT_BIT:            glAttribMask read new glAttribMask(1 shl 15);
    public static property EVAL_BIT:            glAttribMask read new glAttribMask(1 shl 16);
    public static property LIST_BIT:            glAttribMask read new glAttribMask(1 shl 17);
    public static property TEXTURE_BIT:         glAttribMask read new glAttribMask(1 shl 18);
    public static property SCISSOR_BIT:         glAttribMask read new glAttribMask(1 shl 19);
    public static property MULTISAMPLE_BIT:     glAttribMask read new glAttribMask(1 shl 29);
    public static property ALL_ATTRIB_BITS:     glAttribMask read new glAttribMask($FFFFFFFF);
    
    public static function operator+(v1, v2: glAttribMask) := new glAttribMask(v1.val or v2.val);
    public static function operator or(v1, v2: glAttribMask) := new glAttribMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glAttribMask; v2: glAttribMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glAttribMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glAttribMask[0]';
        exit;
      end;
      if CURRENT_BIT in self then
      begin
        res += 'CURRENT_BIT+';
        left_val := left_val and not CURRENT_BIT.val;
      end;
      if POINT_BIT in self then
      begin
        res += 'POINT_BIT+';
        left_val := left_val and not POINT_BIT.val;
      end;
      if LINE_BIT in self then
      begin
        res += 'LINE_BIT+';
        left_val := left_val and not LINE_BIT.val;
      end;
      if POLYGON_BIT in self then
      begin
        res += 'POLYGON_BIT+';
        left_val := left_val and not POLYGON_BIT.val;
      end;
      if POLYGON_STIPPLE_BIT in self then
      begin
        res += 'POLYGON_STIPPLE_BIT+';
        left_val := left_val and not POLYGON_STIPPLE_BIT.val;
      end;
      if PIXEL_MODE_BIT in self then
      begin
        res += 'PIXEL_MODE_BIT+';
        left_val := left_val and not PIXEL_MODE_BIT.val;
      end;
      if LIGHTING_BIT in self then
      begin
        res += 'LIGHTING_BIT+';
        left_val := left_val and not LIGHTING_BIT.val;
      end;
      if FOG_BIT in self then
      begin
        res += 'FOG_BIT+';
        left_val := left_val and not FOG_BIT.val;
      end;
      if DEPTH_BUFFER_BIT in self then
      begin
        res += 'DEPTH_BUFFER_BIT+';
        left_val := left_val and not DEPTH_BUFFER_BIT.val;
      end;
      if ACCUM_BUFFER_BIT in self then
      begin
        res += 'ACCUM_BUFFER_BIT+';
        left_val := left_val and not ACCUM_BUFFER_BIT.val;
      end;
      if STENCIL_BUFFER_BIT in self then
      begin
        res += 'STENCIL_BUFFER_BIT+';
        left_val := left_val and not STENCIL_BUFFER_BIT.val;
      end;
      if VIEWPORT_BIT in self then
      begin
        res += 'VIEWPORT_BIT+';
        left_val := left_val and not VIEWPORT_BIT.val;
      end;
      if TRANSFORM_BIT in self then
      begin
        res += 'TRANSFORM_BIT+';
        left_val := left_val and not TRANSFORM_BIT.val;
      end;
      if ENABLE_BIT in self then
      begin
        res += 'ENABLE_BIT+';
        left_val := left_val and not ENABLE_BIT.val;
      end;
      if COLOR_BUFFER_BIT in self then
      begin
        res += 'COLOR_BUFFER_BIT+';
        left_val := left_val and not COLOR_BUFFER_BIT.val;
      end;
      if HINT_BIT in self then
      begin
        res += 'HINT_BIT+';
        left_val := left_val and not HINT_BIT.val;
      end;
      if EVAL_BIT in self then
      begin
        res += 'EVAL_BIT+';
        left_val := left_val and not EVAL_BIT.val;
      end;
      if LIST_BIT in self then
      begin
        res += 'LIST_BIT+';
        left_val := left_val and not LIST_BIT.val;
      end;
      if TEXTURE_BIT in self then
      begin
        res += 'TEXTURE_BIT+';
        left_val := left_val and not TEXTURE_BIT.val;
      end;
      if SCISSOR_BIT in self then
      begin
        res += 'SCISSOR_BIT+';
        left_val := left_val and not SCISSOR_BIT.val;
      end;
      if MULTISAMPLE_BIT in self then
      begin
        res += 'MULTISAMPLE_BIT+';
        left_val := left_val and not MULTISAMPLE_BIT.val;
      end;
      if ALL_ATTRIB_BITS in self then
      begin
        res += 'ALL_ATTRIB_BITS+';
        left_val := left_val and not ALL_ATTRIB_BITS.val;
      end;
      if left_val<>0 then
      begin
        res += 'glAttribMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glAttributeType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property INT:                                       glAttributeType read new glAttributeType($1404);
    public static property UNSIGNED_INT:                              glAttributeType read new glAttributeType($1405);
    public static property FLOAT:                                     glAttributeType read new glAttributeType($1406);
    public static property DOUBLE:                                    glAttributeType read new glAttributeType($140A);
    public static property INT64:                                     glAttributeType read new glAttributeType($140E);
    public static property UNSIGNED_INT64_ARB:                        glAttributeType read new glAttributeType($140F);
    public static property UNSIGNED_INT64_NV:                         glAttributeType read new glAttributeType($140F);
    public static property FLOAT_VEC2:                                glAttributeType read new glAttributeType($8B50);
    public static property FLOAT_VEC3:                                glAttributeType read new glAttributeType($8B51);
    public static property FLOAT_VEC4:                                glAttributeType read new glAttributeType($8B52);
    public static property INT_VEC2:                                  glAttributeType read new glAttributeType($8B53);
    public static property INT_VEC3:                                  glAttributeType read new glAttributeType($8B54);
    public static property INT_VEC4:                                  glAttributeType read new glAttributeType($8B55);
    public static property BOOL:                                      glAttributeType read new glAttributeType($8B56);
    public static property BOOL_VEC2:                                 glAttributeType read new glAttributeType($8B57);
    public static property BOOL_VEC3:                                 glAttributeType read new glAttributeType($8B58);
    public static property BOOL_VEC4:                                 glAttributeType read new glAttributeType($8B59);
    public static property FLOAT_MAT2:                                glAttributeType read new glAttributeType($8B5A);
    public static property FLOAT_MAT3:                                glAttributeType read new glAttributeType($8B5B);
    public static property FLOAT_MAT4:                                glAttributeType read new glAttributeType($8B5C);
    public static property SAMPLER_1D:                                glAttributeType read new glAttributeType($8B5D);
    public static property SAMPLER_2D:                                glAttributeType read new glAttributeType($8B5E);
    public static property SAMPLER_3D:                                glAttributeType read new glAttributeType($8B5F);
    public static property SAMPLER_CUBE:                              glAttributeType read new glAttributeType($8B60);
    public static property SAMPLER_1D_SHADOW:                         glAttributeType read new glAttributeType($8B61);
    public static property SAMPLER_2D_SHADOW:                         glAttributeType read new glAttributeType($8B62);
    public static property SAMPLER_2D_RECT:                           glAttributeType read new glAttributeType($8B63);
    public static property SAMPLER_2D_RECT_SHADOW:                    glAttributeType read new glAttributeType($8B64);
    public static property FLOAT_MAT2x3:                              glAttributeType read new glAttributeType($8B65);
    public static property FLOAT_MAT2x4:                              glAttributeType read new glAttributeType($8B66);
    public static property FLOAT_MAT3x2:                              glAttributeType read new glAttributeType($8B67);
    public static property FLOAT_MAT3x4:                              glAttributeType read new glAttributeType($8B68);
    public static property FLOAT_MAT4x2:                              glAttributeType read new glAttributeType($8B69);
    public static property FLOAT_MAT4x3:                              glAttributeType read new glAttributeType($8B6A);
    public static property SAMPLER_BUFFER:                            glAttributeType read new glAttributeType($8DC2);
    public static property SAMPLER_1D_ARRAY_SHADOW:                   glAttributeType read new glAttributeType($8DC3);
    public static property SAMPLER_2D_ARRAY_SHADOW:                   glAttributeType read new glAttributeType($8DC4);
    public static property SAMPLER_CUBE_SHADOW:                       glAttributeType read new glAttributeType($8DC5);
    public static property UNSIGNED_INT_VEC2:                         glAttributeType read new glAttributeType($8DC6);
    public static property UNSIGNED_INT_VEC3:                         glAttributeType read new glAttributeType($8DC7);
    public static property UNSIGNED_INT_VEC4:                         glAttributeType read new glAttributeType($8DC8);
    public static property INT_SAMPLER_1D:                            glAttributeType read new glAttributeType($8DC9);
    public static property INT_SAMPLER_2D:                            glAttributeType read new glAttributeType($8DCA);
    public static property INT_SAMPLER_3D:                            glAttributeType read new glAttributeType($8DCB);
    public static property INT_SAMPLER_CUBE:                          glAttributeType read new glAttributeType($8DCC);
    public static property INT_SAMPLER_2D_RECT:                       glAttributeType read new glAttributeType($8DCD);
    public static property INT_SAMPLER_1D_ARRAY:                      glAttributeType read new glAttributeType($8DCE);
    public static property INT_SAMPLER_2D_ARRAY:                      glAttributeType read new glAttributeType($8DCF);
    public static property INT_SAMPLER_BUFFER:                        glAttributeType read new glAttributeType($8DD0);
    public static property UNSIGNED_INT_SAMPLER_1D:                   glAttributeType read new glAttributeType($8DD1);
    public static property UNSIGNED_INT_SAMPLER_2D:                   glAttributeType read new glAttributeType($8DD2);
    public static property UNSIGNED_INT_SAMPLER_3D:                   glAttributeType read new glAttributeType($8DD3);
    public static property UNSIGNED_INT_SAMPLER_CUBE:                 glAttributeType read new glAttributeType($8DD4);
    public static property UNSIGNED_INT_SAMPLER_2D_RECT:              glAttributeType read new glAttributeType($8DD5);
    public static property UNSIGNED_INT_SAMPLER_1D_ARRAY:             glAttributeType read new glAttributeType($8DD6);
    public static property UNSIGNED_INT_SAMPLER_2D_ARRAY:             glAttributeType read new glAttributeType($8DD7);
    public static property UNSIGNED_INT_SAMPLER_BUFFER:               glAttributeType read new glAttributeType($8DD8);
    public static property DOUBLE_MAT2:                               glAttributeType read new glAttributeType($8F46);
    public static property DOUBLE_MAT3:                               glAttributeType read new glAttributeType($8F47);
    public static property DOUBLE_MAT4:                               glAttributeType read new glAttributeType($8F48);
    public static property DOUBLE_MAT2x3:                             glAttributeType read new glAttributeType($8F49);
    public static property DOUBLE_MAT2x4:                             glAttributeType read new glAttributeType($8F4A);
    public static property DOUBLE_MAT3x2:                             glAttributeType read new glAttributeType($8F4B);
    public static property DOUBLE_MAT3x4:                             glAttributeType read new glAttributeType($8F4C);
    public static property DOUBLE_MAT4x2:                             glAttributeType read new glAttributeType($8F4D);
    public static property DOUBLE_MAT4x3:                             glAttributeType read new glAttributeType($8F4E);
    public static property INT64_VEC2:                                glAttributeType read new glAttributeType($8FE9);
    public static property INT64_VEC3:                                glAttributeType read new glAttributeType($8FEA);
    public static property INT64_VEC4:                                glAttributeType read new glAttributeType($8FEB);
    public static property UNSIGNED_INT64_VEC2:                       glAttributeType read new glAttributeType($8FF5);
    public static property UNSIGNED_INT64_VEC3:                       glAttributeType read new glAttributeType($8FF6);
    public static property UNSIGNED_INT64_VEC4:                       glAttributeType read new glAttributeType($8FF7);
    public static property DOUBLE_VEC2:                               glAttributeType read new glAttributeType($8FFC);
    public static property DOUBLE_VEC3:                               glAttributeType read new glAttributeType($8FFD);
    public static property DOUBLE_VEC4:                               glAttributeType read new glAttributeType($8FFE);
    public static property SAMPLER_CUBE_MAP_ARRAY:                    glAttributeType read new glAttributeType($900C);
    public static property SAMPLER_CUBE_MAP_ARRAY_SHADOW:             glAttributeType read new glAttributeType($900D);
    public static property INT_SAMPLER_CUBE_MAP_ARRAY:                glAttributeType read new glAttributeType($900E);
    public static property UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY:       glAttributeType read new glAttributeType($900F);
    public static property IMAGE_1D:                                  glAttributeType read new glAttributeType($904C);
    public static property IMAGE_2D:                                  glAttributeType read new glAttributeType($904D);
    public static property IMAGE_3D:                                  glAttributeType read new glAttributeType($904E);
    public static property IMAGE_2D_RECT:                             glAttributeType read new glAttributeType($904F);
    public static property IMAGE_CUBE:                                glAttributeType read new glAttributeType($9050);
    public static property IMAGE_BUFFER:                              glAttributeType read new glAttributeType($9051);
    public static property IMAGE_1D_ARRAY:                            glAttributeType read new glAttributeType($9052);
    public static property IMAGE_2D_ARRAY:                            glAttributeType read new glAttributeType($9053);
    public static property IMAGE_CUBE_MAP_ARRAY:                      glAttributeType read new glAttributeType($9054);
    public static property IMAGE_2D_MULTISAMPLE:                      glAttributeType read new glAttributeType($9055);
    public static property IMAGE_2D_MULTISAMPLE_ARRAY:                glAttributeType read new glAttributeType($9056);
    public static property INT_IMAGE_1D:                              glAttributeType read new glAttributeType($9057);
    public static property INT_IMAGE_2D:                              glAttributeType read new glAttributeType($9058);
    public static property INT_IMAGE_3D:                              glAttributeType read new glAttributeType($9059);
    public static property INT_IMAGE_2D_RECT:                         glAttributeType read new glAttributeType($905A);
    public static property INT_IMAGE_CUBE:                            glAttributeType read new glAttributeType($905B);
    public static property INT_IMAGE_BUFFER:                          glAttributeType read new glAttributeType($905C);
    public static property INT_IMAGE_1D_ARRAY:                        glAttributeType read new glAttributeType($905D);
    public static property INT_IMAGE_2D_ARRAY:                        glAttributeType read new glAttributeType($905E);
    public static property INT_IMAGE_CUBE_MAP_ARRAY:                  glAttributeType read new glAttributeType($905F);
    public static property INT_IMAGE_2D_MULTISAMPLE:                  glAttributeType read new glAttributeType($9060);
    public static property INT_IMAGE_2D_MULTISAMPLE_ARRAY:            glAttributeType read new glAttributeType($9061);
    public static property UNSIGNED_INT_IMAGE_1D:                     glAttributeType read new glAttributeType($9062);
    public static property UNSIGNED_INT_IMAGE_2D:                     glAttributeType read new glAttributeType($9063);
    public static property UNSIGNED_INT_IMAGE_3D:                     glAttributeType read new glAttributeType($9064);
    public static property UNSIGNED_INT_IMAGE_2D_RECT:                glAttributeType read new glAttributeType($9065);
    public static property UNSIGNED_INT_IMAGE_CUBE:                   glAttributeType read new glAttributeType($9066);
    public static property UNSIGNED_INT_IMAGE_BUFFER:                 glAttributeType read new glAttributeType($9067);
    public static property UNSIGNED_INT_IMAGE_1D_ARRAY:               glAttributeType read new glAttributeType($9068);
    public static property UNSIGNED_INT_IMAGE_2D_ARRAY:               glAttributeType read new glAttributeType($9069);
    public static property UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY:         glAttributeType read new glAttributeType($906A);
    public static property UNSIGNED_INT_IMAGE_2D_MULTISAMPLE:         glAttributeType read new glAttributeType($906B);
    public static property UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY:   glAttributeType read new glAttributeType($906C);
    public static property SAMPLER_2D_MULTISAMPLE:                    glAttributeType read new glAttributeType($9108);
    public static property INT_SAMPLER_2D_MULTISAMPLE:                glAttributeType read new glAttributeType($9109);
    public static property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE:       glAttributeType read new glAttributeType($910A);
    public static property SAMPLER_2D_MULTISAMPLE_ARRAY:              glAttributeType read new glAttributeType($910B);
    public static property INT_SAMPLER_2D_MULTISAMPLE_ARRAY:          glAttributeType read new glAttributeType($910C);
    public static property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: glAttributeType read new glAttributeType($910D);
    
    public function ToString: string; override;
    begin
      if INT = self then
        Result := 'INT' else
      if UNSIGNED_INT = self then
        Result := 'UNSIGNED_INT' else
      if FLOAT = self then
        Result := 'FLOAT' else
      if DOUBLE = self then
        Result := 'DOUBLE' else
      if INT64 = self then
        Result := 'INT64' else
      if UNSIGNED_INT64_ARB = self then
        Result := 'UNSIGNED_INT64_ARB' else
      if UNSIGNED_INT64_NV = self then
        Result := 'UNSIGNED_INT64_NV' else
      if FLOAT_VEC2 = self then
        Result := 'FLOAT_VEC2' else
      if FLOAT_VEC3 = self then
        Result := 'FLOAT_VEC3' else
      if FLOAT_VEC4 = self then
        Result := 'FLOAT_VEC4' else
      if INT_VEC2 = self then
        Result := 'INT_VEC2' else
      if INT_VEC3 = self then
        Result := 'INT_VEC3' else
      if INT_VEC4 = self then
        Result := 'INT_VEC4' else
      if BOOL = self then
        Result := 'BOOL' else
      if BOOL_VEC2 = self then
        Result := 'BOOL_VEC2' else
      if BOOL_VEC3 = self then
        Result := 'BOOL_VEC3' else
      if BOOL_VEC4 = self then
        Result := 'BOOL_VEC4' else
      if FLOAT_MAT2 = self then
        Result := 'FLOAT_MAT2' else
      if FLOAT_MAT3 = self then
        Result := 'FLOAT_MAT3' else
      if FLOAT_MAT4 = self then
        Result := 'FLOAT_MAT4' else
      if SAMPLER_1D = self then
        Result := 'SAMPLER_1D' else
      if SAMPLER_2D = self then
        Result := 'SAMPLER_2D' else
      if SAMPLER_3D = self then
        Result := 'SAMPLER_3D' else
      if SAMPLER_CUBE = self then
        Result := 'SAMPLER_CUBE' else
      if SAMPLER_1D_SHADOW = self then
        Result := 'SAMPLER_1D_SHADOW' else
      if SAMPLER_2D_SHADOW = self then
        Result := 'SAMPLER_2D_SHADOW' else
      if SAMPLER_2D_RECT = self then
        Result := 'SAMPLER_2D_RECT' else
      if SAMPLER_2D_RECT_SHADOW = self then
        Result := 'SAMPLER_2D_RECT_SHADOW' else
      if FLOAT_MAT2x3 = self then
        Result := 'FLOAT_MAT2x3' else
      if FLOAT_MAT2x4 = self then
        Result := 'FLOAT_MAT2x4' else
      if FLOAT_MAT3x2 = self then
        Result := 'FLOAT_MAT3x2' else
      if FLOAT_MAT3x4 = self then
        Result := 'FLOAT_MAT3x4' else
      if FLOAT_MAT4x2 = self then
        Result := 'FLOAT_MAT4x2' else
      if FLOAT_MAT4x3 = self then
        Result := 'FLOAT_MAT4x3' else
      if SAMPLER_BUFFER = self then
        Result := 'SAMPLER_BUFFER' else
      if SAMPLER_1D_ARRAY_SHADOW = self then
        Result := 'SAMPLER_1D_ARRAY_SHADOW' else
      if SAMPLER_2D_ARRAY_SHADOW = self then
        Result := 'SAMPLER_2D_ARRAY_SHADOW' else
      if SAMPLER_CUBE_SHADOW = self then
        Result := 'SAMPLER_CUBE_SHADOW' else
      if UNSIGNED_INT_VEC2 = self then
        Result := 'UNSIGNED_INT_VEC2' else
      if UNSIGNED_INT_VEC3 = self then
        Result := 'UNSIGNED_INT_VEC3' else
      if UNSIGNED_INT_VEC4 = self then
        Result := 'UNSIGNED_INT_VEC4' else
      if INT_SAMPLER_1D = self then
        Result := 'INT_SAMPLER_1D' else
      if INT_SAMPLER_2D = self then
        Result := 'INT_SAMPLER_2D' else
      if INT_SAMPLER_3D = self then
        Result := 'INT_SAMPLER_3D' else
      if INT_SAMPLER_CUBE = self then
        Result := 'INT_SAMPLER_CUBE' else
      if INT_SAMPLER_2D_RECT = self then
        Result := 'INT_SAMPLER_2D_RECT' else
      if INT_SAMPLER_1D_ARRAY = self then
        Result := 'INT_SAMPLER_1D_ARRAY' else
      if INT_SAMPLER_2D_ARRAY = self then
        Result := 'INT_SAMPLER_2D_ARRAY' else
      if INT_SAMPLER_BUFFER = self then
        Result := 'INT_SAMPLER_BUFFER' else
      if UNSIGNED_INT_SAMPLER_1D = self then
        Result := 'UNSIGNED_INT_SAMPLER_1D' else
      if UNSIGNED_INT_SAMPLER_2D = self then
        Result := 'UNSIGNED_INT_SAMPLER_2D' else
      if UNSIGNED_INT_SAMPLER_3D = self then
        Result := 'UNSIGNED_INT_SAMPLER_3D' else
      if UNSIGNED_INT_SAMPLER_CUBE = self then
        Result := 'UNSIGNED_INT_SAMPLER_CUBE' else
      if UNSIGNED_INT_SAMPLER_2D_RECT = self then
        Result := 'UNSIGNED_INT_SAMPLER_2D_RECT' else
      if UNSIGNED_INT_SAMPLER_1D_ARRAY = self then
        Result := 'UNSIGNED_INT_SAMPLER_1D_ARRAY' else
      if UNSIGNED_INT_SAMPLER_2D_ARRAY = self then
        Result := 'UNSIGNED_INT_SAMPLER_2D_ARRAY' else
      if UNSIGNED_INT_SAMPLER_BUFFER = self then
        Result := 'UNSIGNED_INT_SAMPLER_BUFFER' else
      if DOUBLE_MAT2 = self then
        Result := 'DOUBLE_MAT2' else
      if DOUBLE_MAT3 = self then
        Result := 'DOUBLE_MAT3' else
      if DOUBLE_MAT4 = self then
        Result := 'DOUBLE_MAT4' else
      if DOUBLE_MAT2x3 = self then
        Result := 'DOUBLE_MAT2x3' else
      if DOUBLE_MAT2x4 = self then
        Result := 'DOUBLE_MAT2x4' else
      if DOUBLE_MAT3x2 = self then
        Result := 'DOUBLE_MAT3x2' else
      if DOUBLE_MAT3x4 = self then
        Result := 'DOUBLE_MAT3x4' else
      if DOUBLE_MAT4x2 = self then
        Result := 'DOUBLE_MAT4x2' else
      if DOUBLE_MAT4x3 = self then
        Result := 'DOUBLE_MAT4x3' else
      if INT64_VEC2 = self then
        Result := 'INT64_VEC2' else
      if INT64_VEC3 = self then
        Result := 'INT64_VEC3' else
      if INT64_VEC4 = self then
        Result := 'INT64_VEC4' else
      if UNSIGNED_INT64_VEC2 = self then
        Result := 'UNSIGNED_INT64_VEC2' else
      if UNSIGNED_INT64_VEC3 = self then
        Result := 'UNSIGNED_INT64_VEC3' else
      if UNSIGNED_INT64_VEC4 = self then
        Result := 'UNSIGNED_INT64_VEC4' else
      if DOUBLE_VEC2 = self then
        Result := 'DOUBLE_VEC2' else
      if DOUBLE_VEC3 = self then
        Result := 'DOUBLE_VEC3' else
      if DOUBLE_VEC4 = self then
        Result := 'DOUBLE_VEC4' else
      if SAMPLER_CUBE_MAP_ARRAY = self then
        Result := 'SAMPLER_CUBE_MAP_ARRAY' else
      if SAMPLER_CUBE_MAP_ARRAY_SHADOW = self then
        Result := 'SAMPLER_CUBE_MAP_ARRAY_SHADOW' else
      if INT_SAMPLER_CUBE_MAP_ARRAY = self then
        Result := 'INT_SAMPLER_CUBE_MAP_ARRAY' else
      if UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY = self then
        Result := 'UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY' else
      if IMAGE_1D = self then
        Result := 'IMAGE_1D' else
      if IMAGE_2D = self then
        Result := 'IMAGE_2D' else
      if IMAGE_3D = self then
        Result := 'IMAGE_3D' else
      if IMAGE_2D_RECT = self then
        Result := 'IMAGE_2D_RECT' else
      if IMAGE_CUBE = self then
        Result := 'IMAGE_CUBE' else
      if IMAGE_BUFFER = self then
        Result := 'IMAGE_BUFFER' else
      if IMAGE_1D_ARRAY = self then
        Result := 'IMAGE_1D_ARRAY' else
      if IMAGE_2D_ARRAY = self then
        Result := 'IMAGE_2D_ARRAY' else
      if IMAGE_CUBE_MAP_ARRAY = self then
        Result := 'IMAGE_CUBE_MAP_ARRAY' else
      if IMAGE_2D_MULTISAMPLE = self then
        Result := 'IMAGE_2D_MULTISAMPLE' else
      if IMAGE_2D_MULTISAMPLE_ARRAY = self then
        Result := 'IMAGE_2D_MULTISAMPLE_ARRAY' else
      if INT_IMAGE_1D = self then
        Result := 'INT_IMAGE_1D' else
      if INT_IMAGE_2D = self then
        Result := 'INT_IMAGE_2D' else
      if INT_IMAGE_3D = self then
        Result := 'INT_IMAGE_3D' else
      if INT_IMAGE_2D_RECT = self then
        Result := 'INT_IMAGE_2D_RECT' else
      if INT_IMAGE_CUBE = self then
        Result := 'INT_IMAGE_CUBE' else
      if INT_IMAGE_BUFFER = self then
        Result := 'INT_IMAGE_BUFFER' else
      if INT_IMAGE_1D_ARRAY = self then
        Result := 'INT_IMAGE_1D_ARRAY' else
      if INT_IMAGE_2D_ARRAY = self then
        Result := 'INT_IMAGE_2D_ARRAY' else
      if INT_IMAGE_CUBE_MAP_ARRAY = self then
        Result := 'INT_IMAGE_CUBE_MAP_ARRAY' else
      if INT_IMAGE_2D_MULTISAMPLE = self then
        Result := 'INT_IMAGE_2D_MULTISAMPLE' else
      if INT_IMAGE_2D_MULTISAMPLE_ARRAY = self then
        Result := 'INT_IMAGE_2D_MULTISAMPLE_ARRAY' else
      if UNSIGNED_INT_IMAGE_1D = self then
        Result := 'UNSIGNED_INT_IMAGE_1D' else
      if UNSIGNED_INT_IMAGE_2D = self then
        Result := 'UNSIGNED_INT_IMAGE_2D' else
      if UNSIGNED_INT_IMAGE_3D = self then
        Result := 'UNSIGNED_INT_IMAGE_3D' else
      if UNSIGNED_INT_IMAGE_2D_RECT = self then
        Result := 'UNSIGNED_INT_IMAGE_2D_RECT' else
      if UNSIGNED_INT_IMAGE_CUBE = self then
        Result := 'UNSIGNED_INT_IMAGE_CUBE' else
      if UNSIGNED_INT_IMAGE_BUFFER = self then
        Result := 'UNSIGNED_INT_IMAGE_BUFFER' else
      if UNSIGNED_INT_IMAGE_1D_ARRAY = self then
        Result := 'UNSIGNED_INT_IMAGE_1D_ARRAY' else
      if UNSIGNED_INT_IMAGE_2D_ARRAY = self then
        Result := 'UNSIGNED_INT_IMAGE_2D_ARRAY' else
      if UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY = self then
        Result := 'UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY' else
      if UNSIGNED_INT_IMAGE_2D_MULTISAMPLE = self then
        Result := 'UNSIGNED_INT_IMAGE_2D_MULTISAMPLE' else
      if UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY = self then
        Result := 'UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY' else
      if SAMPLER_2D_MULTISAMPLE = self then
        Result := 'SAMPLER_2D_MULTISAMPLE' else
      if INT_SAMPLER_2D_MULTISAMPLE = self then
        Result := 'INT_SAMPLER_2D_MULTISAMPLE' else
      if UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = self then
        Result := 'UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE' else
      if SAMPLER_2D_MULTISAMPLE_ARRAY = self then
        Result := 'SAMPLER_2D_MULTISAMPLE_ARRAY' else
      if INT_SAMPLER_2D_MULTISAMPLE_ARRAY = self then
        Result := 'INT_SAMPLER_2D_MULTISAMPLE_ARRAY' else
      if UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = self then
        Result := 'UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY' else
        Result := $'glAttributeType[{self.val}]';
    end;
    
  end;
  
  glBindTransformFeedbackTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TRANSFORM_FEEDBACK: glBindTransformFeedbackTarget read new glBindTransformFeedbackTarget($8E22);
    
    public function ToString: string; override;
    begin
      if TRANSFORM_FEEDBACK = self then
        Result := 'TRANSFORM_FEEDBACK' else
        Result := $'glBindTransformFeedbackTarget[{self.val}]';
    end;
    
  end;
  
  glBinormalPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:   glBinormalPointerType read new glBinormalPointerType($1400);
    public static property SHORT:  glBinormalPointerType read new glBinormalPointerType($1402);
    public static property INT:    glBinormalPointerType read new glBinormalPointerType($1404);
    public static property FLOAT:  glBinormalPointerType read new glBinormalPointerType($1406);
    public static property DOUBLE: glBinormalPointerType read new glBinormalPointerType($140A);
    
    public function ToString: string; override;
    begin
      if BYTE = self then
        Result := 'BYTE' else
      if SHORT = self then
        Result := 'SHORT' else
      if INT = self then
        Result := 'INT' else
      if FLOAT = self then
        Result := 'FLOAT' else
      if DOUBLE = self then
        Result := 'DOUBLE' else
        Result := $'glBinormalPointerType[{self.val}]';
    end;
    
  end;
  
  glBlendEquationMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FUNC_ADD:              glBlendEquationMode read new glBlendEquationMode($8006);
    public static property MIN:                   glBlendEquationMode read new glBlendEquationMode($8007);
    public static property MAX:                   glBlendEquationMode read new glBlendEquationMode($8008);
    public static property FUNC_SUBTRACT:         glBlendEquationMode read new glBlendEquationMode($800A);
    public static property FUNC_REVERSE_SUBTRACT: glBlendEquationMode read new glBlendEquationMode($800B);
    public static property ALPHA_MIN:             glBlendEquationMode read new glBlendEquationMode($8320);
    public static property ALPHA_MAX:             glBlendEquationMode read new glBlendEquationMode($8321);
    
    public function ToString: string; override;
    begin
      if FUNC_ADD = self then
        Result := 'FUNC_ADD' else
      if MIN = self then
        Result := 'MIN' else
      if MAX = self then
        Result := 'MAX' else
      if FUNC_SUBTRACT = self then
        Result := 'FUNC_SUBTRACT' else
      if FUNC_REVERSE_SUBTRACT = self then
        Result := 'FUNC_REVERSE_SUBTRACT' else
      if ALPHA_MIN = self then
        Result := 'ALPHA_MIN' else
      if ALPHA_MAX = self then
        Result := 'ALPHA_MAX' else
        Result := $'glBlendEquationMode[{self.val}]';
    end;
    
  end;
  
  glBlendingFactor = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ZERO:                     glBlendingFactor read new glBlendingFactor(0);
    public static property ONE:                      glBlendingFactor read new glBlendingFactor($0001);
    public static property SRC_COLOR:                glBlendingFactor read new glBlendingFactor($0300);
    public static property ONE_MINUS_SRC_COLOR:      glBlendingFactor read new glBlendingFactor($0301);
    public static property SRC_ALPHA:                glBlendingFactor read new glBlendingFactor($0302);
    public static property ONE_MINUS_SRC_ALPHA:      glBlendingFactor read new glBlendingFactor($0303);
    public static property DST_ALPHA:                glBlendingFactor read new glBlendingFactor($0304);
    public static property ONE_MINUS_DST_ALPHA:      glBlendingFactor read new glBlendingFactor($0305);
    public static property DST_COLOR:                glBlendingFactor read new glBlendingFactor($0306);
    public static property ONE_MINUS_DST_COLOR:      glBlendingFactor read new glBlendingFactor($0307);
    public static property SRC_ALPHA_SATURATE:       glBlendingFactor read new glBlendingFactor($0308);
    public static property CONSTANT_COLOR:           glBlendingFactor read new glBlendingFactor($8001);
    public static property ONE_MINUS_CONSTANT_COLOR: glBlendingFactor read new glBlendingFactor($8002);
    public static property CONSTANT_ALPHA:           glBlendingFactor read new glBlendingFactor($8003);
    public static property ONE_MINUS_CONSTANT_ALPHA: glBlendingFactor read new glBlendingFactor($8004);
    public static property SRC1_ALPHA:               glBlendingFactor read new glBlendingFactor($8589);
    public static property SRC1_COLOR:               glBlendingFactor read new glBlendingFactor($88F9);
    public static property ONE_MINUS_SRC1_COLOR:     glBlendingFactor read new glBlendingFactor($88FA);
    public static property ONE_MINUS_SRC1_ALPHA:     glBlendingFactor read new glBlendingFactor($88FB);
    
    public function ToString: string; override;
    begin
      if ZERO = self then
        Result := 'ZERO' else
      if ONE = self then
        Result := 'ONE' else
      if SRC_COLOR = self then
        Result := 'SRC_COLOR' else
      if ONE_MINUS_SRC_COLOR = self then
        Result := 'ONE_MINUS_SRC_COLOR' else
      if SRC_ALPHA = self then
        Result := 'SRC_ALPHA' else
      if ONE_MINUS_SRC_ALPHA = self then
        Result := 'ONE_MINUS_SRC_ALPHA' else
      if DST_ALPHA = self then
        Result := 'DST_ALPHA' else
      if ONE_MINUS_DST_ALPHA = self then
        Result := 'ONE_MINUS_DST_ALPHA' else
      if DST_COLOR = self then
        Result := 'DST_COLOR' else
      if ONE_MINUS_DST_COLOR = self then
        Result := 'ONE_MINUS_DST_COLOR' else
      if SRC_ALPHA_SATURATE = self then
        Result := 'SRC_ALPHA_SATURATE' else
      if CONSTANT_COLOR = self then
        Result := 'CONSTANT_COLOR' else
      if ONE_MINUS_CONSTANT_COLOR = self then
        Result := 'ONE_MINUS_CONSTANT_COLOR' else
      if CONSTANT_ALPHA = self then
        Result := 'CONSTANT_ALPHA' else
      if ONE_MINUS_CONSTANT_ALPHA = self then
        Result := 'ONE_MINUS_CONSTANT_ALPHA' else
      if SRC1_ALPHA = self then
        Result := 'SRC1_ALPHA' else
      if SRC1_COLOR = self then
        Result := 'SRC1_COLOR' else
      if ONE_MINUS_SRC1_COLOR = self then
        Result := 'ONE_MINUS_SRC1_COLOR' else
      if ONE_MINUS_SRC1_ALPHA = self then
        Result := 'ONE_MINUS_SRC1_ALPHA' else
        Result := $'glBlendingFactor[{self.val}]';
    end;
    
  end;
  
  glBlitFramebufferFilter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEAREST: glBlitFramebufferFilter read new glBlitFramebufferFilter($2600);
    public static property LINEAR:  glBlitFramebufferFilter read new glBlitFramebufferFilter($2601);
    
    public function ToString: string; override;
    begin
      if NEAREST = self then
        Result := 'NEAREST' else
      if LINEAR = self then
        Result := 'LINEAR' else
        Result := $'glBlitFramebufferFilter[{self.val}]';
    end;
    
  end;
  
  glBool32 = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FALSE: glBool32 read new glBool32(0);
    public static property TRUE:  glBool32 read new glBool32($0001);
    
    public function ToString: string; override;
    begin
      if FALSE = self then
        Result := 'FALSE' else
      if TRUE = self then
        Result := 'TRUE' else
        Result := $'glBool32[{self.val}]';
    end;
    
    public static function operator implicit(b: glBool32): boolean := b<>FALSE;
    public static function operator implicit(b: boolean): glBool32 := new glBool32(UInt32(b));
    
    public static function operator not(b: glBool32): glBool32 := if b then FALSE else TRUE;
    
  end;
  
  glBool8 = record
    public val: Byte;
    public constructor(val: Byte) := self.val := val;
    
    public static property FALSE: glBool8 read new glBool8(0);
    public static property TRUE:  glBool8 read new glBool8($0001);
    
    public function ToString: string; override;
    begin
      if FALSE = self then
        Result := 'FALSE' else
      if TRUE = self then
        Result := 'TRUE' else
        Result := $'glBool8[{self.val}]';
    end;
    
    public static function operator implicit(b: glBool8): boolean := b<>FALSE;
    public static function operator implicit(b: boolean): glBool8 := new glBool8(Byte(b));
    
    public static function operator not(b: glBool8): glBool8 := if b then FALSE else TRUE;
    
  end;
  
  glBuffer = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COLOR:   glBuffer read new glBuffer($1800);
    public static property DEPTH:   glBuffer read new glBuffer($1801);
    public static property STENCIL: glBuffer read new glBuffer($1802);
    
    public function ToString: string; override;
    begin
      if COLOR = self then
        Result := 'COLOR' else
      if DEPTH = self then
        Result := 'DEPTH' else
      if STENCIL = self then
        Result := 'STENCIL' else
        Result := $'glBuffer[{self.val}]';
    end;
    
  end;
  
  glBufferAccess = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property READ_ONLY:  glBufferAccess read new glBufferAccess($88B8);
    public static property WRITE_ONLY: glBufferAccess read new glBufferAccess($88B9);
    public static property READ_WRITE: glBufferAccess read new glBufferAccess($88BA);
    
    public function ToString: string; override;
    begin
      if READ_ONLY = self then
        Result := 'READ_ONLY' else
      if WRITE_ONLY = self then
        Result := 'WRITE_ONLY' else
      if READ_WRITE = self then
        Result := 'READ_WRITE' else
        Result := $'glBufferAccess[{self.val}]';
    end;
    
  end;
  
  glBufferPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BUFFER_IMMUTABLE_STORAGE: glBufferPName read new glBufferPName($821F);
    public static property BUFFER_STORAGE_FLAGS:     glBufferPName read new glBufferPName($8220);
    public static property BUFFER_SIZE:              glBufferPName read new glBufferPName($8764);
    public static property BUFFER_USAGE:             glBufferPName read new glBufferPName($8765);
    public static property BUFFER_ACCESS:            glBufferPName read new glBufferPName($88BB);
    public static property BUFFER_MAPPED:            glBufferPName read new glBufferPName($88BC);
    public static property BUFFER_ACCESS_FLAGS:      glBufferPName read new glBufferPName($911F);
    public static property BUFFER_MAP_LENGTH:        glBufferPName read new glBufferPName($9120);
    public static property BUFFER_MAP_OFFSET:        glBufferPName read new glBufferPName($9121);
    
    public function ToString: string; override;
    begin
      if BUFFER_IMMUTABLE_STORAGE = self then
        Result := 'BUFFER_IMMUTABLE_STORAGE' else
      if BUFFER_STORAGE_FLAGS = self then
        Result := 'BUFFER_STORAGE_FLAGS' else
      if BUFFER_SIZE = self then
        Result := 'BUFFER_SIZE' else
      if BUFFER_USAGE = self then
        Result := 'BUFFER_USAGE' else
      if BUFFER_ACCESS = self then
        Result := 'BUFFER_ACCESS' else
      if BUFFER_MAPPED = self then
        Result := 'BUFFER_MAPPED' else
      if BUFFER_ACCESS_FLAGS = self then
        Result := 'BUFFER_ACCESS_FLAGS' else
      if BUFFER_MAP_LENGTH = self then
        Result := 'BUFFER_MAP_LENGTH' else
      if BUFFER_MAP_OFFSET = self then
        Result := 'BUFFER_MAP_OFFSET' else
        Result := $'glBufferPName[{self.val}]';
    end;
    
  end;
  
  glBufferPointerName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BUFFER_MAP_POINTER: glBufferPointerName read new glBufferPointerName($88BD);
    
    public function ToString: string; override;
    begin
      if BUFFER_MAP_POINTER = self then
        Result := 'BUFFER_MAP_POINTER' else
        Result := $'glBufferPointerName[{self.val}]';
    end;
    
  end;
  
  glBufferStorageMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MAP_READ_BIT:              glBufferStorageMask read new glBufferStorageMask(1 shl 0);
    public static property MAP_WRITE_BIT:             glBufferStorageMask read new glBufferStorageMask(1 shl 1);
    public static property MAP_PERSISTENT_BIT:        glBufferStorageMask read new glBufferStorageMask(1 shl 6);
    public static property MAP_COHERENT_BIT:          glBufferStorageMask read new glBufferStorageMask(1 shl 7);
    public static property DYNAMIC_STORAGE_BIT:       glBufferStorageMask read new glBufferStorageMask(1 shl 8);
    public static property CLIENT_STORAGE_BIT:        glBufferStorageMask read new glBufferStorageMask(1 shl 9);
    public static property SPARSE_STORAGE_BIT:        glBufferStorageMask read new glBufferStorageMask(1 shl 10);
    public static property LGPU_SEPARATE_STORAGE_BIT: glBufferStorageMask read new glBufferStorageMask(1 shl 11);
    public static property PER_GPU_STORAGE_BIT:       glBufferStorageMask read new glBufferStorageMask(1 shl 11);
    public static property EXTERNAL_STORAGE_BIT:      glBufferStorageMask read new glBufferStorageMask(1 shl 13);
    
    public static function operator+(v1, v2: glBufferStorageMask) := new glBufferStorageMask(v1.val or v2.val);
    public static function operator or(v1, v2: glBufferStorageMask) := new glBufferStorageMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glBufferStorageMask; v2: glBufferStorageMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glBufferStorageMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glBufferStorageMask[0]';
        exit;
      end;
      if MAP_READ_BIT in self then
      begin
        res += 'MAP_READ_BIT+';
        left_val := left_val and not MAP_READ_BIT.val;
      end;
      if MAP_WRITE_BIT in self then
      begin
        res += 'MAP_WRITE_BIT+';
        left_val := left_val and not MAP_WRITE_BIT.val;
      end;
      if MAP_PERSISTENT_BIT in self then
      begin
        res += 'MAP_PERSISTENT_BIT+';
        left_val := left_val and not MAP_PERSISTENT_BIT.val;
      end;
      if MAP_COHERENT_BIT in self then
      begin
        res += 'MAP_COHERENT_BIT+';
        left_val := left_val and not MAP_COHERENT_BIT.val;
      end;
      if DYNAMIC_STORAGE_BIT in self then
      begin
        res += 'DYNAMIC_STORAGE_BIT+';
        left_val := left_val and not DYNAMIC_STORAGE_BIT.val;
      end;
      if CLIENT_STORAGE_BIT in self then
      begin
        res += 'CLIENT_STORAGE_BIT+';
        left_val := left_val and not CLIENT_STORAGE_BIT.val;
      end;
      if SPARSE_STORAGE_BIT in self then
      begin
        res += 'SPARSE_STORAGE_BIT+';
        left_val := left_val and not SPARSE_STORAGE_BIT.val;
      end;
      if LGPU_SEPARATE_STORAGE_BIT in self then
      begin
        res += 'LGPU_SEPARATE_STORAGE_BIT+';
        left_val := left_val and not LGPU_SEPARATE_STORAGE_BIT.val;
      end;
      if PER_GPU_STORAGE_BIT in self then
      begin
        res += 'PER_GPU_STORAGE_BIT+';
        left_val := left_val and not PER_GPU_STORAGE_BIT.val;
      end;
      if EXTERNAL_STORAGE_BIT in self then
      begin
        res += 'EXTERNAL_STORAGE_BIT+';
        left_val := left_val and not EXTERNAL_STORAGE_BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'glBufferStorageMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glBufferStorageTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ARRAY_BUFFER:              glBufferStorageTarget read new glBufferStorageTarget($8892);
    public static property ELEMENT_ARRAY_BUFFER:      glBufferStorageTarget read new glBufferStorageTarget($8893);
    public static property PIXEL_PACK_BUFFER:         glBufferStorageTarget read new glBufferStorageTarget($88EB);
    public static property PIXEL_UNPACK_BUFFER:       glBufferStorageTarget read new glBufferStorageTarget($88EC);
    public static property UNIFORM_BUFFER:            glBufferStorageTarget read new glBufferStorageTarget($8A11);
    public static property TEXTURE_BUFFER:            glBufferStorageTarget read new glBufferStorageTarget($8C2A);
    public static property TRANSFORM_FEEDBACK_BUFFER: glBufferStorageTarget read new glBufferStorageTarget($8C8E);
    public static property COPY_READ_BUFFER:          glBufferStorageTarget read new glBufferStorageTarget($8F36);
    public static property COPY_WRITE_BUFFER:         glBufferStorageTarget read new glBufferStorageTarget($8F37);
    public static property DRAW_INDIRECT_BUFFER:      glBufferStorageTarget read new glBufferStorageTarget($8F3F);
    public static property SHADER_STORAGE_BUFFER:     glBufferStorageTarget read new glBufferStorageTarget($90D2);
    public static property DISPATCH_INDIRECT_BUFFER:  glBufferStorageTarget read new glBufferStorageTarget($90EE);
    public static property QUERY_BUFFER:              glBufferStorageTarget read new glBufferStorageTarget($9192);
    public static property ATOMIC_COUNTER_BUFFER:     glBufferStorageTarget read new glBufferStorageTarget($92C0);
    
    public function ToString: string; override;
    begin
      if ARRAY_BUFFER = self then
        Result := 'ARRAY_BUFFER' else
      if ELEMENT_ARRAY_BUFFER = self then
        Result := 'ELEMENT_ARRAY_BUFFER' else
      if PIXEL_PACK_BUFFER = self then
        Result := 'PIXEL_PACK_BUFFER' else
      if PIXEL_UNPACK_BUFFER = self then
        Result := 'PIXEL_UNPACK_BUFFER' else
      if UNIFORM_BUFFER = self then
        Result := 'UNIFORM_BUFFER' else
      if TEXTURE_BUFFER = self then
        Result := 'TEXTURE_BUFFER' else
      if TRANSFORM_FEEDBACK_BUFFER = self then
        Result := 'TRANSFORM_FEEDBACK_BUFFER' else
      if COPY_READ_BUFFER = self then
        Result := 'COPY_READ_BUFFER' else
      if COPY_WRITE_BUFFER = self then
        Result := 'COPY_WRITE_BUFFER' else
      if DRAW_INDIRECT_BUFFER = self then
        Result := 'DRAW_INDIRECT_BUFFER' else
      if SHADER_STORAGE_BUFFER = self then
        Result := 'SHADER_STORAGE_BUFFER' else
      if DISPATCH_INDIRECT_BUFFER = self then
        Result := 'DISPATCH_INDIRECT_BUFFER' else
      if QUERY_BUFFER = self then
        Result := 'QUERY_BUFFER' else
      if ATOMIC_COUNTER_BUFFER = self then
        Result := 'ATOMIC_COUNTER_BUFFER' else
        Result := $'glBufferStorageTarget[{self.val}]';
    end;
    
  end;
  
  glBufferTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PARAMETER_BUFFER:          glBufferTarget read new glBufferTarget($80EE);
    public static property ARRAY_BUFFER:              glBufferTarget read new glBufferTarget($8892);
    public static property ELEMENT_ARRAY_BUFFER:      glBufferTarget read new glBufferTarget($8893);
    public static property PIXEL_PACK_BUFFER:         glBufferTarget read new glBufferTarget($88EB);
    public static property PIXEL_UNPACK_BUFFER:       glBufferTarget read new glBufferTarget($88EC);
    public static property UNIFORM_BUFFER:            glBufferTarget read new glBufferTarget($8A11);
    public static property TEXTURE_BUFFER:            glBufferTarget read new glBufferTarget($8C2A);
    public static property TRANSFORM_FEEDBACK_BUFFER: glBufferTarget read new glBufferTarget($8C8E);
    public static property COPY_READ_BUFFER:          glBufferTarget read new glBufferTarget($8F36);
    public static property COPY_WRITE_BUFFER:         glBufferTarget read new glBufferTarget($8F37);
    public static property DRAW_INDIRECT_BUFFER:      glBufferTarget read new glBufferTarget($8F3F);
    public static property SHADER_STORAGE_BUFFER:     glBufferTarget read new glBufferTarget($90D2);
    public static property DISPATCH_INDIRECT_BUFFER:  glBufferTarget read new glBufferTarget($90EE);
    public static property QUERY_BUFFER:              glBufferTarget read new glBufferTarget($9192);
    public static property ATOMIC_COUNTER_BUFFER:     glBufferTarget read new glBufferTarget($92C0);
    
    public function ToString: string; override;
    begin
      if PARAMETER_BUFFER = self then
        Result := 'PARAMETER_BUFFER' else
      if ARRAY_BUFFER = self then
        Result := 'ARRAY_BUFFER' else
      if ELEMENT_ARRAY_BUFFER = self then
        Result := 'ELEMENT_ARRAY_BUFFER' else
      if PIXEL_PACK_BUFFER = self then
        Result := 'PIXEL_PACK_BUFFER' else
      if PIXEL_UNPACK_BUFFER = self then
        Result := 'PIXEL_UNPACK_BUFFER' else
      if UNIFORM_BUFFER = self then
        Result := 'UNIFORM_BUFFER' else
      if TEXTURE_BUFFER = self then
        Result := 'TEXTURE_BUFFER' else
      if TRANSFORM_FEEDBACK_BUFFER = self then
        Result := 'TRANSFORM_FEEDBACK_BUFFER' else
      if COPY_READ_BUFFER = self then
        Result := 'COPY_READ_BUFFER' else
      if COPY_WRITE_BUFFER = self then
        Result := 'COPY_WRITE_BUFFER' else
      if DRAW_INDIRECT_BUFFER = self then
        Result := 'DRAW_INDIRECT_BUFFER' else
      if SHADER_STORAGE_BUFFER = self then
        Result := 'SHADER_STORAGE_BUFFER' else
      if DISPATCH_INDIRECT_BUFFER = self then
        Result := 'DISPATCH_INDIRECT_BUFFER' else
      if QUERY_BUFFER = self then
        Result := 'QUERY_BUFFER' else
      if ATOMIC_COUNTER_BUFFER = self then
        Result := 'ATOMIC_COUNTER_BUFFER' else
        Result := $'glBufferTarget[{self.val}]';
    end;
    
  end;
  
  glBufferUsage = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property STREAM_DRAW:  glBufferUsage read new glBufferUsage($88E0);
    public static property STREAM_READ:  glBufferUsage read new glBufferUsage($88E1);
    public static property STREAM_COPY:  glBufferUsage read new glBufferUsage($88E2);
    public static property STATIC_DRAW:  glBufferUsage read new glBufferUsage($88E4);
    public static property STATIC_READ:  glBufferUsage read new glBufferUsage($88E5);
    public static property STATIC_COPY:  glBufferUsage read new glBufferUsage($88E6);
    public static property DYNAMIC_DRAW: glBufferUsage read new glBufferUsage($88E8);
    public static property DYNAMIC_READ: glBufferUsage read new glBufferUsage($88E9);
    public static property DYNAMIC_COPY: glBufferUsage read new glBufferUsage($88EA);
    
    public function ToString: string; override;
    begin
      if STREAM_DRAW = self then
        Result := 'STREAM_DRAW' else
      if STREAM_READ = self then
        Result := 'STREAM_READ' else
      if STREAM_COPY = self then
        Result := 'STREAM_COPY' else
      if STATIC_DRAW = self then
        Result := 'STATIC_DRAW' else
      if STATIC_READ = self then
        Result := 'STATIC_READ' else
      if STATIC_COPY = self then
        Result := 'STATIC_COPY' else
      if DYNAMIC_DRAW = self then
        Result := 'DYNAMIC_DRAW' else
      if DYNAMIC_READ = self then
        Result := 'DYNAMIC_READ' else
      if DYNAMIC_COPY = self then
        Result := 'DYNAMIC_COPY' else
        Result := $'glBufferUsage[{self.val}]';
    end;
    
  end;
  
  glClampColorMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FALSE:      glClampColorMode read new glClampColorMode(0);
    public static property TRUE:       glClampColorMode read new glClampColorMode($0001);
    public static property FIXED_ONLY: glClampColorMode read new glClampColorMode($891D);
    
    public function ToString: string; override;
    begin
      if FALSE = self then
        Result := 'FALSE' else
      if TRUE = self then
        Result := 'TRUE' else
      if FIXED_ONLY = self then
        Result := 'FIXED_ONLY' else
        Result := $'glClampColorMode[{self.val}]';
    end;
    
  end;
  
  glClampColorTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CLAMP_VERTEX_COLOR:   glClampColorTarget read new glClampColorTarget($891A);
    public static property CLAMP_FRAGMENT_COLOR: glClampColorTarget read new glClampColorTarget($891B);
    public static property CLAMP_READ_COLOR:     glClampColorTarget read new glClampColorTarget($891C);
    
    public function ToString: string; override;
    begin
      if CLAMP_VERTEX_COLOR = self then
        Result := 'CLAMP_VERTEX_COLOR' else
      if CLAMP_FRAGMENT_COLOR = self then
        Result := 'CLAMP_FRAGMENT_COLOR' else
      if CLAMP_READ_COLOR = self then
        Result := 'CLAMP_READ_COLOR' else
        Result := $'glClampColorTarget[{self.val}]';
    end;
    
  end;
  
  glClearBufferMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DEPTH_BUFFER_BIT:    glClearBufferMask read new glClearBufferMask(1 shl 8);
    public static property ACCUM_BUFFER_BIT:    glClearBufferMask read new glClearBufferMask(1 shl 9);
    public static property STENCIL_BUFFER_BIT:  glClearBufferMask read new glClearBufferMask(1 shl 10);
    public static property COLOR_BUFFER_BIT:    glClearBufferMask read new glClearBufferMask(1 shl 14);
    public static property COVERAGE_BUFFER_BIT: glClearBufferMask read new glClearBufferMask(1 shl 15);
    
    public static function operator+(v1, v2: glClearBufferMask) := new glClearBufferMask(v1.val or v2.val);
    public static function operator or(v1, v2: glClearBufferMask) := new glClearBufferMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glClearBufferMask; v2: glClearBufferMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glClearBufferMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glClearBufferMask[0]';
        exit;
      end;
      if DEPTH_BUFFER_BIT in self then
      begin
        res += 'DEPTH_BUFFER_BIT+';
        left_val := left_val and not DEPTH_BUFFER_BIT.val;
      end;
      if ACCUM_BUFFER_BIT in self then
      begin
        res += 'ACCUM_BUFFER_BIT+';
        left_val := left_val and not ACCUM_BUFFER_BIT.val;
      end;
      if STENCIL_BUFFER_BIT in self then
      begin
        res += 'STENCIL_BUFFER_BIT+';
        left_val := left_val and not STENCIL_BUFFER_BIT.val;
      end;
      if COLOR_BUFFER_BIT in self then
      begin
        res += 'COLOR_BUFFER_BIT+';
        left_val := left_val and not COLOR_BUFFER_BIT.val;
      end;
      if COVERAGE_BUFFER_BIT in self then
      begin
        res += 'COVERAGE_BUFFER_BIT+';
        left_val := left_val and not COVERAGE_BUFFER_BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'glClearBufferMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glClientAttribMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CLIENT_PIXEL_STORE_BIT:  glClientAttribMask read new glClientAttribMask(1 shl 0);
    public static property CLIENT_VERTEX_ARRAY_BIT: glClientAttribMask read new glClientAttribMask(1 shl 1);
    public static property CLIENT_ALL_ATTRIB_BITS:  glClientAttribMask read new glClientAttribMask($FFFFFFFF);
    
    public static function operator+(v1, v2: glClientAttribMask) := new glClientAttribMask(v1.val or v2.val);
    public static function operator or(v1, v2: glClientAttribMask) := new glClientAttribMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glClientAttribMask; v2: glClientAttribMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glClientAttribMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glClientAttribMask[0]';
        exit;
      end;
      if CLIENT_PIXEL_STORE_BIT in self then
      begin
        res += 'CLIENT_PIXEL_STORE_BIT+';
        left_val := left_val and not CLIENT_PIXEL_STORE_BIT.val;
      end;
      if CLIENT_VERTEX_ARRAY_BIT in self then
      begin
        res += 'CLIENT_VERTEX_ARRAY_BIT+';
        left_val := left_val and not CLIENT_VERTEX_ARRAY_BIT.val;
      end;
      if CLIENT_ALL_ATTRIB_BITS in self then
      begin
        res += 'CLIENT_ALL_ATTRIB_BITS+';
        left_val := left_val and not CLIENT_ALL_ATTRIB_BITS.val;
      end;
      if left_val<>0 then
      begin
        res += 'glClientAttribMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glClipControlDepth = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEGATIVE_ONE_TO_ONE: glClipControlDepth read new glClipControlDepth($935E);
    public static property ZERO_TO_ONE:         glClipControlDepth read new glClipControlDepth($935F);
    
    public function ToString: string; override;
    begin
      if NEGATIVE_ONE_TO_ONE = self then
        Result := 'NEGATIVE_ONE_TO_ONE' else
      if ZERO_TO_ONE = self then
        Result := 'ZERO_TO_ONE' else
        Result := $'glClipControlDepth[{self.val}]';
    end;
    
  end;
  
  glClipControlOrigin = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LOWER_LEFT: glClipControlOrigin read new glClipControlOrigin($8CA1);
    public static property UPPER_LEFT: glClipControlOrigin read new glClipControlOrigin($8CA2);
    
    public function ToString: string; override;
    begin
      if LOWER_LEFT = self then
        Result := 'LOWER_LEFT' else
      if UPPER_LEFT = self then
        Result := 'UPPER_LEFT' else
        Result := $'glClipControlOrigin[{self.val}]';
    end;
    
  end;
  
  glClipPlaneName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CLIP_PLANE0:    glClipPlaneName read new glClipPlaneName($3000);
    public static property CLIP_DISTANCE0: glClipPlaneName read new glClipPlaneName($3000);
    public static property CLIP_PLANE1:    glClipPlaneName read new glClipPlaneName($3001);
    public static property CLIP_DISTANCE1: glClipPlaneName read new glClipPlaneName($3001);
    public static property CLIP_PLANE2:    glClipPlaneName read new glClipPlaneName($3002);
    public static property CLIP_DISTANCE2: glClipPlaneName read new glClipPlaneName($3002);
    public static property CLIP_PLANE3:    glClipPlaneName read new glClipPlaneName($3003);
    public static property CLIP_DISTANCE3: glClipPlaneName read new glClipPlaneName($3003);
    public static property CLIP_PLANE4:    glClipPlaneName read new glClipPlaneName($3004);
    public static property CLIP_DISTANCE4: glClipPlaneName read new glClipPlaneName($3004);
    public static property CLIP_PLANE5:    glClipPlaneName read new glClipPlaneName($3005);
    public static property CLIP_DISTANCE5: glClipPlaneName read new glClipPlaneName($3005);
    public static property CLIP_DISTANCE6: glClipPlaneName read new glClipPlaneName($3006);
    public static property CLIP_DISTANCE7: glClipPlaneName read new glClipPlaneName($3007);
    
    public function ToString: string; override;
    begin
      if CLIP_PLANE0 = self then
        Result := 'CLIP_PLANE0' else
      if CLIP_DISTANCE0 = self then
        Result := 'CLIP_DISTANCE0' else
      if CLIP_PLANE1 = self then
        Result := 'CLIP_PLANE1' else
      if CLIP_DISTANCE1 = self then
        Result := 'CLIP_DISTANCE1' else
      if CLIP_PLANE2 = self then
        Result := 'CLIP_PLANE2' else
      if CLIP_DISTANCE2 = self then
        Result := 'CLIP_DISTANCE2' else
      if CLIP_PLANE3 = self then
        Result := 'CLIP_PLANE3' else
      if CLIP_DISTANCE3 = self then
        Result := 'CLIP_DISTANCE3' else
      if CLIP_PLANE4 = self then
        Result := 'CLIP_PLANE4' else
      if CLIP_DISTANCE4 = self then
        Result := 'CLIP_DISTANCE4' else
      if CLIP_PLANE5 = self then
        Result := 'CLIP_PLANE5' else
      if CLIP_DISTANCE5 = self then
        Result := 'CLIP_DISTANCE5' else
      if CLIP_DISTANCE6 = self then
        Result := 'CLIP_DISTANCE6' else
      if CLIP_DISTANCE7 = self then
        Result := 'CLIP_DISTANCE7' else
        Result := $'glClipPlaneName[{self.val}]';
    end;
    
  end;
  
  glColorBuffer = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:               glColorBuffer read new glColorBuffer(0);
    public static property FRONT_LEFT:         glColorBuffer read new glColorBuffer($0400);
    public static property FRONT_RIGHT:        glColorBuffer read new glColorBuffer($0401);
    public static property BACK_LEFT:          glColorBuffer read new glColorBuffer($0402);
    public static property BACK_RIGHT:         glColorBuffer read new glColorBuffer($0403);
    public static property FRONT:              glColorBuffer read new glColorBuffer($0404);
    public static property BACK:               glColorBuffer read new glColorBuffer($0405);
    public static property LEFT:               glColorBuffer read new glColorBuffer($0406);
    public static property RIGHT:              glColorBuffer read new glColorBuffer($0407);
    public static property FRONT_AND_BACK:     glColorBuffer read new glColorBuffer($0408);
    public static property COLOR_ATTACHMENT0:  glColorBuffer read new glColorBuffer($8CE0);
    public static property COLOR_ATTACHMENT1:  glColorBuffer read new glColorBuffer($8CE1);
    public static property COLOR_ATTACHMENT2:  glColorBuffer read new glColorBuffer($8CE2);
    public static property COLOR_ATTACHMENT3:  glColorBuffer read new glColorBuffer($8CE3);
    public static property COLOR_ATTACHMENT4:  glColorBuffer read new glColorBuffer($8CE4);
    public static property COLOR_ATTACHMENT5:  glColorBuffer read new glColorBuffer($8CE5);
    public static property COLOR_ATTACHMENT6:  glColorBuffer read new glColorBuffer($8CE6);
    public static property COLOR_ATTACHMENT7:  glColorBuffer read new glColorBuffer($8CE7);
    public static property COLOR_ATTACHMENT8:  glColorBuffer read new glColorBuffer($8CE8);
    public static property COLOR_ATTACHMENT9:  glColorBuffer read new glColorBuffer($8CE9);
    public static property COLOR_ATTACHMENT10: glColorBuffer read new glColorBuffer($8CEA);
    public static property COLOR_ATTACHMENT11: glColorBuffer read new glColorBuffer($8CEB);
    public static property COLOR_ATTACHMENT12: glColorBuffer read new glColorBuffer($8CEC);
    public static property COLOR_ATTACHMENT13: glColorBuffer read new glColorBuffer($8CED);
    public static property COLOR_ATTACHMENT14: glColorBuffer read new glColorBuffer($8CEE);
    public static property COLOR_ATTACHMENT15: glColorBuffer read new glColorBuffer($8CEF);
    public static property COLOR_ATTACHMENT16: glColorBuffer read new glColorBuffer($8CF0);
    public static property COLOR_ATTACHMENT17: glColorBuffer read new glColorBuffer($8CF1);
    public static property COLOR_ATTACHMENT18: glColorBuffer read new glColorBuffer($8CF2);
    public static property COLOR_ATTACHMENT19: glColorBuffer read new glColorBuffer($8CF3);
    public static property COLOR_ATTACHMENT20: glColorBuffer read new glColorBuffer($8CF4);
    public static property COLOR_ATTACHMENT21: glColorBuffer read new glColorBuffer($8CF5);
    public static property COLOR_ATTACHMENT22: glColorBuffer read new glColorBuffer($8CF6);
    public static property COLOR_ATTACHMENT23: glColorBuffer read new glColorBuffer($8CF7);
    public static property COLOR_ATTACHMENT24: glColorBuffer read new glColorBuffer($8CF8);
    public static property COLOR_ATTACHMENT25: glColorBuffer read new glColorBuffer($8CF9);
    public static property COLOR_ATTACHMENT26: glColorBuffer read new glColorBuffer($8CFA);
    public static property COLOR_ATTACHMENT27: glColorBuffer read new glColorBuffer($8CFB);
    public static property COLOR_ATTACHMENT28: glColorBuffer read new glColorBuffer($8CFC);
    public static property COLOR_ATTACHMENT29: glColorBuffer read new glColorBuffer($8CFD);
    public static property COLOR_ATTACHMENT30: glColorBuffer read new glColorBuffer($8CFE);
    public static property COLOR_ATTACHMENT31: glColorBuffer read new glColorBuffer($8CFF);
    
    public function ToString: string; override;
    begin
      if NONE = self then
        Result := 'NONE' else
      if FRONT_LEFT = self then
        Result := 'FRONT_LEFT' else
      if FRONT_RIGHT = self then
        Result := 'FRONT_RIGHT' else
      if BACK_LEFT = self then
        Result := 'BACK_LEFT' else
      if BACK_RIGHT = self then
        Result := 'BACK_RIGHT' else
      if FRONT = self then
        Result := 'FRONT' else
      if BACK = self then
        Result := 'BACK' else
      if LEFT = self then
        Result := 'LEFT' else
      if RIGHT = self then
        Result := 'RIGHT' else
      if FRONT_AND_BACK = self then
        Result := 'FRONT_AND_BACK' else
      if COLOR_ATTACHMENT0 = self then
        Result := 'COLOR_ATTACHMENT0' else
      if COLOR_ATTACHMENT1 = self then
        Result := 'COLOR_ATTACHMENT1' else
      if COLOR_ATTACHMENT2 = self then
        Result := 'COLOR_ATTACHMENT2' else
      if COLOR_ATTACHMENT3 = self then
        Result := 'COLOR_ATTACHMENT3' else
      if COLOR_ATTACHMENT4 = self then
        Result := 'COLOR_ATTACHMENT4' else
      if COLOR_ATTACHMENT5 = self then
        Result := 'COLOR_ATTACHMENT5' else
      if COLOR_ATTACHMENT6 = self then
        Result := 'COLOR_ATTACHMENT6' else
      if COLOR_ATTACHMENT7 = self then
        Result := 'COLOR_ATTACHMENT7' else
      if COLOR_ATTACHMENT8 = self then
        Result := 'COLOR_ATTACHMENT8' else
      if COLOR_ATTACHMENT9 = self then
        Result := 'COLOR_ATTACHMENT9' else
      if COLOR_ATTACHMENT10 = self then
        Result := 'COLOR_ATTACHMENT10' else
      if COLOR_ATTACHMENT11 = self then
        Result := 'COLOR_ATTACHMENT11' else
      if COLOR_ATTACHMENT12 = self then
        Result := 'COLOR_ATTACHMENT12' else
      if COLOR_ATTACHMENT13 = self then
        Result := 'COLOR_ATTACHMENT13' else
      if COLOR_ATTACHMENT14 = self then
        Result := 'COLOR_ATTACHMENT14' else
      if COLOR_ATTACHMENT15 = self then
        Result := 'COLOR_ATTACHMENT15' else
      if COLOR_ATTACHMENT16 = self then
        Result := 'COLOR_ATTACHMENT16' else
      if COLOR_ATTACHMENT17 = self then
        Result := 'COLOR_ATTACHMENT17' else
      if COLOR_ATTACHMENT18 = self then
        Result := 'COLOR_ATTACHMENT18' else
      if COLOR_ATTACHMENT19 = self then
        Result := 'COLOR_ATTACHMENT19' else
      if COLOR_ATTACHMENT20 = self then
        Result := 'COLOR_ATTACHMENT20' else
      if COLOR_ATTACHMENT21 = self then
        Result := 'COLOR_ATTACHMENT21' else
      if COLOR_ATTACHMENT22 = self then
        Result := 'COLOR_ATTACHMENT22' else
      if COLOR_ATTACHMENT23 = self then
        Result := 'COLOR_ATTACHMENT23' else
      if COLOR_ATTACHMENT24 = self then
        Result := 'COLOR_ATTACHMENT24' else
      if COLOR_ATTACHMENT25 = self then
        Result := 'COLOR_ATTACHMENT25' else
      if COLOR_ATTACHMENT26 = self then
        Result := 'COLOR_ATTACHMENT26' else
      if COLOR_ATTACHMENT27 = self then
        Result := 'COLOR_ATTACHMENT27' else
      if COLOR_ATTACHMENT28 = self then
        Result := 'COLOR_ATTACHMENT28' else
      if COLOR_ATTACHMENT29 = self then
        Result := 'COLOR_ATTACHMENT29' else
      if COLOR_ATTACHMENT30 = self then
        Result := 'COLOR_ATTACHMENT30' else
      if COLOR_ATTACHMENT31 = self then
        Result := 'COLOR_ATTACHMENT31' else
        Result := $'glColorBuffer[{self.val}]';
    end;
    
  end;
  
  glColorMaterialParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property AMBIENT:             glColorMaterialParameter read new glColorMaterialParameter($1200);
    public static property DIFFUSE:             glColorMaterialParameter read new glColorMaterialParameter($1201);
    public static property SPECULAR:            glColorMaterialParameter read new glColorMaterialParameter($1202);
    public static property EMISSION:            glColorMaterialParameter read new glColorMaterialParameter($1600);
    public static property AMBIENT_AND_DIFFUSE: glColorMaterialParameter read new glColorMaterialParameter($1602);
    
    public function ToString: string; override;
    begin
      if AMBIENT = self then
        Result := 'AMBIENT' else
      if DIFFUSE = self then
        Result := 'DIFFUSE' else
      if SPECULAR = self then
        Result := 'SPECULAR' else
      if EMISSION = self then
        Result := 'EMISSION' else
      if AMBIENT_AND_DIFFUSE = self then
        Result := 'AMBIENT_AND_DIFFUSE' else
        Result := $'glColorMaterialParameter[{self.val}]';
    end;
    
  end;
  
  glColorPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:           glColorPointerType read new glColorPointerType($1400);
    public static property UNSIGNED_BYTE:  glColorPointerType read new glColorPointerType($1401);
    public static property UNSIGNED_SHORT: glColorPointerType read new glColorPointerType($1403);
    public static property UNSIGNED_INT:   glColorPointerType read new glColorPointerType($1405);
    
    public function ToString: string; override;
    begin
      if BYTE = self then
        Result := 'BYTE' else
      if UNSIGNED_BYTE = self then
        Result := 'UNSIGNED_BYTE' else
      if UNSIGNED_SHORT = self then
        Result := 'UNSIGNED_SHORT' else
      if UNSIGNED_INT = self then
        Result := 'UNSIGNED_INT' else
        Result := $'glColorPointerType[{self.val}]';
    end;
    
  end;
  
  glColorTableParameterPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COLOR_TABLE_SCALE:          glColorTableParameterPName read new glColorTableParameterPName($80D6);
    public static property COLOR_TABLE_BIAS:           glColorTableParameterPName read new glColorTableParameterPName($80D7);
    public static property COLOR_TABLE_FORMAT:         glColorTableParameterPName read new glColorTableParameterPName($80D8);
    public static property COLOR_TABLE_WIDTH:          glColorTableParameterPName read new glColorTableParameterPName($80D9);
    public static property COLOR_TABLE_RED_SIZE:       glColorTableParameterPName read new glColorTableParameterPName($80DA);
    public static property COLOR_TABLE_GREEN_SIZE:     glColorTableParameterPName read new glColorTableParameterPName($80DB);
    public static property COLOR_TABLE_BLUE_SIZE:      glColorTableParameterPName read new glColorTableParameterPName($80DC);
    public static property COLOR_TABLE_ALPHA_SIZE:     glColorTableParameterPName read new glColorTableParameterPName($80DD);
    public static property COLOR_TABLE_LUMINANCE_SIZE: glColorTableParameterPName read new glColorTableParameterPName($80DE);
    public static property COLOR_TABLE_INTENSITY_SIZE: glColorTableParameterPName read new glColorTableParameterPName($80DF);
    
    public function ToString: string; override;
    begin
      if COLOR_TABLE_SCALE = self then
        Result := 'COLOR_TABLE_SCALE' else
      if COLOR_TABLE_BIAS = self then
        Result := 'COLOR_TABLE_BIAS' else
      if COLOR_TABLE_FORMAT = self then
        Result := 'COLOR_TABLE_FORMAT' else
      if COLOR_TABLE_WIDTH = self then
        Result := 'COLOR_TABLE_WIDTH' else
      if COLOR_TABLE_RED_SIZE = self then
        Result := 'COLOR_TABLE_RED_SIZE' else
      if COLOR_TABLE_GREEN_SIZE = self then
        Result := 'COLOR_TABLE_GREEN_SIZE' else
      if COLOR_TABLE_BLUE_SIZE = self then
        Result := 'COLOR_TABLE_BLUE_SIZE' else
      if COLOR_TABLE_ALPHA_SIZE = self then
        Result := 'COLOR_TABLE_ALPHA_SIZE' else
      if COLOR_TABLE_LUMINANCE_SIZE = self then
        Result := 'COLOR_TABLE_LUMINANCE_SIZE' else
      if COLOR_TABLE_INTENSITY_SIZE = self then
        Result := 'COLOR_TABLE_INTENSITY_SIZE' else
        Result := $'glColorTableParameterPName[{self.val}]';
    end;
    
  end;
  
  glColorTableTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_COLOR_TABLE:                 glColorTableTarget read new glColorTableTarget($80BC);
    public static property PROXY_TEXTURE_COLOR_TABLE:           glColorTableTarget read new glColorTableTarget($80BD);
    public static property COLOR_TABLE:                         glColorTableTarget read new glColorTableTarget($80D0);
    public static property POST_CONVOLUTION_COLOR_TABLE:        glColorTableTarget read new glColorTableTarget($80D1);
    public static property POST_COLOR_MATRIX_COLOR_TABLE:       glColorTableTarget read new glColorTableTarget($80D2);
    public static property PROXY_COLOR_TABLE:                   glColorTableTarget read new glColorTableTarget($80D3);
    public static property PROXY_POST_CONVOLUTION_COLOR_TABLE:  glColorTableTarget read new glColorTableTarget($80D4);
    public static property PROXY_POST_COLOR_MATRIX_COLOR_TABLE: glColorTableTarget read new glColorTableTarget($80D5);
    
    public function ToString: string; override;
    begin
      if TEXTURE_COLOR_TABLE = self then
        Result := 'TEXTURE_COLOR_TABLE' else
      if PROXY_TEXTURE_COLOR_TABLE = self then
        Result := 'PROXY_TEXTURE_COLOR_TABLE' else
      if COLOR_TABLE = self then
        Result := 'COLOR_TABLE' else
      if POST_CONVOLUTION_COLOR_TABLE = self then
        Result := 'POST_CONVOLUTION_COLOR_TABLE' else
      if POST_COLOR_MATRIX_COLOR_TABLE = self then
        Result := 'POST_COLOR_MATRIX_COLOR_TABLE' else
      if PROXY_COLOR_TABLE = self then
        Result := 'PROXY_COLOR_TABLE' else
      if PROXY_POST_CONVOLUTION_COLOR_TABLE = self then
        Result := 'PROXY_POST_CONVOLUTION_COLOR_TABLE' else
      if PROXY_POST_COLOR_MATRIX_COLOR_TABLE = self then
        Result := 'PROXY_POST_COLOR_MATRIX_COLOR_TABLE' else
        Result := $'glColorTableTarget[{self.val}]';
    end;
    
  end;
  
  glCombinerBias = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:                      glCombinerBias read new glCombinerBias(0);
    public static property BIAS_BY_NEGATIVE_ONE_HALF: glCombinerBias read new glCombinerBias($8541);
    
    public function ToString: string; override;
    begin
      if NONE = self then
        Result := 'NONE' else
      if BIAS_BY_NEGATIVE_ONE_HALF = self then
        Result := 'BIAS_BY_NEGATIVE_ONE_HALF' else
        Result := $'glCombinerBias[{self.val}]';
    end;
    
  end;
  
  glCombinerComponentUsage = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BLUE:  glCombinerComponentUsage read new glCombinerComponentUsage($1905);
    public static property ALPHA: glCombinerComponentUsage read new glCombinerComponentUsage($1906);
    public static property RGB:   glCombinerComponentUsage read new glCombinerComponentUsage($1907);
    
    public function ToString: string; override;
    begin
      if BLUE = self then
        Result := 'BLUE' else
      if ALPHA = self then
        Result := 'ALPHA' else
      if RGB = self then
        Result := 'RGB' else
        Result := $'glCombinerComponentUsage[{self.val}]';
    end;
    
  end;
  
  glCombinerMapping = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNSIGNED_IDENTITY: glCombinerMapping read new glCombinerMapping($8536);
    public static property UNSIGNED_INVERT:   glCombinerMapping read new glCombinerMapping($8537);
    public static property EXPAND_NORMAL:     glCombinerMapping read new glCombinerMapping($8538);
    public static property EXPAND_NEGATE:     glCombinerMapping read new glCombinerMapping($8539);
    public static property HALF_BIAS_NORMAL:  glCombinerMapping read new glCombinerMapping($853A);
    public static property HALF_BIAS_NEGATE:  glCombinerMapping read new glCombinerMapping($853B);
    public static property SIGNED_IDENTITY:   glCombinerMapping read new glCombinerMapping($853C);
    public static property SIGNED_NEGATE:     glCombinerMapping read new glCombinerMapping($853D);
    
    public function ToString: string; override;
    begin
      if UNSIGNED_IDENTITY = self then
        Result := 'UNSIGNED_IDENTITY' else
      if UNSIGNED_INVERT = self then
        Result := 'UNSIGNED_INVERT' else
      if EXPAND_NORMAL = self then
        Result := 'EXPAND_NORMAL' else
      if EXPAND_NEGATE = self then
        Result := 'EXPAND_NEGATE' else
      if HALF_BIAS_NORMAL = self then
        Result := 'HALF_BIAS_NORMAL' else
      if HALF_BIAS_NEGATE = self then
        Result := 'HALF_BIAS_NEGATE' else
      if SIGNED_IDENTITY = self then
        Result := 'SIGNED_IDENTITY' else
      if SIGNED_NEGATE = self then
        Result := 'SIGNED_NEGATE' else
        Result := $'glCombinerMapping[{self.val}]';
    end;
    
  end;
  
  glCombinerParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMBINER_INPUT:           glCombinerParameter read new glCombinerParameter($8542);
    public static property COMBINER_MAPPING:         glCombinerParameter read new glCombinerParameter($8543);
    public static property COMBINER_COMPONENT_USAGE: glCombinerParameter read new glCombinerParameter($8544);
    
    public function ToString: string; override;
    begin
      if COMBINER_INPUT = self then
        Result := 'COMBINER_INPUT' else
      if COMBINER_MAPPING = self then
        Result := 'COMBINER_MAPPING' else
      if COMBINER_COMPONENT_USAGE = self then
        Result := 'COMBINER_COMPONENT_USAGE' else
        Result := $'glCombinerParameter[{self.val}]';
    end;
    
  end;
  
  glCombinerPortion = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ALPHA: glCombinerPortion read new glCombinerPortion($1906);
    public static property RGB:   glCombinerPortion read new glCombinerPortion($1907);
    
    public function ToString: string; override;
    begin
      if ALPHA = self then
        Result := 'ALPHA' else
      if RGB = self then
        Result := 'RGB' else
        Result := $'glCombinerPortion[{self.val}]';
    end;
    
  end;
  
  glCombinerRegister = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE0:         glCombinerRegister read new glCombinerRegister($84C0);
    public static property TEXTURE1:         glCombinerRegister read new glCombinerRegister($84C1);
    public static property PRIMARY_COLOR_NV: glCombinerRegister read new glCombinerRegister($852C);
    public static property SECONDARY_COLOR:  glCombinerRegister read new glCombinerRegister($852D);
    public static property SPARE0:           glCombinerRegister read new glCombinerRegister($852E);
    public static property SPARE1:           glCombinerRegister read new glCombinerRegister($852F);
    public static property DISCARD_NV:       glCombinerRegister read new glCombinerRegister($8530);
    
    public function ToString: string; override;
    begin
      if TEXTURE0 = self then
        Result := 'TEXTURE0' else
      if TEXTURE1 = self then
        Result := 'TEXTURE1' else
      if PRIMARY_COLOR_NV = self then
        Result := 'PRIMARY_COLOR_NV' else
      if SECONDARY_COLOR = self then
        Result := 'SECONDARY_COLOR' else
      if SPARE0 = self then
        Result := 'SPARE0' else
      if SPARE1 = self then
        Result := 'SPARE1' else
      if DISCARD_NV = self then
        Result := 'DISCARD_NV' else
        Result := $'glCombinerRegister[{self.val}]';
    end;
    
  end;
  
  glCombinerScale = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:              glCombinerScale read new glCombinerScale(0);
    public static property SCALE_BY_TWO:      glCombinerScale read new glCombinerScale($853E);
    public static property SCALE_BY_FOUR:     glCombinerScale read new glCombinerScale($853F);
    public static property SCALE_BY_ONE_HALF: glCombinerScale read new glCombinerScale($8540);
    
    public function ToString: string; override;
    begin
      if NONE = self then
        Result := 'NONE' else
      if SCALE_BY_TWO = self then
        Result := 'SCALE_BY_TWO' else
      if SCALE_BY_FOUR = self then
        Result := 'SCALE_BY_FOUR' else
      if SCALE_BY_ONE_HALF = self then
        Result := 'SCALE_BY_ONE_HALF' else
        Result := $'glCombinerScale[{self.val}]';
    end;
    
  end;
  
  glCombinerStage = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMBINER0: glCombinerStage read new glCombinerStage($8550);
    public static property COMBINER1: glCombinerStage read new glCombinerStage($8551);
    public static property COMBINER2: glCombinerStage read new glCombinerStage($8552);
    public static property COMBINER3: glCombinerStage read new glCombinerStage($8553);
    public static property COMBINER4: glCombinerStage read new glCombinerStage($8554);
    public static property COMBINER5: glCombinerStage read new glCombinerStage($8555);
    public static property COMBINER6: glCombinerStage read new glCombinerStage($8556);
    public static property COMBINER7: glCombinerStage read new glCombinerStage($8557);
    
    public function ToString: string; override;
    begin
      if COMBINER0 = self then
        Result := 'COMBINER0' else
      if COMBINER1 = self then
        Result := 'COMBINER1' else
      if COMBINER2 = self then
        Result := 'COMBINER2' else
      if COMBINER3 = self then
        Result := 'COMBINER3' else
      if COMBINER4 = self then
        Result := 'COMBINER4' else
      if COMBINER5 = self then
        Result := 'COMBINER5' else
      if COMBINER6 = self then
        Result := 'COMBINER6' else
      if COMBINER7 = self then
        Result := 'COMBINER7' else
        Result := $'glCombinerStage[{self.val}]';
    end;
    
  end;
  
  glCombinerVariable = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VARIABLE_A: glCombinerVariable read new glCombinerVariable($8523);
    public static property VARIABLE_B: glCombinerVariable read new glCombinerVariable($8524);
    public static property VARIABLE_C: glCombinerVariable read new glCombinerVariable($8525);
    public static property VARIABLE_D: glCombinerVariable read new glCombinerVariable($8526);
    public static property VARIABLE_E: glCombinerVariable read new glCombinerVariable($8527);
    public static property VARIABLE_F: glCombinerVariable read new glCombinerVariable($8528);
    public static property VARIABLE_G: glCombinerVariable read new glCombinerVariable($8529);
    
    public function ToString: string; override;
    begin
      if VARIABLE_A = self then
        Result := 'VARIABLE_A' else
      if VARIABLE_B = self then
        Result := 'VARIABLE_B' else
      if VARIABLE_C = self then
        Result := 'VARIABLE_C' else
      if VARIABLE_D = self then
        Result := 'VARIABLE_D' else
      if VARIABLE_E = self then
        Result := 'VARIABLE_E' else
      if VARIABLE_F = self then
        Result := 'VARIABLE_F' else
      if VARIABLE_G = self then
        Result := 'VARIABLE_G' else
        Result := $'glCombinerVariable[{self.val}]';
    end;
    
  end;
  
  glCommandOpcodes = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TERMINATE_SEQUENCE_COMMAND:      glCommandOpcodes read new glCommandOpcodes(0);
    public static property NOP_COMMAND:                     glCommandOpcodes read new glCommandOpcodes($0001);
    public static property DRAW_ELEMENTS_COMMAND:           glCommandOpcodes read new glCommandOpcodes($0002);
    public static property DRAW_ARRAYS_COMMAND:             glCommandOpcodes read new glCommandOpcodes($0003);
    public static property DRAW_ELEMENTS_STRIP_COMMAND:     glCommandOpcodes read new glCommandOpcodes($0004);
    public static property DRAW_ARRAYS_STRIP_COMMAND:       glCommandOpcodes read new glCommandOpcodes($0005);
    public static property DRAW_ELEMENTS_INSTANCED_COMMAND: glCommandOpcodes read new glCommandOpcodes($0006);
    public static property DRAW_ARRAYS_INSTANCED_COMMAND:   glCommandOpcodes read new glCommandOpcodes($0007);
    public static property ELEMENT_ADDRESS_COMMAND:         glCommandOpcodes read new glCommandOpcodes($0008);
    public static property ATTRIBUTE_ADDRESS_COMMAND:       glCommandOpcodes read new glCommandOpcodes($0009);
    public static property UNIFORM_ADDRESS_COMMAND:         glCommandOpcodes read new glCommandOpcodes($000A);
    public static property BLEND_COLOR_COMMAND:             glCommandOpcodes read new glCommandOpcodes($000B);
    public static property STENCIL_REF_COMMAND:             glCommandOpcodes read new glCommandOpcodes($000C);
    public static property LINE_WIDTH_COMMAND:              glCommandOpcodes read new glCommandOpcodes($000D);
    public static property POLYGON_OFFSET_COMMAND:          glCommandOpcodes read new glCommandOpcodes($000E);
    public static property ALPHA_REF_COMMAND:               glCommandOpcodes read new glCommandOpcodes($000F);
    public static property VIEWPORT_COMMAND:                glCommandOpcodes read new glCommandOpcodes($0010);
    public static property SCISSOR_COMMAND:                 glCommandOpcodes read new glCommandOpcodes($0011);
    public static property FRONT_FACE_COMMAND:              glCommandOpcodes read new glCommandOpcodes($0012);
    
    public function ToString: string; override;
    begin
      if TERMINATE_SEQUENCE_COMMAND = self then
        Result := 'TERMINATE_SEQUENCE_COMMAND' else
      if NOP_COMMAND = self then
        Result := 'NOP_COMMAND' else
      if DRAW_ELEMENTS_COMMAND = self then
        Result := 'DRAW_ELEMENTS_COMMAND' else
      if DRAW_ARRAYS_COMMAND = self then
        Result := 'DRAW_ARRAYS_COMMAND' else
      if DRAW_ELEMENTS_STRIP_COMMAND = self then
        Result := 'DRAW_ELEMENTS_STRIP_COMMAND' else
      if DRAW_ARRAYS_STRIP_COMMAND = self then
        Result := 'DRAW_ARRAYS_STRIP_COMMAND' else
      if DRAW_ELEMENTS_INSTANCED_COMMAND = self then
        Result := 'DRAW_ELEMENTS_INSTANCED_COMMAND' else
      if DRAW_ARRAYS_INSTANCED_COMMAND = self then
        Result := 'DRAW_ARRAYS_INSTANCED_COMMAND' else
      if ELEMENT_ADDRESS_COMMAND = self then
        Result := 'ELEMENT_ADDRESS_COMMAND' else
      if ATTRIBUTE_ADDRESS_COMMAND = self then
        Result := 'ATTRIBUTE_ADDRESS_COMMAND' else
      if UNIFORM_ADDRESS_COMMAND = self then
        Result := 'UNIFORM_ADDRESS_COMMAND' else
      if BLEND_COLOR_COMMAND = self then
        Result := 'BLEND_COLOR_COMMAND' else
      if STENCIL_REF_COMMAND = self then
        Result := 'STENCIL_REF_COMMAND' else
      if LINE_WIDTH_COMMAND = self then
        Result := 'LINE_WIDTH_COMMAND' else
      if POLYGON_OFFSET_COMMAND = self then
        Result := 'POLYGON_OFFSET_COMMAND' else
      if ALPHA_REF_COMMAND = self then
        Result := 'ALPHA_REF_COMMAND' else
      if VIEWPORT_COMMAND = self then
        Result := 'VIEWPORT_COMMAND' else
      if SCISSOR_COMMAND = self then
        Result := 'SCISSOR_COMMAND' else
      if FRONT_FACE_COMMAND = self then
        Result := 'FRONT_FACE_COMMAND' else
        Result := $'glCommandOpcodes[{self.val}]';
    end;
    
  end;
  
  glConditionalRenderMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property QUERY_WAIT:                       glConditionalRenderMode read new glConditionalRenderMode($8E13);
    public static property QUERY_NO_WAIT:                    glConditionalRenderMode read new glConditionalRenderMode($8E14);
    public static property QUERY_BY_REGION_WAIT:             glConditionalRenderMode read new glConditionalRenderMode($8E15);
    public static property QUERY_BY_REGION_NO_WAIT:          glConditionalRenderMode read new glConditionalRenderMode($8E16);
    public static property QUERY_WAIT_INVERTED:              glConditionalRenderMode read new glConditionalRenderMode($8E17);
    public static property QUERY_NO_WAIT_INVERTED:           glConditionalRenderMode read new glConditionalRenderMode($8E18);
    public static property QUERY_BY_REGION_WAIT_INVERTED:    glConditionalRenderMode read new glConditionalRenderMode($8E19);
    public static property QUERY_BY_REGION_NO_WAIT_INVERTED: glConditionalRenderMode read new glConditionalRenderMode($8E1A);
    
    public function ToString: string; override;
    begin
      if QUERY_WAIT = self then
        Result := 'QUERY_WAIT' else
      if QUERY_NO_WAIT = self then
        Result := 'QUERY_NO_WAIT' else
      if QUERY_BY_REGION_WAIT = self then
        Result := 'QUERY_BY_REGION_WAIT' else
      if QUERY_BY_REGION_NO_WAIT = self then
        Result := 'QUERY_BY_REGION_NO_WAIT' else
      if QUERY_WAIT_INVERTED = self then
        Result := 'QUERY_WAIT_INVERTED' else
      if QUERY_NO_WAIT_INVERTED = self then
        Result := 'QUERY_NO_WAIT_INVERTED' else
      if QUERY_BY_REGION_WAIT_INVERTED = self then
        Result := 'QUERY_BY_REGION_WAIT_INVERTED' else
      if QUERY_BY_REGION_NO_WAIT_INVERTED = self then
        Result := 'QUERY_BY_REGION_NO_WAIT_INVERTED' else
        Result := $'glConditionalRenderMode[{self.val}]';
    end;
    
  end;
  
  glContainerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROGRAM_OBJECT: glContainerType read new glContainerType($8B40);
    
    public function ToString: string; override;
    begin
      if PROGRAM_OBJECT = self then
        Result := 'PROGRAM_OBJECT' else
        Result := $'glContainerType[{self.val}]';
    end;
    
  end;
  
  glContextFlagMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: glContextFlagMask read new glContextFlagMask(1 shl 0);
    public static property CONTEXT_FLAG_DEBUG_BIT:              glContextFlagMask read new glContextFlagMask(1 shl 1);
    public static property CONTEXT_FLAG_ROBUST_ACCESS_BIT:      glContextFlagMask read new glContextFlagMask(1 shl 2);
    public static property CONTEXT_FLAG_NO_ERROR_BIT:           glContextFlagMask read new glContextFlagMask(1 shl 3);
    public static property CONTEXT_FLAG_PROTECTED_CONTENT_BIT:  glContextFlagMask read new glContextFlagMask(1 shl 4);
    
    public static function operator+(v1, v2: glContextFlagMask) := new glContextFlagMask(v1.val or v2.val);
    public static function operator or(v1, v2: glContextFlagMask) := new glContextFlagMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glContextFlagMask; v2: glContextFlagMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glContextFlagMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glContextFlagMask[0]';
        exit;
      end;
      if CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT in self then
      begin
        res += 'CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT+';
        left_val := left_val and not CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT.val;
      end;
      if CONTEXT_FLAG_DEBUG_BIT in self then
      begin
        res += 'CONTEXT_FLAG_DEBUG_BIT+';
        left_val := left_val and not CONTEXT_FLAG_DEBUG_BIT.val;
      end;
      if CONTEXT_FLAG_ROBUST_ACCESS_BIT in self then
      begin
        res += 'CONTEXT_FLAG_ROBUST_ACCESS_BIT+';
        left_val := left_val and not CONTEXT_FLAG_ROBUST_ACCESS_BIT.val;
      end;
      if CONTEXT_FLAG_NO_ERROR_BIT in self then
      begin
        res += 'CONTEXT_FLAG_NO_ERROR_BIT+';
        left_val := left_val and not CONTEXT_FLAG_NO_ERROR_BIT.val;
      end;
      if CONTEXT_FLAG_PROTECTED_CONTENT_BIT in self then
      begin
        res += 'CONTEXT_FLAG_PROTECTED_CONTENT_BIT+';
        left_val := left_val and not CONTEXT_FLAG_PROTECTED_CONTENT_BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'glContextFlagMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glContextProfileMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CONTEXT_CORE_PROFILE_BIT:          glContextProfileMask read new glContextProfileMask(1 shl 0);
    public static property CONTEXT_COMPATIBILITY_PROFILE_BIT: glContextProfileMask read new glContextProfileMask(1 shl 1);
    
    public static function operator+(v1, v2: glContextProfileMask) := new glContextProfileMask(v1.val or v2.val);
    public static function operator or(v1, v2: glContextProfileMask) := new glContextProfileMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glContextProfileMask; v2: glContextProfileMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glContextProfileMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glContextProfileMask[0]';
        exit;
      end;
      if CONTEXT_CORE_PROFILE_BIT in self then
      begin
        res += 'CONTEXT_CORE_PROFILE_BIT+';
        left_val := left_val and not CONTEXT_CORE_PROFILE_BIT.val;
      end;
      if CONTEXT_COMPATIBILITY_PROFILE_BIT in self then
      begin
        res += 'CONTEXT_COMPATIBILITY_PROFILE_BIT+';
        left_val := left_val and not CONTEXT_COMPATIBILITY_PROFILE_BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'glContextProfileMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glConvolutionBorderMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property REDUCE: glConvolutionBorderMode read new glConvolutionBorderMode($8016);
    
    public function ToString: string; override;
    begin
      if REDUCE = self then
        Result := 'REDUCE' else
        Result := $'glConvolutionBorderMode[{self.val}]';
    end;
    
  end;
  
  glConvolutionParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CONVOLUTION_BORDER_MODE:  glConvolutionParameter read new glConvolutionParameter($8013);
    public static property CONVOLUTION_FILTER_SCALE: glConvolutionParameter read new glConvolutionParameter($8014);
    public static property CONVOLUTION_FILTER_BIAS:  glConvolutionParameter read new glConvolutionParameter($8015);
    public static property CONVOLUTION_FORMAT:       glConvolutionParameter read new glConvolutionParameter($8017);
    public static property CONVOLUTION_WIDTH:        glConvolutionParameter read new glConvolutionParameter($8018);
    public static property CONVOLUTION_HEIGHT:       glConvolutionParameter read new glConvolutionParameter($8019);
    public static property MAX_CONVOLUTION_WIDTH:    glConvolutionParameter read new glConvolutionParameter($801A);
    public static property MAX_CONVOLUTION_HEIGHT:   glConvolutionParameter read new glConvolutionParameter($801B);
    public static property CONVOLUTION_BORDER_COLOR: glConvolutionParameter read new glConvolutionParameter($8154);
    
    public function ToString: string; override;
    begin
      if CONVOLUTION_BORDER_MODE = self then
        Result := 'CONVOLUTION_BORDER_MODE' else
      if CONVOLUTION_FILTER_SCALE = self then
        Result := 'CONVOLUTION_FILTER_SCALE' else
      if CONVOLUTION_FILTER_BIAS = self then
        Result := 'CONVOLUTION_FILTER_BIAS' else
      if CONVOLUTION_FORMAT = self then
        Result := 'CONVOLUTION_FORMAT' else
      if CONVOLUTION_WIDTH = self then
        Result := 'CONVOLUTION_WIDTH' else
      if CONVOLUTION_HEIGHT = self then
        Result := 'CONVOLUTION_HEIGHT' else
      if MAX_CONVOLUTION_WIDTH = self then
        Result := 'MAX_CONVOLUTION_WIDTH' else
      if MAX_CONVOLUTION_HEIGHT = self then
        Result := 'MAX_CONVOLUTION_HEIGHT' else
      if CONVOLUTION_BORDER_COLOR = self then
        Result := 'CONVOLUTION_BORDER_COLOR' else
        Result := $'glConvolutionParameter[{self.val}]';
    end;
    
  end;
  
  glConvolutionTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CONVOLUTION_1D: glConvolutionTarget read new glConvolutionTarget($8010);
    public static property CONVOLUTION_2D: glConvolutionTarget read new glConvolutionTarget($8011);
    
    public function ToString: string; override;
    begin
      if CONVOLUTION_1D = self then
        Result := 'CONVOLUTION_1D' else
      if CONVOLUTION_2D = self then
        Result := 'CONVOLUTION_2D' else
        Result := $'glConvolutionTarget[{self.val}]';
    end;
    
  end;
  
  glCopyBufferSubDataTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ARRAY_BUFFER:              glCopyBufferSubDataTarget read new glCopyBufferSubDataTarget($8892);
    public static property ELEMENT_ARRAY_BUFFER:      glCopyBufferSubDataTarget read new glCopyBufferSubDataTarget($8893);
    public static property PIXEL_PACK_BUFFER:         glCopyBufferSubDataTarget read new glCopyBufferSubDataTarget($88EB);
    public static property PIXEL_UNPACK_BUFFER:       glCopyBufferSubDataTarget read new glCopyBufferSubDataTarget($88EC);
    public static property UNIFORM_BUFFER:            glCopyBufferSubDataTarget read new glCopyBufferSubDataTarget($8A11);
    public static property TEXTURE_BUFFER:            glCopyBufferSubDataTarget read new glCopyBufferSubDataTarget($8C2A);
    public static property TRANSFORM_FEEDBACK_BUFFER: glCopyBufferSubDataTarget read new glCopyBufferSubDataTarget($8C8E);
    public static property COPY_READ_BUFFER:          glCopyBufferSubDataTarget read new glCopyBufferSubDataTarget($8F36);
    public static property COPY_WRITE_BUFFER:         glCopyBufferSubDataTarget read new glCopyBufferSubDataTarget($8F37);
    public static property DRAW_INDIRECT_BUFFER:      glCopyBufferSubDataTarget read new glCopyBufferSubDataTarget($8F3F);
    public static property SHADER_STORAGE_BUFFER:     glCopyBufferSubDataTarget read new glCopyBufferSubDataTarget($90D2);
    public static property DISPATCH_INDIRECT_BUFFER:  glCopyBufferSubDataTarget read new glCopyBufferSubDataTarget($90EE);
    public static property QUERY_BUFFER:              glCopyBufferSubDataTarget read new glCopyBufferSubDataTarget($9192);
    public static property ATOMIC_COUNTER_BUFFER:     glCopyBufferSubDataTarget read new glCopyBufferSubDataTarget($92C0);
    
    public function ToString: string; override;
    begin
      if ARRAY_BUFFER = self then
        Result := 'ARRAY_BUFFER' else
      if ELEMENT_ARRAY_BUFFER = self then
        Result := 'ELEMENT_ARRAY_BUFFER' else
      if PIXEL_PACK_BUFFER = self then
        Result := 'PIXEL_PACK_BUFFER' else
      if PIXEL_UNPACK_BUFFER = self then
        Result := 'PIXEL_UNPACK_BUFFER' else
      if UNIFORM_BUFFER = self then
        Result := 'UNIFORM_BUFFER' else
      if TEXTURE_BUFFER = self then
        Result := 'TEXTURE_BUFFER' else
      if TRANSFORM_FEEDBACK_BUFFER = self then
        Result := 'TRANSFORM_FEEDBACK_BUFFER' else
      if COPY_READ_BUFFER = self then
        Result := 'COPY_READ_BUFFER' else
      if COPY_WRITE_BUFFER = self then
        Result := 'COPY_WRITE_BUFFER' else
      if DRAW_INDIRECT_BUFFER = self then
        Result := 'DRAW_INDIRECT_BUFFER' else
      if SHADER_STORAGE_BUFFER = self then
        Result := 'SHADER_STORAGE_BUFFER' else
      if DISPATCH_INDIRECT_BUFFER = self then
        Result := 'DISPATCH_INDIRECT_BUFFER' else
      if QUERY_BUFFER = self then
        Result := 'QUERY_BUFFER' else
      if ATOMIC_COUNTER_BUFFER = self then
        Result := 'ATOMIC_COUNTER_BUFFER' else
        Result := $'glCopyBufferSubDataTarget[{self.val}]';
    end;
    
  end;
  
  glCopyImageSubDataTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_1D:                   glCopyImageSubDataTarget read new glCopyImageSubDataTarget($0DE0);
    public static property TEXTURE_2D:                   glCopyImageSubDataTarget read new glCopyImageSubDataTarget($0DE1);
    public static property TEXTURE_3D:                   glCopyImageSubDataTarget read new glCopyImageSubDataTarget($806F);
    public static property TEXTURE_RECTANGLE:            glCopyImageSubDataTarget read new glCopyImageSubDataTarget($84F5);
    public static property TEXTURE_CUBE_MAP:             glCopyImageSubDataTarget read new glCopyImageSubDataTarget($8513);
    public static property TEXTURE_1D_ARRAY:             glCopyImageSubDataTarget read new glCopyImageSubDataTarget($8C18);
    public static property TEXTURE_2D_ARRAY:             glCopyImageSubDataTarget read new glCopyImageSubDataTarget($8C1A);
    public static property RENDERBUFFER:                 glCopyImageSubDataTarget read new glCopyImageSubDataTarget($8D41);
    public static property TEXTURE_CUBE_MAP_ARRAY:       glCopyImageSubDataTarget read new glCopyImageSubDataTarget($9009);
    public static property TEXTURE_2D_MULTISAMPLE:       glCopyImageSubDataTarget read new glCopyImageSubDataTarget($9100);
    public static property TEXTURE_2D_MULTISAMPLE_ARRAY: glCopyImageSubDataTarget read new glCopyImageSubDataTarget($9102);
    
    public function ToString: string; override;
    begin
      if TEXTURE_1D = self then
        Result := 'TEXTURE_1D' else
      if TEXTURE_2D = self then
        Result := 'TEXTURE_2D' else
      if TEXTURE_3D = self then
        Result := 'TEXTURE_3D' else
      if TEXTURE_RECTANGLE = self then
        Result := 'TEXTURE_RECTANGLE' else
      if TEXTURE_CUBE_MAP = self then
        Result := 'TEXTURE_CUBE_MAP' else
      if TEXTURE_1D_ARRAY = self then
        Result := 'TEXTURE_1D_ARRAY' else
      if TEXTURE_2D_ARRAY = self then
        Result := 'TEXTURE_2D_ARRAY' else
      if RENDERBUFFER = self then
        Result := 'RENDERBUFFER' else
      if TEXTURE_CUBE_MAP_ARRAY = self then
        Result := 'TEXTURE_CUBE_MAP_ARRAY' else
      if TEXTURE_2D_MULTISAMPLE = self then
        Result := 'TEXTURE_2D_MULTISAMPLE' else
      if TEXTURE_2D_MULTISAMPLE_ARRAY = self then
        Result := 'TEXTURE_2D_MULTISAMPLE_ARRAY' else
        Result := $'glCopyImageSubDataTarget[{self.val}]';
    end;
    
  end;
  
  glCullParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CULL_VERTEX_EYE_POSITION:    glCullParameter read new glCullParameter($81AB);
    public static property CULL_VERTEX_OBJECT_POSITION: glCullParameter read new glCullParameter($81AC);
    
    public function ToString: string; override;
    begin
      if CULL_VERTEX_EYE_POSITION = self then
        Result := 'CULL_VERTEX_EYE_POSITION' else
      if CULL_VERTEX_OBJECT_POSITION = self then
        Result := 'CULL_VERTEX_OBJECT_POSITION' else
        Result := $'glCullParameter[{self.val}]';
    end;
    
  end;
  
  glDataType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SCALAR: glDataType read new glDataType($87BE);
    public static property VECTOR: glDataType read new glDataType($87BF);
    public static property MATRIX: glDataType read new glDataType($87C0);
    
    public function ToString: string; override;
    begin
      if SCALAR = self then
        Result := 'SCALAR' else
      if VECTOR = self then
        Result := 'VECTOR' else
      if MATRIX = self then
        Result := 'MATRIX' else
        Result := $'glDataType[{self.val}]';
    end;
    
  end;
  
  glDebugCategory = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DEBUG_CATEGORY_API_ERROR:          glDebugCategory read new glDebugCategory($9149);
    public static property DEBUG_CATEGORY_WINDOW_SYSTEM:      glDebugCategory read new glDebugCategory($914A);
    public static property DEBUG_CATEGORY_DEPRECATION:        glDebugCategory read new glDebugCategory($914B);
    public static property DEBUG_CATEGORY_UNDEFINED_BEHAVIOR: glDebugCategory read new glDebugCategory($914C);
    public static property DEBUG_CATEGORY_PERFORMANCE:        glDebugCategory read new glDebugCategory($914D);
    public static property DEBUG_CATEGORY_SHADER_COMPILER:    glDebugCategory read new glDebugCategory($914E);
    public static property DEBUG_CATEGORY_APPLICATION:        glDebugCategory read new glDebugCategory($914F);
    public static property DEBUG_CATEGORY_OTHER:              glDebugCategory read new glDebugCategory($9150);
    
    public function ToString: string; override;
    begin
      if DEBUG_CATEGORY_API_ERROR = self then
        Result := 'DEBUG_CATEGORY_API_ERROR' else
      if DEBUG_CATEGORY_WINDOW_SYSTEM = self then
        Result := 'DEBUG_CATEGORY_WINDOW_SYSTEM' else
      if DEBUG_CATEGORY_DEPRECATION = self then
        Result := 'DEBUG_CATEGORY_DEPRECATION' else
      if DEBUG_CATEGORY_UNDEFINED_BEHAVIOR = self then
        Result := 'DEBUG_CATEGORY_UNDEFINED_BEHAVIOR' else
      if DEBUG_CATEGORY_PERFORMANCE = self then
        Result := 'DEBUG_CATEGORY_PERFORMANCE' else
      if DEBUG_CATEGORY_SHADER_COMPILER = self then
        Result := 'DEBUG_CATEGORY_SHADER_COMPILER' else
      if DEBUG_CATEGORY_APPLICATION = self then
        Result := 'DEBUG_CATEGORY_APPLICATION' else
      if DEBUG_CATEGORY_OTHER = self then
        Result := 'DEBUG_CATEGORY_OTHER' else
        Result := $'glDebugCategory[{self.val}]';
    end;
    
  end;
  
  glDebugSeverity = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DONT_CARE:                   glDebugSeverity read new glDebugSeverity($1100);
    public static property DEBUG_SEVERITY_NOTIFICATION: glDebugSeverity read new glDebugSeverity($826B);
    public static property DEBUG_SEVERITY_HIGH:         glDebugSeverity read new glDebugSeverity($9146);
    public static property DEBUG_SEVERITY_MEDIUM:       glDebugSeverity read new glDebugSeverity($9147);
    public static property DEBUG_SEVERITY_LOW:          glDebugSeverity read new glDebugSeverity($9148);
    
    public function ToString: string; override;
    begin
      if DONT_CARE = self then
        Result := 'DONT_CARE' else
      if DEBUG_SEVERITY_NOTIFICATION = self then
        Result := 'DEBUG_SEVERITY_NOTIFICATION' else
      if DEBUG_SEVERITY_HIGH = self then
        Result := 'DEBUG_SEVERITY_HIGH' else
      if DEBUG_SEVERITY_MEDIUM = self then
        Result := 'DEBUG_SEVERITY_MEDIUM' else
      if DEBUG_SEVERITY_LOW = self then
        Result := 'DEBUG_SEVERITY_LOW' else
        Result := $'glDebugSeverity[{self.val}]';
    end;
    
  end;
  
  glDebugSource = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DONT_CARE:                    glDebugSource read new glDebugSource($1100);
    public static property DEBUG_SOURCE_API:             glDebugSource read new glDebugSource($8246);
    public static property DEBUG_SOURCE_WINDOW_SYSTEM:   glDebugSource read new glDebugSource($8247);
    public static property DEBUG_SOURCE_SHADER_COMPILER: glDebugSource read new glDebugSource($8248);
    public static property DEBUG_SOURCE_THIRD_PARTY:     glDebugSource read new glDebugSource($8249);
    public static property DEBUG_SOURCE_APPLICATION:     glDebugSource read new glDebugSource($824A);
    public static property DEBUG_SOURCE_OTHER:           glDebugSource read new glDebugSource($824B);
    
    public function ToString: string; override;
    begin
      if DONT_CARE = self then
        Result := 'DONT_CARE' else
      if DEBUG_SOURCE_API = self then
        Result := 'DEBUG_SOURCE_API' else
      if DEBUG_SOURCE_WINDOW_SYSTEM = self then
        Result := 'DEBUG_SOURCE_WINDOW_SYSTEM' else
      if DEBUG_SOURCE_SHADER_COMPILER = self then
        Result := 'DEBUG_SOURCE_SHADER_COMPILER' else
      if DEBUG_SOURCE_THIRD_PARTY = self then
        Result := 'DEBUG_SOURCE_THIRD_PARTY' else
      if DEBUG_SOURCE_APPLICATION = self then
        Result := 'DEBUG_SOURCE_APPLICATION' else
      if DEBUG_SOURCE_OTHER = self then
        Result := 'DEBUG_SOURCE_OTHER' else
        Result := $'glDebugSource[{self.val}]';
    end;
    
  end;
  
  glDebugType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DONT_CARE:                      glDebugType read new glDebugType($1100);
    public static property DEBUG_TYPE_ERROR:               glDebugType read new glDebugType($824C);
    public static property DEBUG_TYPE_DEPRECATED_BEHAVIOR: glDebugType read new glDebugType($824D);
    public static property DEBUG_TYPE_UNDEFINED_BEHAVIOR:  glDebugType read new glDebugType($824E);
    public static property DEBUG_TYPE_PORTABILITY:         glDebugType read new glDebugType($824F);
    public static property DEBUG_TYPE_PERFORMANCE:         glDebugType read new glDebugType($8250);
    public static property DEBUG_TYPE_OTHER:               glDebugType read new glDebugType($8251);
    public static property DEBUG_TYPE_MARKER:              glDebugType read new glDebugType($8268);
    public static property DEBUG_TYPE_PUSH_GROUP:          glDebugType read new glDebugType($8269);
    public static property DEBUG_TYPE_POP_GROUP:           glDebugType read new glDebugType($826A);
    
    public function ToString: string; override;
    begin
      if DONT_CARE = self then
        Result := 'DONT_CARE' else
      if DEBUG_TYPE_ERROR = self then
        Result := 'DEBUG_TYPE_ERROR' else
      if DEBUG_TYPE_DEPRECATED_BEHAVIOR = self then
        Result := 'DEBUG_TYPE_DEPRECATED_BEHAVIOR' else
      if DEBUG_TYPE_UNDEFINED_BEHAVIOR = self then
        Result := 'DEBUG_TYPE_UNDEFINED_BEHAVIOR' else
      if DEBUG_TYPE_PORTABILITY = self then
        Result := 'DEBUG_TYPE_PORTABILITY' else
      if DEBUG_TYPE_PERFORMANCE = self then
        Result := 'DEBUG_TYPE_PERFORMANCE' else
      if DEBUG_TYPE_OTHER = self then
        Result := 'DEBUG_TYPE_OTHER' else
      if DEBUG_TYPE_MARKER = self then
        Result := 'DEBUG_TYPE_MARKER' else
      if DEBUG_TYPE_PUSH_GROUP = self then
        Result := 'DEBUG_TYPE_PUSH_GROUP' else
      if DEBUG_TYPE_POP_GROUP = self then
        Result := 'DEBUG_TYPE_POP_GROUP' else
        Result := $'glDebugType[{self.val}]';
    end;
    
  end;
  
  glDepthFunction = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEVER:    glDepthFunction read new glDepthFunction($0200);
    public static property LESS:     glDepthFunction read new glDepthFunction($0201);
    public static property EQUAL:    glDepthFunction read new glDepthFunction($0202);
    public static property LEQUAL:   glDepthFunction read new glDepthFunction($0203);
    public static property GREATER:  glDepthFunction read new glDepthFunction($0204);
    public static property NOTEQUAL: glDepthFunction read new glDepthFunction($0205);
    public static property GEQUAL:   glDepthFunction read new glDepthFunction($0206);
    public static property ALWAYS:   glDepthFunction read new glDepthFunction($0207);
    
    public function ToString: string; override;
    begin
      if NEVER = self then
        Result := 'NEVER' else
      if LESS = self then
        Result := 'LESS' else
      if EQUAL = self then
        Result := 'EQUAL' else
      if LEQUAL = self then
        Result := 'LEQUAL' else
      if GREATER = self then
        Result := 'GREATER' else
      if NOTEQUAL = self then
        Result := 'NOTEQUAL' else
      if GEQUAL = self then
        Result := 'GEQUAL' else
      if ALWAYS = self then
        Result := 'ALWAYS' else
        Result := $'glDepthFunction[{self.val}]';
    end;
    
  end;
  
  glDepthStencilTextureMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property STENCIL_INDEX:   glDepthStencilTextureMode read new glDepthStencilTextureMode($1901);
    public static property DEPTH_COMPONENT: glDepthStencilTextureMode read new glDepthStencilTextureMode($1902);
    
    public function ToString: string; override;
    begin
      if STENCIL_INDEX = self then
        Result := 'STENCIL_INDEX' else
      if DEPTH_COMPONENT = self then
        Result := 'DEPTH_COMPONENT' else
        Result := $'glDepthStencilTextureMode[{self.val}]';
    end;
    
  end;
  
  glDrawBufferMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:               glDrawBufferMode read new glDrawBufferMode(0);
    public static property FRONT_LEFT:         glDrawBufferMode read new glDrawBufferMode($0400);
    public static property FRONT_RIGHT:        glDrawBufferMode read new glDrawBufferMode($0401);
    public static property BACK_LEFT:          glDrawBufferMode read new glDrawBufferMode($0402);
    public static property BACK_RIGHT:         glDrawBufferMode read new glDrawBufferMode($0403);
    public static property FRONT:              glDrawBufferMode read new glDrawBufferMode($0404);
    public static property BACK:               glDrawBufferMode read new glDrawBufferMode($0405);
    public static property LEFT:               glDrawBufferMode read new glDrawBufferMode($0406);
    public static property RIGHT:              glDrawBufferMode read new glDrawBufferMode($0407);
    public static property FRONT_AND_BACK:     glDrawBufferMode read new glDrawBufferMode($0408);
    public static property AUX0:               glDrawBufferMode read new glDrawBufferMode($0409);
    public static property AUX1:               glDrawBufferMode read new glDrawBufferMode($040A);
    public static property AUX2:               glDrawBufferMode read new glDrawBufferMode($040B);
    public static property AUX3:               glDrawBufferMode read new glDrawBufferMode($040C);
    public static property COLOR_ATTACHMENT0:  glDrawBufferMode read new glDrawBufferMode($8CE0);
    public static property COLOR_ATTACHMENT1:  glDrawBufferMode read new glDrawBufferMode($8CE1);
    public static property COLOR_ATTACHMENT2:  glDrawBufferMode read new glDrawBufferMode($8CE2);
    public static property COLOR_ATTACHMENT3:  glDrawBufferMode read new glDrawBufferMode($8CE3);
    public static property COLOR_ATTACHMENT4:  glDrawBufferMode read new glDrawBufferMode($8CE4);
    public static property COLOR_ATTACHMENT5:  glDrawBufferMode read new glDrawBufferMode($8CE5);
    public static property COLOR_ATTACHMENT6:  glDrawBufferMode read new glDrawBufferMode($8CE6);
    public static property COLOR_ATTACHMENT7:  glDrawBufferMode read new glDrawBufferMode($8CE7);
    public static property COLOR_ATTACHMENT8:  glDrawBufferMode read new glDrawBufferMode($8CE8);
    public static property COLOR_ATTACHMENT9:  glDrawBufferMode read new glDrawBufferMode($8CE9);
    public static property COLOR_ATTACHMENT10: glDrawBufferMode read new glDrawBufferMode($8CEA);
    public static property COLOR_ATTACHMENT11: glDrawBufferMode read new glDrawBufferMode($8CEB);
    public static property COLOR_ATTACHMENT12: glDrawBufferMode read new glDrawBufferMode($8CEC);
    public static property COLOR_ATTACHMENT13: glDrawBufferMode read new glDrawBufferMode($8CED);
    public static property COLOR_ATTACHMENT14: glDrawBufferMode read new glDrawBufferMode($8CEE);
    public static property COLOR_ATTACHMENT15: glDrawBufferMode read new glDrawBufferMode($8CEF);
    public static property COLOR_ATTACHMENT16: glDrawBufferMode read new glDrawBufferMode($8CF0);
    public static property COLOR_ATTACHMENT17: glDrawBufferMode read new glDrawBufferMode($8CF1);
    public static property COLOR_ATTACHMENT18: glDrawBufferMode read new glDrawBufferMode($8CF2);
    public static property COLOR_ATTACHMENT19: glDrawBufferMode read new glDrawBufferMode($8CF3);
    public static property COLOR_ATTACHMENT20: glDrawBufferMode read new glDrawBufferMode($8CF4);
    public static property COLOR_ATTACHMENT21: glDrawBufferMode read new glDrawBufferMode($8CF5);
    public static property COLOR_ATTACHMENT22: glDrawBufferMode read new glDrawBufferMode($8CF6);
    public static property COLOR_ATTACHMENT23: glDrawBufferMode read new glDrawBufferMode($8CF7);
    public static property COLOR_ATTACHMENT24: glDrawBufferMode read new glDrawBufferMode($8CF8);
    public static property COLOR_ATTACHMENT25: glDrawBufferMode read new glDrawBufferMode($8CF9);
    public static property COLOR_ATTACHMENT26: glDrawBufferMode read new glDrawBufferMode($8CFA);
    public static property COLOR_ATTACHMENT27: glDrawBufferMode read new glDrawBufferMode($8CFB);
    public static property COLOR_ATTACHMENT28: glDrawBufferMode read new glDrawBufferMode($8CFC);
    public static property COLOR_ATTACHMENT29: glDrawBufferMode read new glDrawBufferMode($8CFD);
    public static property COLOR_ATTACHMENT30: glDrawBufferMode read new glDrawBufferMode($8CFE);
    public static property COLOR_ATTACHMENT31: glDrawBufferMode read new glDrawBufferMode($8CFF);
    
    public function ToString: string; override;
    begin
      if NONE = self then
        Result := 'NONE' else
      if FRONT_LEFT = self then
        Result := 'FRONT_LEFT' else
      if FRONT_RIGHT = self then
        Result := 'FRONT_RIGHT' else
      if BACK_LEFT = self then
        Result := 'BACK_LEFT' else
      if BACK_RIGHT = self then
        Result := 'BACK_RIGHT' else
      if FRONT = self then
        Result := 'FRONT' else
      if BACK = self then
        Result := 'BACK' else
      if LEFT = self then
        Result := 'LEFT' else
      if RIGHT = self then
        Result := 'RIGHT' else
      if FRONT_AND_BACK = self then
        Result := 'FRONT_AND_BACK' else
      if AUX0 = self then
        Result := 'AUX0' else
      if AUX1 = self then
        Result := 'AUX1' else
      if AUX2 = self then
        Result := 'AUX2' else
      if AUX3 = self then
        Result := 'AUX3' else
      if COLOR_ATTACHMENT0 = self then
        Result := 'COLOR_ATTACHMENT0' else
      if COLOR_ATTACHMENT1 = self then
        Result := 'COLOR_ATTACHMENT1' else
      if COLOR_ATTACHMENT2 = self then
        Result := 'COLOR_ATTACHMENT2' else
      if COLOR_ATTACHMENT3 = self then
        Result := 'COLOR_ATTACHMENT3' else
      if COLOR_ATTACHMENT4 = self then
        Result := 'COLOR_ATTACHMENT4' else
      if COLOR_ATTACHMENT5 = self then
        Result := 'COLOR_ATTACHMENT5' else
      if COLOR_ATTACHMENT6 = self then
        Result := 'COLOR_ATTACHMENT6' else
      if COLOR_ATTACHMENT7 = self then
        Result := 'COLOR_ATTACHMENT7' else
      if COLOR_ATTACHMENT8 = self then
        Result := 'COLOR_ATTACHMENT8' else
      if COLOR_ATTACHMENT9 = self then
        Result := 'COLOR_ATTACHMENT9' else
      if COLOR_ATTACHMENT10 = self then
        Result := 'COLOR_ATTACHMENT10' else
      if COLOR_ATTACHMENT11 = self then
        Result := 'COLOR_ATTACHMENT11' else
      if COLOR_ATTACHMENT12 = self then
        Result := 'COLOR_ATTACHMENT12' else
      if COLOR_ATTACHMENT13 = self then
        Result := 'COLOR_ATTACHMENT13' else
      if COLOR_ATTACHMENT14 = self then
        Result := 'COLOR_ATTACHMENT14' else
      if COLOR_ATTACHMENT15 = self then
        Result := 'COLOR_ATTACHMENT15' else
      if COLOR_ATTACHMENT16 = self then
        Result := 'COLOR_ATTACHMENT16' else
      if COLOR_ATTACHMENT17 = self then
        Result := 'COLOR_ATTACHMENT17' else
      if COLOR_ATTACHMENT18 = self then
        Result := 'COLOR_ATTACHMENT18' else
      if COLOR_ATTACHMENT19 = self then
        Result := 'COLOR_ATTACHMENT19' else
      if COLOR_ATTACHMENT20 = self then
        Result := 'COLOR_ATTACHMENT20' else
      if COLOR_ATTACHMENT21 = self then
        Result := 'COLOR_ATTACHMENT21' else
      if COLOR_ATTACHMENT22 = self then
        Result := 'COLOR_ATTACHMENT22' else
      if COLOR_ATTACHMENT23 = self then
        Result := 'COLOR_ATTACHMENT23' else
      if COLOR_ATTACHMENT24 = self then
        Result := 'COLOR_ATTACHMENT24' else
      if COLOR_ATTACHMENT25 = self then
        Result := 'COLOR_ATTACHMENT25' else
      if COLOR_ATTACHMENT26 = self then
        Result := 'COLOR_ATTACHMENT26' else
      if COLOR_ATTACHMENT27 = self then
        Result := 'COLOR_ATTACHMENT27' else
      if COLOR_ATTACHMENT28 = self then
        Result := 'COLOR_ATTACHMENT28' else
      if COLOR_ATTACHMENT29 = self then
        Result := 'COLOR_ATTACHMENT29' else
      if COLOR_ATTACHMENT30 = self then
        Result := 'COLOR_ATTACHMENT30' else
      if COLOR_ATTACHMENT31 = self then
        Result := 'COLOR_ATTACHMENT31' else
        Result := $'glDrawBufferMode[{self.val}]';
    end;
    
  end;
  
  glDrawElementsType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNSIGNED_BYTE:  glDrawElementsType read new glDrawElementsType($1401);
    public static property UNSIGNED_SHORT: glDrawElementsType read new glDrawElementsType($1403);
    public static property UNSIGNED_INT:   glDrawElementsType read new glDrawElementsType($1405);
    
    public function ToString: string; override;
    begin
      if UNSIGNED_BYTE = self then
        Result := 'UNSIGNED_BYTE' else
      if UNSIGNED_SHORT = self then
        Result := 'UNSIGNED_SHORT' else
      if UNSIGNED_INT = self then
        Result := 'UNSIGNED_INT' else
        Result := $'glDrawElementsType[{self.val}]';
    end;
    
  end;
  
  glElementPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNSIGNED_BYTE:  glElementPointerType read new glElementPointerType($1401);
    public static property UNSIGNED_SHORT: glElementPointerType read new glElementPointerType($1403);
    public static property UNSIGNED_INT:   glElementPointerType read new glElementPointerType($1405);
    
    public function ToString: string; override;
    begin
      if UNSIGNED_BYTE = self then
        Result := 'UNSIGNED_BYTE' else
      if UNSIGNED_SHORT = self then
        Result := 'UNSIGNED_SHORT' else
      if UNSIGNED_INT = self then
        Result := 'UNSIGNED_INT' else
        Result := $'glElementPointerType[{self.val}]';
    end;
    
  end;
  
  glEnableCap = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINT_SMOOTH:                       glEnableCap read new glEnableCap($0B10);
    public static property LINE_SMOOTH:                        glEnableCap read new glEnableCap($0B20);
    public static property LINE_STIPPLE:                       glEnableCap read new glEnableCap($0B24);
    public static property POLYGON_SMOOTH:                     glEnableCap read new glEnableCap($0B41);
    public static property POLYGON_STIPPLE:                    glEnableCap read new glEnableCap($0B42);
    public static property CULL_FACE:                          glEnableCap read new glEnableCap($0B44);
    public static property LIGHTING:                           glEnableCap read new glEnableCap($0B50);
    public static property COLOR_MATERIAL:                     glEnableCap read new glEnableCap($0B57);
    public static property FOG:                                glEnableCap read new glEnableCap($0B60);
    public static property DEPTH_TEST:                         glEnableCap read new glEnableCap($0B71);
    public static property STENCIL_TEST:                       glEnableCap read new glEnableCap($0B90);
    public static property NORMALIZE:                          glEnableCap read new glEnableCap($0BA1);
    public static property ALPHA_TEST:                         glEnableCap read new glEnableCap($0BC0);
    public static property DITHER:                             glEnableCap read new glEnableCap($0BD0);
    public static property BLEND:                              glEnableCap read new glEnableCap($0BE2);
    public static property INDEX_LOGIC_OP:                     glEnableCap read new glEnableCap($0BF1);
    public static property COLOR_LOGIC_OP:                     glEnableCap read new glEnableCap($0BF2);
    public static property SCISSOR_TEST:                       glEnableCap read new glEnableCap($0C11);
    public static property TEXTURE_GEN_S:                      glEnableCap read new glEnableCap($0C60);
    public static property TEXTURE_GEN_T:                      glEnableCap read new glEnableCap($0C61);
    public static property TEXTURE_GEN_R:                      glEnableCap read new glEnableCap($0C62);
    public static property TEXTURE_GEN_Q:                      glEnableCap read new glEnableCap($0C63);
    public static property AUTO_NORMAL:                        glEnableCap read new glEnableCap($0D80);
    public static property MAP1_COLOR_4:                       glEnableCap read new glEnableCap($0D90);
    public static property MAP1_INDEX:                         glEnableCap read new glEnableCap($0D91);
    public static property MAP1_NORMAL:                        glEnableCap read new glEnableCap($0D92);
    public static property MAP1_TEXTURE_COORD_1:               glEnableCap read new glEnableCap($0D93);
    public static property MAP1_TEXTURE_COORD_2:               glEnableCap read new glEnableCap($0D94);
    public static property MAP1_TEXTURE_COORD_3:               glEnableCap read new glEnableCap($0D95);
    public static property MAP1_TEXTURE_COORD_4:               glEnableCap read new glEnableCap($0D96);
    public static property MAP1_VERTEX_3:                      glEnableCap read new glEnableCap($0D97);
    public static property MAP1_VERTEX_4:                      glEnableCap read new glEnableCap($0D98);
    public static property MAP2_COLOR_4:                       glEnableCap read new glEnableCap($0DB0);
    public static property MAP2_INDEX:                         glEnableCap read new glEnableCap($0DB1);
    public static property MAP2_NORMAL:                        glEnableCap read new glEnableCap($0DB2);
    public static property MAP2_TEXTURE_COORD_1:               glEnableCap read new glEnableCap($0DB3);
    public static property MAP2_TEXTURE_COORD_2:               glEnableCap read new glEnableCap($0DB4);
    public static property MAP2_TEXTURE_COORD_3:               glEnableCap read new glEnableCap($0DB5);
    public static property MAP2_TEXTURE_COORD_4:               glEnableCap read new glEnableCap($0DB6);
    public static property MAP2_VERTEX_3:                      glEnableCap read new glEnableCap($0DB7);
    public static property MAP2_VERTEX_4:                      glEnableCap read new glEnableCap($0DB8);
    public static property TEXTURE_1D:                         glEnableCap read new glEnableCap($0DE0);
    public static property TEXTURE_2D:                         glEnableCap read new glEnableCap($0DE1);
    public static property POLYGON_OFFSET_POINT:               glEnableCap read new glEnableCap($2A01);
    public static property POLYGON_OFFSET_LINE:                glEnableCap read new glEnableCap($2A02);
    public static property CLIP_PLANE0:                        glEnableCap read new glEnableCap($3000);
    public static property CLIP_DISTANCE0:                     glEnableCap read new glEnableCap($3000);
    public static property CLIP_PLANE1:                        glEnableCap read new glEnableCap($3001);
    public static property CLIP_DISTANCE1:                     glEnableCap read new glEnableCap($3001);
    public static property CLIP_PLANE2:                        glEnableCap read new glEnableCap($3002);
    public static property CLIP_DISTANCE2:                     glEnableCap read new glEnableCap($3002);
    public static property CLIP_PLANE3:                        glEnableCap read new glEnableCap($3003);
    public static property CLIP_DISTANCE3:                     glEnableCap read new glEnableCap($3003);
    public static property CLIP_PLANE4:                        glEnableCap read new glEnableCap($3004);
    public static property CLIP_DISTANCE4:                     glEnableCap read new glEnableCap($3004);
    public static property CLIP_PLANE5:                        glEnableCap read new glEnableCap($3005);
    public static property CLIP_DISTANCE5:                     glEnableCap read new glEnableCap($3005);
    public static property CLIP_DISTANCE6:                     glEnableCap read new glEnableCap($3006);
    public static property CLIP_DISTANCE7:                     glEnableCap read new glEnableCap($3007);
    public static property LIGHT0:                             glEnableCap read new glEnableCap($4000);
    public static property LIGHT1:                             glEnableCap read new glEnableCap($4001);
    public static property LIGHT2:                             glEnableCap read new glEnableCap($4002);
    public static property LIGHT3:                             glEnableCap read new glEnableCap($4003);
    public static property LIGHT4:                             glEnableCap read new glEnableCap($4004);
    public static property LIGHT5:                             glEnableCap read new glEnableCap($4005);
    public static property LIGHT6:                             glEnableCap read new glEnableCap($4006);
    public static property LIGHT7:                             glEnableCap read new glEnableCap($4007);
    public static property CONVOLUTION_1D:                     glEnableCap read new glEnableCap($8010);
    public static property CONVOLUTION_2D:                     glEnableCap read new glEnableCap($8011);
    public static property SEPARABLE_2D:                       glEnableCap read new glEnableCap($8012);
    public static property HISTOGRAM:                          glEnableCap read new glEnableCap($8024);
    public static property MINMAX:                             glEnableCap read new glEnableCap($802E);
    public static property POLYGON_OFFSET_FILL:                glEnableCap read new glEnableCap($8037);
    public static property RESCALE_NORMAL:                     glEnableCap read new glEnableCap($803A);
    public static property TEXTURE_3D:                         glEnableCap read new glEnableCap($806F);
    public static property VERTEX_ARRAY:                       glEnableCap read new glEnableCap($8074);
    public static property NORMAL_ARRAY:                       glEnableCap read new glEnableCap($8075);
    public static property COLOR_ARRAY:                        glEnableCap read new glEnableCap($8076);
    public static property INDEX_ARRAY:                        glEnableCap read new glEnableCap($8077);
    public static property TEXTURE_COORD_ARRAY:                glEnableCap read new glEnableCap($8078);
    public static property EDGE_FLAG_ARRAY:                    glEnableCap read new glEnableCap($8079);
    public static property INTERLACE_SGIX:                     glEnableCap read new glEnableCap($8094);
    public static property MULTISAMPLE:                        glEnableCap read new glEnableCap($809D);
    public static property SAMPLE_ALPHA_TO_COVERAGE:           glEnableCap read new glEnableCap($809E);
    public static property SAMPLE_ALPHA_TO_MASK:               glEnableCap read new glEnableCap($809E);
    public static property SAMPLE_ALPHA_TO_ONE:                glEnableCap read new glEnableCap($809F);
    public static property SAMPLE_COVERAGE:                    glEnableCap read new glEnableCap($80A0);
    public static property SAMPLE_MASK_SGIS:                   glEnableCap read new glEnableCap($80A0);
    public static property TEXTURE_COLOR_TABLE:                glEnableCap read new glEnableCap($80BC);
    public static property COLOR_TABLE:                        glEnableCap read new glEnableCap($80D0);
    public static property POST_CONVOLUTION_COLOR_TABLE:       glEnableCap read new glEnableCap($80D1);
    public static property POST_COLOR_MATRIX_COLOR_TABLE:      glEnableCap read new glEnableCap($80D2);
    public static property TEXTURE_4D:                         glEnableCap read new glEnableCap($8134);
    public static property PIXEL_TEX_GEN:                      glEnableCap read new glEnableCap($8139);
    public static property SPRITE:                             glEnableCap read new glEnableCap($8148);
    public static property REFERENCE_PLANE:                    glEnableCap read new glEnableCap($817D);
    public static property IR_INSTRUMENT1:                     glEnableCap read new glEnableCap($817F);
    public static property CALLIGRAPHIC_FRAGMENT:              glEnableCap read new glEnableCap($8183);
    public static property FRAMEZOOM:                          glEnableCap read new glEnableCap($818B);
    public static property FOG_OFFSET:                         glEnableCap read new glEnableCap($8198);
    public static property SHARED_TEXTURE_PALETTE:             glEnableCap read new glEnableCap($81FB);
    public static property DEBUG_OUTPUT_SYNCHRONOUS:           glEnableCap read new glEnableCap($8242);
    public static property ASYNC_HISTOGRAM:                    glEnableCap read new glEnableCap($832C);
    public static property PIXEL_TEXTURE:                      glEnableCap read new glEnableCap($8353);
    public static property ASYNC_TEX_IMAGE:                    glEnableCap read new glEnableCap($835C);
    public static property ASYNC_DRAW_PIXELS:                  glEnableCap read new glEnableCap($835D);
    public static property ASYNC_READ_PIXELS:                  glEnableCap read new glEnableCap($835E);
    public static property FRAGMENT_LIGHTING:                  glEnableCap read new glEnableCap($8400);
    public static property FRAGMENT_COLOR_MATERIAL:            glEnableCap read new glEnableCap($8401);
    public static property FRAGMENT_LIGHT0:                    glEnableCap read new glEnableCap($840C);
    public static property FRAGMENT_LIGHT1:                    glEnableCap read new glEnableCap($840D);
    public static property FRAGMENT_LIGHT2:                    glEnableCap read new glEnableCap($840E);
    public static property FRAGMENT_LIGHT3:                    glEnableCap read new glEnableCap($840F);
    public static property FRAGMENT_LIGHT4:                    glEnableCap read new glEnableCap($8410);
    public static property FRAGMENT_LIGHT5:                    glEnableCap read new glEnableCap($8411);
    public static property FRAGMENT_LIGHT6:                    glEnableCap read new glEnableCap($8412);
    public static property FRAGMENT_LIGHT7:                    glEnableCap read new glEnableCap($8413);
    public static property TEXTURE_RECTANGLE:                  glEnableCap read new glEnableCap($84F5);
    public static property TEXTURE_CUBE_MAP:                   glEnableCap read new glEnableCap($8513);
    public static property PROGRAM_POINT_SIZE:                 glEnableCap read new glEnableCap($8642);
    public static property DEPTH_CLAMP:                        glEnableCap read new glEnableCap($864F);
    public static property TEXTURE_CUBE_MAP_SEAMLESS:          glEnableCap read new glEnableCap($884F);
    public static property SAMPLE_SHADING:                     glEnableCap read new glEnableCap($8C36);
    public static property RASTERIZER_DISCARD:                 glEnableCap read new glEnableCap($8C89);
    public static property TEXTURE_GEN_STR:                    glEnableCap read new glEnableCap($8D60);
    public static property PRIMITIVE_RESTART_FIXED_INDEX:      glEnableCap read new glEnableCap($8D69);
    public static property FRAMEBUFFER_SRGB:                   glEnableCap read new glEnableCap($8DB9);
    public static property SAMPLE_MASK:                        glEnableCap read new glEnableCap($8E51);
    public static property FETCH_PER_SAMPLE:                   glEnableCap read new glEnableCap($8F65);
    public static property PRIMITIVE_RESTART:                  glEnableCap read new glEnableCap($8F9D);
    public static property DEBUG_OUTPUT:                       glEnableCap read new glEnableCap($92E0);
    public static property SHADING_RATE_IMAGE_PER_PRIMITIVE:   glEnableCap read new glEnableCap($95B1);
    public static property FRAMEBUFFER_FETCH_NONCOHERENT:      glEnableCap read new glEnableCap($96A2);
    public static property SHADING_RATE_PRESERVE_ASPECT_RATIO: glEnableCap read new glEnableCap($96A5);
    
    public function ToString: string; override;
    begin
      if POINT_SMOOTH = self then
        Result := 'POINT_SMOOTH' else
      if LINE_SMOOTH = self then
        Result := 'LINE_SMOOTH' else
      if LINE_STIPPLE = self then
        Result := 'LINE_STIPPLE' else
      if POLYGON_SMOOTH = self then
        Result := 'POLYGON_SMOOTH' else
      if POLYGON_STIPPLE = self then
        Result := 'POLYGON_STIPPLE' else
      if CULL_FACE = self then
        Result := 'CULL_FACE' else
      if LIGHTING = self then
        Result := 'LIGHTING' else
      if COLOR_MATERIAL = self then
        Result := 'COLOR_MATERIAL' else
      if FOG = self then
        Result := 'FOG' else
      if DEPTH_TEST = self then
        Result := 'DEPTH_TEST' else
      if STENCIL_TEST = self then
        Result := 'STENCIL_TEST' else
      if NORMALIZE = self then
        Result := 'NORMALIZE' else
      if ALPHA_TEST = self then
        Result := 'ALPHA_TEST' else
      if DITHER = self then
        Result := 'DITHER' else
      if BLEND = self then
        Result := 'BLEND' else
      if INDEX_LOGIC_OP = self then
        Result := 'INDEX_LOGIC_OP' else
      if COLOR_LOGIC_OP = self then
        Result := 'COLOR_LOGIC_OP' else
      if SCISSOR_TEST = self then
        Result := 'SCISSOR_TEST' else
      if TEXTURE_GEN_S = self then
        Result := 'TEXTURE_GEN_S' else
      if TEXTURE_GEN_T = self then
        Result := 'TEXTURE_GEN_T' else
      if TEXTURE_GEN_R = self then
        Result := 'TEXTURE_GEN_R' else
      if TEXTURE_GEN_Q = self then
        Result := 'TEXTURE_GEN_Q' else
      if AUTO_NORMAL = self then
        Result := 'AUTO_NORMAL' else
      if MAP1_COLOR_4 = self then
        Result := 'MAP1_COLOR_4' else
      if MAP1_INDEX = self then
        Result := 'MAP1_INDEX' else
      if MAP1_NORMAL = self then
        Result := 'MAP1_NORMAL' else
      if MAP1_TEXTURE_COORD_1 = self then
        Result := 'MAP1_TEXTURE_COORD_1' else
      if MAP1_TEXTURE_COORD_2 = self then
        Result := 'MAP1_TEXTURE_COORD_2' else
      if MAP1_TEXTURE_COORD_3 = self then
        Result := 'MAP1_TEXTURE_COORD_3' else
      if MAP1_TEXTURE_COORD_4 = self then
        Result := 'MAP1_TEXTURE_COORD_4' else
      if MAP1_VERTEX_3 = self then
        Result := 'MAP1_VERTEX_3' else
      if MAP1_VERTEX_4 = self then
        Result := 'MAP1_VERTEX_4' else
      if MAP2_COLOR_4 = self then
        Result := 'MAP2_COLOR_4' else
      if MAP2_INDEX = self then
        Result := 'MAP2_INDEX' else
      if MAP2_NORMAL = self then
        Result := 'MAP2_NORMAL' else
      if MAP2_TEXTURE_COORD_1 = self then
        Result := 'MAP2_TEXTURE_COORD_1' else
      if MAP2_TEXTURE_COORD_2 = self then
        Result := 'MAP2_TEXTURE_COORD_2' else
      if MAP2_TEXTURE_COORD_3 = self then
        Result := 'MAP2_TEXTURE_COORD_3' else
      if MAP2_TEXTURE_COORD_4 = self then
        Result := 'MAP2_TEXTURE_COORD_4' else
      if MAP2_VERTEX_3 = self then
        Result := 'MAP2_VERTEX_3' else
      if MAP2_VERTEX_4 = self then
        Result := 'MAP2_VERTEX_4' else
      if TEXTURE_1D = self then
        Result := 'TEXTURE_1D' else
      if TEXTURE_2D = self then
        Result := 'TEXTURE_2D' else
      if POLYGON_OFFSET_POINT = self then
        Result := 'POLYGON_OFFSET_POINT' else
      if POLYGON_OFFSET_LINE = self then
        Result := 'POLYGON_OFFSET_LINE' else
      if CLIP_PLANE0 = self then
        Result := 'CLIP_PLANE0' else
      if CLIP_DISTANCE0 = self then
        Result := 'CLIP_DISTANCE0' else
      if CLIP_PLANE1 = self then
        Result := 'CLIP_PLANE1' else
      if CLIP_DISTANCE1 = self then
        Result := 'CLIP_DISTANCE1' else
      if CLIP_PLANE2 = self then
        Result := 'CLIP_PLANE2' else
      if CLIP_DISTANCE2 = self then
        Result := 'CLIP_DISTANCE2' else
      if CLIP_PLANE3 = self then
        Result := 'CLIP_PLANE3' else
      if CLIP_DISTANCE3 = self then
        Result := 'CLIP_DISTANCE3' else
      if CLIP_PLANE4 = self then
        Result := 'CLIP_PLANE4' else
      if CLIP_DISTANCE4 = self then
        Result := 'CLIP_DISTANCE4' else
      if CLIP_PLANE5 = self then
        Result := 'CLIP_PLANE5' else
      if CLIP_DISTANCE5 = self then
        Result := 'CLIP_DISTANCE5' else
      if CLIP_DISTANCE6 = self then
        Result := 'CLIP_DISTANCE6' else
      if CLIP_DISTANCE7 = self then
        Result := 'CLIP_DISTANCE7' else
      if LIGHT0 = self then
        Result := 'LIGHT0' else
      if LIGHT1 = self then
        Result := 'LIGHT1' else
      if LIGHT2 = self then
        Result := 'LIGHT2' else
      if LIGHT3 = self then
        Result := 'LIGHT3' else
      if LIGHT4 = self then
        Result := 'LIGHT4' else
      if LIGHT5 = self then
        Result := 'LIGHT5' else
      if LIGHT6 = self then
        Result := 'LIGHT6' else
      if LIGHT7 = self then
        Result := 'LIGHT7' else
      if CONVOLUTION_1D = self then
        Result := 'CONVOLUTION_1D' else
      if CONVOLUTION_2D = self then
        Result := 'CONVOLUTION_2D' else
      if SEPARABLE_2D = self then
        Result := 'SEPARABLE_2D' else
      if HISTOGRAM = self then
        Result := 'HISTOGRAM' else
      if MINMAX = self then
        Result := 'MINMAX' else
      if POLYGON_OFFSET_FILL = self then
        Result := 'POLYGON_OFFSET_FILL' else
      if RESCALE_NORMAL = self then
        Result := 'RESCALE_NORMAL' else
      if TEXTURE_3D = self then
        Result := 'TEXTURE_3D' else
      if VERTEX_ARRAY = self then
        Result := 'VERTEX_ARRAY' else
      if NORMAL_ARRAY = self then
        Result := 'NORMAL_ARRAY' else
      if COLOR_ARRAY = self then
        Result := 'COLOR_ARRAY' else
      if INDEX_ARRAY = self then
        Result := 'INDEX_ARRAY' else
      if TEXTURE_COORD_ARRAY = self then
        Result := 'TEXTURE_COORD_ARRAY' else
      if EDGE_FLAG_ARRAY = self then
        Result := 'EDGE_FLAG_ARRAY' else
      if INTERLACE_SGIX = self then
        Result := 'INTERLACE_SGIX' else
      if MULTISAMPLE = self then
        Result := 'MULTISAMPLE' else
      if SAMPLE_ALPHA_TO_COVERAGE = self then
        Result := 'SAMPLE_ALPHA_TO_COVERAGE' else
      if SAMPLE_ALPHA_TO_MASK = self then
        Result := 'SAMPLE_ALPHA_TO_MASK' else
      if SAMPLE_ALPHA_TO_ONE = self then
        Result := 'SAMPLE_ALPHA_TO_ONE' else
      if SAMPLE_COVERAGE = self then
        Result := 'SAMPLE_COVERAGE' else
      if SAMPLE_MASK_SGIS = self then
        Result := 'SAMPLE_MASK_SGIS' else
      if TEXTURE_COLOR_TABLE = self then
        Result := 'TEXTURE_COLOR_TABLE' else
      if COLOR_TABLE = self then
        Result := 'COLOR_TABLE' else
      if POST_CONVOLUTION_COLOR_TABLE = self then
        Result := 'POST_CONVOLUTION_COLOR_TABLE' else
      if POST_COLOR_MATRIX_COLOR_TABLE = self then
        Result := 'POST_COLOR_MATRIX_COLOR_TABLE' else
      if TEXTURE_4D = self then
        Result := 'TEXTURE_4D' else
      if PIXEL_TEX_GEN = self then
        Result := 'PIXEL_TEX_GEN' else
      if SPRITE = self then
        Result := 'SPRITE' else
      if REFERENCE_PLANE = self then
        Result := 'REFERENCE_PLANE' else
      if IR_INSTRUMENT1 = self then
        Result := 'IR_INSTRUMENT1' else
      if CALLIGRAPHIC_FRAGMENT = self then
        Result := 'CALLIGRAPHIC_FRAGMENT' else
      if FRAMEZOOM = self then
        Result := 'FRAMEZOOM' else
      if FOG_OFFSET = self then
        Result := 'FOG_OFFSET' else
      if SHARED_TEXTURE_PALETTE = self then
        Result := 'SHARED_TEXTURE_PALETTE' else
      if DEBUG_OUTPUT_SYNCHRONOUS = self then
        Result := 'DEBUG_OUTPUT_SYNCHRONOUS' else
      if ASYNC_HISTOGRAM = self then
        Result := 'ASYNC_HISTOGRAM' else
      if PIXEL_TEXTURE = self then
        Result := 'PIXEL_TEXTURE' else
      if ASYNC_TEX_IMAGE = self then
        Result := 'ASYNC_TEX_IMAGE' else
      if ASYNC_DRAW_PIXELS = self then
        Result := 'ASYNC_DRAW_PIXELS' else
      if ASYNC_READ_PIXELS = self then
        Result := 'ASYNC_READ_PIXELS' else
      if FRAGMENT_LIGHTING = self then
        Result := 'FRAGMENT_LIGHTING' else
      if FRAGMENT_COLOR_MATERIAL = self then
        Result := 'FRAGMENT_COLOR_MATERIAL' else
      if FRAGMENT_LIGHT0 = self then
        Result := 'FRAGMENT_LIGHT0' else
      if FRAGMENT_LIGHT1 = self then
        Result := 'FRAGMENT_LIGHT1' else
      if FRAGMENT_LIGHT2 = self then
        Result := 'FRAGMENT_LIGHT2' else
      if FRAGMENT_LIGHT3 = self then
        Result := 'FRAGMENT_LIGHT3' else
      if FRAGMENT_LIGHT4 = self then
        Result := 'FRAGMENT_LIGHT4' else
      if FRAGMENT_LIGHT5 = self then
        Result := 'FRAGMENT_LIGHT5' else
      if FRAGMENT_LIGHT6 = self then
        Result := 'FRAGMENT_LIGHT6' else
      if FRAGMENT_LIGHT7 = self then
        Result := 'FRAGMENT_LIGHT7' else
      if TEXTURE_RECTANGLE = self then
        Result := 'TEXTURE_RECTANGLE' else
      if TEXTURE_CUBE_MAP = self then
        Result := 'TEXTURE_CUBE_MAP' else
      if PROGRAM_POINT_SIZE = self then
        Result := 'PROGRAM_POINT_SIZE' else
      if DEPTH_CLAMP = self then
        Result := 'DEPTH_CLAMP' else
      if TEXTURE_CUBE_MAP_SEAMLESS = self then
        Result := 'TEXTURE_CUBE_MAP_SEAMLESS' else
      if SAMPLE_SHADING = self then
        Result := 'SAMPLE_SHADING' else
      if RASTERIZER_DISCARD = self then
        Result := 'RASTERIZER_DISCARD' else
      if TEXTURE_GEN_STR = self then
        Result := 'TEXTURE_GEN_STR' else
      if PRIMITIVE_RESTART_FIXED_INDEX = self then
        Result := 'PRIMITIVE_RESTART_FIXED_INDEX' else
      if FRAMEBUFFER_SRGB = self then
        Result := 'FRAMEBUFFER_SRGB' else
      if SAMPLE_MASK = self then
        Result := 'SAMPLE_MASK' else
      if FETCH_PER_SAMPLE = self then
        Result := 'FETCH_PER_SAMPLE' else
      if PRIMITIVE_RESTART = self then
        Result := 'PRIMITIVE_RESTART' else
      if DEBUG_OUTPUT = self then
        Result := 'DEBUG_OUTPUT' else
      if SHADING_RATE_IMAGE_PER_PRIMITIVE = self then
        Result := 'SHADING_RATE_IMAGE_PER_PRIMITIVE' else
      if FRAMEBUFFER_FETCH_NONCOHERENT = self then
        Result := 'FRAMEBUFFER_FETCH_NONCOHERENT' else
      if SHADING_RATE_PRESERVE_ASPECT_RATIO = self then
        Result := 'SHADING_RATE_PRESERVE_ASPECT_RATIO' else
        Result := $'glEnableCap[{self.val}]';
    end;
    
  end;
  
  glErrorCode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NO_ERROR:                      glErrorCode read new glErrorCode(0);
    public static property INVALID_ENUM:                  glErrorCode read new glErrorCode($0500);
    public static property INVALID_VALUE:                 glErrorCode read new glErrorCode($0501);
    public static property INVALID_OPERATION:             glErrorCode read new glErrorCode($0502);
    public static property STACK_OVERFLOW:                glErrorCode read new glErrorCode($0503);
    public static property STACK_UNDERFLOW:               glErrorCode read new glErrorCode($0504);
    public static property OUT_OF_MEMORY:                 glErrorCode read new glErrorCode($0505);
    public static property INVALID_FRAMEBUFFER_OPERATION: glErrorCode read new glErrorCode($0506);
    public static property TABLE_TOO_LARGE:               glErrorCode read new glErrorCode($8031);
    public static property TEXTURE_TOO_LARGE:             glErrorCode read new glErrorCode($8065);
    
    public function ToString: string; override;
    begin
      if NO_ERROR = self then
        Result := 'NO_ERROR' else
      if INVALID_ENUM = self then
        Result := 'INVALID_ENUM' else
      if INVALID_VALUE = self then
        Result := 'INVALID_VALUE' else
      if INVALID_OPERATION = self then
        Result := 'INVALID_OPERATION' else
      if STACK_OVERFLOW = self then
        Result := 'STACK_OVERFLOW' else
      if STACK_UNDERFLOW = self then
        Result := 'STACK_UNDERFLOW' else
      if OUT_OF_MEMORY = self then
        Result := 'OUT_OF_MEMORY' else
      if INVALID_FRAMEBUFFER_OPERATION = self then
        Result := 'INVALID_FRAMEBUFFER_OPERATION' else
      if TABLE_TOO_LARGE = self then
        Result := 'TABLE_TOO_LARGE' else
      if TEXTURE_TOO_LARGE = self then
        Result := 'TEXTURE_TOO_LARGE' else
        Result := $'glErrorCode[{self.val}]';
    end;
    
    public function IS_ERROR := val<>0;
    
    public procedure RaiseIfError;
    
  end;
  
  glEvalMapsMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FILL: glEvalMapsMode read new glEvalMapsMode($1B02);
    
    public function ToString: string; override;
    begin
      if FILL = self then
        Result := 'FILL' else
        Result := $'glEvalMapsMode[{self.val}]';
    end;
    
  end;
  
  glEvalTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property EVAL_2D:            glEvalTarget read new glEvalTarget($86C0);
    public static property EVAL_TRIANGULAR_2D: glEvalTarget read new glEvalTarget($86C1);
    
    public function ToString: string; override;
    begin
      if EVAL_2D = self then
        Result := 'EVAL_2D' else
      if EVAL_TRIANGULAR_2D = self then
        Result := 'EVAL_TRIANGULAR_2D' else
        Result := $'glEvalTarget[{self.val}]';
    end;
    
  end;
  
  glExternalHandleType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property HANDLE_TYPE_OPAQUE_FD:        glExternalHandleType read new glExternalHandleType($9586);
    public static property HANDLE_TYPE_OPAQUE_WIN32:     glExternalHandleType read new glExternalHandleType($9587);
    public static property HANDLE_TYPE_OPAQUE_WIN32_KMT: glExternalHandleType read new glExternalHandleType($9588);
    public static property HANDLE_TYPE_D3D12_TILEPOOL:   glExternalHandleType read new glExternalHandleType($9589);
    public static property HANDLE_TYPE_D3D12_RESOURCE:   glExternalHandleType read new glExternalHandleType($958A);
    public static property HANDLE_TYPE_D3D11_IMAGE:      glExternalHandleType read new glExternalHandleType($958B);
    public static property HANDLE_TYPE_D3D11_IMAGE_KMT:  glExternalHandleType read new glExternalHandleType($958C);
    public static property HANDLE_TYPE_D3D12_FENCE:      glExternalHandleType read new glExternalHandleType($9594);
    
    public function ToString: string; override;
    begin
      if HANDLE_TYPE_OPAQUE_FD = self then
        Result := 'HANDLE_TYPE_OPAQUE_FD' else
      if HANDLE_TYPE_OPAQUE_WIN32 = self then
        Result := 'HANDLE_TYPE_OPAQUE_WIN32' else
      if HANDLE_TYPE_OPAQUE_WIN32_KMT = self then
        Result := 'HANDLE_TYPE_OPAQUE_WIN32_KMT' else
      if HANDLE_TYPE_D3D12_TILEPOOL = self then
        Result := 'HANDLE_TYPE_D3D12_TILEPOOL' else
      if HANDLE_TYPE_D3D12_RESOURCE = self then
        Result := 'HANDLE_TYPE_D3D12_RESOURCE' else
      if HANDLE_TYPE_D3D11_IMAGE = self then
        Result := 'HANDLE_TYPE_D3D11_IMAGE' else
      if HANDLE_TYPE_D3D11_IMAGE_KMT = self then
        Result := 'HANDLE_TYPE_D3D11_IMAGE_KMT' else
      if HANDLE_TYPE_D3D12_FENCE = self then
        Result := 'HANDLE_TYPE_D3D12_FENCE' else
        Result := $'glExternalHandleType[{self.val}]';
    end;
    
  end;
  
  glFeedBackToken = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PASS_THROUGH_TOKEN: glFeedBackToken read new glFeedBackToken($0700);
    public static property POINT_TOKEN:        glFeedBackToken read new glFeedBackToken($0701);
    public static property LINE_TOKEN:         glFeedBackToken read new glFeedBackToken($0702);
    public static property POLYGON_TOKEN:      glFeedBackToken read new glFeedBackToken($0703);
    public static property BITMAP_TOKEN:       glFeedBackToken read new glFeedBackToken($0704);
    public static property DRAW_PIXEL_TOKEN:   glFeedBackToken read new glFeedBackToken($0705);
    public static property COPY_PIXEL_TOKEN:   glFeedBackToken read new glFeedBackToken($0706);
    public static property LINE_RESET_TOKEN:   glFeedBackToken read new glFeedBackToken($0707);
    
    public function ToString: string; override;
    begin
      if PASS_THROUGH_TOKEN = self then
        Result := 'PASS_THROUGH_TOKEN' else
      if POINT_TOKEN = self then
        Result := 'POINT_TOKEN' else
      if LINE_TOKEN = self then
        Result := 'LINE_TOKEN' else
      if POLYGON_TOKEN = self then
        Result := 'POLYGON_TOKEN' else
      if BITMAP_TOKEN = self then
        Result := 'BITMAP_TOKEN' else
      if DRAW_PIXEL_TOKEN = self then
        Result := 'DRAW_PIXEL_TOKEN' else
      if COPY_PIXEL_TOKEN = self then
        Result := 'COPY_PIXEL_TOKEN' else
      if LINE_RESET_TOKEN = self then
        Result := 'LINE_RESET_TOKEN' else
        Result := $'glFeedBackToken[{self.val}]';
    end;
    
  end;
  
  glFeedbackType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property _2D:               glFeedbackType read new glFeedbackType($0600);
    public static property _3D:               glFeedbackType read new glFeedbackType($0601);
    public static property _3D_COLOR:         glFeedbackType read new glFeedbackType($0602);
    public static property _3D_COLOR_TEXTURE: glFeedbackType read new glFeedbackType($0603);
    public static property _4D_COLOR_TEXTURE: glFeedbackType read new glFeedbackType($0604);
    
    public function ToString: string; override;
    begin
      if _2D = self then
        Result := '2D' else
      if _3D = self then
        Result := '3D' else
      if _3D_COLOR = self then
        Result := '3D_COLOR' else
      if _3D_COLOR_TEXTURE = self then
        Result := '3D_COLOR_TEXTURE' else
      if _4D_COLOR_TEXTURE = self then
        Result := '4D_COLOR_TEXTURE' else
        Result := $'glFeedbackType[{self.val}]';
    end;
    
  end;
  
  glFenceCondition = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ALL_COMPLETED: glFenceCondition read new glFenceCondition($84F2);
    
    public function ToString: string; override;
    begin
      if ALL_COMPLETED = self then
        Result := 'ALL_COMPLETED' else
        Result := $'glFenceCondition[{self.val}]';
    end;
    
  end;
  
  glFenceParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FENCE_STATUS:    glFenceParameterName read new glFenceParameterName($84F3);
    public static property FENCE_CONDITION: glFenceParameterName read new glFenceParameterName($84F4);
    
    public function ToString: string; override;
    begin
      if FENCE_STATUS = self then
        Result := 'FENCE_STATUS' else
      if FENCE_CONDITION = self then
        Result := 'FENCE_CONDITION' else
        Result := $'glFenceParameterName[{self.val}]';
    end;
    
  end;
  
  glFfdMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_DEFORMATION_BIT:  glFfdMask read new glFfdMask(1 shl 0);
    public static property GEOMETRY_DEFORMATION_BIT: glFfdMask read new glFfdMask(1 shl 1);
    
    public static function operator+(v1, v2: glFfdMask) := new glFfdMask(v1.val or v2.val);
    public static function operator or(v1, v2: glFfdMask) := new glFfdMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glFfdMask; v2: glFfdMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glFfdMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glFfdMask[0]';
        exit;
      end;
      if TEXTURE_DEFORMATION_BIT in self then
      begin
        res += 'TEXTURE_DEFORMATION_BIT+';
        left_val := left_val and not TEXTURE_DEFORMATION_BIT.val;
      end;
      if GEOMETRY_DEFORMATION_BIT in self then
      begin
        res += 'GEOMETRY_DEFORMATION_BIT+';
        left_val := left_val and not GEOMETRY_DEFORMATION_BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'glFfdMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glFfdTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GEOMETRY_DEFORMATION: glFfdTarget read new glFfdTarget($8194);
    public static property TEXTURE_DEFORMATION:  glFfdTarget read new glFfdTarget($8195);
    
    public function ToString: string; override;
    begin
      if GEOMETRY_DEFORMATION = self then
        Result := 'GEOMETRY_DEFORMATION' else
      if TEXTURE_DEFORMATION = self then
        Result := 'TEXTURE_DEFORMATION' else
        Result := $'glFfdTarget[{self.val}]';
    end;
    
  end;
  
  glFogCoordinatePointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FLOAT:  glFogCoordinatePointerType read new glFogCoordinatePointerType($1406);
    public static property DOUBLE: glFogCoordinatePointerType read new glFogCoordinatePointerType($140A);
    
    public function ToString: string; override;
    begin
      if FLOAT = self then
        Result := 'FLOAT' else
      if DOUBLE = self then
        Result := 'DOUBLE' else
        Result := $'glFogCoordinatePointerType[{self.val}]';
    end;
    
  end;
  
  glFogCoordSrc = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FOG_COORDINATE: glFogCoordSrc read new glFogCoordSrc($8451);
    public static property FOG_COORD:      glFogCoordSrc read new glFogCoordSrc($8451);
    public static property FRAGMENT_DEPTH: glFogCoordSrc read new glFogCoordSrc($8452);
    
    public function ToString: string; override;
    begin
      if FOG_COORDINATE = self then
        Result := 'FOG_COORDINATE' else
      if FOG_COORD = self then
        Result := 'FOG_COORD' else
      if FRAGMENT_DEPTH = self then
        Result := 'FRAGMENT_DEPTH' else
        Result := $'glFogCoordSrc[{self.val}]';
    end;
    
  end;
  
  glFogMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property EXP:      glFogMode read new glFogMode($0800);
    public static property EXP2:     glFogMode read new glFogMode($0801);
    public static property LINEAR:   glFogMode read new glFogMode($2601);
    public static property FOG_FUNC: glFogMode read new glFogMode($812A);
    
    public function ToString: string; override;
    begin
      if EXP = self then
        Result := 'EXP' else
      if EXP2 = self then
        Result := 'EXP2' else
      if LINEAR = self then
        Result := 'LINEAR' else
      if FOG_FUNC = self then
        Result := 'FOG_FUNC' else
        Result := $'glFogMode[{self.val}]';
    end;
    
  end;
  
  glFogParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FOG_INDEX:        glFogParameter read new glFogParameter($0B61);
    public static property FOG_DENSITY:      glFogParameter read new glFogParameter($0B62);
    public static property FOG_START:        glFogParameter read new glFogParameter($0B63);
    public static property FOG_END:          glFogParameter read new glFogParameter($0B64);
    public static property FOG_MODE:         glFogParameter read new glFogParameter($0B65);
    public static property FOG_COLOR:        glFogParameter read new glFogParameter($0B66);
    public static property FOG_OFFSET_VALUE: glFogParameter read new glFogParameter($8199);
    
    public function ToString: string; override;
    begin
      if FOG_INDEX = self then
        Result := 'FOG_INDEX' else
      if FOG_DENSITY = self then
        Result := 'FOG_DENSITY' else
      if FOG_START = self then
        Result := 'FOG_START' else
      if FOG_END = self then
        Result := 'FOG_END' else
      if FOG_MODE = self then
        Result := 'FOG_MODE' else
      if FOG_COLOR = self then
        Result := 'FOG_COLOR' else
      if FOG_OFFSET_VALUE = self then
        Result := 'FOG_OFFSET_VALUE' else
        Result := $'glFogParameter[{self.val}]';
    end;
    
  end;
  
  glFogPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FOG_INDEX:     glFogPName read new glFogPName($0B61);
    public static property FOG_DENSITY:   glFogPName read new glFogPName($0B62);
    public static property FOG_START:     glFogPName read new glFogPName($0B63);
    public static property FOG_END:       glFogPName read new glFogPName($0B64);
    public static property FOG_MODE:      glFogPName read new glFogPName($0B65);
    public static property FOG_COORD_SRC: glFogPName read new glFogPName($8450);
    
    public function ToString: string; override;
    begin
      if FOG_INDEX = self then
        Result := 'FOG_INDEX' else
      if FOG_DENSITY = self then
        Result := 'FOG_DENSITY' else
      if FOG_START = self then
        Result := 'FOG_START' else
      if FOG_END = self then
        Result := 'FOG_END' else
      if FOG_MODE = self then
        Result := 'FOG_MODE' else
      if FOG_COORD_SRC = self then
        Result := 'FOG_COORD_SRC' else
        Result := $'glFogPName[{self.val}]';
    end;
    
  end;
  
  glFogPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FLOAT:  glFogPointerType read new glFogPointerType($1406);
    public static property DOUBLE: glFogPointerType read new glFogPointerType($140A);
    
    public function ToString: string; override;
    begin
      if FLOAT = self then
        Result := 'FLOAT' else
      if DOUBLE = self then
        Result := 'DOUBLE' else
        Result := $'glFogPointerType[{self.val}]';
    end;
    
  end;
  
  glFoveationConfigBit = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FOVEATION_ENABLE_BIT:                   glFoveationConfigBit read new glFoveationConfigBit(1 shl 0);
    public static property FOVEATION_SCALED_BIN_METHOD_BIT:        glFoveationConfigBit read new glFoveationConfigBit(1 shl 1);
    public static property FOVEATION_SUBSAMPLED_LAYOUT_METHOD_BIT: glFoveationConfigBit read new glFoveationConfigBit(1 shl 2);
    
    public static function operator+(v1, v2: glFoveationConfigBit) := new glFoveationConfigBit(v1.val or v2.val);
    public static function operator or(v1, v2: glFoveationConfigBit) := new glFoveationConfigBit(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glFoveationConfigBit; v2: glFoveationConfigBit) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glFoveationConfigBit) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glFoveationConfigBit[0]';
        exit;
      end;
      if FOVEATION_ENABLE_BIT in self then
      begin
        res += 'FOVEATION_ENABLE_BIT+';
        left_val := left_val and not FOVEATION_ENABLE_BIT.val;
      end;
      if FOVEATION_SCALED_BIN_METHOD_BIT in self then
      begin
        res += 'FOVEATION_SCALED_BIN_METHOD_BIT+';
        left_val := left_val and not FOVEATION_SCALED_BIN_METHOD_BIT.val;
      end;
      if FOVEATION_SUBSAMPLED_LAYOUT_METHOD_BIT in self then
      begin
        res += 'FOVEATION_SUBSAMPLED_LAYOUT_METHOD_BIT+';
        left_val := left_val and not FOVEATION_SUBSAMPLED_LAYOUT_METHOD_BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'glFoveationConfigBit[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glFragmentLightModelParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER:         glFragmentLightModelParameter read new glFragmentLightModelParameter($8408);
    public static property FRAGMENT_LIGHT_MODEL_TWO_SIDE:             glFragmentLightModelParameter read new glFragmentLightModelParameter($8409);
    public static property FRAGMENT_LIGHT_MODEL_AMBIENT:              glFragmentLightModelParameter read new glFragmentLightModelParameter($840A);
    public static property FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION: glFragmentLightModelParameter read new glFragmentLightModelParameter($840B);
    
    public function ToString: string; override;
    begin
      if FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER = self then
        Result := 'FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER' else
      if FRAGMENT_LIGHT_MODEL_TWO_SIDE = self then
        Result := 'FRAGMENT_LIGHT_MODEL_TWO_SIDE' else
      if FRAGMENT_LIGHT_MODEL_AMBIENT = self then
        Result := 'FRAGMENT_LIGHT_MODEL_AMBIENT' else
      if FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION = self then
        Result := 'FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION' else
        Result := $'glFragmentLightModelParameter[{self.val}]';
    end;
    
  end;
  
  glFragmentLightName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRAGMENT_LIGHT0: glFragmentLightName read new glFragmentLightName($840C);
    public static property FRAGMENT_LIGHT1: glFragmentLightName read new glFragmentLightName($840D);
    public static property FRAGMENT_LIGHT2: glFragmentLightName read new glFragmentLightName($840E);
    public static property FRAGMENT_LIGHT3: glFragmentLightName read new glFragmentLightName($840F);
    public static property FRAGMENT_LIGHT4: glFragmentLightName read new glFragmentLightName($8410);
    public static property FRAGMENT_LIGHT5: glFragmentLightName read new glFragmentLightName($8411);
    public static property FRAGMENT_LIGHT6: glFragmentLightName read new glFragmentLightName($8412);
    public static property FRAGMENT_LIGHT7: glFragmentLightName read new glFragmentLightName($8413);
    
    public function ToString: string; override;
    begin
      if FRAGMENT_LIGHT0 = self then
        Result := 'FRAGMENT_LIGHT0' else
      if FRAGMENT_LIGHT1 = self then
        Result := 'FRAGMENT_LIGHT1' else
      if FRAGMENT_LIGHT2 = self then
        Result := 'FRAGMENT_LIGHT2' else
      if FRAGMENT_LIGHT3 = self then
        Result := 'FRAGMENT_LIGHT3' else
      if FRAGMENT_LIGHT4 = self then
        Result := 'FRAGMENT_LIGHT4' else
      if FRAGMENT_LIGHT5 = self then
        Result := 'FRAGMENT_LIGHT5' else
      if FRAGMENT_LIGHT6 = self then
        Result := 'FRAGMENT_LIGHT6' else
      if FRAGMENT_LIGHT7 = self then
        Result := 'FRAGMENT_LIGHT7' else
        Result := $'glFragmentLightName[{self.val}]';
    end;
    
  end;
  
  glFragmentLightParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property AMBIENT:               glFragmentLightParameter read new glFragmentLightParameter($1200);
    public static property DIFFUSE:               glFragmentLightParameter read new glFragmentLightParameter($1201);
    public static property SPECULAR:              glFragmentLightParameter read new glFragmentLightParameter($1202);
    public static property POSITION:              glFragmentLightParameter read new glFragmentLightParameter($1203);
    public static property SPOT_DIRECTION:        glFragmentLightParameter read new glFragmentLightParameter($1204);
    public static property SPOT_EXPONENT:         glFragmentLightParameter read new glFragmentLightParameter($1205);
    public static property SPOT_CUTOFF:           glFragmentLightParameter read new glFragmentLightParameter($1206);
    public static property CONSTANT_ATTENUATION:  glFragmentLightParameter read new glFragmentLightParameter($1207);
    public static property LINEAR_ATTENUATION:    glFragmentLightParameter read new glFragmentLightParameter($1208);
    public static property QUADRATIC_ATTENUATION: glFragmentLightParameter read new glFragmentLightParameter($1209);
    
    public function ToString: string; override;
    begin
      if AMBIENT = self then
        Result := 'AMBIENT' else
      if DIFFUSE = self then
        Result := 'DIFFUSE' else
      if SPECULAR = self then
        Result := 'SPECULAR' else
      if POSITION = self then
        Result := 'POSITION' else
      if SPOT_DIRECTION = self then
        Result := 'SPOT_DIRECTION' else
      if SPOT_EXPONENT = self then
        Result := 'SPOT_EXPONENT' else
      if SPOT_CUTOFF = self then
        Result := 'SPOT_CUTOFF' else
      if CONSTANT_ATTENUATION = self then
        Result := 'CONSTANT_ATTENUATION' else
      if LINEAR_ATTENUATION = self then
        Result := 'LINEAR_ATTENUATION' else
      if QUADRATIC_ATTENUATION = self then
        Result := 'QUADRATIC_ATTENUATION' else
        Result := $'glFragmentLightParameter[{self.val}]';
    end;
    
  end;
  
  glFragmentOp1 = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MOV: glFragmentOp1 read new glFragmentOp1($8961);
    
    public function ToString: string; override;
    begin
      if MOV = self then
        Result := 'MOV' else
        Result := $'glFragmentOp1[{self.val}]';
    end;
    
  end;
  
  glFragmentOp2 = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ADD_ATI: glFragmentOp2 read new glFragmentOp2($8963);
    public static property MUL:     glFragmentOp2 read new glFragmentOp2($8964);
    public static property SUB:     glFragmentOp2 read new glFragmentOp2($8965);
    public static property DOT3:    glFragmentOp2 read new glFragmentOp2($8966);
    public static property DOT4:    glFragmentOp2 read new glFragmentOp2($8967);
    
    public function ToString: string; override;
    begin
      if ADD_ATI = self then
        Result := 'ADD_ATI' else
      if MUL = self then
        Result := 'MUL' else
      if SUB = self then
        Result := 'SUB' else
      if DOT3 = self then
        Result := 'DOT3' else
      if DOT4 = self then
        Result := 'DOT4' else
        Result := $'glFragmentOp2[{self.val}]';
    end;
    
  end;
  
  glFragmentOp3 = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MAD:      glFragmentOp3 read new glFragmentOp3($8968);
    public static property LERP:     glFragmentOp3 read new glFragmentOp3($8969);
    public static property CND:      glFragmentOp3 read new glFragmentOp3($896A);
    public static property CND0:     glFragmentOp3 read new glFragmentOp3($896B);
    public static property DOT2_ADD: glFragmentOp3 read new glFragmentOp3($896C);
    
    public function ToString: string; override;
    begin
      if MAD = self then
        Result := 'MAD' else
      if LERP = self then
        Result := 'LERP' else
      if CND = self then
        Result := 'CND' else
      if CND0 = self then
        Result := 'CND0' else
      if DOT2_ADD = self then
        Result := 'DOT2_ADD' else
        Result := $'glFragmentOp3[{self.val}]';
    end;
    
  end;
  
  glFragmentShaderColorModMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property _2X_BIT:    glFragmentShaderColorModMask read new glFragmentShaderColorModMask(1 shl 0);
    public static property COMP_BIT:   glFragmentShaderColorModMask read new glFragmentShaderColorModMask(1 shl 1);
    public static property NEGATE_BIT: glFragmentShaderColorModMask read new glFragmentShaderColorModMask(1 shl 2);
    public static property BIAS_BIT:   glFragmentShaderColorModMask read new glFragmentShaderColorModMask(1 shl 3);
    
    public static function operator+(v1, v2: glFragmentShaderColorModMask) := new glFragmentShaderColorModMask(v1.val or v2.val);
    public static function operator or(v1, v2: glFragmentShaderColorModMask) := new glFragmentShaderColorModMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glFragmentShaderColorModMask; v2: glFragmentShaderColorModMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glFragmentShaderColorModMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glFragmentShaderColorModMask[0]';
        exit;
      end;
      if _2X_BIT in self then
      begin
        res += '2X_BIT+';
        left_val := left_val and not _2X_BIT.val;
      end;
      if COMP_BIT in self then
      begin
        res += 'COMP_BIT+';
        left_val := left_val and not COMP_BIT.val;
      end;
      if NEGATE_BIT in self then
      begin
        res += 'NEGATE_BIT+';
        left_val := left_val and not NEGATE_BIT.val;
      end;
      if BIAS_BIT in self then
      begin
        res += 'BIAS_BIT+';
        left_val := left_val and not BIAS_BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'glFragmentShaderColorModMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glFragmentShaderCon = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CON_0:  glFragmentShaderCon read new glFragmentShaderCon($8941);
    public static property CON_1:  glFragmentShaderCon read new glFragmentShaderCon($8942);
    public static property CON_2:  glFragmentShaderCon read new glFragmentShaderCon($8943);
    public static property CON_3:  glFragmentShaderCon read new glFragmentShaderCon($8944);
    public static property CON_4:  glFragmentShaderCon read new glFragmentShaderCon($8945);
    public static property CON_5:  glFragmentShaderCon read new glFragmentShaderCon($8946);
    public static property CON_6:  glFragmentShaderCon read new glFragmentShaderCon($8947);
    public static property CON_7:  glFragmentShaderCon read new glFragmentShaderCon($8948);
    public static property CON_8:  glFragmentShaderCon read new glFragmentShaderCon($8949);
    public static property CON_9:  glFragmentShaderCon read new glFragmentShaderCon($894A);
    public static property CON_10: glFragmentShaderCon read new glFragmentShaderCon($894B);
    public static property CON_11: glFragmentShaderCon read new glFragmentShaderCon($894C);
    public static property CON_12: glFragmentShaderCon read new glFragmentShaderCon($894D);
    public static property CON_13: glFragmentShaderCon read new glFragmentShaderCon($894E);
    public static property CON_14: glFragmentShaderCon read new glFragmentShaderCon($894F);
    public static property CON_15: glFragmentShaderCon read new glFragmentShaderCon($8950);
    public static property CON_16: glFragmentShaderCon read new glFragmentShaderCon($8951);
    public static property CON_17: glFragmentShaderCon read new glFragmentShaderCon($8952);
    public static property CON_18: glFragmentShaderCon read new glFragmentShaderCon($8953);
    public static property CON_19: glFragmentShaderCon read new glFragmentShaderCon($8954);
    public static property CON_20: glFragmentShaderCon read new glFragmentShaderCon($8955);
    public static property CON_21: glFragmentShaderCon read new glFragmentShaderCon($8956);
    public static property CON_22: glFragmentShaderCon read new glFragmentShaderCon($8957);
    public static property CON_23: glFragmentShaderCon read new glFragmentShaderCon($8958);
    public static property CON_24: glFragmentShaderCon read new glFragmentShaderCon($8959);
    public static property CON_25: glFragmentShaderCon read new glFragmentShaderCon($895A);
    public static property CON_26: glFragmentShaderCon read new glFragmentShaderCon($895B);
    public static property CON_27: glFragmentShaderCon read new glFragmentShaderCon($895C);
    public static property CON_28: glFragmentShaderCon read new glFragmentShaderCon($895D);
    public static property CON_29: glFragmentShaderCon read new glFragmentShaderCon($895E);
    public static property CON_30: glFragmentShaderCon read new glFragmentShaderCon($895F);
    public static property CON_31: glFragmentShaderCon read new glFragmentShaderCon($8960);
    
    public function ToString: string; override;
    begin
      if CON_0 = self then
        Result := 'CON_0' else
      if CON_1 = self then
        Result := 'CON_1' else
      if CON_2 = self then
        Result := 'CON_2' else
      if CON_3 = self then
        Result := 'CON_3' else
      if CON_4 = self then
        Result := 'CON_4' else
      if CON_5 = self then
        Result := 'CON_5' else
      if CON_6 = self then
        Result := 'CON_6' else
      if CON_7 = self then
        Result := 'CON_7' else
      if CON_8 = self then
        Result := 'CON_8' else
      if CON_9 = self then
        Result := 'CON_9' else
      if CON_10 = self then
        Result := 'CON_10' else
      if CON_11 = self then
        Result := 'CON_11' else
      if CON_12 = self then
        Result := 'CON_12' else
      if CON_13 = self then
        Result := 'CON_13' else
      if CON_14 = self then
        Result := 'CON_14' else
      if CON_15 = self then
        Result := 'CON_15' else
      if CON_16 = self then
        Result := 'CON_16' else
      if CON_17 = self then
        Result := 'CON_17' else
      if CON_18 = self then
        Result := 'CON_18' else
      if CON_19 = self then
        Result := 'CON_19' else
      if CON_20 = self then
        Result := 'CON_20' else
      if CON_21 = self then
        Result := 'CON_21' else
      if CON_22 = self then
        Result := 'CON_22' else
      if CON_23 = self then
        Result := 'CON_23' else
      if CON_24 = self then
        Result := 'CON_24' else
      if CON_25 = self then
        Result := 'CON_25' else
      if CON_26 = self then
        Result := 'CON_26' else
      if CON_27 = self then
        Result := 'CON_27' else
      if CON_28 = self then
        Result := 'CON_28' else
      if CON_29 = self then
        Result := 'CON_29' else
      if CON_30 = self then
        Result := 'CON_30' else
      if CON_31 = self then
        Result := 'CON_31' else
        Result := $'glFragmentShaderCon[{self.val}]';
    end;
    
  end;
  
  glFragmentShaderDestMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:      glFragmentShaderDestMask read new glFragmentShaderDestMask(0);
    public static property RED_BIT:   glFragmentShaderDestMask read new glFragmentShaderDestMask(1 shl 0);
    public static property GREEN_BIT: glFragmentShaderDestMask read new glFragmentShaderDestMask(1 shl 1);
    public static property BLUE_BIT:  glFragmentShaderDestMask read new glFragmentShaderDestMask(1 shl 2);
    
    public property ANY_FLAGS: boolean read self.val<>0;
    
    public static function operator+(v1, v2: glFragmentShaderDestMask) := new glFragmentShaderDestMask(v1.val or v2.val);
    public static function operator or(v1, v2: glFragmentShaderDestMask) := new glFragmentShaderDestMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glFragmentShaderDestMask; v2: glFragmentShaderDestMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glFragmentShaderDestMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'NONE';
        exit;
      end;
      if RED_BIT in self then
      begin
        res += 'RED_BIT+';
        left_val := left_val and not RED_BIT.val;
      end;
      if GREEN_BIT in self then
      begin
        res += 'GREEN_BIT+';
        left_val := left_val and not GREEN_BIT.val;
      end;
      if BLUE_BIT in self then
      begin
        res += 'BLUE_BIT+';
        left_val := left_val and not BLUE_BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'glFragmentShaderDestMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glFragmentShaderDestModMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:         glFragmentShaderDestModMask read new glFragmentShaderDestModMask(0);
    public static property _2X_BIT:      glFragmentShaderDestModMask read new glFragmentShaderDestModMask(1 shl 0);
    public static property _4X_BIT:      glFragmentShaderDestModMask read new glFragmentShaderDestModMask(1 shl 1);
    public static property _8X_BIT:      glFragmentShaderDestModMask read new glFragmentShaderDestModMask(1 shl 2);
    public static property HALF_BIT:     glFragmentShaderDestModMask read new glFragmentShaderDestModMask(1 shl 3);
    public static property QUARTER_BIT:  glFragmentShaderDestModMask read new glFragmentShaderDestModMask(1 shl 4);
    public static property EIGHTH_BIT:   glFragmentShaderDestModMask read new glFragmentShaderDestModMask(1 shl 5);
    public static property SATURATE_BIT: glFragmentShaderDestModMask read new glFragmentShaderDestModMask(1 shl 6);
    
    public property ANY_FLAGS: boolean read self.val<>0;
    
    public static function operator+(v1, v2: glFragmentShaderDestModMask) := new glFragmentShaderDestModMask(v1.val or v2.val);
    public static function operator or(v1, v2: glFragmentShaderDestModMask) := new glFragmentShaderDestModMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glFragmentShaderDestModMask; v2: glFragmentShaderDestModMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glFragmentShaderDestModMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'NONE';
        exit;
      end;
      if _2X_BIT in self then
      begin
        res += '2X_BIT+';
        left_val := left_val and not _2X_BIT.val;
      end;
      if _4X_BIT in self then
      begin
        res += '4X_BIT+';
        left_val := left_val and not _4X_BIT.val;
      end;
      if _8X_BIT in self then
      begin
        res += '8X_BIT+';
        left_val := left_val and not _8X_BIT.val;
      end;
      if HALF_BIT in self then
      begin
        res += 'HALF_BIT+';
        left_val := left_val and not HALF_BIT.val;
      end;
      if QUARTER_BIT in self then
      begin
        res += 'QUARTER_BIT+';
        left_val := left_val and not QUARTER_BIT.val;
      end;
      if EIGHTH_BIT in self then
      begin
        res += 'EIGHTH_BIT+';
        left_val := left_val and not EIGHTH_BIT.val;
      end;
      if SATURATE_BIT in self then
      begin
        res += 'SATURATE_BIT+';
        left_val := left_val and not SATURATE_BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'glFragmentShaderDestModMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glFragmentShaderGenericSource = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ZERO:                   glFragmentShaderGenericSource read new glFragmentShaderGenericSource(0);
    public static property ONE:                    glFragmentShaderGenericSource read new glFragmentShaderGenericSource($0001);
    public static property PRIMARY_COLOR:          glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8577);
    public static property REG_0:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8921);
    public static property REG_1:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8922);
    public static property REG_2:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8923);
    public static property REG_3:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8924);
    public static property REG_4:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8925);
    public static property REG_5:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8926);
    public static property REG_6:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8927);
    public static property REG_7:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8928);
    public static property REG_8:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8929);
    public static property REG_9:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($892A);
    public static property REG_10:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($892B);
    public static property REG_11:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($892C);
    public static property REG_12:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($892D);
    public static property REG_13:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($892E);
    public static property REG_14:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($892F);
    public static property REG_15:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8930);
    public static property REG_16:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8931);
    public static property REG_17:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8932);
    public static property REG_18:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8933);
    public static property REG_19:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8934);
    public static property REG_20:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8935);
    public static property REG_21:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8936);
    public static property REG_22:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8937);
    public static property REG_23:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8938);
    public static property REG_24:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8939);
    public static property REG_25:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($893A);
    public static property REG_26:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($893B);
    public static property REG_27:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($893C);
    public static property REG_28:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($893D);
    public static property REG_29:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($893E);
    public static property REG_30:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($893F);
    public static property REG_31:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8940);
    public static property CON_0:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8941);
    public static property CON_1:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8942);
    public static property CON_2:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8943);
    public static property CON_3:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8944);
    public static property CON_4:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8945);
    public static property CON_5:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8946);
    public static property CON_6:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8947);
    public static property CON_7:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8948);
    public static property CON_8:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8949);
    public static property CON_9:                  glFragmentShaderGenericSource read new glFragmentShaderGenericSource($894A);
    public static property CON_10:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($894B);
    public static property CON_11:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($894C);
    public static property CON_12:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($894D);
    public static property CON_13:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($894E);
    public static property CON_14:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($894F);
    public static property CON_15:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8950);
    public static property CON_16:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8951);
    public static property CON_17:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8952);
    public static property CON_18:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8953);
    public static property CON_19:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8954);
    public static property CON_20:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8955);
    public static property CON_21:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8956);
    public static property CON_22:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8957);
    public static property CON_23:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8958);
    public static property CON_24:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8959);
    public static property CON_25:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($895A);
    public static property CON_26:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($895B);
    public static property CON_27:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($895C);
    public static property CON_28:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($895D);
    public static property CON_29:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($895E);
    public static property CON_30:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($895F);
    public static property CON_31:                 glFragmentShaderGenericSource read new glFragmentShaderGenericSource($8960);
    public static property SECONDARY_INTERPOLATOR: glFragmentShaderGenericSource read new glFragmentShaderGenericSource($896D);
    
    public function ToString: string; override;
    begin
      if ZERO = self then
        Result := 'ZERO' else
      if ONE = self then
        Result := 'ONE' else
      if PRIMARY_COLOR = self then
        Result := 'PRIMARY_COLOR' else
      if REG_0 = self then
        Result := 'REG_0' else
      if REG_1 = self then
        Result := 'REG_1' else
      if REG_2 = self then
        Result := 'REG_2' else
      if REG_3 = self then
        Result := 'REG_3' else
      if REG_4 = self then
        Result := 'REG_4' else
      if REG_5 = self then
        Result := 'REG_5' else
      if REG_6 = self then
        Result := 'REG_6' else
      if REG_7 = self then
        Result := 'REG_7' else
      if REG_8 = self then
        Result := 'REG_8' else
      if REG_9 = self then
        Result := 'REG_9' else
      if REG_10 = self then
        Result := 'REG_10' else
      if REG_11 = self then
        Result := 'REG_11' else
      if REG_12 = self then
        Result := 'REG_12' else
      if REG_13 = self then
        Result := 'REG_13' else
      if REG_14 = self then
        Result := 'REG_14' else
      if REG_15 = self then
        Result := 'REG_15' else
      if REG_16 = self then
        Result := 'REG_16' else
      if REG_17 = self then
        Result := 'REG_17' else
      if REG_18 = self then
        Result := 'REG_18' else
      if REG_19 = self then
        Result := 'REG_19' else
      if REG_20 = self then
        Result := 'REG_20' else
      if REG_21 = self then
        Result := 'REG_21' else
      if REG_22 = self then
        Result := 'REG_22' else
      if REG_23 = self then
        Result := 'REG_23' else
      if REG_24 = self then
        Result := 'REG_24' else
      if REG_25 = self then
        Result := 'REG_25' else
      if REG_26 = self then
        Result := 'REG_26' else
      if REG_27 = self then
        Result := 'REG_27' else
      if REG_28 = self then
        Result := 'REG_28' else
      if REG_29 = self then
        Result := 'REG_29' else
      if REG_30 = self then
        Result := 'REG_30' else
      if REG_31 = self then
        Result := 'REG_31' else
      if CON_0 = self then
        Result := 'CON_0' else
      if CON_1 = self then
        Result := 'CON_1' else
      if CON_2 = self then
        Result := 'CON_2' else
      if CON_3 = self then
        Result := 'CON_3' else
      if CON_4 = self then
        Result := 'CON_4' else
      if CON_5 = self then
        Result := 'CON_5' else
      if CON_6 = self then
        Result := 'CON_6' else
      if CON_7 = self then
        Result := 'CON_7' else
      if CON_8 = self then
        Result := 'CON_8' else
      if CON_9 = self then
        Result := 'CON_9' else
      if CON_10 = self then
        Result := 'CON_10' else
      if CON_11 = self then
        Result := 'CON_11' else
      if CON_12 = self then
        Result := 'CON_12' else
      if CON_13 = self then
        Result := 'CON_13' else
      if CON_14 = self then
        Result := 'CON_14' else
      if CON_15 = self then
        Result := 'CON_15' else
      if CON_16 = self then
        Result := 'CON_16' else
      if CON_17 = self then
        Result := 'CON_17' else
      if CON_18 = self then
        Result := 'CON_18' else
      if CON_19 = self then
        Result := 'CON_19' else
      if CON_20 = self then
        Result := 'CON_20' else
      if CON_21 = self then
        Result := 'CON_21' else
      if CON_22 = self then
        Result := 'CON_22' else
      if CON_23 = self then
        Result := 'CON_23' else
      if CON_24 = self then
        Result := 'CON_24' else
      if CON_25 = self then
        Result := 'CON_25' else
      if CON_26 = self then
        Result := 'CON_26' else
      if CON_27 = self then
        Result := 'CON_27' else
      if CON_28 = self then
        Result := 'CON_28' else
      if CON_29 = self then
        Result := 'CON_29' else
      if CON_30 = self then
        Result := 'CON_30' else
      if CON_31 = self then
        Result := 'CON_31' else
      if SECONDARY_INTERPOLATOR = self then
        Result := 'SECONDARY_INTERPOLATOR' else
        Result := $'glFragmentShaderGenericSource[{self.val}]';
    end;
    
  end;
  
  glFragmentShaderReg = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property REG_0:  glFragmentShaderReg read new glFragmentShaderReg($8921);
    public static property REG_1:  glFragmentShaderReg read new glFragmentShaderReg($8922);
    public static property REG_2:  glFragmentShaderReg read new glFragmentShaderReg($8923);
    public static property REG_3:  glFragmentShaderReg read new glFragmentShaderReg($8924);
    public static property REG_4:  glFragmentShaderReg read new glFragmentShaderReg($8925);
    public static property REG_5:  glFragmentShaderReg read new glFragmentShaderReg($8926);
    public static property REG_6:  glFragmentShaderReg read new glFragmentShaderReg($8927);
    public static property REG_7:  glFragmentShaderReg read new glFragmentShaderReg($8928);
    public static property REG_8:  glFragmentShaderReg read new glFragmentShaderReg($8929);
    public static property REG_9:  glFragmentShaderReg read new glFragmentShaderReg($892A);
    public static property REG_10: glFragmentShaderReg read new glFragmentShaderReg($892B);
    public static property REG_11: glFragmentShaderReg read new glFragmentShaderReg($892C);
    public static property REG_12: glFragmentShaderReg read new glFragmentShaderReg($892D);
    public static property REG_13: glFragmentShaderReg read new glFragmentShaderReg($892E);
    public static property REG_14: glFragmentShaderReg read new glFragmentShaderReg($892F);
    public static property REG_15: glFragmentShaderReg read new glFragmentShaderReg($8930);
    public static property REG_16: glFragmentShaderReg read new glFragmentShaderReg($8931);
    public static property REG_17: glFragmentShaderReg read new glFragmentShaderReg($8932);
    public static property REG_18: glFragmentShaderReg read new glFragmentShaderReg($8933);
    public static property REG_19: glFragmentShaderReg read new glFragmentShaderReg($8934);
    public static property REG_20: glFragmentShaderReg read new glFragmentShaderReg($8935);
    public static property REG_21: glFragmentShaderReg read new glFragmentShaderReg($8936);
    public static property REG_22: glFragmentShaderReg read new glFragmentShaderReg($8937);
    public static property REG_23: glFragmentShaderReg read new glFragmentShaderReg($8938);
    public static property REG_24: glFragmentShaderReg read new glFragmentShaderReg($8939);
    public static property REG_25: glFragmentShaderReg read new glFragmentShaderReg($893A);
    public static property REG_26: glFragmentShaderReg read new glFragmentShaderReg($893B);
    public static property REG_27: glFragmentShaderReg read new glFragmentShaderReg($893C);
    public static property REG_28: glFragmentShaderReg read new glFragmentShaderReg($893D);
    public static property REG_29: glFragmentShaderReg read new glFragmentShaderReg($893E);
    public static property REG_30: glFragmentShaderReg read new glFragmentShaderReg($893F);
    public static property REG_31: glFragmentShaderReg read new glFragmentShaderReg($8940);
    
    public function ToString: string; override;
    begin
      if REG_0 = self then
        Result := 'REG_0' else
      if REG_1 = self then
        Result := 'REG_1' else
      if REG_2 = self then
        Result := 'REG_2' else
      if REG_3 = self then
        Result := 'REG_3' else
      if REG_4 = self then
        Result := 'REG_4' else
      if REG_5 = self then
        Result := 'REG_5' else
      if REG_6 = self then
        Result := 'REG_6' else
      if REG_7 = self then
        Result := 'REG_7' else
      if REG_8 = self then
        Result := 'REG_8' else
      if REG_9 = self then
        Result := 'REG_9' else
      if REG_10 = self then
        Result := 'REG_10' else
      if REG_11 = self then
        Result := 'REG_11' else
      if REG_12 = self then
        Result := 'REG_12' else
      if REG_13 = self then
        Result := 'REG_13' else
      if REG_14 = self then
        Result := 'REG_14' else
      if REG_15 = self then
        Result := 'REG_15' else
      if REG_16 = self then
        Result := 'REG_16' else
      if REG_17 = self then
        Result := 'REG_17' else
      if REG_18 = self then
        Result := 'REG_18' else
      if REG_19 = self then
        Result := 'REG_19' else
      if REG_20 = self then
        Result := 'REG_20' else
      if REG_21 = self then
        Result := 'REG_21' else
      if REG_22 = self then
        Result := 'REG_22' else
      if REG_23 = self then
        Result := 'REG_23' else
      if REG_24 = self then
        Result := 'REG_24' else
      if REG_25 = self then
        Result := 'REG_25' else
      if REG_26 = self then
        Result := 'REG_26' else
      if REG_27 = self then
        Result := 'REG_27' else
      if REG_28 = self then
        Result := 'REG_28' else
      if REG_29 = self then
        Result := 'REG_29' else
      if REG_30 = self then
        Result := 'REG_30' else
      if REG_31 = self then
        Result := 'REG_31' else
        Result := $'glFragmentShaderReg[{self.val}]';
    end;
    
  end;
  
  glFragmentShaderTextureSource = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE0:  glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84C0);
    public static property TEXTURE1:  glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84C1);
    public static property TEXTURE2:  glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84C2);
    public static property TEXTURE3:  glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84C3);
    public static property TEXTURE4:  glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84C4);
    public static property TEXTURE5:  glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84C5);
    public static property TEXTURE6:  glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84C6);
    public static property TEXTURE7:  glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84C7);
    public static property TEXTURE8:  glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84C8);
    public static property TEXTURE9:  glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84C9);
    public static property TEXTURE10: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84CA);
    public static property TEXTURE11: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84CB);
    public static property TEXTURE12: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84CC);
    public static property TEXTURE13: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84CD);
    public static property TEXTURE14: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84CE);
    public static property TEXTURE15: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84CF);
    public static property TEXTURE16: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84D0);
    public static property TEXTURE17: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84D1);
    public static property TEXTURE18: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84D2);
    public static property TEXTURE19: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84D3);
    public static property TEXTURE20: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84D4);
    public static property TEXTURE21: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84D5);
    public static property TEXTURE22: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84D6);
    public static property TEXTURE23: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84D7);
    public static property TEXTURE24: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84D8);
    public static property TEXTURE25: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84D9);
    public static property TEXTURE26: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84DA);
    public static property TEXTURE27: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84DB);
    public static property TEXTURE28: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84DC);
    public static property TEXTURE29: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84DD);
    public static property TEXTURE30: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84DE);
    public static property TEXTURE31: glFragmentShaderTextureSource read new glFragmentShaderTextureSource($84DF);
    public static property REG_0:     glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8921);
    public static property REG_1:     glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8922);
    public static property REG_2:     glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8923);
    public static property REG_3:     glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8924);
    public static property REG_4:     glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8925);
    public static property REG_5:     glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8926);
    public static property REG_6:     glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8927);
    public static property REG_7:     glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8928);
    public static property REG_8:     glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8929);
    public static property REG_9:     glFragmentShaderTextureSource read new glFragmentShaderTextureSource($892A);
    public static property REG_10:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($892B);
    public static property REG_11:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($892C);
    public static property REG_12:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($892D);
    public static property REG_13:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($892E);
    public static property REG_14:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($892F);
    public static property REG_15:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8930);
    public static property REG_16:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8931);
    public static property REG_17:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8932);
    public static property REG_18:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8933);
    public static property REG_19:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8934);
    public static property REG_20:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8935);
    public static property REG_21:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8936);
    public static property REG_22:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8937);
    public static property REG_23:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8938);
    public static property REG_24:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8939);
    public static property REG_25:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($893A);
    public static property REG_26:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($893B);
    public static property REG_27:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($893C);
    public static property REG_28:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($893D);
    public static property REG_29:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($893E);
    public static property REG_30:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($893F);
    public static property REG_31:    glFragmentShaderTextureSource read new glFragmentShaderTextureSource($8940);
    
    public function ToString: string; override;
    begin
      if TEXTURE0 = self then
        Result := 'TEXTURE0' else
      if TEXTURE1 = self then
        Result := 'TEXTURE1' else
      if TEXTURE2 = self then
        Result := 'TEXTURE2' else
      if TEXTURE3 = self then
        Result := 'TEXTURE3' else
      if TEXTURE4 = self then
        Result := 'TEXTURE4' else
      if TEXTURE5 = self then
        Result := 'TEXTURE5' else
      if TEXTURE6 = self then
        Result := 'TEXTURE6' else
      if TEXTURE7 = self then
        Result := 'TEXTURE7' else
      if TEXTURE8 = self then
        Result := 'TEXTURE8' else
      if TEXTURE9 = self then
        Result := 'TEXTURE9' else
      if TEXTURE10 = self then
        Result := 'TEXTURE10' else
      if TEXTURE11 = self then
        Result := 'TEXTURE11' else
      if TEXTURE12 = self then
        Result := 'TEXTURE12' else
      if TEXTURE13 = self then
        Result := 'TEXTURE13' else
      if TEXTURE14 = self then
        Result := 'TEXTURE14' else
      if TEXTURE15 = self then
        Result := 'TEXTURE15' else
      if TEXTURE16 = self then
        Result := 'TEXTURE16' else
      if TEXTURE17 = self then
        Result := 'TEXTURE17' else
      if TEXTURE18 = self then
        Result := 'TEXTURE18' else
      if TEXTURE19 = self then
        Result := 'TEXTURE19' else
      if TEXTURE20 = self then
        Result := 'TEXTURE20' else
      if TEXTURE21 = self then
        Result := 'TEXTURE21' else
      if TEXTURE22 = self then
        Result := 'TEXTURE22' else
      if TEXTURE23 = self then
        Result := 'TEXTURE23' else
      if TEXTURE24 = self then
        Result := 'TEXTURE24' else
      if TEXTURE25 = self then
        Result := 'TEXTURE25' else
      if TEXTURE26 = self then
        Result := 'TEXTURE26' else
      if TEXTURE27 = self then
        Result := 'TEXTURE27' else
      if TEXTURE28 = self then
        Result := 'TEXTURE28' else
      if TEXTURE29 = self then
        Result := 'TEXTURE29' else
      if TEXTURE30 = self then
        Result := 'TEXTURE30' else
      if TEXTURE31 = self then
        Result := 'TEXTURE31' else
      if REG_0 = self then
        Result := 'REG_0' else
      if REG_1 = self then
        Result := 'REG_1' else
      if REG_2 = self then
        Result := 'REG_2' else
      if REG_3 = self then
        Result := 'REG_3' else
      if REG_4 = self then
        Result := 'REG_4' else
      if REG_5 = self then
        Result := 'REG_5' else
      if REG_6 = self then
        Result := 'REG_6' else
      if REG_7 = self then
        Result := 'REG_7' else
      if REG_8 = self then
        Result := 'REG_8' else
      if REG_9 = self then
        Result := 'REG_9' else
      if REG_10 = self then
        Result := 'REG_10' else
      if REG_11 = self then
        Result := 'REG_11' else
      if REG_12 = self then
        Result := 'REG_12' else
      if REG_13 = self then
        Result := 'REG_13' else
      if REG_14 = self then
        Result := 'REG_14' else
      if REG_15 = self then
        Result := 'REG_15' else
      if REG_16 = self then
        Result := 'REG_16' else
      if REG_17 = self then
        Result := 'REG_17' else
      if REG_18 = self then
        Result := 'REG_18' else
      if REG_19 = self then
        Result := 'REG_19' else
      if REG_20 = self then
        Result := 'REG_20' else
      if REG_21 = self then
        Result := 'REG_21' else
      if REG_22 = self then
        Result := 'REG_22' else
      if REG_23 = self then
        Result := 'REG_23' else
      if REG_24 = self then
        Result := 'REG_24' else
      if REG_25 = self then
        Result := 'REG_25' else
      if REG_26 = self then
        Result := 'REG_26' else
      if REG_27 = self then
        Result := 'REG_27' else
      if REG_28 = self then
        Result := 'REG_28' else
      if REG_29 = self then
        Result := 'REG_29' else
      if REG_30 = self then
        Result := 'REG_30' else
      if REG_31 = self then
        Result := 'REG_31' else
        Result := $'glFragmentShaderTextureSource[{self.val}]';
    end;
    
  end;
  
  glFragmentShaderValueRep = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:  glFragmentShaderValueRep read new glFragmentShaderValueRep(0);
    public static property RED:   glFragmentShaderValueRep read new glFragmentShaderValueRep($1903);
    public static property GREEN: glFragmentShaderValueRep read new glFragmentShaderValueRep($1904);
    public static property BLUE:  glFragmentShaderValueRep read new glFragmentShaderValueRep($1905);
    public static property ALPHA: glFragmentShaderValueRep read new glFragmentShaderValueRep($1906);
    
    public function ToString: string; override;
    begin
      if NONE = self then
        Result := 'NONE' else
      if RED = self then
        Result := 'RED' else
      if GREEN = self then
        Result := 'GREEN' else
      if BLUE = self then
        Result := 'BLUE' else
      if ALPHA = self then
        Result := 'ALPHA' else
        Result := $'glFragmentShaderValueRep[{self.val}]';
    end;
    
  end;
  
  glFramebufferAttachment = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DEPTH_STENCIL_ATTACHMENT: glFramebufferAttachment read new glFramebufferAttachment($821A);
    public static property COLOR_ATTACHMENT0:        glFramebufferAttachment read new glFramebufferAttachment($8CE0);
    public static property COLOR_ATTACHMENT1:        glFramebufferAttachment read new glFramebufferAttachment($8CE1);
    public static property COLOR_ATTACHMENT2:        glFramebufferAttachment read new glFramebufferAttachment($8CE2);
    public static property COLOR_ATTACHMENT3:        glFramebufferAttachment read new glFramebufferAttachment($8CE3);
    public static property COLOR_ATTACHMENT4:        glFramebufferAttachment read new glFramebufferAttachment($8CE4);
    public static property COLOR_ATTACHMENT5:        glFramebufferAttachment read new glFramebufferAttachment($8CE5);
    public static property COLOR_ATTACHMENT6:        glFramebufferAttachment read new glFramebufferAttachment($8CE6);
    public static property COLOR_ATTACHMENT7:        glFramebufferAttachment read new glFramebufferAttachment($8CE7);
    public static property COLOR_ATTACHMENT8:        glFramebufferAttachment read new glFramebufferAttachment($8CE8);
    public static property COLOR_ATTACHMENT9:        glFramebufferAttachment read new glFramebufferAttachment($8CE9);
    public static property COLOR_ATTACHMENT10:       glFramebufferAttachment read new glFramebufferAttachment($8CEA);
    public static property COLOR_ATTACHMENT11:       glFramebufferAttachment read new glFramebufferAttachment($8CEB);
    public static property COLOR_ATTACHMENT12:       glFramebufferAttachment read new glFramebufferAttachment($8CEC);
    public static property COLOR_ATTACHMENT13:       glFramebufferAttachment read new glFramebufferAttachment($8CED);
    public static property COLOR_ATTACHMENT14:       glFramebufferAttachment read new glFramebufferAttachment($8CEE);
    public static property COLOR_ATTACHMENT15:       glFramebufferAttachment read new glFramebufferAttachment($8CEF);
    public static property COLOR_ATTACHMENT16:       glFramebufferAttachment read new glFramebufferAttachment($8CF0);
    public static property COLOR_ATTACHMENT17:       glFramebufferAttachment read new glFramebufferAttachment($8CF1);
    public static property COLOR_ATTACHMENT18:       glFramebufferAttachment read new glFramebufferAttachment($8CF2);
    public static property COLOR_ATTACHMENT19:       glFramebufferAttachment read new glFramebufferAttachment($8CF3);
    public static property COLOR_ATTACHMENT20:       glFramebufferAttachment read new glFramebufferAttachment($8CF4);
    public static property COLOR_ATTACHMENT21:       glFramebufferAttachment read new glFramebufferAttachment($8CF5);
    public static property COLOR_ATTACHMENT22:       glFramebufferAttachment read new glFramebufferAttachment($8CF6);
    public static property COLOR_ATTACHMENT23:       glFramebufferAttachment read new glFramebufferAttachment($8CF7);
    public static property COLOR_ATTACHMENT24:       glFramebufferAttachment read new glFramebufferAttachment($8CF8);
    public static property COLOR_ATTACHMENT25:       glFramebufferAttachment read new glFramebufferAttachment($8CF9);
    public static property COLOR_ATTACHMENT26:       glFramebufferAttachment read new glFramebufferAttachment($8CFA);
    public static property COLOR_ATTACHMENT27:       glFramebufferAttachment read new glFramebufferAttachment($8CFB);
    public static property COLOR_ATTACHMENT28:       glFramebufferAttachment read new glFramebufferAttachment($8CFC);
    public static property COLOR_ATTACHMENT29:       glFramebufferAttachment read new glFramebufferAttachment($8CFD);
    public static property COLOR_ATTACHMENT30:       glFramebufferAttachment read new glFramebufferAttachment($8CFE);
    public static property COLOR_ATTACHMENT31:       glFramebufferAttachment read new glFramebufferAttachment($8CFF);
    public static property DEPTH_ATTACHMENT:         glFramebufferAttachment read new glFramebufferAttachment($8D00);
    public static property STENCIL_ATTACHMENT:       glFramebufferAttachment read new glFramebufferAttachment($8D20);
    public static property SHADING_RATE_ATTACHMENT:  glFramebufferAttachment read new glFramebufferAttachment($96D1);
    
    public function ToString: string; override;
    begin
      if DEPTH_STENCIL_ATTACHMENT = self then
        Result := 'DEPTH_STENCIL_ATTACHMENT' else
      if COLOR_ATTACHMENT0 = self then
        Result := 'COLOR_ATTACHMENT0' else
      if COLOR_ATTACHMENT1 = self then
        Result := 'COLOR_ATTACHMENT1' else
      if COLOR_ATTACHMENT2 = self then
        Result := 'COLOR_ATTACHMENT2' else
      if COLOR_ATTACHMENT3 = self then
        Result := 'COLOR_ATTACHMENT3' else
      if COLOR_ATTACHMENT4 = self then
        Result := 'COLOR_ATTACHMENT4' else
      if COLOR_ATTACHMENT5 = self then
        Result := 'COLOR_ATTACHMENT5' else
      if COLOR_ATTACHMENT6 = self then
        Result := 'COLOR_ATTACHMENT6' else
      if COLOR_ATTACHMENT7 = self then
        Result := 'COLOR_ATTACHMENT7' else
      if COLOR_ATTACHMENT8 = self then
        Result := 'COLOR_ATTACHMENT8' else
      if COLOR_ATTACHMENT9 = self then
        Result := 'COLOR_ATTACHMENT9' else
      if COLOR_ATTACHMENT10 = self then
        Result := 'COLOR_ATTACHMENT10' else
      if COLOR_ATTACHMENT11 = self then
        Result := 'COLOR_ATTACHMENT11' else
      if COLOR_ATTACHMENT12 = self then
        Result := 'COLOR_ATTACHMENT12' else
      if COLOR_ATTACHMENT13 = self then
        Result := 'COLOR_ATTACHMENT13' else
      if COLOR_ATTACHMENT14 = self then
        Result := 'COLOR_ATTACHMENT14' else
      if COLOR_ATTACHMENT15 = self then
        Result := 'COLOR_ATTACHMENT15' else
      if COLOR_ATTACHMENT16 = self then
        Result := 'COLOR_ATTACHMENT16' else
      if COLOR_ATTACHMENT17 = self then
        Result := 'COLOR_ATTACHMENT17' else
      if COLOR_ATTACHMENT18 = self then
        Result := 'COLOR_ATTACHMENT18' else
      if COLOR_ATTACHMENT19 = self then
        Result := 'COLOR_ATTACHMENT19' else
      if COLOR_ATTACHMENT20 = self then
        Result := 'COLOR_ATTACHMENT20' else
      if COLOR_ATTACHMENT21 = self then
        Result := 'COLOR_ATTACHMENT21' else
      if COLOR_ATTACHMENT22 = self then
        Result := 'COLOR_ATTACHMENT22' else
      if COLOR_ATTACHMENT23 = self then
        Result := 'COLOR_ATTACHMENT23' else
      if COLOR_ATTACHMENT24 = self then
        Result := 'COLOR_ATTACHMENT24' else
      if COLOR_ATTACHMENT25 = self then
        Result := 'COLOR_ATTACHMENT25' else
      if COLOR_ATTACHMENT26 = self then
        Result := 'COLOR_ATTACHMENT26' else
      if COLOR_ATTACHMENT27 = self then
        Result := 'COLOR_ATTACHMENT27' else
      if COLOR_ATTACHMENT28 = self then
        Result := 'COLOR_ATTACHMENT28' else
      if COLOR_ATTACHMENT29 = self then
        Result := 'COLOR_ATTACHMENT29' else
      if COLOR_ATTACHMENT30 = self then
        Result := 'COLOR_ATTACHMENT30' else
      if COLOR_ATTACHMENT31 = self then
        Result := 'COLOR_ATTACHMENT31' else
      if DEPTH_ATTACHMENT = self then
        Result := 'DEPTH_ATTACHMENT' else
      if STENCIL_ATTACHMENT = self then
        Result := 'STENCIL_ATTACHMENT' else
      if SHADING_RATE_ATTACHMENT = self then
        Result := 'SHADING_RATE_ATTACHMENT' else
        Result := $'glFramebufferAttachment[{self.val}]';
    end;
    
  end;
  
  glFramebufferAttachmentParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:          glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($8210);
    public static property FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:          glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($8211);
    public static property FRAMEBUFFER_ATTACHMENT_RED_SIZE:                glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($8212);
    public static property FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:              glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($8213);
    public static property FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:               glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($8214);
    public static property FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:              glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($8215);
    public static property FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:              glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($8216);
    public static property FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:            glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($8217);
    public static property FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:             glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($8CD0);
    public static property FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:             glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($8CD1);
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:           glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($8CD2);
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:   glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($8CD3);
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET:      glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($8CD4);
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER:           glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($8CD4);
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES:         glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($8D6C);
    public static property FRAMEBUFFER_ATTACHMENT_LAYERED:                 glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($8DA7);
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_SCALE:           glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($913F);
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS:       glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($9630);
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX: glFramebufferAttachmentParameterName read new glFramebufferAttachmentParameterName($9632);
    
    public function ToString: string; override;
    begin
      if FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING' else
      if FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE' else
      if FRAMEBUFFER_ATTACHMENT_RED_SIZE = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_RED_SIZE' else
      if FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_GREEN_SIZE' else
      if FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_BLUE_SIZE' else
      if FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE' else
      if FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE' else
      if FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE' else
      if FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE' else
      if FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_OBJECT_NAME' else
      if FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL' else
      if FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE' else
      if FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET' else
      if FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER' else
      if FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES' else
      if FRAMEBUFFER_ATTACHMENT_LAYERED = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_LAYERED' else
      if FRAMEBUFFER_ATTACHMENT_TEXTURE_SCALE = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_SCALE' else
      if FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS' else
      if FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX = self then
        Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX' else
        Result := $'glFramebufferAttachmentParameterName[{self.val}]';
    end;
    
  end;
  
  glFramebufferParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRAMEBUFFER_DEFAULT_WIDTH:                  glFramebufferParameterName read new glFramebufferParameterName($9310);
    public static property FRAMEBUFFER_DEFAULT_HEIGHT:                 glFramebufferParameterName read new glFramebufferParameterName($9311);
    public static property FRAMEBUFFER_DEFAULT_LAYERS:                 glFramebufferParameterName read new glFramebufferParameterName($9312);
    public static property FRAMEBUFFER_DEFAULT_SAMPLES:                glFramebufferParameterName read new glFramebufferParameterName($9313);
    public static property FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS: glFramebufferParameterName read new glFramebufferParameterName($9314);
    
    public function ToString: string; override;
    begin
      if FRAMEBUFFER_DEFAULT_WIDTH = self then
        Result := 'FRAMEBUFFER_DEFAULT_WIDTH' else
      if FRAMEBUFFER_DEFAULT_HEIGHT = self then
        Result := 'FRAMEBUFFER_DEFAULT_HEIGHT' else
      if FRAMEBUFFER_DEFAULT_LAYERS = self then
        Result := 'FRAMEBUFFER_DEFAULT_LAYERS' else
      if FRAMEBUFFER_DEFAULT_SAMPLES = self then
        Result := 'FRAMEBUFFER_DEFAULT_SAMPLES' else
      if FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS = self then
        Result := 'FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS' else
        Result := $'glFramebufferParameterName[{self.val}]';
    end;
    
  end;
  
  glFramebufferStatus = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRAMEBUFFER_UNDEFINED:                     glFramebufferStatus read new glFramebufferStatus($8219);
    public static property FRAMEBUFFER_COMPLETE:                      glFramebufferStatus read new glFramebufferStatus($8CD5);
    public static property FRAMEBUFFER_INCOMPLETE_ATTACHMENT:         glFramebufferStatus read new glFramebufferStatus($8CD6);
    public static property FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: glFramebufferStatus read new glFramebufferStatus($8CD7);
    public static property FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER:        glFramebufferStatus read new glFramebufferStatus($8CDB);
    public static property FRAMEBUFFER_INCOMPLETE_READ_BUFFER:        glFramebufferStatus read new glFramebufferStatus($8CDC);
    public static property FRAMEBUFFER_UNSUPPORTED:                   glFramebufferStatus read new glFramebufferStatus($8CDD);
    public static property FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:        glFramebufferStatus read new glFramebufferStatus($8D56);
    public static property FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS:      glFramebufferStatus read new glFramebufferStatus($8DA8);
    
    public function ToString: string; override;
    begin
      if FRAMEBUFFER_UNDEFINED = self then
        Result := 'FRAMEBUFFER_UNDEFINED' else
      if FRAMEBUFFER_COMPLETE = self then
        Result := 'FRAMEBUFFER_COMPLETE' else
      if FRAMEBUFFER_INCOMPLETE_ATTACHMENT = self then
        Result := 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT' else
      if FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = self then
        Result := 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT' else
      if FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER = self then
        Result := 'FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER' else
      if FRAMEBUFFER_INCOMPLETE_READ_BUFFER = self then
        Result := 'FRAMEBUFFER_INCOMPLETE_READ_BUFFER' else
      if FRAMEBUFFER_UNSUPPORTED = self then
        Result := 'FRAMEBUFFER_UNSUPPORTED' else
      if FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = self then
        Result := 'FRAMEBUFFER_INCOMPLETE_MULTISAMPLE' else
      if FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS = self then
        Result := 'FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS' else
        Result := $'glFramebufferStatus[{self.val}]';
    end;
    
  end;
  
  glFramebufferTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property READ_FRAMEBUFFER: glFramebufferTarget read new glFramebufferTarget($8CA8);
    public static property DRAW_FRAMEBUFFER: glFramebufferTarget read new glFramebufferTarget($8CA9);
    public static property FRAMEBUFFER:      glFramebufferTarget read new glFramebufferTarget($8D40);
    
    public function ToString: string; override;
    begin
      if READ_FRAMEBUFFER = self then
        Result := 'READ_FRAMEBUFFER' else
      if DRAW_FRAMEBUFFER = self then
        Result := 'DRAW_FRAMEBUFFER' else
      if FRAMEBUFFER = self then
        Result := 'FRAMEBUFFER' else
        Result := $'glFramebufferTarget[{self.val}]';
    end;
    
  end;
  
  glFrontFaceDirection = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CW:  glFrontFaceDirection read new glFrontFaceDirection($0900);
    public static property CCW: glFrontFaceDirection read new glFrontFaceDirection($0901);
    
    public function ToString: string; override;
    begin
      if CW = self then
        Result := 'CW' else
      if CCW = self then
        Result := 'CCW' else
        Result := $'glFrontFaceDirection[{self.val}]';
    end;
    
  end;
  
  glGetFramebufferParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DOUBLEBUFFER:                               glGetFramebufferParameter read new glGetFramebufferParameter($0C32);
    public static property STEREO:                                     glGetFramebufferParameter read new glGetFramebufferParameter($0C33);
    public static property SAMPLE_BUFFERS:                             glGetFramebufferParameter read new glGetFramebufferParameter($80A8);
    public static property SAMPLES:                                    glGetFramebufferParameter read new glGetFramebufferParameter($80A9);
    public static property IMPLEMENTATION_COLOR_READ_TYPE:             glGetFramebufferParameter read new glGetFramebufferParameter($8B9A);
    public static property IMPLEMENTATION_COLOR_READ_FORMAT:           glGetFramebufferParameter read new glGetFramebufferParameter($8B9B);
    public static property FRAMEBUFFER_DEFAULT_WIDTH:                  glGetFramebufferParameter read new glGetFramebufferParameter($9310);
    public static property FRAMEBUFFER_DEFAULT_HEIGHT:                 glGetFramebufferParameter read new glGetFramebufferParameter($9311);
    public static property FRAMEBUFFER_DEFAULT_LAYERS:                 glGetFramebufferParameter read new glGetFramebufferParameter($9312);
    public static property FRAMEBUFFER_DEFAULT_SAMPLES:                glGetFramebufferParameter read new glGetFramebufferParameter($9313);
    public static property FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS: glGetFramebufferParameter read new glGetFramebufferParameter($9314);
    
    public function ToString: string; override;
    begin
      if DOUBLEBUFFER = self then
        Result := 'DOUBLEBUFFER' else
      if STEREO = self then
        Result := 'STEREO' else
      if SAMPLE_BUFFERS = self then
        Result := 'SAMPLE_BUFFERS' else
      if SAMPLES = self then
        Result := 'SAMPLES' else
      if IMPLEMENTATION_COLOR_READ_TYPE = self then
        Result := 'IMPLEMENTATION_COLOR_READ_TYPE' else
      if IMPLEMENTATION_COLOR_READ_FORMAT = self then
        Result := 'IMPLEMENTATION_COLOR_READ_FORMAT' else
      if FRAMEBUFFER_DEFAULT_WIDTH = self then
        Result := 'FRAMEBUFFER_DEFAULT_WIDTH' else
      if FRAMEBUFFER_DEFAULT_HEIGHT = self then
        Result := 'FRAMEBUFFER_DEFAULT_HEIGHT' else
      if FRAMEBUFFER_DEFAULT_LAYERS = self then
        Result := 'FRAMEBUFFER_DEFAULT_LAYERS' else
      if FRAMEBUFFER_DEFAULT_SAMPLES = self then
        Result := 'FRAMEBUFFER_DEFAULT_SAMPLES' else
      if FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS = self then
        Result := 'FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS' else
        Result := $'glGetFramebufferParameter[{self.val}]';
    end;
    
  end;
  
  glGetHistogramParameterPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property HISTOGRAM_WIDTH:          glGetHistogramParameterPName read new glGetHistogramParameterPName($8026);
    public static property HISTOGRAM_FORMAT:         glGetHistogramParameterPName read new glGetHistogramParameterPName($8027);
    public static property HISTOGRAM_RED_SIZE:       glGetHistogramParameterPName read new glGetHistogramParameterPName($8028);
    public static property HISTOGRAM_GREEN_SIZE:     glGetHistogramParameterPName read new glGetHistogramParameterPName($8029);
    public static property HISTOGRAM_BLUE_SIZE:      glGetHistogramParameterPName read new glGetHistogramParameterPName($802A);
    public static property HISTOGRAM_ALPHA_SIZE:     glGetHistogramParameterPName read new glGetHistogramParameterPName($802B);
    public static property HISTOGRAM_LUMINANCE_SIZE: glGetHistogramParameterPName read new glGetHistogramParameterPName($802C);
    public static property HISTOGRAM_SINK:           glGetHistogramParameterPName read new glGetHistogramParameterPName($802D);
    
    public function ToString: string; override;
    begin
      if HISTOGRAM_WIDTH = self then
        Result := 'HISTOGRAM_WIDTH' else
      if HISTOGRAM_FORMAT = self then
        Result := 'HISTOGRAM_FORMAT' else
      if HISTOGRAM_RED_SIZE = self then
        Result := 'HISTOGRAM_RED_SIZE' else
      if HISTOGRAM_GREEN_SIZE = self then
        Result := 'HISTOGRAM_GREEN_SIZE' else
      if HISTOGRAM_BLUE_SIZE = self then
        Result := 'HISTOGRAM_BLUE_SIZE' else
      if HISTOGRAM_ALPHA_SIZE = self then
        Result := 'HISTOGRAM_ALPHA_SIZE' else
      if HISTOGRAM_LUMINANCE_SIZE = self then
        Result := 'HISTOGRAM_LUMINANCE_SIZE' else
      if HISTOGRAM_SINK = self then
        Result := 'HISTOGRAM_SINK' else
        Result := $'glGetHistogramParameterPName[{self.val}]';
    end;
    
  end;
  
  glGetMapQuery = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COEFF:  glGetMapQuery read new glGetMapQuery($0A00);
    public static property ORDER:  glGetMapQuery read new glGetMapQuery($0A01);
    public static property DOMAIN: glGetMapQuery read new glGetMapQuery($0A02);
    
    public function ToString: string; override;
    begin
      if COEFF = self then
        Result := 'COEFF' else
      if ORDER = self then
        Result := 'ORDER' else
      if DOMAIN = self then
        Result := 'DOMAIN' else
        Result := $'glGetMapQuery[{self.val}]';
    end;
    
  end;
  
  glGetMinmaxParameterPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MINMAX_FORMAT: glGetMinmaxParameterPName read new glGetMinmaxParameterPName($802F);
    public static property MINMAX_SINK:   glGetMinmaxParameterPName read new glGetMinmaxParameterPName($8030);
    
    public function ToString: string; override;
    begin
      if MINMAX_FORMAT = self then
        Result := 'MINMAX_FORMAT' else
      if MINMAX_SINK = self then
        Result := 'MINMAX_SINK' else
        Result := $'glGetMinmaxParameterPName[{self.val}]';
    end;
    
  end;
  
  glGetMultisamplePName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SAMPLE_POSITION:              glGetMultisamplePName read new glGetMultisamplePName($8E50);
    public static property SAMPLE_LOCATION:              glGetMultisamplePName read new glGetMultisamplePName($8E50);
    public static property PROGRAMMABLE_SAMPLE_LOCATION: glGetMultisamplePName read new glGetMultisamplePName($9341);
    
    public function ToString: string; override;
    begin
      if SAMPLE_POSITION = self then
        Result := 'SAMPLE_POSITION' else
      if SAMPLE_LOCATION = self then
        Result := 'SAMPLE_LOCATION' else
      if PROGRAMMABLE_SAMPLE_LOCATION = self then
        Result := 'PROGRAMMABLE_SAMPLE_LOCATION' else
        Result := $'glGetMultisamplePName[{self.val}]';
    end;
    
  end;
  
  glGetPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CURRENT_COLOR:                                                       glGetPName read new glGetPName($0B00);
    public static property CURRENT_INDEX:                                                       glGetPName read new glGetPName($0B01);
    public static property CURRENT_NORMAL:                                                      glGetPName read new glGetPName($0B02);
    public static property CURRENT_TEXTURE_COORDS:                                              glGetPName read new glGetPName($0B03);
    public static property CURRENT_RASTER_COLOR:                                                glGetPName read new glGetPName($0B04);
    public static property CURRENT_RASTER_INDEX:                                                glGetPName read new glGetPName($0B05);
    public static property CURRENT_RASTER_TEXTURE_COORDS:                                       glGetPName read new glGetPName($0B06);
    public static property CURRENT_RASTER_POSITION:                                             glGetPName read new glGetPName($0B07);
    public static property CURRENT_RASTER_POSITION_VALID:                                       glGetPName read new glGetPName($0B08);
    public static property CURRENT_RASTER_DISTANCE:                                             glGetPName read new glGetPName($0B09);
    public static property POINT_SMOOTH:                                                        glGetPName read new glGetPName($0B10);
    public static property POINT_SIZE:                                                          glGetPName read new glGetPName($0B11);
    public static property POINT_SIZE_RANGE:                                                    glGetPName read new glGetPName($0B12);
    public static property SMOOTH_POINT_SIZE_RANGE:                                             glGetPName read new glGetPName($0B12);
    public static property POINT_SIZE_GRANULARITY:                                              glGetPName read new glGetPName($0B13);
    public static property SMOOTH_POINT_SIZE_GRANULARITY:                                       glGetPName read new glGetPName($0B13);
    public static property LINE_SMOOTH:                                                         glGetPName read new glGetPName($0B20);
    public static property LINE_WIDTH:                                                          glGetPName read new glGetPName($0B21);
    public static property LINE_WIDTH_RANGE:                                                    glGetPName read new glGetPName($0B22);
    public static property SMOOTH_LINE_WIDTH_RANGE:                                             glGetPName read new glGetPName($0B22);
    public static property LINE_WIDTH_GRANULARITY:                                              glGetPName read new glGetPName($0B23);
    public static property SMOOTH_LINE_WIDTH_GRANULARITY:                                       glGetPName read new glGetPName($0B23);
    public static property LINE_STIPPLE:                                                        glGetPName read new glGetPName($0B24);
    public static property LINE_STIPPLE_PATTERN:                                                glGetPName read new glGetPName($0B25);
    public static property LINE_STIPPLE_REPEAT:                                                 glGetPName read new glGetPName($0B26);
    public static property LIST_MODE:                                                           glGetPName read new glGetPName($0B30);
    public static property MAX_LIST_NESTING:                                                    glGetPName read new glGetPName($0B31);
    public static property LIST_BASE:                                                           glGetPName read new glGetPName($0B32);
    public static property LIST_INDEX:                                                          glGetPName read new glGetPName($0B33);
    public static property POLYGON_MODE:                                                        glGetPName read new glGetPName($0B40);
    public static property POLYGON_SMOOTH:                                                      glGetPName read new glGetPName($0B41);
    public static property POLYGON_STIPPLE:                                                     glGetPName read new glGetPName($0B42);
    public static property EDGE_FLAG:                                                           glGetPName read new glGetPName($0B43);
    public static property CULL_FACE:                                                           glGetPName read new glGetPName($0B44);
    public static property CULL_FACE_MODE:                                                      glGetPName read new glGetPName($0B45);
    public static property FRONT_FACE:                                                          glGetPName read new glGetPName($0B46);
    public static property LIGHTING:                                                            glGetPName read new glGetPName($0B50);
    public static property LIGHT_MODEL_LOCAL_VIEWER:                                            glGetPName read new glGetPName($0B51);
    public static property LIGHT_MODEL_TWO_SIDE:                                                glGetPName read new glGetPName($0B52);
    public static property LIGHT_MODEL_AMBIENT:                                                 glGetPName read new glGetPName($0B53);
    public static property SHADE_MODEL:                                                         glGetPName read new glGetPName($0B54);
    public static property COLOR_MATERIAL_FACE:                                                 glGetPName read new glGetPName($0B55);
    public static property COLOR_MATERIAL_PARAMETER:                                            glGetPName read new glGetPName($0B56);
    public static property COLOR_MATERIAL:                                                      glGetPName read new glGetPName($0B57);
    public static property FOG:                                                                 glGetPName read new glGetPName($0B60);
    public static property FOG_INDEX:                                                           glGetPName read new glGetPName($0B61);
    public static property FOG_DENSITY:                                                         glGetPName read new glGetPName($0B62);
    public static property FOG_START:                                                           glGetPName read new glGetPName($0B63);
    public static property FOG_END:                                                             glGetPName read new glGetPName($0B64);
    public static property FOG_MODE:                                                            glGetPName read new glGetPName($0B65);
    public static property FOG_COLOR:                                                           glGetPName read new glGetPName($0B66);
    public static property DEPTH_RANGE:                                                         glGetPName read new glGetPName($0B70);
    public static property DEPTH_TEST:                                                          glGetPName read new glGetPName($0B71);
    public static property DEPTH_WRITEMASK:                                                     glGetPName read new glGetPName($0B72);
    public static property DEPTH_CLEAR_VALUE:                                                   glGetPName read new glGetPName($0B73);
    public static property DEPTH_FUNC:                                                          glGetPName read new glGetPName($0B74);
    public static property ACCUM_CLEAR_VALUE:                                                   glGetPName read new glGetPName($0B80);
    public static property STENCIL_TEST:                                                        glGetPName read new glGetPName($0B90);
    public static property STENCIL_CLEAR_VALUE:                                                 glGetPName read new glGetPName($0B91);
    public static property STENCIL_FUNC:                                                        glGetPName read new glGetPName($0B92);
    public static property STENCIL_VALUE_MASK:                                                  glGetPName read new glGetPName($0B93);
    public static property STENCIL_FAIL:                                                        glGetPName read new glGetPName($0B94);
    public static property STENCIL_PASS_DEPTH_FAIL:                                             glGetPName read new glGetPName($0B95);
    public static property STENCIL_PASS_DEPTH_PASS:                                             glGetPName read new glGetPName($0B96);
    public static property STENCIL_REF:                                                         glGetPName read new glGetPName($0B97);
    public static property STENCIL_WRITEMASK:                                                   glGetPName read new glGetPName($0B98);
    public static property MATRIX_MODE:                                                         glGetPName read new glGetPName($0BA0);
    public static property NORMALIZE:                                                           glGetPName read new glGetPName($0BA1);
    public static property VIEWPORT:                                                            glGetPName read new glGetPName($0BA2);
    public static property MODELVIEW_STACK_DEPTH:                                               glGetPName read new glGetPName($0BA3);
    public static property MODELVIEW0_STACK_DEPTH:                                              glGetPName read new glGetPName($0BA3);
    public static property PROJECTION_STACK_DEPTH:                                              glGetPName read new glGetPName($0BA4);
    public static property TEXTURE_STACK_DEPTH:                                                 glGetPName read new glGetPName($0BA5);
    public static property MODELVIEW_MATRIX:                                                    glGetPName read new glGetPName($0BA6);
    public static property MODELVIEW0_MATRIX:                                                   glGetPName read new glGetPName($0BA6);
    public static property PROJECTION_MATRIX:                                                   glGetPName read new glGetPName($0BA7);
    public static property TEXTURE_MATRIX:                                                      glGetPName read new glGetPName($0BA8);
    public static property ATTRIB_STACK_DEPTH:                                                  glGetPName read new glGetPName($0BB0);
    public static property CLIENT_ATTRIB_STACK_DEPTH:                                           glGetPName read new glGetPName($0BB1);
    public static property ALPHA_TEST:                                                          glGetPName read new glGetPName($0BC0);
    public static property ALPHA_TEST_FUNC:                                                     glGetPName read new glGetPName($0BC1);
    public static property ALPHA_TEST_REF:                                                      glGetPName read new glGetPName($0BC2);
    public static property DITHER:                                                              glGetPName read new glGetPName($0BD0);
    public static property BLEND_DST:                                                           glGetPName read new glGetPName($0BE0);
    public static property BLEND_SRC:                                                           glGetPName read new glGetPName($0BE1);
    public static property BLEND:                                                               glGetPName read new glGetPName($0BE2);
    public static property LOGIC_OP_MODE:                                                       glGetPName read new glGetPName($0BF0);
    public static property INDEX_LOGIC_OP:                                                      glGetPName read new glGetPName($0BF1);
    public static property LOGIC_OP:                                                            glGetPName read new glGetPName($0BF1);
    public static property COLOR_LOGIC_OP:                                                      glGetPName read new glGetPName($0BF2);
    public static property AUX_BUFFERS:                                                         glGetPName read new glGetPName($0C00);
    public static property DRAW_BUFFER:                                                         glGetPName read new glGetPName($0C01);
    public static property READ_BUFFER:                                                         glGetPName read new glGetPName($0C02);
    public static property SCISSOR_BOX:                                                         glGetPName read new glGetPName($0C10);
    public static property SCISSOR_TEST:                                                        glGetPName read new glGetPName($0C11);
    public static property INDEX_CLEAR_VALUE:                                                   glGetPName read new glGetPName($0C20);
    public static property INDEX_WRITEMASK:                                                     glGetPName read new glGetPName($0C21);
    public static property COLOR_CLEAR_VALUE:                                                   glGetPName read new glGetPName($0C22);
    public static property COLOR_WRITEMASK:                                                     glGetPName read new glGetPName($0C23);
    public static property INDEX_MODE:                                                          glGetPName read new glGetPName($0C30);
    public static property RGBA_MODE:                                                           glGetPName read new glGetPName($0C31);
    public static property DOUBLEBUFFER:                                                        glGetPName read new glGetPName($0C32);
    public static property STEREO:                                                              glGetPName read new glGetPName($0C33);
    public static property RENDER_MODE:                                                         glGetPName read new glGetPName($0C40);
    public static property PERSPECTIVE_CORRECTION_HINT:                                         glGetPName read new glGetPName($0C50);
    public static property POINT_SMOOTH_HINT:                                                   glGetPName read new glGetPName($0C51);
    public static property LINE_SMOOTH_HINT:                                                    glGetPName read new glGetPName($0C52);
    public static property POLYGON_SMOOTH_HINT:                                                 glGetPName read new glGetPName($0C53);
    public static property FOG_HINT:                                                            glGetPName read new glGetPName($0C54);
    public static property TEXTURE_GEN_S:                                                       glGetPName read new glGetPName($0C60);
    public static property TEXTURE_GEN_T:                                                       glGetPName read new glGetPName($0C61);
    public static property TEXTURE_GEN_R:                                                       glGetPName read new glGetPName($0C62);
    public static property TEXTURE_GEN_Q:                                                       glGetPName read new glGetPName($0C63);
    public static property PIXEL_MAP_I_TO_I_SIZE:                                               glGetPName read new glGetPName($0CB0);
    public static property PIXEL_MAP_S_TO_S_SIZE:                                               glGetPName read new glGetPName($0CB1);
    public static property PIXEL_MAP_I_TO_R_SIZE:                                               glGetPName read new glGetPName($0CB2);
    public static property PIXEL_MAP_I_TO_G_SIZE:                                               glGetPName read new glGetPName($0CB3);
    public static property PIXEL_MAP_I_TO_B_SIZE:                                               glGetPName read new glGetPName($0CB4);
    public static property PIXEL_MAP_I_TO_A_SIZE:                                               glGetPName read new glGetPName($0CB5);
    public static property PIXEL_MAP_R_TO_R_SIZE:                                               glGetPName read new glGetPName($0CB6);
    public static property PIXEL_MAP_G_TO_G_SIZE:                                               glGetPName read new glGetPName($0CB7);
    public static property PIXEL_MAP_B_TO_B_SIZE:                                               glGetPName read new glGetPName($0CB8);
    public static property PIXEL_MAP_A_TO_A_SIZE:                                               glGetPName read new glGetPName($0CB9);
    public static property UNPACK_SWAP_BYTES:                                                   glGetPName read new glGetPName($0CF0);
    public static property UNPACK_LSB_FIRST:                                                    glGetPName read new glGetPName($0CF1);
    public static property UNPACK_ROW_LENGTH:                                                   glGetPName read new glGetPName($0CF2);
    public static property UNPACK_SKIP_ROWS:                                                    glGetPName read new glGetPName($0CF3);
    public static property UNPACK_SKIP_PIXELS:                                                  glGetPName read new glGetPName($0CF4);
    public static property UNPACK_ALIGNMENT:                                                    glGetPName read new glGetPName($0CF5);
    public static property PACK_SWAP_BYTES:                                                     glGetPName read new glGetPName($0D00);
    public static property PACK_LSB_FIRST:                                                      glGetPName read new glGetPName($0D01);
    public static property PACK_ROW_LENGTH:                                                     glGetPName read new glGetPName($0D02);
    public static property PACK_SKIP_ROWS:                                                      glGetPName read new glGetPName($0D03);
    public static property PACK_SKIP_PIXELS:                                                    glGetPName read new glGetPName($0D04);
    public static property PACK_ALIGNMENT:                                                      glGetPName read new glGetPName($0D05);
    public static property MAP_COLOR:                                                           glGetPName read new glGetPName($0D10);
    public static property MAP_STENCIL:                                                         glGetPName read new glGetPName($0D11);
    public static property INDEX_SHIFT:                                                         glGetPName read new glGetPName($0D12);
    public static property INDEX_OFFSET:                                                        glGetPName read new glGetPName($0D13);
    public static property RED_SCALE:                                                           glGetPName read new glGetPName($0D14);
    public static property RED_BIAS:                                                            glGetPName read new glGetPName($0D15);
    public static property ZOOM_X:                                                              glGetPName read new glGetPName($0D16);
    public static property ZOOM_Y:                                                              glGetPName read new glGetPName($0D17);
    public static property GREEN_SCALE:                                                         glGetPName read new glGetPName($0D18);
    public static property GREEN_BIAS:                                                          glGetPName read new glGetPName($0D19);
    public static property BLUE_SCALE:                                                          glGetPName read new glGetPName($0D1A);
    public static property BLUE_BIAS:                                                           glGetPName read new glGetPName($0D1B);
    public static property ALPHA_SCALE:                                                         glGetPName read new glGetPName($0D1C);
    public static property ALPHA_BIAS:                                                          glGetPName read new glGetPName($0D1D);
    public static property DEPTH_SCALE:                                                         glGetPName read new glGetPName($0D1E);
    public static property DEPTH_BIAS:                                                          glGetPName read new glGetPName($0D1F);
    public static property MAX_EVAL_ORDER:                                                      glGetPName read new glGetPName($0D30);
    public static property MAX_LIGHTS:                                                          glGetPName read new glGetPName($0D31);
    public static property MAX_CLIP_PLANES:                                                     glGetPName read new glGetPName($0D32);
    public static property MAX_CLIP_DISTANCES:                                                  glGetPName read new glGetPName($0D32);
    public static property MAX_TEXTURE_SIZE:                                                    glGetPName read new glGetPName($0D33);
    public static property MAX_PIXEL_MAP_TABLE:                                                 glGetPName read new glGetPName($0D34);
    public static property MAX_ATTRIB_STACK_DEPTH:                                              glGetPName read new glGetPName($0D35);
    public static property MAX_MODELVIEW_STACK_DEPTH:                                           glGetPName read new glGetPName($0D36);
    public static property MAX_NAME_STACK_DEPTH:                                                glGetPName read new glGetPName($0D37);
    public static property MAX_PROJECTION_STACK_DEPTH:                                          glGetPName read new glGetPName($0D38);
    public static property MAX_TEXTURE_STACK_DEPTH:                                             glGetPName read new glGetPName($0D39);
    public static property MAX_VIEWPORT_DIMS:                                                   glGetPName read new glGetPName($0D3A);
    public static property MAX_CLIENT_ATTRIB_STACK_DEPTH:                                       glGetPName read new glGetPName($0D3B);
    public static property SUBPIXEL_BITS:                                                       glGetPName read new glGetPName($0D50);
    public static property INDEX_BITS:                                                          glGetPName read new glGetPName($0D51);
    public static property RED_BITS:                                                            glGetPName read new glGetPName($0D52);
    public static property GREEN_BITS:                                                          glGetPName read new glGetPName($0D53);
    public static property BLUE_BITS:                                                           glGetPName read new glGetPName($0D54);
    public static property ALPHA_BITS:                                                          glGetPName read new glGetPName($0D55);
    public static property DEPTH_BITS:                                                          glGetPName read new glGetPName($0D56);
    public static property STENCIL_BITS:                                                        glGetPName read new glGetPName($0D57);
    public static property ACCUM_RED_BITS:                                                      glGetPName read new glGetPName($0D58);
    public static property ACCUM_GREEN_BITS:                                                    glGetPName read new glGetPName($0D59);
    public static property ACCUM_BLUE_BITS:                                                     glGetPName read new glGetPName($0D5A);
    public static property ACCUM_ALPHA_BITS:                                                    glGetPName read new glGetPName($0D5B);
    public static property NAME_STACK_DEPTH:                                                    glGetPName read new glGetPName($0D70);
    public static property AUTO_NORMAL:                                                         glGetPName read new glGetPName($0D80);
    public static property MAP1_COLOR_4:                                                        glGetPName read new glGetPName($0D90);
    public static property MAP1_INDEX:                                                          glGetPName read new glGetPName($0D91);
    public static property MAP1_NORMAL:                                                         glGetPName read new glGetPName($0D92);
    public static property MAP1_TEXTURE_COORD_1:                                                glGetPName read new glGetPName($0D93);
    public static property MAP1_TEXTURE_COORD_2:                                                glGetPName read new glGetPName($0D94);
    public static property MAP1_TEXTURE_COORD_3:                                                glGetPName read new glGetPName($0D95);
    public static property MAP1_TEXTURE_COORD_4:                                                glGetPName read new glGetPName($0D96);
    public static property MAP1_VERTEX_3:                                                       glGetPName read new glGetPName($0D97);
    public static property MAP1_VERTEX_4:                                                       glGetPName read new glGetPName($0D98);
    public static property MAP2_COLOR_4:                                                        glGetPName read new glGetPName($0DB0);
    public static property MAP2_INDEX:                                                          glGetPName read new glGetPName($0DB1);
    public static property MAP2_NORMAL:                                                         glGetPName read new glGetPName($0DB2);
    public static property MAP2_TEXTURE_COORD_1:                                                glGetPName read new glGetPName($0DB3);
    public static property MAP2_TEXTURE_COORD_2:                                                glGetPName read new glGetPName($0DB4);
    public static property MAP2_TEXTURE_COORD_3:                                                glGetPName read new glGetPName($0DB5);
    public static property MAP2_TEXTURE_COORD_4:                                                glGetPName read new glGetPName($0DB6);
    public static property MAP2_VERTEX_3:                                                       glGetPName read new glGetPName($0DB7);
    public static property MAP2_VERTEX_4:                                                       glGetPName read new glGetPName($0DB8);
    public static property MAP1_GRID_DOMAIN:                                                    glGetPName read new glGetPName($0DD0);
    public static property MAP1_GRID_SEGMENTS:                                                  glGetPName read new glGetPName($0DD1);
    public static property MAP2_GRID_DOMAIN:                                                    glGetPName read new glGetPName($0DD2);
    public static property MAP2_GRID_SEGMENTS:                                                  glGetPName read new glGetPName($0DD3);
    public static property TEXTURE_1D:                                                          glGetPName read new glGetPName($0DE0);
    public static property TEXTURE_2D:                                                          glGetPName read new glGetPName($0DE1);
    public static property FEEDBACK_BUFFER_SIZE:                                                glGetPName read new glGetPName($0DF1);
    public static property FEEDBACK_BUFFER_TYPE:                                                glGetPName read new glGetPName($0DF2);
    public static property SELECTION_BUFFER_SIZE:                                               glGetPName read new glGetPName($0DF4);
    public static property POLYGON_OFFSET_UNITS:                                                glGetPName read new glGetPName($2A00);
    public static property POLYGON_OFFSET_POINT:                                                glGetPName read new glGetPName($2A01);
    public static property POLYGON_OFFSET_LINE:                                                 glGetPName read new glGetPName($2A02);
    public static property CLIP_PLANE0:                                                         glGetPName read new glGetPName($3000);
    public static property CLIP_PLANE1:                                                         glGetPName read new glGetPName($3001);
    public static property CLIP_PLANE2:                                                         glGetPName read new glGetPName($3002);
    public static property CLIP_PLANE3:                                                         glGetPName read new glGetPName($3003);
    public static property CLIP_PLANE4:                                                         glGetPName read new glGetPName($3004);
    public static property CLIP_PLANE5:                                                         glGetPName read new glGetPName($3005);
    public static property LIGHT0:                                                              glGetPName read new glGetPName($4000);
    public static property LIGHT1:                                                              glGetPName read new glGetPName($4001);
    public static property LIGHT2:                                                              glGetPName read new glGetPName($4002);
    public static property LIGHT3:                                                              glGetPName read new glGetPName($4003);
    public static property LIGHT4:                                                              glGetPName read new glGetPName($4004);
    public static property LIGHT5:                                                              glGetPName read new glGetPName($4005);
    public static property LIGHT6:                                                              glGetPName read new glGetPName($4006);
    public static property LIGHT7:                                                              glGetPName read new glGetPName($4007);
    public static property BLEND_COLOR:                                                         glGetPName read new glGetPName($8005);
    public static property BLEND_EQUATION:                                                      glGetPName read new glGetPName($8009);
    public static property BLEND_EQUATION_RGB:                                                  glGetPName read new glGetPName($8009);
    public static property PACK_CMYK_HINT:                                                      glGetPName read new glGetPName($800E);
    public static property UNPACK_CMYK_HINT:                                                    glGetPName read new glGetPName($800F);
    public static property CONVOLUTION_1D:                                                      glGetPName read new glGetPName($8010);
    public static property CONVOLUTION_2D:                                                      glGetPName read new glGetPName($8011);
    public static property SEPARABLE_2D:                                                        glGetPName read new glGetPName($8012);
    public static property POST_CONVOLUTION_RED_SCALE:                                          glGetPName read new glGetPName($801C);
    public static property POST_CONVOLUTION_GREEN_SCALE:                                        glGetPName read new glGetPName($801D);
    public static property POST_CONVOLUTION_BLUE_SCALE:                                         glGetPName read new glGetPName($801E);
    public static property POST_CONVOLUTION_ALPHA_SCALE:                                        glGetPName read new glGetPName($801F);
    public static property POST_CONVOLUTION_RED_BIAS:                                           glGetPName read new glGetPName($8020);
    public static property POST_CONVOLUTION_GREEN_BIAS:                                         glGetPName read new glGetPName($8021);
    public static property POST_CONVOLUTION_BLUE_BIAS:                                          glGetPName read new glGetPName($8022);
    public static property POST_CONVOLUTION_ALPHA_BIAS:                                         glGetPName read new glGetPName($8023);
    public static property HISTOGRAM:                                                           glGetPName read new glGetPName($8024);
    public static property MINMAX:                                                              glGetPName read new glGetPName($802E);
    public static property POLYGON_OFFSET_FILL:                                                 glGetPName read new glGetPName($8037);
    public static property POLYGON_OFFSET_FACTOR:                                               glGetPName read new glGetPName($8038);
    public static property POLYGON_OFFSET_BIAS:                                                 glGetPName read new glGetPName($8039);
    public static property RESCALE_NORMAL:                                                      glGetPName read new glGetPName($803A);
    public static property TEXTURE_BINDING_1D:                                                  glGetPName read new glGetPName($8068);
    public static property TEXTURE_BINDING_2D:                                                  glGetPName read new glGetPName($8069);
    public static property TEXTURE_3D_BINDING:                                                  glGetPName read new glGetPName($806A);
    public static property TEXTURE_BINDING_3D:                                                  glGetPName read new glGetPName($806A);
    public static property PACK_SKIP_IMAGES:                                                    glGetPName read new glGetPName($806B);
    public static property PACK_IMAGE_HEIGHT:                                                   glGetPName read new glGetPName($806C);
    public static property UNPACK_SKIP_IMAGES:                                                  glGetPName read new glGetPName($806D);
    public static property UNPACK_IMAGE_HEIGHT:                                                 glGetPName read new glGetPName($806E);
    public static property TEXTURE_3D:                                                          glGetPName read new glGetPName($806F);
    public static property MAX_3D_TEXTURE_SIZE:                                                 glGetPName read new glGetPName($8073);
    public static property VERTEX_ARRAY:                                                        glGetPName read new glGetPName($8074);
    public static property NORMAL_ARRAY:                                                        glGetPName read new glGetPName($8075);
    public static property COLOR_ARRAY:                                                         glGetPName read new glGetPName($8076);
    public static property INDEX_ARRAY:                                                         glGetPName read new glGetPName($8077);
    public static property TEXTURE_COORD_ARRAY:                                                 glGetPName read new glGetPName($8078);
    public static property EDGE_FLAG_ARRAY:                                                     glGetPName read new glGetPName($8079);
    public static property VERTEX_ARRAY_SIZE:                                                   glGetPName read new glGetPName($807A);
    public static property VERTEX_ARRAY_TYPE:                                                   glGetPName read new glGetPName($807B);
    public static property VERTEX_ARRAY_STRIDE:                                                 glGetPName read new glGetPName($807C);
    public static property VERTEX_ARRAY_COUNT:                                                  glGetPName read new glGetPName($807D);
    public static property NORMAL_ARRAY_TYPE:                                                   glGetPName read new glGetPName($807E);
    public static property NORMAL_ARRAY_STRIDE:                                                 glGetPName read new glGetPName($807F);
    public static property NORMAL_ARRAY_COUNT:                                                  glGetPName read new glGetPName($8080);
    public static property COLOR_ARRAY_SIZE:                                                    glGetPName read new glGetPName($8081);
    public static property COLOR_ARRAY_TYPE:                                                    glGetPName read new glGetPName($8082);
    public static property COLOR_ARRAY_STRIDE:                                                  glGetPName read new glGetPName($8083);
    public static property COLOR_ARRAY_COUNT:                                                   glGetPName read new glGetPName($8084);
    public static property INDEX_ARRAY_TYPE:                                                    glGetPName read new glGetPName($8085);
    public static property INDEX_ARRAY_STRIDE:                                                  glGetPName read new glGetPName($8086);
    public static property INDEX_ARRAY_COUNT:                                                   glGetPName read new glGetPName($8087);
    public static property TEXTURE_COORD_ARRAY_SIZE:                                            glGetPName read new glGetPName($8088);
    public static property TEXTURE_COORD_ARRAY_TYPE:                                            glGetPName read new glGetPName($8089);
    public static property TEXTURE_COORD_ARRAY_STRIDE:                                          glGetPName read new glGetPName($808A);
    public static property TEXTURE_COORD_ARRAY_COUNT:                                           glGetPName read new glGetPName($808B);
    public static property EDGE_FLAG_ARRAY_STRIDE:                                              glGetPName read new glGetPName($808C);
    public static property EDGE_FLAG_ARRAY_COUNT:                                               glGetPName read new glGetPName($808D);
    public static property INTERLACE_SGIX:                                                      glGetPName read new glGetPName($8094);
    public static property DETAIL_TEXTURE_2D_BINDING:                                           glGetPName read new glGetPName($8096);
    public static property MULTISAMPLE:                                                         glGetPName read new glGetPName($809D);
    public static property SAMPLE_ALPHA_TO_MASK:                                                glGetPName read new glGetPName($809E);
    public static property SAMPLE_ALPHA_TO_ONE:                                                 glGetPName read new glGetPName($809F);
    public static property SAMPLE_MASK_SGIS:                                                    glGetPName read new glGetPName($80A0);
    public static property SAMPLE_BUFFERS:                                                      glGetPName read new glGetPName($80A8);
    public static property SAMPLES:                                                             glGetPName read new glGetPName($80A9);
    public static property SAMPLE_COVERAGE_VALUE:                                               glGetPName read new glGetPName($80AA);
    public static property SAMPLE_MASK_VALUE_SGIS:                                              glGetPName read new glGetPName($80AA);
    public static property SAMPLE_COVERAGE_INVERT:                                              glGetPName read new glGetPName($80AB);
    public static property SAMPLE_MASK_INVERT:                                                  glGetPName read new glGetPName($80AB);
    public static property SAMPLE_PATTERN:                                                      glGetPName read new glGetPName($80AC);
    public static property COLOR_MATRIX:                                                        glGetPName read new glGetPName($80B1);
    public static property COLOR_MATRIX_STACK_DEPTH:                                            glGetPName read new glGetPName($80B2);
    public static property MAX_COLOR_MATRIX_STACK_DEPTH:                                        glGetPName read new glGetPName($80B3);
    public static property POST_COLOR_MATRIX_RED_SCALE:                                         glGetPName read new glGetPName($80B4);
    public static property POST_COLOR_MATRIX_GREEN_SCALE:                                       glGetPName read new glGetPName($80B5);
    public static property POST_COLOR_MATRIX_BLUE_SCALE:                                        glGetPName read new glGetPName($80B6);
    public static property POST_COLOR_MATRIX_ALPHA_SCALE:                                       glGetPName read new glGetPName($80B7);
    public static property POST_COLOR_MATRIX_RED_BIAS:                                          glGetPName read new glGetPName($80B8);
    public static property POST_COLOR_MATRIX_GREEN_BIAS:                                        glGetPName read new glGetPName($80B9);
    public static property POST_COLOR_MATRIX_BLUE_BIAS:                                         glGetPName read new glGetPName($80BA);
    public static property POST_COLOR_MATRIX_ALPHA_BIAS:                                        glGetPName read new glGetPName($80BB);
    public static property TEXTURE_COLOR_TABLE:                                                 glGetPName read new glGetPName($80BC);
    public static property BLEND_DST_RGB:                                                       glGetPName read new glGetPName($80C8);
    public static property BLEND_SRC_RGB:                                                       glGetPName read new glGetPName($80C9);
    public static property BLEND_DST_ALPHA:                                                     glGetPName read new glGetPName($80CA);
    public static property BLEND_SRC_ALPHA:                                                     glGetPName read new glGetPName($80CB);
    public static property COLOR_TABLE:                                                         glGetPName read new glGetPName($80D0);
    public static property POST_CONVOLUTION_COLOR_TABLE:                                        glGetPName read new glGetPName($80D1);
    public static property POST_COLOR_MATRIX_COLOR_TABLE:                                       glGetPName read new glGetPName($80D2);
    public static property MAX_ELEMENTS_VERTICES:                                               glGetPName read new glGetPName($80E8);
    public static property MAX_ELEMENTS_INDICES:                                                glGetPName read new glGetPName($80E9);
    public static property POINT_SIZE_MIN:                                                      glGetPName read new glGetPName($8126);
    public static property POINT_SIZE_MAX:                                                      glGetPName read new glGetPName($8127);
    public static property POINT_FADE_THRESHOLD_SIZE:                                           glGetPName read new glGetPName($8128);
    public static property DISTANCE_ATTENUATION:                                                glGetPName read new glGetPName($8129);
    public static property POINT_DISTANCE_ATTENUATION:                                          glGetPName read new glGetPName($8129);
    public static property FOG_FUNC_POINTS:                                                     glGetPName read new glGetPName($812B);
    public static property MAX_FOG_FUNC_POINTS:                                                 glGetPName read new glGetPName($812C);
    public static property PACK_SKIP_VOLUMES:                                                   glGetPName read new glGetPName($8130);
    public static property PACK_IMAGE_DEPTH:                                                    glGetPName read new glGetPName($8131);
    public static property UNPACK_SKIP_VOLUMES:                                                 glGetPName read new glGetPName($8132);
    public static property UNPACK_IMAGE_DEPTH:                                                  glGetPName read new glGetPName($8133);
    public static property TEXTURE_4D:                                                          glGetPName read new glGetPName($8134);
    public static property MAX_4D_TEXTURE_SIZE:                                                 glGetPName read new glGetPName($8138);
    public static property PIXEL_TEX_GEN:                                                       glGetPName read new glGetPName($8139);
    public static property PIXEL_TILE_BEST_ALIGNMENT:                                           glGetPName read new glGetPName($813E);
    public static property PIXEL_TILE_CACHE_INCREMENT:                                          glGetPName read new glGetPName($813F);
    public static property PIXEL_TILE_WIDTH:                                                    glGetPName read new glGetPName($8140);
    public static property PIXEL_TILE_HEIGHT:                                                   glGetPName read new glGetPName($8141);
    public static property PIXEL_TILE_GRID_WIDTH:                                               glGetPName read new glGetPName($8142);
    public static property PIXEL_TILE_GRID_HEIGHT:                                              glGetPName read new glGetPName($8143);
    public static property PIXEL_TILE_GRID_DEPTH:                                               glGetPName read new glGetPName($8144);
    public static property PIXEL_TILE_CACHE_SIZE:                                               glGetPName read new glGetPName($8145);
    public static property SPRITE:                                                              glGetPName read new glGetPName($8148);
    public static property SPRITE_MODE:                                                         glGetPName read new glGetPName($8149);
    public static property SPRITE_AXIS:                                                         glGetPName read new glGetPName($814A);
    public static property SPRITE_TRANSLATION:                                                  glGetPName read new glGetPName($814B);
    public static property TEXTURE_4D_BINDING:                                                  glGetPName read new glGetPName($814F);
    public static property MAX_CLIPMAP_DEPTH:                                                   glGetPName read new glGetPName($8177);
    public static property MAX_CLIPMAP_VIRTUAL_DEPTH:                                           glGetPName read new glGetPName($8178);
    public static property POST_TEXTURE_FILTER_BIAS_RANGE:                                      glGetPName read new glGetPName($817B);
    public static property POST_TEXTURE_FILTER_SCALE_RANGE:                                     glGetPName read new glGetPName($817C);
    public static property REFERENCE_PLANE:                                                     glGetPName read new glGetPName($817D);
    public static property REFERENCE_PLANE_EQUATION:                                            glGetPName read new glGetPName($817E);
    public static property IR_INSTRUMENT1:                                                      glGetPName read new glGetPName($817F);
    public static property INSTRUMENT_MEASUREMENTS:                                             glGetPName read new glGetPName($8181);
    public static property CALLIGRAPHIC_FRAGMENT:                                               glGetPName read new glGetPName($8183);
    public static property FRAMEZOOM:                                                           glGetPName read new glGetPName($818B);
    public static property FRAMEZOOM_FACTOR:                                                    glGetPName read new glGetPName($818C);
    public static property MAX_FRAMEZOOM_FACTOR:                                                glGetPName read new glGetPName($818D);
    public static property GENERATE_MIPMAP_HINT:                                                glGetPName read new glGetPName($8192);
    public static property DEFORMATIONS_MASK:                                                   glGetPName read new glGetPName($8196);
    public static property FOG_OFFSET:                                                          glGetPName read new glGetPName($8198);
    public static property FOG_OFFSET_VALUE:                                                    glGetPName read new glGetPName($8199);
    public static property LIGHT_MODEL_COLOR_CONTROL:                                           glGetPName read new glGetPName($81F8);
    public static property SHARED_TEXTURE_PALETTE:                                              glGetPName read new glGetPName($81FB);
    public static property MAJOR_VERSION:                                                       glGetPName read new glGetPName($821B);
    public static property MINOR_VERSION:                                                       glGetPName read new glGetPName($821C);
    public static property NUM_EXTENSIONS:                                                      glGetPName read new glGetPName($821D);
    public static property CONTEXT_FLAGS:                                                       glGetPName read new glGetPName($821E);
    public static property PROGRAM_PIPELINE_BINDING:                                            glGetPName read new glGetPName($825A);
    public static property MAX_VIEWPORTS:                                                       glGetPName read new glGetPName($825B);
    public static property VIEWPORT_SUBPIXEL_BITS:                                              glGetPName read new glGetPName($825C);
    public static property VIEWPORT_BOUNDS_RANGE:                                               glGetPName read new glGetPName($825D);
    public static property LAYER_PROVOKING_VERTEX:                                              glGetPName read new glGetPName($825E);
    public static property VIEWPORT_INDEX_PROVOKING_VERTEX:                                     glGetPName read new glGetPName($825F);
    public static property MAX_COMPUTE_UNIFORM_COMPONENTS:                                      glGetPName read new glGetPName($8263);
    public static property MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS:                                  glGetPName read new glGetPName($8264);
    public static property MAX_COMPUTE_ATOMIC_COUNTERS:                                         glGetPName read new glGetPName($8265);
    public static property MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS:                             glGetPName read new glGetPName($8266);
    public static property MAX_DEBUG_GROUP_STACK_DEPTH:                                         glGetPName read new glGetPName($826C);
    public static property DEBUG_GROUP_STACK_DEPTH:                                             glGetPName read new glGetPName($826D);
    public static property MAX_UNIFORM_LOCATIONS:                                               glGetPName read new glGetPName($826E);
    public static property VERTEX_BINDING_DIVISOR:                                              glGetPName read new glGetPName($82D6);
    public static property VERTEX_BINDING_OFFSET:                                               glGetPName read new glGetPName($82D7);
    public static property VERTEX_BINDING_STRIDE:                                               glGetPName read new glGetPName($82D8);
    public static property MAX_VERTEX_ATTRIB_RELATIVE_OFFSET:                                   glGetPName read new glGetPName($82D9);
    public static property MAX_VERTEX_ATTRIB_BINDINGS:                                          glGetPName read new glGetPName($82DA);
    public static property MAX_LABEL_LENGTH:                                                    glGetPName read new glGetPName($82E8);
    public static property CONVOLUTION_HINT:                                                    glGetPName read new glGetPName($8316);
    public static property ASYNC_MARKER:                                                        glGetPName read new glGetPName($8329);
    public static property PIXEL_TEX_GEN_MODE:                                                  glGetPName read new glGetPName($832B);
    public static property ASYNC_HISTOGRAM:                                                     glGetPName read new glGetPName($832C);
    public static property MAX_ASYNC_HISTOGRAM:                                                 glGetPName read new glGetPName($832D);
    public static property PIXEL_TEXTURE:                                                       glGetPName read new glGetPName($8353);
    public static property ASYNC_TEX_IMAGE:                                                     glGetPName read new glGetPName($835C);
    public static property ASYNC_DRAW_PIXELS:                                                   glGetPName read new glGetPName($835D);
    public static property ASYNC_READ_PIXELS:                                                   glGetPName read new glGetPName($835E);
    public static property MAX_ASYNC_TEX_IMAGE:                                                 glGetPName read new glGetPName($835F);
    public static property MAX_ASYNC_DRAW_PIXELS:                                               glGetPName read new glGetPName($8360);
    public static property MAX_ASYNC_READ_PIXELS:                                               glGetPName read new glGetPName($8361);
    public static property VERTEX_PRECLIP:                                                      glGetPName read new glGetPName($83EE);
    public static property VERTEX_PRECLIP_HINT:                                                 glGetPName read new glGetPName($83EF);
    public static property FRAGMENT_LIGHTING:                                                   glGetPName read new glGetPName($8400);
    public static property FRAGMENT_COLOR_MATERIAL:                                             glGetPName read new glGetPName($8401);
    public static property FRAGMENT_COLOR_MATERIAL_FACE:                                        glGetPName read new glGetPName($8402);
    public static property FRAGMENT_COLOR_MATERIAL_PARAMETER:                                   glGetPName read new glGetPName($8403);
    public static property MAX_FRAGMENT_LIGHTS:                                                 glGetPName read new glGetPName($8404);
    public static property MAX_ACTIVE_LIGHTS:                                                   glGetPName read new glGetPName($8405);
    public static property LIGHT_ENV_MODE:                                                      glGetPName read new glGetPName($8407);
    public static property FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER:                                   glGetPName read new glGetPName($8408);
    public static property FRAGMENT_LIGHT_MODEL_TWO_SIDE:                                       glGetPName read new glGetPName($8409);
    public static property FRAGMENT_LIGHT_MODEL_AMBIENT:                                        glGetPName read new glGetPName($840A);
    public static property FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION:                           glGetPName read new glGetPName($840B);
    public static property FRAGMENT_LIGHT0:                                                     glGetPName read new glGetPName($840C);
    public static property PACK_RESAMPLE_SGIX:                                                  glGetPName read new glGetPName($842E);
    public static property UNPACK_RESAMPLE_SGIX:                                                glGetPName read new glGetPName($842F);
    public static property ALIASED_POINT_SIZE_RANGE:                                            glGetPName read new glGetPName($846D);
    public static property ALIASED_LINE_WIDTH_RANGE:                                            glGetPName read new glGetPName($846E);
    public static property ACTIVE_TEXTURE:                                                      glGetPName read new glGetPName($84E0);
    public static property MAX_RENDERBUFFER_SIZE:                                               glGetPName read new glGetPName($84E8);
    public static property TEXTURE_COMPRESSION_HINT:                                            glGetPName read new glGetPName($84EF);
    public static property TEXTURE_BINDING_RECTANGLE:                                           glGetPName read new glGetPName($84F6);
    public static property MAX_RECTANGLE_TEXTURE_SIZE:                                          glGetPName read new glGetPName($84F8);
    public static property MAX_TEXTURE_LOD_BIAS:                                                glGetPName read new glGetPName($84FD);
    public static property TEXTURE_BINDING_CUBE_MAP:                                            glGetPName read new glGetPName($8514);
    public static property MAX_CUBE_MAP_TEXTURE_SIZE:                                           glGetPName read new glGetPName($851C);
    public static property PACK_SUBSAMPLE_RATE:                                                 glGetPName read new glGetPName($85A0);
    public static property UNPACK_SUBSAMPLE_RATE:                                               glGetPName read new glGetPName($85A1);
    public static property VERTEX_ARRAY_BINDING:                                                glGetPName read new glGetPName($85B5);
    public static property PROGRAM_POINT_SIZE:                                                  glGetPName read new glGetPName($8642);
    public static property NUM_COMPRESSED_TEXTURE_FORMATS:                                      glGetPName read new glGetPName($86A2);
    public static property COMPRESSED_TEXTURE_FORMATS:                                          glGetPName read new glGetPName($86A3);
    public static property NUM_PROGRAM_BINARY_FORMATS:                                          glGetPName read new glGetPName($87FE);
    public static property PROGRAM_BINARY_FORMATS:                                              glGetPName read new glGetPName($87FF);
    public static property STENCIL_BACK_FUNC:                                                   glGetPName read new glGetPName($8800);
    public static property STENCIL_BACK_FAIL:                                                   glGetPName read new glGetPName($8801);
    public static property STENCIL_BACK_PASS_DEPTH_FAIL:                                        glGetPName read new glGetPName($8802);
    public static property STENCIL_BACK_PASS_DEPTH_PASS:                                        glGetPName read new glGetPName($8803);
    public static property MAX_DRAW_BUFFERS:                                                    glGetPName read new glGetPName($8824);
    public static property BLEND_EQUATION_ALPHA:                                                glGetPName read new glGetPName($883D);
    public static property MAX_VERTEX_ATTRIBS:                                                  glGetPName read new glGetPName($8869);
    public static property MAX_TEXTURE_IMAGE_UNITS:                                             glGetPName read new glGetPName($8872);
    public static property ARRAY_BUFFER_BINDING:                                                glGetPName read new glGetPName($8894);
    public static property ELEMENT_ARRAY_BUFFER_BINDING:                                        glGetPName read new glGetPName($8895);
    public static property PIXEL_PACK_BUFFER_BINDING:                                           glGetPName read new glGetPName($88ED);
    public static property PIXEL_UNPACK_BUFFER_BINDING:                                         glGetPName read new glGetPName($88EF);
    public static property MAX_DUAL_SOURCE_DRAW_BUFFERS:                                        glGetPName read new glGetPName($88FC);
    public static property MAX_ARRAY_TEXTURE_LAYERS:                                            glGetPName read new glGetPName($88FF);
    public static property MIN_PROGRAM_TEXEL_OFFSET:                                            glGetPName read new glGetPName($8904);
    public static property MAX_PROGRAM_TEXEL_OFFSET:                                            glGetPName read new glGetPName($8905);
    public static property SAMPLER_BINDING:                                                     glGetPName read new glGetPName($8919);
    public static property FRAGMENT_SHADER_ATI:                                                 glGetPName read new glGetPName($8920);
    public static property UNIFORM_BUFFER_BINDING:                                              glGetPName read new glGetPName($8A28);
    public static property UNIFORM_BUFFER_START:                                                glGetPName read new glGetPName($8A29);
    public static property UNIFORM_BUFFER_SIZE:                                                 glGetPName read new glGetPName($8A2A);
    public static property MAX_VERTEX_UNIFORM_BLOCKS:                                           glGetPName read new glGetPName($8A2B);
    public static property MAX_GEOMETRY_UNIFORM_BLOCKS:                                         glGetPName read new glGetPName($8A2C);
    public static property MAX_FRAGMENT_UNIFORM_BLOCKS:                                         glGetPName read new glGetPName($8A2D);
    public static property MAX_COMBINED_UNIFORM_BLOCKS:                                         glGetPName read new glGetPName($8A2E);
    public static property MAX_UNIFORM_BUFFER_BINDINGS:                                         glGetPName read new glGetPName($8A2F);
    public static property MAX_UNIFORM_BLOCK_SIZE:                                              glGetPName read new glGetPName($8A30);
    public static property MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:                              glGetPName read new glGetPName($8A31);
    public static property MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS:                            glGetPName read new glGetPName($8A32);
    public static property MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:                            glGetPName read new glGetPName($8A33);
    public static property UNIFORM_BUFFER_OFFSET_ALIGNMENT:                                     glGetPName read new glGetPName($8A34);
    public static property MAX_FRAGMENT_UNIFORM_COMPONENTS:                                     glGetPName read new glGetPName($8B49);
    public static property MAX_VERTEX_UNIFORM_COMPONENTS:                                       glGetPName read new glGetPName($8B4A);
    public static property MAX_VARYING_FLOATS:                                                  glGetPName read new glGetPName($8B4B);
    public static property MAX_VARYING_COMPONENTS:                                              glGetPName read new glGetPName($8B4B);
    public static property MAX_VERTEX_TEXTURE_IMAGE_UNITS:                                      glGetPName read new glGetPName($8B4C);
    public static property MAX_COMBINED_TEXTURE_IMAGE_UNITS:                                    glGetPName read new glGetPName($8B4D);
    public static property FRAGMENT_SHADER_DERIVATIVE_HINT:                                     glGetPName read new glGetPName($8B8B);
    public static property CURRENT_PROGRAM:                                                     glGetPName read new glGetPName($8B8D);
    public static property IMPLEMENTATION_COLOR_READ_TYPE:                                      glGetPName read new glGetPName($8B9A);
    public static property IMPLEMENTATION_COLOR_READ_FORMAT:                                    glGetPName read new glGetPName($8B9B);
    public static property TEXTURE_BINDING_1D_ARRAY:                                            glGetPName read new glGetPName($8C1C);
    public static property TEXTURE_BINDING_2D_ARRAY:                                            glGetPName read new glGetPName($8C1D);
    public static property MAX_GEOMETRY_TEXTURE_IMAGE_UNITS:                                    glGetPName read new glGetPName($8C29);
    public static property MAX_TEXTURE_BUFFER_SIZE:                                             glGetPName read new glGetPName($8C2B);
    public static property TEXTURE_BINDING_BUFFER:                                              glGetPName read new glGetPName($8C2C);
    public static property TRANSFORM_FEEDBACK_BUFFER_START:                                     glGetPName read new glGetPName($8C84);
    public static property TRANSFORM_FEEDBACK_BUFFER_SIZE:                                      glGetPName read new glGetPName($8C85);
    public static property TRANSFORM_FEEDBACK_BUFFER_BINDING:                                   glGetPName read new glGetPName($8C8F);
    public static property MOTION_ESTIMATION_SEARCH_BLOCK_X:                                    glGetPName read new glGetPName($8C90);
    public static property MOTION_ESTIMATION_SEARCH_BLOCK_Y:                                    glGetPName read new glGetPName($8C91);
    public static property STENCIL_BACK_REF:                                                    glGetPName read new glGetPName($8CA3);
    public static property STENCIL_BACK_VALUE_MASK:                                             glGetPName read new glGetPName($8CA4);
    public static property STENCIL_BACK_WRITEMASK:                                              glGetPName read new glGetPName($8CA5);
    public static property DRAW_FRAMEBUFFER_BINDING:                                            glGetPName read new glGetPName($8CA6);
    public static property RENDERBUFFER_BINDING:                                                glGetPName read new glGetPName($8CA7);
    public static property READ_FRAMEBUFFER_BINDING:                                            glGetPName read new glGetPName($8CAA);
    public static property MAX_COLOR_ATTACHMENTS:                                               glGetPName read new glGetPName($8CDF);
    public static property TEXTURE_GEN_STR:                                                     glGetPName read new glGetPName($8D60);
    public static property MAX_ELEMENT_INDEX:                                                   glGetPName read new glGetPName($8D6B);
    public static property MAX_GEOMETRY_UNIFORM_COMPONENTS:                                     glGetPName read new glGetPName($8DDF);
    public static property SHADER_BINARY_FORMATS:                                               glGetPName read new glGetPName($8DF8);
    public static property NUM_SHADER_BINARY_FORMATS:                                           glGetPName read new glGetPName($8DF9);
    public static property SHADER_COMPILER:                                                     glGetPName read new glGetPName($8DFA);
    public static property MAX_VERTEX_UNIFORM_VECTORS:                                          glGetPName read new glGetPName($8DFB);
    public static property MAX_VARYING_VECTORS:                                                 glGetPName read new glGetPName($8DFC);
    public static property MAX_FRAGMENT_UNIFORM_VECTORS:                                        glGetPName read new glGetPName($8DFD);
    public static property TIMESTAMP:                                                           glGetPName read new glGetPName($8E28);
    public static property PROVOKING_VERTEX:                                                    glGetPName read new glGetPName($8E4F);
    public static property MAX_SAMPLE_MASK_WORDS:                                               glGetPName read new glGetPName($8E59);
    public static property MAX_TESS_CONTROL_UNIFORM_BLOCKS:                                     glGetPName read new glGetPName($8E89);
    public static property MAX_TESS_EVALUATION_UNIFORM_BLOCKS:                                  glGetPName read new glGetPName($8E8A);
    public static property FETCH_PER_SAMPLE:                                                    glGetPName read new glGetPName($8F65);
    public static property FRAGMENT_SHADER_FRAMEBUFFER_FETCH_MRT:                               glGetPName read new glGetPName($8F66);
    public static property FRAGMENT_SHADING_RATE_NON_TRIVIAL_COMBINERS_SUPPORTED:               glGetPName read new glGetPName($8F6F);
    public static property PRIMITIVE_RESTART_INDEX:                                             glGetPName read new glGetPName($8F9E);
    public static property MIN_MAP_BUFFER_ALIGNMENT:                                            glGetPName read new glGetPName($90BC);
    public static property SHADER_STORAGE_BUFFER_BINDING:                                       glGetPName read new glGetPName($90D3);
    public static property SHADER_STORAGE_BUFFER_START:                                         glGetPName read new glGetPName($90D4);
    public static property SHADER_STORAGE_BUFFER_SIZE:                                          glGetPName read new glGetPName($90D5);
    public static property MAX_VERTEX_SHADER_STORAGE_BLOCKS:                                    glGetPName read new glGetPName($90D6);
    public static property MAX_GEOMETRY_SHADER_STORAGE_BLOCKS:                                  glGetPName read new glGetPName($90D7);
    public static property MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS:                              glGetPName read new glGetPName($90D8);
    public static property MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS:                           glGetPName read new glGetPName($90D9);
    public static property MAX_FRAGMENT_SHADER_STORAGE_BLOCKS:                                  glGetPName read new glGetPName($90DA);
    public static property MAX_COMPUTE_SHADER_STORAGE_BLOCKS:                                   glGetPName read new glGetPName($90DB);
    public static property MAX_COMBINED_SHADER_STORAGE_BLOCKS:                                  glGetPName read new glGetPName($90DC);
    public static property MAX_SHADER_STORAGE_BUFFER_BINDINGS:                                  glGetPName read new glGetPName($90DD);
    public static property SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT:                              glGetPName read new glGetPName($90DF);
    public static property MAX_COMPUTE_WORK_GROUP_INVOCATIONS:                                  glGetPName read new glGetPName($90EB);
    public static property DISPATCH_INDIRECT_BUFFER_BINDING:                                    glGetPName read new glGetPName($90EF);
    public static property TEXTURE_BINDING_2D_MULTISAMPLE:                                      glGetPName read new glGetPName($9104);
    public static property TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY:                                glGetPName read new glGetPName($9105);
    public static property MAX_COLOR_TEXTURE_SAMPLES:                                           glGetPName read new glGetPName($910E);
    public static property MAX_DEPTH_TEXTURE_SAMPLES:                                           glGetPName read new glGetPName($910F);
    public static property MAX_INTEGER_SAMPLES:                                                 glGetPName read new glGetPName($9110);
    public static property MAX_SERVER_WAIT_TIMEOUT:                                             glGetPName read new glGetPName($9111);
    public static property MAX_VERTEX_OUTPUT_COMPONENTS:                                        glGetPName read new glGetPName($9122);
    public static property MAX_GEOMETRY_INPUT_COMPONENTS:                                       glGetPName read new glGetPName($9123);
    public static property MAX_GEOMETRY_OUTPUT_COMPONENTS:                                      glGetPName read new glGetPName($9124);
    public static property MAX_FRAGMENT_INPUT_COMPONENTS:                                       glGetPName read new glGetPName($9125);
    public static property CONTEXT_PROFILE_MASK:                                                glGetPName read new glGetPName($9126);
    public static property TEXTURE_BUFFER_OFFSET_ALIGNMENT:                                     glGetPName read new glGetPName($919F);
    public static property MAX_COMPUTE_UNIFORM_BLOCKS:                                          glGetPName read new glGetPName($91BB);
    public static property MAX_COMPUTE_TEXTURE_IMAGE_UNITS:                                     glGetPName read new glGetPName($91BC);
    public static property MAX_COMPUTE_WORK_GROUP_COUNT:                                        glGetPName read new glGetPName($91BE);
    public static property MAX_COMPUTE_WORK_GROUP_SIZE:                                         glGetPName read new glGetPName($91BF);
    public static property MAX_VERTEX_ATOMIC_COUNTERS:                                          glGetPName read new glGetPName($92D2);
    public static property MAX_TESS_CONTROL_ATOMIC_COUNTERS:                                    glGetPName read new glGetPName($92D3);
    public static property MAX_TESS_EVALUATION_ATOMIC_COUNTERS:                                 glGetPName read new glGetPName($92D4);
    public static property MAX_GEOMETRY_ATOMIC_COUNTERS:                                        glGetPName read new glGetPName($92D5);
    public static property MAX_FRAGMENT_ATOMIC_COUNTERS:                                        glGetPName read new glGetPName($92D6);
    public static property MAX_COMBINED_ATOMIC_COUNTERS:                                        glGetPName read new glGetPName($92D7);
    public static property MAX_FRAMEBUFFER_WIDTH:                                               glGetPName read new glGetPName($9315);
    public static property MAX_FRAMEBUFFER_HEIGHT:                                              glGetPName read new glGetPName($9316);
    public static property MAX_FRAMEBUFFER_LAYERS:                                              glGetPName read new glGetPName($9317);
    public static property MAX_FRAMEBUFFER_SAMPLES:                                             glGetPName read new glGetPName($9318);
    public static property NUM_DEVICE_UUIDS:                                                    glGetPName read new glGetPName($9596);
    public static property DEVICE_UUID:                                                         glGetPName read new glGetPName($9597);
    public static property DRIVER_UUID:                                                         glGetPName read new glGetPName($9598);
    public static property DEVICE_LUID:                                                         glGetPName read new glGetPName($9599);
    public static property DEVICE_NODE_MASK:                                                    glGetPName read new glGetPName($959A);
    public static property SHADING_RATE_IMAGE_PER_PRIMITIVE:                                    glGetPName read new glGetPName($95B1);
    public static property SHADING_RATE_IMAGE_PALETTE_COUNT:                                    glGetPName read new glGetPName($95B2);
    public static property MAX_TIMELINE_SEMAPHORE_VALUE_DIFFERENCE:                             glGetPName read new glGetPName($95B6);
    public static property FRAMEBUFFER_FETCH_NONCOHERENT:                                       glGetPName read new glGetPName($96A2);
    public static property SHADING_RATE_QCOM:                                                   glGetPName read new glGetPName($96A4);
    public static property SHADING_RATE_EXT:                                                    glGetPName read new glGetPName($96D0);
    public static property MIN_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_WIDTH:                    glGetPName read new glGetPName($96D7);
    public static property MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_WIDTH:                    glGetPName read new glGetPName($96D8);
    public static property MIN_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_HEIGHT:                   glGetPName read new glGetPName($96D9);
    public static property MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_HEIGHT:                   glGetPName read new glGetPName($96DA);
    public static property MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_ASPECT_RATIO:             glGetPName read new glGetPName($96DB);
    public static property MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_LAYERS:                         glGetPName read new glGetPName($96DC);
    public static property FRAGMENT_SHADING_RATE_WITH_SHADER_DEPTH_STENCIL_WRITES_SUPPORTED:    glGetPName read new glGetPName($96DD);
    public static property FRAGMENT_SHADING_RATE_WITH_SAMPLE_MASK_SUPPORTED:                    glGetPName read new glGetPName($96DE);
    public static property FRAGMENT_SHADING_RATE_ATTACHMENT_WITH_DEFAULT_FRAMEBUFFER_SUPPORTED: glGetPName read new glGetPName($96DF);
    
    public function ToString: string; override;
    begin
      if CURRENT_COLOR = self then
        Result := 'CURRENT_COLOR' else
      if CURRENT_INDEX = self then
        Result := 'CURRENT_INDEX' else
      if CURRENT_NORMAL = self then
        Result := 'CURRENT_NORMAL' else
      if CURRENT_TEXTURE_COORDS = self then
        Result := 'CURRENT_TEXTURE_COORDS' else
      if CURRENT_RASTER_COLOR = self then
        Result := 'CURRENT_RASTER_COLOR' else
      if CURRENT_RASTER_INDEX = self then
        Result := 'CURRENT_RASTER_INDEX' else
      if CURRENT_RASTER_TEXTURE_COORDS = self then
        Result := 'CURRENT_RASTER_TEXTURE_COORDS' else
      if CURRENT_RASTER_POSITION = self then
        Result := 'CURRENT_RASTER_POSITION' else
      if CURRENT_RASTER_POSITION_VALID = self then
        Result := 'CURRENT_RASTER_POSITION_VALID' else
      if CURRENT_RASTER_DISTANCE = self then
        Result := 'CURRENT_RASTER_DISTANCE' else
      if POINT_SMOOTH = self then
        Result := 'POINT_SMOOTH' else
      if POINT_SIZE = self then
        Result := 'POINT_SIZE' else
      if POINT_SIZE_RANGE = self then
        Result := 'POINT_SIZE_RANGE' else
      if SMOOTH_POINT_SIZE_RANGE = self then
        Result := 'SMOOTH_POINT_SIZE_RANGE' else
      if POINT_SIZE_GRANULARITY = self then
        Result := 'POINT_SIZE_GRANULARITY' else
      if SMOOTH_POINT_SIZE_GRANULARITY = self then
        Result := 'SMOOTH_POINT_SIZE_GRANULARITY' else
      if LINE_SMOOTH = self then
        Result := 'LINE_SMOOTH' else
      if LINE_WIDTH = self then
        Result := 'LINE_WIDTH' else
      if LINE_WIDTH_RANGE = self then
        Result := 'LINE_WIDTH_RANGE' else
      if SMOOTH_LINE_WIDTH_RANGE = self then
        Result := 'SMOOTH_LINE_WIDTH_RANGE' else
      if LINE_WIDTH_GRANULARITY = self then
        Result := 'LINE_WIDTH_GRANULARITY' else
      if SMOOTH_LINE_WIDTH_GRANULARITY = self then
        Result := 'SMOOTH_LINE_WIDTH_GRANULARITY' else
      if LINE_STIPPLE = self then
        Result := 'LINE_STIPPLE' else
      if LINE_STIPPLE_PATTERN = self then
        Result := 'LINE_STIPPLE_PATTERN' else
      if LINE_STIPPLE_REPEAT = self then
        Result := 'LINE_STIPPLE_REPEAT' else
      if LIST_MODE = self then
        Result := 'LIST_MODE' else
      if MAX_LIST_NESTING = self then
        Result := 'MAX_LIST_NESTING' else
      if LIST_BASE = self then
        Result := 'LIST_BASE' else
      if LIST_INDEX = self then
        Result := 'LIST_INDEX' else
      if POLYGON_MODE = self then
        Result := 'POLYGON_MODE' else
      if POLYGON_SMOOTH = self then
        Result := 'POLYGON_SMOOTH' else
      if POLYGON_STIPPLE = self then
        Result := 'POLYGON_STIPPLE' else
      if EDGE_FLAG = self then
        Result := 'EDGE_FLAG' else
      if CULL_FACE = self then
        Result := 'CULL_FACE' else
      if CULL_FACE_MODE = self then
        Result := 'CULL_FACE_MODE' else
      if FRONT_FACE = self then
        Result := 'FRONT_FACE' else
      if LIGHTING = self then
        Result := 'LIGHTING' else
      if LIGHT_MODEL_LOCAL_VIEWER = self then
        Result := 'LIGHT_MODEL_LOCAL_VIEWER' else
      if LIGHT_MODEL_TWO_SIDE = self then
        Result := 'LIGHT_MODEL_TWO_SIDE' else
      if LIGHT_MODEL_AMBIENT = self then
        Result := 'LIGHT_MODEL_AMBIENT' else
      if SHADE_MODEL = self then
        Result := 'SHADE_MODEL' else
      if COLOR_MATERIAL_FACE = self then
        Result := 'COLOR_MATERIAL_FACE' else
      if COLOR_MATERIAL_PARAMETER = self then
        Result := 'COLOR_MATERIAL_PARAMETER' else
      if COLOR_MATERIAL = self then
        Result := 'COLOR_MATERIAL' else
      if FOG = self then
        Result := 'FOG' else
      if FOG_INDEX = self then
        Result := 'FOG_INDEX' else
      if FOG_DENSITY = self then
        Result := 'FOG_DENSITY' else
      if FOG_START = self then
        Result := 'FOG_START' else
      if FOG_END = self then
        Result := 'FOG_END' else
      if FOG_MODE = self then
        Result := 'FOG_MODE' else
      if FOG_COLOR = self then
        Result := 'FOG_COLOR' else
      if DEPTH_RANGE = self then
        Result := 'DEPTH_RANGE' else
      if DEPTH_TEST = self then
        Result := 'DEPTH_TEST' else
      if DEPTH_WRITEMASK = self then
        Result := 'DEPTH_WRITEMASK' else
      if DEPTH_CLEAR_VALUE = self then
        Result := 'DEPTH_CLEAR_VALUE' else
      if DEPTH_FUNC = self then
        Result := 'DEPTH_FUNC' else
      if ACCUM_CLEAR_VALUE = self then
        Result := 'ACCUM_CLEAR_VALUE' else
      if STENCIL_TEST = self then
        Result := 'STENCIL_TEST' else
      if STENCIL_CLEAR_VALUE = self then
        Result := 'STENCIL_CLEAR_VALUE' else
      if STENCIL_FUNC = self then
        Result := 'STENCIL_FUNC' else
      if STENCIL_VALUE_MASK = self then
        Result := 'STENCIL_VALUE_MASK' else
      if STENCIL_FAIL = self then
        Result := 'STENCIL_FAIL' else
      if STENCIL_PASS_DEPTH_FAIL = self then
        Result := 'STENCIL_PASS_DEPTH_FAIL' else
      if STENCIL_PASS_DEPTH_PASS = self then
        Result := 'STENCIL_PASS_DEPTH_PASS' else
      if STENCIL_REF = self then
        Result := 'STENCIL_REF' else
      if STENCIL_WRITEMASK = self then
        Result := 'STENCIL_WRITEMASK' else
      if MATRIX_MODE = self then
        Result := 'MATRIX_MODE' else
      if NORMALIZE = self then
        Result := 'NORMALIZE' else
      if VIEWPORT = self then
        Result := 'VIEWPORT' else
      if MODELVIEW_STACK_DEPTH = self then
        Result := 'MODELVIEW_STACK_DEPTH' else
      if MODELVIEW0_STACK_DEPTH = self then
        Result := 'MODELVIEW0_STACK_DEPTH' else
      if PROJECTION_STACK_DEPTH = self then
        Result := 'PROJECTION_STACK_DEPTH' else
      if TEXTURE_STACK_DEPTH = self then
        Result := 'TEXTURE_STACK_DEPTH' else
      if MODELVIEW_MATRIX = self then
        Result := 'MODELVIEW_MATRIX' else
      if MODELVIEW0_MATRIX = self then
        Result := 'MODELVIEW0_MATRIX' else
      if PROJECTION_MATRIX = self then
        Result := 'PROJECTION_MATRIX' else
      if TEXTURE_MATRIX = self then
        Result := 'TEXTURE_MATRIX' else
      if ATTRIB_STACK_DEPTH = self then
        Result := 'ATTRIB_STACK_DEPTH' else
      if CLIENT_ATTRIB_STACK_DEPTH = self then
        Result := 'CLIENT_ATTRIB_STACK_DEPTH' else
      if ALPHA_TEST = self then
        Result := 'ALPHA_TEST' else
      if ALPHA_TEST_FUNC = self then
        Result := 'ALPHA_TEST_FUNC' else
      if ALPHA_TEST_REF = self then
        Result := 'ALPHA_TEST_REF' else
      if DITHER = self then
        Result := 'DITHER' else
      if BLEND_DST = self then
        Result := 'BLEND_DST' else
      if BLEND_SRC = self then
        Result := 'BLEND_SRC' else
      if BLEND = self then
        Result := 'BLEND' else
      if LOGIC_OP_MODE = self then
        Result := 'LOGIC_OP_MODE' else
      if INDEX_LOGIC_OP = self then
        Result := 'INDEX_LOGIC_OP' else
      if LOGIC_OP = self then
        Result := 'LOGIC_OP' else
      if COLOR_LOGIC_OP = self then
        Result := 'COLOR_LOGIC_OP' else
      if AUX_BUFFERS = self then
        Result := 'AUX_BUFFERS' else
      if DRAW_BUFFER = self then
        Result := 'DRAW_BUFFER' else
      if READ_BUFFER = self then
        Result := 'READ_BUFFER' else
      if SCISSOR_BOX = self then
        Result := 'SCISSOR_BOX' else
      if SCISSOR_TEST = self then
        Result := 'SCISSOR_TEST' else
      if INDEX_CLEAR_VALUE = self then
        Result := 'INDEX_CLEAR_VALUE' else
      if INDEX_WRITEMASK = self then
        Result := 'INDEX_WRITEMASK' else
      if COLOR_CLEAR_VALUE = self then
        Result := 'COLOR_CLEAR_VALUE' else
      if COLOR_WRITEMASK = self then
        Result := 'COLOR_WRITEMASK' else
      if INDEX_MODE = self then
        Result := 'INDEX_MODE' else
      if RGBA_MODE = self then
        Result := 'RGBA_MODE' else
      if DOUBLEBUFFER = self then
        Result := 'DOUBLEBUFFER' else
      if STEREO = self then
        Result := 'STEREO' else
      if RENDER_MODE = self then
        Result := 'RENDER_MODE' else
      if PERSPECTIVE_CORRECTION_HINT = self then
        Result := 'PERSPECTIVE_CORRECTION_HINT' else
      if POINT_SMOOTH_HINT = self then
        Result := 'POINT_SMOOTH_HINT' else
      if LINE_SMOOTH_HINT = self then
        Result := 'LINE_SMOOTH_HINT' else
      if POLYGON_SMOOTH_HINT = self then
        Result := 'POLYGON_SMOOTH_HINT' else
      if FOG_HINT = self then
        Result := 'FOG_HINT' else
      if TEXTURE_GEN_S = self then
        Result := 'TEXTURE_GEN_S' else
      if TEXTURE_GEN_T = self then
        Result := 'TEXTURE_GEN_T' else
      if TEXTURE_GEN_R = self then
        Result := 'TEXTURE_GEN_R' else
      if TEXTURE_GEN_Q = self then
        Result := 'TEXTURE_GEN_Q' else
      if PIXEL_MAP_I_TO_I_SIZE = self then
        Result := 'PIXEL_MAP_I_TO_I_SIZE' else
      if PIXEL_MAP_S_TO_S_SIZE = self then
        Result := 'PIXEL_MAP_S_TO_S_SIZE' else
      if PIXEL_MAP_I_TO_R_SIZE = self then
        Result := 'PIXEL_MAP_I_TO_R_SIZE' else
      if PIXEL_MAP_I_TO_G_SIZE = self then
        Result := 'PIXEL_MAP_I_TO_G_SIZE' else
      if PIXEL_MAP_I_TO_B_SIZE = self then
        Result := 'PIXEL_MAP_I_TO_B_SIZE' else
      if PIXEL_MAP_I_TO_A_SIZE = self then
        Result := 'PIXEL_MAP_I_TO_A_SIZE' else
      if PIXEL_MAP_R_TO_R_SIZE = self then
        Result := 'PIXEL_MAP_R_TO_R_SIZE' else
      if PIXEL_MAP_G_TO_G_SIZE = self then
        Result := 'PIXEL_MAP_G_TO_G_SIZE' else
      if PIXEL_MAP_B_TO_B_SIZE = self then
        Result := 'PIXEL_MAP_B_TO_B_SIZE' else
      if PIXEL_MAP_A_TO_A_SIZE = self then
        Result := 'PIXEL_MAP_A_TO_A_SIZE' else
      if UNPACK_SWAP_BYTES = self then
        Result := 'UNPACK_SWAP_BYTES' else
      if UNPACK_LSB_FIRST = self then
        Result := 'UNPACK_LSB_FIRST' else
      if UNPACK_ROW_LENGTH = self then
        Result := 'UNPACK_ROW_LENGTH' else
      if UNPACK_SKIP_ROWS = self then
        Result := 'UNPACK_SKIP_ROWS' else
      if UNPACK_SKIP_PIXELS = self then
        Result := 'UNPACK_SKIP_PIXELS' else
      if UNPACK_ALIGNMENT = self then
        Result := 'UNPACK_ALIGNMENT' else
      if PACK_SWAP_BYTES = self then
        Result := 'PACK_SWAP_BYTES' else
      if PACK_LSB_FIRST = self then
        Result := 'PACK_LSB_FIRST' else
      if PACK_ROW_LENGTH = self then
        Result := 'PACK_ROW_LENGTH' else
      if PACK_SKIP_ROWS = self then
        Result := 'PACK_SKIP_ROWS' else
      if PACK_SKIP_PIXELS = self then
        Result := 'PACK_SKIP_PIXELS' else
      if PACK_ALIGNMENT = self then
        Result := 'PACK_ALIGNMENT' else
      if MAP_COLOR = self then
        Result := 'MAP_COLOR' else
      if MAP_STENCIL = self then
        Result := 'MAP_STENCIL' else
      if INDEX_SHIFT = self then
        Result := 'INDEX_SHIFT' else
      if INDEX_OFFSET = self then
        Result := 'INDEX_OFFSET' else
      if RED_SCALE = self then
        Result := 'RED_SCALE' else
      if RED_BIAS = self then
        Result := 'RED_BIAS' else
      if ZOOM_X = self then
        Result := 'ZOOM_X' else
      if ZOOM_Y = self then
        Result := 'ZOOM_Y' else
      if GREEN_SCALE = self then
        Result := 'GREEN_SCALE' else
      if GREEN_BIAS = self then
        Result := 'GREEN_BIAS' else
      if BLUE_SCALE = self then
        Result := 'BLUE_SCALE' else
      if BLUE_BIAS = self then
        Result := 'BLUE_BIAS' else
      if ALPHA_SCALE = self then
        Result := 'ALPHA_SCALE' else
      if ALPHA_BIAS = self then
        Result := 'ALPHA_BIAS' else
      if DEPTH_SCALE = self then
        Result := 'DEPTH_SCALE' else
      if DEPTH_BIAS = self then
        Result := 'DEPTH_BIAS' else
      if MAX_EVAL_ORDER = self then
        Result := 'MAX_EVAL_ORDER' else
      if MAX_LIGHTS = self then
        Result := 'MAX_LIGHTS' else
      if MAX_CLIP_PLANES = self then
        Result := 'MAX_CLIP_PLANES' else
      if MAX_CLIP_DISTANCES = self then
        Result := 'MAX_CLIP_DISTANCES' else
      if MAX_TEXTURE_SIZE = self then
        Result := 'MAX_TEXTURE_SIZE' else
      if MAX_PIXEL_MAP_TABLE = self then
        Result := 'MAX_PIXEL_MAP_TABLE' else
      if MAX_ATTRIB_STACK_DEPTH = self then
        Result := 'MAX_ATTRIB_STACK_DEPTH' else
      if MAX_MODELVIEW_STACK_DEPTH = self then
        Result := 'MAX_MODELVIEW_STACK_DEPTH' else
      if MAX_NAME_STACK_DEPTH = self then
        Result := 'MAX_NAME_STACK_DEPTH' else
      if MAX_PROJECTION_STACK_DEPTH = self then
        Result := 'MAX_PROJECTION_STACK_DEPTH' else
      if MAX_TEXTURE_STACK_DEPTH = self then
        Result := 'MAX_TEXTURE_STACK_DEPTH' else
      if MAX_VIEWPORT_DIMS = self then
        Result := 'MAX_VIEWPORT_DIMS' else
      if MAX_CLIENT_ATTRIB_STACK_DEPTH = self then
        Result := 'MAX_CLIENT_ATTRIB_STACK_DEPTH' else
      if SUBPIXEL_BITS = self then
        Result := 'SUBPIXEL_BITS' else
      if INDEX_BITS = self then
        Result := 'INDEX_BITS' else
      if RED_BITS = self then
        Result := 'RED_BITS' else
      if GREEN_BITS = self then
        Result := 'GREEN_BITS' else
      if BLUE_BITS = self then
        Result := 'BLUE_BITS' else
      if ALPHA_BITS = self then
        Result := 'ALPHA_BITS' else
      if DEPTH_BITS = self then
        Result := 'DEPTH_BITS' else
      if STENCIL_BITS = self then
        Result := 'STENCIL_BITS' else
      if ACCUM_RED_BITS = self then
        Result := 'ACCUM_RED_BITS' else
      if ACCUM_GREEN_BITS = self then
        Result := 'ACCUM_GREEN_BITS' else
      if ACCUM_BLUE_BITS = self then
        Result := 'ACCUM_BLUE_BITS' else
      if ACCUM_ALPHA_BITS = self then
        Result := 'ACCUM_ALPHA_BITS' else
      if NAME_STACK_DEPTH = self then
        Result := 'NAME_STACK_DEPTH' else
      if AUTO_NORMAL = self then
        Result := 'AUTO_NORMAL' else
      if MAP1_COLOR_4 = self then
        Result := 'MAP1_COLOR_4' else
      if MAP1_INDEX = self then
        Result := 'MAP1_INDEX' else
      if MAP1_NORMAL = self then
        Result := 'MAP1_NORMAL' else
      if MAP1_TEXTURE_COORD_1 = self then
        Result := 'MAP1_TEXTURE_COORD_1' else
      if MAP1_TEXTURE_COORD_2 = self then
        Result := 'MAP1_TEXTURE_COORD_2' else
      if MAP1_TEXTURE_COORD_3 = self then
        Result := 'MAP1_TEXTURE_COORD_3' else
      if MAP1_TEXTURE_COORD_4 = self then
        Result := 'MAP1_TEXTURE_COORD_4' else
      if MAP1_VERTEX_3 = self then
        Result := 'MAP1_VERTEX_3' else
      if MAP1_VERTEX_4 = self then
        Result := 'MAP1_VERTEX_4' else
      if MAP2_COLOR_4 = self then
        Result := 'MAP2_COLOR_4' else
      if MAP2_INDEX = self then
        Result := 'MAP2_INDEX' else
      if MAP2_NORMAL = self then
        Result := 'MAP2_NORMAL' else
      if MAP2_TEXTURE_COORD_1 = self then
        Result := 'MAP2_TEXTURE_COORD_1' else
      if MAP2_TEXTURE_COORD_2 = self then
        Result := 'MAP2_TEXTURE_COORD_2' else
      if MAP2_TEXTURE_COORD_3 = self then
        Result := 'MAP2_TEXTURE_COORD_3' else
      if MAP2_TEXTURE_COORD_4 = self then
        Result := 'MAP2_TEXTURE_COORD_4' else
      if MAP2_VERTEX_3 = self then
        Result := 'MAP2_VERTEX_3' else
      if MAP2_VERTEX_4 = self then
        Result := 'MAP2_VERTEX_4' else
      if MAP1_GRID_DOMAIN = self then
        Result := 'MAP1_GRID_DOMAIN' else
      if MAP1_GRID_SEGMENTS = self then
        Result := 'MAP1_GRID_SEGMENTS' else
      if MAP2_GRID_DOMAIN = self then
        Result := 'MAP2_GRID_DOMAIN' else
      if MAP2_GRID_SEGMENTS = self then
        Result := 'MAP2_GRID_SEGMENTS' else
      if TEXTURE_1D = self then
        Result := 'TEXTURE_1D' else
      if TEXTURE_2D = self then
        Result := 'TEXTURE_2D' else
      if FEEDBACK_BUFFER_SIZE = self then
        Result := 'FEEDBACK_BUFFER_SIZE' else
      if FEEDBACK_BUFFER_TYPE = self then
        Result := 'FEEDBACK_BUFFER_TYPE' else
      if SELECTION_BUFFER_SIZE = self then
        Result := 'SELECTION_BUFFER_SIZE' else
      if POLYGON_OFFSET_UNITS = self then
        Result := 'POLYGON_OFFSET_UNITS' else
      if POLYGON_OFFSET_POINT = self then
        Result := 'POLYGON_OFFSET_POINT' else
      if POLYGON_OFFSET_LINE = self then
        Result := 'POLYGON_OFFSET_LINE' else
      if CLIP_PLANE0 = self then
        Result := 'CLIP_PLANE0' else
      if CLIP_PLANE1 = self then
        Result := 'CLIP_PLANE1' else
      if CLIP_PLANE2 = self then
        Result := 'CLIP_PLANE2' else
      if CLIP_PLANE3 = self then
        Result := 'CLIP_PLANE3' else
      if CLIP_PLANE4 = self then
        Result := 'CLIP_PLANE4' else
      if CLIP_PLANE5 = self then
        Result := 'CLIP_PLANE5' else
      if LIGHT0 = self then
        Result := 'LIGHT0' else
      if LIGHT1 = self then
        Result := 'LIGHT1' else
      if LIGHT2 = self then
        Result := 'LIGHT2' else
      if LIGHT3 = self then
        Result := 'LIGHT3' else
      if LIGHT4 = self then
        Result := 'LIGHT4' else
      if LIGHT5 = self then
        Result := 'LIGHT5' else
      if LIGHT6 = self then
        Result := 'LIGHT6' else
      if LIGHT7 = self then
        Result := 'LIGHT7' else
      if BLEND_COLOR = self then
        Result := 'BLEND_COLOR' else
      if BLEND_EQUATION = self then
        Result := 'BLEND_EQUATION' else
      if BLEND_EQUATION_RGB = self then
        Result := 'BLEND_EQUATION_RGB' else
      if PACK_CMYK_HINT = self then
        Result := 'PACK_CMYK_HINT' else
      if UNPACK_CMYK_HINT = self then
        Result := 'UNPACK_CMYK_HINT' else
      if CONVOLUTION_1D = self then
        Result := 'CONVOLUTION_1D' else
      if CONVOLUTION_2D = self then
        Result := 'CONVOLUTION_2D' else
      if SEPARABLE_2D = self then
        Result := 'SEPARABLE_2D' else
      if POST_CONVOLUTION_RED_SCALE = self then
        Result := 'POST_CONVOLUTION_RED_SCALE' else
      if POST_CONVOLUTION_GREEN_SCALE = self then
        Result := 'POST_CONVOLUTION_GREEN_SCALE' else
      if POST_CONVOLUTION_BLUE_SCALE = self then
        Result := 'POST_CONVOLUTION_BLUE_SCALE' else
      if POST_CONVOLUTION_ALPHA_SCALE = self then
        Result := 'POST_CONVOLUTION_ALPHA_SCALE' else
      if POST_CONVOLUTION_RED_BIAS = self then
        Result := 'POST_CONVOLUTION_RED_BIAS' else
      if POST_CONVOLUTION_GREEN_BIAS = self then
        Result := 'POST_CONVOLUTION_GREEN_BIAS' else
      if POST_CONVOLUTION_BLUE_BIAS = self then
        Result := 'POST_CONVOLUTION_BLUE_BIAS' else
      if POST_CONVOLUTION_ALPHA_BIAS = self then
        Result := 'POST_CONVOLUTION_ALPHA_BIAS' else
      if HISTOGRAM = self then
        Result := 'HISTOGRAM' else
      if MINMAX = self then
        Result := 'MINMAX' else
      if POLYGON_OFFSET_FILL = self then
        Result := 'POLYGON_OFFSET_FILL' else
      if POLYGON_OFFSET_FACTOR = self then
        Result := 'POLYGON_OFFSET_FACTOR' else
      if POLYGON_OFFSET_BIAS = self then
        Result := 'POLYGON_OFFSET_BIAS' else
      if RESCALE_NORMAL = self then
        Result := 'RESCALE_NORMAL' else
      if TEXTURE_BINDING_1D = self then
        Result := 'TEXTURE_BINDING_1D' else
      if TEXTURE_BINDING_2D = self then
        Result := 'TEXTURE_BINDING_2D' else
      if TEXTURE_3D_BINDING = self then
        Result := 'TEXTURE_3D_BINDING' else
      if TEXTURE_BINDING_3D = self then
        Result := 'TEXTURE_BINDING_3D' else
      if PACK_SKIP_IMAGES = self then
        Result := 'PACK_SKIP_IMAGES' else
      if PACK_IMAGE_HEIGHT = self then
        Result := 'PACK_IMAGE_HEIGHT' else
      if UNPACK_SKIP_IMAGES = self then
        Result := 'UNPACK_SKIP_IMAGES' else
      if UNPACK_IMAGE_HEIGHT = self then
        Result := 'UNPACK_IMAGE_HEIGHT' else
      if TEXTURE_3D = self then
        Result := 'TEXTURE_3D' else
      if MAX_3D_TEXTURE_SIZE = self then
        Result := 'MAX_3D_TEXTURE_SIZE' else
      if VERTEX_ARRAY = self then
        Result := 'VERTEX_ARRAY' else
      if NORMAL_ARRAY = self then
        Result := 'NORMAL_ARRAY' else
      if COLOR_ARRAY = self then
        Result := 'COLOR_ARRAY' else
      if INDEX_ARRAY = self then
        Result := 'INDEX_ARRAY' else
      if TEXTURE_COORD_ARRAY = self then
        Result := 'TEXTURE_COORD_ARRAY' else
      if EDGE_FLAG_ARRAY = self then
        Result := 'EDGE_FLAG_ARRAY' else
      if VERTEX_ARRAY_SIZE = self then
        Result := 'VERTEX_ARRAY_SIZE' else
      if VERTEX_ARRAY_TYPE = self then
        Result := 'VERTEX_ARRAY_TYPE' else
      if VERTEX_ARRAY_STRIDE = self then
        Result := 'VERTEX_ARRAY_STRIDE' else
      if VERTEX_ARRAY_COUNT = self then
        Result := 'VERTEX_ARRAY_COUNT' else
      if NORMAL_ARRAY_TYPE = self then
        Result := 'NORMAL_ARRAY_TYPE' else
      if NORMAL_ARRAY_STRIDE = self then
        Result := 'NORMAL_ARRAY_STRIDE' else
      if NORMAL_ARRAY_COUNT = self then
        Result := 'NORMAL_ARRAY_COUNT' else
      if COLOR_ARRAY_SIZE = self then
        Result := 'COLOR_ARRAY_SIZE' else
      if COLOR_ARRAY_TYPE = self then
        Result := 'COLOR_ARRAY_TYPE' else
      if COLOR_ARRAY_STRIDE = self then
        Result := 'COLOR_ARRAY_STRIDE' else
      if COLOR_ARRAY_COUNT = self then
        Result := 'COLOR_ARRAY_COUNT' else
      if INDEX_ARRAY_TYPE = self then
        Result := 'INDEX_ARRAY_TYPE' else
      if INDEX_ARRAY_STRIDE = self then
        Result := 'INDEX_ARRAY_STRIDE' else
      if INDEX_ARRAY_COUNT = self then
        Result := 'INDEX_ARRAY_COUNT' else
      if TEXTURE_COORD_ARRAY_SIZE = self then
        Result := 'TEXTURE_COORD_ARRAY_SIZE' else
      if TEXTURE_COORD_ARRAY_TYPE = self then
        Result := 'TEXTURE_COORD_ARRAY_TYPE' else
      if TEXTURE_COORD_ARRAY_STRIDE = self then
        Result := 'TEXTURE_COORD_ARRAY_STRIDE' else
      if TEXTURE_COORD_ARRAY_COUNT = self then
        Result := 'TEXTURE_COORD_ARRAY_COUNT' else
      if EDGE_FLAG_ARRAY_STRIDE = self then
        Result := 'EDGE_FLAG_ARRAY_STRIDE' else
      if EDGE_FLAG_ARRAY_COUNT = self then
        Result := 'EDGE_FLAG_ARRAY_COUNT' else
      if INTERLACE_SGIX = self then
        Result := 'INTERLACE_SGIX' else
      if DETAIL_TEXTURE_2D_BINDING = self then
        Result := 'DETAIL_TEXTURE_2D_BINDING' else
      if MULTISAMPLE = self then
        Result := 'MULTISAMPLE' else
      if SAMPLE_ALPHA_TO_MASK = self then
        Result := 'SAMPLE_ALPHA_TO_MASK' else
      if SAMPLE_ALPHA_TO_ONE = self then
        Result := 'SAMPLE_ALPHA_TO_ONE' else
      if SAMPLE_MASK_SGIS = self then
        Result := 'SAMPLE_MASK_SGIS' else
      if SAMPLE_BUFFERS = self then
        Result := 'SAMPLE_BUFFERS' else
      if SAMPLES = self then
        Result := 'SAMPLES' else
      if SAMPLE_COVERAGE_VALUE = self then
        Result := 'SAMPLE_COVERAGE_VALUE' else
      if SAMPLE_MASK_VALUE_SGIS = self then
        Result := 'SAMPLE_MASK_VALUE_SGIS' else
      if SAMPLE_COVERAGE_INVERT = self then
        Result := 'SAMPLE_COVERAGE_INVERT' else
      if SAMPLE_MASK_INVERT = self then
        Result := 'SAMPLE_MASK_INVERT' else
      if SAMPLE_PATTERN = self then
        Result := 'SAMPLE_PATTERN' else
      if COLOR_MATRIX = self then
        Result := 'COLOR_MATRIX' else
      if COLOR_MATRIX_STACK_DEPTH = self then
        Result := 'COLOR_MATRIX_STACK_DEPTH' else
      if MAX_COLOR_MATRIX_STACK_DEPTH = self then
        Result := 'MAX_COLOR_MATRIX_STACK_DEPTH' else
      if POST_COLOR_MATRIX_RED_SCALE = self then
        Result := 'POST_COLOR_MATRIX_RED_SCALE' else
      if POST_COLOR_MATRIX_GREEN_SCALE = self then
        Result := 'POST_COLOR_MATRIX_GREEN_SCALE' else
      if POST_COLOR_MATRIX_BLUE_SCALE = self then
        Result := 'POST_COLOR_MATRIX_BLUE_SCALE' else
      if POST_COLOR_MATRIX_ALPHA_SCALE = self then
        Result := 'POST_COLOR_MATRIX_ALPHA_SCALE' else
      if POST_COLOR_MATRIX_RED_BIAS = self then
        Result := 'POST_COLOR_MATRIX_RED_BIAS' else
      if POST_COLOR_MATRIX_GREEN_BIAS = self then
        Result := 'POST_COLOR_MATRIX_GREEN_BIAS' else
      if POST_COLOR_MATRIX_BLUE_BIAS = self then
        Result := 'POST_COLOR_MATRIX_BLUE_BIAS' else
      if POST_COLOR_MATRIX_ALPHA_BIAS = self then
        Result := 'POST_COLOR_MATRIX_ALPHA_BIAS' else
      if TEXTURE_COLOR_TABLE = self then
        Result := 'TEXTURE_COLOR_TABLE' else
      if BLEND_DST_RGB = self then
        Result := 'BLEND_DST_RGB' else
      if BLEND_SRC_RGB = self then
        Result := 'BLEND_SRC_RGB' else
      if BLEND_DST_ALPHA = self then
        Result := 'BLEND_DST_ALPHA' else
      if BLEND_SRC_ALPHA = self then
        Result := 'BLEND_SRC_ALPHA' else
      if COLOR_TABLE = self then
        Result := 'COLOR_TABLE' else
      if POST_CONVOLUTION_COLOR_TABLE = self then
        Result := 'POST_CONVOLUTION_COLOR_TABLE' else
      if POST_COLOR_MATRIX_COLOR_TABLE = self then
        Result := 'POST_COLOR_MATRIX_COLOR_TABLE' else
      if MAX_ELEMENTS_VERTICES = self then
        Result := 'MAX_ELEMENTS_VERTICES' else
      if MAX_ELEMENTS_INDICES = self then
        Result := 'MAX_ELEMENTS_INDICES' else
      if POINT_SIZE_MIN = self then
        Result := 'POINT_SIZE_MIN' else
      if POINT_SIZE_MAX = self then
        Result := 'POINT_SIZE_MAX' else
      if POINT_FADE_THRESHOLD_SIZE = self then
        Result := 'POINT_FADE_THRESHOLD_SIZE' else
      if DISTANCE_ATTENUATION = self then
        Result := 'DISTANCE_ATTENUATION' else
      if POINT_DISTANCE_ATTENUATION = self then
        Result := 'POINT_DISTANCE_ATTENUATION' else
      if FOG_FUNC_POINTS = self then
        Result := 'FOG_FUNC_POINTS' else
      if MAX_FOG_FUNC_POINTS = self then
        Result := 'MAX_FOG_FUNC_POINTS' else
      if PACK_SKIP_VOLUMES = self then
        Result := 'PACK_SKIP_VOLUMES' else
      if PACK_IMAGE_DEPTH = self then
        Result := 'PACK_IMAGE_DEPTH' else
      if UNPACK_SKIP_VOLUMES = self then
        Result := 'UNPACK_SKIP_VOLUMES' else
      if UNPACK_IMAGE_DEPTH = self then
        Result := 'UNPACK_IMAGE_DEPTH' else
      if TEXTURE_4D = self then
        Result := 'TEXTURE_4D' else
      if MAX_4D_TEXTURE_SIZE = self then
        Result := 'MAX_4D_TEXTURE_SIZE' else
      if PIXEL_TEX_GEN = self then
        Result := 'PIXEL_TEX_GEN' else
      if PIXEL_TILE_BEST_ALIGNMENT = self then
        Result := 'PIXEL_TILE_BEST_ALIGNMENT' else
      if PIXEL_TILE_CACHE_INCREMENT = self then
        Result := 'PIXEL_TILE_CACHE_INCREMENT' else
      if PIXEL_TILE_WIDTH = self then
        Result := 'PIXEL_TILE_WIDTH' else
      if PIXEL_TILE_HEIGHT = self then
        Result := 'PIXEL_TILE_HEIGHT' else
      if PIXEL_TILE_GRID_WIDTH = self then
        Result := 'PIXEL_TILE_GRID_WIDTH' else
      if PIXEL_TILE_GRID_HEIGHT = self then
        Result := 'PIXEL_TILE_GRID_HEIGHT' else
      if PIXEL_TILE_GRID_DEPTH = self then
        Result := 'PIXEL_TILE_GRID_DEPTH' else
      if PIXEL_TILE_CACHE_SIZE = self then
        Result := 'PIXEL_TILE_CACHE_SIZE' else
      if SPRITE = self then
        Result := 'SPRITE' else
      if SPRITE_MODE = self then
        Result := 'SPRITE_MODE' else
      if SPRITE_AXIS = self then
        Result := 'SPRITE_AXIS' else
      if SPRITE_TRANSLATION = self then
        Result := 'SPRITE_TRANSLATION' else
      if TEXTURE_4D_BINDING = self then
        Result := 'TEXTURE_4D_BINDING' else
      if MAX_CLIPMAP_DEPTH = self then
        Result := 'MAX_CLIPMAP_DEPTH' else
      if MAX_CLIPMAP_VIRTUAL_DEPTH = self then
        Result := 'MAX_CLIPMAP_VIRTUAL_DEPTH' else
      if POST_TEXTURE_FILTER_BIAS_RANGE = self then
        Result := 'POST_TEXTURE_FILTER_BIAS_RANGE' else
      if POST_TEXTURE_FILTER_SCALE_RANGE = self then
        Result := 'POST_TEXTURE_FILTER_SCALE_RANGE' else
      if REFERENCE_PLANE = self then
        Result := 'REFERENCE_PLANE' else
      if REFERENCE_PLANE_EQUATION = self then
        Result := 'REFERENCE_PLANE_EQUATION' else
      if IR_INSTRUMENT1 = self then
        Result := 'IR_INSTRUMENT1' else
      if INSTRUMENT_MEASUREMENTS = self then
        Result := 'INSTRUMENT_MEASUREMENTS' else
      if CALLIGRAPHIC_FRAGMENT = self then
        Result := 'CALLIGRAPHIC_FRAGMENT' else
      if FRAMEZOOM = self then
        Result := 'FRAMEZOOM' else
      if FRAMEZOOM_FACTOR = self then
        Result := 'FRAMEZOOM_FACTOR' else
      if MAX_FRAMEZOOM_FACTOR = self then
        Result := 'MAX_FRAMEZOOM_FACTOR' else
      if GENERATE_MIPMAP_HINT = self then
        Result := 'GENERATE_MIPMAP_HINT' else
      if DEFORMATIONS_MASK = self then
        Result := 'DEFORMATIONS_MASK' else
      if FOG_OFFSET = self then
        Result := 'FOG_OFFSET' else
      if FOG_OFFSET_VALUE = self then
        Result := 'FOG_OFFSET_VALUE' else
      if LIGHT_MODEL_COLOR_CONTROL = self then
        Result := 'LIGHT_MODEL_COLOR_CONTROL' else
      if SHARED_TEXTURE_PALETTE = self then
        Result := 'SHARED_TEXTURE_PALETTE' else
      if MAJOR_VERSION = self then
        Result := 'MAJOR_VERSION' else
      if MINOR_VERSION = self then
        Result := 'MINOR_VERSION' else
      if NUM_EXTENSIONS = self then
        Result := 'NUM_EXTENSIONS' else
      if CONTEXT_FLAGS = self then
        Result := 'CONTEXT_FLAGS' else
      if PROGRAM_PIPELINE_BINDING = self then
        Result := 'PROGRAM_PIPELINE_BINDING' else
      if MAX_VIEWPORTS = self then
        Result := 'MAX_VIEWPORTS' else
      if VIEWPORT_SUBPIXEL_BITS = self then
        Result := 'VIEWPORT_SUBPIXEL_BITS' else
      if VIEWPORT_BOUNDS_RANGE = self then
        Result := 'VIEWPORT_BOUNDS_RANGE' else
      if LAYER_PROVOKING_VERTEX = self then
        Result := 'LAYER_PROVOKING_VERTEX' else
      if VIEWPORT_INDEX_PROVOKING_VERTEX = self then
        Result := 'VIEWPORT_INDEX_PROVOKING_VERTEX' else
      if MAX_COMPUTE_UNIFORM_COMPONENTS = self then
        Result := 'MAX_COMPUTE_UNIFORM_COMPONENTS' else
      if MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS = self then
        Result := 'MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS' else
      if MAX_COMPUTE_ATOMIC_COUNTERS = self then
        Result := 'MAX_COMPUTE_ATOMIC_COUNTERS' else
      if MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS = self then
        Result := 'MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS' else
      if MAX_DEBUG_GROUP_STACK_DEPTH = self then
        Result := 'MAX_DEBUG_GROUP_STACK_DEPTH' else
      if DEBUG_GROUP_STACK_DEPTH = self then
        Result := 'DEBUG_GROUP_STACK_DEPTH' else
      if MAX_UNIFORM_LOCATIONS = self then
        Result := 'MAX_UNIFORM_LOCATIONS' else
      if VERTEX_BINDING_DIVISOR = self then
        Result := 'VERTEX_BINDING_DIVISOR' else
      if VERTEX_BINDING_OFFSET = self then
        Result := 'VERTEX_BINDING_OFFSET' else
      if VERTEX_BINDING_STRIDE = self then
        Result := 'VERTEX_BINDING_STRIDE' else
      if MAX_VERTEX_ATTRIB_RELATIVE_OFFSET = self then
        Result := 'MAX_VERTEX_ATTRIB_RELATIVE_OFFSET' else
      if MAX_VERTEX_ATTRIB_BINDINGS = self then
        Result := 'MAX_VERTEX_ATTRIB_BINDINGS' else
      if MAX_LABEL_LENGTH = self then
        Result := 'MAX_LABEL_LENGTH' else
      if CONVOLUTION_HINT = self then
        Result := 'CONVOLUTION_HINT' else
      if ASYNC_MARKER = self then
        Result := 'ASYNC_MARKER' else
      if PIXEL_TEX_GEN_MODE = self then
        Result := 'PIXEL_TEX_GEN_MODE' else
      if ASYNC_HISTOGRAM = self then
        Result := 'ASYNC_HISTOGRAM' else
      if MAX_ASYNC_HISTOGRAM = self then
        Result := 'MAX_ASYNC_HISTOGRAM' else
      if PIXEL_TEXTURE = self then
        Result := 'PIXEL_TEXTURE' else
      if ASYNC_TEX_IMAGE = self then
        Result := 'ASYNC_TEX_IMAGE' else
      if ASYNC_DRAW_PIXELS = self then
        Result := 'ASYNC_DRAW_PIXELS' else
      if ASYNC_READ_PIXELS = self then
        Result := 'ASYNC_READ_PIXELS' else
      if MAX_ASYNC_TEX_IMAGE = self then
        Result := 'MAX_ASYNC_TEX_IMAGE' else
      if MAX_ASYNC_DRAW_PIXELS = self then
        Result := 'MAX_ASYNC_DRAW_PIXELS' else
      if MAX_ASYNC_READ_PIXELS = self then
        Result := 'MAX_ASYNC_READ_PIXELS' else
      if VERTEX_PRECLIP = self then
        Result := 'VERTEX_PRECLIP' else
      if VERTEX_PRECLIP_HINT = self then
        Result := 'VERTEX_PRECLIP_HINT' else
      if FRAGMENT_LIGHTING = self then
        Result := 'FRAGMENT_LIGHTING' else
      if FRAGMENT_COLOR_MATERIAL = self then
        Result := 'FRAGMENT_COLOR_MATERIAL' else
      if FRAGMENT_COLOR_MATERIAL_FACE = self then
        Result := 'FRAGMENT_COLOR_MATERIAL_FACE' else
      if FRAGMENT_COLOR_MATERIAL_PARAMETER = self then
        Result := 'FRAGMENT_COLOR_MATERIAL_PARAMETER' else
      if MAX_FRAGMENT_LIGHTS = self then
        Result := 'MAX_FRAGMENT_LIGHTS' else
      if MAX_ACTIVE_LIGHTS = self then
        Result := 'MAX_ACTIVE_LIGHTS' else
      if LIGHT_ENV_MODE = self then
        Result := 'LIGHT_ENV_MODE' else
      if FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER = self then
        Result := 'FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER' else
      if FRAGMENT_LIGHT_MODEL_TWO_SIDE = self then
        Result := 'FRAGMENT_LIGHT_MODEL_TWO_SIDE' else
      if FRAGMENT_LIGHT_MODEL_AMBIENT = self then
        Result := 'FRAGMENT_LIGHT_MODEL_AMBIENT' else
      if FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION = self then
        Result := 'FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION' else
      if FRAGMENT_LIGHT0 = self then
        Result := 'FRAGMENT_LIGHT0' else
      if PACK_RESAMPLE_SGIX = self then
        Result := 'PACK_RESAMPLE_SGIX' else
      if UNPACK_RESAMPLE_SGIX = self then
        Result := 'UNPACK_RESAMPLE_SGIX' else
      if ALIASED_POINT_SIZE_RANGE = self then
        Result := 'ALIASED_POINT_SIZE_RANGE' else
      if ALIASED_LINE_WIDTH_RANGE = self then
        Result := 'ALIASED_LINE_WIDTH_RANGE' else
      if ACTIVE_TEXTURE = self then
        Result := 'ACTIVE_TEXTURE' else
      if MAX_RENDERBUFFER_SIZE = self then
        Result := 'MAX_RENDERBUFFER_SIZE' else
      if TEXTURE_COMPRESSION_HINT = self then
        Result := 'TEXTURE_COMPRESSION_HINT' else
      if TEXTURE_BINDING_RECTANGLE = self then
        Result := 'TEXTURE_BINDING_RECTANGLE' else
      if MAX_RECTANGLE_TEXTURE_SIZE = self then
        Result := 'MAX_RECTANGLE_TEXTURE_SIZE' else
      if MAX_TEXTURE_LOD_BIAS = self then
        Result := 'MAX_TEXTURE_LOD_BIAS' else
      if TEXTURE_BINDING_CUBE_MAP = self then
        Result := 'TEXTURE_BINDING_CUBE_MAP' else
      if MAX_CUBE_MAP_TEXTURE_SIZE = self then
        Result := 'MAX_CUBE_MAP_TEXTURE_SIZE' else
      if PACK_SUBSAMPLE_RATE = self then
        Result := 'PACK_SUBSAMPLE_RATE' else
      if UNPACK_SUBSAMPLE_RATE = self then
        Result := 'UNPACK_SUBSAMPLE_RATE' else
      if VERTEX_ARRAY_BINDING = self then
        Result := 'VERTEX_ARRAY_BINDING' else
      if PROGRAM_POINT_SIZE = self then
        Result := 'PROGRAM_POINT_SIZE' else
      if NUM_COMPRESSED_TEXTURE_FORMATS = self then
        Result := 'NUM_COMPRESSED_TEXTURE_FORMATS' else
      if COMPRESSED_TEXTURE_FORMATS = self then
        Result := 'COMPRESSED_TEXTURE_FORMATS' else
      if NUM_PROGRAM_BINARY_FORMATS = self then
        Result := 'NUM_PROGRAM_BINARY_FORMATS' else
      if PROGRAM_BINARY_FORMATS = self then
        Result := 'PROGRAM_BINARY_FORMATS' else
      if STENCIL_BACK_FUNC = self then
        Result := 'STENCIL_BACK_FUNC' else
      if STENCIL_BACK_FAIL = self then
        Result := 'STENCIL_BACK_FAIL' else
      if STENCIL_BACK_PASS_DEPTH_FAIL = self then
        Result := 'STENCIL_BACK_PASS_DEPTH_FAIL' else
      if STENCIL_BACK_PASS_DEPTH_PASS = self then
        Result := 'STENCIL_BACK_PASS_DEPTH_PASS' else
      if MAX_DRAW_BUFFERS = self then
        Result := 'MAX_DRAW_BUFFERS' else
      if BLEND_EQUATION_ALPHA = self then
        Result := 'BLEND_EQUATION_ALPHA' else
      if MAX_VERTEX_ATTRIBS = self then
        Result := 'MAX_VERTEX_ATTRIBS' else
      if MAX_TEXTURE_IMAGE_UNITS = self then
        Result := 'MAX_TEXTURE_IMAGE_UNITS' else
      if ARRAY_BUFFER_BINDING = self then
        Result := 'ARRAY_BUFFER_BINDING' else
      if ELEMENT_ARRAY_BUFFER_BINDING = self then
        Result := 'ELEMENT_ARRAY_BUFFER_BINDING' else
      if PIXEL_PACK_BUFFER_BINDING = self then
        Result := 'PIXEL_PACK_BUFFER_BINDING' else
      if PIXEL_UNPACK_BUFFER_BINDING = self then
        Result := 'PIXEL_UNPACK_BUFFER_BINDING' else
      if MAX_DUAL_SOURCE_DRAW_BUFFERS = self then
        Result := 'MAX_DUAL_SOURCE_DRAW_BUFFERS' else
      if MAX_ARRAY_TEXTURE_LAYERS = self then
        Result := 'MAX_ARRAY_TEXTURE_LAYERS' else
      if MIN_PROGRAM_TEXEL_OFFSET = self then
        Result := 'MIN_PROGRAM_TEXEL_OFFSET' else
      if MAX_PROGRAM_TEXEL_OFFSET = self then
        Result := 'MAX_PROGRAM_TEXEL_OFFSET' else
      if SAMPLER_BINDING = self then
        Result := 'SAMPLER_BINDING' else
      if FRAGMENT_SHADER_ATI = self then
        Result := 'FRAGMENT_SHADER_ATI' else
      if UNIFORM_BUFFER_BINDING = self then
        Result := 'UNIFORM_BUFFER_BINDING' else
      if UNIFORM_BUFFER_START = self then
        Result := 'UNIFORM_BUFFER_START' else
      if UNIFORM_BUFFER_SIZE = self then
        Result := 'UNIFORM_BUFFER_SIZE' else
      if MAX_VERTEX_UNIFORM_BLOCKS = self then
        Result := 'MAX_VERTEX_UNIFORM_BLOCKS' else
      if MAX_GEOMETRY_UNIFORM_BLOCKS = self then
        Result := 'MAX_GEOMETRY_UNIFORM_BLOCKS' else
      if MAX_FRAGMENT_UNIFORM_BLOCKS = self then
        Result := 'MAX_FRAGMENT_UNIFORM_BLOCKS' else
      if MAX_COMBINED_UNIFORM_BLOCKS = self then
        Result := 'MAX_COMBINED_UNIFORM_BLOCKS' else
      if MAX_UNIFORM_BUFFER_BINDINGS = self then
        Result := 'MAX_UNIFORM_BUFFER_BINDINGS' else
      if MAX_UNIFORM_BLOCK_SIZE = self then
        Result := 'MAX_UNIFORM_BLOCK_SIZE' else
      if MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = self then
        Result := 'MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS' else
      if MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS = self then
        Result := 'MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS' else
      if MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = self then
        Result := 'MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS' else
      if UNIFORM_BUFFER_OFFSET_ALIGNMENT = self then
        Result := 'UNIFORM_BUFFER_OFFSET_ALIGNMENT' else
      if MAX_FRAGMENT_UNIFORM_COMPONENTS = self then
        Result := 'MAX_FRAGMENT_UNIFORM_COMPONENTS' else
      if MAX_VERTEX_UNIFORM_COMPONENTS = self then
        Result := 'MAX_VERTEX_UNIFORM_COMPONENTS' else
      if MAX_VARYING_FLOATS = self then
        Result := 'MAX_VARYING_FLOATS' else
      if MAX_VARYING_COMPONENTS = self then
        Result := 'MAX_VARYING_COMPONENTS' else
      if MAX_VERTEX_TEXTURE_IMAGE_UNITS = self then
        Result := 'MAX_VERTEX_TEXTURE_IMAGE_UNITS' else
      if MAX_COMBINED_TEXTURE_IMAGE_UNITS = self then
        Result := 'MAX_COMBINED_TEXTURE_IMAGE_UNITS' else
      if FRAGMENT_SHADER_DERIVATIVE_HINT = self then
        Result := 'FRAGMENT_SHADER_DERIVATIVE_HINT' else
      if CURRENT_PROGRAM = self then
        Result := 'CURRENT_PROGRAM' else
      if IMPLEMENTATION_COLOR_READ_TYPE = self then
        Result := 'IMPLEMENTATION_COLOR_READ_TYPE' else
      if IMPLEMENTATION_COLOR_READ_FORMAT = self then
        Result := 'IMPLEMENTATION_COLOR_READ_FORMAT' else
      if TEXTURE_BINDING_1D_ARRAY = self then
        Result := 'TEXTURE_BINDING_1D_ARRAY' else
      if TEXTURE_BINDING_2D_ARRAY = self then
        Result := 'TEXTURE_BINDING_2D_ARRAY' else
      if MAX_GEOMETRY_TEXTURE_IMAGE_UNITS = self then
        Result := 'MAX_GEOMETRY_TEXTURE_IMAGE_UNITS' else
      if MAX_TEXTURE_BUFFER_SIZE = self then
        Result := 'MAX_TEXTURE_BUFFER_SIZE' else
      if TEXTURE_BINDING_BUFFER = self then
        Result := 'TEXTURE_BINDING_BUFFER' else
      if TRANSFORM_FEEDBACK_BUFFER_START = self then
        Result := 'TRANSFORM_FEEDBACK_BUFFER_START' else
      if TRANSFORM_FEEDBACK_BUFFER_SIZE = self then
        Result := 'TRANSFORM_FEEDBACK_BUFFER_SIZE' else
      if TRANSFORM_FEEDBACK_BUFFER_BINDING = self then
        Result := 'TRANSFORM_FEEDBACK_BUFFER_BINDING' else
      if MOTION_ESTIMATION_SEARCH_BLOCK_X = self then
        Result := 'MOTION_ESTIMATION_SEARCH_BLOCK_X' else
      if MOTION_ESTIMATION_SEARCH_BLOCK_Y = self then
        Result := 'MOTION_ESTIMATION_SEARCH_BLOCK_Y' else
      if STENCIL_BACK_REF = self then
        Result := 'STENCIL_BACK_REF' else
      if STENCIL_BACK_VALUE_MASK = self then
        Result := 'STENCIL_BACK_VALUE_MASK' else
      if STENCIL_BACK_WRITEMASK = self then
        Result := 'STENCIL_BACK_WRITEMASK' else
      if DRAW_FRAMEBUFFER_BINDING = self then
        Result := 'DRAW_FRAMEBUFFER_BINDING' else
      if RENDERBUFFER_BINDING = self then
        Result := 'RENDERBUFFER_BINDING' else
      if READ_FRAMEBUFFER_BINDING = self then
        Result := 'READ_FRAMEBUFFER_BINDING' else
      if MAX_COLOR_ATTACHMENTS = self then
        Result := 'MAX_COLOR_ATTACHMENTS' else
      if TEXTURE_GEN_STR = self then
        Result := 'TEXTURE_GEN_STR' else
      if MAX_ELEMENT_INDEX = self then
        Result := 'MAX_ELEMENT_INDEX' else
      if MAX_GEOMETRY_UNIFORM_COMPONENTS = self then
        Result := 'MAX_GEOMETRY_UNIFORM_COMPONENTS' else
      if SHADER_BINARY_FORMATS = self then
        Result := 'SHADER_BINARY_FORMATS' else
      if NUM_SHADER_BINARY_FORMATS = self then
        Result := 'NUM_SHADER_BINARY_FORMATS' else
      if SHADER_COMPILER = self then
        Result := 'SHADER_COMPILER' else
      if MAX_VERTEX_UNIFORM_VECTORS = self then
        Result := 'MAX_VERTEX_UNIFORM_VECTORS' else
      if MAX_VARYING_VECTORS = self then
        Result := 'MAX_VARYING_VECTORS' else
      if MAX_FRAGMENT_UNIFORM_VECTORS = self then
        Result := 'MAX_FRAGMENT_UNIFORM_VECTORS' else
      if TIMESTAMP = self then
        Result := 'TIMESTAMP' else
      if PROVOKING_VERTEX = self then
        Result := 'PROVOKING_VERTEX' else
      if MAX_SAMPLE_MASK_WORDS = self then
        Result := 'MAX_SAMPLE_MASK_WORDS' else
      if MAX_TESS_CONTROL_UNIFORM_BLOCKS = self then
        Result := 'MAX_TESS_CONTROL_UNIFORM_BLOCKS' else
      if MAX_TESS_EVALUATION_UNIFORM_BLOCKS = self then
        Result := 'MAX_TESS_EVALUATION_UNIFORM_BLOCKS' else
      if FETCH_PER_SAMPLE = self then
        Result := 'FETCH_PER_SAMPLE' else
      if FRAGMENT_SHADER_FRAMEBUFFER_FETCH_MRT = self then
        Result := 'FRAGMENT_SHADER_FRAMEBUFFER_FETCH_MRT' else
      if FRAGMENT_SHADING_RATE_NON_TRIVIAL_COMBINERS_SUPPORTED = self then
        Result := 'FRAGMENT_SHADING_RATE_NON_TRIVIAL_COMBINERS_SUPPORTED' else
      if PRIMITIVE_RESTART_INDEX = self then
        Result := 'PRIMITIVE_RESTART_INDEX' else
      if MIN_MAP_BUFFER_ALIGNMENT = self then
        Result := 'MIN_MAP_BUFFER_ALIGNMENT' else
      if SHADER_STORAGE_BUFFER_BINDING = self then
        Result := 'SHADER_STORAGE_BUFFER_BINDING' else
      if SHADER_STORAGE_BUFFER_START = self then
        Result := 'SHADER_STORAGE_BUFFER_START' else
      if SHADER_STORAGE_BUFFER_SIZE = self then
        Result := 'SHADER_STORAGE_BUFFER_SIZE' else
      if MAX_VERTEX_SHADER_STORAGE_BLOCKS = self then
        Result := 'MAX_VERTEX_SHADER_STORAGE_BLOCKS' else
      if MAX_GEOMETRY_SHADER_STORAGE_BLOCKS = self then
        Result := 'MAX_GEOMETRY_SHADER_STORAGE_BLOCKS' else
      if MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS = self then
        Result := 'MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS' else
      if MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS = self then
        Result := 'MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS' else
      if MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = self then
        Result := 'MAX_FRAGMENT_SHADER_STORAGE_BLOCKS' else
      if MAX_COMPUTE_SHADER_STORAGE_BLOCKS = self then
        Result := 'MAX_COMPUTE_SHADER_STORAGE_BLOCKS' else
      if MAX_COMBINED_SHADER_STORAGE_BLOCKS = self then
        Result := 'MAX_COMBINED_SHADER_STORAGE_BLOCKS' else
      if MAX_SHADER_STORAGE_BUFFER_BINDINGS = self then
        Result := 'MAX_SHADER_STORAGE_BUFFER_BINDINGS' else
      if SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT = self then
        Result := 'SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT' else
      if MAX_COMPUTE_WORK_GROUP_INVOCATIONS = self then
        Result := 'MAX_COMPUTE_WORK_GROUP_INVOCATIONS' else
      if DISPATCH_INDIRECT_BUFFER_BINDING = self then
        Result := 'DISPATCH_INDIRECT_BUFFER_BINDING' else
      if TEXTURE_BINDING_2D_MULTISAMPLE = self then
        Result := 'TEXTURE_BINDING_2D_MULTISAMPLE' else
      if TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY = self then
        Result := 'TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY' else
      if MAX_COLOR_TEXTURE_SAMPLES = self then
        Result := 'MAX_COLOR_TEXTURE_SAMPLES' else
      if MAX_DEPTH_TEXTURE_SAMPLES = self then
        Result := 'MAX_DEPTH_TEXTURE_SAMPLES' else
      if MAX_INTEGER_SAMPLES = self then
        Result := 'MAX_INTEGER_SAMPLES' else
      if MAX_SERVER_WAIT_TIMEOUT = self then
        Result := 'MAX_SERVER_WAIT_TIMEOUT' else
      if MAX_VERTEX_OUTPUT_COMPONENTS = self then
        Result := 'MAX_VERTEX_OUTPUT_COMPONENTS' else
      if MAX_GEOMETRY_INPUT_COMPONENTS = self then
        Result := 'MAX_GEOMETRY_INPUT_COMPONENTS' else
      if MAX_GEOMETRY_OUTPUT_COMPONENTS = self then
        Result := 'MAX_GEOMETRY_OUTPUT_COMPONENTS' else
      if MAX_FRAGMENT_INPUT_COMPONENTS = self then
        Result := 'MAX_FRAGMENT_INPUT_COMPONENTS' else
      if CONTEXT_PROFILE_MASK = self then
        Result := 'CONTEXT_PROFILE_MASK' else
      if TEXTURE_BUFFER_OFFSET_ALIGNMENT = self then
        Result := 'TEXTURE_BUFFER_OFFSET_ALIGNMENT' else
      if MAX_COMPUTE_UNIFORM_BLOCKS = self then
        Result := 'MAX_COMPUTE_UNIFORM_BLOCKS' else
      if MAX_COMPUTE_TEXTURE_IMAGE_UNITS = self then
        Result := 'MAX_COMPUTE_TEXTURE_IMAGE_UNITS' else
      if MAX_COMPUTE_WORK_GROUP_COUNT = self then
        Result := 'MAX_COMPUTE_WORK_GROUP_COUNT' else
      if MAX_COMPUTE_WORK_GROUP_SIZE = self then
        Result := 'MAX_COMPUTE_WORK_GROUP_SIZE' else
      if MAX_VERTEX_ATOMIC_COUNTERS = self then
        Result := 'MAX_VERTEX_ATOMIC_COUNTERS' else
      if MAX_TESS_CONTROL_ATOMIC_COUNTERS = self then
        Result := 'MAX_TESS_CONTROL_ATOMIC_COUNTERS' else
      if MAX_TESS_EVALUATION_ATOMIC_COUNTERS = self then
        Result := 'MAX_TESS_EVALUATION_ATOMIC_COUNTERS' else
      if MAX_GEOMETRY_ATOMIC_COUNTERS = self then
        Result := 'MAX_GEOMETRY_ATOMIC_COUNTERS' else
      if MAX_FRAGMENT_ATOMIC_COUNTERS = self then
        Result := 'MAX_FRAGMENT_ATOMIC_COUNTERS' else
      if MAX_COMBINED_ATOMIC_COUNTERS = self then
        Result := 'MAX_COMBINED_ATOMIC_COUNTERS' else
      if MAX_FRAMEBUFFER_WIDTH = self then
        Result := 'MAX_FRAMEBUFFER_WIDTH' else
      if MAX_FRAMEBUFFER_HEIGHT = self then
        Result := 'MAX_FRAMEBUFFER_HEIGHT' else
      if MAX_FRAMEBUFFER_LAYERS = self then
        Result := 'MAX_FRAMEBUFFER_LAYERS' else
      if MAX_FRAMEBUFFER_SAMPLES = self then
        Result := 'MAX_FRAMEBUFFER_SAMPLES' else
      if NUM_DEVICE_UUIDS = self then
        Result := 'NUM_DEVICE_UUIDS' else
      if DEVICE_UUID = self then
        Result := 'DEVICE_UUID' else
      if DRIVER_UUID = self then
        Result := 'DRIVER_UUID' else
      if DEVICE_LUID = self then
        Result := 'DEVICE_LUID' else
      if DEVICE_NODE_MASK = self then
        Result := 'DEVICE_NODE_MASK' else
      if SHADING_RATE_IMAGE_PER_PRIMITIVE = self then
        Result := 'SHADING_RATE_IMAGE_PER_PRIMITIVE' else
      if SHADING_RATE_IMAGE_PALETTE_COUNT = self then
        Result := 'SHADING_RATE_IMAGE_PALETTE_COUNT' else
      if MAX_TIMELINE_SEMAPHORE_VALUE_DIFFERENCE = self then
        Result := 'MAX_TIMELINE_SEMAPHORE_VALUE_DIFFERENCE' else
      if FRAMEBUFFER_FETCH_NONCOHERENT = self then
        Result := 'FRAMEBUFFER_FETCH_NONCOHERENT' else
      if SHADING_RATE_QCOM = self then
        Result := 'SHADING_RATE_QCOM' else
      if SHADING_RATE_EXT = self then
        Result := 'SHADING_RATE_EXT' else
      if MIN_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_WIDTH = self then
        Result := 'MIN_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_WIDTH' else
      if MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_WIDTH = self then
        Result := 'MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_WIDTH' else
      if MIN_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_HEIGHT = self then
        Result := 'MIN_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_HEIGHT' else
      if MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_HEIGHT = self then
        Result := 'MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_HEIGHT' else
      if MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_ASPECT_RATIO = self then
        Result := 'MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_ASPECT_RATIO' else
      if MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_LAYERS = self then
        Result := 'MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_LAYERS' else
      if FRAGMENT_SHADING_RATE_WITH_SHADER_DEPTH_STENCIL_WRITES_SUPPORTED = self then
        Result := 'FRAGMENT_SHADING_RATE_WITH_SHADER_DEPTH_STENCIL_WRITES_SUPPORTED' else
      if FRAGMENT_SHADING_RATE_WITH_SAMPLE_MASK_SUPPORTED = self then
        Result := 'FRAGMENT_SHADING_RATE_WITH_SAMPLE_MASK_SUPPORTED' else
      if FRAGMENT_SHADING_RATE_ATTACHMENT_WITH_DEFAULT_FRAMEBUFFER_SUPPORTED = self then
        Result := 'FRAGMENT_SHADING_RATE_ATTACHMENT_WITH_DEFAULT_FRAMEBUFFER_SUPPORTED' else
        Result := $'glGetPName[{self.val}]';
    end;
    
  end;
  
  glGetPointervPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FEEDBACK_BUFFER_POINTER:     glGetPointervPName read new glGetPointervPName($0DF0);
    public static property SELECTION_BUFFER_POINTER:    glGetPointervPName read new glGetPointervPName($0DF3);
    public static property VERTEX_ARRAY_POINTER:        glGetPointervPName read new glGetPointervPName($808E);
    public static property NORMAL_ARRAY_POINTER:        glGetPointervPName read new glGetPointervPName($808F);
    public static property COLOR_ARRAY_POINTER:         glGetPointervPName read new glGetPointervPName($8090);
    public static property INDEX_ARRAY_POINTER:         glGetPointervPName read new glGetPointervPName($8091);
    public static property TEXTURE_COORD_ARRAY_POINTER: glGetPointervPName read new glGetPointervPName($8092);
    public static property EDGE_FLAG_ARRAY_POINTER:     glGetPointervPName read new glGetPointervPName($8093);
    public static property INSTRUMENT_BUFFER_POINTER:   glGetPointervPName read new glGetPointervPName($8180);
    public static property DEBUG_CALLBACK_FUNCTION:     glGetPointervPName read new glGetPointervPName($8244);
    public static property DEBUG_CALLBACK_USER_PARAM:   glGetPointervPName read new glGetPointervPName($8245);
    
    public function ToString: string; override;
    begin
      if FEEDBACK_BUFFER_POINTER = self then
        Result := 'FEEDBACK_BUFFER_POINTER' else
      if SELECTION_BUFFER_POINTER = self then
        Result := 'SELECTION_BUFFER_POINTER' else
      if VERTEX_ARRAY_POINTER = self then
        Result := 'VERTEX_ARRAY_POINTER' else
      if NORMAL_ARRAY_POINTER = self then
        Result := 'NORMAL_ARRAY_POINTER' else
      if COLOR_ARRAY_POINTER = self then
        Result := 'COLOR_ARRAY_POINTER' else
      if INDEX_ARRAY_POINTER = self then
        Result := 'INDEX_ARRAY_POINTER' else
      if TEXTURE_COORD_ARRAY_POINTER = self then
        Result := 'TEXTURE_COORD_ARRAY_POINTER' else
      if EDGE_FLAG_ARRAY_POINTER = self then
        Result := 'EDGE_FLAG_ARRAY_POINTER' else
      if INSTRUMENT_BUFFER_POINTER = self then
        Result := 'INSTRUMENT_BUFFER_POINTER' else
      if DEBUG_CALLBACK_FUNCTION = self then
        Result := 'DEBUG_CALLBACK_FUNCTION' else
      if DEBUG_CALLBACK_USER_PARAM = self then
        Result := 'DEBUG_CALLBACK_USER_PARAM' else
        Result := $'glGetPointervPName[{self.val}]';
    end;
    
  end;
  
  glGetTexBumpParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BUMP_ROT_MATRIX:      glGetTexBumpParameter read new glGetTexBumpParameter($8775);
    public static property BUMP_ROT_MATRIX_SIZE: glGetTexBumpParameter read new glGetTexBumpParameter($8776);
    public static property BUMP_NUM_TEX_UNITS:   glGetTexBumpParameter read new glGetTexBumpParameter($8777);
    public static property BUMP_TEX_UNITS:       glGetTexBumpParameter read new glGetTexBumpParameter($8778);
    
    public function ToString: string; override;
    begin
      if BUMP_ROT_MATRIX = self then
        Result := 'BUMP_ROT_MATRIX' else
      if BUMP_ROT_MATRIX_SIZE = self then
        Result := 'BUMP_ROT_MATRIX_SIZE' else
      if BUMP_NUM_TEX_UNITS = self then
        Result := 'BUMP_NUM_TEX_UNITS' else
      if BUMP_TEX_UNITS = self then
        Result := 'BUMP_TEX_UNITS' else
        Result := $'glGetTexBumpParameter[{self.val}]';
    end;
    
  end;
  
  glGetTextureParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_WIDTH:                    glGetTextureParameter read new glGetTextureParameter($1000);
    public static property TEXTURE_HEIGHT:                   glGetTextureParameter read new glGetTextureParameter($1001);
    public static property TEXTURE_INTERNAL_FORMAT:          glGetTextureParameter read new glGetTextureParameter($1003);
    public static property TEXTURE_COMPONENTS:               glGetTextureParameter read new glGetTextureParameter($1003);
    public static property TEXTURE_BORDER_COLOR:             glGetTextureParameter read new glGetTextureParameter($1004);
    public static property TEXTURE_BORDER:                   glGetTextureParameter read new glGetTextureParameter($1005);
    public static property TEXTURE_MAG_FILTER:               glGetTextureParameter read new glGetTextureParameter($2800);
    public static property TEXTURE_MIN_FILTER:               glGetTextureParameter read new glGetTextureParameter($2801);
    public static property TEXTURE_WRAP_S:                   glGetTextureParameter read new glGetTextureParameter($2802);
    public static property TEXTURE_WRAP_T:                   glGetTextureParameter read new glGetTextureParameter($2803);
    public static property TEXTURE_RED_SIZE:                 glGetTextureParameter read new glGetTextureParameter($805C);
    public static property TEXTURE_GREEN_SIZE:               glGetTextureParameter read new glGetTextureParameter($805D);
    public static property TEXTURE_BLUE_SIZE:                glGetTextureParameter read new glGetTextureParameter($805E);
    public static property TEXTURE_ALPHA_SIZE:               glGetTextureParameter read new glGetTextureParameter($805F);
    public static property TEXTURE_LUMINANCE_SIZE:           glGetTextureParameter read new glGetTextureParameter($8060);
    public static property TEXTURE_INTENSITY_SIZE:           glGetTextureParameter read new glGetTextureParameter($8061);
    public static property TEXTURE_PRIORITY:                 glGetTextureParameter read new glGetTextureParameter($8066);
    public static property TEXTURE_RESIDENT:                 glGetTextureParameter read new glGetTextureParameter($8067);
    public static property TEXTURE_DEPTH:                    glGetTextureParameter read new glGetTextureParameter($8071);
    public static property TEXTURE_WRAP_R:                   glGetTextureParameter read new glGetTextureParameter($8072);
    public static property DETAIL_TEXTURE_LEVEL:             glGetTextureParameter read new glGetTextureParameter($809A);
    public static property DETAIL_TEXTURE_MODE:              glGetTextureParameter read new glGetTextureParameter($809B);
    public static property DETAIL_TEXTURE_FUNC_POINTS:       glGetTextureParameter read new glGetTextureParameter($809C);
    public static property SHARPEN_TEXTURE_FUNC_POINTS:      glGetTextureParameter read new glGetTextureParameter($80B0);
    public static property SHADOW_AMBIENT:                   glGetTextureParameter read new glGetTextureParameter($80BF);
    public static property DUAL_TEXTURE_SELECT:              glGetTextureParameter read new glGetTextureParameter($8124);
    public static property QUAD_TEXTURE_SELECT:              glGetTextureParameter read new glGetTextureParameter($8125);
    public static property TEXTURE_4DSIZE:                   glGetTextureParameter read new glGetTextureParameter($8136);
    public static property TEXTURE_WRAP_Q:                   glGetTextureParameter read new glGetTextureParameter($8137);
    public static property TEXTURE_MIN_LOD:                  glGetTextureParameter read new glGetTextureParameter($813A);
    public static property TEXTURE_MAX_LOD:                  glGetTextureParameter read new glGetTextureParameter($813B);
    public static property TEXTURE_BASE_LEVEL:               glGetTextureParameter read new glGetTextureParameter($813C);
    public static property TEXTURE_MAX_LEVEL:                glGetTextureParameter read new glGetTextureParameter($813D);
    public static property TEXTURE_FILTER4_SIZE:             glGetTextureParameter read new glGetTextureParameter($8147);
    public static property TEXTURE_CLIPMAP_CENTER:           glGetTextureParameter read new glGetTextureParameter($8171);
    public static property TEXTURE_CLIPMAP_FRAME:            glGetTextureParameter read new glGetTextureParameter($8172);
    public static property TEXTURE_CLIPMAP_OFFSET:           glGetTextureParameter read new glGetTextureParameter($8173);
    public static property TEXTURE_CLIPMAP_VIRTUAL_DEPTH:    glGetTextureParameter read new glGetTextureParameter($8174);
    public static property TEXTURE_CLIPMAP_LOD_OFFSET:       glGetTextureParameter read new glGetTextureParameter($8175);
    public static property TEXTURE_CLIPMAP_DEPTH:            glGetTextureParameter read new glGetTextureParameter($8176);
    public static property POST_TEXTURE_FILTER_BIAS:         glGetTextureParameter read new glGetTextureParameter($8179);
    public static property POST_TEXTURE_FILTER_SCALE:        glGetTextureParameter read new glGetTextureParameter($817A);
    public static property TEXTURE_LOD_BIAS_S:               glGetTextureParameter read new glGetTextureParameter($818E);
    public static property TEXTURE_LOD_BIAS_T:               glGetTextureParameter read new glGetTextureParameter($818F);
    public static property TEXTURE_LOD_BIAS_R:               glGetTextureParameter read new glGetTextureParameter($8190);
    public static property GENERATE_MIPMAP:                  glGetTextureParameter read new glGetTextureParameter($8191);
    public static property TEXTURE_COMPARE:                  glGetTextureParameter read new glGetTextureParameter($819A);
    public static property TEXTURE_COMPARE_OPERATOR:         glGetTextureParameter read new glGetTextureParameter($819B);
    public static property TEXTURE_LEQUAL_R:                 glGetTextureParameter read new glGetTextureParameter($819C);
    public static property TEXTURE_GEQUAL_R:                 glGetTextureParameter read new glGetTextureParameter($819D);
    public static property TEXTURE_MAX_CLAMP_S:              glGetTextureParameter read new glGetTextureParameter($8369);
    public static property TEXTURE_MAX_CLAMP_T:              glGetTextureParameter read new glGetTextureParameter($836A);
    public static property TEXTURE_MAX_CLAMP_R:              glGetTextureParameter read new glGetTextureParameter($836B);
    public static property NORMAL_MAP:                       glGetTextureParameter read new glGetTextureParameter($8511);
    public static property REFLECTION_MAP:                   glGetTextureParameter read new glGetTextureParameter($8512);
    public static property TEXTURE_UNNORMALIZED_COORDINATES: glGetTextureParameter read new glGetTextureParameter($8F6A);
    public static property SURFACE_COMPRESSION:              glGetTextureParameter read new glGetTextureParameter($96C0);
    
    public function ToString: string; override;
    begin
      if TEXTURE_WIDTH = self then
        Result := 'TEXTURE_WIDTH' else
      if TEXTURE_HEIGHT = self then
        Result := 'TEXTURE_HEIGHT' else
      if TEXTURE_INTERNAL_FORMAT = self then
        Result := 'TEXTURE_INTERNAL_FORMAT' else
      if TEXTURE_COMPONENTS = self then
        Result := 'TEXTURE_COMPONENTS' else
      if TEXTURE_BORDER_COLOR = self then
        Result := 'TEXTURE_BORDER_COLOR' else
      if TEXTURE_BORDER = self then
        Result := 'TEXTURE_BORDER' else
      if TEXTURE_MAG_FILTER = self then
        Result := 'TEXTURE_MAG_FILTER' else
      if TEXTURE_MIN_FILTER = self then
        Result := 'TEXTURE_MIN_FILTER' else
      if TEXTURE_WRAP_S = self then
        Result := 'TEXTURE_WRAP_S' else
      if TEXTURE_WRAP_T = self then
        Result := 'TEXTURE_WRAP_T' else
      if TEXTURE_RED_SIZE = self then
        Result := 'TEXTURE_RED_SIZE' else
      if TEXTURE_GREEN_SIZE = self then
        Result := 'TEXTURE_GREEN_SIZE' else
      if TEXTURE_BLUE_SIZE = self then
        Result := 'TEXTURE_BLUE_SIZE' else
      if TEXTURE_ALPHA_SIZE = self then
        Result := 'TEXTURE_ALPHA_SIZE' else
      if TEXTURE_LUMINANCE_SIZE = self then
        Result := 'TEXTURE_LUMINANCE_SIZE' else
      if TEXTURE_INTENSITY_SIZE = self then
        Result := 'TEXTURE_INTENSITY_SIZE' else
      if TEXTURE_PRIORITY = self then
        Result := 'TEXTURE_PRIORITY' else
      if TEXTURE_RESIDENT = self then
        Result := 'TEXTURE_RESIDENT' else
      if TEXTURE_DEPTH = self then
        Result := 'TEXTURE_DEPTH' else
      if TEXTURE_WRAP_R = self then
        Result := 'TEXTURE_WRAP_R' else
      if DETAIL_TEXTURE_LEVEL = self then
        Result := 'DETAIL_TEXTURE_LEVEL' else
      if DETAIL_TEXTURE_MODE = self then
        Result := 'DETAIL_TEXTURE_MODE' else
      if DETAIL_TEXTURE_FUNC_POINTS = self then
        Result := 'DETAIL_TEXTURE_FUNC_POINTS' else
      if SHARPEN_TEXTURE_FUNC_POINTS = self then
        Result := 'SHARPEN_TEXTURE_FUNC_POINTS' else
      if SHADOW_AMBIENT = self then
        Result := 'SHADOW_AMBIENT' else
      if DUAL_TEXTURE_SELECT = self then
        Result := 'DUAL_TEXTURE_SELECT' else
      if QUAD_TEXTURE_SELECT = self then
        Result := 'QUAD_TEXTURE_SELECT' else
      if TEXTURE_4DSIZE = self then
        Result := 'TEXTURE_4DSIZE' else
      if TEXTURE_WRAP_Q = self then
        Result := 'TEXTURE_WRAP_Q' else
      if TEXTURE_MIN_LOD = self then
        Result := 'TEXTURE_MIN_LOD' else
      if TEXTURE_MAX_LOD = self then
        Result := 'TEXTURE_MAX_LOD' else
      if TEXTURE_BASE_LEVEL = self then
        Result := 'TEXTURE_BASE_LEVEL' else
      if TEXTURE_MAX_LEVEL = self then
        Result := 'TEXTURE_MAX_LEVEL' else
      if TEXTURE_FILTER4_SIZE = self then
        Result := 'TEXTURE_FILTER4_SIZE' else
      if TEXTURE_CLIPMAP_CENTER = self then
        Result := 'TEXTURE_CLIPMAP_CENTER' else
      if TEXTURE_CLIPMAP_FRAME = self then
        Result := 'TEXTURE_CLIPMAP_FRAME' else
      if TEXTURE_CLIPMAP_OFFSET = self then
        Result := 'TEXTURE_CLIPMAP_OFFSET' else
      if TEXTURE_CLIPMAP_VIRTUAL_DEPTH = self then
        Result := 'TEXTURE_CLIPMAP_VIRTUAL_DEPTH' else
      if TEXTURE_CLIPMAP_LOD_OFFSET = self then
        Result := 'TEXTURE_CLIPMAP_LOD_OFFSET' else
      if TEXTURE_CLIPMAP_DEPTH = self then
        Result := 'TEXTURE_CLIPMAP_DEPTH' else
      if POST_TEXTURE_FILTER_BIAS = self then
        Result := 'POST_TEXTURE_FILTER_BIAS' else
      if POST_TEXTURE_FILTER_SCALE = self then
        Result := 'POST_TEXTURE_FILTER_SCALE' else
      if TEXTURE_LOD_BIAS_S = self then
        Result := 'TEXTURE_LOD_BIAS_S' else
      if TEXTURE_LOD_BIAS_T = self then
        Result := 'TEXTURE_LOD_BIAS_T' else
      if TEXTURE_LOD_BIAS_R = self then
        Result := 'TEXTURE_LOD_BIAS_R' else
      if GENERATE_MIPMAP = self then
        Result := 'GENERATE_MIPMAP' else
      if TEXTURE_COMPARE = self then
        Result := 'TEXTURE_COMPARE' else
      if TEXTURE_COMPARE_OPERATOR = self then
        Result := 'TEXTURE_COMPARE_OPERATOR' else
      if TEXTURE_LEQUAL_R = self then
        Result := 'TEXTURE_LEQUAL_R' else
      if TEXTURE_GEQUAL_R = self then
        Result := 'TEXTURE_GEQUAL_R' else
      if TEXTURE_MAX_CLAMP_S = self then
        Result := 'TEXTURE_MAX_CLAMP_S' else
      if TEXTURE_MAX_CLAMP_T = self then
        Result := 'TEXTURE_MAX_CLAMP_T' else
      if TEXTURE_MAX_CLAMP_R = self then
        Result := 'TEXTURE_MAX_CLAMP_R' else
      if NORMAL_MAP = self then
        Result := 'NORMAL_MAP' else
      if REFLECTION_MAP = self then
        Result := 'REFLECTION_MAP' else
      if TEXTURE_UNNORMALIZED_COORDINATES = self then
        Result := 'TEXTURE_UNNORMALIZED_COORDINATES' else
      if SURFACE_COMPRESSION = self then
        Result := 'SURFACE_COMPRESSION' else
        Result := $'glGetTextureParameter[{self.val}]';
    end;
    
  end;
  
  glGetVariantValue = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VARIANT_VALUE:        glGetVariantValue read new glGetVariantValue($87E4);
    public static property VARIANT_DATATYPE:     glGetVariantValue read new glGetVariantValue($87E5);
    public static property VARIANT_ARRAY_STRIDE: glGetVariantValue read new glGetVariantValue($87E6);
    public static property VARIANT_ARRAY_TYPE:   glGetVariantValue read new glGetVariantValue($87E7);
    
    public function ToString: string; override;
    begin
      if VARIANT_VALUE = self then
        Result := 'VARIANT_VALUE' else
      if VARIANT_DATATYPE = self then
        Result := 'VARIANT_DATATYPE' else
      if VARIANT_ARRAY_STRIDE = self then
        Result := 'VARIANT_ARRAY_STRIDE' else
      if VARIANT_ARRAY_TYPE = self then
        Result := 'VARIANT_ARRAY_TYPE' else
        Result := $'glGetVariantValue[{self.val}]';
    end;
    
  end;
  
  glGraphicsResetStatus = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NO_ERROR:               glGraphicsResetStatus read new glGraphicsResetStatus(0);
    public static property GUILTY_CONTEXT_RESET:   glGraphicsResetStatus read new glGraphicsResetStatus($8253);
    public static property INNOCENT_CONTEXT_RESET: glGraphicsResetStatus read new glGraphicsResetStatus($8254);
    public static property UNKNOWN_CONTEXT_RESET:  glGraphicsResetStatus read new glGraphicsResetStatus($8255);
    
    public function ToString: string; override;
    begin
      if NO_ERROR = self then
        Result := 'NO_ERROR' else
      if GUILTY_CONTEXT_RESET = self then
        Result := 'GUILTY_CONTEXT_RESET' else
      if INNOCENT_CONTEXT_RESET = self then
        Result := 'INNOCENT_CONTEXT_RESET' else
      if UNKNOWN_CONTEXT_RESET = self then
        Result := 'UNKNOWN_CONTEXT_RESET' else
        Result := $'glGraphicsResetStatus[{self.val}]';
    end;
    
  end;
  
  glHintMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DONT_CARE: glHintMode read new glHintMode($1100);
    public static property FASTEST:   glHintMode read new glHintMode($1101);
    public static property NICEST:    glHintMode read new glHintMode($1102);
    
    public function ToString: string; override;
    begin
      if DONT_CARE = self then
        Result := 'DONT_CARE' else
      if FASTEST = self then
        Result := 'FASTEST' else
      if NICEST = self then
        Result := 'NICEST' else
        Result := $'glHintMode[{self.val}]';
    end;
    
  end;
  
  glHintTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PERSPECTIVE_CORRECTION_HINT:     glHintTarget read new glHintTarget($0C50);
    public static property POINT_SMOOTH_HINT:               glHintTarget read new glHintTarget($0C51);
    public static property LINE_SMOOTH_HINT:                glHintTarget read new glHintTarget($0C52);
    public static property POLYGON_SMOOTH_HINT:             glHintTarget read new glHintTarget($0C53);
    public static property FOG_HINT:                        glHintTarget read new glHintTarget($0C54);
    public static property PACK_CMYK_HINT:                  glHintTarget read new glHintTarget($800E);
    public static property UNPACK_CMYK_HINT:                glHintTarget read new glHintTarget($800F);
    public static property PHONG_HINT:                      glHintTarget read new glHintTarget($80EB);
    public static property CLIP_VOLUME_CLIPPING_HINT:       glHintTarget read new glHintTarget($80F0);
    public static property TEXTURE_MULTI_BUFFER_HINT:       glHintTarget read new glHintTarget($812E);
    public static property GENERATE_MIPMAP_HINT:            glHintTarget read new glHintTarget($8192);
    public static property PROGRAM_BINARY_RETRIEVABLE_HINT: glHintTarget read new glHintTarget($8257);
    public static property CONVOLUTION_HINT:                glHintTarget read new glHintTarget($8316);
    public static property SCALEBIAS_HINT:                  glHintTarget read new glHintTarget($8322);
    public static property LINE_QUALITY_HINT:               glHintTarget read new glHintTarget($835B);
    public static property VERTEX_PRECLIP:                  glHintTarget read new glHintTarget($83EE);
    public static property VERTEX_PRECLIP_HINT:             glHintTarget read new glHintTarget($83EF);
    public static property TEXTURE_COMPRESSION_HINT:        glHintTarget read new glHintTarget($84EF);
    public static property VERTEX_ARRAY_STORAGE_HINT:       glHintTarget read new glHintTarget($851F);
    public static property MULTISAMPLE_FILTER_HINT:         glHintTarget read new glHintTarget($8534);
    public static property TRANSFORM_HINT:                  glHintTarget read new glHintTarget($85B1);
    public static property TEXTURE_STORAGE_HINT:            glHintTarget read new glHintTarget($85BC);
    public static property FRAGMENT_SHADER_DERIVATIVE_HINT: glHintTarget read new glHintTarget($8B8B);
    public static property BINNING_CONTROL_HINT:            glHintTarget read new glHintTarget($8FB0);
    public static property PREFER_DOUBLEBUFFER_HINT:        glHintTarget read new glHintTarget($1A1F8);
    public static property CONSERVE_MEMORY_HINT:            glHintTarget read new glHintTarget($1A1FD);
    public static property RECLAIM_MEMORY_HINT:             glHintTarget read new glHintTarget($1A1FE);
    public static property NATIVE_GRAPHICS_BEGIN_HINT:      glHintTarget read new glHintTarget($1A203);
    public static property NATIVE_GRAPHICS_END_HINT:        glHintTarget read new glHintTarget($1A204);
    public static property ALWAYS_FAST_HINT:                glHintTarget read new glHintTarget($1A20C);
    public static property ALWAYS_SOFT_HINT:                glHintTarget read new glHintTarget($1A20D);
    public static property ALLOW_DRAW_OBJ_HINT:             glHintTarget read new glHintTarget($1A20E);
    public static property ALLOW_DRAW_WIN_HINT:             glHintTarget read new glHintTarget($1A20F);
    public static property ALLOW_DRAW_FRG_HINT:             glHintTarget read new glHintTarget($1A210);
    public static property ALLOW_DRAW_MEM_HINT:             glHintTarget read new glHintTarget($1A211);
    public static property STRICT_DEPTHFUNC_HINT:           glHintTarget read new glHintTarget($1A216);
    public static property STRICT_LIGHTING_HINT:            glHintTarget read new glHintTarget($1A217);
    public static property STRICT_SCISSOR_HINT:             glHintTarget read new glHintTarget($1A218);
    public static property FULL_STIPPLE_HINT:               glHintTarget read new glHintTarget($1A219);
    public static property CLIP_NEAR_HINT:                  glHintTarget read new glHintTarget($1A220);
    public static property CLIP_FAR_HINT:                   glHintTarget read new glHintTarget($1A221);
    public static property WIDE_LINE_HINT:                  glHintTarget read new glHintTarget($1A222);
    public static property BACK_NORMALS_HINT:               glHintTarget read new glHintTarget($1A223);
    public static property VERTEX_DATA_HINT:                glHintTarget read new glHintTarget($1A22A);
    public static property VERTEX_CONSISTENT_HINT:          glHintTarget read new glHintTarget($1A22B);
    public static property MATERIAL_SIDE_HINT:              glHintTarget read new glHintTarget($1A22C);
    public static property MAX_VERTEX_HINT:                 glHintTarget read new glHintTarget($1A22D);
    
    public function ToString: string; override;
    begin
      if PERSPECTIVE_CORRECTION_HINT = self then
        Result := 'PERSPECTIVE_CORRECTION_HINT' else
      if POINT_SMOOTH_HINT = self then
        Result := 'POINT_SMOOTH_HINT' else
      if LINE_SMOOTH_HINT = self then
        Result := 'LINE_SMOOTH_HINT' else
      if POLYGON_SMOOTH_HINT = self then
        Result := 'POLYGON_SMOOTH_HINT' else
      if FOG_HINT = self then
        Result := 'FOG_HINT' else
      if PACK_CMYK_HINT = self then
        Result := 'PACK_CMYK_HINT' else
      if UNPACK_CMYK_HINT = self then
        Result := 'UNPACK_CMYK_HINT' else
      if PHONG_HINT = self then
        Result := 'PHONG_HINT' else
      if CLIP_VOLUME_CLIPPING_HINT = self then
        Result := 'CLIP_VOLUME_CLIPPING_HINT' else
      if TEXTURE_MULTI_BUFFER_HINT = self then
        Result := 'TEXTURE_MULTI_BUFFER_HINT' else
      if GENERATE_MIPMAP_HINT = self then
        Result := 'GENERATE_MIPMAP_HINT' else
      if PROGRAM_BINARY_RETRIEVABLE_HINT = self then
        Result := 'PROGRAM_BINARY_RETRIEVABLE_HINT' else
      if CONVOLUTION_HINT = self then
        Result := 'CONVOLUTION_HINT' else
      if SCALEBIAS_HINT = self then
        Result := 'SCALEBIAS_HINT' else
      if LINE_QUALITY_HINT = self then
        Result := 'LINE_QUALITY_HINT' else
      if VERTEX_PRECLIP = self then
        Result := 'VERTEX_PRECLIP' else
      if VERTEX_PRECLIP_HINT = self then
        Result := 'VERTEX_PRECLIP_HINT' else
      if TEXTURE_COMPRESSION_HINT = self then
        Result := 'TEXTURE_COMPRESSION_HINT' else
      if VERTEX_ARRAY_STORAGE_HINT = self then
        Result := 'VERTEX_ARRAY_STORAGE_HINT' else
      if MULTISAMPLE_FILTER_HINT = self then
        Result := 'MULTISAMPLE_FILTER_HINT' else
      if TRANSFORM_HINT = self then
        Result := 'TRANSFORM_HINT' else
      if TEXTURE_STORAGE_HINT = self then
        Result := 'TEXTURE_STORAGE_HINT' else
      if FRAGMENT_SHADER_DERIVATIVE_HINT = self then
        Result := 'FRAGMENT_SHADER_DERIVATIVE_HINT' else
      if BINNING_CONTROL_HINT = self then
        Result := 'BINNING_CONTROL_HINT' else
      if PREFER_DOUBLEBUFFER_HINT = self then
        Result := 'PREFER_DOUBLEBUFFER_HINT' else
      if CONSERVE_MEMORY_HINT = self then
        Result := 'CONSERVE_MEMORY_HINT' else
      if RECLAIM_MEMORY_HINT = self then
        Result := 'RECLAIM_MEMORY_HINT' else
      if NATIVE_GRAPHICS_BEGIN_HINT = self then
        Result := 'NATIVE_GRAPHICS_BEGIN_HINT' else
      if NATIVE_GRAPHICS_END_HINT = self then
        Result := 'NATIVE_GRAPHICS_END_HINT' else
      if ALWAYS_FAST_HINT = self then
        Result := 'ALWAYS_FAST_HINT' else
      if ALWAYS_SOFT_HINT = self then
        Result := 'ALWAYS_SOFT_HINT' else
      if ALLOW_DRAW_OBJ_HINT = self then
        Result := 'ALLOW_DRAW_OBJ_HINT' else
      if ALLOW_DRAW_WIN_HINT = self then
        Result := 'ALLOW_DRAW_WIN_HINT' else
      if ALLOW_DRAW_FRG_HINT = self then
        Result := 'ALLOW_DRAW_FRG_HINT' else
      if ALLOW_DRAW_MEM_HINT = self then
        Result := 'ALLOW_DRAW_MEM_HINT' else
      if STRICT_DEPTHFUNC_HINT = self then
        Result := 'STRICT_DEPTHFUNC_HINT' else
      if STRICT_LIGHTING_HINT = self then
        Result := 'STRICT_LIGHTING_HINT' else
      if STRICT_SCISSOR_HINT = self then
        Result := 'STRICT_SCISSOR_HINT' else
      if FULL_STIPPLE_HINT = self then
        Result := 'FULL_STIPPLE_HINT' else
      if CLIP_NEAR_HINT = self then
        Result := 'CLIP_NEAR_HINT' else
      if CLIP_FAR_HINT = self then
        Result := 'CLIP_FAR_HINT' else
      if WIDE_LINE_HINT = self then
        Result := 'WIDE_LINE_HINT' else
      if BACK_NORMALS_HINT = self then
        Result := 'BACK_NORMALS_HINT' else
      if VERTEX_DATA_HINT = self then
        Result := 'VERTEX_DATA_HINT' else
      if VERTEX_CONSISTENT_HINT = self then
        Result := 'VERTEX_CONSISTENT_HINT' else
      if MATERIAL_SIDE_HINT = self then
        Result := 'MATERIAL_SIDE_HINT' else
      if MAX_VERTEX_HINT = self then
        Result := 'MAX_VERTEX_HINT' else
        Result := $'glHintTarget[{self.val}]';
    end;
    
  end;
  
  glHistogramTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property HISTOGRAM:       glHistogramTarget read new glHistogramTarget($8024);
    public static property PROXY_HISTOGRAM: glHistogramTarget read new glHistogramTarget($8025);
    
    public function ToString: string; override;
    begin
      if HISTOGRAM = self then
        Result := 'HISTOGRAM' else
      if PROXY_HISTOGRAM = self then
        Result := 'PROXY_HISTOGRAM' else
        Result := $'glHistogramTarget[{self.val}]';
    end;
    
  end;
  
  glImageTransformPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property IMAGE_SCALE_X:         glImageTransformPName read new glImageTransformPName($8155);
    public static property IMAGE_SCALE_Y:         glImageTransformPName read new glImageTransformPName($8156);
    public static property IMAGE_TRANSLATE_X:     glImageTransformPName read new glImageTransformPName($8157);
    public static property IMAGE_TRANSLATE_Y:     glImageTransformPName read new glImageTransformPName($8158);
    public static property IMAGE_ROTATE_ANGLE:    glImageTransformPName read new glImageTransformPName($8159);
    public static property IMAGE_ROTATE_ORIGIN_X: glImageTransformPName read new glImageTransformPName($815A);
    public static property IMAGE_ROTATE_ORIGIN_Y: glImageTransformPName read new glImageTransformPName($815B);
    public static property IMAGE_MAG_FILTER:      glImageTransformPName read new glImageTransformPName($815C);
    public static property IMAGE_MIN_FILTER:      glImageTransformPName read new glImageTransformPName($815D);
    public static property IMAGE_CUBIC_WEIGHT:    glImageTransformPName read new glImageTransformPName($815E);
    
    public function ToString: string; override;
    begin
      if IMAGE_SCALE_X = self then
        Result := 'IMAGE_SCALE_X' else
      if IMAGE_SCALE_Y = self then
        Result := 'IMAGE_SCALE_Y' else
      if IMAGE_TRANSLATE_X = self then
        Result := 'IMAGE_TRANSLATE_X' else
      if IMAGE_TRANSLATE_Y = self then
        Result := 'IMAGE_TRANSLATE_Y' else
      if IMAGE_ROTATE_ANGLE = self then
        Result := 'IMAGE_ROTATE_ANGLE' else
      if IMAGE_ROTATE_ORIGIN_X = self then
        Result := 'IMAGE_ROTATE_ORIGIN_X' else
      if IMAGE_ROTATE_ORIGIN_Y = self then
        Result := 'IMAGE_ROTATE_ORIGIN_Y' else
      if IMAGE_MAG_FILTER = self then
        Result := 'IMAGE_MAG_FILTER' else
      if IMAGE_MIN_FILTER = self then
        Result := 'IMAGE_MIN_FILTER' else
      if IMAGE_CUBIC_WEIGHT = self then
        Result := 'IMAGE_CUBIC_WEIGHT' else
        Result := $'glImageTransformPName[{self.val}]';
    end;
    
  end;
  
  glImageTransformTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property IMAGE_TRANSFORM_2D: glImageTransformTarget read new glImageTransformTarget($8161);
    
    public function ToString: string; override;
    begin
      if IMAGE_TRANSFORM_2D = self then
        Result := 'IMAGE_TRANSFORM_2D' else
        Result := $'glImageTransformTarget[{self.val}]';
    end;
    
  end;
  
  glIndexFunction = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEVER:    glIndexFunction read new glIndexFunction($0200);
    public static property LESS:     glIndexFunction read new glIndexFunction($0201);
    public static property EQUAL:    glIndexFunction read new glIndexFunction($0202);
    public static property LEQUAL:   glIndexFunction read new glIndexFunction($0203);
    public static property GREATER:  glIndexFunction read new glIndexFunction($0204);
    public static property NOTEQUAL: glIndexFunction read new glIndexFunction($0205);
    public static property GEQUAL:   glIndexFunction read new glIndexFunction($0206);
    public static property ALWAYS:   glIndexFunction read new glIndexFunction($0207);
    
    public function ToString: string; override;
    begin
      if NEVER = self then
        Result := 'NEVER' else
      if LESS = self then
        Result := 'LESS' else
      if EQUAL = self then
        Result := 'EQUAL' else
      if LEQUAL = self then
        Result := 'LEQUAL' else
      if GREATER = self then
        Result := 'GREATER' else
      if NOTEQUAL = self then
        Result := 'NOTEQUAL' else
      if GEQUAL = self then
        Result := 'GEQUAL' else
      if ALWAYS = self then
        Result := 'ALWAYS' else
        Result := $'glIndexFunction[{self.val}]';
    end;
    
  end;
  
  glIndexMaterialParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property INDEX_OFFSET: glIndexMaterialParameter read new glIndexMaterialParameter($0D13);
    
    public function ToString: string; override;
    begin
      if INDEX_OFFSET = self then
        Result := 'INDEX_OFFSET' else
        Result := $'glIndexMaterialParameter[{self.val}]';
    end;
    
  end;
  
  glIndexPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SHORT:  glIndexPointerType read new glIndexPointerType($1402);
    public static property INT:    glIndexPointerType read new glIndexPointerType($1404);
    public static property FLOAT:  glIndexPointerType read new glIndexPointerType($1406);
    public static property DOUBLE: glIndexPointerType read new glIndexPointerType($140A);
    
    public function ToString: string; override;
    begin
      if SHORT = self then
        Result := 'SHORT' else
      if INT = self then
        Result := 'INT' else
      if FLOAT = self then
        Result := 'FLOAT' else
      if DOUBLE = self then
        Result := 'DOUBLE' else
        Result := $'glIndexPointerType[{self.val}]';
    end;
    
  end;
  
  glInstancedPathCoverMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PATH_FILL_COVER_MODE:           glInstancedPathCoverMode read new glInstancedPathCoverMode($9082);
    public static property CONVEX_HULL:                    glInstancedPathCoverMode read new glInstancedPathCoverMode($908B);
    public static property BOUNDING_BOX:                   glInstancedPathCoverMode read new glInstancedPathCoverMode($908D);
    public static property BOUNDING_BOX_OF_BOUNDING_BOXES: glInstancedPathCoverMode read new glInstancedPathCoverMode($909C);
    
    public function ToString: string; override;
    begin
      if PATH_FILL_COVER_MODE = self then
        Result := 'PATH_FILL_COVER_MODE' else
      if CONVEX_HULL = self then
        Result := 'CONVEX_HULL' else
      if BOUNDING_BOX = self then
        Result := 'BOUNDING_BOX' else
      if BOUNDING_BOX_OF_BOUNDING_BOXES = self then
        Result := 'BOUNDING_BOX_OF_BOUNDING_BOXES' else
        Result := $'glInstancedPathCoverMode[{self.val}]';
    end;
    
  end;
  
  glInterleavedArrayFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property V2F:             glInterleavedArrayFormat read new glInterleavedArrayFormat($2A20);
    public static property V3F:             glInterleavedArrayFormat read new glInterleavedArrayFormat($2A21);
    public static property C4UB_V2F:        glInterleavedArrayFormat read new glInterleavedArrayFormat($2A22);
    public static property C4UB_V3F:        glInterleavedArrayFormat read new glInterleavedArrayFormat($2A23);
    public static property C3F_V3F:         glInterleavedArrayFormat read new glInterleavedArrayFormat($2A24);
    public static property N3F_V3F:         glInterleavedArrayFormat read new glInterleavedArrayFormat($2A25);
    public static property C4F_N3F_V3F:     glInterleavedArrayFormat read new glInterleavedArrayFormat($2A26);
    public static property T2F_V3F:         glInterleavedArrayFormat read new glInterleavedArrayFormat($2A27);
    public static property T4F_V4F:         glInterleavedArrayFormat read new glInterleavedArrayFormat($2A28);
    public static property T2F_C4UB_V3F:    glInterleavedArrayFormat read new glInterleavedArrayFormat($2A29);
    public static property T2F_C3F_V3F:     glInterleavedArrayFormat read new glInterleavedArrayFormat($2A2A);
    public static property T2F_N3F_V3F:     glInterleavedArrayFormat read new glInterleavedArrayFormat($2A2B);
    public static property T2F_C4F_N3F_V3F: glInterleavedArrayFormat read new glInterleavedArrayFormat($2A2C);
    public static property T4F_C4F_N3F_V4F: glInterleavedArrayFormat read new glInterleavedArrayFormat($2A2D);
    
    public function ToString: string; override;
    begin
      if V2F = self then
        Result := 'V2F' else
      if V3F = self then
        Result := 'V3F' else
      if C4UB_V2F = self then
        Result := 'C4UB_V2F' else
      if C4UB_V3F = self then
        Result := 'C4UB_V3F' else
      if C3F_V3F = self then
        Result := 'C3F_V3F' else
      if N3F_V3F = self then
        Result := 'N3F_V3F' else
      if C4F_N3F_V3F = self then
        Result := 'C4F_N3F_V3F' else
      if T2F_V3F = self then
        Result := 'T2F_V3F' else
      if T4F_V4F = self then
        Result := 'T4F_V4F' else
      if T2F_C4UB_V3F = self then
        Result := 'T2F_C4UB_V3F' else
      if T2F_C3F_V3F = self then
        Result := 'T2F_C3F_V3F' else
      if T2F_N3F_V3F = self then
        Result := 'T2F_N3F_V3F' else
      if T2F_C4F_N3F_V3F = self then
        Result := 'T2F_C4F_N3F_V3F' else
      if T4F_C4F_N3F_V4F = self then
        Result := 'T4F_C4F_N3F_V4F' else
        Result := $'glInterleavedArrayFormat[{self.val}]';
    end;
    
  end;
  
  glInternalFormat = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property STENCIL_INDEX:                             glInternalFormat read new glInternalFormat($1901);
    public static property DEPTH_COMPONENT:                           glInternalFormat read new glInternalFormat($1902);
    public static property RED:                                       glInternalFormat read new glInternalFormat($1903);
    public static property RGB:                                       glInternalFormat read new glInternalFormat($1907);
    public static property RGBA:                                      glInternalFormat read new glInternalFormat($1908);
    public static property R3_G3_B2:                                  glInternalFormat read new glInternalFormat($2A10);
    public static property ALPHA4:                                    glInternalFormat read new glInternalFormat($803B);
    public static property ALPHA8:                                    glInternalFormat read new glInternalFormat($803C);
    public static property ALPHA12:                                   glInternalFormat read new glInternalFormat($803D);
    public static property ALPHA16:                                   glInternalFormat read new glInternalFormat($803E);
    public static property LUMINANCE4:                                glInternalFormat read new glInternalFormat($803F);
    public static property LUMINANCE8:                                glInternalFormat read new glInternalFormat($8040);
    public static property LUMINANCE12:                               glInternalFormat read new glInternalFormat($8041);
    public static property LUMINANCE16:                               glInternalFormat read new glInternalFormat($8042);
    public static property LUMINANCE4_ALPHA4:                         glInternalFormat read new glInternalFormat($8043);
    public static property LUMINANCE6_ALPHA2:                         glInternalFormat read new glInternalFormat($8044);
    public static property LUMINANCE8_ALPHA8:                         glInternalFormat read new glInternalFormat($8045);
    public static property LUMINANCE12_ALPHA4:                        glInternalFormat read new glInternalFormat($8046);
    public static property LUMINANCE12_ALPHA12:                       glInternalFormat read new glInternalFormat($8047);
    public static property LUMINANCE16_ALPHA16:                       glInternalFormat read new glInternalFormat($8048);
    public static property INTENSITY:                                 glInternalFormat read new glInternalFormat($8049);
    public static property INTENSITY4:                                glInternalFormat read new glInternalFormat($804A);
    public static property INTENSITY8:                                glInternalFormat read new glInternalFormat($804B);
    public static property INTENSITY12:                               glInternalFormat read new glInternalFormat($804C);
    public static property INTENSITY16:                               glInternalFormat read new glInternalFormat($804D);
    public static property RGB2:                                      glInternalFormat read new glInternalFormat($804E);
    public static property RGB4:                                      glInternalFormat read new glInternalFormat($804F);
    public static property RGB5:                                      glInternalFormat read new glInternalFormat($8050);
    public static property RGB8:                                      glInternalFormat read new glInternalFormat($8051);
    public static property RGB10:                                     glInternalFormat read new glInternalFormat($8052);
    public static property RGB12:                                     glInternalFormat read new glInternalFormat($8053);
    public static property RGB16:                                     glInternalFormat read new glInternalFormat($8054);
    public static property RGBA2:                                     glInternalFormat read new glInternalFormat($8055);
    public static property RGBA4:                                     glInternalFormat read new glInternalFormat($8056);
    public static property RGB5_A1:                                   glInternalFormat read new glInternalFormat($8057);
    public static property RGBA8:                                     glInternalFormat read new glInternalFormat($8058);
    public static property RGB10_A2:                                  glInternalFormat read new glInternalFormat($8059);
    public static property RGBA12:                                    glInternalFormat read new glInternalFormat($805A);
    public static property RGBA16:                                    glInternalFormat read new glInternalFormat($805B);
    public static property DUAL_ALPHA4:                               glInternalFormat read new glInternalFormat($8110);
    public static property DUAL_ALPHA8:                               glInternalFormat read new glInternalFormat($8111);
    public static property DUAL_ALPHA12:                              glInternalFormat read new glInternalFormat($8112);
    public static property DUAL_ALPHA16:                              glInternalFormat read new glInternalFormat($8113);
    public static property DUAL_LUMINANCE4:                           glInternalFormat read new glInternalFormat($8114);
    public static property DUAL_LUMINANCE8:                           glInternalFormat read new glInternalFormat($8115);
    public static property DUAL_LUMINANCE12:                          glInternalFormat read new glInternalFormat($8116);
    public static property DUAL_LUMINANCE16:                          glInternalFormat read new glInternalFormat($8117);
    public static property DUAL_INTENSITY4:                           glInternalFormat read new glInternalFormat($8118);
    public static property DUAL_INTENSITY8:                           glInternalFormat read new glInternalFormat($8119);
    public static property DUAL_INTENSITY12:                          glInternalFormat read new glInternalFormat($811A);
    public static property DUAL_INTENSITY16:                          glInternalFormat read new glInternalFormat($811B);
    public static property DUAL_LUMINANCE_ALPHA4:                     glInternalFormat read new glInternalFormat($811C);
    public static property DUAL_LUMINANCE_ALPHA8:                     glInternalFormat read new glInternalFormat($811D);
    public static property QUAD_ALPHA4:                               glInternalFormat read new glInternalFormat($811E);
    public static property QUAD_ALPHA8:                               glInternalFormat read new glInternalFormat($811F);
    public static property QUAD_LUMINANCE4:                           glInternalFormat read new glInternalFormat($8120);
    public static property QUAD_LUMINANCE8:                           glInternalFormat read new glInternalFormat($8121);
    public static property QUAD_INTENSITY4:                           glInternalFormat read new glInternalFormat($8122);
    public static property QUAD_INTENSITY8:                           glInternalFormat read new glInternalFormat($8123);
    public static property DEPTH_COMPONENT16:                         glInternalFormat read new glInternalFormat($81A5);
    public static property DEPTH_COMPONENT24:                         glInternalFormat read new glInternalFormat($81A6);
    public static property DEPTH_COMPONENT32:                         glInternalFormat read new glInternalFormat($81A7);
    public static property COMPRESSED_RED:                            glInternalFormat read new glInternalFormat($8225);
    public static property COMPRESSED_RG:                             glInternalFormat read new glInternalFormat($8226);
    public static property RG:                                        glInternalFormat read new glInternalFormat($8227);
    public static property R8:                                        glInternalFormat read new glInternalFormat($8229);
    public static property R16:                                       glInternalFormat read new glInternalFormat($822A);
    public static property RG8:                                       glInternalFormat read new glInternalFormat($822B);
    public static property RG16:                                      glInternalFormat read new glInternalFormat($822C);
    public static property R16F:                                      glInternalFormat read new glInternalFormat($822D);
    public static property R32F:                                      glInternalFormat read new glInternalFormat($822E);
    public static property RG16F:                                     glInternalFormat read new glInternalFormat($822F);
    public static property RG32F:                                     glInternalFormat read new glInternalFormat($8230);
    public static property R8I:                                       glInternalFormat read new glInternalFormat($8231);
    public static property R8UI:                                      glInternalFormat read new glInternalFormat($8232);
    public static property R16I:                                      glInternalFormat read new glInternalFormat($8233);
    public static property R16UI:                                     glInternalFormat read new glInternalFormat($8234);
    public static property R32I:                                      glInternalFormat read new glInternalFormat($8235);
    public static property R32UI:                                     glInternalFormat read new glInternalFormat($8236);
    public static property RG8I:                                      glInternalFormat read new glInternalFormat($8237);
    public static property RG8UI:                                     glInternalFormat read new glInternalFormat($8238);
    public static property RG16I:                                     glInternalFormat read new glInternalFormat($8239);
    public static property RG16UI:                                    glInternalFormat read new glInternalFormat($823A);
    public static property RG32I:                                     glInternalFormat read new glInternalFormat($823B);
    public static property RG32UI:                                    glInternalFormat read new glInternalFormat($823C);
    public static property COMPRESSED_RGB_S3TC_DXT1:                  glInternalFormat read new glInternalFormat($83F0);
    public static property COMPRESSED_RGBA_S3TC_DXT1:                 glInternalFormat read new glInternalFormat($83F1);
    public static property COMPRESSED_RGBA_S3TC_DXT3:                 glInternalFormat read new glInternalFormat($83F2);
    public static property COMPRESSED_RGBA_S3TC_DXT5:                 glInternalFormat read new glInternalFormat($83F3);
    public static property COMPRESSED_RGB:                            glInternalFormat read new glInternalFormat($84ED);
    public static property COMPRESSED_RGBA:                           glInternalFormat read new glInternalFormat($84EE);
    public static property DEPTH_STENCIL:                             glInternalFormat read new glInternalFormat($84F9);
    public static property DEPTH_STENCIL_MESA:                        glInternalFormat read new glInternalFormat($8750);
    public static property RGBA32F:                                   glInternalFormat read new glInternalFormat($8814);
    public static property RGB32F:                                    glInternalFormat read new glInternalFormat($8815);
    public static property RGBA16F:                                   glInternalFormat read new glInternalFormat($881A);
    public static property RGB16F:                                    glInternalFormat read new glInternalFormat($881B);
    public static property DEPTH24_STENCIL8:                          glInternalFormat read new glInternalFormat($88F0);
    public static property R11F_G11F_B10F:                            glInternalFormat read new glInternalFormat($8C3A);
    public static property RGB9_E5:                                   glInternalFormat read new glInternalFormat($8C3D);
    public static property SRGB:                                      glInternalFormat read new glInternalFormat($8C40);
    public static property SRGB8:                                     glInternalFormat read new glInternalFormat($8C41);
    public static property SRGB_ALPHA:                                glInternalFormat read new glInternalFormat($8C42);
    public static property SRGB8_ALPHA8:                              glInternalFormat read new glInternalFormat($8C43);
    public static property COMPRESSED_SRGB:                           glInternalFormat read new glInternalFormat($8C48);
    public static property COMPRESSED_SRGB_ALPHA:                     glInternalFormat read new glInternalFormat($8C49);
    public static property COMPRESSED_SRGB_S3TC_DXT1:                 glInternalFormat read new glInternalFormat($8C4C);
    public static property COMPRESSED_SRGB_ALPHA_S3TC_DXT1:           glInternalFormat read new glInternalFormat($8C4D);
    public static property COMPRESSED_SRGB_ALPHA_S3TC_DXT3:           glInternalFormat read new glInternalFormat($8C4E);
    public static property COMPRESSED_SRGB_ALPHA_S3TC_DXT5:           glInternalFormat read new glInternalFormat($8C4F);
    public static property DEPTH_COMPONENT32F:                        glInternalFormat read new glInternalFormat($8CAC);
    public static property DEPTH32F_STENCIL8:                         glInternalFormat read new glInternalFormat($8CAD);
    public static property STENCIL_INDEX1:                            glInternalFormat read new glInternalFormat($8D46);
    public static property STENCIL_INDEX4:                            glInternalFormat read new glInternalFormat($8D47);
    public static property STENCIL_INDEX8:                            glInternalFormat read new glInternalFormat($8D48);
    public static property STENCIL_INDEX16:                           glInternalFormat read new glInternalFormat($8D49);
    public static property RGB565:                                    glInternalFormat read new glInternalFormat($8D62);
    public static property ETC1_RGB8:                                 glInternalFormat read new glInternalFormat($8D64);
    public static property RGBA32UI:                                  glInternalFormat read new glInternalFormat($8D70);
    public static property RGB32UI:                                   glInternalFormat read new glInternalFormat($8D71);
    public static property ALPHA32UI:                                 glInternalFormat read new glInternalFormat($8D72);
    public static property INTENSITY32UI:                             glInternalFormat read new glInternalFormat($8D73);
    public static property LUMINANCE32UI:                             glInternalFormat read new glInternalFormat($8D74);
    public static property LUMINANCE_ALPHA32UI:                       glInternalFormat read new glInternalFormat($8D75);
    public static property RGBA16UI:                                  glInternalFormat read new glInternalFormat($8D76);
    public static property RGB16UI:                                   glInternalFormat read new glInternalFormat($8D77);
    public static property ALPHA16UI:                                 glInternalFormat read new glInternalFormat($8D78);
    public static property INTENSITY16UI:                             glInternalFormat read new glInternalFormat($8D79);
    public static property LUMINANCE16UI:                             glInternalFormat read new glInternalFormat($8D7A);
    public static property LUMINANCE_ALPHA16UI:                       glInternalFormat read new glInternalFormat($8D7B);
    public static property RGBA8UI:                                   glInternalFormat read new glInternalFormat($8D7C);
    public static property RGB8UI:                                    glInternalFormat read new glInternalFormat($8D7D);
    public static property ALPHA8UI:                                  glInternalFormat read new glInternalFormat($8D7E);
    public static property INTENSITY8UI:                              glInternalFormat read new glInternalFormat($8D7F);
    public static property LUMINANCE8UI:                              glInternalFormat read new glInternalFormat($8D80);
    public static property LUMINANCE_ALPHA8UI:                        glInternalFormat read new glInternalFormat($8D81);
    public static property RGBA32I:                                   glInternalFormat read new glInternalFormat($8D82);
    public static property RGB32I:                                    glInternalFormat read new glInternalFormat($8D83);
    public static property ALPHA32I:                                  glInternalFormat read new glInternalFormat($8D84);
    public static property INTENSITY32I:                              glInternalFormat read new glInternalFormat($8D85);
    public static property LUMINANCE32I:                              glInternalFormat read new glInternalFormat($8D86);
    public static property LUMINANCE_ALPHA32I:                        glInternalFormat read new glInternalFormat($8D87);
    public static property RGBA16I:                                   glInternalFormat read new glInternalFormat($8D88);
    public static property RGB16I:                                    glInternalFormat read new glInternalFormat($8D89);
    public static property ALPHA16I:                                  glInternalFormat read new glInternalFormat($8D8A);
    public static property INTENSITY16I:                              glInternalFormat read new glInternalFormat($8D8B);
    public static property LUMINANCE16I:                              glInternalFormat read new glInternalFormat($8D8C);
    public static property LUMINANCE_ALPHA16I:                        glInternalFormat read new glInternalFormat($8D8D);
    public static property RGBA8I:                                    glInternalFormat read new glInternalFormat($8D8E);
    public static property RGB8I:                                     glInternalFormat read new glInternalFormat($8D8F);
    public static property ALPHA8I:                                   glInternalFormat read new glInternalFormat($8D90);
    public static property INTENSITY8I:                               glInternalFormat read new glInternalFormat($8D91);
    public static property LUMINANCE8I:                               glInternalFormat read new glInternalFormat($8D92);
    public static property LUMINANCE_ALPHA8I:                         glInternalFormat read new glInternalFormat($8D93);
    public static property DEPTH_COMPONENT32F_NV:                     glInternalFormat read new glInternalFormat($8DAB);
    public static property DEPTH32F_STENCIL8_NV:                      glInternalFormat read new glInternalFormat($8DAC);
    public static property COMPRESSED_RED_RGTC1:                      glInternalFormat read new glInternalFormat($8DBB);
    public static property COMPRESSED_SIGNED_RED_RGTC1:               glInternalFormat read new glInternalFormat($8DBC);
    public static property COMPRESSED_RED_GREEN_RGTC2:                glInternalFormat read new glInternalFormat($8DBD);
    public static property COMPRESSED_RG_RGTC2:                       glInternalFormat read new glInternalFormat($8DBD);
    public static property COMPRESSED_SIGNED_RED_GREEN_RGTC2:         glInternalFormat read new glInternalFormat($8DBE);
    public static property COMPRESSED_SIGNED_RG_RGTC2:                glInternalFormat read new glInternalFormat($8DBE);
    public static property COMPRESSED_RGBA_BPTC_UNORM:                glInternalFormat read new glInternalFormat($8E8C);
    public static property COMPRESSED_SRGB_ALPHA_BPTC_UNORM:          glInternalFormat read new glInternalFormat($8E8D);
    public static property COMPRESSED_RGB_BPTC_SIGNED_FLOAT:          glInternalFormat read new glInternalFormat($8E8E);
    public static property COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:        glInternalFormat read new glInternalFormat($8E8F);
    public static property R8_SNORM:                                  glInternalFormat read new glInternalFormat($8F94);
    public static property RG8_SNORM:                                 glInternalFormat read new glInternalFormat($8F95);
    public static property RGB8_SNORM:                                glInternalFormat read new glInternalFormat($8F96);
    public static property RGBA8_SNORM:                               glInternalFormat read new glInternalFormat($8F97);
    public static property R16_SNORM:                                 glInternalFormat read new glInternalFormat($8F98);
    public static property RG16_SNORM:                                glInternalFormat read new glInternalFormat($8F99);
    public static property RGB16_SNORM:                               glInternalFormat read new glInternalFormat($8F9A);
    public static property RGBA16_SNORM:                              glInternalFormat read new glInternalFormat($8F9B);
    public static property SR8:                                       glInternalFormat read new glInternalFormat($8FBD);
    public static property SRG8:                                      glInternalFormat read new glInternalFormat($8FBE);
    public static property RGB10_A2UI:                                glInternalFormat read new glInternalFormat($906F);
    public static property COMPRESSED_R11_EAC:                        glInternalFormat read new glInternalFormat($9270);
    public static property COMPRESSED_SIGNED_R11_EAC:                 glInternalFormat read new glInternalFormat($9271);
    public static property COMPRESSED_RG11_EAC:                       glInternalFormat read new glInternalFormat($9272);
    public static property COMPRESSED_SIGNED_RG11_EAC:                glInternalFormat read new glInternalFormat($9273);
    public static property COMPRESSED_RGB8_ETC2:                      glInternalFormat read new glInternalFormat($9274);
    public static property COMPRESSED_SRGB8_ETC2:                     glInternalFormat read new glInternalFormat($9275);
    public static property COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:  glInternalFormat read new glInternalFormat($9276);
    public static property COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: glInternalFormat read new glInternalFormat($9277);
    public static property COMPRESSED_RGBA8_ETC2_EAC:                 glInternalFormat read new glInternalFormat($9278);
    public static property COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:          glInternalFormat read new glInternalFormat($9279);
    public static property COMPRESSED_RGBA_ASTC_4x4:                  glInternalFormat read new glInternalFormat($93B0);
    public static property COMPRESSED_RGBA_ASTC_5x4:                  glInternalFormat read new glInternalFormat($93B1);
    public static property COMPRESSED_RGBA_ASTC_5x5:                  glInternalFormat read new glInternalFormat($93B2);
    public static property COMPRESSED_RGBA_ASTC_6x5:                  glInternalFormat read new glInternalFormat($93B3);
    public static property COMPRESSED_RGBA_ASTC_6x6:                  glInternalFormat read new glInternalFormat($93B4);
    public static property COMPRESSED_RGBA_ASTC_8x5:                  glInternalFormat read new glInternalFormat($93B5);
    public static property COMPRESSED_RGBA_ASTC_8x6:                  glInternalFormat read new glInternalFormat($93B6);
    public static property COMPRESSED_RGBA_ASTC_8x8:                  glInternalFormat read new glInternalFormat($93B7);
    public static property COMPRESSED_RGBA_ASTC_10x5:                 glInternalFormat read new glInternalFormat($93B8);
    public static property COMPRESSED_RGBA_ASTC_10x6:                 glInternalFormat read new glInternalFormat($93B9);
    public static property COMPRESSED_RGBA_ASTC_10x8:                 glInternalFormat read new glInternalFormat($93BA);
    public static property COMPRESSED_RGBA_ASTC_10x10:                glInternalFormat read new glInternalFormat($93BB);
    public static property COMPRESSED_RGBA_ASTC_12x10:                glInternalFormat read new glInternalFormat($93BC);
    public static property COMPRESSED_RGBA_ASTC_12x12:                glInternalFormat read new glInternalFormat($93BD);
    public static property COMPRESSED_RGBA_ASTC_3x3x3:                glInternalFormat read new glInternalFormat($93C0);
    public static property COMPRESSED_RGBA_ASTC_4x3x3:                glInternalFormat read new glInternalFormat($93C1);
    public static property COMPRESSED_RGBA_ASTC_4x4x3:                glInternalFormat read new glInternalFormat($93C2);
    public static property COMPRESSED_RGBA_ASTC_4x4x4:                glInternalFormat read new glInternalFormat($93C3);
    public static property COMPRESSED_RGBA_ASTC_5x4x4:                glInternalFormat read new glInternalFormat($93C4);
    public static property COMPRESSED_RGBA_ASTC_5x5x4:                glInternalFormat read new glInternalFormat($93C5);
    public static property COMPRESSED_RGBA_ASTC_5x5x5:                glInternalFormat read new glInternalFormat($93C6);
    public static property COMPRESSED_RGBA_ASTC_6x5x5:                glInternalFormat read new glInternalFormat($93C7);
    public static property COMPRESSED_RGBA_ASTC_6x6x5:                glInternalFormat read new glInternalFormat($93C8);
    public static property COMPRESSED_RGBA_ASTC_6x6x6:                glInternalFormat read new glInternalFormat($93C9);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x4:          glInternalFormat read new glInternalFormat($93D0);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x4:          glInternalFormat read new glInternalFormat($93D1);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x5:          glInternalFormat read new glInternalFormat($93D2);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x5:          glInternalFormat read new glInternalFormat($93D3);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x6:          glInternalFormat read new glInternalFormat($93D4);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x5:          glInternalFormat read new glInternalFormat($93D5);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x6:          glInternalFormat read new glInternalFormat($93D6);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x8:          glInternalFormat read new glInternalFormat($93D7);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x5:         glInternalFormat read new glInternalFormat($93D8);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x6:         glInternalFormat read new glInternalFormat($93D9);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x8:         glInternalFormat read new glInternalFormat($93DA);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x10:        glInternalFormat read new glInternalFormat($93DB);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_12x10:        glInternalFormat read new glInternalFormat($93DC);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_12x12:        glInternalFormat read new glInternalFormat($93DD);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3:        glInternalFormat read new glInternalFormat($93E0);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3:        glInternalFormat read new glInternalFormat($93E1);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3:        glInternalFormat read new glInternalFormat($93E2);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4:        glInternalFormat read new glInternalFormat($93E3);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4:        glInternalFormat read new glInternalFormat($93E4);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4:        glInternalFormat read new glInternalFormat($93E5);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5:        glInternalFormat read new glInternalFormat($93E6);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5:        glInternalFormat read new glInternalFormat($93E7);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5:        glInternalFormat read new glInternalFormat($93E8);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6:        glInternalFormat read new glInternalFormat($93E9);
    
    public function ToString: string; override;
    begin
      if STENCIL_INDEX = self then
        Result := 'STENCIL_INDEX' else
      if DEPTH_COMPONENT = self then
        Result := 'DEPTH_COMPONENT' else
      if RED = self then
        Result := 'RED' else
      if RGB = self then
        Result := 'RGB' else
      if RGBA = self then
        Result := 'RGBA' else
      if R3_G3_B2 = self then
        Result := 'R3_G3_B2' else
      if ALPHA4 = self then
        Result := 'ALPHA4' else
      if ALPHA8 = self then
        Result := 'ALPHA8' else
      if ALPHA12 = self then
        Result := 'ALPHA12' else
      if ALPHA16 = self then
        Result := 'ALPHA16' else
      if LUMINANCE4 = self then
        Result := 'LUMINANCE4' else
      if LUMINANCE8 = self then
        Result := 'LUMINANCE8' else
      if LUMINANCE12 = self then
        Result := 'LUMINANCE12' else
      if LUMINANCE16 = self then
        Result := 'LUMINANCE16' else
      if LUMINANCE4_ALPHA4 = self then
        Result := 'LUMINANCE4_ALPHA4' else
      if LUMINANCE6_ALPHA2 = self then
        Result := 'LUMINANCE6_ALPHA2' else
      if LUMINANCE8_ALPHA8 = self then
        Result := 'LUMINANCE8_ALPHA8' else
      if LUMINANCE12_ALPHA4 = self then
        Result := 'LUMINANCE12_ALPHA4' else
      if LUMINANCE12_ALPHA12 = self then
        Result := 'LUMINANCE12_ALPHA12' else
      if LUMINANCE16_ALPHA16 = self then
        Result := 'LUMINANCE16_ALPHA16' else
      if INTENSITY = self then
        Result := 'INTENSITY' else
      if INTENSITY4 = self then
        Result := 'INTENSITY4' else
      if INTENSITY8 = self then
        Result := 'INTENSITY8' else
      if INTENSITY12 = self then
        Result := 'INTENSITY12' else
      if INTENSITY16 = self then
        Result := 'INTENSITY16' else
      if RGB2 = self then
        Result := 'RGB2' else
      if RGB4 = self then
        Result := 'RGB4' else
      if RGB5 = self then
        Result := 'RGB5' else
      if RGB8 = self then
        Result := 'RGB8' else
      if RGB10 = self then
        Result := 'RGB10' else
      if RGB12 = self then
        Result := 'RGB12' else
      if RGB16 = self then
        Result := 'RGB16' else
      if RGBA2 = self then
        Result := 'RGBA2' else
      if RGBA4 = self then
        Result := 'RGBA4' else
      if RGB5_A1 = self then
        Result := 'RGB5_A1' else
      if RGBA8 = self then
        Result := 'RGBA8' else
      if RGB10_A2 = self then
        Result := 'RGB10_A2' else
      if RGBA12 = self then
        Result := 'RGBA12' else
      if RGBA16 = self then
        Result := 'RGBA16' else
      if DUAL_ALPHA4 = self then
        Result := 'DUAL_ALPHA4' else
      if DUAL_ALPHA8 = self then
        Result := 'DUAL_ALPHA8' else
      if DUAL_ALPHA12 = self then
        Result := 'DUAL_ALPHA12' else
      if DUAL_ALPHA16 = self then
        Result := 'DUAL_ALPHA16' else
      if DUAL_LUMINANCE4 = self then
        Result := 'DUAL_LUMINANCE4' else
      if DUAL_LUMINANCE8 = self then
        Result := 'DUAL_LUMINANCE8' else
      if DUAL_LUMINANCE12 = self then
        Result := 'DUAL_LUMINANCE12' else
      if DUAL_LUMINANCE16 = self then
        Result := 'DUAL_LUMINANCE16' else
      if DUAL_INTENSITY4 = self then
        Result := 'DUAL_INTENSITY4' else
      if DUAL_INTENSITY8 = self then
        Result := 'DUAL_INTENSITY8' else
      if DUAL_INTENSITY12 = self then
        Result := 'DUAL_INTENSITY12' else
      if DUAL_INTENSITY16 = self then
        Result := 'DUAL_INTENSITY16' else
      if DUAL_LUMINANCE_ALPHA4 = self then
        Result := 'DUAL_LUMINANCE_ALPHA4' else
      if DUAL_LUMINANCE_ALPHA8 = self then
        Result := 'DUAL_LUMINANCE_ALPHA8' else
      if QUAD_ALPHA4 = self then
        Result := 'QUAD_ALPHA4' else
      if QUAD_ALPHA8 = self then
        Result := 'QUAD_ALPHA8' else
      if QUAD_LUMINANCE4 = self then
        Result := 'QUAD_LUMINANCE4' else
      if QUAD_LUMINANCE8 = self then
        Result := 'QUAD_LUMINANCE8' else
      if QUAD_INTENSITY4 = self then
        Result := 'QUAD_INTENSITY4' else
      if QUAD_INTENSITY8 = self then
        Result := 'QUAD_INTENSITY8' else
      if DEPTH_COMPONENT16 = self then
        Result := 'DEPTH_COMPONENT16' else
      if DEPTH_COMPONENT24 = self then
        Result := 'DEPTH_COMPONENT24' else
      if DEPTH_COMPONENT32 = self then
        Result := 'DEPTH_COMPONENT32' else
      if COMPRESSED_RED = self then
        Result := 'COMPRESSED_RED' else
      if COMPRESSED_RG = self then
        Result := 'COMPRESSED_RG' else
      if RG = self then
        Result := 'RG' else
      if R8 = self then
        Result := 'R8' else
      if R16 = self then
        Result := 'R16' else
      if RG8 = self then
        Result := 'RG8' else
      if RG16 = self then
        Result := 'RG16' else
      if R16F = self then
        Result := 'R16F' else
      if R32F = self then
        Result := 'R32F' else
      if RG16F = self then
        Result := 'RG16F' else
      if RG32F = self then
        Result := 'RG32F' else
      if R8I = self then
        Result := 'R8I' else
      if R8UI = self then
        Result := 'R8UI' else
      if R16I = self then
        Result := 'R16I' else
      if R16UI = self then
        Result := 'R16UI' else
      if R32I = self then
        Result := 'R32I' else
      if R32UI = self then
        Result := 'R32UI' else
      if RG8I = self then
        Result := 'RG8I' else
      if RG8UI = self then
        Result := 'RG8UI' else
      if RG16I = self then
        Result := 'RG16I' else
      if RG16UI = self then
        Result := 'RG16UI' else
      if RG32I = self then
        Result := 'RG32I' else
      if RG32UI = self then
        Result := 'RG32UI' else
      if COMPRESSED_RGB_S3TC_DXT1 = self then
        Result := 'COMPRESSED_RGB_S3TC_DXT1' else
      if COMPRESSED_RGBA_S3TC_DXT1 = self then
        Result := 'COMPRESSED_RGBA_S3TC_DXT1' else
      if COMPRESSED_RGBA_S3TC_DXT3 = self then
        Result := 'COMPRESSED_RGBA_S3TC_DXT3' else
      if COMPRESSED_RGBA_S3TC_DXT5 = self then
        Result := 'COMPRESSED_RGBA_S3TC_DXT5' else
      if COMPRESSED_RGB = self then
        Result := 'COMPRESSED_RGB' else
      if COMPRESSED_RGBA = self then
        Result := 'COMPRESSED_RGBA' else
      if DEPTH_STENCIL = self then
        Result := 'DEPTH_STENCIL' else
      if DEPTH_STENCIL_MESA = self then
        Result := 'DEPTH_STENCIL_MESA' else
      if RGBA32F = self then
        Result := 'RGBA32F' else
      if RGB32F = self then
        Result := 'RGB32F' else
      if RGBA16F = self then
        Result := 'RGBA16F' else
      if RGB16F = self then
        Result := 'RGB16F' else
      if DEPTH24_STENCIL8 = self then
        Result := 'DEPTH24_STENCIL8' else
      if R11F_G11F_B10F = self then
        Result := 'R11F_G11F_B10F' else
      if RGB9_E5 = self then
        Result := 'RGB9_E5' else
      if SRGB = self then
        Result := 'SRGB' else
      if SRGB8 = self then
        Result := 'SRGB8' else
      if SRGB_ALPHA = self then
        Result := 'SRGB_ALPHA' else
      if SRGB8_ALPHA8 = self then
        Result := 'SRGB8_ALPHA8' else
      if COMPRESSED_SRGB = self then
        Result := 'COMPRESSED_SRGB' else
      if COMPRESSED_SRGB_ALPHA = self then
        Result := 'COMPRESSED_SRGB_ALPHA' else
      if COMPRESSED_SRGB_S3TC_DXT1 = self then
        Result := 'COMPRESSED_SRGB_S3TC_DXT1' else
      if COMPRESSED_SRGB_ALPHA_S3TC_DXT1 = self then
        Result := 'COMPRESSED_SRGB_ALPHA_S3TC_DXT1' else
      if COMPRESSED_SRGB_ALPHA_S3TC_DXT3 = self then
        Result := 'COMPRESSED_SRGB_ALPHA_S3TC_DXT3' else
      if COMPRESSED_SRGB_ALPHA_S3TC_DXT5 = self then
        Result := 'COMPRESSED_SRGB_ALPHA_S3TC_DXT5' else
      if DEPTH_COMPONENT32F = self then
        Result := 'DEPTH_COMPONENT32F' else
      if DEPTH32F_STENCIL8 = self then
        Result := 'DEPTH32F_STENCIL8' else
      if STENCIL_INDEX1 = self then
        Result := 'STENCIL_INDEX1' else
      if STENCIL_INDEX4 = self then
        Result := 'STENCIL_INDEX4' else
      if STENCIL_INDEX8 = self then
        Result := 'STENCIL_INDEX8' else
      if STENCIL_INDEX16 = self then
        Result := 'STENCIL_INDEX16' else
      if RGB565 = self then
        Result := 'RGB565' else
      if ETC1_RGB8 = self then
        Result := 'ETC1_RGB8' else
      if RGBA32UI = self then
        Result := 'RGBA32UI' else
      if RGB32UI = self then
        Result := 'RGB32UI' else
      if ALPHA32UI = self then
        Result := 'ALPHA32UI' else
      if INTENSITY32UI = self then
        Result := 'INTENSITY32UI' else
      if LUMINANCE32UI = self then
        Result := 'LUMINANCE32UI' else
      if LUMINANCE_ALPHA32UI = self then
        Result := 'LUMINANCE_ALPHA32UI' else
      if RGBA16UI = self then
        Result := 'RGBA16UI' else
      if RGB16UI = self then
        Result := 'RGB16UI' else
      if ALPHA16UI = self then
        Result := 'ALPHA16UI' else
      if INTENSITY16UI = self then
        Result := 'INTENSITY16UI' else
      if LUMINANCE16UI = self then
        Result := 'LUMINANCE16UI' else
      if LUMINANCE_ALPHA16UI = self then
        Result := 'LUMINANCE_ALPHA16UI' else
      if RGBA8UI = self then
        Result := 'RGBA8UI' else
      if RGB8UI = self then
        Result := 'RGB8UI' else
      if ALPHA8UI = self then
        Result := 'ALPHA8UI' else
      if INTENSITY8UI = self then
        Result := 'INTENSITY8UI' else
      if LUMINANCE8UI = self then
        Result := 'LUMINANCE8UI' else
      if LUMINANCE_ALPHA8UI = self then
        Result := 'LUMINANCE_ALPHA8UI' else
      if RGBA32I = self then
        Result := 'RGBA32I' else
      if RGB32I = self then
        Result := 'RGB32I' else
      if ALPHA32I = self then
        Result := 'ALPHA32I' else
      if INTENSITY32I = self then
        Result := 'INTENSITY32I' else
      if LUMINANCE32I = self then
        Result := 'LUMINANCE32I' else
      if LUMINANCE_ALPHA32I = self then
        Result := 'LUMINANCE_ALPHA32I' else
      if RGBA16I = self then
        Result := 'RGBA16I' else
      if RGB16I = self then
        Result := 'RGB16I' else
      if ALPHA16I = self then
        Result := 'ALPHA16I' else
      if INTENSITY16I = self then
        Result := 'INTENSITY16I' else
      if LUMINANCE16I = self then
        Result := 'LUMINANCE16I' else
      if LUMINANCE_ALPHA16I = self then
        Result := 'LUMINANCE_ALPHA16I' else
      if RGBA8I = self then
        Result := 'RGBA8I' else
      if RGB8I = self then
        Result := 'RGB8I' else
      if ALPHA8I = self then
        Result := 'ALPHA8I' else
      if INTENSITY8I = self then
        Result := 'INTENSITY8I' else
      if LUMINANCE8I = self then
        Result := 'LUMINANCE8I' else
      if LUMINANCE_ALPHA8I = self then
        Result := 'LUMINANCE_ALPHA8I' else
      if DEPTH_COMPONENT32F_NV = self then
        Result := 'DEPTH_COMPONENT32F_NV' else
      if DEPTH32F_STENCIL8_NV = self then
        Result := 'DEPTH32F_STENCIL8_NV' else
      if COMPRESSED_RED_RGTC1 = self then
        Result := 'COMPRESSED_RED_RGTC1' else
      if COMPRESSED_SIGNED_RED_RGTC1 = self then
        Result := 'COMPRESSED_SIGNED_RED_RGTC1' else
      if COMPRESSED_RED_GREEN_RGTC2 = self then
        Result := 'COMPRESSED_RED_GREEN_RGTC2' else
      if COMPRESSED_RG_RGTC2 = self then
        Result := 'COMPRESSED_RG_RGTC2' else
      if COMPRESSED_SIGNED_RED_GREEN_RGTC2 = self then
        Result := 'COMPRESSED_SIGNED_RED_GREEN_RGTC2' else
      if COMPRESSED_SIGNED_RG_RGTC2 = self then
        Result := 'COMPRESSED_SIGNED_RG_RGTC2' else
      if COMPRESSED_RGBA_BPTC_UNORM = self then
        Result := 'COMPRESSED_RGBA_BPTC_UNORM' else
      if COMPRESSED_SRGB_ALPHA_BPTC_UNORM = self then
        Result := 'COMPRESSED_SRGB_ALPHA_BPTC_UNORM' else
      if COMPRESSED_RGB_BPTC_SIGNED_FLOAT = self then
        Result := 'COMPRESSED_RGB_BPTC_SIGNED_FLOAT' else
      if COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = self then
        Result := 'COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT' else
      if R8_SNORM = self then
        Result := 'R8_SNORM' else
      if RG8_SNORM = self then
        Result := 'RG8_SNORM' else
      if RGB8_SNORM = self then
        Result := 'RGB8_SNORM' else
      if RGBA8_SNORM = self then
        Result := 'RGBA8_SNORM' else
      if R16_SNORM = self then
        Result := 'R16_SNORM' else
      if RG16_SNORM = self then
        Result := 'RG16_SNORM' else
      if RGB16_SNORM = self then
        Result := 'RGB16_SNORM' else
      if RGBA16_SNORM = self then
        Result := 'RGBA16_SNORM' else
      if SR8 = self then
        Result := 'SR8' else
      if SRG8 = self then
        Result := 'SRG8' else
      if RGB10_A2UI = self then
        Result := 'RGB10_A2UI' else
      if COMPRESSED_R11_EAC = self then
        Result := 'COMPRESSED_R11_EAC' else
      if COMPRESSED_SIGNED_R11_EAC = self then
        Result := 'COMPRESSED_SIGNED_R11_EAC' else
      if COMPRESSED_RG11_EAC = self then
        Result := 'COMPRESSED_RG11_EAC' else
      if COMPRESSED_SIGNED_RG11_EAC = self then
        Result := 'COMPRESSED_SIGNED_RG11_EAC' else
      if COMPRESSED_RGB8_ETC2 = self then
        Result := 'COMPRESSED_RGB8_ETC2' else
      if COMPRESSED_SRGB8_ETC2 = self then
        Result := 'COMPRESSED_SRGB8_ETC2' else
      if COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = self then
        Result := 'COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2' else
      if COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = self then
        Result := 'COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2' else
      if COMPRESSED_RGBA8_ETC2_EAC = self then
        Result := 'COMPRESSED_RGBA8_ETC2_EAC' else
      if COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ETC2_EAC' else
      if COMPRESSED_RGBA_ASTC_4x4 = self then
        Result := 'COMPRESSED_RGBA_ASTC_4x4' else
      if COMPRESSED_RGBA_ASTC_5x4 = self then
        Result := 'COMPRESSED_RGBA_ASTC_5x4' else
      if COMPRESSED_RGBA_ASTC_5x5 = self then
        Result := 'COMPRESSED_RGBA_ASTC_5x5' else
      if COMPRESSED_RGBA_ASTC_6x5 = self then
        Result := 'COMPRESSED_RGBA_ASTC_6x5' else
      if COMPRESSED_RGBA_ASTC_6x6 = self then
        Result := 'COMPRESSED_RGBA_ASTC_6x6' else
      if COMPRESSED_RGBA_ASTC_8x5 = self then
        Result := 'COMPRESSED_RGBA_ASTC_8x5' else
      if COMPRESSED_RGBA_ASTC_8x6 = self then
        Result := 'COMPRESSED_RGBA_ASTC_8x6' else
      if COMPRESSED_RGBA_ASTC_8x8 = self then
        Result := 'COMPRESSED_RGBA_ASTC_8x8' else
      if COMPRESSED_RGBA_ASTC_10x5 = self then
        Result := 'COMPRESSED_RGBA_ASTC_10x5' else
      if COMPRESSED_RGBA_ASTC_10x6 = self then
        Result := 'COMPRESSED_RGBA_ASTC_10x6' else
      if COMPRESSED_RGBA_ASTC_10x8 = self then
        Result := 'COMPRESSED_RGBA_ASTC_10x8' else
      if COMPRESSED_RGBA_ASTC_10x10 = self then
        Result := 'COMPRESSED_RGBA_ASTC_10x10' else
      if COMPRESSED_RGBA_ASTC_12x10 = self then
        Result := 'COMPRESSED_RGBA_ASTC_12x10' else
      if COMPRESSED_RGBA_ASTC_12x12 = self then
        Result := 'COMPRESSED_RGBA_ASTC_12x12' else
      if COMPRESSED_RGBA_ASTC_3x3x3 = self then
        Result := 'COMPRESSED_RGBA_ASTC_3x3x3' else
      if COMPRESSED_RGBA_ASTC_4x3x3 = self then
        Result := 'COMPRESSED_RGBA_ASTC_4x3x3' else
      if COMPRESSED_RGBA_ASTC_4x4x3 = self then
        Result := 'COMPRESSED_RGBA_ASTC_4x4x3' else
      if COMPRESSED_RGBA_ASTC_4x4x4 = self then
        Result := 'COMPRESSED_RGBA_ASTC_4x4x4' else
      if COMPRESSED_RGBA_ASTC_5x4x4 = self then
        Result := 'COMPRESSED_RGBA_ASTC_5x4x4' else
      if COMPRESSED_RGBA_ASTC_5x5x4 = self then
        Result := 'COMPRESSED_RGBA_ASTC_5x5x4' else
      if COMPRESSED_RGBA_ASTC_5x5x5 = self then
        Result := 'COMPRESSED_RGBA_ASTC_5x5x5' else
      if COMPRESSED_RGBA_ASTC_6x5x5 = self then
        Result := 'COMPRESSED_RGBA_ASTC_6x5x5' else
      if COMPRESSED_RGBA_ASTC_6x6x5 = self then
        Result := 'COMPRESSED_RGBA_ASTC_6x6x5' else
      if COMPRESSED_RGBA_ASTC_6x6x6 = self then
        Result := 'COMPRESSED_RGBA_ASTC_6x6x6' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_4x4 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x4' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_5x4 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x4' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_5x5 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x5' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_6x5 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x5' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_6x6 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x6' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_8x5 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x5' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_8x6 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x6' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_8x8 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x8' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_10x5 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x5' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_10x6 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x6' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_10x8 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x8' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_10x10 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x10' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_12x10 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_12x10' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_12x12 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_12x12' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6' else
        Result := $'glInternalFormat[{self.val}]';
    end;
    
  end;
  
  glInternalFormatPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SAMPLES:                                glInternalFormatPName read new glInternalFormatPName($80A9);
    public static property GENERATE_MIPMAP:                        glInternalFormatPName read new glInternalFormatPName($8191);
    public static property INTERNALFORMAT_SUPPORTED:               glInternalFormatPName read new glInternalFormatPName($826F);
    public static property INTERNALFORMAT_PREFERRED:               glInternalFormatPName read new glInternalFormatPName($8270);
    public static property INTERNALFORMAT_RED_SIZE:                glInternalFormatPName read new glInternalFormatPName($8271);
    public static property INTERNALFORMAT_GREEN_SIZE:              glInternalFormatPName read new glInternalFormatPName($8272);
    public static property INTERNALFORMAT_BLUE_SIZE:               glInternalFormatPName read new glInternalFormatPName($8273);
    public static property INTERNALFORMAT_ALPHA_SIZE:              glInternalFormatPName read new glInternalFormatPName($8274);
    public static property INTERNALFORMAT_DEPTH_SIZE:              glInternalFormatPName read new glInternalFormatPName($8275);
    public static property INTERNALFORMAT_STENCIL_SIZE:            glInternalFormatPName read new glInternalFormatPName($8276);
    public static property INTERNALFORMAT_SHARED_SIZE:             glInternalFormatPName read new glInternalFormatPName($8277);
    public static property INTERNALFORMAT_RED_TYPE:                glInternalFormatPName read new glInternalFormatPName($8278);
    public static property INTERNALFORMAT_GREEN_TYPE:              glInternalFormatPName read new glInternalFormatPName($8279);
    public static property INTERNALFORMAT_BLUE_TYPE:               glInternalFormatPName read new glInternalFormatPName($827A);
    public static property INTERNALFORMAT_ALPHA_TYPE:              glInternalFormatPName read new glInternalFormatPName($827B);
    public static property INTERNALFORMAT_DEPTH_TYPE:              glInternalFormatPName read new glInternalFormatPName($827C);
    public static property INTERNALFORMAT_STENCIL_TYPE:            glInternalFormatPName read new glInternalFormatPName($827D);
    public static property MAX_WIDTH:                              glInternalFormatPName read new glInternalFormatPName($827E);
    public static property MAX_HEIGHT:                             glInternalFormatPName read new glInternalFormatPName($827F);
    public static property MAX_DEPTH:                              glInternalFormatPName read new glInternalFormatPName($8280);
    public static property MAX_LAYERS:                             glInternalFormatPName read new glInternalFormatPName($8281);
    public static property COLOR_COMPONENTS:                       glInternalFormatPName read new glInternalFormatPName($8283);
    public static property COLOR_RENDERABLE:                       glInternalFormatPName read new glInternalFormatPName($8286);
    public static property DEPTH_RENDERABLE:                       glInternalFormatPName read new glInternalFormatPName($8287);
    public static property STENCIL_RENDERABLE:                     glInternalFormatPName read new glInternalFormatPName($8288);
    public static property FRAMEBUFFER_RENDERABLE:                 glInternalFormatPName read new glInternalFormatPName($8289);
    public static property FRAMEBUFFER_RENDERABLE_LAYERED:         glInternalFormatPName read new glInternalFormatPName($828A);
    public static property FRAMEBUFFER_BLEND:                      glInternalFormatPName read new glInternalFormatPName($828B);
    public static property READ_PIXELS:                            glInternalFormatPName read new glInternalFormatPName($828C);
    public static property READ_PIXELS_FORMAT:                     glInternalFormatPName read new glInternalFormatPName($828D);
    public static property READ_PIXELS_TYPE:                       glInternalFormatPName read new glInternalFormatPName($828E);
    public static property TEXTURE_IMAGE_FORMAT:                   glInternalFormatPName read new glInternalFormatPName($828F);
    public static property TEXTURE_IMAGE_TYPE:                     glInternalFormatPName read new glInternalFormatPName($8290);
    public static property _GET_TEXTURE_IMAGE_FORMAT:              glInternalFormatPName read new glInternalFormatPName($8291);
    public static property _GET_TEXTURE_IMAGE_TYPE:                glInternalFormatPName read new glInternalFormatPName($8292);
    public static property MIPMAP:                                 glInternalFormatPName read new glInternalFormatPName($8293);
    public static property AUTO_GENERATE_MIPMAP:                   glInternalFormatPName read new glInternalFormatPName($8295);
    public static property COLOR_ENCODING:                         glInternalFormatPName read new glInternalFormatPName($8296);
    public static property SRGB_READ:                              glInternalFormatPName read new glInternalFormatPName($8297);
    public static property SRGB_WRITE:                             glInternalFormatPName read new glInternalFormatPName($8298);
    public static property FILTER:                                 glInternalFormatPName read new glInternalFormatPName($829A);
    public static property VERTEX_TEXTURE:                         glInternalFormatPName read new glInternalFormatPName($829B);
    public static property TESS_CONTROL_TEXTURE:                   glInternalFormatPName read new glInternalFormatPName($829C);
    public static property TESS_EVALUATION_TEXTURE:                glInternalFormatPName read new glInternalFormatPName($829D);
    public static property GEOMETRY_TEXTURE:                       glInternalFormatPName read new glInternalFormatPName($829E);
    public static property FRAGMENT_TEXTURE:                       glInternalFormatPName read new glInternalFormatPName($829F);
    public static property COMPUTE_TEXTURE:                        glInternalFormatPName read new glInternalFormatPName($82A0);
    public static property TEXTURE_SHADOW:                         glInternalFormatPName read new glInternalFormatPName($82A1);
    public static property TEXTURE_GATHER:                         glInternalFormatPName read new glInternalFormatPName($82A2);
    public static property TEXTURE_GATHER_SHADOW:                  glInternalFormatPName read new glInternalFormatPName($82A3);
    public static property SHADER_IMAGE_LOAD:                      glInternalFormatPName read new glInternalFormatPName($82A4);
    public static property SHADER_IMAGE_STORE:                     glInternalFormatPName read new glInternalFormatPName($82A5);
    public static property SHADER_IMAGE_ATOMIC:                    glInternalFormatPName read new glInternalFormatPName($82A6);
    public static property IMAGE_TEXEL_SIZE:                       glInternalFormatPName read new glInternalFormatPName($82A7);
    public static property IMAGE_COMPATIBILITY_CLASS:              glInternalFormatPName read new glInternalFormatPName($82A8);
    public static property IMAGE_PIXEL_FORMAT:                     glInternalFormatPName read new glInternalFormatPName($82A9);
    public static property IMAGE_PIXEL_TYPE:                       glInternalFormatPName read new glInternalFormatPName($82AA);
    public static property SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST:    glInternalFormatPName read new glInternalFormatPName($82AC);
    public static property SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST:  glInternalFormatPName read new glInternalFormatPName($82AD);
    public static property SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE:   glInternalFormatPName read new glInternalFormatPName($82AE);
    public static property SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE: glInternalFormatPName read new glInternalFormatPName($82AF);
    public static property TEXTURE_COMPRESSED_BLOCK_WIDTH:         glInternalFormatPName read new glInternalFormatPName($82B1);
    public static property TEXTURE_COMPRESSED_BLOCK_HEIGHT:        glInternalFormatPName read new glInternalFormatPName($82B2);
    public static property TEXTURE_COMPRESSED_BLOCK_SIZE:          glInternalFormatPName read new glInternalFormatPName($82B3);
    public static property CLEAR_BUFFER:                           glInternalFormatPName read new glInternalFormatPName($82B4);
    public static property TEXTURE_VIEW:                           glInternalFormatPName read new glInternalFormatPName($82B5);
    public static property VIEW_COMPATIBILITY_CLASS:               glInternalFormatPName read new glInternalFormatPName($82B6);
    public static property TEXTURE_COMPRESSED:                     glInternalFormatPName read new glInternalFormatPName($86A1);
    public static property NUM_SURFACE_COMPRESSION_FIXED_RATES:    glInternalFormatPName read new glInternalFormatPName($8F6E);
    public static property IMAGE_FORMAT_COMPATIBILITY_TYPE:        glInternalFormatPName read new glInternalFormatPName($90C7);
    public static property CLEAR_TEXTURE:                          glInternalFormatPName read new glInternalFormatPName($9365);
    public static property NUM_SAMPLE_COUNTS:                      glInternalFormatPName read new glInternalFormatPName($9380);
    
    public function ToString: string; override;
    begin
      if SAMPLES = self then
        Result := 'SAMPLES' else
      if GENERATE_MIPMAP = self then
        Result := 'GENERATE_MIPMAP' else
      if INTERNALFORMAT_SUPPORTED = self then
        Result := 'INTERNALFORMAT_SUPPORTED' else
      if INTERNALFORMAT_PREFERRED = self then
        Result := 'INTERNALFORMAT_PREFERRED' else
      if INTERNALFORMAT_RED_SIZE = self then
        Result := 'INTERNALFORMAT_RED_SIZE' else
      if INTERNALFORMAT_GREEN_SIZE = self then
        Result := 'INTERNALFORMAT_GREEN_SIZE' else
      if INTERNALFORMAT_BLUE_SIZE = self then
        Result := 'INTERNALFORMAT_BLUE_SIZE' else
      if INTERNALFORMAT_ALPHA_SIZE = self then
        Result := 'INTERNALFORMAT_ALPHA_SIZE' else
      if INTERNALFORMAT_DEPTH_SIZE = self then
        Result := 'INTERNALFORMAT_DEPTH_SIZE' else
      if INTERNALFORMAT_STENCIL_SIZE = self then
        Result := 'INTERNALFORMAT_STENCIL_SIZE' else
      if INTERNALFORMAT_SHARED_SIZE = self then
        Result := 'INTERNALFORMAT_SHARED_SIZE' else
      if INTERNALFORMAT_RED_TYPE = self then
        Result := 'INTERNALFORMAT_RED_TYPE' else
      if INTERNALFORMAT_GREEN_TYPE = self then
        Result := 'INTERNALFORMAT_GREEN_TYPE' else
      if INTERNALFORMAT_BLUE_TYPE = self then
        Result := 'INTERNALFORMAT_BLUE_TYPE' else
      if INTERNALFORMAT_ALPHA_TYPE = self then
        Result := 'INTERNALFORMAT_ALPHA_TYPE' else
      if INTERNALFORMAT_DEPTH_TYPE = self then
        Result := 'INTERNALFORMAT_DEPTH_TYPE' else
      if INTERNALFORMAT_STENCIL_TYPE = self then
        Result := 'INTERNALFORMAT_STENCIL_TYPE' else
      if MAX_WIDTH = self then
        Result := 'MAX_WIDTH' else
      if MAX_HEIGHT = self then
        Result := 'MAX_HEIGHT' else
      if MAX_DEPTH = self then
        Result := 'MAX_DEPTH' else
      if MAX_LAYERS = self then
        Result := 'MAX_LAYERS' else
      if COLOR_COMPONENTS = self then
        Result := 'COLOR_COMPONENTS' else
      if COLOR_RENDERABLE = self then
        Result := 'COLOR_RENDERABLE' else
      if DEPTH_RENDERABLE = self then
        Result := 'DEPTH_RENDERABLE' else
      if STENCIL_RENDERABLE = self then
        Result := 'STENCIL_RENDERABLE' else
      if FRAMEBUFFER_RENDERABLE = self then
        Result := 'FRAMEBUFFER_RENDERABLE' else
      if FRAMEBUFFER_RENDERABLE_LAYERED = self then
        Result := 'FRAMEBUFFER_RENDERABLE_LAYERED' else
      if FRAMEBUFFER_BLEND = self then
        Result := 'FRAMEBUFFER_BLEND' else
      if READ_PIXELS = self then
        Result := 'READ_PIXELS' else
      if READ_PIXELS_FORMAT = self then
        Result := 'READ_PIXELS_FORMAT' else
      if READ_PIXELS_TYPE = self then
        Result := 'READ_PIXELS_TYPE' else
      if TEXTURE_IMAGE_FORMAT = self then
        Result := 'TEXTURE_IMAGE_FORMAT' else
      if TEXTURE_IMAGE_TYPE = self then
        Result := 'TEXTURE_IMAGE_TYPE' else
      if _GET_TEXTURE_IMAGE_FORMAT = self then
        Result := '_GET_TEXTURE_IMAGE_FORMAT' else
      if _GET_TEXTURE_IMAGE_TYPE = self then
        Result := '_GET_TEXTURE_IMAGE_TYPE' else
      if MIPMAP = self then
        Result := 'MIPMAP' else
      if AUTO_GENERATE_MIPMAP = self then
        Result := 'AUTO_GENERATE_MIPMAP' else
      if COLOR_ENCODING = self then
        Result := 'COLOR_ENCODING' else
      if SRGB_READ = self then
        Result := 'SRGB_READ' else
      if SRGB_WRITE = self then
        Result := 'SRGB_WRITE' else
      if FILTER = self then
        Result := 'FILTER' else
      if VERTEX_TEXTURE = self then
        Result := 'VERTEX_TEXTURE' else
      if TESS_CONTROL_TEXTURE = self then
        Result := 'TESS_CONTROL_TEXTURE' else
      if TESS_EVALUATION_TEXTURE = self then
        Result := 'TESS_EVALUATION_TEXTURE' else
      if GEOMETRY_TEXTURE = self then
        Result := 'GEOMETRY_TEXTURE' else
      if FRAGMENT_TEXTURE = self then
        Result := 'FRAGMENT_TEXTURE' else
      if COMPUTE_TEXTURE = self then
        Result := 'COMPUTE_TEXTURE' else
      if TEXTURE_SHADOW = self then
        Result := 'TEXTURE_SHADOW' else
      if TEXTURE_GATHER = self then
        Result := 'TEXTURE_GATHER' else
      if TEXTURE_GATHER_SHADOW = self then
        Result := 'TEXTURE_GATHER_SHADOW' else
      if SHADER_IMAGE_LOAD = self then
        Result := 'SHADER_IMAGE_LOAD' else
      if SHADER_IMAGE_STORE = self then
        Result := 'SHADER_IMAGE_STORE' else
      if SHADER_IMAGE_ATOMIC = self then
        Result := 'SHADER_IMAGE_ATOMIC' else
      if IMAGE_TEXEL_SIZE = self then
        Result := 'IMAGE_TEXEL_SIZE' else
      if IMAGE_COMPATIBILITY_CLASS = self then
        Result := 'IMAGE_COMPATIBILITY_CLASS' else
      if IMAGE_PIXEL_FORMAT = self then
        Result := 'IMAGE_PIXEL_FORMAT' else
      if IMAGE_PIXEL_TYPE = self then
        Result := 'IMAGE_PIXEL_TYPE' else
      if SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST = self then
        Result := 'SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST' else
      if SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST = self then
        Result := 'SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST' else
      if SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE = self then
        Result := 'SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE' else
      if SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE = self then
        Result := 'SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE' else
      if TEXTURE_COMPRESSED_BLOCK_WIDTH = self then
        Result := 'TEXTURE_COMPRESSED_BLOCK_WIDTH' else
      if TEXTURE_COMPRESSED_BLOCK_HEIGHT = self then
        Result := 'TEXTURE_COMPRESSED_BLOCK_HEIGHT' else
      if TEXTURE_COMPRESSED_BLOCK_SIZE = self then
        Result := 'TEXTURE_COMPRESSED_BLOCK_SIZE' else
      if CLEAR_BUFFER = self then
        Result := 'CLEAR_BUFFER' else
      if TEXTURE_VIEW = self then
        Result := 'TEXTURE_VIEW' else
      if VIEW_COMPATIBILITY_CLASS = self then
        Result := 'VIEW_COMPATIBILITY_CLASS' else
      if TEXTURE_COMPRESSED = self then
        Result := 'TEXTURE_COMPRESSED' else
      if NUM_SURFACE_COMPRESSION_FIXED_RATES = self then
        Result := 'NUM_SURFACE_COMPRESSION_FIXED_RATES' else
      if IMAGE_FORMAT_COMPATIBILITY_TYPE = self then
        Result := 'IMAGE_FORMAT_COMPATIBILITY_TYPE' else
      if CLEAR_TEXTURE = self then
        Result := 'CLEAR_TEXTURE' else
      if NUM_SAMPLE_COUNTS = self then
        Result := 'NUM_SAMPLE_COUNTS' else
        Result := $'glInternalFormatPName[{self.val}]';
    end;
    
  end;
  
  glInvalidateFramebufferAttachment = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COLOR:                    glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($1800);
    public static property DEPTH:                    glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($1801);
    public static property STENCIL:                  glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($1802);
    public static property DEPTH_STENCIL_ATTACHMENT: glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($821A);
    public static property COLOR_ATTACHMENT0:        glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CE0);
    public static property COLOR_ATTACHMENT1:        glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CE1);
    public static property COLOR_ATTACHMENT2:        glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CE2);
    public static property COLOR_ATTACHMENT3:        glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CE3);
    public static property COLOR_ATTACHMENT4:        glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CE4);
    public static property COLOR_ATTACHMENT5:        glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CE5);
    public static property COLOR_ATTACHMENT6:        glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CE6);
    public static property COLOR_ATTACHMENT7:        glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CE7);
    public static property COLOR_ATTACHMENT8:        glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CE8);
    public static property COLOR_ATTACHMENT9:        glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CE9);
    public static property COLOR_ATTACHMENT10:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CEA);
    public static property COLOR_ATTACHMENT11:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CEB);
    public static property COLOR_ATTACHMENT12:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CEC);
    public static property COLOR_ATTACHMENT13:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CED);
    public static property COLOR_ATTACHMENT14:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CEE);
    public static property COLOR_ATTACHMENT15:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CEF);
    public static property COLOR_ATTACHMENT16:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CF0);
    public static property COLOR_ATTACHMENT17:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CF1);
    public static property COLOR_ATTACHMENT18:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CF2);
    public static property COLOR_ATTACHMENT19:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CF3);
    public static property COLOR_ATTACHMENT20:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CF4);
    public static property COLOR_ATTACHMENT21:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CF5);
    public static property COLOR_ATTACHMENT22:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CF6);
    public static property COLOR_ATTACHMENT23:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CF7);
    public static property COLOR_ATTACHMENT24:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CF8);
    public static property COLOR_ATTACHMENT25:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CF9);
    public static property COLOR_ATTACHMENT26:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CFA);
    public static property COLOR_ATTACHMENT27:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CFB);
    public static property COLOR_ATTACHMENT28:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CFC);
    public static property COLOR_ATTACHMENT29:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CFD);
    public static property COLOR_ATTACHMENT30:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CFE);
    public static property COLOR_ATTACHMENT31:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8CFF);
    public static property DEPTH_ATTACHMENT:         glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8D00);
    public static property STENCIL_ATTACHMENT:       glInvalidateFramebufferAttachment read new glInvalidateFramebufferAttachment($8D20);
    
    public function ToString: string; override;
    begin
      if COLOR = self then
        Result := 'COLOR' else
      if DEPTH = self then
        Result := 'DEPTH' else
      if STENCIL = self then
        Result := 'STENCIL' else
      if DEPTH_STENCIL_ATTACHMENT = self then
        Result := 'DEPTH_STENCIL_ATTACHMENT' else
      if COLOR_ATTACHMENT0 = self then
        Result := 'COLOR_ATTACHMENT0' else
      if COLOR_ATTACHMENT1 = self then
        Result := 'COLOR_ATTACHMENT1' else
      if COLOR_ATTACHMENT2 = self then
        Result := 'COLOR_ATTACHMENT2' else
      if COLOR_ATTACHMENT3 = self then
        Result := 'COLOR_ATTACHMENT3' else
      if COLOR_ATTACHMENT4 = self then
        Result := 'COLOR_ATTACHMENT4' else
      if COLOR_ATTACHMENT5 = self then
        Result := 'COLOR_ATTACHMENT5' else
      if COLOR_ATTACHMENT6 = self then
        Result := 'COLOR_ATTACHMENT6' else
      if COLOR_ATTACHMENT7 = self then
        Result := 'COLOR_ATTACHMENT7' else
      if COLOR_ATTACHMENT8 = self then
        Result := 'COLOR_ATTACHMENT8' else
      if COLOR_ATTACHMENT9 = self then
        Result := 'COLOR_ATTACHMENT9' else
      if COLOR_ATTACHMENT10 = self then
        Result := 'COLOR_ATTACHMENT10' else
      if COLOR_ATTACHMENT11 = self then
        Result := 'COLOR_ATTACHMENT11' else
      if COLOR_ATTACHMENT12 = self then
        Result := 'COLOR_ATTACHMENT12' else
      if COLOR_ATTACHMENT13 = self then
        Result := 'COLOR_ATTACHMENT13' else
      if COLOR_ATTACHMENT14 = self then
        Result := 'COLOR_ATTACHMENT14' else
      if COLOR_ATTACHMENT15 = self then
        Result := 'COLOR_ATTACHMENT15' else
      if COLOR_ATTACHMENT16 = self then
        Result := 'COLOR_ATTACHMENT16' else
      if COLOR_ATTACHMENT17 = self then
        Result := 'COLOR_ATTACHMENT17' else
      if COLOR_ATTACHMENT18 = self then
        Result := 'COLOR_ATTACHMENT18' else
      if COLOR_ATTACHMENT19 = self then
        Result := 'COLOR_ATTACHMENT19' else
      if COLOR_ATTACHMENT20 = self then
        Result := 'COLOR_ATTACHMENT20' else
      if COLOR_ATTACHMENT21 = self then
        Result := 'COLOR_ATTACHMENT21' else
      if COLOR_ATTACHMENT22 = self then
        Result := 'COLOR_ATTACHMENT22' else
      if COLOR_ATTACHMENT23 = self then
        Result := 'COLOR_ATTACHMENT23' else
      if COLOR_ATTACHMENT24 = self then
        Result := 'COLOR_ATTACHMENT24' else
      if COLOR_ATTACHMENT25 = self then
        Result := 'COLOR_ATTACHMENT25' else
      if COLOR_ATTACHMENT26 = self then
        Result := 'COLOR_ATTACHMENT26' else
      if COLOR_ATTACHMENT27 = self then
        Result := 'COLOR_ATTACHMENT27' else
      if COLOR_ATTACHMENT28 = self then
        Result := 'COLOR_ATTACHMENT28' else
      if COLOR_ATTACHMENT29 = self then
        Result := 'COLOR_ATTACHMENT29' else
      if COLOR_ATTACHMENT30 = self then
        Result := 'COLOR_ATTACHMENT30' else
      if COLOR_ATTACHMENT31 = self then
        Result := 'COLOR_ATTACHMENT31' else
      if DEPTH_ATTACHMENT = self then
        Result := 'DEPTH_ATTACHMENT' else
      if STENCIL_ATTACHMENT = self then
        Result := 'STENCIL_ATTACHMENT' else
        Result := $'glInvalidateFramebufferAttachment[{self.val}]';
    end;
    
  end;
  
  glLightEnvMode = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property ADD:      glLightEnvMode read new glLightEnvMode($0104);
    public static property REPLACE:  glLightEnvMode read new glLightEnvMode($1E01);
    public static property MODULATE: glLightEnvMode read new glLightEnvMode($2100);
    
    public function ToString: string; override;
    begin
      if ADD = self then
        Result := 'ADD' else
      if REPLACE = self then
        Result := 'REPLACE' else
      if MODULATE = self then
        Result := 'MODULATE' else
        Result := $'glLightEnvMode[{self.val}]';
    end;
    
  end;
  
  glLightEnvParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LIGHT_ENV_MODE: glLightEnvParameter read new glLightEnvParameter($8407);
    
    public function ToString: string; override;
    begin
      if LIGHT_ENV_MODE = self then
        Result := 'LIGHT_ENV_MODE' else
        Result := $'glLightEnvParameter[{self.val}]';
    end;
    
  end;
  
  glLightModelColorControl = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SINGLE_COLOR:            glLightModelColorControl read new glLightModelColorControl($81F9);
    public static property SEPARATE_SPECULAR_COLOR: glLightModelColorControl read new glLightModelColorControl($81FA);
    
    public function ToString: string; override;
    begin
      if SINGLE_COLOR = self then
        Result := 'SINGLE_COLOR' else
      if SEPARATE_SPECULAR_COLOR = self then
        Result := 'SEPARATE_SPECULAR_COLOR' else
        Result := $'glLightModelColorControl[{self.val}]';
    end;
    
  end;
  
  glLightModelParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LIGHT_MODEL_LOCAL_VIEWER:  glLightModelParameter read new glLightModelParameter($0B51);
    public static property LIGHT_MODEL_TWO_SIDE:      glLightModelParameter read new glLightModelParameter($0B52);
    public static property LIGHT_MODEL_AMBIENT:       glLightModelParameter read new glLightModelParameter($0B53);
    public static property LIGHT_MODEL_COLOR_CONTROL: glLightModelParameter read new glLightModelParameter($81F8);
    
    public function ToString: string; override;
    begin
      if LIGHT_MODEL_LOCAL_VIEWER = self then
        Result := 'LIGHT_MODEL_LOCAL_VIEWER' else
      if LIGHT_MODEL_TWO_SIDE = self then
        Result := 'LIGHT_MODEL_TWO_SIDE' else
      if LIGHT_MODEL_AMBIENT = self then
        Result := 'LIGHT_MODEL_AMBIENT' else
      if LIGHT_MODEL_COLOR_CONTROL = self then
        Result := 'LIGHT_MODEL_COLOR_CONTROL' else
        Result := $'glLightModelParameter[{self.val}]';
    end;
    
  end;
  
  glLightName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LIGHT0:          glLightName read new glLightName($4000);
    public static property LIGHT1:          glLightName read new glLightName($4001);
    public static property LIGHT2:          glLightName read new glLightName($4002);
    public static property LIGHT3:          glLightName read new glLightName($4003);
    public static property LIGHT4:          glLightName read new glLightName($4004);
    public static property LIGHT5:          glLightName read new glLightName($4005);
    public static property LIGHT6:          glLightName read new glLightName($4006);
    public static property LIGHT7:          glLightName read new glLightName($4007);
    public static property FRAGMENT_LIGHT0: glLightName read new glLightName($840C);
    public static property FRAGMENT_LIGHT1: glLightName read new glLightName($840D);
    public static property FRAGMENT_LIGHT2: glLightName read new glLightName($840E);
    public static property FRAGMENT_LIGHT3: glLightName read new glLightName($840F);
    public static property FRAGMENT_LIGHT4: glLightName read new glLightName($8410);
    public static property FRAGMENT_LIGHT5: glLightName read new glLightName($8411);
    public static property FRAGMENT_LIGHT6: glLightName read new glLightName($8412);
    public static property FRAGMENT_LIGHT7: glLightName read new glLightName($8413);
    
    public function ToString: string; override;
    begin
      if LIGHT0 = self then
        Result := 'LIGHT0' else
      if LIGHT1 = self then
        Result := 'LIGHT1' else
      if LIGHT2 = self then
        Result := 'LIGHT2' else
      if LIGHT3 = self then
        Result := 'LIGHT3' else
      if LIGHT4 = self then
        Result := 'LIGHT4' else
      if LIGHT5 = self then
        Result := 'LIGHT5' else
      if LIGHT6 = self then
        Result := 'LIGHT6' else
      if LIGHT7 = self then
        Result := 'LIGHT7' else
      if FRAGMENT_LIGHT0 = self then
        Result := 'FRAGMENT_LIGHT0' else
      if FRAGMENT_LIGHT1 = self then
        Result := 'FRAGMENT_LIGHT1' else
      if FRAGMENT_LIGHT2 = self then
        Result := 'FRAGMENT_LIGHT2' else
      if FRAGMENT_LIGHT3 = self then
        Result := 'FRAGMENT_LIGHT3' else
      if FRAGMENT_LIGHT4 = self then
        Result := 'FRAGMENT_LIGHT4' else
      if FRAGMENT_LIGHT5 = self then
        Result := 'FRAGMENT_LIGHT5' else
      if FRAGMENT_LIGHT6 = self then
        Result := 'FRAGMENT_LIGHT6' else
      if FRAGMENT_LIGHT7 = self then
        Result := 'FRAGMENT_LIGHT7' else
        Result := $'glLightName[{self.val}]';
    end;
    
  end;
  
  glLightParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POSITION:              glLightParameter read new glLightParameter($1203);
    public static property SPOT_DIRECTION:        glLightParameter read new glLightParameter($1204);
    public static property SPOT_EXPONENT:         glLightParameter read new glLightParameter($1205);
    public static property SPOT_CUTOFF:           glLightParameter read new glLightParameter($1206);
    public static property CONSTANT_ATTENUATION:  glLightParameter read new glLightParameter($1207);
    public static property LINEAR_ATTENUATION:    glLightParameter read new glLightParameter($1208);
    public static property QUADRATIC_ATTENUATION: glLightParameter read new glLightParameter($1209);
    
    public function ToString: string; override;
    begin
      if POSITION = self then
        Result := 'POSITION' else
      if SPOT_DIRECTION = self then
        Result := 'SPOT_DIRECTION' else
      if SPOT_EXPONENT = self then
        Result := 'SPOT_EXPONENT' else
      if SPOT_CUTOFF = self then
        Result := 'SPOT_CUTOFF' else
      if CONSTANT_ATTENUATION = self then
        Result := 'CONSTANT_ATTENUATION' else
      if LINEAR_ATTENUATION = self then
        Result := 'LINEAR_ATTENUATION' else
      if QUADRATIC_ATTENUATION = self then
        Result := 'QUADRATIC_ATTENUATION' else
        Result := $'glLightParameter[{self.val}]';
    end;
    
  end;
  
  glLightTextureMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRAGMENT_MATERIAL: glLightTextureMode read new glLightTextureMode($8349);
    public static property FRAGMENT_NORMAL:   glLightTextureMode read new glLightTextureMode($834A);
    public static property FRAGMENT_COLOR:    glLightTextureMode read new glLightTextureMode($834C);
    public static property FRAGMENT_DEPTH:    glLightTextureMode read new glLightTextureMode($8452);
    
    public function ToString: string; override;
    begin
      if FRAGMENT_MATERIAL = self then
        Result := 'FRAGMENT_MATERIAL' else
      if FRAGMENT_NORMAL = self then
        Result := 'FRAGMENT_NORMAL' else
      if FRAGMENT_COLOR = self then
        Result := 'FRAGMENT_COLOR' else
      if FRAGMENT_DEPTH = self then
        Result := 'FRAGMENT_DEPTH' else
        Result := $'glLightTextureMode[{self.val}]';
    end;
    
  end;
  
  glLightTexturePName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ATTENUATION:        glLightTexturePName read new glLightTexturePName($834D);
    public static property SHADOW_ATTENUATION: glLightTexturePName read new glLightTexturePName($834E);
    
    public function ToString: string; override;
    begin
      if ATTENUATION = self then
        Result := 'ATTENUATION' else
      if SHADOW_ATTENUATION = self then
        Result := 'SHADOW_ATTENUATION' else
        Result := $'glLightTexturePName[{self.val}]';
    end;
    
  end;
  
  glListMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMPILE:             glListMode read new glListMode($1300);
    public static property COMPILE_AND_EXECUTE: glListMode read new glListMode($1301);
    
    public function ToString: string; override;
    begin
      if COMPILE = self then
        Result := 'COMPILE' else
      if COMPILE_AND_EXECUTE = self then
        Result := 'COMPILE_AND_EXECUTE' else
        Result := $'glListMode[{self.val}]';
    end;
    
  end;
  
  glListNameType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:           glListNameType read new glListNameType($1400);
    public static property UNSIGNED_BYTE:  glListNameType read new glListNameType($1401);
    public static property SHORT:          glListNameType read new glListNameType($1402);
    public static property UNSIGNED_SHORT: glListNameType read new glListNameType($1403);
    public static property INT:            glListNameType read new glListNameType($1404);
    public static property UNSIGNED_INT:   glListNameType read new glListNameType($1405);
    public static property FLOAT:          glListNameType read new glListNameType($1406);
    public static property _2_BYTES:       glListNameType read new glListNameType($1407);
    public static property _3_BYTES:       glListNameType read new glListNameType($1408);
    public static property _4_BYTES:       glListNameType read new glListNameType($1409);
    
    public function ToString: string; override;
    begin
      if BYTE = self then
        Result := 'BYTE' else
      if UNSIGNED_BYTE = self then
        Result := 'UNSIGNED_BYTE' else
      if SHORT = self then
        Result := 'SHORT' else
      if UNSIGNED_SHORT = self then
        Result := 'UNSIGNED_SHORT' else
      if INT = self then
        Result := 'INT' else
      if UNSIGNED_INT = self then
        Result := 'UNSIGNED_INT' else
      if FLOAT = self then
        Result := 'FLOAT' else
      if _2_BYTES = self then
        Result := '2_BYTES' else
      if _3_BYTES = self then
        Result := '3_BYTES' else
      if _4_BYTES = self then
        Result := '4_BYTES' else
        Result := $'glListNameType[{self.val}]';
    end;
    
  end;
  
  glListParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LIST_PRIORITY: glListParameterName read new glListParameterName($8182);
    
    public function ToString: string; override;
    begin
      if LIST_PRIORITY = self then
        Result := 'LIST_PRIORITY' else
        Result := $'glListParameterName[{self.val}]';
    end;
    
  end;
  
  glLogicOp = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CLEAR:         glLogicOp read new glLogicOp($1500);
    public static property &AND:          glLogicOp read new glLogicOp($1501);
    public static property AND_REVERSE:   glLogicOp read new glLogicOp($1502);
    public static property COPY:          glLogicOp read new glLogicOp($1503);
    public static property AND_INVERTED:  glLogicOp read new glLogicOp($1504);
    public static property NOOP:          glLogicOp read new glLogicOp($1505);
    public static property &XOR:          glLogicOp read new glLogicOp($1506);
    public static property &OR:           glLogicOp read new glLogicOp($1507);
    public static property NOR:           glLogicOp read new glLogicOp($1508);
    public static property EQUIV:         glLogicOp read new glLogicOp($1509);
    public static property INVERT:        glLogicOp read new glLogicOp($150A);
    public static property OR_REVERSE:    glLogicOp read new glLogicOp($150B);
    public static property COPY_INVERTED: glLogicOp read new glLogicOp($150C);
    public static property OR_INVERTED:   glLogicOp read new glLogicOp($150D);
    public static property NAND:          glLogicOp read new glLogicOp($150E);
    public static property &SET:          glLogicOp read new glLogicOp($150F);
    
    public function ToString: string; override;
    begin
      if CLEAR = self then
        Result := 'CLEAR' else
      if &AND = self then
        Result := 'AND' else
      if AND_REVERSE = self then
        Result := 'AND_REVERSE' else
      if COPY = self then
        Result := 'COPY' else
      if AND_INVERTED = self then
        Result := 'AND_INVERTED' else
      if NOOP = self then
        Result := 'NOOP' else
      if &XOR = self then
        Result := 'XOR' else
      if &OR = self then
        Result := 'OR' else
      if NOR = self then
        Result := 'NOR' else
      if EQUIV = self then
        Result := 'EQUIV' else
      if INVERT = self then
        Result := 'INVERT' else
      if OR_REVERSE = self then
        Result := 'OR_REVERSE' else
      if COPY_INVERTED = self then
        Result := 'COPY_INVERTED' else
      if OR_INVERTED = self then
        Result := 'OR_INVERTED' else
      if NAND = self then
        Result := 'NAND' else
      if &SET = self then
        Result := 'SET' else
        Result := $'glLogicOp[{self.val}]';
    end;
    
  end;
  
  glMapAttribParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MAP_ATTRIB_U_ORDER: glMapAttribParameter read new glMapAttribParameter($86C3);
    public static property MAP_ATTRIB_V_ORDER: glMapAttribParameter read new glMapAttribParameter($86C4);
    
    public function ToString: string; override;
    begin
      if MAP_ATTRIB_U_ORDER = self then
        Result := 'MAP_ATTRIB_U_ORDER' else
      if MAP_ATTRIB_V_ORDER = self then
        Result := 'MAP_ATTRIB_V_ORDER' else
        Result := $'glMapAttribParameter[{self.val}]';
    end;
    
  end;
  
  glMapBufferAccessMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MAP_READ_BIT:              glMapBufferAccessMask read new glMapBufferAccessMask(1 shl 0);
    public static property MAP_WRITE_BIT:             glMapBufferAccessMask read new glMapBufferAccessMask(1 shl 1);
    public static property MAP_INVALIDATE_RANGE_BIT:  glMapBufferAccessMask read new glMapBufferAccessMask(1 shl 2);
    public static property MAP_INVALIDATE_BUFFER_BIT: glMapBufferAccessMask read new glMapBufferAccessMask(1 shl 3);
    public static property MAP_FLUSH_EXPLICIT_BIT:    glMapBufferAccessMask read new glMapBufferAccessMask(1 shl 4);
    public static property MAP_UNSYNCHRONIZED_BIT:    glMapBufferAccessMask read new glMapBufferAccessMask(1 shl 5);
    public static property MAP_PERSISTENT_BIT:        glMapBufferAccessMask read new glMapBufferAccessMask(1 shl 6);
    public static property MAP_COHERENT_BIT:          glMapBufferAccessMask read new glMapBufferAccessMask(1 shl 7);
    
    public static function operator+(v1, v2: glMapBufferAccessMask) := new glMapBufferAccessMask(v1.val or v2.val);
    public static function operator or(v1, v2: glMapBufferAccessMask) := new glMapBufferAccessMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glMapBufferAccessMask; v2: glMapBufferAccessMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glMapBufferAccessMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glMapBufferAccessMask[0]';
        exit;
      end;
      if MAP_READ_BIT in self then
      begin
        res += 'MAP_READ_BIT+';
        left_val := left_val and not MAP_READ_BIT.val;
      end;
      if MAP_WRITE_BIT in self then
      begin
        res += 'MAP_WRITE_BIT+';
        left_val := left_val and not MAP_WRITE_BIT.val;
      end;
      if MAP_INVALIDATE_RANGE_BIT in self then
      begin
        res += 'MAP_INVALIDATE_RANGE_BIT+';
        left_val := left_val and not MAP_INVALIDATE_RANGE_BIT.val;
      end;
      if MAP_INVALIDATE_BUFFER_BIT in self then
      begin
        res += 'MAP_INVALIDATE_BUFFER_BIT+';
        left_val := left_val and not MAP_INVALIDATE_BUFFER_BIT.val;
      end;
      if MAP_FLUSH_EXPLICIT_BIT in self then
      begin
        res += 'MAP_FLUSH_EXPLICIT_BIT+';
        left_val := left_val and not MAP_FLUSH_EXPLICIT_BIT.val;
      end;
      if MAP_UNSYNCHRONIZED_BIT in self then
      begin
        res += 'MAP_UNSYNCHRONIZED_BIT+';
        left_val := left_val and not MAP_UNSYNCHRONIZED_BIT.val;
      end;
      if MAP_PERSISTENT_BIT in self then
      begin
        res += 'MAP_PERSISTENT_BIT+';
        left_val := left_val and not MAP_PERSISTENT_BIT.val;
      end;
      if MAP_COHERENT_BIT in self then
      begin
        res += 'MAP_COHERENT_BIT+';
        left_val := left_val and not MAP_COHERENT_BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'glMapBufferAccessMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glMapParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MAP_TESSELLATION: glMapParameter read new glMapParameter($86C2);
    
    public function ToString: string; override;
    begin
      if MAP_TESSELLATION = self then
        Result := 'MAP_TESSELLATION' else
        Result := $'glMapParameter[{self.val}]';
    end;
    
  end;
  
  glMapQuery = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COEFF:  glMapQuery read new glMapQuery($0A00);
    public static property ORDER:  glMapQuery read new glMapQuery($0A01);
    public static property DOMAIN: glMapQuery read new glMapQuery($0A02);
    
    public function ToString: string; override;
    begin
      if COEFF = self then
        Result := 'COEFF' else
      if ORDER = self then
        Result := 'ORDER' else
      if DOMAIN = self then
        Result := 'DOMAIN' else
        Result := $'glMapQuery[{self.val}]';
    end;
    
  end;
  
  glMapTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MAP1_COLOR_4:         glMapTarget read new glMapTarget($0D90);
    public static property MAP1_INDEX:           glMapTarget read new glMapTarget($0D91);
    public static property MAP1_NORMAL:          glMapTarget read new glMapTarget($0D92);
    public static property MAP1_TEXTURE_COORD_1: glMapTarget read new glMapTarget($0D93);
    public static property MAP1_TEXTURE_COORD_2: glMapTarget read new glMapTarget($0D94);
    public static property MAP1_TEXTURE_COORD_3: glMapTarget read new glMapTarget($0D95);
    public static property MAP1_TEXTURE_COORD_4: glMapTarget read new glMapTarget($0D96);
    public static property MAP1_VERTEX_3:        glMapTarget read new glMapTarget($0D97);
    public static property MAP1_VERTEX_4:        glMapTarget read new glMapTarget($0D98);
    public static property MAP2_COLOR_4:         glMapTarget read new glMapTarget($0DB0);
    public static property MAP2_INDEX:           glMapTarget read new glMapTarget($0DB1);
    public static property MAP2_NORMAL:          glMapTarget read new glMapTarget($0DB2);
    public static property MAP2_TEXTURE_COORD_1: glMapTarget read new glMapTarget($0DB3);
    public static property MAP2_TEXTURE_COORD_2: glMapTarget read new glMapTarget($0DB4);
    public static property MAP2_TEXTURE_COORD_3: glMapTarget read new glMapTarget($0DB5);
    public static property MAP2_TEXTURE_COORD_4: glMapTarget read new glMapTarget($0DB6);
    public static property MAP2_VERTEX_3:        glMapTarget read new glMapTarget($0DB7);
    public static property MAP2_VERTEX_4:        glMapTarget read new glMapTarget($0DB8);
    public static property GEOMETRY_DEFORMATION: glMapTarget read new glMapTarget($8194);
    public static property TEXTURE_DEFORMATION:  glMapTarget read new glMapTarget($8195);
    
    public function ToString: string; override;
    begin
      if MAP1_COLOR_4 = self then
        Result := 'MAP1_COLOR_4' else
      if MAP1_INDEX = self then
        Result := 'MAP1_INDEX' else
      if MAP1_NORMAL = self then
        Result := 'MAP1_NORMAL' else
      if MAP1_TEXTURE_COORD_1 = self then
        Result := 'MAP1_TEXTURE_COORD_1' else
      if MAP1_TEXTURE_COORD_2 = self then
        Result := 'MAP1_TEXTURE_COORD_2' else
      if MAP1_TEXTURE_COORD_3 = self then
        Result := 'MAP1_TEXTURE_COORD_3' else
      if MAP1_TEXTURE_COORD_4 = self then
        Result := 'MAP1_TEXTURE_COORD_4' else
      if MAP1_VERTEX_3 = self then
        Result := 'MAP1_VERTEX_3' else
      if MAP1_VERTEX_4 = self then
        Result := 'MAP1_VERTEX_4' else
      if MAP2_COLOR_4 = self then
        Result := 'MAP2_COLOR_4' else
      if MAP2_INDEX = self then
        Result := 'MAP2_INDEX' else
      if MAP2_NORMAL = self then
        Result := 'MAP2_NORMAL' else
      if MAP2_TEXTURE_COORD_1 = self then
        Result := 'MAP2_TEXTURE_COORD_1' else
      if MAP2_TEXTURE_COORD_2 = self then
        Result := 'MAP2_TEXTURE_COORD_2' else
      if MAP2_TEXTURE_COORD_3 = self then
        Result := 'MAP2_TEXTURE_COORD_3' else
      if MAP2_TEXTURE_COORD_4 = self then
        Result := 'MAP2_TEXTURE_COORD_4' else
      if MAP2_VERTEX_3 = self then
        Result := 'MAP2_VERTEX_3' else
      if MAP2_VERTEX_4 = self then
        Result := 'MAP2_VERTEX_4' else
      if GEOMETRY_DEFORMATION = self then
        Result := 'GEOMETRY_DEFORMATION' else
      if TEXTURE_DEFORMATION = self then
        Result := 'TEXTURE_DEFORMATION' else
        Result := $'glMapTarget[{self.val}]';
    end;
    
  end;
  
  glMapTextureFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LAYOUT_DEFAULT:           glMapTextureFormat read new glMapTextureFormat(0);
    public static property LAYOUT_LINEAR:            glMapTextureFormat read new glMapTextureFormat($0001);
    public static property LAYOUT_LINEAR_CPU_CACHED: glMapTextureFormat read new glMapTextureFormat($0002);
    
    public function ToString: string; override;
    begin
      if LAYOUT_DEFAULT = self then
        Result := 'LAYOUT_DEFAULT' else
      if LAYOUT_LINEAR = self then
        Result := 'LAYOUT_LINEAR' else
      if LAYOUT_LINEAR_CPU_CACHED = self then
        Result := 'LAYOUT_LINEAR_CPU_CACHED' else
        Result := $'glMapTextureFormat[{self.val}]';
    end;
    
  end;
  
  glMapType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FLOAT:  glMapType read new glMapType($1406);
    public static property DOUBLE: glMapType read new glMapType($140A);
    
    public function ToString: string; override;
    begin
      if FLOAT = self then
        Result := 'FLOAT' else
      if DOUBLE = self then
        Result := 'DOUBLE' else
        Result := $'glMapType[{self.val}]';
    end;
    
  end;
  
  glMaterialParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property AMBIENT:             glMaterialParameter read new glMaterialParameter($1200);
    public static property DIFFUSE:             glMaterialParameter read new glMaterialParameter($1201);
    public static property SPECULAR:            glMaterialParameter read new glMaterialParameter($1202);
    public static property EMISSION:            glMaterialParameter read new glMaterialParameter($1600);
    public static property SHININESS:           glMaterialParameter read new glMaterialParameter($1601);
    public static property AMBIENT_AND_DIFFUSE: glMaterialParameter read new glMaterialParameter($1602);
    public static property COLOR_INDEXES:       glMaterialParameter read new glMaterialParameter($1603);
    
    public function ToString: string; override;
    begin
      if AMBIENT = self then
        Result := 'AMBIENT' else
      if DIFFUSE = self then
        Result := 'DIFFUSE' else
      if SPECULAR = self then
        Result := 'SPECULAR' else
      if EMISSION = self then
        Result := 'EMISSION' else
      if SHININESS = self then
        Result := 'SHININESS' else
      if AMBIENT_AND_DIFFUSE = self then
        Result := 'AMBIENT_AND_DIFFUSE' else
      if COLOR_INDEXES = self then
        Result := 'COLOR_INDEXES' else
        Result := $'glMaterialParameter[{self.val}]';
    end;
    
  end;
  
  glMatrixIndexPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNSIGNED_BYTE:  glMatrixIndexPointerType read new glMatrixIndexPointerType($1401);
    public static property UNSIGNED_SHORT: glMatrixIndexPointerType read new glMatrixIndexPointerType($1403);
    public static property UNSIGNED_INT:   glMatrixIndexPointerType read new glMatrixIndexPointerType($1405);
    
    public function ToString: string; override;
    begin
      if UNSIGNED_BYTE = self then
        Result := 'UNSIGNED_BYTE' else
      if UNSIGNED_SHORT = self then
        Result := 'UNSIGNED_SHORT' else
      if UNSIGNED_INT = self then
        Result := 'UNSIGNED_INT' else
        Result := $'glMatrixIndexPointerType[{self.val}]';
    end;
    
  end;
  
  glMatrixMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MODELVIEW:  glMatrixMode read new glMatrixMode($1700);
    public static property MODELVIEW0: glMatrixMode read new glMatrixMode($1700);
    public static property PROJECTION: glMatrixMode read new glMatrixMode($1701);
    public static property TEXTURE:    glMatrixMode read new glMatrixMode($1702);
    
    public function ToString: string; override;
    begin
      if MODELVIEW = self then
        Result := 'MODELVIEW' else
      if MODELVIEW0 = self then
        Result := 'MODELVIEW0' else
      if PROJECTION = self then
        Result := 'PROJECTION' else
      if TEXTURE = self then
        Result := 'TEXTURE' else
        Result := $'glMatrixMode[{self.val}]';
    end;
    
  end;
  
  glMemoryBarrierMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_ATTRIB_ARRAY_BARRIER_BIT:  glMemoryBarrierMask read new glMemoryBarrierMask(1 shl 0);
    public static property ELEMENT_ARRAY_BARRIER_BIT:        glMemoryBarrierMask read new glMemoryBarrierMask(1 shl 1);
    public static property UNIFORM_BARRIER_BIT:              glMemoryBarrierMask read new glMemoryBarrierMask(1 shl 2);
    public static property TEXTURE_FETCH_BARRIER_BIT:        glMemoryBarrierMask read new glMemoryBarrierMask(1 shl 3);
    public static property SHADER_GLOBAL_ACCESS_BARRIER_BIT: glMemoryBarrierMask read new glMemoryBarrierMask(1 shl 4);
    public static property SHADER_IMAGE_ACCESS_BARRIER_BIT:  glMemoryBarrierMask read new glMemoryBarrierMask(1 shl 5);
    public static property COMMAND_BARRIER_BIT:              glMemoryBarrierMask read new glMemoryBarrierMask(1 shl 6);
    public static property PIXEL_BUFFER_BARRIER_BIT:         glMemoryBarrierMask read new glMemoryBarrierMask(1 shl 7);
    public static property TEXTURE_UPDATE_BARRIER_BIT:       glMemoryBarrierMask read new glMemoryBarrierMask(1 shl 8);
    public static property BUFFER_UPDATE_BARRIER_BIT:        glMemoryBarrierMask read new glMemoryBarrierMask(1 shl 9);
    public static property FRAMEBUFFER_BARRIER_BIT:          glMemoryBarrierMask read new glMemoryBarrierMask(1 shl 10);
    public static property TRANSFORM_FEEDBACK_BARRIER_BIT:   glMemoryBarrierMask read new glMemoryBarrierMask(1 shl 11);
    public static property ATOMIC_COUNTER_BARRIER_BIT:       glMemoryBarrierMask read new glMemoryBarrierMask(1 shl 12);
    public static property SHADER_STORAGE_BARRIER_BIT:       glMemoryBarrierMask read new glMemoryBarrierMask(1 shl 13);
    public static property CLIENT_MAPPED_BUFFER_BARRIER_BIT: glMemoryBarrierMask read new glMemoryBarrierMask(1 shl 14);
    public static property QUERY_BUFFER_BARRIER_BIT:         glMemoryBarrierMask read new glMemoryBarrierMask(1 shl 15);
    public static property ALL_BARRIER_BITS:                 glMemoryBarrierMask read new glMemoryBarrierMask($FFFFFFFF);
    
    public static function operator+(v1, v2: glMemoryBarrierMask) := new glMemoryBarrierMask(v1.val or v2.val);
    public static function operator or(v1, v2: glMemoryBarrierMask) := new glMemoryBarrierMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glMemoryBarrierMask; v2: glMemoryBarrierMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glMemoryBarrierMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glMemoryBarrierMask[0]';
        exit;
      end;
      if VERTEX_ATTRIB_ARRAY_BARRIER_BIT in self then
      begin
        res += 'VERTEX_ATTRIB_ARRAY_BARRIER_BIT+';
        left_val := left_val and not VERTEX_ATTRIB_ARRAY_BARRIER_BIT.val;
      end;
      if ELEMENT_ARRAY_BARRIER_BIT in self then
      begin
        res += 'ELEMENT_ARRAY_BARRIER_BIT+';
        left_val := left_val and not ELEMENT_ARRAY_BARRIER_BIT.val;
      end;
      if UNIFORM_BARRIER_BIT in self then
      begin
        res += 'UNIFORM_BARRIER_BIT+';
        left_val := left_val and not UNIFORM_BARRIER_BIT.val;
      end;
      if TEXTURE_FETCH_BARRIER_BIT in self then
      begin
        res += 'TEXTURE_FETCH_BARRIER_BIT+';
        left_val := left_val and not TEXTURE_FETCH_BARRIER_BIT.val;
      end;
      if SHADER_GLOBAL_ACCESS_BARRIER_BIT in self then
      begin
        res += 'SHADER_GLOBAL_ACCESS_BARRIER_BIT+';
        left_val := left_val and not SHADER_GLOBAL_ACCESS_BARRIER_BIT.val;
      end;
      if SHADER_IMAGE_ACCESS_BARRIER_BIT in self then
      begin
        res += 'SHADER_IMAGE_ACCESS_BARRIER_BIT+';
        left_val := left_val and not SHADER_IMAGE_ACCESS_BARRIER_BIT.val;
      end;
      if COMMAND_BARRIER_BIT in self then
      begin
        res += 'COMMAND_BARRIER_BIT+';
        left_val := left_val and not COMMAND_BARRIER_BIT.val;
      end;
      if PIXEL_BUFFER_BARRIER_BIT in self then
      begin
        res += 'PIXEL_BUFFER_BARRIER_BIT+';
        left_val := left_val and not PIXEL_BUFFER_BARRIER_BIT.val;
      end;
      if TEXTURE_UPDATE_BARRIER_BIT in self then
      begin
        res += 'TEXTURE_UPDATE_BARRIER_BIT+';
        left_val := left_val and not TEXTURE_UPDATE_BARRIER_BIT.val;
      end;
      if BUFFER_UPDATE_BARRIER_BIT in self then
      begin
        res += 'BUFFER_UPDATE_BARRIER_BIT+';
        left_val := left_val and not BUFFER_UPDATE_BARRIER_BIT.val;
      end;
      if FRAMEBUFFER_BARRIER_BIT in self then
      begin
        res += 'FRAMEBUFFER_BARRIER_BIT+';
        left_val := left_val and not FRAMEBUFFER_BARRIER_BIT.val;
      end;
      if TRANSFORM_FEEDBACK_BARRIER_BIT in self then
      begin
        res += 'TRANSFORM_FEEDBACK_BARRIER_BIT+';
        left_val := left_val and not TRANSFORM_FEEDBACK_BARRIER_BIT.val;
      end;
      if ATOMIC_COUNTER_BARRIER_BIT in self then
      begin
        res += 'ATOMIC_COUNTER_BARRIER_BIT+';
        left_val := left_val and not ATOMIC_COUNTER_BARRIER_BIT.val;
      end;
      if SHADER_STORAGE_BARRIER_BIT in self then
      begin
        res += 'SHADER_STORAGE_BARRIER_BIT+';
        left_val := left_val and not SHADER_STORAGE_BARRIER_BIT.val;
      end;
      if CLIENT_MAPPED_BUFFER_BARRIER_BIT in self then
      begin
        res += 'CLIENT_MAPPED_BUFFER_BARRIER_BIT+';
        left_val := left_val and not CLIENT_MAPPED_BUFFER_BARRIER_BIT.val;
      end;
      if QUERY_BUFFER_BARRIER_BIT in self then
      begin
        res += 'QUERY_BUFFER_BARRIER_BIT+';
        left_val := left_val and not QUERY_BUFFER_BARRIER_BIT.val;
      end;
      if ALL_BARRIER_BITS in self then
      begin
        res += 'ALL_BARRIER_BITS+';
        left_val := left_val and not ALL_BARRIER_BITS.val;
      end;
      if left_val<>0 then
      begin
        res += 'glMemoryBarrierMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glMemoryObjectParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DEDICATED_MEMORY_OBJECT: glMemoryObjectParameterName read new glMemoryObjectParameterName($9581);
    public static property PROTECTED_MEMORY_OBJECT: glMemoryObjectParameterName read new glMemoryObjectParameterName($959B);
    
    public function ToString: string; override;
    begin
      if DEDICATED_MEMORY_OBJECT = self then
        Result := 'DEDICATED_MEMORY_OBJECT' else
      if PROTECTED_MEMORY_OBJECT = self then
        Result := 'PROTECTED_MEMORY_OBJECT' else
        Result := $'glMemoryObjectParameterName[{self.val}]';
    end;
    
  end;
  
  glMeshMode1 = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINT: glMeshMode1 read new glMeshMode1($1B00);
    public static property LINE:  glMeshMode1 read new glMeshMode1($1B01);
    
    public function ToString: string; override;
    begin
      if POINT = self then
        Result := 'POINT' else
      if LINE = self then
        Result := 'LINE' else
        Result := $'glMeshMode1[{self.val}]';
    end;
    
  end;
  
  glMeshMode2 = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINT: glMeshMode2 read new glMeshMode2($1B00);
    public static property LINE:  glMeshMode2 read new glMeshMode2($1B01);
    public static property FILL:  glMeshMode2 read new glMeshMode2($1B02);
    
    public function ToString: string; override;
    begin
      if POINT = self then
        Result := 'POINT' else
      if LINE = self then
        Result := 'LINE' else
      if FILL = self then
        Result := 'FILL' else
        Result := $'glMeshMode2[{self.val}]';
    end;
    
  end;
  
  glMinmaxTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MINMAX: glMinmaxTarget read new glMinmaxTarget($802E);
    
    public function ToString: string; override;
    begin
      if MINMAX = self then
        Result := 'MINMAX' else
        Result := $'glMinmaxTarget[{self.val}]';
    end;
    
  end;
  
  glNormalPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:   glNormalPointerType read new glNormalPointerType($1400);
    public static property SHORT:  glNormalPointerType read new glNormalPointerType($1402);
    public static property INT:    glNormalPointerType read new glNormalPointerType($1404);
    public static property FLOAT:  glNormalPointerType read new glNormalPointerType($1406);
    public static property DOUBLE: glNormalPointerType read new glNormalPointerType($140A);
    
    public function ToString: string; override;
    begin
      if BYTE = self then
        Result := 'BYTE' else
      if SHORT = self then
        Result := 'SHORT' else
      if INT = self then
        Result := 'INT' else
      if FLOAT = self then
        Result := 'FLOAT' else
      if DOUBLE = self then
        Result := 'DOUBLE' else
        Result := $'glNormalPointerType[{self.val}]';
    end;
    
  end;
  
  glObjectIdentifier = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE:            glObjectIdentifier read new glObjectIdentifier($1702);
    public static property VERTEX_ARRAY:       glObjectIdentifier read new glObjectIdentifier($8074);
    public static property BUFFER:             glObjectIdentifier read new glObjectIdentifier($82E0);
    public static property SHADER:             glObjectIdentifier read new glObjectIdentifier($82E1);
    public static property &PROGRAM:           glObjectIdentifier read new glObjectIdentifier($82E2);
    public static property QUERY:              glObjectIdentifier read new glObjectIdentifier($82E3);
    public static property PROGRAM_PIPELINE:   glObjectIdentifier read new glObjectIdentifier($82E4);
    public static property SAMPLER:            glObjectIdentifier read new glObjectIdentifier($82E6);
    public static property FRAMEBUFFER:        glObjectIdentifier read new glObjectIdentifier($8D40);
    public static property RENDERBUFFER:       glObjectIdentifier read new glObjectIdentifier($8D41);
    public static property TRANSFORM_FEEDBACK: glObjectIdentifier read new glObjectIdentifier($8E22);
    
    public function ToString: string; override;
    begin
      if TEXTURE = self then
        Result := 'TEXTURE' else
      if VERTEX_ARRAY = self then
        Result := 'VERTEX_ARRAY' else
      if BUFFER = self then
        Result := 'BUFFER' else
      if SHADER = self then
        Result := 'SHADER' else
      if &PROGRAM = self then
        Result := 'PROGRAM' else
      if QUERY = self then
        Result := 'QUERY' else
      if PROGRAM_PIPELINE = self then
        Result := 'PROGRAM_PIPELINE' else
      if SAMPLER = self then
        Result := 'SAMPLER' else
      if FRAMEBUFFER = self then
        Result := 'FRAMEBUFFER' else
      if RENDERBUFFER = self then
        Result := 'RENDERBUFFER' else
      if TRANSFORM_FEEDBACK = self then
        Result := 'TRANSFORM_FEEDBACK' else
        Result := $'glObjectIdentifier[{self.val}]';
    end;
    
  end;
  
  glObjectType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DRAW_PIXELS: glObjectType read new glObjectType($8A0A);
    public static property FENCE:       glObjectType read new glObjectType($8A0B);
    
    public function ToString: string; override;
    begin
      if DRAW_PIXELS = self then
        Result := 'DRAW_PIXELS' else
      if FENCE = self then
        Result := 'FENCE' else
        Result := $'glObjectType[{self.val}]';
    end;
    
  end;
  
  glOcclusionQueryEventMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property QUERY_DEPTH_PASS_EVENT_BIT:        glOcclusionQueryEventMask read new glOcclusionQueryEventMask(1 shl 0);
    public static property QUERY_DEPTH_FAIL_EVENT_BIT:        glOcclusionQueryEventMask read new glOcclusionQueryEventMask(1 shl 1);
    public static property QUERY_STENCIL_FAIL_EVENT_BIT:      glOcclusionQueryEventMask read new glOcclusionQueryEventMask(1 shl 2);
    public static property QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT: glOcclusionQueryEventMask read new glOcclusionQueryEventMask(1 shl 3);
    public static property QUERY_ALL_EVENT_BITS:              glOcclusionQueryEventMask read new glOcclusionQueryEventMask($FFFFFFFF);
    
    public static function operator+(v1, v2: glOcclusionQueryEventMask) := new glOcclusionQueryEventMask(v1.val or v2.val);
    public static function operator or(v1, v2: glOcclusionQueryEventMask) := new glOcclusionQueryEventMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glOcclusionQueryEventMask; v2: glOcclusionQueryEventMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glOcclusionQueryEventMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glOcclusionQueryEventMask[0]';
        exit;
      end;
      if QUERY_DEPTH_PASS_EVENT_BIT in self then
      begin
        res += 'QUERY_DEPTH_PASS_EVENT_BIT+';
        left_val := left_val and not QUERY_DEPTH_PASS_EVENT_BIT.val;
      end;
      if QUERY_DEPTH_FAIL_EVENT_BIT in self then
      begin
        res += 'QUERY_DEPTH_FAIL_EVENT_BIT+';
        left_val := left_val and not QUERY_DEPTH_FAIL_EVENT_BIT.val;
      end;
      if QUERY_STENCIL_FAIL_EVENT_BIT in self then
      begin
        res += 'QUERY_STENCIL_FAIL_EVENT_BIT+';
        left_val := left_val and not QUERY_STENCIL_FAIL_EVENT_BIT.val;
      end;
      if QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT in self then
      begin
        res += 'QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT+';
        left_val := left_val and not QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT.val;
      end;
      if QUERY_ALL_EVENT_BITS in self then
      begin
        res += 'QUERY_ALL_EVENT_BITS+';
        left_val := left_val and not QUERY_ALL_EVENT_BITS.val;
      end;
      if left_val<>0 then
      begin
        res += 'glOcclusionQueryEventMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glOcclusionQueryParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PIXEL_COUNT:           glOcclusionQueryParameterName read new glOcclusionQueryParameterName($8866);
    public static property PIXEL_COUNT_AVAILABLE: glOcclusionQueryParameterName read new glOcclusionQueryParameterName($8867);
    
    public function ToString: string; override;
    begin
      if PIXEL_COUNT = self then
        Result := 'PIXEL_COUNT' else
      if PIXEL_COUNT_AVAILABLE = self then
        Result := 'PIXEL_COUNT_AVAILABLE' else
        Result := $'glOcclusionQueryParameterName[{self.val}]';
    end;
    
  end;
  
  glParameterRange = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NORMALIZED_RANGE: glParameterRange read new glParameterRange($87E0);
    public static property FULL_RANGE:       glParameterRange read new glParameterRange($87E1);
    
    public function ToString: string; override;
    begin
      if NORMALIZED_RANGE = self then
        Result := 'NORMALIZED_RANGE' else
      if FULL_RANGE = self then
        Result := 'FULL_RANGE' else
        Result := $'glParameterRange[{self.val}]';
    end;
    
  end;
  
  glPatchParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PATCH_VERTICES:            glPatchParameterName read new glPatchParameterName($8E72);
    public static property PATCH_DEFAULT_INNER_LEVEL: glPatchParameterName read new glPatchParameterName($8E73);
    public static property PATCH_DEFAULT_OUTER_LEVEL: glPatchParameterName read new glPatchParameterName($8E74);
    
    public function ToString: string; override;
    begin
      if PATCH_VERTICES = self then
        Result := 'PATCH_VERTICES' else
      if PATCH_DEFAULT_INNER_LEVEL = self then
        Result := 'PATCH_DEFAULT_INNER_LEVEL' else
      if PATCH_DEFAULT_OUTER_LEVEL = self then
        Result := 'PATCH_DEFAULT_OUTER_LEVEL' else
        Result := $'glPatchParameterName[{self.val}]';
    end;
    
  end;
  
  glPathColor = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PRIMARY_COLOR_NV: glPathColor read new glPathColor($852C);
    public static property SECONDARY_COLOR:  glPathColor read new glPathColor($852D);
    public static property PRIMARY_COLOR:    glPathColor read new glPathColor($8577);
    
    public function ToString: string; override;
    begin
      if PRIMARY_COLOR_NV = self then
        Result := 'PRIMARY_COLOR_NV' else
      if SECONDARY_COLOR = self then
        Result := 'SECONDARY_COLOR' else
      if PRIMARY_COLOR = self then
        Result := 'PRIMARY_COLOR' else
        Result := $'glPathColor[{self.val}]';
    end;
    
  end;
  
  glPathColorFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:            glPathColorFormat read new glPathColorFormat(0);
    public static property ALPHA:           glPathColorFormat read new glPathColorFormat($1906);
    public static property RGB:             glPathColorFormat read new glPathColorFormat($1907);
    public static property RGBA:            glPathColorFormat read new glPathColorFormat($1908);
    public static property LUMINANCE:       glPathColorFormat read new glPathColorFormat($1909);
    public static property LUMINANCE_ALPHA: glPathColorFormat read new glPathColorFormat($190A);
    public static property INTENSITY:       glPathColorFormat read new glPathColorFormat($8049);
    
    public function ToString: string; override;
    begin
      if NONE = self then
        Result := 'NONE' else
      if ALPHA = self then
        Result := 'ALPHA' else
      if RGB = self then
        Result := 'RGB' else
      if RGBA = self then
        Result := 'RGBA' else
      if LUMINANCE = self then
        Result := 'LUMINANCE' else
      if LUMINANCE_ALPHA = self then
        Result := 'LUMINANCE_ALPHA' else
      if INTENSITY = self then
        Result := 'INTENSITY' else
        Result := $'glPathColorFormat[{self.val}]';
    end;
    
  end;
  
  glPathCoordType = record
    public val: Byte;
    public constructor(val: Byte) := self.val := val;
    
    public static property CLOSE_PATH:                         glPathCoordType read new glPathCoordType(0);
    public static property MOVE_TO:                            glPathCoordType read new glPathCoordType($0002);
    public static property RELATIVE_MOVE_TO:                   glPathCoordType read new glPathCoordType($0003);
    public static property LINE_TO:                            glPathCoordType read new glPathCoordType($0004);
    public static property RELATIVE_LINE_TO:                   glPathCoordType read new glPathCoordType($0005);
    public static property HORIZONTAL_LINE_TO:                 glPathCoordType read new glPathCoordType($0006);
    public static property RELATIVE_HORIZONTAL_LINE_TO:        glPathCoordType read new glPathCoordType($0007);
    public static property VERTICAL_LINE_TO:                   glPathCoordType read new glPathCoordType($0008);
    public static property RELATIVE_VERTICAL_LINE_TO:          glPathCoordType read new glPathCoordType($0009);
    public static property QUADRATIC_CURVE_TO:                 glPathCoordType read new glPathCoordType($000A);
    public static property RELATIVE_QUADRATIC_CURVE_TO:        glPathCoordType read new glPathCoordType($000B);
    public static property CUBIC_CURVE_TO:                     glPathCoordType read new glPathCoordType($000C);
    public static property RELATIVE_CUBIC_CURVE_TO:            glPathCoordType read new glPathCoordType($000D);
    public static property SMOOTH_QUADRATIC_CURVE_TO:          glPathCoordType read new glPathCoordType($000E);
    public static property RELATIVE_SMOOTH_QUADRATIC_CURVE_TO: glPathCoordType read new glPathCoordType($000F);
    public static property SMOOTH_CUBIC_CURVE_TO:              glPathCoordType read new glPathCoordType($0010);
    public static property RELATIVE_SMOOTH_CUBIC_CURVE_TO:     glPathCoordType read new glPathCoordType($0011);
    public static property SMALL_CCW_ARC_TO:                   glPathCoordType read new glPathCoordType($0012);
    public static property RELATIVE_SMALL_CCW_ARC_TO:          glPathCoordType read new glPathCoordType($0013);
    public static property SMALL_CW_ARC_TO:                    glPathCoordType read new glPathCoordType($0014);
    public static property RELATIVE_SMALL_CW_ARC_TO:           glPathCoordType read new glPathCoordType($0015);
    public static property LARGE_CCW_ARC_TO:                   glPathCoordType read new glPathCoordType($0016);
    public static property RELATIVE_LARGE_CCW_ARC_TO:          glPathCoordType read new glPathCoordType($0017);
    public static property LARGE_CW_ARC_TO:                    glPathCoordType read new glPathCoordType($0018);
    public static property RELATIVE_LARGE_CW_ARC_TO:           glPathCoordType read new glPathCoordType($0019);
    public static property CONIC_CURVE_TO:                     glPathCoordType read new glPathCoordType($001A);
    public static property RELATIVE_CONIC_CURVE_TO:            glPathCoordType read new glPathCoordType($001B);
    public static property ROUNDED_RECT:                       glPathCoordType read new glPathCoordType($00E8);
    public static property RELATIVE_ROUNDED_RECT:              glPathCoordType read new glPathCoordType($00E9);
    public static property ROUNDED_RECT2:                      glPathCoordType read new glPathCoordType($00EA);
    public static property RELATIVE_ROUNDED_RECT2:             glPathCoordType read new glPathCoordType($00EB);
    public static property ROUNDED_RECT4:                      glPathCoordType read new glPathCoordType($00EC);
    public static property RELATIVE_ROUNDED_RECT4:             glPathCoordType read new glPathCoordType($00ED);
    public static property ROUNDED_RECT8:                      glPathCoordType read new glPathCoordType($00EE);
    public static property RELATIVE_ROUNDED_RECT8:             glPathCoordType read new glPathCoordType($00EF);
    public static property RESTART_PATH:                       glPathCoordType read new glPathCoordType($00F0);
    public static property DUP_FIRST_CUBIC_CURVE_TO:           glPathCoordType read new glPathCoordType($00F2);
    public static property DUP_LAST_CUBIC_CURVE_TO:            glPathCoordType read new glPathCoordType($00F4);
    public static property RECT:                               glPathCoordType read new glPathCoordType($00F6);
    public static property RELATIVE_RECT:                      glPathCoordType read new glPathCoordType($00F7);
    public static property CIRCULAR_CCW_ARC_TO:                glPathCoordType read new glPathCoordType($00F8);
    public static property CIRCULAR_CW_ARC_TO:                 glPathCoordType read new glPathCoordType($00FA);
    public static property CIRCULAR_TANGENT_ARC_TO:            glPathCoordType read new glPathCoordType($00FC);
    public static property ARC_TO:                             glPathCoordType read new glPathCoordType($00FE);
    public static property RELATIVE_ARC_TO:                    glPathCoordType read new glPathCoordType($00FF);
    
    public function ToString: string; override;
    begin
      if CLOSE_PATH = self then
        Result := 'CLOSE_PATH' else
      if MOVE_TO = self then
        Result := 'MOVE_TO' else
      if RELATIVE_MOVE_TO = self then
        Result := 'RELATIVE_MOVE_TO' else
      if LINE_TO = self then
        Result := 'LINE_TO' else
      if RELATIVE_LINE_TO = self then
        Result := 'RELATIVE_LINE_TO' else
      if HORIZONTAL_LINE_TO = self then
        Result := 'HORIZONTAL_LINE_TO' else
      if RELATIVE_HORIZONTAL_LINE_TO = self then
        Result := 'RELATIVE_HORIZONTAL_LINE_TO' else
      if VERTICAL_LINE_TO = self then
        Result := 'VERTICAL_LINE_TO' else
      if RELATIVE_VERTICAL_LINE_TO = self then
        Result := 'RELATIVE_VERTICAL_LINE_TO' else
      if QUADRATIC_CURVE_TO = self then
        Result := 'QUADRATIC_CURVE_TO' else
      if RELATIVE_QUADRATIC_CURVE_TO = self then
        Result := 'RELATIVE_QUADRATIC_CURVE_TO' else
      if CUBIC_CURVE_TO = self then
        Result := 'CUBIC_CURVE_TO' else
      if RELATIVE_CUBIC_CURVE_TO = self then
        Result := 'RELATIVE_CUBIC_CURVE_TO' else
      if SMOOTH_QUADRATIC_CURVE_TO = self then
        Result := 'SMOOTH_QUADRATIC_CURVE_TO' else
      if RELATIVE_SMOOTH_QUADRATIC_CURVE_TO = self then
        Result := 'RELATIVE_SMOOTH_QUADRATIC_CURVE_TO' else
      if SMOOTH_CUBIC_CURVE_TO = self then
        Result := 'SMOOTH_CUBIC_CURVE_TO' else
      if RELATIVE_SMOOTH_CUBIC_CURVE_TO = self then
        Result := 'RELATIVE_SMOOTH_CUBIC_CURVE_TO' else
      if SMALL_CCW_ARC_TO = self then
        Result := 'SMALL_CCW_ARC_TO' else
      if RELATIVE_SMALL_CCW_ARC_TO = self then
        Result := 'RELATIVE_SMALL_CCW_ARC_TO' else
      if SMALL_CW_ARC_TO = self then
        Result := 'SMALL_CW_ARC_TO' else
      if RELATIVE_SMALL_CW_ARC_TO = self then
        Result := 'RELATIVE_SMALL_CW_ARC_TO' else
      if LARGE_CCW_ARC_TO = self then
        Result := 'LARGE_CCW_ARC_TO' else
      if RELATIVE_LARGE_CCW_ARC_TO = self then
        Result := 'RELATIVE_LARGE_CCW_ARC_TO' else
      if LARGE_CW_ARC_TO = self then
        Result := 'LARGE_CW_ARC_TO' else
      if RELATIVE_LARGE_CW_ARC_TO = self then
        Result := 'RELATIVE_LARGE_CW_ARC_TO' else
      if CONIC_CURVE_TO = self then
        Result := 'CONIC_CURVE_TO' else
      if RELATIVE_CONIC_CURVE_TO = self then
        Result := 'RELATIVE_CONIC_CURVE_TO' else
      if ROUNDED_RECT = self then
        Result := 'ROUNDED_RECT' else
      if RELATIVE_ROUNDED_RECT = self then
        Result := 'RELATIVE_ROUNDED_RECT' else
      if ROUNDED_RECT2 = self then
        Result := 'ROUNDED_RECT2' else
      if RELATIVE_ROUNDED_RECT2 = self then
        Result := 'RELATIVE_ROUNDED_RECT2' else
      if ROUNDED_RECT4 = self then
        Result := 'ROUNDED_RECT4' else
      if RELATIVE_ROUNDED_RECT4 = self then
        Result := 'RELATIVE_ROUNDED_RECT4' else
      if ROUNDED_RECT8 = self then
        Result := 'ROUNDED_RECT8' else
      if RELATIVE_ROUNDED_RECT8 = self then
        Result := 'RELATIVE_ROUNDED_RECT8' else
      if RESTART_PATH = self then
        Result := 'RESTART_PATH' else
      if DUP_FIRST_CUBIC_CURVE_TO = self then
        Result := 'DUP_FIRST_CUBIC_CURVE_TO' else
      if DUP_LAST_CUBIC_CURVE_TO = self then
        Result := 'DUP_LAST_CUBIC_CURVE_TO' else
      if RECT = self then
        Result := 'RECT' else
      if RELATIVE_RECT = self then
        Result := 'RELATIVE_RECT' else
      if CIRCULAR_CCW_ARC_TO = self then
        Result := 'CIRCULAR_CCW_ARC_TO' else
      if CIRCULAR_CW_ARC_TO = self then
        Result := 'CIRCULAR_CW_ARC_TO' else
      if CIRCULAR_TANGENT_ARC_TO = self then
        Result := 'CIRCULAR_TANGENT_ARC_TO' else
      if ARC_TO = self then
        Result := 'ARC_TO' else
      if RELATIVE_ARC_TO = self then
        Result := 'RELATIVE_ARC_TO' else
        Result := $'glPathCoordType[{self.val}]';
    end;
    
  end;
  glPathCoordTypeUInt32 = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static function operator implicit(v: glPathCoordTypeUInt32): glPathCoordType :=
      new glPathCoordType(v.val);
    public static function operator implicit(v: glPathCoordType): glPathCoordTypeUInt32 :=
      new glPathCoordTypeUInt32(v.val);
    
    public static property CLOSE_PATH:                         glPathCoordTypeUInt32 read new glPathCoordTypeUInt32(0);
    public static property MOVE_TO:                            glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0002);
    public static property RELATIVE_MOVE_TO:                   glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0003);
    public static property LINE_TO:                            glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0004);
    public static property RELATIVE_LINE_TO:                   glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0005);
    public static property HORIZONTAL_LINE_TO:                 glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0006);
    public static property RELATIVE_HORIZONTAL_LINE_TO:        glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0007);
    public static property VERTICAL_LINE_TO:                   glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0008);
    public static property RELATIVE_VERTICAL_LINE_TO:          glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0009);
    public static property QUADRATIC_CURVE_TO:                 glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($000A);
    public static property RELATIVE_QUADRATIC_CURVE_TO:        glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($000B);
    public static property CUBIC_CURVE_TO:                     glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($000C);
    public static property RELATIVE_CUBIC_CURVE_TO:            glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($000D);
    public static property SMOOTH_QUADRATIC_CURVE_TO:          glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($000E);
    public static property RELATIVE_SMOOTH_QUADRATIC_CURVE_TO: glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($000F);
    public static property SMOOTH_CUBIC_CURVE_TO:              glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0010);
    public static property RELATIVE_SMOOTH_CUBIC_CURVE_TO:     glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0011);
    public static property SMALL_CCW_ARC_TO:                   glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0012);
    public static property RELATIVE_SMALL_CCW_ARC_TO:          glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0013);
    public static property SMALL_CW_ARC_TO:                    glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0014);
    public static property RELATIVE_SMALL_CW_ARC_TO:           glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0015);
    public static property LARGE_CCW_ARC_TO:                   glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0016);
    public static property RELATIVE_LARGE_CCW_ARC_TO:          glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0017);
    public static property LARGE_CW_ARC_TO:                    glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0018);
    public static property RELATIVE_LARGE_CW_ARC_TO:           glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($0019);
    public static property CONIC_CURVE_TO:                     glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($001A);
    public static property RELATIVE_CONIC_CURVE_TO:            glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($001B);
    public static property ROUNDED_RECT:                       glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00E8);
    public static property RELATIVE_ROUNDED_RECT:              glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00E9);
    public static property ROUNDED_RECT2:                      glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00EA);
    public static property RELATIVE_ROUNDED_RECT2:             glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00EB);
    public static property ROUNDED_RECT4:                      glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00EC);
    public static property RELATIVE_ROUNDED_RECT4:             glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00ED);
    public static property ROUNDED_RECT8:                      glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00EE);
    public static property RELATIVE_ROUNDED_RECT8:             glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00EF);
    public static property RESTART_PATH:                       glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00F0);
    public static property DUP_FIRST_CUBIC_CURVE_TO:           glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00F2);
    public static property DUP_LAST_CUBIC_CURVE_TO:            glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00F4);
    public static property RECT:                               glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00F6);
    public static property RELATIVE_RECT:                      glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00F7);
    public static property CIRCULAR_CCW_ARC_TO:                glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00F8);
    public static property CIRCULAR_CW_ARC_TO:                 glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00FA);
    public static property CIRCULAR_TANGENT_ARC_TO:            glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00FC);
    public static property ARC_TO:                             glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00FE);
    public static property RELATIVE_ARC_TO:                    glPathCoordTypeUInt32 read new glPathCoordTypeUInt32($00FF);
    
    public function ToString: string; override;
    begin
      if CLOSE_PATH = self then
        Result := 'CLOSE_PATH' else
      if MOVE_TO = self then
        Result := 'MOVE_TO' else
      if RELATIVE_MOVE_TO = self then
        Result := 'RELATIVE_MOVE_TO' else
      if LINE_TO = self then
        Result := 'LINE_TO' else
      if RELATIVE_LINE_TO = self then
        Result := 'RELATIVE_LINE_TO' else
      if HORIZONTAL_LINE_TO = self then
        Result := 'HORIZONTAL_LINE_TO' else
      if RELATIVE_HORIZONTAL_LINE_TO = self then
        Result := 'RELATIVE_HORIZONTAL_LINE_TO' else
      if VERTICAL_LINE_TO = self then
        Result := 'VERTICAL_LINE_TO' else
      if RELATIVE_VERTICAL_LINE_TO = self then
        Result := 'RELATIVE_VERTICAL_LINE_TO' else
      if QUADRATIC_CURVE_TO = self then
        Result := 'QUADRATIC_CURVE_TO' else
      if RELATIVE_QUADRATIC_CURVE_TO = self then
        Result := 'RELATIVE_QUADRATIC_CURVE_TO' else
      if CUBIC_CURVE_TO = self then
        Result := 'CUBIC_CURVE_TO' else
      if RELATIVE_CUBIC_CURVE_TO = self then
        Result := 'RELATIVE_CUBIC_CURVE_TO' else
      if SMOOTH_QUADRATIC_CURVE_TO = self then
        Result := 'SMOOTH_QUADRATIC_CURVE_TO' else
      if RELATIVE_SMOOTH_QUADRATIC_CURVE_TO = self then
        Result := 'RELATIVE_SMOOTH_QUADRATIC_CURVE_TO' else
      if SMOOTH_CUBIC_CURVE_TO = self then
        Result := 'SMOOTH_CUBIC_CURVE_TO' else
      if RELATIVE_SMOOTH_CUBIC_CURVE_TO = self then
        Result := 'RELATIVE_SMOOTH_CUBIC_CURVE_TO' else
      if SMALL_CCW_ARC_TO = self then
        Result := 'SMALL_CCW_ARC_TO' else
      if RELATIVE_SMALL_CCW_ARC_TO = self then
        Result := 'RELATIVE_SMALL_CCW_ARC_TO' else
      if SMALL_CW_ARC_TO = self then
        Result := 'SMALL_CW_ARC_TO' else
      if RELATIVE_SMALL_CW_ARC_TO = self then
        Result := 'RELATIVE_SMALL_CW_ARC_TO' else
      if LARGE_CCW_ARC_TO = self then
        Result := 'LARGE_CCW_ARC_TO' else
      if RELATIVE_LARGE_CCW_ARC_TO = self then
        Result := 'RELATIVE_LARGE_CCW_ARC_TO' else
      if LARGE_CW_ARC_TO = self then
        Result := 'LARGE_CW_ARC_TO' else
      if RELATIVE_LARGE_CW_ARC_TO = self then
        Result := 'RELATIVE_LARGE_CW_ARC_TO' else
      if CONIC_CURVE_TO = self then
        Result := 'CONIC_CURVE_TO' else
      if RELATIVE_CONIC_CURVE_TO = self then
        Result := 'RELATIVE_CONIC_CURVE_TO' else
      if ROUNDED_RECT = self then
        Result := 'ROUNDED_RECT' else
      if RELATIVE_ROUNDED_RECT = self then
        Result := 'RELATIVE_ROUNDED_RECT' else
      if ROUNDED_RECT2 = self then
        Result := 'ROUNDED_RECT2' else
      if RELATIVE_ROUNDED_RECT2 = self then
        Result := 'RELATIVE_ROUNDED_RECT2' else
      if ROUNDED_RECT4 = self then
        Result := 'ROUNDED_RECT4' else
      if RELATIVE_ROUNDED_RECT4 = self then
        Result := 'RELATIVE_ROUNDED_RECT4' else
      if ROUNDED_RECT8 = self then
        Result := 'ROUNDED_RECT8' else
      if RELATIVE_ROUNDED_RECT8 = self then
        Result := 'RELATIVE_ROUNDED_RECT8' else
      if RESTART_PATH = self then
        Result := 'RESTART_PATH' else
      if DUP_FIRST_CUBIC_CURVE_TO = self then
        Result := 'DUP_FIRST_CUBIC_CURVE_TO' else
      if DUP_LAST_CUBIC_CURVE_TO = self then
        Result := 'DUP_LAST_CUBIC_CURVE_TO' else
      if RECT = self then
        Result := 'RECT' else
      if RELATIVE_RECT = self then
        Result := 'RELATIVE_RECT' else
      if CIRCULAR_CCW_ARC_TO = self then
        Result := 'CIRCULAR_CCW_ARC_TO' else
      if CIRCULAR_CW_ARC_TO = self then
        Result := 'CIRCULAR_CW_ARC_TO' else
      if CIRCULAR_TANGENT_ARC_TO = self then
        Result := 'CIRCULAR_TANGENT_ARC_TO' else
      if ARC_TO = self then
        Result := 'ARC_TO' else
      if RELATIVE_ARC_TO = self then
        Result := 'RELATIVE_ARC_TO' else
        Result := $'glPathCoordTypeUInt32[{self.val}]';
    end;
    
  end;
  glPathCoordTypeByte = glPathCoordType;
  
  glPathCoverMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PATH_FILL_COVER_MODE: glPathCoverMode read new glPathCoverMode($9082);
    public static property CONVEX_HULL:          glPathCoverMode read new glPathCoverMode($908B);
    public static property BOUNDING_BOX:         glPathCoverMode read new glPathCoverMode($908D);
    
    public function ToString: string; override;
    begin
      if PATH_FILL_COVER_MODE = self then
        Result := 'PATH_FILL_COVER_MODE' else
      if CONVEX_HULL = self then
        Result := 'CONVEX_HULL' else
      if BOUNDING_BOX = self then
        Result := 'BOUNDING_BOX' else
        Result := $'glPathCoverMode[{self.val}]';
    end;
    
  end;
  
  glPathElementType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UTF8:  glPathElementType read new glPathElementType($909A);
    public static property UTF16: glPathElementType read new glPathElementType($909B);
    
    public function ToString: string; override;
    begin
      if UTF8 = self then
        Result := 'UTF8' else
      if UTF16 = self then
        Result := 'UTF16' else
        Result := $'glPathElementType[{self.val}]';
    end;
    
  end;
  
  glPathFillMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property INVERT:         glPathFillMode read new glPathFillMode($150A);
    public static property PATH_FILL_MODE: glPathFillMode read new glPathFillMode($9080);
    public static property COUNT_UP:       glPathFillMode read new glPathFillMode($9088);
    public static property COUNT_DOWN:     glPathFillMode read new glPathFillMode($9089);
    
    public function ToString: string; override;
    begin
      if INVERT = self then
        Result := 'INVERT' else
      if PATH_FILL_MODE = self then
        Result := 'PATH_FILL_MODE' else
      if COUNT_UP = self then
        Result := 'COUNT_UP' else
      if COUNT_DOWN = self then
        Result := 'COUNT_DOWN' else
        Result := $'glPathFillMode[{self.val}]';
    end;
    
  end;
  
  glPathFontStyle = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:       glPathFontStyle read new glPathFontStyle(0);
    public static property BOLD_BIT:   glPathFontStyle read new glPathFontStyle(1 shl 0);
    public static property ITALIC_BIT: glPathFontStyle read new glPathFontStyle(1 shl 1);
    
    public property ANY_FLAGS: boolean read self.val<>0;
    
    public static function operator+(v1, v2: glPathFontStyle) := new glPathFontStyle(v1.val or v2.val);
    public static function operator or(v1, v2: glPathFontStyle) := new glPathFontStyle(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glPathFontStyle; v2: glPathFontStyle) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glPathFontStyle) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'NONE';
        exit;
      end;
      if BOLD_BIT in self then
      begin
        res += 'BOLD_BIT+';
        left_val := left_val and not BOLD_BIT.val;
      end;
      if ITALIC_BIT in self then
      begin
        res += 'ITALIC_BIT+';
        left_val := left_val and not ITALIC_BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'glPathFontStyle[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glPathFontTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property STANDARD_FONT_NAME: glPathFontTarget read new glPathFontTarget($9072);
    public static property SYSTEM_FONT_NAME:   glPathFontTarget read new glPathFontTarget($9073);
    public static property FILE_NAME:          glPathFontTarget read new glPathFontTarget($9074);
    
    public function ToString: string; override;
    begin
      if STANDARD_FONT_NAME = self then
        Result := 'STANDARD_FONT_NAME' else
      if SYSTEM_FONT_NAME = self then
        Result := 'SYSTEM_FONT_NAME' else
      if FILE_NAME = self then
        Result := 'FILE_NAME' else
        Result := $'glPathFontTarget[{self.val}]';
    end;
    
  end;
  
  glPathGenMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:                     glPathGenMode read new glPathGenMode(0);
    public static property EYE_LINEAR:               glPathGenMode read new glPathGenMode($2400);
    public static property OBJECT_LINEAR:            glPathGenMode read new glPathGenMode($2401);
    public static property CONSTANT:                 glPathGenMode read new glPathGenMode($8576);
    public static property PATH_OBJECT_BOUNDING_BOX: glPathGenMode read new glPathGenMode($908A);
    
    public function ToString: string; override;
    begin
      if NONE = self then
        Result := 'NONE' else
      if EYE_LINEAR = self then
        Result := 'EYE_LINEAR' else
      if OBJECT_LINEAR = self then
        Result := 'OBJECT_LINEAR' else
      if CONSTANT = self then
        Result := 'CONSTANT' else
      if PATH_OBJECT_BOUNDING_BOX = self then
        Result := 'PATH_OBJECT_BOUNDING_BOX' else
        Result := $'glPathGenMode[{self.val}]';
    end;
    
  end;
  
  glPathHandleMissingGlyphs = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SKIP_MISSING_GLYPH: glPathHandleMissingGlyphs read new glPathHandleMissingGlyphs($90A9);
    public static property USE_MISSING_GLYPH:  glPathHandleMissingGlyphs read new glPathHandleMissingGlyphs($90AA);
    
    public function ToString: string; override;
    begin
      if SKIP_MISSING_GLYPH = self then
        Result := 'SKIP_MISSING_GLYPH' else
      if USE_MISSING_GLYPH = self then
        Result := 'USE_MISSING_GLYPH' else
        Result := $'glPathHandleMissingGlyphs[{self.val}]';
    end;
    
  end;
  
  glPathListMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACCUM_ADJACENT_PAIRS: glPathListMode read new glPathListMode($90AD);
    public static property ADJACENT_PAIRS:       glPathListMode read new glPathListMode($90AE);
    public static property FIRST_TO_REST:        glPathListMode read new glPathListMode($90AF);
    
    public function ToString: string; override;
    begin
      if ACCUM_ADJACENT_PAIRS = self then
        Result := 'ACCUM_ADJACENT_PAIRS' else
      if ADJACENT_PAIRS = self then
        Result := 'ADJACENT_PAIRS' else
      if FIRST_TO_REST = self then
        Result := 'FIRST_TO_REST' else
        Result := $'glPathListMode[{self.val}]';
    end;
    
  end;
  
  glPathMetricMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GLYPH_WIDTH_BIT:                      glPathMetricMask read new glPathMetricMask(1 shl 0);
    public static property GLYPH_HEIGHT_BIT:                     glPathMetricMask read new glPathMetricMask(1 shl 1);
    public static property GLYPH_HORIZONTAL_BEARING_X_BIT:       glPathMetricMask read new glPathMetricMask(1 shl 2);
    public static property GLYPH_HORIZONTAL_BEARING_Y_BIT:       glPathMetricMask read new glPathMetricMask(1 shl 3);
    public static property GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT: glPathMetricMask read new glPathMetricMask(1 shl 4);
    public static property GLYPH_VERTICAL_BEARING_X_BIT:         glPathMetricMask read new glPathMetricMask(1 shl 5);
    public static property GLYPH_VERTICAL_BEARING_Y_BIT:         glPathMetricMask read new glPathMetricMask(1 shl 6);
    public static property GLYPH_VERTICAL_BEARING_ADVANCE_BIT:   glPathMetricMask read new glPathMetricMask(1 shl 7);
    public static property GLYPH_HAS_KERNING_BIT:                glPathMetricMask read new glPathMetricMask(1 shl 8);
    public static property FONT_X_MIN_BOUNDS_BIT:                glPathMetricMask read new glPathMetricMask(1 shl 16);
    public static property FONT_Y_MIN_BOUNDS_BIT:                glPathMetricMask read new glPathMetricMask(1 shl 17);
    public static property FONT_X_MAX_BOUNDS_BIT:                glPathMetricMask read new glPathMetricMask(1 shl 18);
    public static property FONT_Y_MAX_BOUNDS_BIT:                glPathMetricMask read new glPathMetricMask(1 shl 19);
    public static property FONT_UNITS_PER_EM_BIT:                glPathMetricMask read new glPathMetricMask(1 shl 20);
    public static property FONT_ASCENDER_BIT:                    glPathMetricMask read new glPathMetricMask(1 shl 21);
    public static property FONT_DESCENDER_BIT:                   glPathMetricMask read new glPathMetricMask(1 shl 22);
    public static property FONT_HEIGHT_BIT:                      glPathMetricMask read new glPathMetricMask(1 shl 23);
    public static property FONT_MAX_ADVANCE_WIDTH_BIT:           glPathMetricMask read new glPathMetricMask(1 shl 24);
    public static property FONT_MAX_ADVANCE_HEIGHT_BIT:          glPathMetricMask read new glPathMetricMask(1 shl 25);
    public static property FONT_UNDERLINE_POSITION_BIT:          glPathMetricMask read new glPathMetricMask(1 shl 26);
    public static property FONT_UNDERLINE_THICKNESS_BIT:         glPathMetricMask read new glPathMetricMask(1 shl 27);
    public static property FONT_HAS_KERNING_BIT:                 glPathMetricMask read new glPathMetricMask(1 shl 28);
    public static property FONT_NUM_GLYPH_INDICES_BIT:           glPathMetricMask read new glPathMetricMask(1 shl 29);
    
    public static function operator+(v1, v2: glPathMetricMask) := new glPathMetricMask(v1.val or v2.val);
    public static function operator or(v1, v2: glPathMetricMask) := new glPathMetricMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glPathMetricMask; v2: glPathMetricMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glPathMetricMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glPathMetricMask[0]';
        exit;
      end;
      if GLYPH_WIDTH_BIT in self then
      begin
        res += 'GLYPH_WIDTH_BIT+';
        left_val := left_val and not GLYPH_WIDTH_BIT.val;
      end;
      if GLYPH_HEIGHT_BIT in self then
      begin
        res += 'GLYPH_HEIGHT_BIT+';
        left_val := left_val and not GLYPH_HEIGHT_BIT.val;
      end;
      if GLYPH_HORIZONTAL_BEARING_X_BIT in self then
      begin
        res += 'GLYPH_HORIZONTAL_BEARING_X_BIT+';
        left_val := left_val and not GLYPH_HORIZONTAL_BEARING_X_BIT.val;
      end;
      if GLYPH_HORIZONTAL_BEARING_Y_BIT in self then
      begin
        res += 'GLYPH_HORIZONTAL_BEARING_Y_BIT+';
        left_val := left_val and not GLYPH_HORIZONTAL_BEARING_Y_BIT.val;
      end;
      if GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT in self then
      begin
        res += 'GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT+';
        left_val := left_val and not GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT.val;
      end;
      if GLYPH_VERTICAL_BEARING_X_BIT in self then
      begin
        res += 'GLYPH_VERTICAL_BEARING_X_BIT+';
        left_val := left_val and not GLYPH_VERTICAL_BEARING_X_BIT.val;
      end;
      if GLYPH_VERTICAL_BEARING_Y_BIT in self then
      begin
        res += 'GLYPH_VERTICAL_BEARING_Y_BIT+';
        left_val := left_val and not GLYPH_VERTICAL_BEARING_Y_BIT.val;
      end;
      if GLYPH_VERTICAL_BEARING_ADVANCE_BIT in self then
      begin
        res += 'GLYPH_VERTICAL_BEARING_ADVANCE_BIT+';
        left_val := left_val and not GLYPH_VERTICAL_BEARING_ADVANCE_BIT.val;
      end;
      if GLYPH_HAS_KERNING_BIT in self then
      begin
        res += 'GLYPH_HAS_KERNING_BIT+';
        left_val := left_val and not GLYPH_HAS_KERNING_BIT.val;
      end;
      if FONT_X_MIN_BOUNDS_BIT in self then
      begin
        res += 'FONT_X_MIN_BOUNDS_BIT+';
        left_val := left_val and not FONT_X_MIN_BOUNDS_BIT.val;
      end;
      if FONT_Y_MIN_BOUNDS_BIT in self then
      begin
        res += 'FONT_Y_MIN_BOUNDS_BIT+';
        left_val := left_val and not FONT_Y_MIN_BOUNDS_BIT.val;
      end;
      if FONT_X_MAX_BOUNDS_BIT in self then
      begin
        res += 'FONT_X_MAX_BOUNDS_BIT+';
        left_val := left_val and not FONT_X_MAX_BOUNDS_BIT.val;
      end;
      if FONT_Y_MAX_BOUNDS_BIT in self then
      begin
        res += 'FONT_Y_MAX_BOUNDS_BIT+';
        left_val := left_val and not FONT_Y_MAX_BOUNDS_BIT.val;
      end;
      if FONT_UNITS_PER_EM_BIT in self then
      begin
        res += 'FONT_UNITS_PER_EM_BIT+';
        left_val := left_val and not FONT_UNITS_PER_EM_BIT.val;
      end;
      if FONT_ASCENDER_BIT in self then
      begin
        res += 'FONT_ASCENDER_BIT+';
        left_val := left_val and not FONT_ASCENDER_BIT.val;
      end;
      if FONT_DESCENDER_BIT in self then
      begin
        res += 'FONT_DESCENDER_BIT+';
        left_val := left_val and not FONT_DESCENDER_BIT.val;
      end;
      if FONT_HEIGHT_BIT in self then
      begin
        res += 'FONT_HEIGHT_BIT+';
        left_val := left_val and not FONT_HEIGHT_BIT.val;
      end;
      if FONT_MAX_ADVANCE_WIDTH_BIT in self then
      begin
        res += 'FONT_MAX_ADVANCE_WIDTH_BIT+';
        left_val := left_val and not FONT_MAX_ADVANCE_WIDTH_BIT.val;
      end;
      if FONT_MAX_ADVANCE_HEIGHT_BIT in self then
      begin
        res += 'FONT_MAX_ADVANCE_HEIGHT_BIT+';
        left_val := left_val and not FONT_MAX_ADVANCE_HEIGHT_BIT.val;
      end;
      if FONT_UNDERLINE_POSITION_BIT in self then
      begin
        res += 'FONT_UNDERLINE_POSITION_BIT+';
        left_val := left_val and not FONT_UNDERLINE_POSITION_BIT.val;
      end;
      if FONT_UNDERLINE_THICKNESS_BIT in self then
      begin
        res += 'FONT_UNDERLINE_THICKNESS_BIT+';
        left_val := left_val and not FONT_UNDERLINE_THICKNESS_BIT.val;
      end;
      if FONT_HAS_KERNING_BIT in self then
      begin
        res += 'FONT_HAS_KERNING_BIT+';
        left_val := left_val and not FONT_HAS_KERNING_BIT.val;
      end;
      if FONT_NUM_GLYPH_INDICES_BIT in self then
      begin
        res += 'FONT_NUM_GLYPH_INDICES_BIT+';
        left_val := left_val and not FONT_NUM_GLYPH_INDICES_BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'glPathMetricMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glPathParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PATH_STROKE_WIDTH:        glPathParameter read new glPathParameter($9075);
    public static property PATH_END_CAPS:            glPathParameter read new glPathParameter($9076);
    public static property PATH_INITIAL_END_CAP:     glPathParameter read new glPathParameter($9077);
    public static property PATH_TERMINAL_END_CAP:    glPathParameter read new glPathParameter($9078);
    public static property PATH_JOIN_STYLE:          glPathParameter read new glPathParameter($9079);
    public static property PATH_MITER_LIMIT:         glPathParameter read new glPathParameter($907A);
    public static property PATH_DASH_CAPS:           glPathParameter read new glPathParameter($907B);
    public static property PATH_INITIAL_DASH_CAP:    glPathParameter read new glPathParameter($907C);
    public static property PATH_TERMINAL_DASH_CAP:   glPathParameter read new glPathParameter($907D);
    public static property PATH_DASH_OFFSET:         glPathParameter read new glPathParameter($907E);
    public static property PATH_CLIENT_LENGTH:       glPathParameter read new glPathParameter($907F);
    public static property PATH_FILL_MODE:           glPathParameter read new glPathParameter($9080);
    public static property PATH_FILL_MASK:           glPathParameter read new glPathParameter($9081);
    public static property PATH_FILL_COVER_MODE:     glPathParameter read new glPathParameter($9082);
    public static property PATH_STROKE_COVER_MODE:   glPathParameter read new glPathParameter($9083);
    public static property PATH_STROKE_MASK:         glPathParameter read new glPathParameter($9084);
    public static property PATH_OBJECT_BOUNDING_BOX: glPathParameter read new glPathParameter($908A);
    public static property PATH_COMMAND_COUNT:       glPathParameter read new glPathParameter($909D);
    public static property PATH_COORD_COUNT:         glPathParameter read new glPathParameter($909E);
    public static property PATH_DASH_ARRAY_COUNT:    glPathParameter read new glPathParameter($909F);
    public static property PATH_COMPUTED_LENGTH:     glPathParameter read new glPathParameter($90A0);
    public static property PATH_FILL_BOUNDING_BOX:   glPathParameter read new glPathParameter($90A1);
    public static property PATH_STROKE_BOUNDING_BOX: glPathParameter read new glPathParameter($90A2);
    public static property PATH_DASH_OFFSET_RESET:   glPathParameter read new glPathParameter($90B4);
    
    public function ToString: string; override;
    begin
      if PATH_STROKE_WIDTH = self then
        Result := 'PATH_STROKE_WIDTH' else
      if PATH_END_CAPS = self then
        Result := 'PATH_END_CAPS' else
      if PATH_INITIAL_END_CAP = self then
        Result := 'PATH_INITIAL_END_CAP' else
      if PATH_TERMINAL_END_CAP = self then
        Result := 'PATH_TERMINAL_END_CAP' else
      if PATH_JOIN_STYLE = self then
        Result := 'PATH_JOIN_STYLE' else
      if PATH_MITER_LIMIT = self then
        Result := 'PATH_MITER_LIMIT' else
      if PATH_DASH_CAPS = self then
        Result := 'PATH_DASH_CAPS' else
      if PATH_INITIAL_DASH_CAP = self then
        Result := 'PATH_INITIAL_DASH_CAP' else
      if PATH_TERMINAL_DASH_CAP = self then
        Result := 'PATH_TERMINAL_DASH_CAP' else
      if PATH_DASH_OFFSET = self then
        Result := 'PATH_DASH_OFFSET' else
      if PATH_CLIENT_LENGTH = self then
        Result := 'PATH_CLIENT_LENGTH' else
      if PATH_FILL_MODE = self then
        Result := 'PATH_FILL_MODE' else
      if PATH_FILL_MASK = self then
        Result := 'PATH_FILL_MASK' else
      if PATH_FILL_COVER_MODE = self then
        Result := 'PATH_FILL_COVER_MODE' else
      if PATH_STROKE_COVER_MODE = self then
        Result := 'PATH_STROKE_COVER_MODE' else
      if PATH_STROKE_MASK = self then
        Result := 'PATH_STROKE_MASK' else
      if PATH_OBJECT_BOUNDING_BOX = self then
        Result := 'PATH_OBJECT_BOUNDING_BOX' else
      if PATH_COMMAND_COUNT = self then
        Result := 'PATH_COMMAND_COUNT' else
      if PATH_COORD_COUNT = self then
        Result := 'PATH_COORD_COUNT' else
      if PATH_DASH_ARRAY_COUNT = self then
        Result := 'PATH_DASH_ARRAY_COUNT' else
      if PATH_COMPUTED_LENGTH = self then
        Result := 'PATH_COMPUTED_LENGTH' else
      if PATH_FILL_BOUNDING_BOX = self then
        Result := 'PATH_FILL_BOUNDING_BOX' else
      if PATH_STROKE_BOUNDING_BOX = self then
        Result := 'PATH_STROKE_BOUNDING_BOX' else
      if PATH_DASH_OFFSET_RESET = self then
        Result := 'PATH_DASH_OFFSET_RESET' else
        Result := $'glPathParameter[{self.val}]';
    end;
    
  end;
  
  glPathStringFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PATH_FORMAT_SVG: glPathStringFormat read new glPathStringFormat($9070);
    public static property PATH_FORMAT_PS:  glPathStringFormat read new glPathStringFormat($9071);
    
    public function ToString: string; override;
    begin
      if PATH_FORMAT_SVG = self then
        Result := 'PATH_FORMAT_SVG' else
      if PATH_FORMAT_PS = self then
        Result := 'PATH_FORMAT_PS' else
        Result := $'glPathStringFormat[{self.val}]';
    end;
    
  end;
  
  glPathTransformType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:                glPathTransformType read new glPathTransformType(0);
    public static property TRANSLATE_X:         glPathTransformType read new glPathTransformType($908E);
    public static property TRANSLATE_Y:         glPathTransformType read new glPathTransformType($908F);
    public static property TRANSLATE_2D:        glPathTransformType read new glPathTransformType($9090);
    public static property TRANSLATE_3D:        glPathTransformType read new glPathTransformType($9091);
    public static property AFFINE_2D:           glPathTransformType read new glPathTransformType($9092);
    public static property AFFINE_3D:           glPathTransformType read new glPathTransformType($9094);
    public static property TRANSPOSE_AFFINE_2D: glPathTransformType read new glPathTransformType($9096);
    public static property TRANSPOSE_AFFINE_3D: glPathTransformType read new glPathTransformType($9098);
    
    public function ToString: string; override;
    begin
      if NONE = self then
        Result := 'NONE' else
      if TRANSLATE_X = self then
        Result := 'TRANSLATE_X' else
      if TRANSLATE_Y = self then
        Result := 'TRANSLATE_Y' else
      if TRANSLATE_2D = self then
        Result := 'TRANSLATE_2D' else
      if TRANSLATE_3D = self then
        Result := 'TRANSLATE_3D' else
      if AFFINE_2D = self then
        Result := 'AFFINE_2D' else
      if AFFINE_3D = self then
        Result := 'AFFINE_3D' else
      if TRANSPOSE_AFFINE_2D = self then
        Result := 'TRANSPOSE_AFFINE_2D' else
      if TRANSPOSE_AFFINE_3D = self then
        Result := 'TRANSPOSE_AFFINE_3D' else
        Result := $'glPathTransformType[{self.val}]';
    end;
    
  end;
  
  glPerformanceQueryCapsMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PERFQUERY_SINGLE_CONTEXT: glPerformanceQueryCapsMask read new glPerformanceQueryCapsMask(0);
    public static property PERFQUERY_GLOBAL_CONTEXT: glPerformanceQueryCapsMask read new glPerformanceQueryCapsMask(1 shl 0);
    
    public property ANY_FLAGS: boolean read self.val<>0;
    
    public static function operator+(v1, v2: glPerformanceQueryCapsMask) := new glPerformanceQueryCapsMask(v1.val or v2.val);
    public static function operator or(v1, v2: glPerformanceQueryCapsMask) := new glPerformanceQueryCapsMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glPerformanceQueryCapsMask; v2: glPerformanceQueryCapsMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glPerformanceQueryCapsMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'PERFQUERY_SINGLE_CONTEXT';
        exit;
      end;
      if PERFQUERY_GLOBAL_CONTEXT in self then
      begin
        res += 'PERFQUERY_GLOBAL_CONTEXT+';
        left_val := left_val and not PERFQUERY_GLOBAL_CONTEXT.val;
      end;
      if left_val<>0 then
      begin
        res += 'glPerformanceQueryCapsMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glPerfQueryDataFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PERFQUERY_DONOT_FLUSH: glPerfQueryDataFlags read new glPerfQueryDataFlags($83F9);
    public static property PERFQUERY_FLUSH:       glPerfQueryDataFlags read new glPerfQueryDataFlags($83FA);
    public static property PERFQUERY_WAIT:        glPerfQueryDataFlags read new glPerfQueryDataFlags($83FB);
    
    public function ToString: string; override;
    begin
      if PERFQUERY_DONOT_FLUSH = self then
        Result := 'PERFQUERY_DONOT_FLUSH' else
      if PERFQUERY_FLUSH = self then
        Result := 'PERFQUERY_FLUSH' else
      if PERFQUERY_WAIT = self then
        Result := 'PERFQUERY_WAIT' else
        Result := $'glPerfQueryDataFlags[{self.val}]';
    end;
    
  end;
  
  glPipelineParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_PROGRAM:         glPipelineParameterName read new glPipelineParameterName($8259);
    public static property FRAGMENT_SHADER:        glPipelineParameterName read new glPipelineParameterName($8B30);
    public static property VERTEX_SHADER:          glPipelineParameterName read new glPipelineParameterName($8B31);
    public static property INFO_LOG_LENGTH:        glPipelineParameterName read new glPipelineParameterName($8B84);
    public static property GEOMETRY_SHADER:        glPipelineParameterName read new glPipelineParameterName($8DD9);
    public static property TESS_EVALUATION_SHADER: glPipelineParameterName read new glPipelineParameterName($8E87);
    public static property TESS_CONTROL_SHADER:    glPipelineParameterName read new glPipelineParameterName($8E88);
    
    public function ToString: string; override;
    begin
      if ACTIVE_PROGRAM = self then
        Result := 'ACTIVE_PROGRAM' else
      if FRAGMENT_SHADER = self then
        Result := 'FRAGMENT_SHADER' else
      if VERTEX_SHADER = self then
        Result := 'VERTEX_SHADER' else
      if INFO_LOG_LENGTH = self then
        Result := 'INFO_LOG_LENGTH' else
      if GEOMETRY_SHADER = self then
        Result := 'GEOMETRY_SHADER' else
      if TESS_EVALUATION_SHADER = self then
        Result := 'TESS_EVALUATION_SHADER' else
      if TESS_CONTROL_SHADER = self then
        Result := 'TESS_CONTROL_SHADER' else
        Result := $'glPipelineParameterName[{self.val}]';
    end;
    
  end;
  
  glPixelCopyType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COLOR:   glPixelCopyType read new glPixelCopyType($1800);
    public static property DEPTH:   glPixelCopyType read new glPixelCopyType($1801);
    public static property STENCIL: glPixelCopyType read new glPixelCopyType($1802);
    
    public function ToString: string; override;
    begin
      if COLOR = self then
        Result := 'COLOR' else
      if DEPTH = self then
        Result := 'DEPTH' else
      if STENCIL = self then
        Result := 'STENCIL' else
        Result := $'glPixelCopyType[{self.val}]';
    end;
    
  end;
  
  glPixelDataRangeTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property WRITE_PIXEL_DATA_RANGE: glPixelDataRangeTarget read new glPixelDataRangeTarget($8878);
    public static property READ_PIXEL_DATA_RANGE:  glPixelDataRangeTarget read new glPixelDataRangeTarget($8879);
    
    public function ToString: string; override;
    begin
      if WRITE_PIXEL_DATA_RANGE = self then
        Result := 'WRITE_PIXEL_DATA_RANGE' else
      if READ_PIXEL_DATA_RANGE = self then
        Result := 'READ_PIXEL_DATA_RANGE' else
        Result := $'glPixelDataRangeTarget[{self.val}]';
    end;
    
  end;
  
  glPixelFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNSIGNED_SHORT:  glPixelFormat read new glPixelFormat($1403);
    public static property UNSIGNED_INT:    glPixelFormat read new glPixelFormat($1405);
    public static property COLOR_INDEX:     glPixelFormat read new glPixelFormat($1900);
    public static property STENCIL_INDEX:   glPixelFormat read new glPixelFormat($1901);
    public static property DEPTH_COMPONENT: glPixelFormat read new glPixelFormat($1902);
    public static property RED:             glPixelFormat read new glPixelFormat($1903);
    public static property GREEN:           glPixelFormat read new glPixelFormat($1904);
    public static property BLUE:            glPixelFormat read new glPixelFormat($1905);
    public static property ALPHA:           glPixelFormat read new glPixelFormat($1906);
    public static property RGB:             glPixelFormat read new glPixelFormat($1907);
    public static property RGBA:            glPixelFormat read new glPixelFormat($1908);
    public static property LUMINANCE:       glPixelFormat read new glPixelFormat($1909);
    public static property LUMINANCE_ALPHA: glPixelFormat read new glPixelFormat($190A);
    public static property ABGR:            glPixelFormat read new glPixelFormat($8000);
    public static property CMYK:            glPixelFormat read new glPixelFormat($800C);
    public static property CMYKA:           glPixelFormat read new glPixelFormat($800D);
    public static property BGR:             glPixelFormat read new glPixelFormat($80E0);
    public static property BGRA:            glPixelFormat read new glPixelFormat($80E1);
    public static property YCRCB_422:       glPixelFormat read new glPixelFormat($81BB);
    public static property YCRCB_444:       glPixelFormat read new glPixelFormat($81BC);
    public static property RG:              glPixelFormat read new glPixelFormat($8227);
    public static property RG_INTEGER:      glPixelFormat read new glPixelFormat($8228);
    public static property DEPTH_STENCIL:   glPixelFormat read new glPixelFormat($84F9);
    public static property RED_INTEGER:     glPixelFormat read new glPixelFormat($8D94);
    public static property GREEN_INTEGER:   glPixelFormat read new glPixelFormat($8D95);
    public static property BLUE_INTEGER:    glPixelFormat read new glPixelFormat($8D96);
    public static property RGB_INTEGER:     glPixelFormat read new glPixelFormat($8D98);
    public static property RGBA_INTEGER:    glPixelFormat read new glPixelFormat($8D99);
    public static property BGR_INTEGER:     glPixelFormat read new glPixelFormat($8D9A);
    public static property BGRA_INTEGER:    glPixelFormat read new glPixelFormat($8D9B);
    
    public function ToString: string; override;
    begin
      if UNSIGNED_SHORT = self then
        Result := 'UNSIGNED_SHORT' else
      if UNSIGNED_INT = self then
        Result := 'UNSIGNED_INT' else
      if COLOR_INDEX = self then
        Result := 'COLOR_INDEX' else
      if STENCIL_INDEX = self then
        Result := 'STENCIL_INDEX' else
      if DEPTH_COMPONENT = self then
        Result := 'DEPTH_COMPONENT' else
      if RED = self then
        Result := 'RED' else
      if GREEN = self then
        Result := 'GREEN' else
      if BLUE = self then
        Result := 'BLUE' else
      if ALPHA = self then
        Result := 'ALPHA' else
      if RGB = self then
        Result := 'RGB' else
      if RGBA = self then
        Result := 'RGBA' else
      if LUMINANCE = self then
        Result := 'LUMINANCE' else
      if LUMINANCE_ALPHA = self then
        Result := 'LUMINANCE_ALPHA' else
      if ABGR = self then
        Result := 'ABGR' else
      if CMYK = self then
        Result := 'CMYK' else
      if CMYKA = self then
        Result := 'CMYKA' else
      if BGR = self then
        Result := 'BGR' else
      if BGRA = self then
        Result := 'BGRA' else
      if YCRCB_422 = self then
        Result := 'YCRCB_422' else
      if YCRCB_444 = self then
        Result := 'YCRCB_444' else
      if RG = self then
        Result := 'RG' else
      if RG_INTEGER = self then
        Result := 'RG_INTEGER' else
      if DEPTH_STENCIL = self then
        Result := 'DEPTH_STENCIL' else
      if RED_INTEGER = self then
        Result := 'RED_INTEGER' else
      if GREEN_INTEGER = self then
        Result := 'GREEN_INTEGER' else
      if BLUE_INTEGER = self then
        Result := 'BLUE_INTEGER' else
      if RGB_INTEGER = self then
        Result := 'RGB_INTEGER' else
      if RGBA_INTEGER = self then
        Result := 'RGBA_INTEGER' else
      if BGR_INTEGER = self then
        Result := 'BGR_INTEGER' else
      if BGRA_INTEGER = self then
        Result := 'BGRA_INTEGER' else
        Result := $'glPixelFormat[{self.val}]';
    end;
    
  end;
  
  glPixelMap = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PIXEL_MAP_I_TO_I: glPixelMap read new glPixelMap($0C70);
    public static property PIXEL_MAP_S_TO_S: glPixelMap read new glPixelMap($0C71);
    public static property PIXEL_MAP_I_TO_R: glPixelMap read new glPixelMap($0C72);
    public static property PIXEL_MAP_I_TO_G: glPixelMap read new glPixelMap($0C73);
    public static property PIXEL_MAP_I_TO_B: glPixelMap read new glPixelMap($0C74);
    public static property PIXEL_MAP_I_TO_A: glPixelMap read new glPixelMap($0C75);
    public static property PIXEL_MAP_R_TO_R: glPixelMap read new glPixelMap($0C76);
    public static property PIXEL_MAP_G_TO_G: glPixelMap read new glPixelMap($0C77);
    public static property PIXEL_MAP_B_TO_B: glPixelMap read new glPixelMap($0C78);
    public static property PIXEL_MAP_A_TO_A: glPixelMap read new glPixelMap($0C79);
    
    public function ToString: string; override;
    begin
      if PIXEL_MAP_I_TO_I = self then
        Result := 'PIXEL_MAP_I_TO_I' else
      if PIXEL_MAP_S_TO_S = self then
        Result := 'PIXEL_MAP_S_TO_S' else
      if PIXEL_MAP_I_TO_R = self then
        Result := 'PIXEL_MAP_I_TO_R' else
      if PIXEL_MAP_I_TO_G = self then
        Result := 'PIXEL_MAP_I_TO_G' else
      if PIXEL_MAP_I_TO_B = self then
        Result := 'PIXEL_MAP_I_TO_B' else
      if PIXEL_MAP_I_TO_A = self then
        Result := 'PIXEL_MAP_I_TO_A' else
      if PIXEL_MAP_R_TO_R = self then
        Result := 'PIXEL_MAP_R_TO_R' else
      if PIXEL_MAP_G_TO_G = self then
        Result := 'PIXEL_MAP_G_TO_G' else
      if PIXEL_MAP_B_TO_B = self then
        Result := 'PIXEL_MAP_B_TO_B' else
      if PIXEL_MAP_A_TO_A = self then
        Result := 'PIXEL_MAP_A_TO_A' else
        Result := $'glPixelMap[{self.val}]';
    end;
    
  end;
  
  glPixelStoreParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNPACK_SWAP_BYTES:      glPixelStoreParameter read new glPixelStoreParameter($0CF0);
    public static property UNPACK_LSB_FIRST:       glPixelStoreParameter read new glPixelStoreParameter($0CF1);
    public static property UNPACK_ROW_LENGTH:      glPixelStoreParameter read new glPixelStoreParameter($0CF2);
    public static property UNPACK_SKIP_ROWS:       glPixelStoreParameter read new glPixelStoreParameter($0CF3);
    public static property UNPACK_SKIP_PIXELS:     glPixelStoreParameter read new glPixelStoreParameter($0CF4);
    public static property UNPACK_ALIGNMENT:       glPixelStoreParameter read new glPixelStoreParameter($0CF5);
    public static property PACK_SWAP_BYTES:        glPixelStoreParameter read new glPixelStoreParameter($0D00);
    public static property PACK_LSB_FIRST:         glPixelStoreParameter read new glPixelStoreParameter($0D01);
    public static property PACK_ROW_LENGTH:        glPixelStoreParameter read new glPixelStoreParameter($0D02);
    public static property PACK_SKIP_ROWS:         glPixelStoreParameter read new glPixelStoreParameter($0D03);
    public static property PACK_SKIP_PIXELS:       glPixelStoreParameter read new glPixelStoreParameter($0D04);
    public static property PACK_ALIGNMENT:         glPixelStoreParameter read new glPixelStoreParameter($0D05);
    public static property PACK_SKIP_IMAGES:       glPixelStoreParameter read new glPixelStoreParameter($806B);
    public static property PACK_IMAGE_HEIGHT:      glPixelStoreParameter read new glPixelStoreParameter($806C);
    public static property UNPACK_SKIP_IMAGES:     glPixelStoreParameter read new glPixelStoreParameter($806D);
    public static property UNPACK_IMAGE_HEIGHT:    glPixelStoreParameter read new glPixelStoreParameter($806E);
    public static property PACK_SKIP_VOLUMES:      glPixelStoreParameter read new glPixelStoreParameter($8130);
    public static property PACK_IMAGE_DEPTH:       glPixelStoreParameter read new glPixelStoreParameter($8131);
    public static property UNPACK_SKIP_VOLUMES:    glPixelStoreParameter read new glPixelStoreParameter($8132);
    public static property UNPACK_IMAGE_DEPTH:     glPixelStoreParameter read new glPixelStoreParameter($8133);
    public static property PIXEL_TILE_WIDTH:       glPixelStoreParameter read new glPixelStoreParameter($8140);
    public static property PIXEL_TILE_HEIGHT:      glPixelStoreParameter read new glPixelStoreParameter($8141);
    public static property PIXEL_TILE_GRID_WIDTH:  glPixelStoreParameter read new glPixelStoreParameter($8142);
    public static property PIXEL_TILE_GRID_HEIGHT: glPixelStoreParameter read new glPixelStoreParameter($8143);
    public static property PIXEL_TILE_GRID_DEPTH:  glPixelStoreParameter read new glPixelStoreParameter($8144);
    public static property PIXEL_TILE_CACHE_SIZE:  glPixelStoreParameter read new glPixelStoreParameter($8145);
    public static property PACK_RESAMPLE_SGIX:     glPixelStoreParameter read new glPixelStoreParameter($842E);
    public static property UNPACK_RESAMPLE_SGIX:   glPixelStoreParameter read new glPixelStoreParameter($842F);
    public static property PACK_SUBSAMPLE_RATE:    glPixelStoreParameter read new glPixelStoreParameter($85A0);
    public static property UNPACK_SUBSAMPLE_RATE:  glPixelStoreParameter read new glPixelStoreParameter($85A1);
    public static property PACK_RESAMPLE_OML:      glPixelStoreParameter read new glPixelStoreParameter($8984);
    public static property UNPACK_RESAMPLE_OML:    glPixelStoreParameter read new glPixelStoreParameter($8985);
    
    public function ToString: string; override;
    begin
      if UNPACK_SWAP_BYTES = self then
        Result := 'UNPACK_SWAP_BYTES' else
      if UNPACK_LSB_FIRST = self then
        Result := 'UNPACK_LSB_FIRST' else
      if UNPACK_ROW_LENGTH = self then
        Result := 'UNPACK_ROW_LENGTH' else
      if UNPACK_SKIP_ROWS = self then
        Result := 'UNPACK_SKIP_ROWS' else
      if UNPACK_SKIP_PIXELS = self then
        Result := 'UNPACK_SKIP_PIXELS' else
      if UNPACK_ALIGNMENT = self then
        Result := 'UNPACK_ALIGNMENT' else
      if PACK_SWAP_BYTES = self then
        Result := 'PACK_SWAP_BYTES' else
      if PACK_LSB_FIRST = self then
        Result := 'PACK_LSB_FIRST' else
      if PACK_ROW_LENGTH = self then
        Result := 'PACK_ROW_LENGTH' else
      if PACK_SKIP_ROWS = self then
        Result := 'PACK_SKIP_ROWS' else
      if PACK_SKIP_PIXELS = self then
        Result := 'PACK_SKIP_PIXELS' else
      if PACK_ALIGNMENT = self then
        Result := 'PACK_ALIGNMENT' else
      if PACK_SKIP_IMAGES = self then
        Result := 'PACK_SKIP_IMAGES' else
      if PACK_IMAGE_HEIGHT = self then
        Result := 'PACK_IMAGE_HEIGHT' else
      if UNPACK_SKIP_IMAGES = self then
        Result := 'UNPACK_SKIP_IMAGES' else
      if UNPACK_IMAGE_HEIGHT = self then
        Result := 'UNPACK_IMAGE_HEIGHT' else
      if PACK_SKIP_VOLUMES = self then
        Result := 'PACK_SKIP_VOLUMES' else
      if PACK_IMAGE_DEPTH = self then
        Result := 'PACK_IMAGE_DEPTH' else
      if UNPACK_SKIP_VOLUMES = self then
        Result := 'UNPACK_SKIP_VOLUMES' else
      if UNPACK_IMAGE_DEPTH = self then
        Result := 'UNPACK_IMAGE_DEPTH' else
      if PIXEL_TILE_WIDTH = self then
        Result := 'PIXEL_TILE_WIDTH' else
      if PIXEL_TILE_HEIGHT = self then
        Result := 'PIXEL_TILE_HEIGHT' else
      if PIXEL_TILE_GRID_WIDTH = self then
        Result := 'PIXEL_TILE_GRID_WIDTH' else
      if PIXEL_TILE_GRID_HEIGHT = self then
        Result := 'PIXEL_TILE_GRID_HEIGHT' else
      if PIXEL_TILE_GRID_DEPTH = self then
        Result := 'PIXEL_TILE_GRID_DEPTH' else
      if PIXEL_TILE_CACHE_SIZE = self then
        Result := 'PIXEL_TILE_CACHE_SIZE' else
      if PACK_RESAMPLE_SGIX = self then
        Result := 'PACK_RESAMPLE_SGIX' else
      if UNPACK_RESAMPLE_SGIX = self then
        Result := 'UNPACK_RESAMPLE_SGIX' else
      if PACK_SUBSAMPLE_RATE = self then
        Result := 'PACK_SUBSAMPLE_RATE' else
      if UNPACK_SUBSAMPLE_RATE = self then
        Result := 'UNPACK_SUBSAMPLE_RATE' else
      if PACK_RESAMPLE_OML = self then
        Result := 'PACK_RESAMPLE_OML' else
      if UNPACK_RESAMPLE_OML = self then
        Result := 'UNPACK_RESAMPLE_OML' else
        Result := $'glPixelStoreParameter[{self.val}]';
    end;
    
  end;
  
  glPixelStoreResampleMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RESAMPLE_DECIMATE_SGIX:  glPixelStoreResampleMode read new glPixelStoreResampleMode($8430);
    public static property RESAMPLE_REPLICATE_SGIX: glPixelStoreResampleMode read new glPixelStoreResampleMode($8433);
    public static property RESAMPLE_ZERO_FILL_SGIX: glPixelStoreResampleMode read new glPixelStoreResampleMode($8434);
    
    public function ToString: string; override;
    begin
      if RESAMPLE_DECIMATE_SGIX = self then
        Result := 'RESAMPLE_DECIMATE_SGIX' else
      if RESAMPLE_REPLICATE_SGIX = self then
        Result := 'RESAMPLE_REPLICATE_SGIX' else
      if RESAMPLE_ZERO_FILL_SGIX = self then
        Result := 'RESAMPLE_ZERO_FILL_SGIX' else
        Result := $'glPixelStoreResampleMode[{self.val}]';
    end;
    
  end;
  
  glPixelStoreSubsampleRate = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PIXEL_SUBSAMPLE_4444: glPixelStoreSubsampleRate read new glPixelStoreSubsampleRate($85A2);
    public static property PIXEL_SUBSAMPLE_2424: glPixelStoreSubsampleRate read new glPixelStoreSubsampleRate($85A3);
    public static property PIXEL_SUBSAMPLE_4242: glPixelStoreSubsampleRate read new glPixelStoreSubsampleRate($85A4);
    
    public function ToString: string; override;
    begin
      if PIXEL_SUBSAMPLE_4444 = self then
        Result := 'PIXEL_SUBSAMPLE_4444' else
      if PIXEL_SUBSAMPLE_2424 = self then
        Result := 'PIXEL_SUBSAMPLE_2424' else
      if PIXEL_SUBSAMPLE_4242 = self then
        Result := 'PIXEL_SUBSAMPLE_4242' else
        Result := $'glPixelStoreSubsampleRate[{self.val}]';
    end;
    
  end;
  
  glPixelTexGenMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:                    glPixelTexGenMode read new glPixelTexGenMode(0);
    public static property ALPHA:                   glPixelTexGenMode read new glPixelTexGenMode($1906);
    public static property RGB:                     glPixelTexGenMode read new glPixelTexGenMode($1907);
    public static property RGBA:                    glPixelTexGenMode read new glPixelTexGenMode($1908);
    public static property PIXEL_TEX_GEN_Q_CEILING: glPixelTexGenMode read new glPixelTexGenMode($8184);
    public static property PIXEL_TEX_GEN_Q_ROUND:   glPixelTexGenMode read new glPixelTexGenMode($8185);
    public static property PIXEL_TEX_GEN_Q_FLOOR:   glPixelTexGenMode read new glPixelTexGenMode($8186);
    public static property PIXEL_TEX_GEN_ALPHA_LS:  glPixelTexGenMode read new glPixelTexGenMode($8189);
    public static property PIXEL_TEX_GEN_ALPHA_MS:  glPixelTexGenMode read new glPixelTexGenMode($818A);
    
    public function ToString: string; override;
    begin
      if NONE = self then
        Result := 'NONE' else
      if ALPHA = self then
        Result := 'ALPHA' else
      if RGB = self then
        Result := 'RGB' else
      if RGBA = self then
        Result := 'RGBA' else
      if PIXEL_TEX_GEN_Q_CEILING = self then
        Result := 'PIXEL_TEX_GEN_Q_CEILING' else
      if PIXEL_TEX_GEN_Q_ROUND = self then
        Result := 'PIXEL_TEX_GEN_Q_ROUND' else
      if PIXEL_TEX_GEN_Q_FLOOR = self then
        Result := 'PIXEL_TEX_GEN_Q_FLOOR' else
      if PIXEL_TEX_GEN_ALPHA_LS = self then
        Result := 'PIXEL_TEX_GEN_ALPHA_LS' else
      if PIXEL_TEX_GEN_ALPHA_MS = self then
        Result := 'PIXEL_TEX_GEN_ALPHA_MS' else
        Result := $'glPixelTexGenMode[{self.val}]';
    end;
    
  end;
  
  glPixelTexGenParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PIXEL_FRAGMENT_RGB_SOURCE:   glPixelTexGenParameterName read new glPixelTexGenParameterName($8354);
    public static property PIXEL_FRAGMENT_ALPHA_SOURCE: glPixelTexGenParameterName read new glPixelTexGenParameterName($8355);
    
    public function ToString: string; override;
    begin
      if PIXEL_FRAGMENT_RGB_SOURCE = self then
        Result := 'PIXEL_FRAGMENT_RGB_SOURCE' else
      if PIXEL_FRAGMENT_ALPHA_SOURCE = self then
        Result := 'PIXEL_FRAGMENT_ALPHA_SOURCE' else
        Result := $'glPixelTexGenParameterName[{self.val}]';
    end;
    
  end;
  
  glPixelTransferParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MAP_COLOR:                     glPixelTransferParameter read new glPixelTransferParameter($0D10);
    public static property MAP_STENCIL:                   glPixelTransferParameter read new glPixelTransferParameter($0D11);
    public static property INDEX_SHIFT:                   glPixelTransferParameter read new glPixelTransferParameter($0D12);
    public static property INDEX_OFFSET:                  glPixelTransferParameter read new glPixelTransferParameter($0D13);
    public static property RED_SCALE:                     glPixelTransferParameter read new glPixelTransferParameter($0D14);
    public static property RED_BIAS:                      glPixelTransferParameter read new glPixelTransferParameter($0D15);
    public static property GREEN_SCALE:                   glPixelTransferParameter read new glPixelTransferParameter($0D18);
    public static property GREEN_BIAS:                    glPixelTransferParameter read new glPixelTransferParameter($0D19);
    public static property BLUE_SCALE:                    glPixelTransferParameter read new glPixelTransferParameter($0D1A);
    public static property BLUE_BIAS:                     glPixelTransferParameter read new glPixelTransferParameter($0D1B);
    public static property ALPHA_SCALE:                   glPixelTransferParameter read new glPixelTransferParameter($0D1C);
    public static property ALPHA_BIAS:                    glPixelTransferParameter read new glPixelTransferParameter($0D1D);
    public static property DEPTH_SCALE:                   glPixelTransferParameter read new glPixelTransferParameter($0D1E);
    public static property DEPTH_BIAS:                    glPixelTransferParameter read new glPixelTransferParameter($0D1F);
    public static property POST_CONVOLUTION_RED_SCALE:    glPixelTransferParameter read new glPixelTransferParameter($801C);
    public static property POST_CONVOLUTION_GREEN_SCALE:  glPixelTransferParameter read new glPixelTransferParameter($801D);
    public static property POST_CONVOLUTION_BLUE_SCALE:   glPixelTransferParameter read new glPixelTransferParameter($801E);
    public static property POST_CONVOLUTION_ALPHA_SCALE:  glPixelTransferParameter read new glPixelTransferParameter($801F);
    public static property POST_CONVOLUTION_RED_BIAS:     glPixelTransferParameter read new glPixelTransferParameter($8020);
    public static property POST_CONVOLUTION_GREEN_BIAS:   glPixelTransferParameter read new glPixelTransferParameter($8021);
    public static property POST_CONVOLUTION_BLUE_BIAS:    glPixelTransferParameter read new glPixelTransferParameter($8022);
    public static property POST_CONVOLUTION_ALPHA_BIAS:   glPixelTransferParameter read new glPixelTransferParameter($8023);
    public static property POST_COLOR_MATRIX_RED_SCALE:   glPixelTransferParameter read new glPixelTransferParameter($80B4);
    public static property POST_COLOR_MATRIX_GREEN_SCALE: glPixelTransferParameter read new glPixelTransferParameter($80B5);
    public static property POST_COLOR_MATRIX_BLUE_SCALE:  glPixelTransferParameter read new glPixelTransferParameter($80B6);
    public static property POST_COLOR_MATRIX_ALPHA_SCALE: glPixelTransferParameter read new glPixelTransferParameter($80B7);
    public static property POST_COLOR_MATRIX_RED_BIAS:    glPixelTransferParameter read new glPixelTransferParameter($80B8);
    public static property POST_COLOR_MATRIX_GREEN_BIAS:  glPixelTransferParameter read new glPixelTransferParameter($80B9);
    public static property POST_COLOR_MATRIX_BLUE_BIAS:   glPixelTransferParameter read new glPixelTransferParameter($80BA);
    public static property POST_COLOR_MATRIX_ALPHA_BIAS:  glPixelTransferParameter read new glPixelTransferParameter($80BB);
    
    public function ToString: string; override;
    begin
      if MAP_COLOR = self then
        Result := 'MAP_COLOR' else
      if MAP_STENCIL = self then
        Result := 'MAP_STENCIL' else
      if INDEX_SHIFT = self then
        Result := 'INDEX_SHIFT' else
      if INDEX_OFFSET = self then
        Result := 'INDEX_OFFSET' else
      if RED_SCALE = self then
        Result := 'RED_SCALE' else
      if RED_BIAS = self then
        Result := 'RED_BIAS' else
      if GREEN_SCALE = self then
        Result := 'GREEN_SCALE' else
      if GREEN_BIAS = self then
        Result := 'GREEN_BIAS' else
      if BLUE_SCALE = self then
        Result := 'BLUE_SCALE' else
      if BLUE_BIAS = self then
        Result := 'BLUE_BIAS' else
      if ALPHA_SCALE = self then
        Result := 'ALPHA_SCALE' else
      if ALPHA_BIAS = self then
        Result := 'ALPHA_BIAS' else
      if DEPTH_SCALE = self then
        Result := 'DEPTH_SCALE' else
      if DEPTH_BIAS = self then
        Result := 'DEPTH_BIAS' else
      if POST_CONVOLUTION_RED_SCALE = self then
        Result := 'POST_CONVOLUTION_RED_SCALE' else
      if POST_CONVOLUTION_GREEN_SCALE = self then
        Result := 'POST_CONVOLUTION_GREEN_SCALE' else
      if POST_CONVOLUTION_BLUE_SCALE = self then
        Result := 'POST_CONVOLUTION_BLUE_SCALE' else
      if POST_CONVOLUTION_ALPHA_SCALE = self then
        Result := 'POST_CONVOLUTION_ALPHA_SCALE' else
      if POST_CONVOLUTION_RED_BIAS = self then
        Result := 'POST_CONVOLUTION_RED_BIAS' else
      if POST_CONVOLUTION_GREEN_BIAS = self then
        Result := 'POST_CONVOLUTION_GREEN_BIAS' else
      if POST_CONVOLUTION_BLUE_BIAS = self then
        Result := 'POST_CONVOLUTION_BLUE_BIAS' else
      if POST_CONVOLUTION_ALPHA_BIAS = self then
        Result := 'POST_CONVOLUTION_ALPHA_BIAS' else
      if POST_COLOR_MATRIX_RED_SCALE = self then
        Result := 'POST_COLOR_MATRIX_RED_SCALE' else
      if POST_COLOR_MATRIX_GREEN_SCALE = self then
        Result := 'POST_COLOR_MATRIX_GREEN_SCALE' else
      if POST_COLOR_MATRIX_BLUE_SCALE = self then
        Result := 'POST_COLOR_MATRIX_BLUE_SCALE' else
      if POST_COLOR_MATRIX_ALPHA_SCALE = self then
        Result := 'POST_COLOR_MATRIX_ALPHA_SCALE' else
      if POST_COLOR_MATRIX_RED_BIAS = self then
        Result := 'POST_COLOR_MATRIX_RED_BIAS' else
      if POST_COLOR_MATRIX_GREEN_BIAS = self then
        Result := 'POST_COLOR_MATRIX_GREEN_BIAS' else
      if POST_COLOR_MATRIX_BLUE_BIAS = self then
        Result := 'POST_COLOR_MATRIX_BLUE_BIAS' else
      if POST_COLOR_MATRIX_ALPHA_BIAS = self then
        Result := 'POST_COLOR_MATRIX_ALPHA_BIAS' else
        Result := $'glPixelTransferParameter[{self.val}]';
    end;
    
  end;
  
  glPixelTransformPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PIXEL_MAG_FILTER:   glPixelTransformPName read new glPixelTransformPName($8331);
    public static property PIXEL_MIN_FILTER:   glPixelTransformPName read new glPixelTransformPName($8332);
    public static property PIXEL_CUBIC_WEIGHT: glPixelTransformPName read new glPixelTransformPName($8333);
    
    public function ToString: string; override;
    begin
      if PIXEL_MAG_FILTER = self then
        Result := 'PIXEL_MAG_FILTER' else
      if PIXEL_MIN_FILTER = self then
        Result := 'PIXEL_MIN_FILTER' else
      if PIXEL_CUBIC_WEIGHT = self then
        Result := 'PIXEL_CUBIC_WEIGHT' else
        Result := $'glPixelTransformPName[{self.val}]';
    end;
    
  end;
  
  glPixelTransformTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PIXEL_TRANSFORM_2D: glPixelTransformTarget read new glPixelTransformTarget($8330);
    
    public function ToString: string; override;
    begin
      if PIXEL_TRANSFORM_2D = self then
        Result := 'PIXEL_TRANSFORM_2D' else
        Result := $'glPixelTransformTarget[{self.val}]';
    end;
    
  end;
  
  glPixelType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:                           glPixelType read new glPixelType($1400);
    public static property UNSIGNED_BYTE:                  glPixelType read new glPixelType($1401);
    public static property SHORT:                          glPixelType read new glPixelType($1402);
    public static property UNSIGNED_SHORT:                 glPixelType read new glPixelType($1403);
    public static property INT:                            glPixelType read new glPixelType($1404);
    public static property UNSIGNED_INT:                   glPixelType read new glPixelType($1405);
    public static property FLOAT:                          glPixelType read new glPixelType($1406);
    public static property HALF_FLOAT:                     glPixelType read new glPixelType($140B);
    public static property HALF:                           glPixelType read new glPixelType($140B);
    public static property BITMAP:                         glPixelType read new glPixelType($1A00);
    public static property UNSIGNED_BYTE_3_3_2:            glPixelType read new glPixelType($8032);
    public static property UNSIGNED_SHORT_4_4_4_4:         glPixelType read new glPixelType($8033);
    public static property UNSIGNED_SHORT_5_5_5_1:         glPixelType read new glPixelType($8034);
    public static property UNSIGNED_INT_8_8_8_8:           glPixelType read new glPixelType($8035);
    public static property UNSIGNED_INT_10_10_10_2:        glPixelType read new glPixelType($8036);
    public static property UNSIGNED_BYTE_2_3_3_REV:        glPixelType read new glPixelType($8362);
    public static property UNSIGNED_SHORT_5_6_5:           glPixelType read new glPixelType($8363);
    public static property UNSIGNED_SHORT_5_6_5_REV:       glPixelType read new glPixelType($8364);
    public static property UNSIGNED_SHORT_4_4_4_4_REV:     glPixelType read new glPixelType($8365);
    public static property UNSIGNED_SHORT_1_5_5_5_REV:     glPixelType read new glPixelType($8366);
    public static property UNSIGNED_INT_8_8_8_8_REV:       glPixelType read new glPixelType($8367);
    public static property UNSIGNED_INT_2_10_10_10_REV:    glPixelType read new glPixelType($8368);
    public static property UNSIGNED_INT_24_8:              glPixelType read new glPixelType($84FA);
    public static property UNSIGNED_INT_10F_11F_11F_REV:   glPixelType read new glPixelType($8C3B);
    public static property UNSIGNED_INT_5_9_9_9_REV:       glPixelType read new glPixelType($8C3E);
    public static property FLOAT_32_UNSIGNED_INT_24_8_REV: glPixelType read new glPixelType($8DAD);
    
    public function ToString: string; override;
    begin
      if BYTE = self then
        Result := 'BYTE' else
      if UNSIGNED_BYTE = self then
        Result := 'UNSIGNED_BYTE' else
      if SHORT = self then
        Result := 'SHORT' else
      if UNSIGNED_SHORT = self then
        Result := 'UNSIGNED_SHORT' else
      if INT = self then
        Result := 'INT' else
      if UNSIGNED_INT = self then
        Result := 'UNSIGNED_INT' else
      if FLOAT = self then
        Result := 'FLOAT' else
      if HALF_FLOAT = self then
        Result := 'HALF_FLOAT' else
      if HALF = self then
        Result := 'HALF' else
      if BITMAP = self then
        Result := 'BITMAP' else
      if UNSIGNED_BYTE_3_3_2 = self then
        Result := 'UNSIGNED_BYTE_3_3_2' else
      if UNSIGNED_SHORT_4_4_4_4 = self then
        Result := 'UNSIGNED_SHORT_4_4_4_4' else
      if UNSIGNED_SHORT_5_5_5_1 = self then
        Result := 'UNSIGNED_SHORT_5_5_5_1' else
      if UNSIGNED_INT_8_8_8_8 = self then
        Result := 'UNSIGNED_INT_8_8_8_8' else
      if UNSIGNED_INT_10_10_10_2 = self then
        Result := 'UNSIGNED_INT_10_10_10_2' else
      if UNSIGNED_BYTE_2_3_3_REV = self then
        Result := 'UNSIGNED_BYTE_2_3_3_REV' else
      if UNSIGNED_SHORT_5_6_5 = self then
        Result := 'UNSIGNED_SHORT_5_6_5' else
      if UNSIGNED_SHORT_5_6_5_REV = self then
        Result := 'UNSIGNED_SHORT_5_6_5_REV' else
      if UNSIGNED_SHORT_4_4_4_4_REV = self then
        Result := 'UNSIGNED_SHORT_4_4_4_4_REV' else
      if UNSIGNED_SHORT_1_5_5_5_REV = self then
        Result := 'UNSIGNED_SHORT_1_5_5_5_REV' else
      if UNSIGNED_INT_8_8_8_8_REV = self then
        Result := 'UNSIGNED_INT_8_8_8_8_REV' else
      if UNSIGNED_INT_2_10_10_10_REV = self then
        Result := 'UNSIGNED_INT_2_10_10_10_REV' else
      if UNSIGNED_INT_24_8 = self then
        Result := 'UNSIGNED_INT_24_8' else
      if UNSIGNED_INT_10F_11F_11F_REV = self then
        Result := 'UNSIGNED_INT_10F_11F_11F_REV' else
      if UNSIGNED_INT_5_9_9_9_REV = self then
        Result := 'UNSIGNED_INT_5_9_9_9_REV' else
      if FLOAT_32_UNSIGNED_INT_24_8_REV = self then
        Result := 'FLOAT_32_UNSIGNED_INT_24_8_REV' else
        Result := $'glPixelType[{self.val}]';
    end;
    
  end;
  
  glPNTrianglesPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PN_TRIANGLES_POINT_MODE:        glPNTrianglesPName read new glPNTrianglesPName($87F2);
    public static property PN_TRIANGLES_NORMAL_MODE:       glPNTrianglesPName read new glPNTrianglesPName($87F3);
    public static property PN_TRIANGLES_TESSELATION_LEVEL: glPNTrianglesPName read new glPNTrianglesPName($87F4);
    
    public function ToString: string; override;
    begin
      if PN_TRIANGLES_POINT_MODE = self then
        Result := 'PN_TRIANGLES_POINT_MODE' else
      if PN_TRIANGLES_NORMAL_MODE = self then
        Result := 'PN_TRIANGLES_NORMAL_MODE' else
      if PN_TRIANGLES_TESSELATION_LEVEL = self then
        Result := 'PN_TRIANGLES_TESSELATION_LEVEL' else
        Result := $'glPNTrianglesPName[{self.val}]';
    end;
    
  end;
  
  glPointParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINT_SIZE_MIN:             glPointParameterName read new glPointParameterName($8126);
    public static property POINT_SIZE_MAX:             glPointParameterName read new glPointParameterName($8127);
    public static property POINT_FADE_THRESHOLD_SIZE:  glPointParameterName read new glPointParameterName($8128);
    public static property DISTANCE_ATTENUATION:       glPointParameterName read new glPointParameterName($8129);
    public static property POINT_DISTANCE_ATTENUATION: glPointParameterName read new glPointParameterName($8129);
    
    public function ToString: string; override;
    begin
      if POINT_SIZE_MIN = self then
        Result := 'POINT_SIZE_MIN' else
      if POINT_SIZE_MAX = self then
        Result := 'POINT_SIZE_MAX' else
      if POINT_FADE_THRESHOLD_SIZE = self then
        Result := 'POINT_FADE_THRESHOLD_SIZE' else
      if DISTANCE_ATTENUATION = self then
        Result := 'DISTANCE_ATTENUATION' else
      if POINT_DISTANCE_ATTENUATION = self then
        Result := 'POINT_DISTANCE_ATTENUATION' else
        Result := $'glPointParameterName[{self.val}]';
    end;
    
  end;
  
  glPolygonMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINT: glPolygonMode read new glPolygonMode($1B00);
    public static property LINE:  glPolygonMode read new glPolygonMode($1B01);
    public static property FILL:  glPolygonMode read new glPolygonMode($1B02);
    
    public function ToString: string; override;
    begin
      if POINT = self then
        Result := 'POINT' else
      if LINE = self then
        Result := 'LINE' else
      if FILL = self then
        Result := 'FILL' else
        Result := $'glPolygonMode[{self.val}]';
    end;
    
  end;
  
  glPrecisionType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LOW_FLOAT:    glPrecisionType read new glPrecisionType($8DF0);
    public static property MEDIUM_FLOAT: glPrecisionType read new glPrecisionType($8DF1);
    public static property HIGH_FLOAT:   glPrecisionType read new glPrecisionType($8DF2);
    public static property LOW_INT:      glPrecisionType read new glPrecisionType($8DF3);
    public static property MEDIUM_INT:   glPrecisionType read new glPrecisionType($8DF4);
    public static property HIGH_INT:     glPrecisionType read new glPrecisionType($8DF5);
    
    public function ToString: string; override;
    begin
      if LOW_FLOAT = self then
        Result := 'LOW_FLOAT' else
      if MEDIUM_FLOAT = self then
        Result := 'MEDIUM_FLOAT' else
      if HIGH_FLOAT = self then
        Result := 'HIGH_FLOAT' else
      if LOW_INT = self then
        Result := 'LOW_INT' else
      if MEDIUM_INT = self then
        Result := 'MEDIUM_INT' else
      if HIGH_INT = self then
        Result := 'HIGH_INT' else
        Result := $'glPrecisionType[{self.val}]';
    end;
    
  end;
  
  glPreserveMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PRESERVE:    glPreserveMode read new glPreserveMode($8762);
    public static property DISCARD_ATI: glPreserveMode read new glPreserveMode($8763);
    
    public function ToString: string; override;
    begin
      if PRESERVE = self then
        Result := 'PRESERVE' else
      if DISCARD_ATI = self then
        Result := 'DISCARD_ATI' else
        Result := $'glPreserveMode[{self.val}]';
    end;
    
  end;
  
  glPrimitiveType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINTS:                   glPrimitiveType read new glPrimitiveType(0);
    public static property LINES:                    glPrimitiveType read new glPrimitiveType($0001);
    public static property LINE_LOOP:                glPrimitiveType read new glPrimitiveType($0002);
    public static property LINE_STRIP:               glPrimitiveType read new glPrimitiveType($0003);
    public static property TRIANGLES:                glPrimitiveType read new glPrimitiveType($0004);
    public static property TRIANGLE_STRIP:           glPrimitiveType read new glPrimitiveType($0005);
    public static property TRIANGLE_FAN:             glPrimitiveType read new glPrimitiveType($0006);
    public static property QUADS:                    glPrimitiveType read new glPrimitiveType($0007);
    public static property QUAD_STRIP:               glPrimitiveType read new glPrimitiveType($0008);
    public static property POLYGON:                  glPrimitiveType read new glPrimitiveType($0009);
    public static property LINES_ADJACENCY:          glPrimitiveType read new glPrimitiveType($000A);
    public static property LINE_STRIP_ADJACENCY:     glPrimitiveType read new glPrimitiveType($000B);
    public static property TRIANGLES_ADJACENCY:      glPrimitiveType read new glPrimitiveType($000C);
    public static property TRIANGLE_STRIP_ADJACENCY: glPrimitiveType read new glPrimitiveType($000D);
    public static property PATCHES:                  glPrimitiveType read new glPrimitiveType($000E);
    
    public function ToString: string; override;
    begin
      if POINTS = self then
        Result := 'POINTS' else
      if LINES = self then
        Result := 'LINES' else
      if LINE_LOOP = self then
        Result := 'LINE_LOOP' else
      if LINE_STRIP = self then
        Result := 'LINE_STRIP' else
      if TRIANGLES = self then
        Result := 'TRIANGLES' else
      if TRIANGLE_STRIP = self then
        Result := 'TRIANGLE_STRIP' else
      if TRIANGLE_FAN = self then
        Result := 'TRIANGLE_FAN' else
      if QUADS = self then
        Result := 'QUADS' else
      if QUAD_STRIP = self then
        Result := 'QUAD_STRIP' else
      if POLYGON = self then
        Result := 'POLYGON' else
      if LINES_ADJACENCY = self then
        Result := 'LINES_ADJACENCY' else
      if LINE_STRIP_ADJACENCY = self then
        Result := 'LINE_STRIP_ADJACENCY' else
      if TRIANGLES_ADJACENCY = self then
        Result := 'TRIANGLES_ADJACENCY' else
      if TRIANGLE_STRIP_ADJACENCY = self then
        Result := 'TRIANGLE_STRIP_ADJACENCY' else
      if PATCHES = self then
        Result := 'PATCHES' else
        Result := $'glPrimitiveType[{self.val}]';
    end;
    
  end;
  
  glProgramFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROGRAM_FORMAT_ASCII: glProgramFormat read new glProgramFormat($8875);
    
    public function ToString: string; override;
    begin
      if PROGRAM_FORMAT_ASCII = self then
        Result := 'PROGRAM_FORMAT_ASCII' else
        Result := $'glProgramFormat[{self.val}]';
    end;
    
  end;
  
  glProgramInterface = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TRANSFORM_FEEDBACK_BUFFER:          glProgramInterface read new glProgramInterface($8C8E);
    public static property UNIFORM:                            glProgramInterface read new glProgramInterface($92E1);
    public static property UNIFORM_BLOCK:                      glProgramInterface read new glProgramInterface($92E2);
    public static property PROGRAM_INPUT:                      glProgramInterface read new glProgramInterface($92E3);
    public static property PROGRAM_OUTPUT:                     glProgramInterface read new glProgramInterface($92E4);
    public static property BUFFER_VARIABLE:                    glProgramInterface read new glProgramInterface($92E5);
    public static property SHADER_STORAGE_BLOCK:               glProgramInterface read new glProgramInterface($92E6);
    public static property VERTEX_SUBROUTINE:                  glProgramInterface read new glProgramInterface($92E8);
    public static property TESS_CONTROL_SUBROUTINE:            glProgramInterface read new glProgramInterface($92E9);
    public static property TESS_EVALUATION_SUBROUTINE:         glProgramInterface read new glProgramInterface($92EA);
    public static property GEOMETRY_SUBROUTINE:                glProgramInterface read new glProgramInterface($92EB);
    public static property FRAGMENT_SUBROUTINE:                glProgramInterface read new glProgramInterface($92EC);
    public static property COMPUTE_SUBROUTINE:                 glProgramInterface read new glProgramInterface($92ED);
    public static property VERTEX_SUBROUTINE_UNIFORM:          glProgramInterface read new glProgramInterface($92EE);
    public static property TESS_CONTROL_SUBROUTINE_UNIFORM:    glProgramInterface read new glProgramInterface($92EF);
    public static property TESS_EVALUATION_SUBROUTINE_UNIFORM: glProgramInterface read new glProgramInterface($92F0);
    public static property GEOMETRY_SUBROUTINE_UNIFORM:        glProgramInterface read new glProgramInterface($92F1);
    public static property FRAGMENT_SUBROUTINE_UNIFORM:        glProgramInterface read new glProgramInterface($92F2);
    public static property COMPUTE_SUBROUTINE_UNIFORM:         glProgramInterface read new glProgramInterface($92F3);
    public static property TRANSFORM_FEEDBACK_VARYING:         glProgramInterface read new glProgramInterface($92F4);
    
    public function ToString: string; override;
    begin
      if TRANSFORM_FEEDBACK_BUFFER = self then
        Result := 'TRANSFORM_FEEDBACK_BUFFER' else
      if UNIFORM = self then
        Result := 'UNIFORM' else
      if UNIFORM_BLOCK = self then
        Result := 'UNIFORM_BLOCK' else
      if PROGRAM_INPUT = self then
        Result := 'PROGRAM_INPUT' else
      if PROGRAM_OUTPUT = self then
        Result := 'PROGRAM_OUTPUT' else
      if BUFFER_VARIABLE = self then
        Result := 'BUFFER_VARIABLE' else
      if SHADER_STORAGE_BLOCK = self then
        Result := 'SHADER_STORAGE_BLOCK' else
      if VERTEX_SUBROUTINE = self then
        Result := 'VERTEX_SUBROUTINE' else
      if TESS_CONTROL_SUBROUTINE = self then
        Result := 'TESS_CONTROL_SUBROUTINE' else
      if TESS_EVALUATION_SUBROUTINE = self then
        Result := 'TESS_EVALUATION_SUBROUTINE' else
      if GEOMETRY_SUBROUTINE = self then
        Result := 'GEOMETRY_SUBROUTINE' else
      if FRAGMENT_SUBROUTINE = self then
        Result := 'FRAGMENT_SUBROUTINE' else
      if COMPUTE_SUBROUTINE = self then
        Result := 'COMPUTE_SUBROUTINE' else
      if VERTEX_SUBROUTINE_UNIFORM = self then
        Result := 'VERTEX_SUBROUTINE_UNIFORM' else
      if TESS_CONTROL_SUBROUTINE_UNIFORM = self then
        Result := 'TESS_CONTROL_SUBROUTINE_UNIFORM' else
      if TESS_EVALUATION_SUBROUTINE_UNIFORM = self then
        Result := 'TESS_EVALUATION_SUBROUTINE_UNIFORM' else
      if GEOMETRY_SUBROUTINE_UNIFORM = self then
        Result := 'GEOMETRY_SUBROUTINE_UNIFORM' else
      if FRAGMENT_SUBROUTINE_UNIFORM = self then
        Result := 'FRAGMENT_SUBROUTINE_UNIFORM' else
      if COMPUTE_SUBROUTINE_UNIFORM = self then
        Result := 'COMPUTE_SUBROUTINE_UNIFORM' else
      if TRANSFORM_FEEDBACK_VARYING = self then
        Result := 'TRANSFORM_FEEDBACK_VARYING' else
        Result := $'glProgramInterface[{self.val}]';
    end;
    
  end;
  
  glProgramInterfacePName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_RESOURCES:               glProgramInterfacePName read new glProgramInterfacePName($92F5);
    public static property MAX_NAME_LENGTH:                glProgramInterfacePName read new glProgramInterfacePName($92F6);
    public static property MAX_NUM_ACTIVE_VARIABLES:       glProgramInterfacePName read new glProgramInterfacePName($92F7);
    public static property MAX_NUM_COMPATIBLE_SUBROUTINES: glProgramInterfacePName read new glProgramInterfacePName($92F8);
    
    public function ToString: string; override;
    begin
      if ACTIVE_RESOURCES = self then
        Result := 'ACTIVE_RESOURCES' else
      if MAX_NAME_LENGTH = self then
        Result := 'MAX_NAME_LENGTH' else
      if MAX_NUM_ACTIVE_VARIABLES = self then
        Result := 'MAX_NUM_ACTIVE_VARIABLES' else
      if MAX_NUM_COMPATIBLE_SUBROUTINES = self then
        Result := 'MAX_NUM_COMPATIBLE_SUBROUTINES' else
        Result := $'glProgramInterfacePName[{self.val}]';
    end;
    
  end;
  
  glProgramParameterPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROGRAM_BINARY_RETRIEVABLE_HINT: glProgramParameterPName read new glProgramParameterPName($8257);
    public static property PROGRAM_SEPARABLE:               glProgramParameterPName read new glProgramParameterPName($8258);
    
    public function ToString: string; override;
    begin
      if PROGRAM_BINARY_RETRIEVABLE_HINT = self then
        Result := 'PROGRAM_BINARY_RETRIEVABLE_HINT' else
      if PROGRAM_SEPARABLE = self then
        Result := 'PROGRAM_SEPARABLE' else
        Result := $'glProgramParameterPName[{self.val}]';
    end;
    
  end;
  
  glProgramProperty = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMPUTE_WORK_GROUP_SIZE:               glProgramProperty read new glProgramProperty($8267);
    public static property PROGRAM_BINARY_LENGTH:                 glProgramProperty read new glProgramProperty($8741);
    public static property GEOMETRY_VERTICES_OUT:                 glProgramProperty read new glProgramProperty($8916);
    public static property GEOMETRY_INPUT_TYPE:                   glProgramProperty read new glProgramProperty($8917);
    public static property GEOMETRY_OUTPUT_TYPE:                  glProgramProperty read new glProgramProperty($8918);
    public static property ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH:  glProgramProperty read new glProgramProperty($8A35);
    public static property ACTIVE_UNIFORM_BLOCKS:                 glProgramProperty read new glProgramProperty($8A36);
    public static property DELETE_STATUS:                         glProgramProperty read new glProgramProperty($8B80);
    public static property LINK_STATUS:                           glProgramProperty read new glProgramProperty($8B82);
    public static property VALIDATE_STATUS:                       glProgramProperty read new glProgramProperty($8B83);
    public static property INFO_LOG_LENGTH:                       glProgramProperty read new glProgramProperty($8B84);
    public static property ATTACHED_SHADERS:                      glProgramProperty read new glProgramProperty($8B85);
    public static property ACTIVE_UNIFORMS:                       glProgramProperty read new glProgramProperty($8B86);
    public static property ACTIVE_UNIFORM_MAX_LENGTH:             glProgramProperty read new glProgramProperty($8B87);
    public static property ACTIVE_ATTRIBUTES:                     glProgramProperty read new glProgramProperty($8B89);
    public static property ACTIVE_ATTRIBUTE_MAX_LENGTH:           glProgramProperty read new glProgramProperty($8B8A);
    public static property TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: glProgramProperty read new glProgramProperty($8C76);
    public static property TRANSFORM_FEEDBACK_BUFFER_MODE:        glProgramProperty read new glProgramProperty($8C7F);
    public static property TRANSFORM_FEEDBACK_VARYINGS:           glProgramProperty read new glProgramProperty($8C83);
    public static property ACTIVE_ATOMIC_COUNTER_BUFFERS:         glProgramProperty read new glProgramProperty($92D9);
    
    public function ToString: string; override;
    begin
      if COMPUTE_WORK_GROUP_SIZE = self then
        Result := 'COMPUTE_WORK_GROUP_SIZE' else
      if PROGRAM_BINARY_LENGTH = self then
        Result := 'PROGRAM_BINARY_LENGTH' else
      if GEOMETRY_VERTICES_OUT = self then
        Result := 'GEOMETRY_VERTICES_OUT' else
      if GEOMETRY_INPUT_TYPE = self then
        Result := 'GEOMETRY_INPUT_TYPE' else
      if GEOMETRY_OUTPUT_TYPE = self then
        Result := 'GEOMETRY_OUTPUT_TYPE' else
      if ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = self then
        Result := 'ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH' else
      if ACTIVE_UNIFORM_BLOCKS = self then
        Result := 'ACTIVE_UNIFORM_BLOCKS' else
      if DELETE_STATUS = self then
        Result := 'DELETE_STATUS' else
      if LINK_STATUS = self then
        Result := 'LINK_STATUS' else
      if VALIDATE_STATUS = self then
        Result := 'VALIDATE_STATUS' else
      if INFO_LOG_LENGTH = self then
        Result := 'INFO_LOG_LENGTH' else
      if ATTACHED_SHADERS = self then
        Result := 'ATTACHED_SHADERS' else
      if ACTIVE_UNIFORMS = self then
        Result := 'ACTIVE_UNIFORMS' else
      if ACTIVE_UNIFORM_MAX_LENGTH = self then
        Result := 'ACTIVE_UNIFORM_MAX_LENGTH' else
      if ACTIVE_ATTRIBUTES = self then
        Result := 'ACTIVE_ATTRIBUTES' else
      if ACTIVE_ATTRIBUTE_MAX_LENGTH = self then
        Result := 'ACTIVE_ATTRIBUTE_MAX_LENGTH' else
      if TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH = self then
        Result := 'TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH' else
      if TRANSFORM_FEEDBACK_BUFFER_MODE = self then
        Result := 'TRANSFORM_FEEDBACK_BUFFER_MODE' else
      if TRANSFORM_FEEDBACK_VARYINGS = self then
        Result := 'TRANSFORM_FEEDBACK_VARYINGS' else
      if ACTIVE_ATOMIC_COUNTER_BUFFERS = self then
        Result := 'ACTIVE_ATOMIC_COUNTER_BUFFERS' else
        Result := $'glProgramProperty[{self.val}]';
    end;
    
  end;
  
  glProgramResourceProperty = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NUM_COMPATIBLE_SUBROUTINES:           glProgramResourceProperty read new glProgramResourceProperty($8E4A);
    public static property COMPATIBLE_SUBROUTINES:               glProgramResourceProperty read new glProgramResourceProperty($8E4B);
    public static property UNIFORM:                              glProgramResourceProperty read new glProgramResourceProperty($92E1);
    public static property IS_PER_PATCH:                         glProgramResourceProperty read new glProgramResourceProperty($92E7);
    public static property NAME_LENGTH:                          glProgramResourceProperty read new glProgramResourceProperty($92F9);
    public static property &TYPE:                                glProgramResourceProperty read new glProgramResourceProperty($92FA);
    public static property ARRAY_SIZE:                           glProgramResourceProperty read new glProgramResourceProperty($92FB);
    public static property OFFSET:                               glProgramResourceProperty read new glProgramResourceProperty($92FC);
    public static property BLOCK_INDEX:                          glProgramResourceProperty read new glProgramResourceProperty($92FD);
    public static property ARRAY_STRIDE:                         glProgramResourceProperty read new glProgramResourceProperty($92FE);
    public static property MATRIX_STRIDE:                        glProgramResourceProperty read new glProgramResourceProperty($92FF);
    public static property IS_ROW_MAJOR:                         glProgramResourceProperty read new glProgramResourceProperty($9300);
    public static property ATOMIC_COUNTER_BUFFER_INDEX:          glProgramResourceProperty read new glProgramResourceProperty($9301);
    public static property BUFFER_BINDING:                       glProgramResourceProperty read new glProgramResourceProperty($9302);
    public static property BUFFER_DATA_SIZE:                     glProgramResourceProperty read new glProgramResourceProperty($9303);
    public static property NUM_ACTIVE_VARIABLES:                 glProgramResourceProperty read new glProgramResourceProperty($9304);
    public static property ACTIVE_VARIABLES:                     glProgramResourceProperty read new glProgramResourceProperty($9305);
    public static property REFERENCED_BY_VERTEX_SHADER:          glProgramResourceProperty read new glProgramResourceProperty($9306);
    public static property REFERENCED_BY_TESS_CONTROL_SHADER:    glProgramResourceProperty read new glProgramResourceProperty($9307);
    public static property REFERENCED_BY_TESS_EVALUATION_SHADER: glProgramResourceProperty read new glProgramResourceProperty($9308);
    public static property REFERENCED_BY_GEOMETRY_SHADER:        glProgramResourceProperty read new glProgramResourceProperty($9309);
    public static property REFERENCED_BY_FRAGMENT_SHADER:        glProgramResourceProperty read new glProgramResourceProperty($930A);
    public static property REFERENCED_BY_COMPUTE_SHADER:         glProgramResourceProperty read new glProgramResourceProperty($930B);
    public static property TOP_LEVEL_ARRAY_SIZE:                 glProgramResourceProperty read new glProgramResourceProperty($930C);
    public static property TOP_LEVEL_ARRAY_STRIDE:               glProgramResourceProperty read new glProgramResourceProperty($930D);
    public static property LOCATION:                             glProgramResourceProperty read new glProgramResourceProperty($930E);
    public static property LOCATION_INDEX:                       glProgramResourceProperty read new glProgramResourceProperty($930F);
    public static property LOCATION_COMPONENT:                   glProgramResourceProperty read new glProgramResourceProperty($934A);
    public static property TRANSFORM_FEEDBACK_BUFFER_INDEX:      glProgramResourceProperty read new glProgramResourceProperty($934B);
    public static property TRANSFORM_FEEDBACK_BUFFER_STRIDE:     glProgramResourceProperty read new glProgramResourceProperty($934C);
    
    public function ToString: string; override;
    begin
      if NUM_COMPATIBLE_SUBROUTINES = self then
        Result := 'NUM_COMPATIBLE_SUBROUTINES' else
      if COMPATIBLE_SUBROUTINES = self then
        Result := 'COMPATIBLE_SUBROUTINES' else
      if UNIFORM = self then
        Result := 'UNIFORM' else
      if IS_PER_PATCH = self then
        Result := 'IS_PER_PATCH' else
      if NAME_LENGTH = self then
        Result := 'NAME_LENGTH' else
      if &TYPE = self then
        Result := 'TYPE' else
      if ARRAY_SIZE = self then
        Result := 'ARRAY_SIZE' else
      if OFFSET = self then
        Result := 'OFFSET' else
      if BLOCK_INDEX = self then
        Result := 'BLOCK_INDEX' else
      if ARRAY_STRIDE = self then
        Result := 'ARRAY_STRIDE' else
      if MATRIX_STRIDE = self then
        Result := 'MATRIX_STRIDE' else
      if IS_ROW_MAJOR = self then
        Result := 'IS_ROW_MAJOR' else
      if ATOMIC_COUNTER_BUFFER_INDEX = self then
        Result := 'ATOMIC_COUNTER_BUFFER_INDEX' else
      if BUFFER_BINDING = self then
        Result := 'BUFFER_BINDING' else
      if BUFFER_DATA_SIZE = self then
        Result := 'BUFFER_DATA_SIZE' else
      if NUM_ACTIVE_VARIABLES = self then
        Result := 'NUM_ACTIVE_VARIABLES' else
      if ACTIVE_VARIABLES = self then
        Result := 'ACTIVE_VARIABLES' else
      if REFERENCED_BY_VERTEX_SHADER = self then
        Result := 'REFERENCED_BY_VERTEX_SHADER' else
      if REFERENCED_BY_TESS_CONTROL_SHADER = self then
        Result := 'REFERENCED_BY_TESS_CONTROL_SHADER' else
      if REFERENCED_BY_TESS_EVALUATION_SHADER = self then
        Result := 'REFERENCED_BY_TESS_EVALUATION_SHADER' else
      if REFERENCED_BY_GEOMETRY_SHADER = self then
        Result := 'REFERENCED_BY_GEOMETRY_SHADER' else
      if REFERENCED_BY_FRAGMENT_SHADER = self then
        Result := 'REFERENCED_BY_FRAGMENT_SHADER' else
      if REFERENCED_BY_COMPUTE_SHADER = self then
        Result := 'REFERENCED_BY_COMPUTE_SHADER' else
      if TOP_LEVEL_ARRAY_SIZE = self then
        Result := 'TOP_LEVEL_ARRAY_SIZE' else
      if TOP_LEVEL_ARRAY_STRIDE = self then
        Result := 'TOP_LEVEL_ARRAY_STRIDE' else
      if LOCATION = self then
        Result := 'LOCATION' else
      if LOCATION_INDEX = self then
        Result := 'LOCATION_INDEX' else
      if LOCATION_COMPONENT = self then
        Result := 'LOCATION_COMPONENT' else
      if TRANSFORM_FEEDBACK_BUFFER_INDEX = self then
        Result := 'TRANSFORM_FEEDBACK_BUFFER_INDEX' else
      if TRANSFORM_FEEDBACK_BUFFER_STRIDE = self then
        Result := 'TRANSFORM_FEEDBACK_BUFFER_STRIDE' else
        Result := $'glProgramResourceProperty[{self.val}]';
    end;
    
  end;
  
  glProgramStagePName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_SUBROUTINES:                   glProgramStagePName read new glProgramStagePName($8DE5);
    public static property ACTIVE_SUBROUTINE_UNIFORMS:           glProgramStagePName read new glProgramStagePName($8DE6);
    public static property ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS:  glProgramStagePName read new glProgramStagePName($8E47);
    public static property ACTIVE_SUBROUTINE_MAX_LENGTH:         glProgramStagePName read new glProgramStagePName($8E48);
    public static property ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH: glProgramStagePName read new glProgramStagePName($8E49);
    
    public function ToString: string; override;
    begin
      if ACTIVE_SUBROUTINES = self then
        Result := 'ACTIVE_SUBROUTINES' else
      if ACTIVE_SUBROUTINE_UNIFORMS = self then
        Result := 'ACTIVE_SUBROUTINE_UNIFORMS' else
      if ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS = self then
        Result := 'ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS' else
      if ACTIVE_SUBROUTINE_MAX_LENGTH = self then
        Result := 'ACTIVE_SUBROUTINE_MAX_LENGTH' else
      if ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH = self then
        Result := 'ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH' else
        Result := $'glProgramStagePName[{self.val}]';
    end;
    
  end;
  
  glProgramStringProperty = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROGRAM_STRING: glProgramStringProperty read new glProgramStringProperty($8628);
    
    public function ToString: string; override;
    begin
      if PROGRAM_STRING = self then
        Result := 'PROGRAM_STRING' else
        Result := $'glProgramStringProperty[{self.val}]';
    end;
    
  end;
  
  glProgramTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXT_FRAGMENT_SHADER:    glProgramTarget read new glProgramTarget($8200);
    public static property VERTEX_PROGRAM:          glProgramTarget read new glProgramTarget($8620);
    public static property FRAGMENT_PROGRAM_ARB:    glProgramTarget read new glProgramTarget($8804);
    public static property TESS_CONTROL_PROGRAM:    glProgramTarget read new glProgramTarget($891E);
    public static property TESS_EVALUATION_PROGRAM: glProgramTarget read new glProgramTarget($891F);
    public static property GEOMETRY_PROGRAM:        glProgramTarget read new glProgramTarget($8C26);
    public static property COMPUTE_PROGRAM:         glProgramTarget read new glProgramTarget($90FB);
    
    public function ToString: string; override;
    begin
      if TEXT_FRAGMENT_SHADER = self then
        Result := 'TEXT_FRAGMENT_SHADER' else
      if VERTEX_PROGRAM = self then
        Result := 'VERTEX_PROGRAM' else
      if FRAGMENT_PROGRAM_ARB = self then
        Result := 'FRAGMENT_PROGRAM_ARB' else
      if TESS_CONTROL_PROGRAM = self then
        Result := 'TESS_CONTROL_PROGRAM' else
      if TESS_EVALUATION_PROGRAM = self then
        Result := 'TESS_EVALUATION_PROGRAM' else
      if GEOMETRY_PROGRAM = self then
        Result := 'GEOMETRY_PROGRAM' else
      if COMPUTE_PROGRAM = self then
        Result := 'COMPUTE_PROGRAM' else
        Result := $'glProgramTarget[{self.val}]';
    end;
    
  end;
  
  glQueryCounterTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TIMESTAMP: glQueryCounterTarget read new glQueryCounterTarget($8E28);
    
    public function ToString: string; override;
    begin
      if TIMESTAMP = self then
        Result := 'TIMESTAMP' else
        Result := $'glQueryCounterTarget[{self.val}]';
    end;
    
  end;
  
  glQueryObjectParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property QUERY_TARGET:           glQueryObjectParameterName read new glQueryObjectParameterName($82EA);
    public static property QUERY_RESULT:           glQueryObjectParameterName read new glQueryObjectParameterName($8866);
    public static property QUERY_RESULT_AVAILABLE: glQueryObjectParameterName read new glQueryObjectParameterName($8867);
    public static property QUERY_RESULT_NO_WAIT:   glQueryObjectParameterName read new glQueryObjectParameterName($9194);
    
    public function ToString: string; override;
    begin
      if QUERY_TARGET = self then
        Result := 'QUERY_TARGET' else
      if QUERY_RESULT = self then
        Result := 'QUERY_RESULT' else
      if QUERY_RESULT_AVAILABLE = self then
        Result := 'QUERY_RESULT_AVAILABLE' else
      if QUERY_RESULT_NO_WAIT = self then
        Result := 'QUERY_RESULT_NO_WAIT' else
        Result := $'glQueryObjectParameterName[{self.val}]';
    end;
    
  end;
  
  glQueryParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property QUERY_COUNTER_BITS: glQueryParameterName read new glQueryParameterName($8864);
    public static property CURRENT_QUERY:      glQueryParameterName read new glQueryParameterName($8865);
    
    public function ToString: string; override;
    begin
      if QUERY_COUNTER_BITS = self then
        Result := 'QUERY_COUNTER_BITS' else
      if CURRENT_QUERY = self then
        Result := 'CURRENT_QUERY' else
        Result := $'glQueryParameterName[{self.val}]';
    end;
    
  end;
  
  glQueryTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TRANSFORM_FEEDBACK_OVERFLOW:           glQueryTarget read new glQueryTarget($82EC);
    public static property VERTICES_SUBMITTED:                    glQueryTarget read new glQueryTarget($82EE);
    public static property PRIMITIVES_SUBMITTED:                  glQueryTarget read new glQueryTarget($82EF);
    public static property VERTEX_SHADER_INVOCATIONS:             glQueryTarget read new glQueryTarget($82F0);
    public static property TIME_ELAPSED:                          glQueryTarget read new glQueryTarget($88BF);
    public static property SAMPLES_PASSED:                        glQueryTarget read new glQueryTarget($8914);
    public static property ANY_SAMPLES_PASSED:                    glQueryTarget read new glQueryTarget($8C2F);
    public static property PRIMITIVES_GENERATED:                  glQueryTarget read new glQueryTarget($8C87);
    public static property TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: glQueryTarget read new glQueryTarget($8C88);
    public static property ANY_SAMPLES_PASSED_CONSERVATIVE:       glQueryTarget read new glQueryTarget($8D6A);
    
    public function ToString: string; override;
    begin
      if TRANSFORM_FEEDBACK_OVERFLOW = self then
        Result := 'TRANSFORM_FEEDBACK_OVERFLOW' else
      if VERTICES_SUBMITTED = self then
        Result := 'VERTICES_SUBMITTED' else
      if PRIMITIVES_SUBMITTED = self then
        Result := 'PRIMITIVES_SUBMITTED' else
      if VERTEX_SHADER_INVOCATIONS = self then
        Result := 'VERTEX_SHADER_INVOCATIONS' else
      if TIME_ELAPSED = self then
        Result := 'TIME_ELAPSED' else
      if SAMPLES_PASSED = self then
        Result := 'SAMPLES_PASSED' else
      if ANY_SAMPLES_PASSED = self then
        Result := 'ANY_SAMPLES_PASSED' else
      if PRIMITIVES_GENERATED = self then
        Result := 'PRIMITIVES_GENERATED' else
      if TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = self then
        Result := 'TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN' else
      if ANY_SAMPLES_PASSED_CONSERVATIVE = self then
        Result := 'ANY_SAMPLES_PASSED_CONSERVATIVE' else
        Result := $'glQueryTarget[{self.val}]';
    end;
    
  end;
  
  glReadBufferMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:               glReadBufferMode read new glReadBufferMode(0);
    public static property FRONT_LEFT:         glReadBufferMode read new glReadBufferMode($0400);
    public static property FRONT_RIGHT:        glReadBufferMode read new glReadBufferMode($0401);
    public static property BACK_LEFT:          glReadBufferMode read new glReadBufferMode($0402);
    public static property BACK_RIGHT:         glReadBufferMode read new glReadBufferMode($0403);
    public static property FRONT:              glReadBufferMode read new glReadBufferMode($0404);
    public static property BACK:               glReadBufferMode read new glReadBufferMode($0405);
    public static property LEFT:               glReadBufferMode read new glReadBufferMode($0406);
    public static property RIGHT:              glReadBufferMode read new glReadBufferMode($0407);
    public static property AUX0:               glReadBufferMode read new glReadBufferMode($0409);
    public static property AUX1:               glReadBufferMode read new glReadBufferMode($040A);
    public static property AUX2:               glReadBufferMode read new glReadBufferMode($040B);
    public static property AUX3:               glReadBufferMode read new glReadBufferMode($040C);
    public static property COLOR_ATTACHMENT0:  glReadBufferMode read new glReadBufferMode($8CE0);
    public static property COLOR_ATTACHMENT1:  glReadBufferMode read new glReadBufferMode($8CE1);
    public static property COLOR_ATTACHMENT2:  glReadBufferMode read new glReadBufferMode($8CE2);
    public static property COLOR_ATTACHMENT3:  glReadBufferMode read new glReadBufferMode($8CE3);
    public static property COLOR_ATTACHMENT4:  glReadBufferMode read new glReadBufferMode($8CE4);
    public static property COLOR_ATTACHMENT5:  glReadBufferMode read new glReadBufferMode($8CE5);
    public static property COLOR_ATTACHMENT6:  glReadBufferMode read new glReadBufferMode($8CE6);
    public static property COLOR_ATTACHMENT7:  glReadBufferMode read new glReadBufferMode($8CE7);
    public static property COLOR_ATTACHMENT8:  glReadBufferMode read new glReadBufferMode($8CE8);
    public static property COLOR_ATTACHMENT9:  glReadBufferMode read new glReadBufferMode($8CE9);
    public static property COLOR_ATTACHMENT10: glReadBufferMode read new glReadBufferMode($8CEA);
    public static property COLOR_ATTACHMENT11: glReadBufferMode read new glReadBufferMode($8CEB);
    public static property COLOR_ATTACHMENT12: glReadBufferMode read new glReadBufferMode($8CEC);
    public static property COLOR_ATTACHMENT13: glReadBufferMode read new glReadBufferMode($8CED);
    public static property COLOR_ATTACHMENT14: glReadBufferMode read new glReadBufferMode($8CEE);
    public static property COLOR_ATTACHMENT15: glReadBufferMode read new glReadBufferMode($8CEF);
    
    public function ToString: string; override;
    begin
      if NONE = self then
        Result := 'NONE' else
      if FRONT_LEFT = self then
        Result := 'FRONT_LEFT' else
      if FRONT_RIGHT = self then
        Result := 'FRONT_RIGHT' else
      if BACK_LEFT = self then
        Result := 'BACK_LEFT' else
      if BACK_RIGHT = self then
        Result := 'BACK_RIGHT' else
      if FRONT = self then
        Result := 'FRONT' else
      if BACK = self then
        Result := 'BACK' else
      if LEFT = self then
        Result := 'LEFT' else
      if RIGHT = self then
        Result := 'RIGHT' else
      if AUX0 = self then
        Result := 'AUX0' else
      if AUX1 = self then
        Result := 'AUX1' else
      if AUX2 = self then
        Result := 'AUX2' else
      if AUX3 = self then
        Result := 'AUX3' else
      if COLOR_ATTACHMENT0 = self then
        Result := 'COLOR_ATTACHMENT0' else
      if COLOR_ATTACHMENT1 = self then
        Result := 'COLOR_ATTACHMENT1' else
      if COLOR_ATTACHMENT2 = self then
        Result := 'COLOR_ATTACHMENT2' else
      if COLOR_ATTACHMENT3 = self then
        Result := 'COLOR_ATTACHMENT3' else
      if COLOR_ATTACHMENT4 = self then
        Result := 'COLOR_ATTACHMENT4' else
      if COLOR_ATTACHMENT5 = self then
        Result := 'COLOR_ATTACHMENT5' else
      if COLOR_ATTACHMENT6 = self then
        Result := 'COLOR_ATTACHMENT6' else
      if COLOR_ATTACHMENT7 = self then
        Result := 'COLOR_ATTACHMENT7' else
      if COLOR_ATTACHMENT8 = self then
        Result := 'COLOR_ATTACHMENT8' else
      if COLOR_ATTACHMENT9 = self then
        Result := 'COLOR_ATTACHMENT9' else
      if COLOR_ATTACHMENT10 = self then
        Result := 'COLOR_ATTACHMENT10' else
      if COLOR_ATTACHMENT11 = self then
        Result := 'COLOR_ATTACHMENT11' else
      if COLOR_ATTACHMENT12 = self then
        Result := 'COLOR_ATTACHMENT12' else
      if COLOR_ATTACHMENT13 = self then
        Result := 'COLOR_ATTACHMENT13' else
      if COLOR_ATTACHMENT14 = self then
        Result := 'COLOR_ATTACHMENT14' else
      if COLOR_ATTACHMENT15 = self then
        Result := 'COLOR_ATTACHMENT15' else
        Result := $'glReadBufferMode[{self.val}]';
    end;
    
  end;
  
  glRenderbufferParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RENDERBUFFER_COVERAGE_SAMPLES: glRenderbufferParameterName read new glRenderbufferParameterName($8CAB);
    public static property RENDERBUFFER_SAMPLES:          glRenderbufferParameterName read new glRenderbufferParameterName($8CAB);
    public static property RENDERBUFFER_WIDTH:            glRenderbufferParameterName read new glRenderbufferParameterName($8D42);
    public static property RENDERBUFFER_HEIGHT:           glRenderbufferParameterName read new glRenderbufferParameterName($8D43);
    public static property RENDERBUFFER_INTERNAL_FORMAT:  glRenderbufferParameterName read new glRenderbufferParameterName($8D44);
    public static property RENDERBUFFER_RED_SIZE:         glRenderbufferParameterName read new glRenderbufferParameterName($8D50);
    public static property RENDERBUFFER_GREEN_SIZE:       glRenderbufferParameterName read new glRenderbufferParameterName($8D51);
    public static property RENDERBUFFER_BLUE_SIZE:        glRenderbufferParameterName read new glRenderbufferParameterName($8D52);
    public static property RENDERBUFFER_ALPHA_SIZE:       glRenderbufferParameterName read new glRenderbufferParameterName($8D53);
    public static property RENDERBUFFER_DEPTH_SIZE:       glRenderbufferParameterName read new glRenderbufferParameterName($8D54);
    public static property RENDERBUFFER_STENCIL_SIZE:     glRenderbufferParameterName read new glRenderbufferParameterName($8D55);
    public static property RENDERBUFFER_COLOR_SAMPLES:    glRenderbufferParameterName read new glRenderbufferParameterName($8E10);
    public static property RENDERBUFFER_SAMPLES_IMG:      glRenderbufferParameterName read new glRenderbufferParameterName($9133);
    public static property RENDERBUFFER_STORAGE_SAMPLES:  glRenderbufferParameterName read new glRenderbufferParameterName($91B2);
    
    public function ToString: string; override;
    begin
      if RENDERBUFFER_COVERAGE_SAMPLES = self then
        Result := 'RENDERBUFFER_COVERAGE_SAMPLES' else
      if RENDERBUFFER_SAMPLES = self then
        Result := 'RENDERBUFFER_SAMPLES' else
      if RENDERBUFFER_WIDTH = self then
        Result := 'RENDERBUFFER_WIDTH' else
      if RENDERBUFFER_HEIGHT = self then
        Result := 'RENDERBUFFER_HEIGHT' else
      if RENDERBUFFER_INTERNAL_FORMAT = self then
        Result := 'RENDERBUFFER_INTERNAL_FORMAT' else
      if RENDERBUFFER_RED_SIZE = self then
        Result := 'RENDERBUFFER_RED_SIZE' else
      if RENDERBUFFER_GREEN_SIZE = self then
        Result := 'RENDERBUFFER_GREEN_SIZE' else
      if RENDERBUFFER_BLUE_SIZE = self then
        Result := 'RENDERBUFFER_BLUE_SIZE' else
      if RENDERBUFFER_ALPHA_SIZE = self then
        Result := 'RENDERBUFFER_ALPHA_SIZE' else
      if RENDERBUFFER_DEPTH_SIZE = self then
        Result := 'RENDERBUFFER_DEPTH_SIZE' else
      if RENDERBUFFER_STENCIL_SIZE = self then
        Result := 'RENDERBUFFER_STENCIL_SIZE' else
      if RENDERBUFFER_COLOR_SAMPLES = self then
        Result := 'RENDERBUFFER_COLOR_SAMPLES' else
      if RENDERBUFFER_SAMPLES_IMG = self then
        Result := 'RENDERBUFFER_SAMPLES_IMG' else
      if RENDERBUFFER_STORAGE_SAMPLES = self then
        Result := 'RENDERBUFFER_STORAGE_SAMPLES' else
        Result := $'glRenderbufferParameterName[{self.val}]';
    end;
    
  end;
  
  glRenderbufferTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RENDERBUFFER: glRenderbufferTarget read new glRenderbufferTarget($8D41);
    
    public function ToString: string; override;
    begin
      if RENDERBUFFER = self then
        Result := 'RENDERBUFFER' else
        Result := $'glRenderbufferTarget[{self.val}]';
    end;
    
  end;
  
  glRenderingMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RENDER:   glRenderingMode read new glRenderingMode($1C00);
    public static property FEEDBACK: glRenderingMode read new glRenderingMode($1C01);
    public static property SELECT:   glRenderingMode read new glRenderingMode($1C02);
    
    public function ToString: string; override;
    begin
      if RENDER = self then
        Result := 'RENDER' else
      if FEEDBACK = self then
        Result := 'FEEDBACK' else
      if SELECT = self then
        Result := 'SELECT' else
        Result := $'glRenderingMode[{self.val}]';
    end;
    
  end;
  
  glReplacementCodeType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNSIGNED_BYTE:  glReplacementCodeType read new glReplacementCodeType($1401);
    public static property UNSIGNED_SHORT: glReplacementCodeType read new glReplacementCodeType($1403);
    public static property UNSIGNED_INT:   glReplacementCodeType read new glReplacementCodeType($1405);
    
    public function ToString: string; override;
    begin
      if UNSIGNED_BYTE = self then
        Result := 'UNSIGNED_BYTE' else
      if UNSIGNED_SHORT = self then
        Result := 'UNSIGNED_SHORT' else
      if UNSIGNED_INT = self then
        Result := 'UNSIGNED_INT' else
        Result := $'glReplacementCodeType[{self.val}]';
    end;
    
  end;
  
  glSamplePattern = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property _1PASS:   glSamplePattern read new glSamplePattern($80A1);
    public static property _2PASS_0: glSamplePattern read new glSamplePattern($80A2);
    public static property _2PASS_1: glSamplePattern read new glSamplePattern($80A3);
    public static property _4PASS_0: glSamplePattern read new glSamplePattern($80A4);
    public static property _4PASS_1: glSamplePattern read new glSamplePattern($80A5);
    public static property _4PASS_2: glSamplePattern read new glSamplePattern($80A6);
    public static property _4PASS_3: glSamplePattern read new glSamplePattern($80A7);
    
    public function ToString: string; override;
    begin
      if _1PASS = self then
        Result := '1PASS' else
      if _2PASS_0 = self then
        Result := '2PASS_0' else
      if _2PASS_1 = self then
        Result := '2PASS_1' else
      if _4PASS_0 = self then
        Result := '4PASS_0' else
      if _4PASS_1 = self then
        Result := '4PASS_1' else
      if _4PASS_2 = self then
        Result := '4PASS_2' else
      if _4PASS_3 = self then
        Result := '4PASS_3' else
        Result := $'glSamplePattern[{self.val}]';
    end;
    
  end;
  
  glSamplerParameterF = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_BORDER_COLOR:             glSamplerParameterF read new glSamplerParameterF($1004);
    public static property TEXTURE_MIN_LOD:                  glSamplerParameterF read new glSamplerParameterF($813A);
    public static property TEXTURE_MAX_LOD:                  glSamplerParameterF read new glSamplerParameterF($813B);
    public static property TEXTURE_MAX_ANISOTROPY:           glSamplerParameterF read new glSamplerParameterF($84FE);
    public static property TEXTURE_LOD_BIAS:                 glSamplerParameterF read new glSamplerParameterF($8501);
    public static property TEXTURE_UNNORMALIZED_COORDINATES: glSamplerParameterF read new glSamplerParameterF($8F6A);
    
    public function ToString: string; override;
    begin
      if TEXTURE_BORDER_COLOR = self then
        Result := 'TEXTURE_BORDER_COLOR' else
      if TEXTURE_MIN_LOD = self then
        Result := 'TEXTURE_MIN_LOD' else
      if TEXTURE_MAX_LOD = self then
        Result := 'TEXTURE_MAX_LOD' else
      if TEXTURE_MAX_ANISOTROPY = self then
        Result := 'TEXTURE_MAX_ANISOTROPY' else
      if TEXTURE_LOD_BIAS = self then
        Result := 'TEXTURE_LOD_BIAS' else
      if TEXTURE_UNNORMALIZED_COORDINATES = self then
        Result := 'TEXTURE_UNNORMALIZED_COORDINATES' else
        Result := $'glSamplerParameterF[{self.val}]';
    end;
    
  end;
  
  glSamplerParameterI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_MAG_FILTER:               glSamplerParameterI read new glSamplerParameterI($2800);
    public static property TEXTURE_MIN_FILTER:               glSamplerParameterI read new glSamplerParameterI($2801);
    public static property TEXTURE_WRAP_S:                   glSamplerParameterI read new glSamplerParameterI($2802);
    public static property TEXTURE_WRAP_T:                   glSamplerParameterI read new glSamplerParameterI($2803);
    public static property TEXTURE_WRAP_R:                   glSamplerParameterI read new glSamplerParameterI($8072);
    public static property TEXTURE_COMPARE_MODE:             glSamplerParameterI read new glSamplerParameterI($884C);
    public static property TEXTURE_COMPARE_FUNC:             glSamplerParameterI read new glSamplerParameterI($884D);
    public static property TEXTURE_UNNORMALIZED_COORDINATES: glSamplerParameterI read new glSamplerParameterI($8F6A);
    
    public function ToString: string; override;
    begin
      if TEXTURE_MAG_FILTER = self then
        Result := 'TEXTURE_MAG_FILTER' else
      if TEXTURE_MIN_FILTER = self then
        Result := 'TEXTURE_MIN_FILTER' else
      if TEXTURE_WRAP_S = self then
        Result := 'TEXTURE_WRAP_S' else
      if TEXTURE_WRAP_T = self then
        Result := 'TEXTURE_WRAP_T' else
      if TEXTURE_WRAP_R = self then
        Result := 'TEXTURE_WRAP_R' else
      if TEXTURE_COMPARE_MODE = self then
        Result := 'TEXTURE_COMPARE_MODE' else
      if TEXTURE_COMPARE_FUNC = self then
        Result := 'TEXTURE_COMPARE_FUNC' else
      if TEXTURE_UNNORMALIZED_COORDINATES = self then
        Result := 'TEXTURE_UNNORMALIZED_COORDINATES' else
        Result := $'glSamplerParameterI[{self.val}]';
    end;
    
  end;
  
  glScalarType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNSIGNED_BYTE:  glScalarType read new glScalarType($1401);
    public static property UNSIGNED_SHORT: glScalarType read new glScalarType($1403);
    public static property UNSIGNED_INT:   glScalarType read new glScalarType($1405);
    
    public function ToString: string; override;
    begin
      if UNSIGNED_BYTE = self then
        Result := 'UNSIGNED_BYTE' else
      if UNSIGNED_SHORT = self then
        Result := 'UNSIGNED_SHORT' else
      if UNSIGNED_INT = self then
        Result := 'UNSIGNED_INT' else
        Result := $'glScalarType[{self.val}]';
    end;
    
  end;
  
  glSecondaryColorPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SHORT:  glSecondaryColorPointerType read new glSecondaryColorPointerType($1402);
    public static property INT:    glSecondaryColorPointerType read new glSecondaryColorPointerType($1404);
    public static property FLOAT:  glSecondaryColorPointerType read new glSecondaryColorPointerType($1406);
    public static property DOUBLE: glSecondaryColorPointerType read new glSecondaryColorPointerType($140A);
    
    public function ToString: string; override;
    begin
      if SHORT = self then
        Result := 'SHORT' else
      if INT = self then
        Result := 'INT' else
      if FLOAT = self then
        Result := 'FLOAT' else
      if DOUBLE = self then
        Result := 'DOUBLE' else
        Result := $'glSecondaryColorPointerType[{self.val}]';
    end;
    
  end;
  
  glSemaphoreParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property D3D12_FENCE_VALUE:        glSemaphoreParameterName read new glSemaphoreParameterName($9595);
    public static property TIMELINE_SEMAPHORE_VALUE: glSemaphoreParameterName read new glSemaphoreParameterName($9595);
    public static property SEMAPHORE_TYPE:           glSemaphoreParameterName read new glSemaphoreParameterName($95B3);
    public static property SEMAPHORE_TYPE_BINARY:    glSemaphoreParameterName read new glSemaphoreParameterName($95B4);
    public static property SEMAPHORE_TYPE_TIMELINE:  glSemaphoreParameterName read new glSemaphoreParameterName($95B5);
    
    public function ToString: string; override;
    begin
      if D3D12_FENCE_VALUE = self then
        Result := 'D3D12_FENCE_VALUE' else
      if TIMELINE_SEMAPHORE_VALUE = self then
        Result := 'TIMELINE_SEMAPHORE_VALUE' else
      if SEMAPHORE_TYPE = self then
        Result := 'SEMAPHORE_TYPE' else
      if SEMAPHORE_TYPE_BINARY = self then
        Result := 'SEMAPHORE_TYPE_BINARY' else
      if SEMAPHORE_TYPE_TIMELINE = self then
        Result := 'SEMAPHORE_TYPE_TIMELINE' else
        Result := $'glSemaphoreParameterName[{self.val}]';
    end;
    
  end;
  
  glSeparableTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SEPARABLE_2D: glSeparableTarget read new glSeparableTarget($8012);
    
    public function ToString: string; override;
    begin
      if SEPARABLE_2D = self then
        Result := 'SEPARABLE_2D' else
        Result := $'glSeparableTarget[{self.val}]';
    end;
    
  end;
  
  glShaderBinaryFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SGX_BINARY:                  glShaderBinaryFormat read new glShaderBinaryFormat($8C0A);
    public static property MALI_SHADER_BINARY:          glShaderBinaryFormat read new glShaderBinaryFormat($8F60);
    public static property SHADER_BINARY_VIV:           glShaderBinaryFormat read new glShaderBinaryFormat($8FC4);
    public static property SHADER_BINARY_DMP:           glShaderBinaryFormat read new glShaderBinaryFormat($9250);
    public static property GCCSO_SHADER_BINARY_FJ:      glShaderBinaryFormat read new glShaderBinaryFormat($9260);
    public static property SHADER_BINARY_FORMAT_SPIR_V: glShaderBinaryFormat read new glShaderBinaryFormat($9551);
    
    public function ToString: string; override;
    begin
      if SGX_BINARY = self then
        Result := 'SGX_BINARY' else
      if MALI_SHADER_BINARY = self then
        Result := 'MALI_SHADER_BINARY' else
      if SHADER_BINARY_VIV = self then
        Result := 'SHADER_BINARY_VIV' else
      if SHADER_BINARY_DMP = self then
        Result := 'SHADER_BINARY_DMP' else
      if GCCSO_SHADER_BINARY_FJ = self then
        Result := 'GCCSO_SHADER_BINARY_FJ' else
      if SHADER_BINARY_FORMAT_SPIR_V = self then
        Result := 'SHADER_BINARY_FORMAT_SPIR_V' else
        Result := $'glShaderBinaryFormat[{self.val}]';
    end;
    
  end;
  
  glShaderParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SHADER_TYPE:          glShaderParameterName read new glShaderParameterName($8B4F);
    public static property DELETE_STATUS:        glShaderParameterName read new glShaderParameterName($8B80);
    public static property COMPILE_STATUS:       glShaderParameterName read new glShaderParameterName($8B81);
    public static property INFO_LOG_LENGTH:      glShaderParameterName read new glShaderParameterName($8B84);
    public static property SHADER_SOURCE_LENGTH: glShaderParameterName read new glShaderParameterName($8B88);
    
    public function ToString: string; override;
    begin
      if SHADER_TYPE = self then
        Result := 'SHADER_TYPE' else
      if DELETE_STATUS = self then
        Result := 'DELETE_STATUS' else
      if COMPILE_STATUS = self then
        Result := 'COMPILE_STATUS' else
      if INFO_LOG_LENGTH = self then
        Result := 'INFO_LOG_LENGTH' else
      if SHADER_SOURCE_LENGTH = self then
        Result := 'SHADER_SOURCE_LENGTH' else
        Result := $'glShaderParameterName[{self.val}]';
    end;
    
  end;
  
  glShaderType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRAGMENT_SHADER:        glShaderType read new glShaderType($8B30);
    public static property VERTEX_SHADER:          glShaderType read new glShaderType($8B31);
    public static property GEOMETRY_SHADER:        glShaderType read new glShaderType($8DD9);
    public static property TESS_EVALUATION_SHADER: glShaderType read new glShaderType($8E87);
    public static property TESS_CONTROL_SHADER:    glShaderType read new glShaderType($8E88);
    public static property COMPUTE_SHADER:         glShaderType read new glShaderType($91B9);
    
    public function ToString: string; override;
    begin
      if FRAGMENT_SHADER = self then
        Result := 'FRAGMENT_SHADER' else
      if VERTEX_SHADER = self then
        Result := 'VERTEX_SHADER' else
      if GEOMETRY_SHADER = self then
        Result := 'GEOMETRY_SHADER' else
      if TESS_EVALUATION_SHADER = self then
        Result := 'TESS_EVALUATION_SHADER' else
      if TESS_CONTROL_SHADER = self then
        Result := 'TESS_CONTROL_SHADER' else
      if COMPUTE_SHADER = self then
        Result := 'COMPUTE_SHADER' else
        Result := $'glShaderType[{self.val}]';
    end;
    
  end;
  
  glShadingModel = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FLAT:   glShadingModel read new glShadingModel($1D00);
    public static property SMOOTH: glShadingModel read new glShadingModel($1D01);
    
    public function ToString: string; override;
    begin
      if FLAT = self then
        Result := 'FLAT' else
      if SMOOTH = self then
        Result := 'SMOOTH' else
        Result := $'glShadingModel[{self.val}]';
    end;
    
  end;
  
  glSizedInternalFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property R3_G3_B2:                                  glSizedInternalFormat read new glSizedInternalFormat($2A10);
    public static property ALPHA4:                                    glSizedInternalFormat read new glSizedInternalFormat($803B);
    public static property ALPHA8:                                    glSizedInternalFormat read new glSizedInternalFormat($803C);
    public static property ALPHA12:                                   glSizedInternalFormat read new glSizedInternalFormat($803D);
    public static property ALPHA16:                                   glSizedInternalFormat read new glSizedInternalFormat($803E);
    public static property LUMINANCE4:                                glSizedInternalFormat read new glSizedInternalFormat($803F);
    public static property LUMINANCE8:                                glSizedInternalFormat read new glSizedInternalFormat($8040);
    public static property LUMINANCE12:                               glSizedInternalFormat read new glSizedInternalFormat($8041);
    public static property LUMINANCE16:                               glSizedInternalFormat read new glSizedInternalFormat($8042);
    public static property LUMINANCE4_ALPHA4:                         glSizedInternalFormat read new glSizedInternalFormat($8043);
    public static property LUMINANCE6_ALPHA2:                         glSizedInternalFormat read new glSizedInternalFormat($8044);
    public static property LUMINANCE8_ALPHA8:                         glSizedInternalFormat read new glSizedInternalFormat($8045);
    public static property LUMINANCE12_ALPHA4:                        glSizedInternalFormat read new glSizedInternalFormat($8046);
    public static property LUMINANCE12_ALPHA12:                       glSizedInternalFormat read new glSizedInternalFormat($8047);
    public static property LUMINANCE16_ALPHA16:                       glSizedInternalFormat read new glSizedInternalFormat($8048);
    public static property INTENSITY4:                                glSizedInternalFormat read new glSizedInternalFormat($804A);
    public static property INTENSITY8:                                glSizedInternalFormat read new glSizedInternalFormat($804B);
    public static property INTENSITY12:                               glSizedInternalFormat read new glSizedInternalFormat($804C);
    public static property INTENSITY16:                               glSizedInternalFormat read new glSizedInternalFormat($804D);
    public static property RGB2:                                      glSizedInternalFormat read new glSizedInternalFormat($804E);
    public static property RGB4:                                      glSizedInternalFormat read new glSizedInternalFormat($804F);
    public static property RGB5:                                      glSizedInternalFormat read new glSizedInternalFormat($8050);
    public static property RGB8:                                      glSizedInternalFormat read new glSizedInternalFormat($8051);
    public static property RGB10:                                     glSizedInternalFormat read new glSizedInternalFormat($8052);
    public static property RGB12:                                     glSizedInternalFormat read new glSizedInternalFormat($8053);
    public static property RGB16:                                     glSizedInternalFormat read new glSizedInternalFormat($8054);
    public static property RGBA2:                                     glSizedInternalFormat read new glSizedInternalFormat($8055);
    public static property RGBA4:                                     glSizedInternalFormat read new glSizedInternalFormat($8056);
    public static property RGB5_A1:                                   glSizedInternalFormat read new glSizedInternalFormat($8057);
    public static property RGBA8:                                     glSizedInternalFormat read new glSizedInternalFormat($8058);
    public static property RGB10_A2:                                  glSizedInternalFormat read new glSizedInternalFormat($8059);
    public static property RGBA12:                                    glSizedInternalFormat read new glSizedInternalFormat($805A);
    public static property RGBA16:                                    glSizedInternalFormat read new glSizedInternalFormat($805B);
    public static property DEPTH_COMPONENT16:                         glSizedInternalFormat read new glSizedInternalFormat($81A5);
    public static property DEPTH_COMPONENT24:                         glSizedInternalFormat read new glSizedInternalFormat($81A6);
    public static property DEPTH_COMPONENT32:                         glSizedInternalFormat read new glSizedInternalFormat($81A7);
    public static property R8:                                        glSizedInternalFormat read new glSizedInternalFormat($8229);
    public static property R16:                                       glSizedInternalFormat read new glSizedInternalFormat($822A);
    public static property RG8:                                       glSizedInternalFormat read new glSizedInternalFormat($822B);
    public static property RG16:                                      glSizedInternalFormat read new glSizedInternalFormat($822C);
    public static property R16F:                                      glSizedInternalFormat read new glSizedInternalFormat($822D);
    public static property R32F:                                      glSizedInternalFormat read new glSizedInternalFormat($822E);
    public static property RG16F:                                     glSizedInternalFormat read new glSizedInternalFormat($822F);
    public static property RG32F:                                     glSizedInternalFormat read new glSizedInternalFormat($8230);
    public static property R8I:                                       glSizedInternalFormat read new glSizedInternalFormat($8231);
    public static property R8UI:                                      glSizedInternalFormat read new glSizedInternalFormat($8232);
    public static property R16I:                                      glSizedInternalFormat read new glSizedInternalFormat($8233);
    public static property R16UI:                                     glSizedInternalFormat read new glSizedInternalFormat($8234);
    public static property R32I:                                      glSizedInternalFormat read new glSizedInternalFormat($8235);
    public static property R32UI:                                     glSizedInternalFormat read new glSizedInternalFormat($8236);
    public static property RG8I:                                      glSizedInternalFormat read new glSizedInternalFormat($8237);
    public static property RG8UI:                                     glSizedInternalFormat read new glSizedInternalFormat($8238);
    public static property RG16I:                                     glSizedInternalFormat read new glSizedInternalFormat($8239);
    public static property RG16UI:                                    glSizedInternalFormat read new glSizedInternalFormat($823A);
    public static property RG32I:                                     glSizedInternalFormat read new glSizedInternalFormat($823B);
    public static property RG32UI:                                    glSizedInternalFormat read new glSizedInternalFormat($823C);
    public static property COMPRESSED_RGB_S3TC_DXT1:                  glSizedInternalFormat read new glSizedInternalFormat($83F0);
    public static property COMPRESSED_RGBA_S3TC_DXT1:                 glSizedInternalFormat read new glSizedInternalFormat($83F1);
    public static property COMPRESSED_RGBA_S3TC_DXT3:                 glSizedInternalFormat read new glSizedInternalFormat($83F2);
    public static property COMPRESSED_RGBA_S3TC_DXT5:                 glSizedInternalFormat read new glSizedInternalFormat($83F3);
    public static property RGBA32F:                                   glSizedInternalFormat read new glSizedInternalFormat($8814);
    public static property RGB32F:                                    glSizedInternalFormat read new glSizedInternalFormat($8815);
    public static property RGBA16F:                                   glSizedInternalFormat read new glSizedInternalFormat($881A);
    public static property RGB16F:                                    glSizedInternalFormat read new glSizedInternalFormat($881B);
    public static property DEPTH24_STENCIL8:                          glSizedInternalFormat read new glSizedInternalFormat($88F0);
    public static property R11F_G11F_B10F:                            glSizedInternalFormat read new glSizedInternalFormat($8C3A);
    public static property RGB9_E5:                                   glSizedInternalFormat read new glSizedInternalFormat($8C3D);
    public static property SRGB8:                                     glSizedInternalFormat read new glSizedInternalFormat($8C41);
    public static property SRGB8_ALPHA8:                              glSizedInternalFormat read new glSizedInternalFormat($8C43);
    public static property COMPRESSED_SRGB_S3TC_DXT1:                 glSizedInternalFormat read new glSizedInternalFormat($8C4C);
    public static property COMPRESSED_SRGB_ALPHA_S3TC_DXT1:           glSizedInternalFormat read new glSizedInternalFormat($8C4D);
    public static property COMPRESSED_SRGB_ALPHA_S3TC_DXT3:           glSizedInternalFormat read new glSizedInternalFormat($8C4E);
    public static property COMPRESSED_SRGB_ALPHA_S3TC_DXT5:           glSizedInternalFormat read new glSizedInternalFormat($8C4F);
    public static property DEPTH_COMPONENT32F:                        glSizedInternalFormat read new glSizedInternalFormat($8CAC);
    public static property DEPTH32F_STENCIL8:                         glSizedInternalFormat read new glSizedInternalFormat($8CAD);
    public static property STENCIL_INDEX1:                            glSizedInternalFormat read new glSizedInternalFormat($8D46);
    public static property STENCIL_INDEX4:                            glSizedInternalFormat read new glSizedInternalFormat($8D47);
    public static property STENCIL_INDEX8:                            glSizedInternalFormat read new glSizedInternalFormat($8D48);
    public static property STENCIL_INDEX16:                           glSizedInternalFormat read new glSizedInternalFormat($8D49);
    public static property RGB565:                                    glSizedInternalFormat read new glSizedInternalFormat($8D62);
    public static property ETC1_RGB8:                                 glSizedInternalFormat read new glSizedInternalFormat($8D64);
    public static property RGBA32UI:                                  glSizedInternalFormat read new glSizedInternalFormat($8D70);
    public static property RGB32UI:                                   glSizedInternalFormat read new glSizedInternalFormat($8D71);
    public static property ALPHA32UI:                                 glSizedInternalFormat read new glSizedInternalFormat($8D72);
    public static property INTENSITY32UI:                             glSizedInternalFormat read new glSizedInternalFormat($8D73);
    public static property LUMINANCE32UI:                             glSizedInternalFormat read new glSizedInternalFormat($8D74);
    public static property LUMINANCE_ALPHA32UI:                       glSizedInternalFormat read new glSizedInternalFormat($8D75);
    public static property RGBA16UI:                                  glSizedInternalFormat read new glSizedInternalFormat($8D76);
    public static property RGB16UI:                                   glSizedInternalFormat read new glSizedInternalFormat($8D77);
    public static property ALPHA16UI:                                 glSizedInternalFormat read new glSizedInternalFormat($8D78);
    public static property INTENSITY16UI:                             glSizedInternalFormat read new glSizedInternalFormat($8D79);
    public static property LUMINANCE16UI:                             glSizedInternalFormat read new glSizedInternalFormat($8D7A);
    public static property LUMINANCE_ALPHA16UI:                       glSizedInternalFormat read new glSizedInternalFormat($8D7B);
    public static property RGBA8UI:                                   glSizedInternalFormat read new glSizedInternalFormat($8D7C);
    public static property RGB8UI:                                    glSizedInternalFormat read new glSizedInternalFormat($8D7D);
    public static property ALPHA8UI:                                  glSizedInternalFormat read new glSizedInternalFormat($8D7E);
    public static property INTENSITY8UI:                              glSizedInternalFormat read new glSizedInternalFormat($8D7F);
    public static property LUMINANCE8UI:                              glSizedInternalFormat read new glSizedInternalFormat($8D80);
    public static property LUMINANCE_ALPHA8UI:                        glSizedInternalFormat read new glSizedInternalFormat($8D81);
    public static property RGBA32I:                                   glSizedInternalFormat read new glSizedInternalFormat($8D82);
    public static property RGB32I:                                    glSizedInternalFormat read new glSizedInternalFormat($8D83);
    public static property ALPHA32I:                                  glSizedInternalFormat read new glSizedInternalFormat($8D84);
    public static property INTENSITY32I:                              glSizedInternalFormat read new glSizedInternalFormat($8D85);
    public static property LUMINANCE32I:                              glSizedInternalFormat read new glSizedInternalFormat($8D86);
    public static property LUMINANCE_ALPHA32I:                        glSizedInternalFormat read new glSizedInternalFormat($8D87);
    public static property RGBA16I:                                   glSizedInternalFormat read new glSizedInternalFormat($8D88);
    public static property RGB16I:                                    glSizedInternalFormat read new glSizedInternalFormat($8D89);
    public static property ALPHA16I:                                  glSizedInternalFormat read new glSizedInternalFormat($8D8A);
    public static property INTENSITY16I:                              glSizedInternalFormat read new glSizedInternalFormat($8D8B);
    public static property LUMINANCE16I:                              glSizedInternalFormat read new glSizedInternalFormat($8D8C);
    public static property LUMINANCE_ALPHA16I:                        glSizedInternalFormat read new glSizedInternalFormat($8D8D);
    public static property RGBA8I:                                    glSizedInternalFormat read new glSizedInternalFormat($8D8E);
    public static property RGB8I:                                     glSizedInternalFormat read new glSizedInternalFormat($8D8F);
    public static property ALPHA8I:                                   glSizedInternalFormat read new glSizedInternalFormat($8D90);
    public static property INTENSITY8I:                               glSizedInternalFormat read new glSizedInternalFormat($8D91);
    public static property LUMINANCE8I:                               glSizedInternalFormat read new glSizedInternalFormat($8D92);
    public static property LUMINANCE_ALPHA8I:                         glSizedInternalFormat read new glSizedInternalFormat($8D93);
    public static property DEPTH_COMPONENT32F_NV:                     glSizedInternalFormat read new glSizedInternalFormat($8DAB);
    public static property DEPTH32F_STENCIL8_NV:                      glSizedInternalFormat read new glSizedInternalFormat($8DAC);
    public static property COMPRESSED_RED_RGTC1:                      glSizedInternalFormat read new glSizedInternalFormat($8DBB);
    public static property COMPRESSED_SIGNED_RED_RGTC1:               glSizedInternalFormat read new glSizedInternalFormat($8DBC);
    public static property COMPRESSED_RED_GREEN_RGTC2:                glSizedInternalFormat read new glSizedInternalFormat($8DBD);
    public static property COMPRESSED_RG_RGTC2:                       glSizedInternalFormat read new glSizedInternalFormat($8DBD);
    public static property COMPRESSED_SIGNED_RED_GREEN_RGTC2:         glSizedInternalFormat read new glSizedInternalFormat($8DBE);
    public static property COMPRESSED_SIGNED_RG_RGTC2:                glSizedInternalFormat read new glSizedInternalFormat($8DBE);
    public static property COMPRESSED_RGBA_BPTC_UNORM:                glSizedInternalFormat read new glSizedInternalFormat($8E8C);
    public static property COMPRESSED_SRGB_ALPHA_BPTC_UNORM:          glSizedInternalFormat read new glSizedInternalFormat($8E8D);
    public static property COMPRESSED_RGB_BPTC_SIGNED_FLOAT:          glSizedInternalFormat read new glSizedInternalFormat($8E8E);
    public static property COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:        glSizedInternalFormat read new glSizedInternalFormat($8E8F);
    public static property R8_SNORM:                                  glSizedInternalFormat read new glSizedInternalFormat($8F94);
    public static property RG8_SNORM:                                 glSizedInternalFormat read new glSizedInternalFormat($8F95);
    public static property RGB8_SNORM:                                glSizedInternalFormat read new glSizedInternalFormat($8F96);
    public static property RGBA8_SNORM:                               glSizedInternalFormat read new glSizedInternalFormat($8F97);
    public static property R16_SNORM:                                 glSizedInternalFormat read new glSizedInternalFormat($8F98);
    public static property RG16_SNORM:                                glSizedInternalFormat read new glSizedInternalFormat($8F99);
    public static property RGB16_SNORM:                               glSizedInternalFormat read new glSizedInternalFormat($8F9A);
    public static property RGBA16_SNORM:                              glSizedInternalFormat read new glSizedInternalFormat($8F9B);
    public static property RGB10_A2UI:                                glSizedInternalFormat read new glSizedInternalFormat($906F);
    public static property COMPRESSED_R11_EAC:                        glSizedInternalFormat read new glSizedInternalFormat($9270);
    public static property COMPRESSED_SIGNED_R11_EAC:                 glSizedInternalFormat read new glSizedInternalFormat($9271);
    public static property COMPRESSED_RG11_EAC:                       glSizedInternalFormat read new glSizedInternalFormat($9272);
    public static property COMPRESSED_SIGNED_RG11_EAC:                glSizedInternalFormat read new glSizedInternalFormat($9273);
    public static property COMPRESSED_RGB8_ETC2:                      glSizedInternalFormat read new glSizedInternalFormat($9274);
    public static property COMPRESSED_SRGB8_ETC2:                     glSizedInternalFormat read new glSizedInternalFormat($9275);
    public static property COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:  glSizedInternalFormat read new glSizedInternalFormat($9276);
    public static property COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: glSizedInternalFormat read new glSizedInternalFormat($9277);
    public static property COMPRESSED_RGBA8_ETC2_EAC:                 glSizedInternalFormat read new glSizedInternalFormat($9278);
    public static property COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:          glSizedInternalFormat read new glSizedInternalFormat($9279);
    public static property COMPRESSED_RGBA_ASTC_4x4:                  glSizedInternalFormat read new glSizedInternalFormat($93B0);
    public static property COMPRESSED_RGBA_ASTC_5x4:                  glSizedInternalFormat read new glSizedInternalFormat($93B1);
    public static property COMPRESSED_RGBA_ASTC_5x5:                  glSizedInternalFormat read new glSizedInternalFormat($93B2);
    public static property COMPRESSED_RGBA_ASTC_6x5:                  glSizedInternalFormat read new glSizedInternalFormat($93B3);
    public static property COMPRESSED_RGBA_ASTC_6x6:                  glSizedInternalFormat read new glSizedInternalFormat($93B4);
    public static property COMPRESSED_RGBA_ASTC_8x5:                  glSizedInternalFormat read new glSizedInternalFormat($93B5);
    public static property COMPRESSED_RGBA_ASTC_8x6:                  glSizedInternalFormat read new glSizedInternalFormat($93B6);
    public static property COMPRESSED_RGBA_ASTC_8x8:                  glSizedInternalFormat read new glSizedInternalFormat($93B7);
    public static property COMPRESSED_RGBA_ASTC_10x5:                 glSizedInternalFormat read new glSizedInternalFormat($93B8);
    public static property COMPRESSED_RGBA_ASTC_10x6:                 glSizedInternalFormat read new glSizedInternalFormat($93B9);
    public static property COMPRESSED_RGBA_ASTC_10x8:                 glSizedInternalFormat read new glSizedInternalFormat($93BA);
    public static property COMPRESSED_RGBA_ASTC_10x10:                glSizedInternalFormat read new glSizedInternalFormat($93BB);
    public static property COMPRESSED_RGBA_ASTC_12x10:                glSizedInternalFormat read new glSizedInternalFormat($93BC);
    public static property COMPRESSED_RGBA_ASTC_12x12:                glSizedInternalFormat read new glSizedInternalFormat($93BD);
    public static property COMPRESSED_RGBA_ASTC_3x3x3:                glSizedInternalFormat read new glSizedInternalFormat($93C0);
    public static property COMPRESSED_RGBA_ASTC_4x3x3:                glSizedInternalFormat read new glSizedInternalFormat($93C1);
    public static property COMPRESSED_RGBA_ASTC_4x4x3:                glSizedInternalFormat read new glSizedInternalFormat($93C2);
    public static property COMPRESSED_RGBA_ASTC_4x4x4:                glSizedInternalFormat read new glSizedInternalFormat($93C3);
    public static property COMPRESSED_RGBA_ASTC_5x4x4:                glSizedInternalFormat read new glSizedInternalFormat($93C4);
    public static property COMPRESSED_RGBA_ASTC_5x5x4:                glSizedInternalFormat read new glSizedInternalFormat($93C5);
    public static property COMPRESSED_RGBA_ASTC_5x5x5:                glSizedInternalFormat read new glSizedInternalFormat($93C6);
    public static property COMPRESSED_RGBA_ASTC_6x5x5:                glSizedInternalFormat read new glSizedInternalFormat($93C7);
    public static property COMPRESSED_RGBA_ASTC_6x6x5:                glSizedInternalFormat read new glSizedInternalFormat($93C8);
    public static property COMPRESSED_RGBA_ASTC_6x6x6:                glSizedInternalFormat read new glSizedInternalFormat($93C9);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x4:          glSizedInternalFormat read new glSizedInternalFormat($93D0);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x4:          glSizedInternalFormat read new glSizedInternalFormat($93D1);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x5:          glSizedInternalFormat read new glSizedInternalFormat($93D2);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x5:          glSizedInternalFormat read new glSizedInternalFormat($93D3);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x6:          glSizedInternalFormat read new glSizedInternalFormat($93D4);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x5:          glSizedInternalFormat read new glSizedInternalFormat($93D5);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x6:          glSizedInternalFormat read new glSizedInternalFormat($93D6);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x8:          glSizedInternalFormat read new glSizedInternalFormat($93D7);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x5:         glSizedInternalFormat read new glSizedInternalFormat($93D8);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x6:         glSizedInternalFormat read new glSizedInternalFormat($93D9);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x8:         glSizedInternalFormat read new glSizedInternalFormat($93DA);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x10:        glSizedInternalFormat read new glSizedInternalFormat($93DB);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_12x10:        glSizedInternalFormat read new glSizedInternalFormat($93DC);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_12x12:        glSizedInternalFormat read new glSizedInternalFormat($93DD);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3:        glSizedInternalFormat read new glSizedInternalFormat($93E0);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3:        glSizedInternalFormat read new glSizedInternalFormat($93E1);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3:        glSizedInternalFormat read new glSizedInternalFormat($93E2);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4:        glSizedInternalFormat read new glSizedInternalFormat($93E3);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4:        glSizedInternalFormat read new glSizedInternalFormat($93E4);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4:        glSizedInternalFormat read new glSizedInternalFormat($93E5);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5:        glSizedInternalFormat read new glSizedInternalFormat($93E6);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5:        glSizedInternalFormat read new glSizedInternalFormat($93E7);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5:        glSizedInternalFormat read new glSizedInternalFormat($93E8);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6:        glSizedInternalFormat read new glSizedInternalFormat($93E9);
    
    public function ToString: string; override;
    begin
      if R3_G3_B2 = self then
        Result := 'R3_G3_B2' else
      if ALPHA4 = self then
        Result := 'ALPHA4' else
      if ALPHA8 = self then
        Result := 'ALPHA8' else
      if ALPHA12 = self then
        Result := 'ALPHA12' else
      if ALPHA16 = self then
        Result := 'ALPHA16' else
      if LUMINANCE4 = self then
        Result := 'LUMINANCE4' else
      if LUMINANCE8 = self then
        Result := 'LUMINANCE8' else
      if LUMINANCE12 = self then
        Result := 'LUMINANCE12' else
      if LUMINANCE16 = self then
        Result := 'LUMINANCE16' else
      if LUMINANCE4_ALPHA4 = self then
        Result := 'LUMINANCE4_ALPHA4' else
      if LUMINANCE6_ALPHA2 = self then
        Result := 'LUMINANCE6_ALPHA2' else
      if LUMINANCE8_ALPHA8 = self then
        Result := 'LUMINANCE8_ALPHA8' else
      if LUMINANCE12_ALPHA4 = self then
        Result := 'LUMINANCE12_ALPHA4' else
      if LUMINANCE12_ALPHA12 = self then
        Result := 'LUMINANCE12_ALPHA12' else
      if LUMINANCE16_ALPHA16 = self then
        Result := 'LUMINANCE16_ALPHA16' else
      if INTENSITY4 = self then
        Result := 'INTENSITY4' else
      if INTENSITY8 = self then
        Result := 'INTENSITY8' else
      if INTENSITY12 = self then
        Result := 'INTENSITY12' else
      if INTENSITY16 = self then
        Result := 'INTENSITY16' else
      if RGB2 = self then
        Result := 'RGB2' else
      if RGB4 = self then
        Result := 'RGB4' else
      if RGB5 = self then
        Result := 'RGB5' else
      if RGB8 = self then
        Result := 'RGB8' else
      if RGB10 = self then
        Result := 'RGB10' else
      if RGB12 = self then
        Result := 'RGB12' else
      if RGB16 = self then
        Result := 'RGB16' else
      if RGBA2 = self then
        Result := 'RGBA2' else
      if RGBA4 = self then
        Result := 'RGBA4' else
      if RGB5_A1 = self then
        Result := 'RGB5_A1' else
      if RGBA8 = self then
        Result := 'RGBA8' else
      if RGB10_A2 = self then
        Result := 'RGB10_A2' else
      if RGBA12 = self then
        Result := 'RGBA12' else
      if RGBA16 = self then
        Result := 'RGBA16' else
      if DEPTH_COMPONENT16 = self then
        Result := 'DEPTH_COMPONENT16' else
      if DEPTH_COMPONENT24 = self then
        Result := 'DEPTH_COMPONENT24' else
      if DEPTH_COMPONENT32 = self then
        Result := 'DEPTH_COMPONENT32' else
      if R8 = self then
        Result := 'R8' else
      if R16 = self then
        Result := 'R16' else
      if RG8 = self then
        Result := 'RG8' else
      if RG16 = self then
        Result := 'RG16' else
      if R16F = self then
        Result := 'R16F' else
      if R32F = self then
        Result := 'R32F' else
      if RG16F = self then
        Result := 'RG16F' else
      if RG32F = self then
        Result := 'RG32F' else
      if R8I = self then
        Result := 'R8I' else
      if R8UI = self then
        Result := 'R8UI' else
      if R16I = self then
        Result := 'R16I' else
      if R16UI = self then
        Result := 'R16UI' else
      if R32I = self then
        Result := 'R32I' else
      if R32UI = self then
        Result := 'R32UI' else
      if RG8I = self then
        Result := 'RG8I' else
      if RG8UI = self then
        Result := 'RG8UI' else
      if RG16I = self then
        Result := 'RG16I' else
      if RG16UI = self then
        Result := 'RG16UI' else
      if RG32I = self then
        Result := 'RG32I' else
      if RG32UI = self then
        Result := 'RG32UI' else
      if COMPRESSED_RGB_S3TC_DXT1 = self then
        Result := 'COMPRESSED_RGB_S3TC_DXT1' else
      if COMPRESSED_RGBA_S3TC_DXT1 = self then
        Result := 'COMPRESSED_RGBA_S3TC_DXT1' else
      if COMPRESSED_RGBA_S3TC_DXT3 = self then
        Result := 'COMPRESSED_RGBA_S3TC_DXT3' else
      if COMPRESSED_RGBA_S3TC_DXT5 = self then
        Result := 'COMPRESSED_RGBA_S3TC_DXT5' else
      if RGBA32F = self then
        Result := 'RGBA32F' else
      if RGB32F = self then
        Result := 'RGB32F' else
      if RGBA16F = self then
        Result := 'RGBA16F' else
      if RGB16F = self then
        Result := 'RGB16F' else
      if DEPTH24_STENCIL8 = self then
        Result := 'DEPTH24_STENCIL8' else
      if R11F_G11F_B10F = self then
        Result := 'R11F_G11F_B10F' else
      if RGB9_E5 = self then
        Result := 'RGB9_E5' else
      if SRGB8 = self then
        Result := 'SRGB8' else
      if SRGB8_ALPHA8 = self then
        Result := 'SRGB8_ALPHA8' else
      if COMPRESSED_SRGB_S3TC_DXT1 = self then
        Result := 'COMPRESSED_SRGB_S3TC_DXT1' else
      if COMPRESSED_SRGB_ALPHA_S3TC_DXT1 = self then
        Result := 'COMPRESSED_SRGB_ALPHA_S3TC_DXT1' else
      if COMPRESSED_SRGB_ALPHA_S3TC_DXT3 = self then
        Result := 'COMPRESSED_SRGB_ALPHA_S3TC_DXT3' else
      if COMPRESSED_SRGB_ALPHA_S3TC_DXT5 = self then
        Result := 'COMPRESSED_SRGB_ALPHA_S3TC_DXT5' else
      if DEPTH_COMPONENT32F = self then
        Result := 'DEPTH_COMPONENT32F' else
      if DEPTH32F_STENCIL8 = self then
        Result := 'DEPTH32F_STENCIL8' else
      if STENCIL_INDEX1 = self then
        Result := 'STENCIL_INDEX1' else
      if STENCIL_INDEX4 = self then
        Result := 'STENCIL_INDEX4' else
      if STENCIL_INDEX8 = self then
        Result := 'STENCIL_INDEX8' else
      if STENCIL_INDEX16 = self then
        Result := 'STENCIL_INDEX16' else
      if RGB565 = self then
        Result := 'RGB565' else
      if ETC1_RGB8 = self then
        Result := 'ETC1_RGB8' else
      if RGBA32UI = self then
        Result := 'RGBA32UI' else
      if RGB32UI = self then
        Result := 'RGB32UI' else
      if ALPHA32UI = self then
        Result := 'ALPHA32UI' else
      if INTENSITY32UI = self then
        Result := 'INTENSITY32UI' else
      if LUMINANCE32UI = self then
        Result := 'LUMINANCE32UI' else
      if LUMINANCE_ALPHA32UI = self then
        Result := 'LUMINANCE_ALPHA32UI' else
      if RGBA16UI = self then
        Result := 'RGBA16UI' else
      if RGB16UI = self then
        Result := 'RGB16UI' else
      if ALPHA16UI = self then
        Result := 'ALPHA16UI' else
      if INTENSITY16UI = self then
        Result := 'INTENSITY16UI' else
      if LUMINANCE16UI = self then
        Result := 'LUMINANCE16UI' else
      if LUMINANCE_ALPHA16UI = self then
        Result := 'LUMINANCE_ALPHA16UI' else
      if RGBA8UI = self then
        Result := 'RGBA8UI' else
      if RGB8UI = self then
        Result := 'RGB8UI' else
      if ALPHA8UI = self then
        Result := 'ALPHA8UI' else
      if INTENSITY8UI = self then
        Result := 'INTENSITY8UI' else
      if LUMINANCE8UI = self then
        Result := 'LUMINANCE8UI' else
      if LUMINANCE_ALPHA8UI = self then
        Result := 'LUMINANCE_ALPHA8UI' else
      if RGBA32I = self then
        Result := 'RGBA32I' else
      if RGB32I = self then
        Result := 'RGB32I' else
      if ALPHA32I = self then
        Result := 'ALPHA32I' else
      if INTENSITY32I = self then
        Result := 'INTENSITY32I' else
      if LUMINANCE32I = self then
        Result := 'LUMINANCE32I' else
      if LUMINANCE_ALPHA32I = self then
        Result := 'LUMINANCE_ALPHA32I' else
      if RGBA16I = self then
        Result := 'RGBA16I' else
      if RGB16I = self then
        Result := 'RGB16I' else
      if ALPHA16I = self then
        Result := 'ALPHA16I' else
      if INTENSITY16I = self then
        Result := 'INTENSITY16I' else
      if LUMINANCE16I = self then
        Result := 'LUMINANCE16I' else
      if LUMINANCE_ALPHA16I = self then
        Result := 'LUMINANCE_ALPHA16I' else
      if RGBA8I = self then
        Result := 'RGBA8I' else
      if RGB8I = self then
        Result := 'RGB8I' else
      if ALPHA8I = self then
        Result := 'ALPHA8I' else
      if INTENSITY8I = self then
        Result := 'INTENSITY8I' else
      if LUMINANCE8I = self then
        Result := 'LUMINANCE8I' else
      if LUMINANCE_ALPHA8I = self then
        Result := 'LUMINANCE_ALPHA8I' else
      if DEPTH_COMPONENT32F_NV = self then
        Result := 'DEPTH_COMPONENT32F_NV' else
      if DEPTH32F_STENCIL8_NV = self then
        Result := 'DEPTH32F_STENCIL8_NV' else
      if COMPRESSED_RED_RGTC1 = self then
        Result := 'COMPRESSED_RED_RGTC1' else
      if COMPRESSED_SIGNED_RED_RGTC1 = self then
        Result := 'COMPRESSED_SIGNED_RED_RGTC1' else
      if COMPRESSED_RED_GREEN_RGTC2 = self then
        Result := 'COMPRESSED_RED_GREEN_RGTC2' else
      if COMPRESSED_RG_RGTC2 = self then
        Result := 'COMPRESSED_RG_RGTC2' else
      if COMPRESSED_SIGNED_RED_GREEN_RGTC2 = self then
        Result := 'COMPRESSED_SIGNED_RED_GREEN_RGTC2' else
      if COMPRESSED_SIGNED_RG_RGTC2 = self then
        Result := 'COMPRESSED_SIGNED_RG_RGTC2' else
      if COMPRESSED_RGBA_BPTC_UNORM = self then
        Result := 'COMPRESSED_RGBA_BPTC_UNORM' else
      if COMPRESSED_SRGB_ALPHA_BPTC_UNORM = self then
        Result := 'COMPRESSED_SRGB_ALPHA_BPTC_UNORM' else
      if COMPRESSED_RGB_BPTC_SIGNED_FLOAT = self then
        Result := 'COMPRESSED_RGB_BPTC_SIGNED_FLOAT' else
      if COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = self then
        Result := 'COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT' else
      if R8_SNORM = self then
        Result := 'R8_SNORM' else
      if RG8_SNORM = self then
        Result := 'RG8_SNORM' else
      if RGB8_SNORM = self then
        Result := 'RGB8_SNORM' else
      if RGBA8_SNORM = self then
        Result := 'RGBA8_SNORM' else
      if R16_SNORM = self then
        Result := 'R16_SNORM' else
      if RG16_SNORM = self then
        Result := 'RG16_SNORM' else
      if RGB16_SNORM = self then
        Result := 'RGB16_SNORM' else
      if RGBA16_SNORM = self then
        Result := 'RGBA16_SNORM' else
      if RGB10_A2UI = self then
        Result := 'RGB10_A2UI' else
      if COMPRESSED_R11_EAC = self then
        Result := 'COMPRESSED_R11_EAC' else
      if COMPRESSED_SIGNED_R11_EAC = self then
        Result := 'COMPRESSED_SIGNED_R11_EAC' else
      if COMPRESSED_RG11_EAC = self then
        Result := 'COMPRESSED_RG11_EAC' else
      if COMPRESSED_SIGNED_RG11_EAC = self then
        Result := 'COMPRESSED_SIGNED_RG11_EAC' else
      if COMPRESSED_RGB8_ETC2 = self then
        Result := 'COMPRESSED_RGB8_ETC2' else
      if COMPRESSED_SRGB8_ETC2 = self then
        Result := 'COMPRESSED_SRGB8_ETC2' else
      if COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = self then
        Result := 'COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2' else
      if COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = self then
        Result := 'COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2' else
      if COMPRESSED_RGBA8_ETC2_EAC = self then
        Result := 'COMPRESSED_RGBA8_ETC2_EAC' else
      if COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ETC2_EAC' else
      if COMPRESSED_RGBA_ASTC_4x4 = self then
        Result := 'COMPRESSED_RGBA_ASTC_4x4' else
      if COMPRESSED_RGBA_ASTC_5x4 = self then
        Result := 'COMPRESSED_RGBA_ASTC_5x4' else
      if COMPRESSED_RGBA_ASTC_5x5 = self then
        Result := 'COMPRESSED_RGBA_ASTC_5x5' else
      if COMPRESSED_RGBA_ASTC_6x5 = self then
        Result := 'COMPRESSED_RGBA_ASTC_6x5' else
      if COMPRESSED_RGBA_ASTC_6x6 = self then
        Result := 'COMPRESSED_RGBA_ASTC_6x6' else
      if COMPRESSED_RGBA_ASTC_8x5 = self then
        Result := 'COMPRESSED_RGBA_ASTC_8x5' else
      if COMPRESSED_RGBA_ASTC_8x6 = self then
        Result := 'COMPRESSED_RGBA_ASTC_8x6' else
      if COMPRESSED_RGBA_ASTC_8x8 = self then
        Result := 'COMPRESSED_RGBA_ASTC_8x8' else
      if COMPRESSED_RGBA_ASTC_10x5 = self then
        Result := 'COMPRESSED_RGBA_ASTC_10x5' else
      if COMPRESSED_RGBA_ASTC_10x6 = self then
        Result := 'COMPRESSED_RGBA_ASTC_10x6' else
      if COMPRESSED_RGBA_ASTC_10x8 = self then
        Result := 'COMPRESSED_RGBA_ASTC_10x8' else
      if COMPRESSED_RGBA_ASTC_10x10 = self then
        Result := 'COMPRESSED_RGBA_ASTC_10x10' else
      if COMPRESSED_RGBA_ASTC_12x10 = self then
        Result := 'COMPRESSED_RGBA_ASTC_12x10' else
      if COMPRESSED_RGBA_ASTC_12x12 = self then
        Result := 'COMPRESSED_RGBA_ASTC_12x12' else
      if COMPRESSED_RGBA_ASTC_3x3x3 = self then
        Result := 'COMPRESSED_RGBA_ASTC_3x3x3' else
      if COMPRESSED_RGBA_ASTC_4x3x3 = self then
        Result := 'COMPRESSED_RGBA_ASTC_4x3x3' else
      if COMPRESSED_RGBA_ASTC_4x4x3 = self then
        Result := 'COMPRESSED_RGBA_ASTC_4x4x3' else
      if COMPRESSED_RGBA_ASTC_4x4x4 = self then
        Result := 'COMPRESSED_RGBA_ASTC_4x4x4' else
      if COMPRESSED_RGBA_ASTC_5x4x4 = self then
        Result := 'COMPRESSED_RGBA_ASTC_5x4x4' else
      if COMPRESSED_RGBA_ASTC_5x5x4 = self then
        Result := 'COMPRESSED_RGBA_ASTC_5x5x4' else
      if COMPRESSED_RGBA_ASTC_5x5x5 = self then
        Result := 'COMPRESSED_RGBA_ASTC_5x5x5' else
      if COMPRESSED_RGBA_ASTC_6x5x5 = self then
        Result := 'COMPRESSED_RGBA_ASTC_6x5x5' else
      if COMPRESSED_RGBA_ASTC_6x6x5 = self then
        Result := 'COMPRESSED_RGBA_ASTC_6x6x5' else
      if COMPRESSED_RGBA_ASTC_6x6x6 = self then
        Result := 'COMPRESSED_RGBA_ASTC_6x6x6' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_4x4 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x4' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_5x4 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x4' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_5x5 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x5' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_6x5 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x5' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_6x6 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x6' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_8x5 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x5' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_8x6 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x6' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_8x8 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x8' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_10x5 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x5' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_10x6 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x6' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_10x8 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x8' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_10x10 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x10' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_12x10 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_12x10' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_12x12 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_12x12' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5' else
      if COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6 = self then
        Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6' else
        Result := $'glSizedInternalFormat[{self.val}]';
    end;
    
  end;
  
  glSpriteMode = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property SPRITE_AXIAL:          glSpriteMode read new glSpriteMode($814C);
    public static property SPRITE_OBJECT_ALIGNED: glSpriteMode read new glSpriteMode($814D);
    public static property SPRITE_EYE_ALIGNED:    glSpriteMode read new glSpriteMode($814E);
    
    public function ToString: string; override;
    begin
      if SPRITE_AXIAL = self then
        Result := 'SPRITE_AXIAL' else
      if SPRITE_OBJECT_ALIGNED = self then
        Result := 'SPRITE_OBJECT_ALIGNED' else
      if SPRITE_EYE_ALIGNED = self then
        Result := 'SPRITE_EYE_ALIGNED' else
        Result := $'glSpriteMode[{self.val}]';
    end;
    
  end;
  
  glSpriteParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SPRITE_MODE: glSpriteParameterName read new glSpriteParameterName($8149);
    
    public function ToString: string; override;
    begin
      if SPRITE_MODE = self then
        Result := 'SPRITE_MODE' else
        Result := $'glSpriteParameterName[{self.val}]';
    end;
    
  end;
  
  glStencilFunction = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEVER:    glStencilFunction read new glStencilFunction($0200);
    public static property LESS:     glStencilFunction read new glStencilFunction($0201);
    public static property EQUAL:    glStencilFunction read new glStencilFunction($0202);
    public static property LEQUAL:   glStencilFunction read new glStencilFunction($0203);
    public static property GREATER:  glStencilFunction read new glStencilFunction($0204);
    public static property NOTEQUAL: glStencilFunction read new glStencilFunction($0205);
    public static property GEQUAL:   glStencilFunction read new glStencilFunction($0206);
    public static property ALWAYS:   glStencilFunction read new glStencilFunction($0207);
    
    public function ToString: string; override;
    begin
      if NEVER = self then
        Result := 'NEVER' else
      if LESS = self then
        Result := 'LESS' else
      if EQUAL = self then
        Result := 'EQUAL' else
      if LEQUAL = self then
        Result := 'LEQUAL' else
      if GREATER = self then
        Result := 'GREATER' else
      if NOTEQUAL = self then
        Result := 'NOTEQUAL' else
      if GEQUAL = self then
        Result := 'GEQUAL' else
      if ALWAYS = self then
        Result := 'ALWAYS' else
        Result := $'glStencilFunction[{self.val}]';
    end;
    
  end;
  
  glStencilOp = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ZERO:      glStencilOp read new glStencilOp(0);
    public static property INVERT:    glStencilOp read new glStencilOp($150A);
    public static property KEEP:      glStencilOp read new glStencilOp($1E00);
    public static property REPLACE:   glStencilOp read new glStencilOp($1E01);
    public static property INCR:      glStencilOp read new glStencilOp($1E02);
    public static property DECR:      glStencilOp read new glStencilOp($1E03);
    public static property INCR_WRAP: glStencilOp read new glStencilOp($8507);
    public static property DECR_WRAP: glStencilOp read new glStencilOp($8508);
    
    public function ToString: string; override;
    begin
      if ZERO = self then
        Result := 'ZERO' else
      if INVERT = self then
        Result := 'INVERT' else
      if KEEP = self then
        Result := 'KEEP' else
      if REPLACE = self then
        Result := 'REPLACE' else
      if INCR = self then
        Result := 'INCR' else
      if DECR = self then
        Result := 'DECR' else
      if INCR_WRAP = self then
        Result := 'INCR_WRAP' else
      if DECR_WRAP = self then
        Result := 'DECR_WRAP' else
        Result := $'glStencilOp[{self.val}]';
    end;
    
  end;
  
  glStringName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VENDOR:                   glStringName read new glStringName($1F00);
    public static property RENDERER:                 glStringName read new glStringName($1F01);
    public static property VERSION:                  glStringName read new glStringName($1F02);
    public static property EXTENSIONS:               glStringName read new glStringName($1F03);
    public static property SHADING_LANGUAGE_VERSION: glStringName read new glStringName($8B8C);
    
    public function ToString: string; override;
    begin
      if VENDOR = self then
        Result := 'VENDOR' else
      if RENDERER = self then
        Result := 'RENDERER' else
      if VERSION = self then
        Result := 'VERSION' else
      if EXTENSIONS = self then
        Result := 'EXTENSIONS' else
      if SHADING_LANGUAGE_VERSION = self then
        Result := 'SHADING_LANGUAGE_VERSION' else
        Result := $'glStringName[{self.val}]';
    end;
    
  end;
  
  glSubgroupSupportedFeatures = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SUBGROUP_FEATURE_BASIC_BIT:            glSubgroupSupportedFeatures read new glSubgroupSupportedFeatures(1 shl 0);
    public static property SUBGROUP_FEATURE_VOTE_BIT:             glSubgroupSupportedFeatures read new glSubgroupSupportedFeatures(1 shl 1);
    public static property SUBGROUP_FEATURE_ARITHMETIC_BIT:       glSubgroupSupportedFeatures read new glSubgroupSupportedFeatures(1 shl 2);
    public static property SUBGROUP_FEATURE_BALLOT_BIT:           glSubgroupSupportedFeatures read new glSubgroupSupportedFeatures(1 shl 3);
    public static property SUBGROUP_FEATURE_SHUFFLE_BIT:          glSubgroupSupportedFeatures read new glSubgroupSupportedFeatures(1 shl 4);
    public static property SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT: glSubgroupSupportedFeatures read new glSubgroupSupportedFeatures(1 shl 5);
    public static property SUBGROUP_FEATURE_CLUSTERED_BIT:        glSubgroupSupportedFeatures read new glSubgroupSupportedFeatures(1 shl 6);
    public static property SUBGROUP_FEATURE_QUAD_BIT:             glSubgroupSupportedFeatures read new glSubgroupSupportedFeatures(1 shl 7);
    public static property SUBGROUP_FEATURE_PARTITIONED_BIT:      glSubgroupSupportedFeatures read new glSubgroupSupportedFeatures(1 shl 8);
    
    public static function operator+(v1, v2: glSubgroupSupportedFeatures) := new glSubgroupSupportedFeatures(v1.val or v2.val);
    public static function operator or(v1, v2: glSubgroupSupportedFeatures) := new glSubgroupSupportedFeatures(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glSubgroupSupportedFeatures; v2: glSubgroupSupportedFeatures) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glSubgroupSupportedFeatures) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glSubgroupSupportedFeatures[0]';
        exit;
      end;
      if SUBGROUP_FEATURE_BASIC_BIT in self then
      begin
        res += 'SUBGROUP_FEATURE_BASIC_BIT+';
        left_val := left_val and not SUBGROUP_FEATURE_BASIC_BIT.val;
      end;
      if SUBGROUP_FEATURE_VOTE_BIT in self then
      begin
        res += 'SUBGROUP_FEATURE_VOTE_BIT+';
        left_val := left_val and not SUBGROUP_FEATURE_VOTE_BIT.val;
      end;
      if SUBGROUP_FEATURE_ARITHMETIC_BIT in self then
      begin
        res += 'SUBGROUP_FEATURE_ARITHMETIC_BIT+';
        left_val := left_val and not SUBGROUP_FEATURE_ARITHMETIC_BIT.val;
      end;
      if SUBGROUP_FEATURE_BALLOT_BIT in self then
      begin
        res += 'SUBGROUP_FEATURE_BALLOT_BIT+';
        left_val := left_val and not SUBGROUP_FEATURE_BALLOT_BIT.val;
      end;
      if SUBGROUP_FEATURE_SHUFFLE_BIT in self then
      begin
        res += 'SUBGROUP_FEATURE_SHUFFLE_BIT+';
        left_val := left_val and not SUBGROUP_FEATURE_SHUFFLE_BIT.val;
      end;
      if SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT in self then
      begin
        res += 'SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT+';
        left_val := left_val and not SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT.val;
      end;
      if SUBGROUP_FEATURE_CLUSTERED_BIT in self then
      begin
        res += 'SUBGROUP_FEATURE_CLUSTERED_BIT+';
        left_val := left_val and not SUBGROUP_FEATURE_CLUSTERED_BIT.val;
      end;
      if SUBGROUP_FEATURE_QUAD_BIT in self then
      begin
        res += 'SUBGROUP_FEATURE_QUAD_BIT+';
        left_val := left_val and not SUBGROUP_FEATURE_QUAD_BIT.val;
      end;
      if SUBGROUP_FEATURE_PARTITIONED_BIT in self then
      begin
        res += 'SUBGROUP_FEATURE_PARTITIONED_BIT+';
        left_val := left_val and not SUBGROUP_FEATURE_PARTITIONED_BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'glSubgroupSupportedFeatures[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glSubroutineParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNIFORM_SIZE:               glSubroutineParameterName read new glSubroutineParameterName($8A38);
    public static property UNIFORM_NAME_LENGTH:        glSubroutineParameterName read new glSubroutineParameterName($8A39);
    public static property NUM_COMPATIBLE_SUBROUTINES: glSubroutineParameterName read new glSubroutineParameterName($8E4A);
    public static property COMPATIBLE_SUBROUTINES:     glSubroutineParameterName read new glSubroutineParameterName($8E4B);
    
    public function ToString: string; override;
    begin
      if UNIFORM_SIZE = self then
        Result := 'UNIFORM_SIZE' else
      if UNIFORM_NAME_LENGTH = self then
        Result := 'UNIFORM_NAME_LENGTH' else
      if NUM_COMPATIBLE_SUBROUTINES = self then
        Result := 'NUM_COMPATIBLE_SUBROUTINES' else
      if COMPATIBLE_SUBROUTINES = self then
        Result := 'COMPATIBLE_SUBROUTINES' else
        Result := $'glSubroutineParameterName[{self.val}]';
    end;
    
  end;
  
  glSwizzleOp = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SWIZZLE_STR:    glSwizzleOp read new glSwizzleOp($8976);
    public static property SWIZZLE_STQ:    glSwizzleOp read new glSwizzleOp($8977);
    public static property SWIZZLE_STR_DR: glSwizzleOp read new glSwizzleOp($8978);
    public static property SWIZZLE_STQ_DQ: glSwizzleOp read new glSwizzleOp($8979);
    
    public function ToString: string; override;
    begin
      if SWIZZLE_STR = self then
        Result := 'SWIZZLE_STR' else
      if SWIZZLE_STQ = self then
        Result := 'SWIZZLE_STQ' else
      if SWIZZLE_STR_DR = self then
        Result := 'SWIZZLE_STR_DR' else
      if SWIZZLE_STQ_DQ = self then
        Result := 'SWIZZLE_STQ_DQ' else
        Result := $'glSwizzleOp[{self.val}]';
    end;
    
  end;
  
  glSyncBehaviorFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE: glSyncBehaviorFlags read new glSyncBehaviorFlags(0);
    
    public function ToString: string; override;
    begin
      if NONE = self then
        Result := 'NONE' else
        Result := $'glSyncBehaviorFlags[{self.val}]';
    end;
    
  end;
  
  glSyncCondition = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SYNC_GPU_COMMANDS_COMPLETE: glSyncCondition read new glSyncCondition($9117);
    
    public function ToString: string; override;
    begin
      if SYNC_GPU_COMMANDS_COMPLETE = self then
        Result := 'SYNC_GPU_COMMANDS_COMPLETE' else
        Result := $'glSyncCondition[{self.val}]';
    end;
    
  end;
  
  glSyncObjectMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SYNC_FLUSH_COMMANDS_BIT: glSyncObjectMask read new glSyncObjectMask(1 shl 0);
    
    public static function operator+(v1, v2: glSyncObjectMask) := new glSyncObjectMask(v1.val or v2.val);
    public static function operator or(v1, v2: glSyncObjectMask) := new glSyncObjectMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glSyncObjectMask; v2: glSyncObjectMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glSyncObjectMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glSyncObjectMask[0]';
        exit;
      end;
      if SYNC_FLUSH_COMMANDS_BIT in self then
      begin
        res += 'SYNC_FLUSH_COMMANDS_BIT+';
        left_val := left_val and not SYNC_FLUSH_COMMANDS_BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'glSyncObjectMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glSyncParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property OBJECT_TYPE:    glSyncParameterName read new glSyncParameterName($9112);
    public static property SYNC_CONDITION: glSyncParameterName read new glSyncParameterName($9113);
    public static property SYNC_STATUS:    glSyncParameterName read new glSyncParameterName($9114);
    public static property SYNC_FLAGS:     glSyncParameterName read new glSyncParameterName($9115);
    
    public function ToString: string; override;
    begin
      if OBJECT_TYPE = self then
        Result := 'OBJECT_TYPE' else
      if SYNC_CONDITION = self then
        Result := 'SYNC_CONDITION' else
      if SYNC_STATUS = self then
        Result := 'SYNC_STATUS' else
      if SYNC_FLAGS = self then
        Result := 'SYNC_FLAGS' else
        Result := $'glSyncParameterName[{self.val}]';
    end;
    
  end;
  
  glSyncStatus = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ALREADY_SIGNALED:    glSyncStatus read new glSyncStatus($911A);
    public static property TIMEOUT_EXPIRED:     glSyncStatus read new glSyncStatus($911B);
    public static property CONDITION_SATISFIED: glSyncStatus read new glSyncStatus($911C);
    public static property WAIT_FAILED:         glSyncStatus read new glSyncStatus($911D);
    
    public function ToString: string; override;
    begin
      if ALREADY_SIGNALED = self then
        Result := 'ALREADY_SIGNALED' else
      if TIMEOUT_EXPIRED = self then
        Result := 'TIMEOUT_EXPIRED' else
      if CONDITION_SATISFIED = self then
        Result := 'CONDITION_SATISFIED' else
      if WAIT_FAILED = self then
        Result := 'WAIT_FAILED' else
        Result := $'glSyncStatus[{self.val}]';
    end;
    
  end;
  
  glTangentPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:   glTangentPointerType read new glTangentPointerType($1400);
    public static property SHORT:  glTangentPointerType read new glTangentPointerType($1402);
    public static property INT:    glTangentPointerType read new glTangentPointerType($1404);
    public static property FLOAT:  glTangentPointerType read new glTangentPointerType($1406);
    public static property DOUBLE: glTangentPointerType read new glTangentPointerType($140A);
    
    public function ToString: string; override;
    begin
      if BYTE = self then
        Result := 'BYTE' else
      if SHORT = self then
        Result := 'SHORT' else
      if INT = self then
        Result := 'INT' else
      if FLOAT = self then
        Result := 'FLOAT' else
      if DOUBLE = self then
        Result := 'DOUBLE' else
        Result := $'glTangentPointerType[{self.val}]';
    end;
    
  end;
  
  glTexBumpParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BUMP_ROT_MATRIX: glTexBumpParameter read new glTexBumpParameter($8775);
    
    public function ToString: string; override;
    begin
      if BUMP_ROT_MATRIX = self then
        Result := 'BUMP_ROT_MATRIX' else
        Result := $'glTexBumpParameter[{self.val}]';
    end;
    
  end;
  
  glTexCoordPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SHORT:  glTexCoordPointerType read new glTexCoordPointerType($1402);
    public static property INT:    glTexCoordPointerType read new glTexCoordPointerType($1404);
    public static property FLOAT:  glTexCoordPointerType read new glTexCoordPointerType($1406);
    public static property DOUBLE: glTexCoordPointerType read new glTexCoordPointerType($140A);
    
    public function ToString: string; override;
    begin
      if SHORT = self then
        Result := 'SHORT' else
      if INT = self then
        Result := 'INT' else
      if FLOAT = self then
        Result := 'FLOAT' else
      if DOUBLE = self then
        Result := 'DOUBLE' else
        Result := $'glTexCoordPointerType[{self.val}]';
    end;
    
  end;
  
  glTextureCompareMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:                   glTextureCompareMode read new glTextureCompareMode(0);
    public static property COMPARE_R_TO_TEXTURE:   glTextureCompareMode read new glTextureCompareMode($884E);
    public static property COMPARE_REF_TO_TEXTURE: glTextureCompareMode read new glTextureCompareMode($884E);
    
    public function ToString: string; override;
    begin
      if NONE = self then
        Result := 'NONE' else
      if COMPARE_R_TO_TEXTURE = self then
        Result := 'COMPARE_R_TO_TEXTURE' else
      if COMPARE_REF_TO_TEXTURE = self then
        Result := 'COMPARE_REF_TO_TEXTURE' else
        Result := $'glTextureCompareMode[{self.val}]';
    end;
    
  end;
  
  glTextureCoordName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property S:               glTextureCoordName read new glTextureCoordName($2000);
    public static property T:               glTextureCoordName read new glTextureCoordName($2001);
    public static property R:               glTextureCoordName read new glTextureCoordName($2002);
    public static property Q:               glTextureCoordName read new glTextureCoordName($2003);
    public static property TEXTURE_GEN_STR: glTextureCoordName read new glTextureCoordName($8D60);
    
    public function ToString: string; override;
    begin
      if S = self then
        Result := 'S' else
      if T = self then
        Result := 'T' else
      if R = self then
        Result := 'R' else
      if Q = self then
        Result := 'Q' else
      if TEXTURE_GEN_STR = self then
        Result := 'TEXTURE_GEN_STR' else
        Result := $'glTextureCoordName[{self.val}]';
    end;
    
  end;
  
  glTextureEnvMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ADD:              glTextureEnvMode read new glTextureEnvMode($0104);
    public static property BLEND:            glTextureEnvMode read new glTextureEnvMode($0BE2);
    public static property REPLACE:          glTextureEnvMode read new glTextureEnvMode($1E01);
    public static property MODULATE:         glTextureEnvMode read new glTextureEnvMode($2100);
    public static property DECAL:            glTextureEnvMode read new glTextureEnvMode($2101);
    public static property REPLACE_EXT:      glTextureEnvMode read new glTextureEnvMode($8062);
    public static property TEXTURE_ENV_BIAS: glTextureEnvMode read new glTextureEnvMode($80BE);
    public static property COMBINE:          glTextureEnvMode read new glTextureEnvMode($8570);
    
    public function ToString: string; override;
    begin
      if ADD = self then
        Result := 'ADD' else
      if BLEND = self then
        Result := 'BLEND' else
      if REPLACE = self then
        Result := 'REPLACE' else
      if MODULATE = self then
        Result := 'MODULATE' else
      if DECAL = self then
        Result := 'DECAL' else
      if REPLACE_EXT = self then
        Result := 'REPLACE_EXT' else
      if TEXTURE_ENV_BIAS = self then
        Result := 'TEXTURE_ENV_BIAS' else
      if COMBINE = self then
        Result := 'COMBINE' else
        Result := $'glTextureEnvMode[{self.val}]';
    end;
    
  end;
  
  glTextureEnvParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ALPHA_SCALE:       glTextureEnvParameter read new glTextureEnvParameter($0D1C);
    public static property TEXTURE_ENV_MODE:  glTextureEnvParameter read new glTextureEnvParameter($2200);
    public static property TEXTURE_ENV_COLOR: glTextureEnvParameter read new glTextureEnvParameter($2201);
    public static property TEXTURE_LOD_BIAS:  glTextureEnvParameter read new glTextureEnvParameter($8501);
    public static property COMBINE:           glTextureEnvParameter read new glTextureEnvParameter($8570);
    public static property COMBINE_RGB:       glTextureEnvParameter read new glTextureEnvParameter($8571);
    public static property COMBINE_ALPHA:     glTextureEnvParameter read new glTextureEnvParameter($8572);
    public static property RGB_SCALE:         glTextureEnvParameter read new glTextureEnvParameter($8573);
    public static property ADD_SIGNED:        glTextureEnvParameter read new glTextureEnvParameter($8574);
    public static property INTERPOLATE:       glTextureEnvParameter read new glTextureEnvParameter($8575);
    public static property CONSTANT:          glTextureEnvParameter read new glTextureEnvParameter($8576);
    public static property PRIMARY_COLOR:     glTextureEnvParameter read new glTextureEnvParameter($8577);
    public static property PREVIOUS:          glTextureEnvParameter read new glTextureEnvParameter($8578);
    public static property SOURCE0_RGB:       glTextureEnvParameter read new glTextureEnvParameter($8580);
    public static property SRC0_RGB:          glTextureEnvParameter read new glTextureEnvParameter($8580);
    public static property SOURCE1_RGB:       glTextureEnvParameter read new glTextureEnvParameter($8581);
    public static property SRC1_RGB:          glTextureEnvParameter read new glTextureEnvParameter($8581);
    public static property SOURCE2_RGB:       glTextureEnvParameter read new glTextureEnvParameter($8582);
    public static property SRC2_RGB:          glTextureEnvParameter read new glTextureEnvParameter($8582);
    public static property SOURCE3_RGB:       glTextureEnvParameter read new glTextureEnvParameter($8583);
    public static property SOURCE0_ALPHA:     glTextureEnvParameter read new glTextureEnvParameter($8588);
    public static property SRC0_ALPHA:        glTextureEnvParameter read new glTextureEnvParameter($8588);
    public static property SOURCE1_ALPHA:     glTextureEnvParameter read new glTextureEnvParameter($8589);
    public static property SRC1_ALPHA:        glTextureEnvParameter read new glTextureEnvParameter($8589);
    public static property SOURCE2_ALPHA:     glTextureEnvParameter read new glTextureEnvParameter($858A);
    public static property SRC2_ALPHA:        glTextureEnvParameter read new glTextureEnvParameter($858A);
    public static property SOURCE3_ALPHA:     glTextureEnvParameter read new glTextureEnvParameter($858B);
    public static property OPERAND0_RGB:      glTextureEnvParameter read new glTextureEnvParameter($8590);
    public static property OPERAND1_RGB:      glTextureEnvParameter read new glTextureEnvParameter($8591);
    public static property OPERAND2_RGB:      glTextureEnvParameter read new glTextureEnvParameter($8592);
    public static property OPERAND3_RGB:      glTextureEnvParameter read new glTextureEnvParameter($8593);
    public static property OPERAND0_ALPHA:    glTextureEnvParameter read new glTextureEnvParameter($8598);
    public static property OPERAND1_ALPHA:    glTextureEnvParameter read new glTextureEnvParameter($8599);
    public static property OPERAND2_ALPHA:    glTextureEnvParameter read new glTextureEnvParameter($859A);
    public static property OPERAND3_ALPHA:    glTextureEnvParameter read new glTextureEnvParameter($859B);
    public static property COORD_REPLACE:     glTextureEnvParameter read new glTextureEnvParameter($8862);
    
    public function ToString: string; override;
    begin
      if ALPHA_SCALE = self then
        Result := 'ALPHA_SCALE' else
      if TEXTURE_ENV_MODE = self then
        Result := 'TEXTURE_ENV_MODE' else
      if TEXTURE_ENV_COLOR = self then
        Result := 'TEXTURE_ENV_COLOR' else
      if TEXTURE_LOD_BIAS = self then
        Result := 'TEXTURE_LOD_BIAS' else
      if COMBINE = self then
        Result := 'COMBINE' else
      if COMBINE_RGB = self then
        Result := 'COMBINE_RGB' else
      if COMBINE_ALPHA = self then
        Result := 'COMBINE_ALPHA' else
      if RGB_SCALE = self then
        Result := 'RGB_SCALE' else
      if ADD_SIGNED = self then
        Result := 'ADD_SIGNED' else
      if INTERPOLATE = self then
        Result := 'INTERPOLATE' else
      if CONSTANT = self then
        Result := 'CONSTANT' else
      if PRIMARY_COLOR = self then
        Result := 'PRIMARY_COLOR' else
      if PREVIOUS = self then
        Result := 'PREVIOUS' else
      if SOURCE0_RGB = self then
        Result := 'SOURCE0_RGB' else
      if SRC0_RGB = self then
        Result := 'SRC0_RGB' else
      if SOURCE1_RGB = self then
        Result := 'SOURCE1_RGB' else
      if SRC1_RGB = self then
        Result := 'SRC1_RGB' else
      if SOURCE2_RGB = self then
        Result := 'SOURCE2_RGB' else
      if SRC2_RGB = self then
        Result := 'SRC2_RGB' else
      if SOURCE3_RGB = self then
        Result := 'SOURCE3_RGB' else
      if SOURCE0_ALPHA = self then
        Result := 'SOURCE0_ALPHA' else
      if SRC0_ALPHA = self then
        Result := 'SRC0_ALPHA' else
      if SOURCE1_ALPHA = self then
        Result := 'SOURCE1_ALPHA' else
      if SRC1_ALPHA = self then
        Result := 'SRC1_ALPHA' else
      if SOURCE2_ALPHA = self then
        Result := 'SOURCE2_ALPHA' else
      if SRC2_ALPHA = self then
        Result := 'SRC2_ALPHA' else
      if SOURCE3_ALPHA = self then
        Result := 'SOURCE3_ALPHA' else
      if OPERAND0_RGB = self then
        Result := 'OPERAND0_RGB' else
      if OPERAND1_RGB = self then
        Result := 'OPERAND1_RGB' else
      if OPERAND2_RGB = self then
        Result := 'OPERAND2_RGB' else
      if OPERAND3_RGB = self then
        Result := 'OPERAND3_RGB' else
      if OPERAND0_ALPHA = self then
        Result := 'OPERAND0_ALPHA' else
      if OPERAND1_ALPHA = self then
        Result := 'OPERAND1_ALPHA' else
      if OPERAND2_ALPHA = self then
        Result := 'OPERAND2_ALPHA' else
      if OPERAND3_ALPHA = self then
        Result := 'OPERAND3_ALPHA' else
      if COORD_REPLACE = self then
        Result := 'COORD_REPLACE' else
        Result := $'glTextureEnvParameter[{self.val}]';
    end;
    
  end;
  
  glTextureEnvTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_ENV:            glTextureEnvTarget read new glTextureEnvTarget($2300);
    public static property TEXTURE_FILTER_CONTROL: glTextureEnvTarget read new glTextureEnvTarget($8500);
    public static property POINT_SPRITE:           glTextureEnvTarget read new glTextureEnvTarget($8861);
    
    public function ToString: string; override;
    begin
      if TEXTURE_ENV = self then
        Result := 'TEXTURE_ENV' else
      if TEXTURE_FILTER_CONTROL = self then
        Result := 'TEXTURE_FILTER_CONTROL' else
      if POINT_SPRITE = self then
        Result := 'POINT_SPRITE' else
        Result := $'glTextureEnvTarget[{self.val}]';
    end;
    
  end;
  
  glTextureFilter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FILTER4: glTextureFilter read new glTextureFilter($8146);
    
    public function ToString: string; override;
    begin
      if FILTER4 = self then
        Result := 'FILTER4' else
        Result := $'glTextureFilter[{self.val}]';
    end;
    
  end;
  
  glTextureGenMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property EYE_LINEAR:               glTextureGenMode read new glTextureGenMode($2400);
    public static property OBJECT_LINEAR:            glTextureGenMode read new glTextureGenMode($2401);
    public static property SPHERE_MAP:               glTextureGenMode read new glTextureGenMode($2402);
    public static property EYE_DISTANCE_TO_POINT:    glTextureGenMode read new glTextureGenMode($81F0);
    public static property OBJECT_DISTANCE_TO_POINT: glTextureGenMode read new glTextureGenMode($81F1);
    public static property EYE_DISTANCE_TO_LINE:     glTextureGenMode read new glTextureGenMode($81F2);
    public static property OBJECT_DISTANCE_TO_LINE:  glTextureGenMode read new glTextureGenMode($81F3);
    
    public function ToString: string; override;
    begin
      if EYE_LINEAR = self then
        Result := 'EYE_LINEAR' else
      if OBJECT_LINEAR = self then
        Result := 'OBJECT_LINEAR' else
      if SPHERE_MAP = self then
        Result := 'SPHERE_MAP' else
      if EYE_DISTANCE_TO_POINT = self then
        Result := 'EYE_DISTANCE_TO_POINT' else
      if OBJECT_DISTANCE_TO_POINT = self then
        Result := 'OBJECT_DISTANCE_TO_POINT' else
      if EYE_DISTANCE_TO_LINE = self then
        Result := 'EYE_DISTANCE_TO_LINE' else
      if OBJECT_DISTANCE_TO_LINE = self then
        Result := 'OBJECT_DISTANCE_TO_LINE' else
        Result := $'glTextureGenMode[{self.val}]';
    end;
    
  end;
  
  glTextureGenParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_GEN_MODE: glTextureGenParameter read new glTextureGenParameter($2500);
    public static property OBJECT_PLANE:     glTextureGenParameter read new glTextureGenParameter($2501);
    public static property EYE_PLANE:        glTextureGenParameter read new glTextureGenParameter($2502);
    public static property EYE_POINT:        glTextureGenParameter read new glTextureGenParameter($81F4);
    public static property OBJECT_POINT:     glTextureGenParameter read new glTextureGenParameter($81F5);
    public static property EYE_LINE:         glTextureGenParameter read new glTextureGenParameter($81F6);
    public static property OBJECT_LINE:      glTextureGenParameter read new glTextureGenParameter($81F7);
    
    public function ToString: string; override;
    begin
      if TEXTURE_GEN_MODE = self then
        Result := 'TEXTURE_GEN_MODE' else
      if OBJECT_PLANE = self then
        Result := 'OBJECT_PLANE' else
      if EYE_PLANE = self then
        Result := 'EYE_PLANE' else
      if EYE_POINT = self then
        Result := 'EYE_POINT' else
      if OBJECT_POINT = self then
        Result := 'OBJECT_POINT' else
      if EYE_LINE = self then
        Result := 'EYE_LINE' else
      if OBJECT_LINE = self then
        Result := 'OBJECT_LINE' else
        Result := $'glTextureGenParameter[{self.val}]';
    end;
    
  end;
  
  glTextureLayout = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT: glTextureLayout read new glTextureLayout($9530);
    public static property LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY: glTextureLayout read new glTextureLayout($9531);
    public static property LAYOUT_GENERAL:                            glTextureLayout read new glTextureLayout($958D);
    public static property LAYOUT_COLOR_ATTACHMENT:                   glTextureLayout read new glTextureLayout($958E);
    public static property LAYOUT_DEPTH_STENCIL_ATTACHMENT:           glTextureLayout read new glTextureLayout($958F);
    public static property LAYOUT_DEPTH_STENCIL_READ_ONLY:            glTextureLayout read new glTextureLayout($9590);
    public static property LAYOUT_SHADER_READ_ONLY:                   glTextureLayout read new glTextureLayout($9591);
    public static property LAYOUT_TRANSFER_SRC:                       glTextureLayout read new glTextureLayout($9592);
    public static property LAYOUT_TRANSFER_DST:                       glTextureLayout read new glTextureLayout($9593);
    
    public function ToString: string; override;
    begin
      if LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT = self then
        Result := 'LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT' else
      if LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY = self then
        Result := 'LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY' else
      if LAYOUT_GENERAL = self then
        Result := 'LAYOUT_GENERAL' else
      if LAYOUT_COLOR_ATTACHMENT = self then
        Result := 'LAYOUT_COLOR_ATTACHMENT' else
      if LAYOUT_DEPTH_STENCIL_ATTACHMENT = self then
        Result := 'LAYOUT_DEPTH_STENCIL_ATTACHMENT' else
      if LAYOUT_DEPTH_STENCIL_READ_ONLY = self then
        Result := 'LAYOUT_DEPTH_STENCIL_READ_ONLY' else
      if LAYOUT_SHADER_READ_ONLY = self then
        Result := 'LAYOUT_SHADER_READ_ONLY' else
      if LAYOUT_TRANSFER_SRC = self then
        Result := 'LAYOUT_TRANSFER_SRC' else
      if LAYOUT_TRANSFER_DST = self then
        Result := 'LAYOUT_TRANSFER_DST' else
        Result := $'glTextureLayout[{self.val}]';
    end;
    
  end;
  
  glTextureMagFilter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEAREST:                 glTextureMagFilter read new glTextureMagFilter($2600);
    public static property LINEAR:                  glTextureMagFilter read new glTextureMagFilter($2601);
    public static property LINEAR_DETAIL:           glTextureMagFilter read new glTextureMagFilter($8097);
    public static property LINEAR_DETAIL_ALPHA:     glTextureMagFilter read new glTextureMagFilter($8098);
    public static property LINEAR_DETAIL_COLOR:     glTextureMagFilter read new glTextureMagFilter($8099);
    public static property LINEAR_SHARPEN:          glTextureMagFilter read new glTextureMagFilter($80AD);
    public static property LINEAR_SHARPEN_ALPHA:    glTextureMagFilter read new glTextureMagFilter($80AE);
    public static property LINEAR_SHARPEN_COLOR:    glTextureMagFilter read new glTextureMagFilter($80AF);
    public static property FILTER4:                 glTextureMagFilter read new glTextureMagFilter($8146);
    public static property PIXEL_TEX_GEN_Q_CEILING: glTextureMagFilter read new glTextureMagFilter($8184);
    public static property PIXEL_TEX_GEN_Q_ROUND:   glTextureMagFilter read new glTextureMagFilter($8185);
    public static property PIXEL_TEX_GEN_Q_FLOOR:   glTextureMagFilter read new glTextureMagFilter($8186);
    
    public function ToString: string; override;
    begin
      if NEAREST = self then
        Result := 'NEAREST' else
      if LINEAR = self then
        Result := 'LINEAR' else
      if LINEAR_DETAIL = self then
        Result := 'LINEAR_DETAIL' else
      if LINEAR_DETAIL_ALPHA = self then
        Result := 'LINEAR_DETAIL_ALPHA' else
      if LINEAR_DETAIL_COLOR = self then
        Result := 'LINEAR_DETAIL_COLOR' else
      if LINEAR_SHARPEN = self then
        Result := 'LINEAR_SHARPEN' else
      if LINEAR_SHARPEN_ALPHA = self then
        Result := 'LINEAR_SHARPEN_ALPHA' else
      if LINEAR_SHARPEN_COLOR = self then
        Result := 'LINEAR_SHARPEN_COLOR' else
      if FILTER4 = self then
        Result := 'FILTER4' else
      if PIXEL_TEX_GEN_Q_CEILING = self then
        Result := 'PIXEL_TEX_GEN_Q_CEILING' else
      if PIXEL_TEX_GEN_Q_ROUND = self then
        Result := 'PIXEL_TEX_GEN_Q_ROUND' else
      if PIXEL_TEX_GEN_Q_FLOOR = self then
        Result := 'PIXEL_TEX_GEN_Q_FLOOR' else
        Result := $'glTextureMagFilter[{self.val}]';
    end;
    
  end;
  
  glTextureMinFilter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEAREST:                 glTextureMinFilter read new glTextureMinFilter($2600);
    public static property LINEAR:                  glTextureMinFilter read new glTextureMinFilter($2601);
    public static property NEAREST_MIPMAP_NEAREST:  glTextureMinFilter read new glTextureMinFilter($2700);
    public static property LINEAR_MIPMAP_NEAREST:   glTextureMinFilter read new glTextureMinFilter($2701);
    public static property NEAREST_MIPMAP_LINEAR:   glTextureMinFilter read new glTextureMinFilter($2702);
    public static property LINEAR_MIPMAP_LINEAR:    glTextureMinFilter read new glTextureMinFilter($2703);
    public static property FILTER4:                 glTextureMinFilter read new glTextureMinFilter($8146);
    public static property LINEAR_CLIPMAP_LINEAR:   glTextureMinFilter read new glTextureMinFilter($8170);
    public static property PIXEL_TEX_GEN_Q_CEILING: glTextureMinFilter read new glTextureMinFilter($8184);
    public static property PIXEL_TEX_GEN_Q_ROUND:   glTextureMinFilter read new glTextureMinFilter($8185);
    public static property PIXEL_TEX_GEN_Q_FLOOR:   glTextureMinFilter read new glTextureMinFilter($8186);
    public static property NEAREST_CLIPMAP_NEAREST: glTextureMinFilter read new glTextureMinFilter($844D);
    public static property NEAREST_CLIPMAP_LINEAR:  glTextureMinFilter read new glTextureMinFilter($844E);
    public static property LINEAR_CLIPMAP_NEAREST:  glTextureMinFilter read new glTextureMinFilter($844F);
    
    public function ToString: string; override;
    begin
      if NEAREST = self then
        Result := 'NEAREST' else
      if LINEAR = self then
        Result := 'LINEAR' else
      if NEAREST_MIPMAP_NEAREST = self then
        Result := 'NEAREST_MIPMAP_NEAREST' else
      if LINEAR_MIPMAP_NEAREST = self then
        Result := 'LINEAR_MIPMAP_NEAREST' else
      if NEAREST_MIPMAP_LINEAR = self then
        Result := 'NEAREST_MIPMAP_LINEAR' else
      if LINEAR_MIPMAP_LINEAR = self then
        Result := 'LINEAR_MIPMAP_LINEAR' else
      if FILTER4 = self then
        Result := 'FILTER4' else
      if LINEAR_CLIPMAP_LINEAR = self then
        Result := 'LINEAR_CLIPMAP_LINEAR' else
      if PIXEL_TEX_GEN_Q_CEILING = self then
        Result := 'PIXEL_TEX_GEN_Q_CEILING' else
      if PIXEL_TEX_GEN_Q_ROUND = self then
        Result := 'PIXEL_TEX_GEN_Q_ROUND' else
      if PIXEL_TEX_GEN_Q_FLOOR = self then
        Result := 'PIXEL_TEX_GEN_Q_FLOOR' else
      if NEAREST_CLIPMAP_NEAREST = self then
        Result := 'NEAREST_CLIPMAP_NEAREST' else
      if NEAREST_CLIPMAP_LINEAR = self then
        Result := 'NEAREST_CLIPMAP_LINEAR' else
      if LINEAR_CLIPMAP_NEAREST = self then
        Result := 'LINEAR_CLIPMAP_NEAREST' else
        Result := $'glTextureMinFilter[{self.val}]';
    end;
    
  end;
  
  glTextureNormalMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PERTURB: glTextureNormalMode read new glTextureNormalMode($85AE);
    
    public function ToString: string; override;
    begin
      if PERTURB = self then
        Result := 'PERTURB' else
        Result := $'glTextureNormalMode[{self.val}]';
    end;
    
  end;
  
  glTextureParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_WIDTH:                    glTextureParameterName read new glTextureParameterName($1000);
    public static property TEXTURE_HEIGHT:                   glTextureParameterName read new glTextureParameterName($1001);
    public static property TEXTURE_INTERNAL_FORMAT:          glTextureParameterName read new glTextureParameterName($1003);
    public static property TEXTURE_COMPONENTS:               glTextureParameterName read new glTextureParameterName($1003);
    public static property TEXTURE_BORDER_COLOR:             glTextureParameterName read new glTextureParameterName($1004);
    public static property TEXTURE_BORDER:                   glTextureParameterName read new glTextureParameterName($1005);
    public static property TEXTURE_MAG_FILTER:               glTextureParameterName read new glTextureParameterName($2800);
    public static property TEXTURE_MIN_FILTER:               glTextureParameterName read new glTextureParameterName($2801);
    public static property TEXTURE_WRAP_S:                   glTextureParameterName read new glTextureParameterName($2802);
    public static property TEXTURE_WRAP_T:                   glTextureParameterName read new glTextureParameterName($2803);
    public static property TEXTURE_RED_SIZE:                 glTextureParameterName read new glTextureParameterName($805C);
    public static property TEXTURE_GREEN_SIZE:               glTextureParameterName read new glTextureParameterName($805D);
    public static property TEXTURE_BLUE_SIZE:                glTextureParameterName read new glTextureParameterName($805E);
    public static property TEXTURE_ALPHA_SIZE:               glTextureParameterName read new glTextureParameterName($805F);
    public static property TEXTURE_LUMINANCE_SIZE:           glTextureParameterName read new glTextureParameterName($8060);
    public static property TEXTURE_INTENSITY_SIZE:           glTextureParameterName read new glTextureParameterName($8061);
    public static property TEXTURE_PRIORITY:                 glTextureParameterName read new glTextureParameterName($8066);
    public static property TEXTURE_RESIDENT:                 glTextureParameterName read new glTextureParameterName($8067);
    public static property TEXTURE_DEPTH:                    glTextureParameterName read new glTextureParameterName($8071);
    public static property TEXTURE_WRAP_R:                   glTextureParameterName read new glTextureParameterName($8072);
    public static property DETAIL_TEXTURE_LEVEL:             glTextureParameterName read new glTextureParameterName($809A);
    public static property DETAIL_TEXTURE_MODE:              glTextureParameterName read new glTextureParameterName($809B);
    public static property DETAIL_TEXTURE_FUNC_POINTS:       glTextureParameterName read new glTextureParameterName($809C);
    public static property SHARPEN_TEXTURE_FUNC_POINTS:      glTextureParameterName read new glTextureParameterName($80B0);
    public static property SHADOW_AMBIENT:                   glTextureParameterName read new glTextureParameterName($80BF);
    public static property DUAL_TEXTURE_SELECT:              glTextureParameterName read new glTextureParameterName($8124);
    public static property QUAD_TEXTURE_SELECT:              glTextureParameterName read new glTextureParameterName($8125);
    public static property TEXTURE_4DSIZE:                   glTextureParameterName read new glTextureParameterName($8136);
    public static property TEXTURE_WRAP_Q:                   glTextureParameterName read new glTextureParameterName($8137);
    public static property TEXTURE_MIN_LOD:                  glTextureParameterName read new glTextureParameterName($813A);
    public static property TEXTURE_MAX_LOD:                  glTextureParameterName read new glTextureParameterName($813B);
    public static property TEXTURE_BASE_LEVEL:               glTextureParameterName read new glTextureParameterName($813C);
    public static property TEXTURE_MAX_LEVEL:                glTextureParameterName read new glTextureParameterName($813D);
    public static property TEXTURE_FILTER4_SIZE:             glTextureParameterName read new glTextureParameterName($8147);
    public static property TEXTURE_CLIPMAP_CENTER:           glTextureParameterName read new glTextureParameterName($8171);
    public static property TEXTURE_CLIPMAP_FRAME:            glTextureParameterName read new glTextureParameterName($8172);
    public static property TEXTURE_CLIPMAP_OFFSET:           glTextureParameterName read new glTextureParameterName($8173);
    public static property TEXTURE_CLIPMAP_VIRTUAL_DEPTH:    glTextureParameterName read new glTextureParameterName($8174);
    public static property TEXTURE_CLIPMAP_LOD_OFFSET:       glTextureParameterName read new glTextureParameterName($8175);
    public static property TEXTURE_CLIPMAP_DEPTH:            glTextureParameterName read new glTextureParameterName($8176);
    public static property POST_TEXTURE_FILTER_BIAS:         glTextureParameterName read new glTextureParameterName($8179);
    public static property POST_TEXTURE_FILTER_SCALE:        glTextureParameterName read new glTextureParameterName($817A);
    public static property TEXTURE_LOD_BIAS_S:               glTextureParameterName read new glTextureParameterName($818E);
    public static property TEXTURE_LOD_BIAS_T:               glTextureParameterName read new glTextureParameterName($818F);
    public static property TEXTURE_LOD_BIAS_R:               glTextureParameterName read new glTextureParameterName($8190);
    public static property GENERATE_MIPMAP:                  glTextureParameterName read new glTextureParameterName($8191);
    public static property TEXTURE_COMPARE:                  glTextureParameterName read new glTextureParameterName($819A);
    public static property TEXTURE_COMPARE_OPERATOR:         glTextureParameterName read new glTextureParameterName($819B);
    public static property TEXTURE_LEQUAL_R:                 glTextureParameterName read new glTextureParameterName($819C);
    public static property TEXTURE_GEQUAL_R:                 glTextureParameterName read new glTextureParameterName($819D);
    public static property TEXTURE_MAX_CLAMP_S:              glTextureParameterName read new glTextureParameterName($8369);
    public static property TEXTURE_MAX_CLAMP_T:              glTextureParameterName read new glTextureParameterName($836A);
    public static property TEXTURE_MAX_CLAMP_R:              glTextureParameterName read new glTextureParameterName($836B);
    public static property TEXTURE_MEMORY_LAYOUT:            glTextureParameterName read new glTextureParameterName($83FF);
    public static property TEXTURE_MAX_ANISOTROPY:           glTextureParameterName read new glTextureParameterName($84FE);
    public static property TEXTURE_LOD_BIAS:                 glTextureParameterName read new glTextureParameterName($8501);
    public static property TEXTURE_COMPARE_MODE:             glTextureParameterName read new glTextureParameterName($884C);
    public static property TEXTURE_COMPARE_FUNC:             glTextureParameterName read new glTextureParameterName($884D);
    public static property TEXTURE_SWIZZLE_R:                glTextureParameterName read new glTextureParameterName($8E42);
    public static property TEXTURE_SWIZZLE_G:                glTextureParameterName read new glTextureParameterName($8E43);
    public static property TEXTURE_SWIZZLE_B:                glTextureParameterName read new glTextureParameterName($8E44);
    public static property TEXTURE_SWIZZLE_A:                glTextureParameterName read new glTextureParameterName($8E45);
    public static property TEXTURE_SWIZZLE_RGBA:             glTextureParameterName read new glTextureParameterName($8E46);
    public static property TEXTURE_UNNORMALIZED_COORDINATES: glTextureParameterName read new glTextureParameterName($8F6A);
    public static property DEPTH_STENCIL_TEXTURE_MODE:       glTextureParameterName read new glTextureParameterName($90EA);
    public static property TEXTURE_TILING:                   glTextureParameterName read new glTextureParameterName($9580);
    public static property TEXTURE_FOVEATED_CUTOFF_DENSITY:  glTextureParameterName read new glTextureParameterName($96A0);
    
    public function ToString: string; override;
    begin
      if TEXTURE_WIDTH = self then
        Result := 'TEXTURE_WIDTH' else
      if TEXTURE_HEIGHT = self then
        Result := 'TEXTURE_HEIGHT' else
      if TEXTURE_INTERNAL_FORMAT = self then
        Result := 'TEXTURE_INTERNAL_FORMAT' else
      if TEXTURE_COMPONENTS = self then
        Result := 'TEXTURE_COMPONENTS' else
      if TEXTURE_BORDER_COLOR = self then
        Result := 'TEXTURE_BORDER_COLOR' else
      if TEXTURE_BORDER = self then
        Result := 'TEXTURE_BORDER' else
      if TEXTURE_MAG_FILTER = self then
        Result := 'TEXTURE_MAG_FILTER' else
      if TEXTURE_MIN_FILTER = self then
        Result := 'TEXTURE_MIN_FILTER' else
      if TEXTURE_WRAP_S = self then
        Result := 'TEXTURE_WRAP_S' else
      if TEXTURE_WRAP_T = self then
        Result := 'TEXTURE_WRAP_T' else
      if TEXTURE_RED_SIZE = self then
        Result := 'TEXTURE_RED_SIZE' else
      if TEXTURE_GREEN_SIZE = self then
        Result := 'TEXTURE_GREEN_SIZE' else
      if TEXTURE_BLUE_SIZE = self then
        Result := 'TEXTURE_BLUE_SIZE' else
      if TEXTURE_ALPHA_SIZE = self then
        Result := 'TEXTURE_ALPHA_SIZE' else
      if TEXTURE_LUMINANCE_SIZE = self then
        Result := 'TEXTURE_LUMINANCE_SIZE' else
      if TEXTURE_INTENSITY_SIZE = self then
        Result := 'TEXTURE_INTENSITY_SIZE' else
      if TEXTURE_PRIORITY = self then
        Result := 'TEXTURE_PRIORITY' else
      if TEXTURE_RESIDENT = self then
        Result := 'TEXTURE_RESIDENT' else
      if TEXTURE_DEPTH = self then
        Result := 'TEXTURE_DEPTH' else
      if TEXTURE_WRAP_R = self then
        Result := 'TEXTURE_WRAP_R' else
      if DETAIL_TEXTURE_LEVEL = self then
        Result := 'DETAIL_TEXTURE_LEVEL' else
      if DETAIL_TEXTURE_MODE = self then
        Result := 'DETAIL_TEXTURE_MODE' else
      if DETAIL_TEXTURE_FUNC_POINTS = self then
        Result := 'DETAIL_TEXTURE_FUNC_POINTS' else
      if SHARPEN_TEXTURE_FUNC_POINTS = self then
        Result := 'SHARPEN_TEXTURE_FUNC_POINTS' else
      if SHADOW_AMBIENT = self then
        Result := 'SHADOW_AMBIENT' else
      if DUAL_TEXTURE_SELECT = self then
        Result := 'DUAL_TEXTURE_SELECT' else
      if QUAD_TEXTURE_SELECT = self then
        Result := 'QUAD_TEXTURE_SELECT' else
      if TEXTURE_4DSIZE = self then
        Result := 'TEXTURE_4DSIZE' else
      if TEXTURE_WRAP_Q = self then
        Result := 'TEXTURE_WRAP_Q' else
      if TEXTURE_MIN_LOD = self then
        Result := 'TEXTURE_MIN_LOD' else
      if TEXTURE_MAX_LOD = self then
        Result := 'TEXTURE_MAX_LOD' else
      if TEXTURE_BASE_LEVEL = self then
        Result := 'TEXTURE_BASE_LEVEL' else
      if TEXTURE_MAX_LEVEL = self then
        Result := 'TEXTURE_MAX_LEVEL' else
      if TEXTURE_FILTER4_SIZE = self then
        Result := 'TEXTURE_FILTER4_SIZE' else
      if TEXTURE_CLIPMAP_CENTER = self then
        Result := 'TEXTURE_CLIPMAP_CENTER' else
      if TEXTURE_CLIPMAP_FRAME = self then
        Result := 'TEXTURE_CLIPMAP_FRAME' else
      if TEXTURE_CLIPMAP_OFFSET = self then
        Result := 'TEXTURE_CLIPMAP_OFFSET' else
      if TEXTURE_CLIPMAP_VIRTUAL_DEPTH = self then
        Result := 'TEXTURE_CLIPMAP_VIRTUAL_DEPTH' else
      if TEXTURE_CLIPMAP_LOD_OFFSET = self then
        Result := 'TEXTURE_CLIPMAP_LOD_OFFSET' else
      if TEXTURE_CLIPMAP_DEPTH = self then
        Result := 'TEXTURE_CLIPMAP_DEPTH' else
      if POST_TEXTURE_FILTER_BIAS = self then
        Result := 'POST_TEXTURE_FILTER_BIAS' else
      if POST_TEXTURE_FILTER_SCALE = self then
        Result := 'POST_TEXTURE_FILTER_SCALE' else
      if TEXTURE_LOD_BIAS_S = self then
        Result := 'TEXTURE_LOD_BIAS_S' else
      if TEXTURE_LOD_BIAS_T = self then
        Result := 'TEXTURE_LOD_BIAS_T' else
      if TEXTURE_LOD_BIAS_R = self then
        Result := 'TEXTURE_LOD_BIAS_R' else
      if GENERATE_MIPMAP = self then
        Result := 'GENERATE_MIPMAP' else
      if TEXTURE_COMPARE = self then
        Result := 'TEXTURE_COMPARE' else
      if TEXTURE_COMPARE_OPERATOR = self then
        Result := 'TEXTURE_COMPARE_OPERATOR' else
      if TEXTURE_LEQUAL_R = self then
        Result := 'TEXTURE_LEQUAL_R' else
      if TEXTURE_GEQUAL_R = self then
        Result := 'TEXTURE_GEQUAL_R' else
      if TEXTURE_MAX_CLAMP_S = self then
        Result := 'TEXTURE_MAX_CLAMP_S' else
      if TEXTURE_MAX_CLAMP_T = self then
        Result := 'TEXTURE_MAX_CLAMP_T' else
      if TEXTURE_MAX_CLAMP_R = self then
        Result := 'TEXTURE_MAX_CLAMP_R' else
      if TEXTURE_MEMORY_LAYOUT = self then
        Result := 'TEXTURE_MEMORY_LAYOUT' else
      if TEXTURE_MAX_ANISOTROPY = self then
        Result := 'TEXTURE_MAX_ANISOTROPY' else
      if TEXTURE_LOD_BIAS = self then
        Result := 'TEXTURE_LOD_BIAS' else
      if TEXTURE_COMPARE_MODE = self then
        Result := 'TEXTURE_COMPARE_MODE' else
      if TEXTURE_COMPARE_FUNC = self then
        Result := 'TEXTURE_COMPARE_FUNC' else
      if TEXTURE_SWIZZLE_R = self then
        Result := 'TEXTURE_SWIZZLE_R' else
      if TEXTURE_SWIZZLE_G = self then
        Result := 'TEXTURE_SWIZZLE_G' else
      if TEXTURE_SWIZZLE_B = self then
        Result := 'TEXTURE_SWIZZLE_B' else
      if TEXTURE_SWIZZLE_A = self then
        Result := 'TEXTURE_SWIZZLE_A' else
      if TEXTURE_SWIZZLE_RGBA = self then
        Result := 'TEXTURE_SWIZZLE_RGBA' else
      if TEXTURE_UNNORMALIZED_COORDINATES = self then
        Result := 'TEXTURE_UNNORMALIZED_COORDINATES' else
      if DEPTH_STENCIL_TEXTURE_MODE = self then
        Result := 'DEPTH_STENCIL_TEXTURE_MODE' else
      if TEXTURE_TILING = self then
        Result := 'TEXTURE_TILING' else
      if TEXTURE_FOVEATED_CUTOFF_DENSITY = self then
        Result := 'TEXTURE_FOVEATED_CUTOFF_DENSITY' else
        Result := $'glTextureParameterName[{self.val}]';
    end;
    
  end;
  
  glTextureStorageMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_STORAGE_SPARSE_BIT: glTextureStorageMask read new glTextureStorageMask(1 shl 0);
    
    public static function operator+(v1, v2: glTextureStorageMask) := new glTextureStorageMask(v1.val or v2.val);
    public static function operator or(v1, v2: glTextureStorageMask) := new glTextureStorageMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glTextureStorageMask; v2: glTextureStorageMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glTextureStorageMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glTextureStorageMask[0]';
        exit;
      end;
      if TEXTURE_STORAGE_SPARSE_BIT in self then
      begin
        res += 'TEXTURE_STORAGE_SPARSE_BIT+';
        left_val := left_val and not TEXTURE_STORAGE_SPARSE_BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'glTextureStorageMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glTextureSwizzle = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ZERO:  glTextureSwizzle read new glTextureSwizzle(0);
    public static property ONE:   glTextureSwizzle read new glTextureSwizzle($0001);
    public static property RED:   glTextureSwizzle read new glTextureSwizzle($1903);
    public static property GREEN: glTextureSwizzle read new glTextureSwizzle($1904);
    public static property BLUE:  glTextureSwizzle read new glTextureSwizzle($1905);
    public static property ALPHA: glTextureSwizzle read new glTextureSwizzle($1906);
    
    public function ToString: string; override;
    begin
      if ZERO = self then
        Result := 'ZERO' else
      if ONE = self then
        Result := 'ONE' else
      if RED = self then
        Result := 'RED' else
      if GREEN = self then
        Result := 'GREEN' else
      if BLUE = self then
        Result := 'BLUE' else
      if ALPHA = self then
        Result := 'ALPHA' else
        Result := $'glTextureSwizzle[{self.val}]';
    end;
    
  end;
  
  glTextureTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_1D:                         glTextureTarget read new glTextureTarget($0DE0);
    public static property TEXTURE_2D:                         glTextureTarget read new glTextureTarget($0DE1);
    public static property PROXY_TEXTURE_1D:                   glTextureTarget read new glTextureTarget($8063);
    public static property PROXY_TEXTURE_2D:                   glTextureTarget read new glTextureTarget($8064);
    public static property TEXTURE_3D:                         glTextureTarget read new glTextureTarget($806F);
    public static property PROXY_TEXTURE_3D:                   glTextureTarget read new glTextureTarget($8070);
    public static property DETAIL_TEXTURE_2D:                  glTextureTarget read new glTextureTarget($8095);
    public static property TEXTURE_4D:                         glTextureTarget read new glTextureTarget($8134);
    public static property PROXY_TEXTURE_4D:                   glTextureTarget read new glTextureTarget($8135);
    public static property TEXTURE_RECTANGLE:                  glTextureTarget read new glTextureTarget($84F5);
    public static property PROXY_TEXTURE_RECTANGLE:            glTextureTarget read new glTextureTarget($84F7);
    public static property TEXTURE_CUBE_MAP:                   glTextureTarget read new glTextureTarget($8513);
    public static property TEXTURE_CUBE_MAP_POSITIVE_X:        glTextureTarget read new glTextureTarget($8515);
    public static property TEXTURE_CUBE_MAP_NEGATIVE_X:        glTextureTarget read new glTextureTarget($8516);
    public static property TEXTURE_CUBE_MAP_POSITIVE_Y:        glTextureTarget read new glTextureTarget($8517);
    public static property TEXTURE_CUBE_MAP_NEGATIVE_Y:        glTextureTarget read new glTextureTarget($8518);
    public static property TEXTURE_CUBE_MAP_POSITIVE_Z:        glTextureTarget read new glTextureTarget($8519);
    public static property TEXTURE_CUBE_MAP_NEGATIVE_Z:        glTextureTarget read new glTextureTarget($851A);
    public static property PROXY_TEXTURE_CUBE_MAP:             glTextureTarget read new glTextureTarget($851B);
    public static property TEXTURE_1D_ARRAY:                   glTextureTarget read new glTextureTarget($8C18);
    public static property PROXY_TEXTURE_1D_ARRAY:             glTextureTarget read new glTextureTarget($8C19);
    public static property TEXTURE_2D_ARRAY:                   glTextureTarget read new glTextureTarget($8C1A);
    public static property PROXY_TEXTURE_2D_ARRAY:             glTextureTarget read new glTextureTarget($8C1B);
    public static property TEXTURE_BUFFER:                     glTextureTarget read new glTextureTarget($8C2A);
    public static property RENDERBUFFER:                       glTextureTarget read new glTextureTarget($8D41);
    public static property TEXTURE_CUBE_MAP_ARRAY:             glTextureTarget read new glTextureTarget($9009);
    public static property PROXY_TEXTURE_CUBE_MAP_ARRAY:       glTextureTarget read new glTextureTarget($900B);
    public static property TEXTURE_2D_MULTISAMPLE:             glTextureTarget read new glTextureTarget($9100);
    public static property PROXY_TEXTURE_2D_MULTISAMPLE:       glTextureTarget read new glTextureTarget($9101);
    public static property TEXTURE_2D_MULTISAMPLE_ARRAY:       glTextureTarget read new glTextureTarget($9102);
    public static property PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: glTextureTarget read new glTextureTarget($9103);
    
    public function ToString: string; override;
    begin
      if TEXTURE_1D = self then
        Result := 'TEXTURE_1D' else
      if TEXTURE_2D = self then
        Result := 'TEXTURE_2D' else
      if PROXY_TEXTURE_1D = self then
        Result := 'PROXY_TEXTURE_1D' else
      if PROXY_TEXTURE_2D = self then
        Result := 'PROXY_TEXTURE_2D' else
      if TEXTURE_3D = self then
        Result := 'TEXTURE_3D' else
      if PROXY_TEXTURE_3D = self then
        Result := 'PROXY_TEXTURE_3D' else
      if DETAIL_TEXTURE_2D = self then
        Result := 'DETAIL_TEXTURE_2D' else
      if TEXTURE_4D = self then
        Result := 'TEXTURE_4D' else
      if PROXY_TEXTURE_4D = self then
        Result := 'PROXY_TEXTURE_4D' else
      if TEXTURE_RECTANGLE = self then
        Result := 'TEXTURE_RECTANGLE' else
      if PROXY_TEXTURE_RECTANGLE = self then
        Result := 'PROXY_TEXTURE_RECTANGLE' else
      if TEXTURE_CUBE_MAP = self then
        Result := 'TEXTURE_CUBE_MAP' else
      if TEXTURE_CUBE_MAP_POSITIVE_X = self then
        Result := 'TEXTURE_CUBE_MAP_POSITIVE_X' else
      if TEXTURE_CUBE_MAP_NEGATIVE_X = self then
        Result := 'TEXTURE_CUBE_MAP_NEGATIVE_X' else
      if TEXTURE_CUBE_MAP_POSITIVE_Y = self then
        Result := 'TEXTURE_CUBE_MAP_POSITIVE_Y' else
      if TEXTURE_CUBE_MAP_NEGATIVE_Y = self then
        Result := 'TEXTURE_CUBE_MAP_NEGATIVE_Y' else
      if TEXTURE_CUBE_MAP_POSITIVE_Z = self then
        Result := 'TEXTURE_CUBE_MAP_POSITIVE_Z' else
      if TEXTURE_CUBE_MAP_NEGATIVE_Z = self then
        Result := 'TEXTURE_CUBE_MAP_NEGATIVE_Z' else
      if PROXY_TEXTURE_CUBE_MAP = self then
        Result := 'PROXY_TEXTURE_CUBE_MAP' else
      if TEXTURE_1D_ARRAY = self then
        Result := 'TEXTURE_1D_ARRAY' else
      if PROXY_TEXTURE_1D_ARRAY = self then
        Result := 'PROXY_TEXTURE_1D_ARRAY' else
      if TEXTURE_2D_ARRAY = self then
        Result := 'TEXTURE_2D_ARRAY' else
      if PROXY_TEXTURE_2D_ARRAY = self then
        Result := 'PROXY_TEXTURE_2D_ARRAY' else
      if TEXTURE_BUFFER = self then
        Result := 'TEXTURE_BUFFER' else
      if RENDERBUFFER = self then
        Result := 'RENDERBUFFER' else
      if TEXTURE_CUBE_MAP_ARRAY = self then
        Result := 'TEXTURE_CUBE_MAP_ARRAY' else
      if PROXY_TEXTURE_CUBE_MAP_ARRAY = self then
        Result := 'PROXY_TEXTURE_CUBE_MAP_ARRAY' else
      if TEXTURE_2D_MULTISAMPLE = self then
        Result := 'TEXTURE_2D_MULTISAMPLE' else
      if PROXY_TEXTURE_2D_MULTISAMPLE = self then
        Result := 'PROXY_TEXTURE_2D_MULTISAMPLE' else
      if TEXTURE_2D_MULTISAMPLE_ARRAY = self then
        Result := 'TEXTURE_2D_MULTISAMPLE_ARRAY' else
      if PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY = self then
        Result := 'PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY' else
        Result := $'glTextureTarget[{self.val}]';
    end;
    
  end;
  
  glTextureUnit = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE0:  glTextureUnit read new glTextureUnit($84C0);
    public static property TEXTURE1:  glTextureUnit read new glTextureUnit($84C1);
    public static property TEXTURE2:  glTextureUnit read new glTextureUnit($84C2);
    public static property TEXTURE3:  glTextureUnit read new glTextureUnit($84C3);
    public static property TEXTURE4:  glTextureUnit read new glTextureUnit($84C4);
    public static property TEXTURE5:  glTextureUnit read new glTextureUnit($84C5);
    public static property TEXTURE6:  glTextureUnit read new glTextureUnit($84C6);
    public static property TEXTURE7:  glTextureUnit read new glTextureUnit($84C7);
    public static property TEXTURE8:  glTextureUnit read new glTextureUnit($84C8);
    public static property TEXTURE9:  glTextureUnit read new glTextureUnit($84C9);
    public static property TEXTURE10: glTextureUnit read new glTextureUnit($84CA);
    public static property TEXTURE11: glTextureUnit read new glTextureUnit($84CB);
    public static property TEXTURE12: glTextureUnit read new glTextureUnit($84CC);
    public static property TEXTURE13: glTextureUnit read new glTextureUnit($84CD);
    public static property TEXTURE14: glTextureUnit read new glTextureUnit($84CE);
    public static property TEXTURE15: glTextureUnit read new glTextureUnit($84CF);
    public static property TEXTURE16: glTextureUnit read new glTextureUnit($84D0);
    public static property TEXTURE17: glTextureUnit read new glTextureUnit($84D1);
    public static property TEXTURE18: glTextureUnit read new glTextureUnit($84D2);
    public static property TEXTURE19: glTextureUnit read new glTextureUnit($84D3);
    public static property TEXTURE20: glTextureUnit read new glTextureUnit($84D4);
    public static property TEXTURE21: glTextureUnit read new glTextureUnit($84D5);
    public static property TEXTURE22: glTextureUnit read new glTextureUnit($84D6);
    public static property TEXTURE23: glTextureUnit read new glTextureUnit($84D7);
    public static property TEXTURE24: glTextureUnit read new glTextureUnit($84D8);
    public static property TEXTURE25: glTextureUnit read new glTextureUnit($84D9);
    public static property TEXTURE26: glTextureUnit read new glTextureUnit($84DA);
    public static property TEXTURE27: glTextureUnit read new glTextureUnit($84DB);
    public static property TEXTURE28: glTextureUnit read new glTextureUnit($84DC);
    public static property TEXTURE29: glTextureUnit read new glTextureUnit($84DD);
    public static property TEXTURE30: glTextureUnit read new glTextureUnit($84DE);
    public static property TEXTURE31: glTextureUnit read new glTextureUnit($84DF);
    
    public function ToString: string; override;
    begin
      if TEXTURE0 = self then
        Result := 'TEXTURE0' else
      if TEXTURE1 = self then
        Result := 'TEXTURE1' else
      if TEXTURE2 = self then
        Result := 'TEXTURE2' else
      if TEXTURE3 = self then
        Result := 'TEXTURE3' else
      if TEXTURE4 = self then
        Result := 'TEXTURE4' else
      if TEXTURE5 = self then
        Result := 'TEXTURE5' else
      if TEXTURE6 = self then
        Result := 'TEXTURE6' else
      if TEXTURE7 = self then
        Result := 'TEXTURE7' else
      if TEXTURE8 = self then
        Result := 'TEXTURE8' else
      if TEXTURE9 = self then
        Result := 'TEXTURE9' else
      if TEXTURE10 = self then
        Result := 'TEXTURE10' else
      if TEXTURE11 = self then
        Result := 'TEXTURE11' else
      if TEXTURE12 = self then
        Result := 'TEXTURE12' else
      if TEXTURE13 = self then
        Result := 'TEXTURE13' else
      if TEXTURE14 = self then
        Result := 'TEXTURE14' else
      if TEXTURE15 = self then
        Result := 'TEXTURE15' else
      if TEXTURE16 = self then
        Result := 'TEXTURE16' else
      if TEXTURE17 = self then
        Result := 'TEXTURE17' else
      if TEXTURE18 = self then
        Result := 'TEXTURE18' else
      if TEXTURE19 = self then
        Result := 'TEXTURE19' else
      if TEXTURE20 = self then
        Result := 'TEXTURE20' else
      if TEXTURE21 = self then
        Result := 'TEXTURE21' else
      if TEXTURE22 = self then
        Result := 'TEXTURE22' else
      if TEXTURE23 = self then
        Result := 'TEXTURE23' else
      if TEXTURE24 = self then
        Result := 'TEXTURE24' else
      if TEXTURE25 = self then
        Result := 'TEXTURE25' else
      if TEXTURE26 = self then
        Result := 'TEXTURE26' else
      if TEXTURE27 = self then
        Result := 'TEXTURE27' else
      if TEXTURE28 = self then
        Result := 'TEXTURE28' else
      if TEXTURE29 = self then
        Result := 'TEXTURE29' else
      if TEXTURE30 = self then
        Result := 'TEXTURE30' else
      if TEXTURE31 = self then
        Result := 'TEXTURE31' else
        Result := $'glTextureUnit[{self.val}]';
    end;
    
  end;
  
  glTextureWrapMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LINEAR_MIPMAP_LINEAR: glTextureWrapMode read new glTextureWrapMode($2703);
    public static property CLAMP:                glTextureWrapMode read new glTextureWrapMode($2900);
    public static property &REPEAT:              glTextureWrapMode read new glTextureWrapMode($2901);
    public static property CLAMP_TO_BORDER:      glTextureWrapMode read new glTextureWrapMode($812D);
    public static property CLAMP_TO_EDGE:        glTextureWrapMode read new glTextureWrapMode($812F);
    public static property MIRRORED_REPEAT:      glTextureWrapMode read new glTextureWrapMode($8370);
    
    public function ToString: string; override;
    begin
      if LINEAR_MIPMAP_LINEAR = self then
        Result := 'LINEAR_MIPMAP_LINEAR' else
      if CLAMP = self then
        Result := 'CLAMP' else
      if &REPEAT = self then
        Result := 'REPEAT' else
      if CLAMP_TO_BORDER = self then
        Result := 'CLAMP_TO_BORDER' else
      if CLAMP_TO_EDGE = self then
        Result := 'CLAMP_TO_EDGE' else
      if MIRRORED_REPEAT = self then
        Result := 'MIRRORED_REPEAT' else
        Result := $'glTextureWrapMode[{self.val}]';
    end;
    
  end;
  
  glTransformFeedbackBufferMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property INTERLEAVED_ATTRIBS: glTransformFeedbackBufferMode read new glTransformFeedbackBufferMode($8C8C);
    public static property SEPARATE_ATTRIBS:    glTransformFeedbackBufferMode read new glTransformFeedbackBufferMode($8C8D);
    
    public function ToString: string; override;
    begin
      if INTERLEAVED_ATTRIBS = self then
        Result := 'INTERLEAVED_ATTRIBS' else
      if SEPARATE_ATTRIBS = self then
        Result := 'SEPARATE_ATTRIBS' else
        Result := $'glTransformFeedbackBufferMode[{self.val}]';
    end;
    
  end;
  
  glTransformFeedbackPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TRANSFORM_FEEDBACK_BUFFER_START:   glTransformFeedbackPName read new glTransformFeedbackPName($8C84);
    public static property TRANSFORM_FEEDBACK_BUFFER_SIZE:    glTransformFeedbackPName read new glTransformFeedbackPName($8C85);
    public static property TRANSFORM_FEEDBACK_BUFFER_BINDING: glTransformFeedbackPName read new glTransformFeedbackPName($8C8F);
    public static property TRANSFORM_FEEDBACK_PAUSED:         glTransformFeedbackPName read new glTransformFeedbackPName($8E23);
    public static property TRANSFORM_FEEDBACK_ACTIVE:         glTransformFeedbackPName read new glTransformFeedbackPName($8E24);
    
    public function ToString: string; override;
    begin
      if TRANSFORM_FEEDBACK_BUFFER_START = self then
        Result := 'TRANSFORM_FEEDBACK_BUFFER_START' else
      if TRANSFORM_FEEDBACK_BUFFER_SIZE = self then
        Result := 'TRANSFORM_FEEDBACK_BUFFER_SIZE' else
      if TRANSFORM_FEEDBACK_BUFFER_BINDING = self then
        Result := 'TRANSFORM_FEEDBACK_BUFFER_BINDING' else
      if TRANSFORM_FEEDBACK_PAUSED = self then
        Result := 'TRANSFORM_FEEDBACK_PAUSED' else
      if TRANSFORM_FEEDBACK_ACTIVE = self then
        Result := 'TRANSFORM_FEEDBACK_ACTIVE' else
        Result := $'glTransformFeedbackPName[{self.val}]';
    end;
    
  end;
  
  glTransformFeedbackToken = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property NEXT_BUFFER:      glTransformFeedbackToken read new glTransformFeedbackToken(-2);
    public static property SKIP_COMPONENTS4: glTransformFeedbackToken read new glTransformFeedbackToken(-3);
    public static property SKIP_COMPONENTS3: glTransformFeedbackToken read new glTransformFeedbackToken(-4);
    public static property SKIP_COMPONENTS2: glTransformFeedbackToken read new glTransformFeedbackToken(-5);
    public static property SKIP_COMPONENTS1: glTransformFeedbackToken read new glTransformFeedbackToken(-6);
    
    public function ToString: string; override;
    begin
      if NEXT_BUFFER = self then
        Result := 'NEXT_BUFFER' else
      if SKIP_COMPONENTS4 = self then
        Result := 'SKIP_COMPONENTS4' else
      if SKIP_COMPONENTS3 = self then
        Result := 'SKIP_COMPONENTS3' else
      if SKIP_COMPONENTS2 = self then
        Result := 'SKIP_COMPONENTS2' else
      if SKIP_COMPONENTS1 = self then
        Result := 'SKIP_COMPONENTS1' else
        Result := $'glTransformFeedbackToken[{self.val}]';
    end;
    
  end;
  
  glTriangleFace = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRONT:          glTriangleFace read new glTriangleFace($0404);
    public static property BACK:           glTriangleFace read new glTriangleFace($0405);
    public static property FRONT_AND_BACK: glTriangleFace read new glTriangleFace($0408);
    
    public function ToString: string; override;
    begin
      if FRONT = self then
        Result := 'FRONT' else
      if BACK = self then
        Result := 'BACK' else
      if FRONT_AND_BACK = self then
        Result := 'FRONT_AND_BACK' else
        Result := $'glTriangleFace[{self.val}]';
    end;
    
  end;
  
  glTriangleList = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RESTART:        glTriangleList read new glTriangleList($0001);
    public static property REPLACE_MIDDLE: glTriangleList read new glTriangleList($0002);
    public static property REPLACE_OLDEST: glTriangleList read new glTriangleList($0003);
    
    public function ToString: string; override;
    begin
      if RESTART = self then
        Result := 'RESTART' else
      if REPLACE_MIDDLE = self then
        Result := 'REPLACE_MIDDLE' else
      if REPLACE_OLDEST = self then
        Result := 'REPLACE_OLDEST' else
        Result := $'glTriangleList[{self.val}]';
    end;
    
  end;
  
  glUniformBlockPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER:    glUniformBlockPName read new glUniformBlockPName($84F0);
    public static property UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER: glUniformBlockPName read new glUniformBlockPName($84F1);
    public static property UNIFORM_BLOCK_BINDING:                              glUniformBlockPName read new glUniformBlockPName($8A3F);
    public static property UNIFORM_BLOCK_DATA_SIZE:                            glUniformBlockPName read new glUniformBlockPName($8A40);
    public static property UNIFORM_BLOCK_NAME_LENGTH:                          glUniformBlockPName read new glUniformBlockPName($8A41);
    public static property UNIFORM_BLOCK_ACTIVE_UNIFORMS:                      glUniformBlockPName read new glUniformBlockPName($8A42);
    public static property UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES:               glUniformBlockPName read new glUniformBlockPName($8A43);
    public static property UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER:          glUniformBlockPName read new glUniformBlockPName($8A44);
    public static property UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER:        glUniformBlockPName read new glUniformBlockPName($8A45);
    public static property UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER:        glUniformBlockPName read new glUniformBlockPName($8A46);
    public static property UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER:         glUniformBlockPName read new glUniformBlockPName($90EC);
    
    public function ToString: string; override;
    begin
      if UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER = self then
        Result := 'UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER' else
      if UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER = self then
        Result := 'UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER' else
      if UNIFORM_BLOCK_BINDING = self then
        Result := 'UNIFORM_BLOCK_BINDING' else
      if UNIFORM_BLOCK_DATA_SIZE = self then
        Result := 'UNIFORM_BLOCK_DATA_SIZE' else
      if UNIFORM_BLOCK_NAME_LENGTH = self then
        Result := 'UNIFORM_BLOCK_NAME_LENGTH' else
      if UNIFORM_BLOCK_ACTIVE_UNIFORMS = self then
        Result := 'UNIFORM_BLOCK_ACTIVE_UNIFORMS' else
      if UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = self then
        Result := 'UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES' else
      if UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = self then
        Result := 'UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER' else
      if UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER = self then
        Result := 'UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER' else
      if UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = self then
        Result := 'UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER' else
      if UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER = self then
        Result := 'UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER' else
        Result := $'glUniformBlockPName[{self.val}]';
    end;
    
  end;
  
  glUniformPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNIFORM_TYPE:                        glUniformPName read new glUniformPName($8A37);
    public static property UNIFORM_SIZE:                        glUniformPName read new glUniformPName($8A38);
    public static property UNIFORM_NAME_LENGTH:                 glUniformPName read new glUniformPName($8A39);
    public static property UNIFORM_BLOCK_INDEX:                 glUniformPName read new glUniformPName($8A3A);
    public static property UNIFORM_OFFSET:                      glUniformPName read new glUniformPName($8A3B);
    public static property UNIFORM_ARRAY_STRIDE:                glUniformPName read new glUniformPName($8A3C);
    public static property UNIFORM_MATRIX_STRIDE:               glUniformPName read new glUniformPName($8A3D);
    public static property UNIFORM_IS_ROW_MAJOR:                glUniformPName read new glUniformPName($8A3E);
    public static property UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX: glUniformPName read new glUniformPName($92DA);
    
    public function ToString: string; override;
    begin
      if UNIFORM_TYPE = self then
        Result := 'UNIFORM_TYPE' else
      if UNIFORM_SIZE = self then
        Result := 'UNIFORM_SIZE' else
      if UNIFORM_NAME_LENGTH = self then
        Result := 'UNIFORM_NAME_LENGTH' else
      if UNIFORM_BLOCK_INDEX = self then
        Result := 'UNIFORM_BLOCK_INDEX' else
      if UNIFORM_OFFSET = self then
        Result := 'UNIFORM_OFFSET' else
      if UNIFORM_ARRAY_STRIDE = self then
        Result := 'UNIFORM_ARRAY_STRIDE' else
      if UNIFORM_MATRIX_STRIDE = self then
        Result := 'UNIFORM_MATRIX_STRIDE' else
      if UNIFORM_IS_ROW_MAJOR = self then
        Result := 'UNIFORM_IS_ROW_MAJOR' else
      if UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX = self then
        Result := 'UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX' else
        Result := $'glUniformPName[{self.val}]';
    end;
    
  end;
  
  glUniformType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property INT:                                       glUniformType read new glUniformType($1404);
    public static property UNSIGNED_INT:                              glUniformType read new glUniformType($1405);
    public static property FLOAT:                                     glUniformType read new glUniformType($1406);
    public static property DOUBLE:                                    glUniformType read new glUniformType($140A);
    public static property FLOAT_VEC2:                                glUniformType read new glUniformType($8B50);
    public static property FLOAT_VEC3:                                glUniformType read new glUniformType($8B51);
    public static property FLOAT_VEC4:                                glUniformType read new glUniformType($8B52);
    public static property INT_VEC2:                                  glUniformType read new glUniformType($8B53);
    public static property INT_VEC3:                                  glUniformType read new glUniformType($8B54);
    public static property INT_VEC4:                                  glUniformType read new glUniformType($8B55);
    public static property BOOL:                                      glUniformType read new glUniformType($8B56);
    public static property BOOL_VEC2:                                 glUniformType read new glUniformType($8B57);
    public static property BOOL_VEC3:                                 glUniformType read new glUniformType($8B58);
    public static property BOOL_VEC4:                                 glUniformType read new glUniformType($8B59);
    public static property FLOAT_MAT2:                                glUniformType read new glUniformType($8B5A);
    public static property FLOAT_MAT3:                                glUniformType read new glUniformType($8B5B);
    public static property FLOAT_MAT4:                                glUniformType read new glUniformType($8B5C);
    public static property SAMPLER_1D:                                glUniformType read new glUniformType($8B5D);
    public static property SAMPLER_2D:                                glUniformType read new glUniformType($8B5E);
    public static property SAMPLER_3D:                                glUniformType read new glUniformType($8B5F);
    public static property SAMPLER_CUBE:                              glUniformType read new glUniformType($8B60);
    public static property SAMPLER_1D_SHADOW:                         glUniformType read new glUniformType($8B61);
    public static property SAMPLER_2D_SHADOW:                         glUniformType read new glUniformType($8B62);
    public static property SAMPLER_2D_RECT:                           glUniformType read new glUniformType($8B63);
    public static property SAMPLER_2D_RECT_SHADOW:                    glUniformType read new glUniformType($8B64);
    public static property FLOAT_MAT2x3:                              glUniformType read new glUniformType($8B65);
    public static property FLOAT_MAT2x4:                              glUniformType read new glUniformType($8B66);
    public static property FLOAT_MAT3x2:                              glUniformType read new glUniformType($8B67);
    public static property FLOAT_MAT3x4:                              glUniformType read new glUniformType($8B68);
    public static property FLOAT_MAT4x2:                              glUniformType read new glUniformType($8B69);
    public static property FLOAT_MAT4x3:                              glUniformType read new glUniformType($8B6A);
    public static property SAMPLER_1D_ARRAY:                          glUniformType read new glUniformType($8DC0);
    public static property SAMPLER_2D_ARRAY:                          glUniformType read new glUniformType($8DC1);
    public static property SAMPLER_BUFFER:                            glUniformType read new glUniformType($8DC2);
    public static property SAMPLER_1D_ARRAY_SHADOW:                   glUniformType read new glUniformType($8DC3);
    public static property SAMPLER_2D_ARRAY_SHADOW:                   glUniformType read new glUniformType($8DC4);
    public static property SAMPLER_CUBE_SHADOW:                       glUniformType read new glUniformType($8DC5);
    public static property UNSIGNED_INT_VEC2:                         glUniformType read new glUniformType($8DC6);
    public static property UNSIGNED_INT_VEC3:                         glUniformType read new glUniformType($8DC7);
    public static property UNSIGNED_INT_VEC4:                         glUniformType read new glUniformType($8DC8);
    public static property INT_SAMPLER_1D:                            glUniformType read new glUniformType($8DC9);
    public static property INT_SAMPLER_2D:                            glUniformType read new glUniformType($8DCA);
    public static property INT_SAMPLER_3D:                            glUniformType read new glUniformType($8DCB);
    public static property INT_SAMPLER_CUBE:                          glUniformType read new glUniformType($8DCC);
    public static property INT_SAMPLER_2D_RECT:                       glUniformType read new glUniformType($8DCD);
    public static property INT_SAMPLER_1D_ARRAY:                      glUniformType read new glUniformType($8DCE);
    public static property INT_SAMPLER_2D_ARRAY:                      glUniformType read new glUniformType($8DCF);
    public static property INT_SAMPLER_BUFFER:                        glUniformType read new glUniformType($8DD0);
    public static property UNSIGNED_INT_SAMPLER_1D:                   glUniformType read new glUniformType($8DD1);
    public static property UNSIGNED_INT_SAMPLER_2D:                   glUniformType read new glUniformType($8DD2);
    public static property UNSIGNED_INT_SAMPLER_3D:                   glUniformType read new glUniformType($8DD3);
    public static property UNSIGNED_INT_SAMPLER_CUBE:                 glUniformType read new glUniformType($8DD4);
    public static property UNSIGNED_INT_SAMPLER_2D_RECT:              glUniformType read new glUniformType($8DD5);
    public static property UNSIGNED_INT_SAMPLER_1D_ARRAY:             glUniformType read new glUniformType($8DD6);
    public static property UNSIGNED_INT_SAMPLER_2D_ARRAY:             glUniformType read new glUniformType($8DD7);
    public static property UNSIGNED_INT_SAMPLER_BUFFER:               glUniformType read new glUniformType($8DD8);
    public static property DOUBLE_MAT2:                               glUniformType read new glUniformType($8F46);
    public static property DOUBLE_MAT3:                               glUniformType read new glUniformType($8F47);
    public static property DOUBLE_MAT4:                               glUniformType read new glUniformType($8F48);
    public static property DOUBLE_MAT2x3:                             glUniformType read new glUniformType($8F49);
    public static property DOUBLE_MAT2x4:                             glUniformType read new glUniformType($8F4A);
    public static property DOUBLE_MAT3x2:                             glUniformType read new glUniformType($8F4B);
    public static property DOUBLE_MAT3x4:                             glUniformType read new glUniformType($8F4C);
    public static property DOUBLE_MAT4x2:                             glUniformType read new glUniformType($8F4D);
    public static property DOUBLE_MAT4x3:                             glUniformType read new glUniformType($8F4E);
    public static property DOUBLE_VEC2:                               glUniformType read new glUniformType($8FFC);
    public static property DOUBLE_VEC3:                               glUniformType read new glUniformType($8FFD);
    public static property DOUBLE_VEC4:                               glUniformType read new glUniformType($8FFE);
    public static property SAMPLER_CUBE_MAP_ARRAY:                    glUniformType read new glUniformType($900C);
    public static property SAMPLER_CUBE_MAP_ARRAY_SHADOW:             glUniformType read new glUniformType($900D);
    public static property INT_SAMPLER_CUBE_MAP_ARRAY:                glUniformType read new glUniformType($900E);
    public static property UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY:       glUniformType read new glUniformType($900F);
    public static property SAMPLER_2D_MULTISAMPLE:                    glUniformType read new glUniformType($9108);
    public static property INT_SAMPLER_2D_MULTISAMPLE:                glUniformType read new glUniformType($9109);
    public static property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE:       glUniformType read new glUniformType($910A);
    public static property SAMPLER_2D_MULTISAMPLE_ARRAY:              glUniformType read new glUniformType($910B);
    public static property INT_SAMPLER_2D_MULTISAMPLE_ARRAY:          glUniformType read new glUniformType($910C);
    public static property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: glUniformType read new glUniformType($910D);
    
    public function ToString: string; override;
    begin
      if INT = self then
        Result := 'INT' else
      if UNSIGNED_INT = self then
        Result := 'UNSIGNED_INT' else
      if FLOAT = self then
        Result := 'FLOAT' else
      if DOUBLE = self then
        Result := 'DOUBLE' else
      if FLOAT_VEC2 = self then
        Result := 'FLOAT_VEC2' else
      if FLOAT_VEC3 = self then
        Result := 'FLOAT_VEC3' else
      if FLOAT_VEC4 = self then
        Result := 'FLOAT_VEC4' else
      if INT_VEC2 = self then
        Result := 'INT_VEC2' else
      if INT_VEC3 = self then
        Result := 'INT_VEC3' else
      if INT_VEC4 = self then
        Result := 'INT_VEC4' else
      if BOOL = self then
        Result := 'BOOL' else
      if BOOL_VEC2 = self then
        Result := 'BOOL_VEC2' else
      if BOOL_VEC3 = self then
        Result := 'BOOL_VEC3' else
      if BOOL_VEC4 = self then
        Result := 'BOOL_VEC4' else
      if FLOAT_MAT2 = self then
        Result := 'FLOAT_MAT2' else
      if FLOAT_MAT3 = self then
        Result := 'FLOAT_MAT3' else
      if FLOAT_MAT4 = self then
        Result := 'FLOAT_MAT4' else
      if SAMPLER_1D = self then
        Result := 'SAMPLER_1D' else
      if SAMPLER_2D = self then
        Result := 'SAMPLER_2D' else
      if SAMPLER_3D = self then
        Result := 'SAMPLER_3D' else
      if SAMPLER_CUBE = self then
        Result := 'SAMPLER_CUBE' else
      if SAMPLER_1D_SHADOW = self then
        Result := 'SAMPLER_1D_SHADOW' else
      if SAMPLER_2D_SHADOW = self then
        Result := 'SAMPLER_2D_SHADOW' else
      if SAMPLER_2D_RECT = self then
        Result := 'SAMPLER_2D_RECT' else
      if SAMPLER_2D_RECT_SHADOW = self then
        Result := 'SAMPLER_2D_RECT_SHADOW' else
      if FLOAT_MAT2x3 = self then
        Result := 'FLOAT_MAT2x3' else
      if FLOAT_MAT2x4 = self then
        Result := 'FLOAT_MAT2x4' else
      if FLOAT_MAT3x2 = self then
        Result := 'FLOAT_MAT3x2' else
      if FLOAT_MAT3x4 = self then
        Result := 'FLOAT_MAT3x4' else
      if FLOAT_MAT4x2 = self then
        Result := 'FLOAT_MAT4x2' else
      if FLOAT_MAT4x3 = self then
        Result := 'FLOAT_MAT4x3' else
      if SAMPLER_1D_ARRAY = self then
        Result := 'SAMPLER_1D_ARRAY' else
      if SAMPLER_2D_ARRAY = self then
        Result := 'SAMPLER_2D_ARRAY' else
      if SAMPLER_BUFFER = self then
        Result := 'SAMPLER_BUFFER' else
      if SAMPLER_1D_ARRAY_SHADOW = self then
        Result := 'SAMPLER_1D_ARRAY_SHADOW' else
      if SAMPLER_2D_ARRAY_SHADOW = self then
        Result := 'SAMPLER_2D_ARRAY_SHADOW' else
      if SAMPLER_CUBE_SHADOW = self then
        Result := 'SAMPLER_CUBE_SHADOW' else
      if UNSIGNED_INT_VEC2 = self then
        Result := 'UNSIGNED_INT_VEC2' else
      if UNSIGNED_INT_VEC3 = self then
        Result := 'UNSIGNED_INT_VEC3' else
      if UNSIGNED_INT_VEC4 = self then
        Result := 'UNSIGNED_INT_VEC4' else
      if INT_SAMPLER_1D = self then
        Result := 'INT_SAMPLER_1D' else
      if INT_SAMPLER_2D = self then
        Result := 'INT_SAMPLER_2D' else
      if INT_SAMPLER_3D = self then
        Result := 'INT_SAMPLER_3D' else
      if INT_SAMPLER_CUBE = self then
        Result := 'INT_SAMPLER_CUBE' else
      if INT_SAMPLER_2D_RECT = self then
        Result := 'INT_SAMPLER_2D_RECT' else
      if INT_SAMPLER_1D_ARRAY = self then
        Result := 'INT_SAMPLER_1D_ARRAY' else
      if INT_SAMPLER_2D_ARRAY = self then
        Result := 'INT_SAMPLER_2D_ARRAY' else
      if INT_SAMPLER_BUFFER = self then
        Result := 'INT_SAMPLER_BUFFER' else
      if UNSIGNED_INT_SAMPLER_1D = self then
        Result := 'UNSIGNED_INT_SAMPLER_1D' else
      if UNSIGNED_INT_SAMPLER_2D = self then
        Result := 'UNSIGNED_INT_SAMPLER_2D' else
      if UNSIGNED_INT_SAMPLER_3D = self then
        Result := 'UNSIGNED_INT_SAMPLER_3D' else
      if UNSIGNED_INT_SAMPLER_CUBE = self then
        Result := 'UNSIGNED_INT_SAMPLER_CUBE' else
      if UNSIGNED_INT_SAMPLER_2D_RECT = self then
        Result := 'UNSIGNED_INT_SAMPLER_2D_RECT' else
      if UNSIGNED_INT_SAMPLER_1D_ARRAY = self then
        Result := 'UNSIGNED_INT_SAMPLER_1D_ARRAY' else
      if UNSIGNED_INT_SAMPLER_2D_ARRAY = self then
        Result := 'UNSIGNED_INT_SAMPLER_2D_ARRAY' else
      if UNSIGNED_INT_SAMPLER_BUFFER = self then
        Result := 'UNSIGNED_INT_SAMPLER_BUFFER' else
      if DOUBLE_MAT2 = self then
        Result := 'DOUBLE_MAT2' else
      if DOUBLE_MAT3 = self then
        Result := 'DOUBLE_MAT3' else
      if DOUBLE_MAT4 = self then
        Result := 'DOUBLE_MAT4' else
      if DOUBLE_MAT2x3 = self then
        Result := 'DOUBLE_MAT2x3' else
      if DOUBLE_MAT2x4 = self then
        Result := 'DOUBLE_MAT2x4' else
      if DOUBLE_MAT3x2 = self then
        Result := 'DOUBLE_MAT3x2' else
      if DOUBLE_MAT3x4 = self then
        Result := 'DOUBLE_MAT3x4' else
      if DOUBLE_MAT4x2 = self then
        Result := 'DOUBLE_MAT4x2' else
      if DOUBLE_MAT4x3 = self then
        Result := 'DOUBLE_MAT4x3' else
      if DOUBLE_VEC2 = self then
        Result := 'DOUBLE_VEC2' else
      if DOUBLE_VEC3 = self then
        Result := 'DOUBLE_VEC3' else
      if DOUBLE_VEC4 = self then
        Result := 'DOUBLE_VEC4' else
      if SAMPLER_CUBE_MAP_ARRAY = self then
        Result := 'SAMPLER_CUBE_MAP_ARRAY' else
      if SAMPLER_CUBE_MAP_ARRAY_SHADOW = self then
        Result := 'SAMPLER_CUBE_MAP_ARRAY_SHADOW' else
      if INT_SAMPLER_CUBE_MAP_ARRAY = self then
        Result := 'INT_SAMPLER_CUBE_MAP_ARRAY' else
      if UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY = self then
        Result := 'UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY' else
      if SAMPLER_2D_MULTISAMPLE = self then
        Result := 'SAMPLER_2D_MULTISAMPLE' else
      if INT_SAMPLER_2D_MULTISAMPLE = self then
        Result := 'INT_SAMPLER_2D_MULTISAMPLE' else
      if UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = self then
        Result := 'UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE' else
      if SAMPLER_2D_MULTISAMPLE_ARRAY = self then
        Result := 'SAMPLER_2D_MULTISAMPLE_ARRAY' else
      if INT_SAMPLER_2D_MULTISAMPLE_ARRAY = self then
        Result := 'INT_SAMPLER_2D_MULTISAMPLE_ARRAY' else
      if UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = self then
        Result := 'UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY' else
        Result := $'glUniformType[{self.val}]';
    end;
    
  end;
  
  glUseProgramStageMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_SHADER_BIT:          glUseProgramStageMask read new glUseProgramStageMask(1 shl 0);
    public static property FRAGMENT_SHADER_BIT:        glUseProgramStageMask read new glUseProgramStageMask(1 shl 1);
    public static property GEOMETRY_SHADER_BIT:        glUseProgramStageMask read new glUseProgramStageMask(1 shl 2);
    public static property TESS_CONTROL_SHADER_BIT:    glUseProgramStageMask read new glUseProgramStageMask(1 shl 3);
    public static property TESS_EVALUATION_SHADER_BIT: glUseProgramStageMask read new glUseProgramStageMask(1 shl 4);
    public static property COMPUTE_SHADER_BIT:         glUseProgramStageMask read new glUseProgramStageMask(1 shl 5);
    public static property MESH_SHADER_BIT:            glUseProgramStageMask read new glUseProgramStageMask(1 shl 6);
    public static property TASK_SHADER_BIT:            glUseProgramStageMask read new glUseProgramStageMask(1 shl 7);
    public static property ALL_SHADER_BITS:            glUseProgramStageMask read new glUseProgramStageMask($FFFFFFFF);
    
    public static function operator+(v1, v2: glUseProgramStageMask) := new glUseProgramStageMask(v1.val or v2.val);
    public static function operator or(v1, v2: glUseProgramStageMask) := new glUseProgramStageMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glUseProgramStageMask; v2: glUseProgramStageMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glUseProgramStageMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glUseProgramStageMask[0]';
        exit;
      end;
      if VERTEX_SHADER_BIT in self then
      begin
        res += 'VERTEX_SHADER_BIT+';
        left_val := left_val and not VERTEX_SHADER_BIT.val;
      end;
      if FRAGMENT_SHADER_BIT in self then
      begin
        res += 'FRAGMENT_SHADER_BIT+';
        left_val := left_val and not FRAGMENT_SHADER_BIT.val;
      end;
      if GEOMETRY_SHADER_BIT in self then
      begin
        res += 'GEOMETRY_SHADER_BIT+';
        left_val := left_val and not GEOMETRY_SHADER_BIT.val;
      end;
      if TESS_CONTROL_SHADER_BIT in self then
      begin
        res += 'TESS_CONTROL_SHADER_BIT+';
        left_val := left_val and not TESS_CONTROL_SHADER_BIT.val;
      end;
      if TESS_EVALUATION_SHADER_BIT in self then
      begin
        res += 'TESS_EVALUATION_SHADER_BIT+';
        left_val := left_val and not TESS_EVALUATION_SHADER_BIT.val;
      end;
      if COMPUTE_SHADER_BIT in self then
      begin
        res += 'COMPUTE_SHADER_BIT+';
        left_val := left_val and not COMPUTE_SHADER_BIT.val;
      end;
      if MESH_SHADER_BIT in self then
      begin
        res += 'MESH_SHADER_BIT+';
        left_val := left_val and not MESH_SHADER_BIT.val;
      end;
      if TASK_SHADER_BIT in self then
      begin
        res += 'TASK_SHADER_BIT+';
        left_val := left_val and not TASK_SHADER_BIT.val;
      end;
      if ALL_SHADER_BITS in self then
      begin
        res += 'ALL_SHADER_BITS+';
        left_val := left_val and not ALL_SHADER_BITS.val;
      end;
      if left_val<>0 then
      begin
        res += 'glUseProgramStageMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glVariantCap = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VARIANT_ARRAY: glVariantCap read new glVariantCap($87E8);
    
    public function ToString: string; override;
    begin
      if VARIANT_ARRAY = self then
        Result := 'VARIANT_ARRAY' else
        Result := $'glVariantCap[{self.val}]';
    end;
    
  end;
  
  glVertexArrayParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property STORAGE_CLIENT: glVertexArrayParameterName read new glVertexArrayParameterName($85B4);
    public static property STORAGE_CACHED: glVertexArrayParameterName read new glVertexArrayParameterName($85BE);
    public static property STORAGE_SHARED: glVertexArrayParameterName read new glVertexArrayParameterName($85BF);
    
    public function ToString: string; override;
    begin
      if STORAGE_CLIENT = self then
        Result := 'STORAGE_CLIENT' else
      if STORAGE_CACHED = self then
        Result := 'STORAGE_CACHED' else
      if STORAGE_SHARED = self then
        Result := 'STORAGE_SHARED' else
        Result := $'glVertexArrayParameterName[{self.val}]';
    end;
    
  end;
  
  glVertexArrayPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_ATTRIB_RELATIVE_OFFSET:  glVertexArrayPName read new glVertexArrayPName($82D5);
    public static property VERTEX_ATTRIB_ARRAY_ENABLED:    glVertexArrayPName read new glVertexArrayPName($8622);
    public static property VERTEX_ATTRIB_ARRAY_SIZE:       glVertexArrayPName read new glVertexArrayPName($8623);
    public static property VERTEX_ATTRIB_ARRAY_STRIDE:     glVertexArrayPName read new glVertexArrayPName($8624);
    public static property VERTEX_ATTRIB_ARRAY_TYPE:       glVertexArrayPName read new glVertexArrayPName($8625);
    public static property VERTEX_ATTRIB_ARRAY_LONG:       glVertexArrayPName read new glVertexArrayPName($874E);
    public static property VERTEX_ATTRIB_ARRAY_NORMALIZED: glVertexArrayPName read new glVertexArrayPName($886A);
    public static property VERTEX_ATTRIB_ARRAY_INTEGER:    glVertexArrayPName read new glVertexArrayPName($88FD);
    public static property VERTEX_ATTRIB_ARRAY_DIVISOR:    glVertexArrayPName read new glVertexArrayPName($88FE);
    
    public function ToString: string; override;
    begin
      if VERTEX_ATTRIB_RELATIVE_OFFSET = self then
        Result := 'VERTEX_ATTRIB_RELATIVE_OFFSET' else
      if VERTEX_ATTRIB_ARRAY_ENABLED = self then
        Result := 'VERTEX_ATTRIB_ARRAY_ENABLED' else
      if VERTEX_ATTRIB_ARRAY_SIZE = self then
        Result := 'VERTEX_ATTRIB_ARRAY_SIZE' else
      if VERTEX_ATTRIB_ARRAY_STRIDE = self then
        Result := 'VERTEX_ATTRIB_ARRAY_STRIDE' else
      if VERTEX_ATTRIB_ARRAY_TYPE = self then
        Result := 'VERTEX_ATTRIB_ARRAY_TYPE' else
      if VERTEX_ATTRIB_ARRAY_LONG = self then
        Result := 'VERTEX_ATTRIB_ARRAY_LONG' else
      if VERTEX_ATTRIB_ARRAY_NORMALIZED = self then
        Result := 'VERTEX_ATTRIB_ARRAY_NORMALIZED' else
      if VERTEX_ATTRIB_ARRAY_INTEGER = self then
        Result := 'VERTEX_ATTRIB_ARRAY_INTEGER' else
      if VERTEX_ATTRIB_ARRAY_DIVISOR = self then
        Result := 'VERTEX_ATTRIB_ARRAY_DIVISOR' else
        Result := $'glVertexArrayPName[{self.val}]';
    end;
    
  end;
  
  glVertexAttribEnum = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_ATTRIB_ARRAY_ENABLED:        glVertexAttribEnum read new glVertexAttribEnum($8622);
    public static property VERTEX_ATTRIB_ARRAY_SIZE:           glVertexAttribEnum read new glVertexAttribEnum($8623);
    public static property VERTEX_ATTRIB_ARRAY_STRIDE:         glVertexAttribEnum read new glVertexAttribEnum($8624);
    public static property VERTEX_ATTRIB_ARRAY_TYPE:           glVertexAttribEnum read new glVertexAttribEnum($8625);
    public static property CURRENT_VERTEX_ATTRIB:              glVertexAttribEnum read new glVertexAttribEnum($8626);
    public static property VERTEX_ATTRIB_ARRAY_NORMALIZED:     glVertexAttribEnum read new glVertexAttribEnum($886A);
    public static property VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: glVertexAttribEnum read new glVertexAttribEnum($889F);
    public static property VERTEX_ATTRIB_ARRAY_INTEGER:        glVertexAttribEnum read new glVertexAttribEnum($88FD);
    public static property VERTEX_ATTRIB_ARRAY_DIVISOR:        glVertexAttribEnum read new glVertexAttribEnum($88FE);
    
    public function ToString: string; override;
    begin
      if VERTEX_ATTRIB_ARRAY_ENABLED = self then
        Result := 'VERTEX_ATTRIB_ARRAY_ENABLED' else
      if VERTEX_ATTRIB_ARRAY_SIZE = self then
        Result := 'VERTEX_ATTRIB_ARRAY_SIZE' else
      if VERTEX_ATTRIB_ARRAY_STRIDE = self then
        Result := 'VERTEX_ATTRIB_ARRAY_STRIDE' else
      if VERTEX_ATTRIB_ARRAY_TYPE = self then
        Result := 'VERTEX_ATTRIB_ARRAY_TYPE' else
      if CURRENT_VERTEX_ATTRIB = self then
        Result := 'CURRENT_VERTEX_ATTRIB' else
      if VERTEX_ATTRIB_ARRAY_NORMALIZED = self then
        Result := 'VERTEX_ATTRIB_ARRAY_NORMALIZED' else
      if VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = self then
        Result := 'VERTEX_ATTRIB_ARRAY_BUFFER_BINDING' else
      if VERTEX_ATTRIB_ARRAY_INTEGER = self then
        Result := 'VERTEX_ATTRIB_ARRAY_INTEGER' else
      if VERTEX_ATTRIB_ARRAY_DIVISOR = self then
        Result := 'VERTEX_ATTRIB_ARRAY_DIVISOR' else
        Result := $'glVertexAttribEnum[{self.val}]';
    end;
    
  end;
  
  glVertexAttribIType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:           glVertexAttribIType read new glVertexAttribIType($1400);
    public static property UNSIGNED_BYTE:  glVertexAttribIType read new glVertexAttribIType($1401);
    public static property SHORT:          glVertexAttribIType read new glVertexAttribIType($1402);
    public static property UNSIGNED_SHORT: glVertexAttribIType read new glVertexAttribIType($1403);
    public static property INT:            glVertexAttribIType read new glVertexAttribIType($1404);
    public static property UNSIGNED_INT:   glVertexAttribIType read new glVertexAttribIType($1405);
    
    public function ToString: string; override;
    begin
      if BYTE = self then
        Result := 'BYTE' else
      if UNSIGNED_BYTE = self then
        Result := 'UNSIGNED_BYTE' else
      if SHORT = self then
        Result := 'SHORT' else
      if UNSIGNED_SHORT = self then
        Result := 'UNSIGNED_SHORT' else
      if INT = self then
        Result := 'INT' else
      if UNSIGNED_INT = self then
        Result := 'UNSIGNED_INT' else
        Result := $'glVertexAttribIType[{self.val}]';
    end;
    
  end;
  
  glVertexAttribLType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DOUBLE: glVertexAttribLType read new glVertexAttribLType($140A);
    
    public function ToString: string; override;
    begin
      if DOUBLE = self then
        Result := 'DOUBLE' else
        Result := $'glVertexAttribLType[{self.val}]';
    end;
    
  end;
  
  glVertexAttribPointerProperty = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_ATTRIB_ARRAY_POINTER: glVertexAttribPointerProperty read new glVertexAttribPointerProperty($8645);
    
    public function ToString: string; override;
    begin
      if VERTEX_ATTRIB_ARRAY_POINTER = self then
        Result := 'VERTEX_ATTRIB_ARRAY_POINTER' else
        Result := $'glVertexAttribPointerProperty[{self.val}]';
    end;
    
  end;
  
  glVertexAttribPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:                         glVertexAttribPointerType read new glVertexAttribPointerType($1400);
    public static property UNSIGNED_BYTE:                glVertexAttribPointerType read new glVertexAttribPointerType($1401);
    public static property SHORT:                        glVertexAttribPointerType read new glVertexAttribPointerType($1402);
    public static property UNSIGNED_SHORT:               glVertexAttribPointerType read new glVertexAttribPointerType($1403);
    public static property INT:                          glVertexAttribPointerType read new glVertexAttribPointerType($1404);
    public static property UNSIGNED_INT:                 glVertexAttribPointerType read new glVertexAttribPointerType($1405);
    public static property FLOAT:                        glVertexAttribPointerType read new glVertexAttribPointerType($1406);
    public static property DOUBLE:                       glVertexAttribPointerType read new glVertexAttribPointerType($140A);
    public static property HALF_FLOAT:                   glVertexAttribPointerType read new glVertexAttribPointerType($140B);
    public static property FIXED:                        glVertexAttribPointerType read new glVertexAttribPointerType($140C);
    public static property INT64:                        glVertexAttribPointerType read new glVertexAttribPointerType($140E);
    public static property UNSIGNED_INT64_ARB:           glVertexAttribPointerType read new glVertexAttribPointerType($140F);
    public static property UNSIGNED_INT64_NV:            glVertexAttribPointerType read new glVertexAttribPointerType($140F);
    public static property UNSIGNED_INT_2_10_10_10_REV:  glVertexAttribPointerType read new glVertexAttribPointerType($8368);
    public static property UNSIGNED_INT_10F_11F_11F_REV: glVertexAttribPointerType read new glVertexAttribPointerType($8C3B);
    public static property INT_2_10_10_10_REV:           glVertexAttribPointerType read new glVertexAttribPointerType($8D9F);
    
    public function ToString: string; override;
    begin
      if BYTE = self then
        Result := 'BYTE' else
      if UNSIGNED_BYTE = self then
        Result := 'UNSIGNED_BYTE' else
      if SHORT = self then
        Result := 'SHORT' else
      if UNSIGNED_SHORT = self then
        Result := 'UNSIGNED_SHORT' else
      if INT = self then
        Result := 'INT' else
      if UNSIGNED_INT = self then
        Result := 'UNSIGNED_INT' else
      if FLOAT = self then
        Result := 'FLOAT' else
      if DOUBLE = self then
        Result := 'DOUBLE' else
      if HALF_FLOAT = self then
        Result := 'HALF_FLOAT' else
      if FIXED = self then
        Result := 'FIXED' else
      if INT64 = self then
        Result := 'INT64' else
      if UNSIGNED_INT64_ARB = self then
        Result := 'UNSIGNED_INT64_ARB' else
      if UNSIGNED_INT64_NV = self then
        Result := 'UNSIGNED_INT64_NV' else
      if UNSIGNED_INT_2_10_10_10_REV = self then
        Result := 'UNSIGNED_INT_2_10_10_10_REV' else
      if UNSIGNED_INT_10F_11F_11F_REV = self then
        Result := 'UNSIGNED_INT_10F_11F_11F_REV' else
      if INT_2_10_10_10_REV = self then
        Result := 'INT_2_10_10_10_REV' else
        Result := $'glVertexAttribPointerType[{self.val}]';
    end;
    
  end;
  
  glVertexAttribProperty = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_ATTRIB_BINDING:              glVertexAttribProperty read new glVertexAttribProperty($82D4);
    public static property VERTEX_ATTRIB_RELATIVE_OFFSET:      glVertexAttribProperty read new glVertexAttribProperty($82D5);
    public static property VERTEX_ATTRIB_ARRAY_ENABLED:        glVertexAttribProperty read new glVertexAttribProperty($8622);
    public static property VERTEX_ATTRIB_ARRAY_SIZE:           glVertexAttribProperty read new glVertexAttribProperty($8623);
    public static property VERTEX_ATTRIB_ARRAY_STRIDE:         glVertexAttribProperty read new glVertexAttribProperty($8624);
    public static property VERTEX_ATTRIB_ARRAY_TYPE:           glVertexAttribProperty read new glVertexAttribProperty($8625);
    public static property CURRENT_VERTEX_ATTRIB:              glVertexAttribProperty read new glVertexAttribProperty($8626);
    public static property VERTEX_ATTRIB_ARRAY_LONG:           glVertexAttribProperty read new glVertexAttribProperty($874E);
    public static property VERTEX_ATTRIB_ARRAY_NORMALIZED:     glVertexAttribProperty read new glVertexAttribProperty($886A);
    public static property VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: glVertexAttribProperty read new glVertexAttribProperty($889F);
    public static property VERTEX_ATTRIB_ARRAY_INTEGER:        glVertexAttribProperty read new glVertexAttribProperty($88FD);
    public static property VERTEX_ATTRIB_ARRAY_DIVISOR:        glVertexAttribProperty read new glVertexAttribProperty($88FE);
    
    public function ToString: string; override;
    begin
      if VERTEX_ATTRIB_BINDING = self then
        Result := 'VERTEX_ATTRIB_BINDING' else
      if VERTEX_ATTRIB_RELATIVE_OFFSET = self then
        Result := 'VERTEX_ATTRIB_RELATIVE_OFFSET' else
      if VERTEX_ATTRIB_ARRAY_ENABLED = self then
        Result := 'VERTEX_ATTRIB_ARRAY_ENABLED' else
      if VERTEX_ATTRIB_ARRAY_SIZE = self then
        Result := 'VERTEX_ATTRIB_ARRAY_SIZE' else
      if VERTEX_ATTRIB_ARRAY_STRIDE = self then
        Result := 'VERTEX_ATTRIB_ARRAY_STRIDE' else
      if VERTEX_ATTRIB_ARRAY_TYPE = self then
        Result := 'VERTEX_ATTRIB_ARRAY_TYPE' else
      if CURRENT_VERTEX_ATTRIB = self then
        Result := 'CURRENT_VERTEX_ATTRIB' else
      if VERTEX_ATTRIB_ARRAY_LONG = self then
        Result := 'VERTEX_ATTRIB_ARRAY_LONG' else
      if VERTEX_ATTRIB_ARRAY_NORMALIZED = self then
        Result := 'VERTEX_ATTRIB_ARRAY_NORMALIZED' else
      if VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = self then
        Result := 'VERTEX_ATTRIB_ARRAY_BUFFER_BINDING' else
      if VERTEX_ATTRIB_ARRAY_INTEGER = self then
        Result := 'VERTEX_ATTRIB_ARRAY_INTEGER' else
      if VERTEX_ATTRIB_ARRAY_DIVISOR = self then
        Result := 'VERTEX_ATTRIB_ARRAY_DIVISOR' else
        Result := $'glVertexAttribProperty[{self.val}]';
    end;
    
  end;
  
  glVertexAttribType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:                         glVertexAttribType read new glVertexAttribType($1400);
    public static property UNSIGNED_BYTE:                glVertexAttribType read new glVertexAttribType($1401);
    public static property SHORT:                        glVertexAttribType read new glVertexAttribType($1402);
    public static property UNSIGNED_SHORT:               glVertexAttribType read new glVertexAttribType($1403);
    public static property INT:                          glVertexAttribType read new glVertexAttribType($1404);
    public static property UNSIGNED_INT:                 glVertexAttribType read new glVertexAttribType($1405);
    public static property FLOAT:                        glVertexAttribType read new glVertexAttribType($1406);
    public static property DOUBLE:                       glVertexAttribType read new glVertexAttribType($140A);
    public static property HALF_FLOAT:                   glVertexAttribType read new glVertexAttribType($140B);
    public static property FIXED:                        glVertexAttribType read new glVertexAttribType($140C);
    public static property UNSIGNED_INT_2_10_10_10_REV:  glVertexAttribType read new glVertexAttribType($8368);
    public static property UNSIGNED_INT_10F_11F_11F_REV: glVertexAttribType read new glVertexAttribType($8C3B);
    public static property INT_2_10_10_10_REV:           glVertexAttribType read new glVertexAttribType($8D9F);
    
    public function ToString: string; override;
    begin
      if BYTE = self then
        Result := 'BYTE' else
      if UNSIGNED_BYTE = self then
        Result := 'UNSIGNED_BYTE' else
      if SHORT = self then
        Result := 'SHORT' else
      if UNSIGNED_SHORT = self then
        Result := 'UNSIGNED_SHORT' else
      if INT = self then
        Result := 'INT' else
      if UNSIGNED_INT = self then
        Result := 'UNSIGNED_INT' else
      if FLOAT = self then
        Result := 'FLOAT' else
      if DOUBLE = self then
        Result := 'DOUBLE' else
      if HALF_FLOAT = self then
        Result := 'HALF_FLOAT' else
      if FIXED = self then
        Result := 'FIXED' else
      if UNSIGNED_INT_2_10_10_10_REV = self then
        Result := 'UNSIGNED_INT_2_10_10_10_REV' else
      if UNSIGNED_INT_10F_11F_11F_REV = self then
        Result := 'UNSIGNED_INT_10F_11F_11F_REV' else
      if INT_2_10_10_10_REV = self then
        Result := 'INT_2_10_10_10_REV' else
        Result := $'glVertexAttribType[{self.val}]';
    end;
    
  end;
  
  glVertexBufferObjectUsage = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property STREAM_DRAW:  glVertexBufferObjectUsage read new glVertexBufferObjectUsage($88E0);
    public static property STREAM_READ:  glVertexBufferObjectUsage read new glVertexBufferObjectUsage($88E1);
    public static property STREAM_COPY:  glVertexBufferObjectUsage read new glVertexBufferObjectUsage($88E2);
    public static property STATIC_DRAW:  glVertexBufferObjectUsage read new glVertexBufferObjectUsage($88E4);
    public static property STATIC_READ:  glVertexBufferObjectUsage read new glVertexBufferObjectUsage($88E5);
    public static property STATIC_COPY:  glVertexBufferObjectUsage read new glVertexBufferObjectUsage($88E6);
    public static property DYNAMIC_DRAW: glVertexBufferObjectUsage read new glVertexBufferObjectUsage($88E8);
    public static property DYNAMIC_READ: glVertexBufferObjectUsage read new glVertexBufferObjectUsage($88E9);
    public static property DYNAMIC_COPY: glVertexBufferObjectUsage read new glVertexBufferObjectUsage($88EA);
    
    public function ToString: string; override;
    begin
      if STREAM_DRAW = self then
        Result := 'STREAM_DRAW' else
      if STREAM_READ = self then
        Result := 'STREAM_READ' else
      if STREAM_COPY = self then
        Result := 'STREAM_COPY' else
      if STATIC_DRAW = self then
        Result := 'STATIC_DRAW' else
      if STATIC_READ = self then
        Result := 'STATIC_READ' else
      if STATIC_COPY = self then
        Result := 'STATIC_COPY' else
      if DYNAMIC_DRAW = self then
        Result := 'DYNAMIC_DRAW' else
      if DYNAMIC_READ = self then
        Result := 'DYNAMIC_READ' else
      if DYNAMIC_COPY = self then
        Result := 'DYNAMIC_COPY' else
        Result := $'glVertexBufferObjectUsage[{self.val}]';
    end;
    
  end;
  
  glVertexHintsMask = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property VERTEX23_BIT:                glVertexHintsMask read new glVertexHintsMask(1 shl 2);
    public static property VERTEX4_BIT:                 glVertexHintsMask read new glVertexHintsMask(1 shl 3);
    public static property COLOR3_BIT:                  glVertexHintsMask read new glVertexHintsMask(1 shl 16);
    public static property COLOR4_BIT:                  glVertexHintsMask read new glVertexHintsMask(1 shl 17);
    public static property EDGEFLAG_BIT:                glVertexHintsMask read new glVertexHintsMask(1 shl 18);
    public static property INDEX_BIT:                   glVertexHintsMask read new glVertexHintsMask(1 shl 19);
    public static property MAT_AMBIENT_BIT:             glVertexHintsMask read new glVertexHintsMask(1 shl 20);
    public static property MAT_AMBIENT_AND_DIFFUSE_BIT: glVertexHintsMask read new glVertexHintsMask(1 shl 21);
    public static property MAT_DIFFUSE_BIT:             glVertexHintsMask read new glVertexHintsMask(1 shl 22);
    public static property MAT_EMISSION_BIT:            glVertexHintsMask read new glVertexHintsMask(1 shl 23);
    public static property MAT_COLOR_INDEXES_BIT:       glVertexHintsMask read new glVertexHintsMask(1 shl 24);
    public static property MAT_SHININESS_BIT:           glVertexHintsMask read new glVertexHintsMask(1 shl 25);
    public static property MAT_SPECULAR_BIT:            glVertexHintsMask read new glVertexHintsMask(1 shl 26);
    public static property NORMAL_BIT:                  glVertexHintsMask read new glVertexHintsMask(1 shl 27);
    public static property TEXCOORD1_BIT:               glVertexHintsMask read new glVertexHintsMask(1 shl 28);
    public static property TEXCOORD2_BIT:               glVertexHintsMask read new glVertexHintsMask(1 shl 29);
    public static property TEXCOORD3_BIT:               glVertexHintsMask read new glVertexHintsMask(1 shl 30);
    public static property TEXCOORD4_BIT:               glVertexHintsMask read new glVertexHintsMask(1 shl 31);
    
    public static function operator+(v1, v2: glVertexHintsMask) := new glVertexHintsMask(v1.val or v2.val);
    public static function operator or(v1, v2: glVertexHintsMask) := new glVertexHintsMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: glVertexHintsMask; v2: glVertexHintsMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: glVertexHintsMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'glVertexHintsMask[0]';
        exit;
      end;
      if VERTEX23_BIT in self then
      begin
        res += 'VERTEX23_BIT+';
        left_val := left_val and not VERTEX23_BIT.val;
      end;
      if VERTEX4_BIT in self then
      begin
        res += 'VERTEX4_BIT+';
        left_val := left_val and not VERTEX4_BIT.val;
      end;
      if COLOR3_BIT in self then
      begin
        res += 'COLOR3_BIT+';
        left_val := left_val and not COLOR3_BIT.val;
      end;
      if COLOR4_BIT in self then
      begin
        res += 'COLOR4_BIT+';
        left_val := left_val and not COLOR4_BIT.val;
      end;
      if EDGEFLAG_BIT in self then
      begin
        res += 'EDGEFLAG_BIT+';
        left_val := left_val and not EDGEFLAG_BIT.val;
      end;
      if INDEX_BIT in self then
      begin
        res += 'INDEX_BIT+';
        left_val := left_val and not INDEX_BIT.val;
      end;
      if MAT_AMBIENT_BIT in self then
      begin
        res += 'MAT_AMBIENT_BIT+';
        left_val := left_val and not MAT_AMBIENT_BIT.val;
      end;
      if MAT_AMBIENT_AND_DIFFUSE_BIT in self then
      begin
        res += 'MAT_AMBIENT_AND_DIFFUSE_BIT+';
        left_val := left_val and not MAT_AMBIENT_AND_DIFFUSE_BIT.val;
      end;
      if MAT_DIFFUSE_BIT in self then
      begin
        res += 'MAT_DIFFUSE_BIT+';
        left_val := left_val and not MAT_DIFFUSE_BIT.val;
      end;
      if MAT_EMISSION_BIT in self then
      begin
        res += 'MAT_EMISSION_BIT+';
        left_val := left_val and not MAT_EMISSION_BIT.val;
      end;
      if MAT_COLOR_INDEXES_BIT in self then
      begin
        res += 'MAT_COLOR_INDEXES_BIT+';
        left_val := left_val and not MAT_COLOR_INDEXES_BIT.val;
      end;
      if MAT_SHININESS_BIT in self then
      begin
        res += 'MAT_SHININESS_BIT+';
        left_val := left_val and not MAT_SHININESS_BIT.val;
      end;
      if MAT_SPECULAR_BIT in self then
      begin
        res += 'MAT_SPECULAR_BIT+';
        left_val := left_val and not MAT_SPECULAR_BIT.val;
      end;
      if NORMAL_BIT in self then
      begin
        res += 'NORMAL_BIT+';
        left_val := left_val and not NORMAL_BIT.val;
      end;
      if TEXCOORD1_BIT in self then
      begin
        res += 'TEXCOORD1_BIT+';
        left_val := left_val and not TEXCOORD1_BIT.val;
      end;
      if TEXCOORD2_BIT in self then
      begin
        res += 'TEXCOORD2_BIT+';
        left_val := left_val and not TEXCOORD2_BIT.val;
      end;
      if TEXCOORD3_BIT in self then
      begin
        res += 'TEXCOORD3_BIT+';
        left_val := left_val and not TEXCOORD3_BIT.val;
      end;
      if TEXCOORD4_BIT in self then
      begin
        res += 'TEXCOORD4_BIT+';
        left_val := left_val and not TEXCOORD4_BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'glVertexHintsMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  glVertexPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SHORT:  glVertexPointerType read new glVertexPointerType($1402);
    public static property INT:    glVertexPointerType read new glVertexPointerType($1404);
    public static property FLOAT:  glVertexPointerType read new glVertexPointerType($1406);
    public static property DOUBLE: glVertexPointerType read new glVertexPointerType($140A);
    
    public function ToString: string; override;
    begin
      if SHORT = self then
        Result := 'SHORT' else
      if INT = self then
        Result := 'INT' else
      if FLOAT = self then
        Result := 'FLOAT' else
      if DOUBLE = self then
        Result := 'DOUBLE' else
        Result := $'glVertexPointerType[{self.val}]';
    end;
    
  end;
  
  glVertexProvokingMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FIRST_VERTEX_CONVENTION: glVertexProvokingMode read new glVertexProvokingMode($8E4D);
    public static property LAST_VERTEX_CONVENTION:  glVertexProvokingMode read new glVertexProvokingMode($8E4E);
    
    public function ToString: string; override;
    begin
      if FIRST_VERTEX_CONVENTION = self then
        Result := 'FIRST_VERTEX_CONVENTION' else
      if LAST_VERTEX_CONVENTION = self then
        Result := 'LAST_VERTEX_CONVENTION' else
        Result := $'glVertexProvokingMode[{self.val}]';
    end;
    
  end;
  
  glVertexShaderCoordOut = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property X:            glVertexShaderCoordOut read new glVertexShaderCoordOut($87D5);
    public static property Y:            glVertexShaderCoordOut read new glVertexShaderCoordOut($87D6);
    public static property Z:            glVertexShaderCoordOut read new glVertexShaderCoordOut($87D7);
    public static property W:            glVertexShaderCoordOut read new glVertexShaderCoordOut($87D8);
    public static property NEGATIVE_X:   glVertexShaderCoordOut read new glVertexShaderCoordOut($87D9);
    public static property NEGATIVE_Y:   glVertexShaderCoordOut read new glVertexShaderCoordOut($87DA);
    public static property NEGATIVE_Z:   glVertexShaderCoordOut read new glVertexShaderCoordOut($87DB);
    public static property NEGATIVE_W:   glVertexShaderCoordOut read new glVertexShaderCoordOut($87DC);
    public static property ZERO_EXT:     glVertexShaderCoordOut read new glVertexShaderCoordOut($87DD);
    public static property ONE_EXT:      glVertexShaderCoordOut read new glVertexShaderCoordOut($87DE);
    public static property NEGATIVE_ONE: glVertexShaderCoordOut read new glVertexShaderCoordOut($87DF);
    
    public function ToString: string; override;
    begin
      if X = self then
        Result := 'X' else
      if Y = self then
        Result := 'Y' else
      if Z = self then
        Result := 'Z' else
      if W = self then
        Result := 'W' else
      if NEGATIVE_X = self then
        Result := 'NEGATIVE_X' else
      if NEGATIVE_Y = self then
        Result := 'NEGATIVE_Y' else
      if NEGATIVE_Z = self then
        Result := 'NEGATIVE_Z' else
      if NEGATIVE_W = self then
        Result := 'NEGATIVE_W' else
      if ZERO_EXT = self then
        Result := 'ZERO_EXT' else
      if ONE_EXT = self then
        Result := 'ONE_EXT' else
      if NEGATIVE_ONE = self then
        Result := 'NEGATIVE_ONE' else
        Result := $'glVertexShaderCoordOut[{self.val}]';
    end;
    
  end;
  
  glVertexShaderOp = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property OP_INDEX:           glVertexShaderOp read new glVertexShaderOp($8782);
    public static property OP_NEGATE:          glVertexShaderOp read new glVertexShaderOp($8783);
    public static property OP_DOT3:            glVertexShaderOp read new glVertexShaderOp($8784);
    public static property OP_DOT4:            glVertexShaderOp read new glVertexShaderOp($8785);
    public static property OP_MUL:             glVertexShaderOp read new glVertexShaderOp($8786);
    public static property OP_ADD:             glVertexShaderOp read new glVertexShaderOp($8787);
    public static property OP_MADD:            glVertexShaderOp read new glVertexShaderOp($8788);
    public static property OP_FRAC:            glVertexShaderOp read new glVertexShaderOp($8789);
    public static property OP_MAX:             glVertexShaderOp read new glVertexShaderOp($878A);
    public static property OP_MIN:             glVertexShaderOp read new glVertexShaderOp($878B);
    public static property OP_SET_GE:          glVertexShaderOp read new glVertexShaderOp($878C);
    public static property OP_SET_LT:          glVertexShaderOp read new glVertexShaderOp($878D);
    public static property OP_CLAMP:           glVertexShaderOp read new glVertexShaderOp($878E);
    public static property OP_FLOOR:           glVertexShaderOp read new glVertexShaderOp($878F);
    public static property OP_ROUND:           glVertexShaderOp read new glVertexShaderOp($8790);
    public static property OP_EXP_BASE_2:      glVertexShaderOp read new glVertexShaderOp($8791);
    public static property OP_LOG_BASE_2:      glVertexShaderOp read new glVertexShaderOp($8792);
    public static property OP_POWER:           glVertexShaderOp read new glVertexShaderOp($8793);
    public static property OP_RECIP:           glVertexShaderOp read new glVertexShaderOp($8794);
    public static property OP_RECIP_SQRT:      glVertexShaderOp read new glVertexShaderOp($8795);
    public static property OP_SUB:             glVertexShaderOp read new glVertexShaderOp($8796);
    public static property OP_CROSS_PRODUCT:   glVertexShaderOp read new glVertexShaderOp($8797);
    public static property OP_MULTIPLY_MATRIX: glVertexShaderOp read new glVertexShaderOp($8798);
    public static property OP_MOV:             glVertexShaderOp read new glVertexShaderOp($8799);
    
    public function ToString: string; override;
    begin
      if OP_INDEX = self then
        Result := 'OP_INDEX' else
      if OP_NEGATE = self then
        Result := 'OP_NEGATE' else
      if OP_DOT3 = self then
        Result := 'OP_DOT3' else
      if OP_DOT4 = self then
        Result := 'OP_DOT4' else
      if OP_MUL = self then
        Result := 'OP_MUL' else
      if OP_ADD = self then
        Result := 'OP_ADD' else
      if OP_MADD = self then
        Result := 'OP_MADD' else
      if OP_FRAC = self then
        Result := 'OP_FRAC' else
      if OP_MAX = self then
        Result := 'OP_MAX' else
      if OP_MIN = self then
        Result := 'OP_MIN' else
      if OP_SET_GE = self then
        Result := 'OP_SET_GE' else
      if OP_SET_LT = self then
        Result := 'OP_SET_LT' else
      if OP_CLAMP = self then
        Result := 'OP_CLAMP' else
      if OP_FLOOR = self then
        Result := 'OP_FLOOR' else
      if OP_ROUND = self then
        Result := 'OP_ROUND' else
      if OP_EXP_BASE_2 = self then
        Result := 'OP_EXP_BASE_2' else
      if OP_LOG_BASE_2 = self then
        Result := 'OP_LOG_BASE_2' else
      if OP_POWER = self then
        Result := 'OP_POWER' else
      if OP_RECIP = self then
        Result := 'OP_RECIP' else
      if OP_RECIP_SQRT = self then
        Result := 'OP_RECIP_SQRT' else
      if OP_SUB = self then
        Result := 'OP_SUB' else
      if OP_CROSS_PRODUCT = self then
        Result := 'OP_CROSS_PRODUCT' else
      if OP_MULTIPLY_MATRIX = self then
        Result := 'OP_MULTIPLY_MATRIX' else
      if OP_MOV = self then
        Result := 'OP_MOV' else
        Result := $'glVertexShaderOp[{self.val}]';
    end;
    
  end;
  
  glVertexShaderParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CURRENT_VERTEX: glVertexShaderParameter read new glVertexShaderParameter($87E2);
    public static property MVP_MATRIX:     glVertexShaderParameter read new glVertexShaderParameter($87E3);
    
    public function ToString: string; override;
    begin
      if CURRENT_VERTEX = self then
        Result := 'CURRENT_VERTEX' else
      if MVP_MATRIX = self then
        Result := 'MVP_MATRIX' else
        Result := $'glVertexShaderParameter[{self.val}]';
    end;
    
  end;
  
  glVertexShaderStorageType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VARIANT:        glVertexShaderStorageType read new glVertexShaderStorageType($87C1);
    public static property INVARIANT:      glVertexShaderStorageType read new glVertexShaderStorageType($87C2);
    public static property LOCAL_CONSTANT: glVertexShaderStorageType read new glVertexShaderStorageType($87C3);
    public static property LOCAL:          glVertexShaderStorageType read new glVertexShaderStorageType($87C4);
    
    public function ToString: string; override;
    begin
      if VARIANT = self then
        Result := 'VARIANT' else
      if INVARIANT = self then
        Result := 'INVARIANT' else
      if LOCAL_CONSTANT = self then
        Result := 'LOCAL_CONSTANT' else
      if LOCAL = self then
        Result := 'LOCAL' else
        Result := $'glVertexShaderStorageType[{self.val}]';
    end;
    
  end;
  
  glVertexShaderTextureUnitParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CURRENT_TEXTURE_COORDS: glVertexShaderTextureUnitParameter read new glVertexShaderTextureUnitParameter($0B03);
    public static property TEXTURE_MATRIX:         glVertexShaderTextureUnitParameter read new glVertexShaderTextureUnitParameter($0BA8);
    
    public function ToString: string; override;
    begin
      if CURRENT_TEXTURE_COORDS = self then
        Result := 'CURRENT_TEXTURE_COORDS' else
      if TEXTURE_MATRIX = self then
        Result := 'TEXTURE_MATRIX' else
        Result := $'glVertexShaderTextureUnitParameter[{self.val}]';
    end;
    
  end;
  
  glVertexShaderWriteMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FALSE: glVertexShaderWriteMask read new glVertexShaderWriteMask(0);
    public static property TRUE:  glVertexShaderWriteMask read new glVertexShaderWriteMask($0001);
    
    public function ToString: string; override;
    begin
      if FALSE = self then
        Result := 'FALSE' else
      if TRUE = self then
        Result := 'TRUE' else
        Result := $'glVertexShaderWriteMask[{self.val}]';
    end;
    
  end;
  
  glVertexStream = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_STREAM0: glVertexStream read new glVertexStream($876C);
    public static property VERTEX_STREAM1: glVertexStream read new glVertexStream($876D);
    public static property VERTEX_STREAM2: glVertexStream read new glVertexStream($876E);
    public static property VERTEX_STREAM3: glVertexStream read new glVertexStream($876F);
    public static property VERTEX_STREAM4: glVertexStream read new glVertexStream($8770);
    public static property VERTEX_STREAM5: glVertexStream read new glVertexStream($8771);
    public static property VERTEX_STREAM6: glVertexStream read new glVertexStream($8772);
    public static property VERTEX_STREAM7: glVertexStream read new glVertexStream($8773);
    
    public function ToString: string; override;
    begin
      if VERTEX_STREAM0 = self then
        Result := 'VERTEX_STREAM0' else
      if VERTEX_STREAM1 = self then
        Result := 'VERTEX_STREAM1' else
      if VERTEX_STREAM2 = self then
        Result := 'VERTEX_STREAM2' else
      if VERTEX_STREAM3 = self then
        Result := 'VERTEX_STREAM3' else
      if VERTEX_STREAM4 = self then
        Result := 'VERTEX_STREAM4' else
      if VERTEX_STREAM5 = self then
        Result := 'VERTEX_STREAM5' else
      if VERTEX_STREAM6 = self then
        Result := 'VERTEX_STREAM6' else
      if VERTEX_STREAM7 = self then
        Result := 'VERTEX_STREAM7' else
        Result := $'glVertexStream[{self.val}]';
    end;
    
  end;
  
  glVertexWeightPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FLOAT: glVertexWeightPointerType read new glVertexWeightPointerType($1406);
    
    public function ToString: string; override;
    begin
      if FLOAT = self then
        Result := 'FLOAT' else
        Result := $'glVertexWeightPointerType[{self.val}]';
    end;
    
  end;
  
  glWeightPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:           glWeightPointerType read new glWeightPointerType($1400);
    public static property UNSIGNED_BYTE:  glWeightPointerType read new glWeightPointerType($1401);
    public static property SHORT:          glWeightPointerType read new glWeightPointerType($1402);
    public static property UNSIGNED_SHORT: glWeightPointerType read new glWeightPointerType($1403);
    public static property INT:            glWeightPointerType read new glWeightPointerType($1404);
    public static property UNSIGNED_INT:   glWeightPointerType read new glWeightPointerType($1405);
    public static property FLOAT:          glWeightPointerType read new glWeightPointerType($1406);
    public static property DOUBLE:         glWeightPointerType read new glWeightPointerType($140A);
    
    public function ToString: string; override;
    begin
      if BYTE = self then
        Result := 'BYTE' else
      if UNSIGNED_BYTE = self then
        Result := 'UNSIGNED_BYTE' else
      if SHORT = self then
        Result := 'SHORT' else
      if UNSIGNED_SHORT = self then
        Result := 'UNSIGNED_SHORT' else
      if INT = self then
        Result := 'INT' else
      if UNSIGNED_INT = self then
        Result := 'UNSIGNED_INT' else
      if FLOAT = self then
        Result := 'FLOAT' else
      if DOUBLE = self then
        Result := 'DOUBLE' else
        Result := $'glWeightPointerType[{self.val}]';
    end;
    
  end;
  
  glVertexAttribEnumNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROGRAM_PARAMETER: glVertexAttribEnumNV read new glVertexAttribEnumNV($8644);
    
    public function ToString: string; override;
    begin
      if PROGRAM_PARAMETER = self then
        Result := 'PROGRAM_PARAMETER' else
        Result := $'glVertexAttribEnumNV[{self.val}]';
    end;
    
  end;
  
  gdiLayerPlaneFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DOUBLEBUFFER:   gdiLayerPlaneFlags read new gdiLayerPlaneFlags(1 shl 0);
    public static property STEREO:         gdiLayerPlaneFlags read new gdiLayerPlaneFlags(1 shl 1);
    public static property SUPPORT_GDI:    gdiLayerPlaneFlags read new gdiLayerPlaneFlags(1 shl 4);
    public static property SUPPORT_OPENGL: gdiLayerPlaneFlags read new gdiLayerPlaneFlags(1 shl 5);
    public static property SHARE_DEPTH:    gdiLayerPlaneFlags read new gdiLayerPlaneFlags(1 shl 6);
    public static property SHARE_STENCIL:  gdiLayerPlaneFlags read new gdiLayerPlaneFlags(1 shl 7);
    public static property SHARE_ACCUM:    gdiLayerPlaneFlags read new gdiLayerPlaneFlags(1 shl 8);
    public static property SWAP_EXCHANGE:  gdiLayerPlaneFlags read new gdiLayerPlaneFlags(1 shl 9);
    public static property SWAP_COPY:      gdiLayerPlaneFlags read new gdiLayerPlaneFlags(1 shl 10);
    public static property TRANSPARENT:    gdiLayerPlaneFlags read new gdiLayerPlaneFlags(1 shl 12);
    
    public static function operator+(v1, v2: gdiLayerPlaneFlags) := new gdiLayerPlaneFlags(v1.val or v2.val);
    public static function operator or(v1, v2: gdiLayerPlaneFlags) := new gdiLayerPlaneFlags(v1.val or v2.val);
    
    public static procedure operator+=(var v1: gdiLayerPlaneFlags; v2: gdiLayerPlaneFlags) := v1 := v1+v2;
    
    public static function operator in(v1, v2: gdiLayerPlaneFlags) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'gdiLayerPlaneFlags[0]';
        exit;
      end;
      if DOUBLEBUFFER in self then
      begin
        res += 'DOUBLEBUFFER+';
        left_val := left_val and not DOUBLEBUFFER.val;
      end;
      if STEREO in self then
      begin
        res += 'STEREO+';
        left_val := left_val and not STEREO.val;
      end;
      if SUPPORT_GDI in self then
      begin
        res += 'SUPPORT_GDI+';
        left_val := left_val and not SUPPORT_GDI.val;
      end;
      if SUPPORT_OPENGL in self then
      begin
        res += 'SUPPORT_OPENGL+';
        left_val := left_val and not SUPPORT_OPENGL.val;
      end;
      if SHARE_DEPTH in self then
      begin
        res += 'SHARE_DEPTH+';
        left_val := left_val and not SHARE_DEPTH.val;
      end;
      if SHARE_STENCIL in self then
      begin
        res += 'SHARE_STENCIL+';
        left_val := left_val and not SHARE_STENCIL.val;
      end;
      if SHARE_ACCUM in self then
      begin
        res += 'SHARE_ACCUM+';
        left_val := left_val and not SHARE_ACCUM.val;
      end;
      if SWAP_EXCHANGE in self then
      begin
        res += 'SWAP_EXCHANGE+';
        left_val := left_val and not SWAP_EXCHANGE.val;
      end;
      if SWAP_COPY in self then
      begin
        res += 'SWAP_COPY+';
        left_val := left_val and not SWAP_COPY.val;
      end;
      if TRANSPARENT in self then
      begin
        res += 'TRANSPARENT+';
        left_val := left_val and not TRANSPARENT.val;
      end;
      if left_val<>0 then
      begin
        res += 'gdiLayerPlaneFlags[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  gdiPixelDataType = record
    public val: Byte;
    public constructor(val: Byte) := self.val := val;
    
    public static property LPD_TYPE_RGBA:       gdiPixelDataType read new gdiPixelDataType(0);
    public static property LPD_TYPE_COLORINDEX: gdiPixelDataType read new gdiPixelDataType($0001);
    
    public function ToString: string; override;
    begin
      if LPD_TYPE_RGBA = self then
        Result := 'LPD_TYPE_RGBA' else
      if LPD_TYPE_COLORINDEX = self then
        Result := 'LPD_TYPE_COLORINDEX' else
        Result := $'gdiPixelDataType[{self.val}]';
    end;
    
  end;
  
  gdiPixelFormatFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DOUBLEBUFFER:          gdiPixelFormatFlags read new gdiPixelFormatFlags(1 shl 0);
    public static property STEREO:                gdiPixelFormatFlags read new gdiPixelFormatFlags(1 shl 1);
    public static property DRAW_TO_WINDOW:        gdiPixelFormatFlags read new gdiPixelFormatFlags(1 shl 2);
    public static property DRAW_TO_BITMAP:        gdiPixelFormatFlags read new gdiPixelFormatFlags(1 shl 3);
    public static property SUPPORT_GDI:           gdiPixelFormatFlags read new gdiPixelFormatFlags(1 shl 4);
    public static property SUPPORT_OPENGL:        gdiPixelFormatFlags read new gdiPixelFormatFlags(1 shl 5);
    public static property GENERIC_FORMAT:        gdiPixelFormatFlags read new gdiPixelFormatFlags(1 shl 6);
    public static property NEED_PALETTE:          gdiPixelFormatFlags read new gdiPixelFormatFlags(1 shl 7);
    public static property NEED_SYSTEM_PALETTE:   gdiPixelFormatFlags read new gdiPixelFormatFlags(1 shl 8);
    public static property SWAP_EXCHANGE:         gdiPixelFormatFlags read new gdiPixelFormatFlags(1 shl 9);
    public static property SWAP_COPY:             gdiPixelFormatFlags read new gdiPixelFormatFlags(1 shl 10);
    public static property SWAP_LAYER_BUFFERS:    gdiPixelFormatFlags read new gdiPixelFormatFlags(1 shl 11);
    public static property GENERIC_ACCELERATED:   gdiPixelFormatFlags read new gdiPixelFormatFlags(1 shl 12);
    public static property DEPTH_DONTCARE:        gdiPixelFormatFlags read new gdiPixelFormatFlags(1 shl 29);
    public static property DOUBLEBUFFER_DONTCARE: gdiPixelFormatFlags read new gdiPixelFormatFlags(1 shl 30);
    public static property STEREO_DONTCARE:       gdiPixelFormatFlags read new gdiPixelFormatFlags(1 shl 31);
    
    public static function operator+(v1, v2: gdiPixelFormatFlags) := new gdiPixelFormatFlags(v1.val or v2.val);
    public static function operator or(v1, v2: gdiPixelFormatFlags) := new gdiPixelFormatFlags(v1.val or v2.val);
    
    public static procedure operator+=(var v1: gdiPixelFormatFlags; v2: gdiPixelFormatFlags) := v1 := v1+v2;
    
    public static function operator in(v1, v2: gdiPixelFormatFlags) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'gdiPixelFormatFlags[0]';
        exit;
      end;
      if DOUBLEBUFFER in self then
      begin
        res += 'DOUBLEBUFFER+';
        left_val := left_val and not DOUBLEBUFFER.val;
      end;
      if STEREO in self then
      begin
        res += 'STEREO+';
        left_val := left_val and not STEREO.val;
      end;
      if DRAW_TO_WINDOW in self then
      begin
        res += 'DRAW_TO_WINDOW+';
        left_val := left_val and not DRAW_TO_WINDOW.val;
      end;
      if DRAW_TO_BITMAP in self then
      begin
        res += 'DRAW_TO_BITMAP+';
        left_val := left_val and not DRAW_TO_BITMAP.val;
      end;
      if SUPPORT_GDI in self then
      begin
        res += 'SUPPORT_GDI+';
        left_val := left_val and not SUPPORT_GDI.val;
      end;
      if SUPPORT_OPENGL in self then
      begin
        res += 'SUPPORT_OPENGL+';
        left_val := left_val and not SUPPORT_OPENGL.val;
      end;
      if GENERIC_FORMAT in self then
      begin
        res += 'GENERIC_FORMAT+';
        left_val := left_val and not GENERIC_FORMAT.val;
      end;
      if NEED_PALETTE in self then
      begin
        res += 'NEED_PALETTE+';
        left_val := left_val and not NEED_PALETTE.val;
      end;
      if NEED_SYSTEM_PALETTE in self then
      begin
        res += 'NEED_SYSTEM_PALETTE+';
        left_val := left_val and not NEED_SYSTEM_PALETTE.val;
      end;
      if SWAP_EXCHANGE in self then
      begin
        res += 'SWAP_EXCHANGE+';
        left_val := left_val and not SWAP_EXCHANGE.val;
      end;
      if SWAP_COPY in self then
      begin
        res += 'SWAP_COPY+';
        left_val := left_val and not SWAP_COPY.val;
      end;
      if SWAP_LAYER_BUFFERS in self then
      begin
        res += 'SWAP_LAYER_BUFFERS+';
        left_val := left_val and not SWAP_LAYER_BUFFERS.val;
      end;
      if GENERIC_ACCELERATED in self then
      begin
        res += 'GENERIC_ACCELERATED+';
        left_val := left_val and not GENERIC_ACCELERATED.val;
      end;
      if DEPTH_DONTCARE in self then
      begin
        res += 'DEPTH_DONTCARE+';
        left_val := left_val and not DEPTH_DONTCARE.val;
      end;
      if DOUBLEBUFFER_DONTCARE in self then
      begin
        res += 'DOUBLEBUFFER_DONTCARE+';
        left_val := left_val and not DOUBLEBUFFER_DONTCARE.val;
      end;
      if STEREO_DONTCARE in self then
      begin
        res += 'STEREO_DONTCARE+';
        left_val := left_val and not STEREO_DONTCARE.val;
      end;
      if left_val<>0 then
      begin
        res += 'gdiPixelFormatFlags[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  wglBufferRegionType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRONT_COLOR_BUFFER_BIT: wglBufferRegionType read new wglBufferRegionType(1 shl 0);
    public static property BACK_COLOR_BUFFER_BIT:  wglBufferRegionType read new wglBufferRegionType(1 shl 1);
    public static property DEPTH_BUFFER_BIT:       wglBufferRegionType read new wglBufferRegionType(1 shl 2);
    public static property STENCIL_BUFFER_BIT:     wglBufferRegionType read new wglBufferRegionType(1 shl 3);
    
    public static function operator+(v1, v2: wglBufferRegionType) := new wglBufferRegionType(v1.val or v2.val);
    public static function operator or(v1, v2: wglBufferRegionType) := new wglBufferRegionType(v1.val or v2.val);
    
    public static procedure operator+=(var v1: wglBufferRegionType; v2: wglBufferRegionType) := v1 := v1+v2;
    
    public static function operator in(v1, v2: wglBufferRegionType) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'wglBufferRegionType[0]';
        exit;
      end;
      if FRONT_COLOR_BUFFER_BIT in self then
      begin
        res += 'FRONT_COLOR_BUFFER_BIT+';
        left_val := left_val and not FRONT_COLOR_BUFFER_BIT.val;
      end;
      if BACK_COLOR_BUFFER_BIT in self then
      begin
        res += 'BACK_COLOR_BUFFER_BIT+';
        left_val := left_val and not BACK_COLOR_BUFFER_BIT.val;
      end;
      if DEPTH_BUFFER_BIT in self then
      begin
        res += 'DEPTH_BUFFER_BIT+';
        left_val := left_val and not DEPTH_BUFFER_BIT.val;
      end;
      if STENCIL_BUFFER_BIT in self then
      begin
        res += 'STENCIL_BUFFER_BIT+';
        left_val := left_val and not STENCIL_BUFFER_BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'wglBufferRegionType[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  wglColorBuffer = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property FRONT_LEFT:  wglColorBuffer read new wglColorBuffer($2083);
    public static property FRONT_RIGHT: wglColorBuffer read new wglColorBuffer($2084);
    public static property BACK_LEFT:   wglColorBuffer read new wglColorBuffer($2085);
    public static property BACK_RIGHT:  wglColorBuffer read new wglColorBuffer($2086);
    public static property AUX0:        wglColorBuffer read new wglColorBuffer($2087);
    public static property AUX1:        wglColorBuffer read new wglColorBuffer($2088);
    public static property AUX2:        wglColorBuffer read new wglColorBuffer($2089);
    public static property AUX3:        wglColorBuffer read new wglColorBuffer($208A);
    public static property AUX4:        wglColorBuffer read new wglColorBuffer($208B);
    public static property AUX5:        wglColorBuffer read new wglColorBuffer($208C);
    public static property AUX6:        wglColorBuffer read new wglColorBuffer($208D);
    public static property AUX7:        wglColorBuffer read new wglColorBuffer($208E);
    public static property AUX8:        wglColorBuffer read new wglColorBuffer($208F);
    public static property AUX9:        wglColorBuffer read new wglColorBuffer($2090);
    
    public function ToString: string; override;
    begin
      if FRONT_LEFT = self then
        Result := 'FRONT_LEFT' else
      if FRONT_RIGHT = self then
        Result := 'FRONT_RIGHT' else
      if BACK_LEFT = self then
        Result := 'BACK_LEFT' else
      if BACK_RIGHT = self then
        Result := 'BACK_RIGHT' else
      if AUX0 = self then
        Result := 'AUX0' else
      if AUX1 = self then
        Result := 'AUX1' else
      if AUX2 = self then
        Result := 'AUX2' else
      if AUX3 = self then
        Result := 'AUX3' else
      if AUX4 = self then
        Result := 'AUX4' else
      if AUX5 = self then
        Result := 'AUX5' else
      if AUX6 = self then
        Result := 'AUX6' else
      if AUX7 = self then
        Result := 'AUX7' else
      if AUX8 = self then
        Result := 'AUX8' else
      if AUX9 = self then
        Result := 'AUX9' else
        Result := $'wglColorBuffer[{self.val}]';
    end;
    
  end;
  
  wglContextAttribute = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property NUM_VIDEO_CAPTURE_SLOTS: wglContextAttribute read new wglContextAttribute($20CF);
    public static property NUM_VIDEO_SLOTS:         wglContextAttribute read new wglContextAttribute($20F0);
    
    public function ToString: string; override;
    begin
      if NUM_VIDEO_CAPTURE_SLOTS = self then
        Result := 'NUM_VIDEO_CAPTURE_SLOTS' else
      if NUM_VIDEO_SLOTS = self then
        Result := 'NUM_VIDEO_SLOTS' else
        Result := $'wglContextAttribute[{self.val}]';
    end;
    
  end;
  
  wglDigitalVideoAttribute = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property DIGITAL_VIDEO_CURSOR_ALPHA_FRAMEBUFFER: wglDigitalVideoAttribute read new wglDigitalVideoAttribute($2050);
    public static property DIGITAL_VIDEO_CURSOR_ALPHA_VALUE:       wglDigitalVideoAttribute read new wglDigitalVideoAttribute($2051);
    public static property DIGITAL_VIDEO_CURSOR_INCLUDED:          wglDigitalVideoAttribute read new wglDigitalVideoAttribute($2052);
    public static property DIGITAL_VIDEO_GAMMA_CORRECTED:          wglDigitalVideoAttribute read new wglDigitalVideoAttribute($2053);
    
    public function ToString: string; override;
    begin
      if DIGITAL_VIDEO_CURSOR_ALPHA_FRAMEBUFFER = self then
        Result := 'DIGITAL_VIDEO_CURSOR_ALPHA_FRAMEBUFFER' else
      if DIGITAL_VIDEO_CURSOR_ALPHA_VALUE = self then
        Result := 'DIGITAL_VIDEO_CURSOR_ALPHA_VALUE' else
      if DIGITAL_VIDEO_CURSOR_INCLUDED = self then
        Result := 'DIGITAL_VIDEO_CURSOR_INCLUDED' else
      if DIGITAL_VIDEO_GAMMA_CORRECTED = self then
        Result := 'DIGITAL_VIDEO_GAMMA_CORRECTED' else
        Result := $'wglDigitalVideoAttribute[{self.val}]';
    end;
    
  end;
  
  wglDXInteropAccessMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACCESS_READ_ONLY:     wglDXInteropAccessMask read new wglDXInteropAccessMask(0);
    public static property ACCESS_READ_WRITE:    wglDXInteropAccessMask read new wglDXInteropAccessMask(1 shl 0);
    public static property ACCESS_WRITE_DISCARD: wglDXInteropAccessMask read new wglDXInteropAccessMask(1 shl 1);
    
    public property ANY_FLAGS: boolean read self.val<>0;
    
    public static function operator+(v1, v2: wglDXInteropAccessMask) := new wglDXInteropAccessMask(v1.val or v2.val);
    public static function operator or(v1, v2: wglDXInteropAccessMask) := new wglDXInteropAccessMask(v1.val or v2.val);
    
    public static procedure operator+=(var v1: wglDXInteropAccessMask; v2: wglDXInteropAccessMask) := v1 := v1+v2;
    
    public static function operator in(v1, v2: wglDXInteropAccessMask) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'ACCESS_READ_ONLY';
        exit;
      end;
      if ACCESS_READ_WRITE in self then
      begin
        res += 'ACCESS_READ_WRITE+';
        left_val := left_val and not ACCESS_READ_WRITE.val;
      end;
      if ACCESS_WRITE_DISCARD in self then
      begin
        res += 'ACCESS_WRITE_DISCARD+';
        left_val := left_val and not ACCESS_WRITE_DISCARD.val;
      end;
      if left_val<>0 then
      begin
        res += 'wglDXInteropAccessMask[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  wglFontFormat = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property FONT_LINES:    wglFontFormat read new wglFontFormat(0);
    public static property FONT_POLYGONS: wglFontFormat read new wglFontFormat($0001);
    
    public function ToString: string; override;
    begin
      if FONT_LINES = self then
        Result := 'FONT_LINES' else
      if FONT_POLYGONS = self then
        Result := 'FONT_POLYGONS' else
        Result := $'wglFontFormat[{self.val}]';
    end;
    
  end;
  
  wglGammaTableAttribute = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property GAMMA_TABLE_SIZE:      wglGammaTableAttribute read new wglGammaTableAttribute($204E);
    public static property GAMMA_EXCLUDE_DESKTOP: wglGammaTableAttribute read new wglGammaTableAttribute($204F);
    
    public function ToString: string; override;
    begin
      if GAMMA_TABLE_SIZE = self then
        Result := 'GAMMA_TABLE_SIZE' else
      if GAMMA_EXCLUDE_DESKTOP = self then
        Result := 'GAMMA_EXCLUDE_DESKTOP' else
        Result := $'wglGammaTableAttribute[{self.val}]';
    end;
    
  end;
  
  wglGPUProperty = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property GPU_VENDOR:                wglGPUProperty read new wglGPUProperty($1F00);
    public static property GPU_RENDERER_STRING:       wglGPUProperty read new wglGPUProperty($1F01);
    public static property GPU_OPENGL_VERSION_STRING: wglGPUProperty read new wglGPUProperty($1F02);
    public static property GPU_RAM:                   wglGPUProperty read new wglGPUProperty($21A3);
    public static property GPU_CLOCK:                 wglGPUProperty read new wglGPUProperty($21A4);
    public static property GPU_NUM_PIPES:             wglGPUProperty read new wglGPUProperty($21A5);
    public static property GPU_NUM_SIMD:              wglGPUProperty read new wglGPUProperty($21A6);
    public static property GPU_NUM_RB:                wglGPUProperty read new wglGPUProperty($21A7);
    public static property GPU_NUM_SPI:               wglGPUProperty read new wglGPUProperty($21A8);
    
    public function ToString: string; override;
    begin
      if GPU_VENDOR = self then
        Result := 'GPU_VENDOR' else
      if GPU_RENDERER_STRING = self then
        Result := 'GPU_RENDERER_STRING' else
      if GPU_OPENGL_VERSION_STRING = self then
        Result := 'GPU_OPENGL_VERSION_STRING' else
      if GPU_RAM = self then
        Result := 'GPU_RAM' else
      if GPU_CLOCK = self then
        Result := 'GPU_CLOCK' else
      if GPU_NUM_PIPES = self then
        Result := 'GPU_NUM_PIPES' else
      if GPU_NUM_SIMD = self then
        Result := 'GPU_NUM_SIMD' else
      if GPU_NUM_RB = self then
        Result := 'GPU_NUM_RB' else
      if GPU_NUM_SPI = self then
        Result := 'GPU_NUM_SPI' else
        Result := $'wglGPUProperty[{self.val}]';
    end;
    
  end;
  
  wglImageBufferFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property IMAGE_BUFFER_MIN_ACCESS: wglImageBufferFlags read new wglImageBufferFlags(1 shl 0);
    public static property IMAGE_BUFFER_LOCK:       wglImageBufferFlags read new wglImageBufferFlags(1 shl 1);
    
    public static function operator+(v1, v2: wglImageBufferFlags) := new wglImageBufferFlags(v1.val or v2.val);
    public static function operator or(v1, v2: wglImageBufferFlags) := new wglImageBufferFlags(v1.val or v2.val);
    
    public static procedure operator+=(var v1: wglImageBufferFlags; v2: wglImageBufferFlags) := v1 := v1+v2;
    
    public static function operator in(v1, v2: wglImageBufferFlags) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'wglImageBufferFlags[0]';
        exit;
      end;
      if IMAGE_BUFFER_MIN_ACCESS in self then
      begin
        res += 'IMAGE_BUFFER_MIN_ACCESS+';
        left_val := left_val and not IMAGE_BUFFER_MIN_ACCESS.val;
      end;
      if IMAGE_BUFFER_LOCK in self then
      begin
        res += 'IMAGE_BUFFER_LOCK+';
        left_val := left_val and not IMAGE_BUFFER_LOCK.val;
      end;
      if left_val<>0 then
      begin
        res += 'wglImageBufferFlags[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  wglPBufferAttribute = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property PBUFFER_WIDTH:  wglPBufferAttribute read new wglPBufferAttribute($2034);
    public static property PBUFFER_HEIGHT: wglPBufferAttribute read new wglPBufferAttribute($2035);
    public static property PBUFFER_LOST:   wglPBufferAttribute read new wglPBufferAttribute($2036);
    public static property TEXTURE_FORMAT: wglPBufferAttribute read new wglPBufferAttribute($2072);
    public static property TEXTURE_TARGET: wglPBufferAttribute read new wglPBufferAttribute($2073);
    public static property MIPMAP_TEXTURE: wglPBufferAttribute read new wglPBufferAttribute($2074);
    public static property MIPMAP_LEVEL:   wglPBufferAttribute read new wglPBufferAttribute($207B);
    public static property CUBE_MAP_FACE:  wglPBufferAttribute read new wglPBufferAttribute($207C);
    
    public function ToString: string; override;
    begin
      if PBUFFER_WIDTH = self then
        Result := 'PBUFFER_WIDTH' else
      if PBUFFER_HEIGHT = self then
        Result := 'PBUFFER_HEIGHT' else
      if PBUFFER_LOST = self then
        Result := 'PBUFFER_LOST' else
      if TEXTURE_FORMAT = self then
        Result := 'TEXTURE_FORMAT' else
      if TEXTURE_TARGET = self then
        Result := 'TEXTURE_TARGET' else
      if MIPMAP_TEXTURE = self then
        Result := 'MIPMAP_TEXTURE' else
      if MIPMAP_LEVEL = self then
        Result := 'MIPMAP_LEVEL' else
      if CUBE_MAP_FACE = self then
        Result := 'CUBE_MAP_FACE' else
        Result := $'wglPBufferAttribute[{self.val}]';
    end;
    
  end;
  
  wglPlane = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property SWAP_MAIN_PLANE: wglPlane read new wglPlane(1 shl 0);
    public static property SWAP_OVERLAY1:   wglPlane read new wglPlane(1 shl 1);
    public static property SWAP_OVERLAY2:   wglPlane read new wglPlane(1 shl 2);
    public static property SWAP_OVERLAY3:   wglPlane read new wglPlane(1 shl 3);
    public static property SWAP_OVERLAY4:   wglPlane read new wglPlane(1 shl 4);
    public static property SWAP_OVERLAY5:   wglPlane read new wglPlane(1 shl 5);
    public static property SWAP_OVERLAY6:   wglPlane read new wglPlane(1 shl 6);
    public static property SWAP_OVERLAY7:   wglPlane read new wglPlane(1 shl 7);
    public static property SWAP_OVERLAY8:   wglPlane read new wglPlane(1 shl 8);
    public static property SWAP_OVERLAY9:   wglPlane read new wglPlane(1 shl 9);
    public static property SWAP_OVERLAY10:  wglPlane read new wglPlane(1 shl 10);
    public static property SWAP_OVERLAY11:  wglPlane read new wglPlane(1 shl 11);
    public static property SWAP_OVERLAY12:  wglPlane read new wglPlane(1 shl 12);
    public static property SWAP_OVERLAY13:  wglPlane read new wglPlane(1 shl 13);
    public static property SWAP_OVERLAY14:  wglPlane read new wglPlane(1 shl 14);
    public static property SWAP_OVERLAY15:  wglPlane read new wglPlane(1 shl 15);
    public static property SWAP_UNDERLAY1:  wglPlane read new wglPlane(1 shl 16);
    public static property SWAP_UNDERLAY2:  wglPlane read new wglPlane(1 shl 17);
    public static property SWAP_UNDERLAY3:  wglPlane read new wglPlane(1 shl 18);
    public static property SWAP_UNDERLAY4:  wglPlane read new wglPlane(1 shl 19);
    public static property SWAP_UNDERLAY5:  wglPlane read new wglPlane(1 shl 20);
    public static property SWAP_UNDERLAY6:  wglPlane read new wglPlane(1 shl 21);
    public static property SWAP_UNDERLAY7:  wglPlane read new wglPlane(1 shl 22);
    public static property SWAP_UNDERLAY8:  wglPlane read new wglPlane(1 shl 23);
    public static property SWAP_UNDERLAY9:  wglPlane read new wglPlane(1 shl 24);
    public static property SWAP_UNDERLAY10: wglPlane read new wglPlane(1 shl 25);
    public static property SWAP_UNDERLAY11: wglPlane read new wglPlane(1 shl 26);
    public static property SWAP_UNDERLAY12: wglPlane read new wglPlane(1 shl 27);
    public static property SWAP_UNDERLAY13: wglPlane read new wglPlane(1 shl 28);
    public static property SWAP_UNDERLAY14: wglPlane read new wglPlane(1 shl 29);
    public static property SWAP_UNDERLAY15: wglPlane read new wglPlane(1 shl 30);
    
    public static function operator+(v1, v2: wglPlane) := new wglPlane(v1.val or v2.val);
    public static function operator or(v1, v2: wglPlane) := new wglPlane(v1.val or v2.val);
    
    public static procedure operator+=(var v1: wglPlane; v2: wglPlane) := v1 := v1+v2;
    
    public static function operator in(v1, v2: wglPlane) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'wglPlane[0]';
        exit;
      end;
      if SWAP_MAIN_PLANE in self then
      begin
        res += 'SWAP_MAIN_PLANE+';
        left_val := left_val and not SWAP_MAIN_PLANE.val;
      end;
      if SWAP_OVERLAY1 in self then
      begin
        res += 'SWAP_OVERLAY1+';
        left_val := left_val and not SWAP_OVERLAY1.val;
      end;
      if SWAP_OVERLAY2 in self then
      begin
        res += 'SWAP_OVERLAY2+';
        left_val := left_val and not SWAP_OVERLAY2.val;
      end;
      if SWAP_OVERLAY3 in self then
      begin
        res += 'SWAP_OVERLAY3+';
        left_val := left_val and not SWAP_OVERLAY3.val;
      end;
      if SWAP_OVERLAY4 in self then
      begin
        res += 'SWAP_OVERLAY4+';
        left_val := left_val and not SWAP_OVERLAY4.val;
      end;
      if SWAP_OVERLAY5 in self then
      begin
        res += 'SWAP_OVERLAY5+';
        left_val := left_val and not SWAP_OVERLAY5.val;
      end;
      if SWAP_OVERLAY6 in self then
      begin
        res += 'SWAP_OVERLAY6+';
        left_val := left_val and not SWAP_OVERLAY6.val;
      end;
      if SWAP_OVERLAY7 in self then
      begin
        res += 'SWAP_OVERLAY7+';
        left_val := left_val and not SWAP_OVERLAY7.val;
      end;
      if SWAP_OVERLAY8 in self then
      begin
        res += 'SWAP_OVERLAY8+';
        left_val := left_val and not SWAP_OVERLAY8.val;
      end;
      if SWAP_OVERLAY9 in self then
      begin
        res += 'SWAP_OVERLAY9+';
        left_val := left_val and not SWAP_OVERLAY9.val;
      end;
      if SWAP_OVERLAY10 in self then
      begin
        res += 'SWAP_OVERLAY10+';
        left_val := left_val and not SWAP_OVERLAY10.val;
      end;
      if SWAP_OVERLAY11 in self then
      begin
        res += 'SWAP_OVERLAY11+';
        left_val := left_val and not SWAP_OVERLAY11.val;
      end;
      if SWAP_OVERLAY12 in self then
      begin
        res += 'SWAP_OVERLAY12+';
        left_val := left_val and not SWAP_OVERLAY12.val;
      end;
      if SWAP_OVERLAY13 in self then
      begin
        res += 'SWAP_OVERLAY13+';
        left_val := left_val and not SWAP_OVERLAY13.val;
      end;
      if SWAP_OVERLAY14 in self then
      begin
        res += 'SWAP_OVERLAY14+';
        left_val := left_val and not SWAP_OVERLAY14.val;
      end;
      if SWAP_OVERLAY15 in self then
      begin
        res += 'SWAP_OVERLAY15+';
        left_val := left_val and not SWAP_OVERLAY15.val;
      end;
      if SWAP_UNDERLAY1 in self then
      begin
        res += 'SWAP_UNDERLAY1+';
        left_val := left_val and not SWAP_UNDERLAY1.val;
      end;
      if SWAP_UNDERLAY2 in self then
      begin
        res += 'SWAP_UNDERLAY2+';
        left_val := left_val and not SWAP_UNDERLAY2.val;
      end;
      if SWAP_UNDERLAY3 in self then
      begin
        res += 'SWAP_UNDERLAY3+';
        left_val := left_val and not SWAP_UNDERLAY3.val;
      end;
      if SWAP_UNDERLAY4 in self then
      begin
        res += 'SWAP_UNDERLAY4+';
        left_val := left_val and not SWAP_UNDERLAY4.val;
      end;
      if SWAP_UNDERLAY5 in self then
      begin
        res += 'SWAP_UNDERLAY5+';
        left_val := left_val and not SWAP_UNDERLAY5.val;
      end;
      if SWAP_UNDERLAY6 in self then
      begin
        res += 'SWAP_UNDERLAY6+';
        left_val := left_val and not SWAP_UNDERLAY6.val;
      end;
      if SWAP_UNDERLAY7 in self then
      begin
        res += 'SWAP_UNDERLAY7+';
        left_val := left_val and not SWAP_UNDERLAY7.val;
      end;
      if SWAP_UNDERLAY8 in self then
      begin
        res += 'SWAP_UNDERLAY8+';
        left_val := left_val and not SWAP_UNDERLAY8.val;
      end;
      if SWAP_UNDERLAY9 in self then
      begin
        res += 'SWAP_UNDERLAY9+';
        left_val := left_val and not SWAP_UNDERLAY9.val;
      end;
      if SWAP_UNDERLAY10 in self then
      begin
        res += 'SWAP_UNDERLAY10+';
        left_val := left_val and not SWAP_UNDERLAY10.val;
      end;
      if SWAP_UNDERLAY11 in self then
      begin
        res += 'SWAP_UNDERLAY11+';
        left_val := left_val and not SWAP_UNDERLAY11.val;
      end;
      if SWAP_UNDERLAY12 in self then
      begin
        res += 'SWAP_UNDERLAY12+';
        left_val := left_val and not SWAP_UNDERLAY12.val;
      end;
      if SWAP_UNDERLAY13 in self then
      begin
        res += 'SWAP_UNDERLAY13+';
        left_val := left_val and not SWAP_UNDERLAY13.val;
      end;
      if SWAP_UNDERLAY14 in self then
      begin
        res += 'SWAP_UNDERLAY14+';
        left_val := left_val and not SWAP_UNDERLAY14.val;
      end;
      if SWAP_UNDERLAY15 in self then
      begin
        res += 'SWAP_UNDERLAY15+';
        left_val := left_val and not SWAP_UNDERLAY15.val;
      end;
      if left_val<>0 then
      begin
        res += 'wglPlane[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  wglStereoEmitterState = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property STEREO_EMITTER_ENABLE:  wglStereoEmitterState read new wglStereoEmitterState($2055);
    public static property STEREO_EMITTER_DISABLE: wglStereoEmitterState read new wglStereoEmitterState($2056);
    public static property STEREO_POLARITY_NORMAL: wglStereoEmitterState read new wglStereoEmitterState($2057);
    public static property STEREO_POLARITY_INVERT: wglStereoEmitterState read new wglStereoEmitterState($2058);
    
    public function ToString: string; override;
    begin
      if STEREO_EMITTER_ENABLE = self then
        Result := 'STEREO_EMITTER_ENABLE' else
      if STEREO_EMITTER_DISABLE = self then
        Result := 'STEREO_EMITTER_DISABLE' else
      if STEREO_POLARITY_NORMAL = self then
        Result := 'STEREO_POLARITY_NORMAL' else
      if STEREO_POLARITY_INVERT = self then
        Result := 'STEREO_POLARITY_INVERT' else
        Result := $'wglStereoEmitterState[{self.val}]';
    end;
    
  end;
  
  wglVideoCaptureDeviceAttribute = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property UNIQUE_ID: wglVideoCaptureDeviceAttribute read new wglVideoCaptureDeviceAttribute($20CE);
    
    public function ToString: string; override;
    begin
      if UNIQUE_ID = self then
        Result := 'UNIQUE_ID' else
        Result := $'wglVideoCaptureDeviceAttribute[{self.val}]';
    end;
    
  end;
  
  wglVideoOutputBuffer = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property VIDEO_OUT_COLOR:           wglVideoOutputBuffer read new wglVideoOutputBuffer($20C3);
    public static property VIDEO_OUT_ALPHA:           wglVideoOutputBuffer read new wglVideoOutputBuffer($20C4);
    public static property VIDEO_OUT_DEPTH:           wglVideoOutputBuffer read new wglVideoOutputBuffer($20C5);
    public static property VIDEO_OUT_COLOR_AND_ALPHA: wglVideoOutputBuffer read new wglVideoOutputBuffer($20C6);
    public static property VIDEO_OUT_COLOR_AND_DEPTH: wglVideoOutputBuffer read new wglVideoOutputBuffer($20C7);
    
    public function ToString: string; override;
    begin
      if VIDEO_OUT_COLOR = self then
        Result := 'VIDEO_OUT_COLOR' else
      if VIDEO_OUT_ALPHA = self then
        Result := 'VIDEO_OUT_ALPHA' else
      if VIDEO_OUT_DEPTH = self then
        Result := 'VIDEO_OUT_DEPTH' else
      if VIDEO_OUT_COLOR_AND_ALPHA = self then
        Result := 'VIDEO_OUT_COLOR_AND_ALPHA' else
      if VIDEO_OUT_COLOR_AND_DEPTH = self then
        Result := 'VIDEO_OUT_COLOR_AND_DEPTH' else
        Result := $'wglVideoOutputBuffer[{self.val}]';
    end;
    
  end;
  
  wglVideoOutputBufferType = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property VIDEO_OUT_FRAME:              wglVideoOutputBufferType read new wglVideoOutputBufferType($20C8);
    public static property VIDEO_OUT_FIELD_1:            wglVideoOutputBufferType read new wglVideoOutputBufferType($20C9);
    public static property VIDEO_OUT_FIELD_2:            wglVideoOutputBufferType read new wglVideoOutputBufferType($20CA);
    public static property VIDEO_OUT_STACKED_FIELDS_1_2: wglVideoOutputBufferType read new wglVideoOutputBufferType($20CB);
    public static property VIDEO_OUT_STACKED_FIELDS_2_1: wglVideoOutputBufferType read new wglVideoOutputBufferType($20CC);
    
    public function ToString: string; override;
    begin
      if VIDEO_OUT_FRAME = self then
        Result := 'VIDEO_OUT_FRAME' else
      if VIDEO_OUT_FIELD_1 = self then
        Result := 'VIDEO_OUT_FIELD_1' else
      if VIDEO_OUT_FIELD_2 = self then
        Result := 'VIDEO_OUT_FIELD_2' else
      if VIDEO_OUT_STACKED_FIELDS_1_2 = self then
        Result := 'VIDEO_OUT_STACKED_FIELDS_1_2' else
      if VIDEO_OUT_STACKED_FIELDS_2_1 = self then
        Result := 'VIDEO_OUT_STACKED_FIELDS_2_1' else
        Result := $'wglVideoOutputBufferType[{self.val}]';
    end;
    
  end;
  
  x_color_map = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: x_color_map read default(x_color_map);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'x_color_map[{self.val}]';
    
  end;
  
  x_direct_memory_buffer = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: x_direct_memory_buffer read default(x_direct_memory_buffer);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'x_direct_memory_buffer[{self.val}]';
    
  end;
  
  x_direct_memory_params = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: x_direct_memory_params read default(x_direct_memory_params);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'x_direct_memory_params[{self.val}]';
    
  end;
  
  x_display_ptr = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: x_display_ptr read default(x_display_ptr);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'x_display_ptr[{self.val}]';
    
  end;
  
  x_font = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: x_font read default(x_font);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'x_font[{self.val}]';
    
  end;
  
  x_pixel_map = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: x_pixel_map read default(x_pixel_map);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'x_pixel_map[{self.val}]';
    
  end;
  
  x_visual_info_ptr = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: x_visual_info_ptr read default(x_visual_info_ptr);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'x_visual_info_ptr[{self.val}]';
    
  end;
  
  x_window = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: x_window read default(x_window);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'x_window[{self.val}]';
    
  end;
  
  gl_buffer = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: gl_buffer read default(gl_buffer);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_buffer[{self.val}]';
    
  end;
  
  gl_display_list = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: gl_display_list read default(gl_display_list);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_display_list[{self.val}]';
    
  end;
  
  gl_fixed = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: gl_fixed read default(gl_fixed);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_fixed[{self.val}]';
    
  end;
  
  gl_framebuffer = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: gl_framebuffer read default(gl_framebuffer);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_framebuffer[{self.val}]';
    
  end;
  
  gl_half = record
    public val: UInt16;
    
    public constructor(val: UInt16) := self.val := val;
    
    public static property Zero: gl_half read default(gl_half);
    
    private static val_sz := Marshal.SizeOf&<UInt16>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_half[{self.val}]';
    
  end;
  
  gl_perf_query_handle = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: gl_perf_query_handle read default(gl_perf_query_handle);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_perf_query_handle[{self.val}]';
    
  end;
  
  gl_perf_query_id = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: gl_perf_query_id read default(gl_perf_query_id);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_perf_query_id[{self.val}]';
    
  end;
  
  gl_program = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: gl_program read default(gl_program);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_program[{self.val}]';
    
  end;
  
  gl_program_pipeline = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: gl_program_pipeline read default(gl_program_pipeline);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_program_pipeline[{self.val}]';
    
  end;
  
  gl_query = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: gl_query read default(gl_query);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_query[{self.val}]';
    
  end;
  
  gl_renderbuffer = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: gl_renderbuffer read default(gl_renderbuffer);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_renderbuffer[{self.val}]';
    
  end;
  
  gl_sampler = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: gl_sampler read default(gl_sampler);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_sampler[{self.val}]';
    
  end;
  
  gl_shader = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: gl_shader read default(gl_shader);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_shader[{self.val}]';
    
  end;
  
  gl_sync = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: gl_sync read default(gl_sync);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_sync[{self.val}]';
    
  end;
  
  gl_texture = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: gl_texture read default(gl_texture);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_texture[{self.val}]';
    
  end;
  
  gl_transform_feedback = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: gl_transform_feedback read default(gl_transform_feedback);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_transform_feedback[{self.val}]';
    
  end;
  
  gl_vdpau_surface = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: gl_vdpau_surface read default(gl_vdpau_surface);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_vdpau_surface[{self.val}]';
    
  end;
  
  gl_vertex_array = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: gl_vertex_array read default(gl_vertex_array);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_vertex_array[{self.val}]';
    
  end;
  
  gl_handle_ARB = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: gl_handle_ARB read default(gl_handle_ARB);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gl_handle_ARB[{self.val}]';
    
  end;
  
  gdi_device_context = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: gdi_device_context read default(gdi_device_context);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gdi_device_context[{self.val}]';
    
  end;
  
  gdi_enhanced_metafile_handle = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: gdi_enhanced_metafile_handle read default(gdi_enhanced_metafile_handle);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gdi_enhanced_metafile_handle[{self.val}]';
    
  end;
  
  gdi_rendering_context = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: gdi_rendering_context read default(gdi_rendering_context);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gdi_rendering_context[{self.val}]';
    
  end;
  
  glx_context = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: glx_context read default(glx_context);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'glx_context[{self.val}]';
    
  end;
  
  glx_context_id = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: glx_context_id read default(glx_context_id);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'glx_context_id[{self.val}]';
    
  end;
  
  glx_drawable = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: glx_drawable read default(glx_drawable);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'glx_drawable[{self.val}]';
    
  end;
  
  glx_frame_buffer_config = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: glx_frame_buffer_config read default(glx_frame_buffer_config);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'glx_frame_buffer_config[{self.val}]';
    
  end;
  
  glx_pixel_buffer = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: glx_pixel_buffer read default(glx_pixel_buffer);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'glx_pixel_buffer[{self.val}]';
    
  end;
  
  glx_pixel_map = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: glx_pixel_map read default(glx_pixel_map);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'glx_pixel_map[{self.val}]';
    
  end;
  
  glx_vl_node = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: glx_vl_node read default(glx_vl_node);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'glx_vl_node[{self.val}]';
    
  end;
  
  glx_vl_path = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: glx_vl_path read default(glx_vl_path);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'glx_vl_path[{self.val}]';
    
  end;
  
  glx_vl_server = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: glx_vl_server read default(glx_vl_server);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'glx_vl_server[{self.val}]';
    
  end;
  
  glx_window = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: glx_window read default(glx_window);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'glx_window[{self.val}]';
    
  end;
  
  glx_video_capture_device_NV = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: glx_video_capture_device_NV read default(glx_video_capture_device_NV);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'glx_video_capture_device_NV[{self.val}]';
    
  end;
  
  glx_video_device_NV = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: glx_video_device_NV read default(glx_video_device_NV);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'glx_video_device_NV[{self.val}]';
    
  end;
  
  glx_video_source_SGIX = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: glx_video_source_SGIX read default(glx_video_source_SGIX);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'glx_video_source_SGIX[{self.val}]';
    
  end;
  
  wgl_pixel_buffer = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: wgl_pixel_buffer read default(wgl_pixel_buffer);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'wgl_pixel_buffer[{self.val}]';
    
  end;
  
  wgl_gpu_NV = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: wgl_gpu_NV read default(wgl_gpu_NV);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'wgl_gpu_NV[{self.val}]';
    
  end;
  
  wgl_gpu_device_NV = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: wgl_gpu_device_NV read default(wgl_gpu_device_NV);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'wgl_gpu_device_NV[{self.val}]';
    
  end;
  
  wgl_video_device_NV = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: wgl_video_device_NV read default(wgl_video_device_NV);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'wgl_video_device_NV[{self.val}]';
    
  end;
  
  wgl_video_input_device_handle_NV = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: wgl_video_input_device_handle_NV read default(wgl_video_input_device_handle_NV);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'wgl_video_input_device_handle_NV[{self.val}]';
    
  end;
  
  wgl_video_output_device_handle_NV = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: wgl_video_output_device_handle_NV read default(wgl_video_output_device_handle_NV);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'wgl_video_output_device_handle_NV[{self.val}]';
    
  end;
  
  gles_image = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: gles_image read default(gles_image);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gles_image[{self.val}]';
    
  end;
  
  gles_client_buffer_EXT = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: gles_client_buffer_EXT read default(gles_client_buffer_EXT);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'gles_client_buffer_EXT[{self.val}]';
    
  end;
  
  gdi_color_ref = record
    private a: Byte := 0;
    public r: Byte;
    public g: Byte;
    public b: Byte;
    
    public constructor(r: Byte; g: Byte; b: Byte);
    begin
      self.r := r;
      self.g := g;
      self.b := b;
    end;
    
  end;
  
  gdi_glyphmetrics_float = record
    public gmfBlackBoxX: single;
    public gmfBlackBoxY: single;
    public gmfptGlyphOriginX: single;
    public gmfptGlyphOriginY: single;
    public gmfCellIncX: single;
    public gmfCellIncY: single;
    
    public constructor(gmfBlackBoxX: single; gmfBlackBoxY: single; gmfptGlyphOriginX: single; gmfptGlyphOriginY: single; gmfCellIncX: single; gmfCellIncY: single);
    begin
      self.gmfBlackBoxX      := gmfBlackBoxX;
      self.gmfBlackBoxY      := gmfBlackBoxY;
      self.gmfptGlyphOriginX := gmfptGlyphOriginX;
      self.gmfptGlyphOriginY := gmfptGlyphOriginY;
      self.gmfCellIncX       := gmfCellIncX;
      self.gmfCellIncY       := gmfCellIncY;
    end;
    
  end;
  
  gdi_layer_plane_descriptor = record
    public nSize: UInt16 := sizeof(gdi_layer_plane_descriptor);
    public nVersion: UInt16 := 1;
    
    public dwFlags: gdiLayerPlaneFlags;
    public iPixelType: gdiPixelDataType;
    
    public cColorBits: Byte; // Кол-во бит для R+G+B
    public cRedBits: Byte; // Если оставить следующие 6 нулями - их заполнит автоматически
    public cRedShift: Byte;
    public cGreenBits: Byte;
    public cGreenShift: Byte;
    public cBlueBits: Byte;
    public cBlueShift: Byte;
    public cAlphaBits: Byte; // Последние 2 не работают на Windows
    public cAlphaShift: Byte;
    
    public cAccumBits: Byte;
    public cAccumRedBits: Byte;
    public cAccumGreenBits: Byte;
    public cAccumBlueBits: Byte;
    public cAccumAlphaBits: Byte;
    public cDepthBits: Byte;
    public cStencilBits: Byte;
    
    public cAuxBuffers: Byte; // Устарело
    public iLayerPlane: Byte;
    public bReserved: Byte;
    
    public crTransparent: gdi_color_ref; // Прозрачный цвет работает только если в dwFlags добавить gdiLayerPlaneFlags.TRANSPARENT
    
    public constructor(dwFlags: gdiLayerPlaneFlags; iPixelType: gdiPixelDataType; cColorBits: Byte; cRedBits: Byte; cRedShift: Byte; cGreenBits: Byte; cGreenShift: Byte; cBlueBits: Byte; cBlueShift: Byte; cAlphaBits: Byte; cAlphaShift: Byte; cAccumBits: Byte; cAccumRedBits: Byte; cAccumGreenBits: Byte; cAccumBlueBits: Byte; cAccumAlphaBits: Byte; cDepthBits: Byte; cStencilBits: Byte; cAuxBuffers: Byte; iLayerPlane: Byte; bReserved: Byte; crTransparent: gdi_color_ref);
    begin
      self.dwFlags         := dwFlags;
      self.iPixelType      := iPixelType;
      self.cColorBits      := cColorBits;
      self.cRedBits        := cRedBits;
      self.cRedShift       := cRedShift;
      self.cGreenBits      := cGreenBits;
      self.cGreenShift     := cGreenShift;
      self.cBlueBits       := cBlueBits;
      self.cBlueShift      := cBlueShift;
      self.cAlphaBits      := cAlphaBits;
      self.cAlphaShift     := cAlphaShift;
      self.cAccumBits      := cAccumBits;
      self.cAccumRedBits   := cAccumRedBits;
      self.cAccumGreenBits := cAccumGreenBits;
      self.cAccumBlueBits  := cAccumBlueBits;
      self.cAccumAlphaBits := cAccumAlphaBits;
      self.cDepthBits      := cDepthBits;
      self.cStencilBits    := cStencilBits;
      self.cAuxBuffers     := cAuxBuffers;
      self.iLayerPlane     := iLayerPlane;
      self.bReserved       := bReserved;
      self.crTransparent   := crTransparent;
    end;
    
  end;
  
  gdi_pixel_format_descriptor = record
    public nSize: UInt16 := sizeof(gdi_pixel_format_descriptor);
    public nVersion: UInt16 := 1;
    
    public dwFlags: gdiPixelFormatFlags;
    public iPixelType: gdiPixelDataType;
    
    public cColorBits: Byte; // Кол-во бит для R+G+B
    public cRedBits: Byte; // Если оставить следующие 6 нулями - их заполнит автоматически
    public cRedShift: Byte;
    public cGreenBits: Byte;
    public cGreenShift: Byte;
    public cBlueBits: Byte;
    public cBlueShift: Byte;
    public cAlphaBits: Byte; // Последние 2 не работают на Windows
    public cAlphaShift: Byte;
    
    public cAccumBits: Byte;
    public cAccumRedBits: Byte;
    public cAccumGreenBits: Byte;
    public cAccumBlueBits: Byte;
    public cAccumAlphaBits: Byte;
    
    public cDepthBits: Byte;
    public cStencilBits: Byte;
    
    public cAuxBuffers: Byte; // Устарело
    public iLayerType: Byte; // Устарело
    public bLayersSize: Byte; // Устарело
    
    public dwLayerMask: UInt32; // Не могу найти нормальное описание последних 3, но все оставляют их нулями
    public dwVisibleMask: UInt32;
    public dwDamageMask: UInt32;
    
    public constructor(dwFlags: gdiPixelFormatFlags; iPixelType: gdiPixelDataType; cColorBits: Byte; cRedBits: Byte; cRedShift: Byte; cGreenBits: Byte; cGreenShift: Byte; cBlueBits: Byte; cBlueShift: Byte; cAlphaBits: Byte; cAlphaShift: Byte; cAccumBits: Byte; cAccumRedBits: Byte; cAccumGreenBits: Byte; cAccumBlueBits: Byte; cAccumAlphaBits: Byte; cDepthBits: Byte; cStencilBits: Byte; cAuxBuffers: Byte; iLayerType: Byte; bLayersSize: Byte; dwLayerMask: UInt32; dwVisibleMask: UInt32; dwDamageMask: UInt32);
    begin
      self.dwFlags         := dwFlags;
      self.iPixelType      := iPixelType;
      self.cColorBits      := cColorBits;
      self.cRedBits        := cRedBits;
      self.cRedShift       := cRedShift;
      self.cGreenBits      := cGreenBits;
      self.cGreenShift     := cGreenShift;
      self.cBlueBits       := cBlueBits;
      self.cBlueShift      := cBlueShift;
      self.cAlphaBits      := cAlphaBits;
      self.cAlphaShift     := cAlphaShift;
      self.cAccumBits      := cAccumBits;
      self.cAccumRedBits   := cAccumRedBits;
      self.cAccumGreenBits := cAccumGreenBits;
      self.cAccumBlueBits  := cAccumBlueBits;
      self.cAccumAlphaBits := cAccumAlphaBits;
      self.cDepthBits      := cDepthBits;
      self.cStencilBits    := cStencilBits;
      self.cAuxBuffers     := cAuxBuffers;
      self.iLayerType      := iLayerType;
      self.bLayersSize     := bLayersSize;
      self.dwLayerMask     := dwLayerMask;
      self.dwVisibleMask   := dwVisibleMask;
      self.dwDamageMask    := dwDamageMask;
    end;
    
  end;
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  glDebugProc = procedure(source: DummyEnum; &type: DummyEnum; id: UInt32; severity: DummyEnum; length: Int32; message: string; userParam: IntPtr);
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  glDebugProcAMD = procedure(id: UInt32; category: DummyEnum; severity: DummyEnum; length: Int32; message: string; userParam: IntPtr);
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  glDebugProcARB = procedure(source: DummyEnum; &type: DummyEnum; id: UInt32; severity: DummyEnum; length: Int32; message: string; userParam: IntPtr);
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  glVulkanProcNV = procedure;
  
  
  