  
  
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  gl = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      if fadr=IntPtr.Zero then default(T) else
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    
    // added in gl4.1
    private ActiveShaderProgram_adr := GetProcAddress('glActiveShaderProgram');
    private ntv_ActiveShaderProgram_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; &program: gl_program)>(ActiveShaderProgram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveShaderProgram(pipeline: gl_program_pipeline; &program: gl_program) :=
      ntv_ActiveShaderProgram_1(pipeline, &program);
    
    // added in gl1.3
    private ActiveTexture_adr := GetProcAddress('glActiveTexture');
    private ntv_ActiveTexture_1 := GetProcOrNil&<procedure(texture: glTextureUnit)>(ActiveTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveTexture(texture: glTextureUnit) :=
      ntv_ActiveTexture_1(texture);
    
    // added in gl2.0
    private AttachShader_adr := GetProcAddress('glAttachShader');
    private ntv_AttachShader_1 := GetProcOrNil&<procedure(&program: gl_program; shader: gl_shader)>(AttachShader_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AttachShader(&program: gl_program; shader: gl_shader) :=
      ntv_AttachShader_1(&program, shader);
    
    // added in gl3.0
    private BeginConditionalRender_adr := GetProcAddress('glBeginConditionalRender');
    private ntv_BeginConditionalRender_1 := GetProcOrNil&<procedure(id: UInt32; mode: glConditionalRenderMode)>(BeginConditionalRender_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginConditionalRender(id: UInt32; mode: glConditionalRenderMode) :=
      ntv_BeginConditionalRender_1(id, mode);
    
    // added in gl1.5
    private BeginQuery_adr := GetProcAddress('glBeginQuery');
    private ntv_BeginQuery_1 := GetProcOrNil&<procedure(target: glQueryTarget; id: gl_query)>(BeginQuery_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginQuery(target: glQueryTarget; id: gl_query) :=
      ntv_BeginQuery_1(target, id);
    
    // added in gl4.0
    private BeginQueryIndexed_adr := GetProcAddress('glBeginQueryIndexed');
    private ntv_BeginQueryIndexed_1 := GetProcOrNil&<procedure(target: glQueryTarget; index: UInt32; id: gl_query)>(BeginQueryIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginQueryIndexed(target: glQueryTarget; index: UInt32; id: gl_query) :=
      ntv_BeginQueryIndexed_1(target, index, id);
    
    // added in gl3.0
    private BeginTransformFeedback_adr := GetProcAddress('glBeginTransformFeedback');
    private ntv_BeginTransformFeedback_1 := GetProcOrNil&<procedure(primitiveMode: glPrimitiveType)>(BeginTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginTransformFeedback(primitiveMode: glPrimitiveType) :=
      ntv_BeginTransformFeedback_1(primitiveMode);
    
    // added in gl2.0
    private BindAttribLocation_adr := GetProcAddress('glBindAttribLocation');
    private ntv_BindAttribLocation_1 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; name: IntPtr)>(BindAttribLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindAttribLocation(&program: gl_program; index: UInt32; name: string);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_BindAttribLocation_1(&program, index, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindAttribLocation(&program: gl_program; index: UInt32; name: IntPtr) :=
      ntv_BindAttribLocation_1(&program, index, name);
    
    // added in gl1.5
    private BindBuffer_adr := GetProcAddress('glBindBuffer');
    private ntv_BindBuffer_1 := GetProcOrNil&<procedure(target: glBufferTarget; buffer: gl_buffer)>(BindBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffer(target: glBufferTarget; buffer: gl_buffer) :=
      ntv_BindBuffer_1(target, buffer);
    
    // added in gl3.0
    private BindBufferBase_adr := GetProcAddress('glBindBufferBase');
    private ntv_BindBufferBase_1 := GetProcOrNil&<procedure(target: glBufferTarget; index: UInt32; buffer: gl_buffer)>(BindBufferBase_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferBase(target: glBufferTarget; index: UInt32; buffer: gl_buffer) :=
      ntv_BindBufferBase_1(target, index, buffer);
    
    // added in gl3.0
    private BindBufferRange_adr := GetProcAddress('glBindBufferRange');
    private ntv_BindBufferRange_1 := GetProcOrNil&<procedure(target: glBufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(BindBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferRange(target: glBufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
      ntv_BindBufferRange_1(target, index, buffer, offset, size);
    
    // added in gl4.4
    private BindBuffersBase_adr := GetProcAddress('glBindBuffersBase');
    private ntv_BindBuffersBase_1 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer)>(BindBuffersBase_adr);
    private ntv_BindBuffersBase_2 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr)>(BindBuffersBase_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersBase(target: glBufferTarget; first: UInt32; count: Int32; buffers: array of gl_buffer);
    type PGl_buffer = ^gl_buffer;
    begin
      if (buffers<>nil) and (buffers.Length<>0) then
        ntv_BindBuffersBase_1(target, first, count, buffers[0]) else
        ntv_BindBuffersBase_1(target, first, count, PGl_buffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersBase(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer) :=
      ntv_BindBuffersBase_1(target, first, count, buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersBase(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr) :=
      ntv_BindBuffersBase_2(target, first, count, buffers);
    
    // added in gl4.4
    private BindBuffersRange_adr := GetProcAddress('glBindBuffersRange');
    private ntv_BindBuffersRange_1 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var sizes: UIntPtr)>(BindBuffersRange_adr);
    private ntv_BindBuffersRange_2 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; sizes: IntPtr)>(BindBuffersRange_adr);
    private ntv_BindBuffersRange_3 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var sizes: UIntPtr)>(BindBuffersRange_adr);
    private ntv_BindBuffersRange_4 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; sizes: IntPtr)>(BindBuffersRange_adr);
    private ntv_BindBuffersRange_5 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var sizes: UIntPtr)>(BindBuffersRange_adr);
    private ntv_BindBuffersRange_6 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; sizes: IntPtr)>(BindBuffersRange_adr);
    private ntv_BindBuffersRange_7 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var sizes: UIntPtr)>(BindBuffersRange_adr);
    private ntv_BindBuffersRange_8 := GetProcOrNil&<procedure(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; sizes: IntPtr)>(BindBuffersRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; buffers: array of gl_buffer; offsets: array of IntPtr; sizes: array of UIntPtr);
    type PGl_buffer = ^gl_buffer;
    type PIntPtr = ^IntPtr;
    type PUIntPtr = ^UIntPtr;
    begin
      if (sizes<>nil) and (sizes.Length<>0) then
        if (buffers<>nil) and (buffers.Length<>0) then
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_BindBuffersRange_1(target, first, count, buffers[0], offsets[0], sizes[0]) else
            ntv_BindBuffersRange_1(target, first, count, buffers[0], PIntPtr(nil)^, sizes[0]) else
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_BindBuffersRange_1(target, first, count, PGl_buffer(nil)^, offsets[0], sizes[0]) else
            ntv_BindBuffersRange_1(target, first, count, PGl_buffer(nil)^, PIntPtr(nil)^, sizes[0]) else
        if (buffers<>nil) and (buffers.Length<>0) then
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_BindBuffersRange_1(target, first, count, buffers[0], offsets[0], PUIntPtr(nil)^) else
            ntv_BindBuffersRange_1(target, first, count, buffers[0], PIntPtr(nil)^, PUIntPtr(nil)^) else
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_BindBuffersRange_1(target, first, count, PGl_buffer(nil)^, offsets[0], PUIntPtr(nil)^) else
            ntv_BindBuffersRange_1(target, first, count, PGl_buffer(nil)^, PIntPtr(nil)^, PUIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var sizes: UIntPtr) :=
      ntv_BindBuffersRange_1(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; sizes: IntPtr) :=
      ntv_BindBuffersRange_2(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var sizes: UIntPtr) :=
      ntv_BindBuffersRange_3(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; sizes: IntPtr) :=
      ntv_BindBuffersRange_4(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var sizes: UIntPtr) :=
      ntv_BindBuffersRange_5(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; sizes: IntPtr) :=
      ntv_BindBuffersRange_6(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var sizes: UIntPtr) :=
      ntv_BindBuffersRange_7(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: glBufferTarget; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; sizes: IntPtr) :=
      ntv_BindBuffersRange_8(target, first, count, buffers, offsets, sizes);
    
    // added in gl3.0
    private BindFragDataLocation_adr := GetProcAddress('glBindFragDataLocation');
    private ntv_BindFragDataLocation_1 := GetProcOrNil&<procedure(&program: gl_program; color: UInt32; name: IntPtr)>(BindFragDataLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocation(&program: gl_program; color: UInt32; name: string);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_BindFragDataLocation_1(&program, color, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocation(&program: gl_program; color: UInt32; name: IntPtr) :=
      ntv_BindFragDataLocation_1(&program, color, name);
    
    // added in gl3.3
    private BindFragDataLocationIndexed_adr := GetProcAddress('glBindFragDataLocationIndexed');
    private ntv_BindFragDataLocationIndexed_1 := GetProcOrNil&<procedure(&program: gl_program; colorNumber: UInt32; index: UInt32; name: IntPtr)>(BindFragDataLocationIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationIndexed(&program: gl_program; colorNumber: UInt32; index: UInt32; name: string);
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        ntv_BindFragDataLocationIndexed_1(&program, colorNumber, index, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationIndexed(&program: gl_program; colorNumber: UInt32; index: UInt32; name: IntPtr) :=
      ntv_BindFragDataLocationIndexed_1(&program, colorNumber, index, name);
    
    // added in gl3.0
    private BindFramebuffer_adr := GetProcAddress('glBindFramebuffer');
    private ntv_BindFramebuffer_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; framebuffer: gl_framebuffer)>(BindFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFramebuffer(target: glFramebufferTarget; framebuffer: gl_framebuffer) :=
      ntv_BindFramebuffer_1(target, framebuffer);
    
    // added in gl4.2
    private BindImageTexture_adr := GetProcAddress('glBindImageTexture');
    private ntv_BindImageTexture_1 := GetProcOrNil&<procedure(&unit: UInt32; texture: gl_texture; level: Int32; layered: glBool8; layer: Int32; access: glBufferAccess; format: glInternalFormat)>(BindImageTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTexture(&unit: UInt32; texture: gl_texture; level: Int32; layered: glBool8; layer: Int32; access: glBufferAccess; format: glInternalFormat) :=
      ntv_BindImageTexture_1(&unit, texture, level, layered, layer, access, format);
    
    // added in gl4.4
    private BindImageTextures_adr := GetProcAddress('glBindImageTextures');
    private ntv_BindImageTextures_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var textures: gl_texture)>(BindImageTextures_adr);
    private ntv_BindImageTextures_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; textures: IntPtr)>(BindImageTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextures(first: UInt32; count: Int32; textures: array of gl_texture);
    type PGl_texture = ^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        ntv_BindImageTextures_1(first, count, textures[0]) else
        ntv_BindImageTextures_1(first, count, PGl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextures(first: UInt32; count: Int32; var textures: gl_texture) :=
      ntv_BindImageTextures_1(first, count, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextures(first: UInt32; count: Int32; textures: IntPtr) :=
      ntv_BindImageTextures_2(first, count, textures);
    
    // added in gl4.1
    private BindProgramPipeline_adr := GetProcAddress('glBindProgramPipeline');
    private ntv_BindProgramPipeline_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline)>(BindProgramPipeline_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindProgramPipeline(pipeline: gl_program_pipeline) :=
      ntv_BindProgramPipeline_1(pipeline);
    
    // added in gl3.0
    private BindRenderbuffer_adr := GetProcAddress('glBindRenderbuffer');
    private ntv_BindRenderbuffer_1 := GetProcOrNil&<procedure(target: glRenderbufferTarget; renderbuffer: gl_renderbuffer)>(BindRenderbuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindRenderbuffer(target: glRenderbufferTarget; renderbuffer: gl_renderbuffer) :=
      ntv_BindRenderbuffer_1(target, renderbuffer);
    
    // added in gl3.3
    private BindSampler_adr := GetProcAddress('glBindSampler');
    private ntv_BindSampler_1 := GetProcOrNil&<procedure(&unit: UInt32; sampler: gl_sampler)>(BindSampler_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSampler(&unit: UInt32; sampler: gl_sampler) :=
      ntv_BindSampler_1(&unit, sampler);
    
    // added in gl4.4
    private BindSamplers_adr := GetProcAddress('glBindSamplers');
    private ntv_BindSamplers_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var samplers: gl_sampler)>(BindSamplers_adr);
    private ntv_BindSamplers_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; samplers: IntPtr)>(BindSamplers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSamplers(first: UInt32; count: Int32; samplers: array of gl_sampler);
    type PGl_sampler = ^gl_sampler;
    begin
      if (samplers<>nil) and (samplers.Length<>0) then
        ntv_BindSamplers_1(first, count, samplers[0]) else
        ntv_BindSamplers_1(first, count, PGl_sampler(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSamplers(first: UInt32; count: Int32; var samplers: gl_sampler) :=
      ntv_BindSamplers_1(first, count, samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSamplers(first: UInt32; count: Int32; samplers: IntPtr) :=
      ntv_BindSamplers_2(first, count, samplers);
    
    // added in gl1.1
    private BindTexture_adr := GetProcAddress('glBindTexture');
    private ntv_BindTexture_1 := GetProcOrNil&<procedure(target: glTextureTarget; texture: gl_texture)>(BindTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTexture(target: glTextureTarget; texture: gl_texture) :=
      ntv_BindTexture_1(target, texture);
    
    // added in gl4.4
    private BindTextures_adr := GetProcAddress('glBindTextures');
    private ntv_BindTextures_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var textures: gl_texture)>(BindTextures_adr);
    private ntv_BindTextures_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; textures: IntPtr)>(BindTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextures(first: UInt32; count: Int32; textures: array of gl_texture);
    type PGl_texture = ^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        ntv_BindTextures_1(first, count, textures[0]) else
        ntv_BindTextures_1(first, count, PGl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextures(first: UInt32; count: Int32; var textures: gl_texture) :=
      ntv_BindTextures_1(first, count, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextures(first: UInt32; count: Int32; textures: IntPtr) :=
      ntv_BindTextures_2(first, count, textures);
    
    // added in gl4.5
    private BindTextureUnit_adr := GetProcAddress('glBindTextureUnit');
    private ntv_BindTextureUnit_1 := GetProcOrNil&<procedure(&unit: UInt32; texture: gl_texture)>(BindTextureUnit_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextureUnit(&unit: UInt32; texture: gl_texture) :=
      ntv_BindTextureUnit_1(&unit, texture);
    
    // added in gl4.0
    private BindTransformFeedback_adr := GetProcAddress('glBindTransformFeedback');
    private ntv_BindTransformFeedback_1 := GetProcOrNil&<procedure(target: glBindTransformFeedbackTarget; id: gl_transform_feedback)>(BindTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTransformFeedback(target: glBindTransformFeedbackTarget; id: gl_transform_feedback) :=
      ntv_BindTransformFeedback_1(target, id);
    
    // added in gl3.0
    private BindVertexArray_adr := GetProcAddress('glBindVertexArray');
    private ntv_BindVertexArray_1 := GetProcOrNil&<procedure(&array: gl_vertex_array)>(BindVertexArray_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexArray(&array: gl_vertex_array) :=
      ntv_BindVertexArray_1(&array);
    
    // added in gl4.3
    private BindVertexBuffer_adr := GetProcAddress('glBindVertexBuffer');
    private ntv_BindVertexBuffer_1 := GetProcOrNil&<procedure(bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32)>(BindVertexBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffer(bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32) :=
      ntv_BindVertexBuffer_1(bindingindex, buffer, offset, stride);
    
    // added in gl4.4
    private BindVertexBuffers_adr := GetProcAddress('glBindVertexBuffers');
    private ntv_BindVertexBuffers_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var strides: Int32)>(BindVertexBuffers_adr);
    private ntv_BindVertexBuffers_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; strides: IntPtr)>(BindVertexBuffers_adr);
    private ntv_BindVertexBuffers_3 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var strides: Int32)>(BindVertexBuffers_adr);
    private ntv_BindVertexBuffers_4 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; strides: IntPtr)>(BindVertexBuffers_adr);
    private ntv_BindVertexBuffers_5 := GetProcOrNil&<procedure(first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var strides: Int32)>(BindVertexBuffers_adr);
    private ntv_BindVertexBuffers_6 := GetProcOrNil&<procedure(first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; strides: IntPtr)>(BindVertexBuffers_adr);
    private ntv_BindVertexBuffers_7 := GetProcOrNil&<procedure(first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var strides: Int32)>(BindVertexBuffers_adr);
    private ntv_BindVertexBuffers_8 := GetProcOrNil&<procedure(first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; strides: IntPtr)>(BindVertexBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: array of gl_buffer; offsets: array of IntPtr; strides: array of Int32);
    type PGl_buffer = ^gl_buffer;
    type PIntPtr = ^IntPtr;
    type PInt32 = ^Int32;
    begin
      if (strides<>nil) and (strides.Length<>0) then
        if (buffers<>nil) and (buffers.Length<>0) then
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_BindVertexBuffers_1(first, count, buffers[0], offsets[0], strides[0]) else
            ntv_BindVertexBuffers_1(first, count, buffers[0], PIntPtr(nil)^, strides[0]) else
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_BindVertexBuffers_1(first, count, PGl_buffer(nil)^, offsets[0], strides[0]) else
            ntv_BindVertexBuffers_1(first, count, PGl_buffer(nil)^, PIntPtr(nil)^, strides[0]) else
        if (buffers<>nil) and (buffers.Length<>0) then
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_BindVertexBuffers_1(first, count, buffers[0], offsets[0], PInt32(nil)^) else
            ntv_BindVertexBuffers_1(first, count, buffers[0], PIntPtr(nil)^, PInt32(nil)^) else
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_BindVertexBuffers_1(first, count, PGl_buffer(nil)^, offsets[0], PInt32(nil)^) else
            ntv_BindVertexBuffers_1(first, count, PGl_buffer(nil)^, PIntPtr(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var strides: Int32) :=
      ntv_BindVertexBuffers_1(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; strides: IntPtr) :=
      ntv_BindVertexBuffers_2(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var strides: Int32) :=
      ntv_BindVertexBuffers_3(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; strides: IntPtr) :=
      ntv_BindVertexBuffers_4(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var strides: Int32) :=
      ntv_BindVertexBuffers_5(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; strides: IntPtr) :=
      ntv_BindVertexBuffers_6(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var strides: Int32) :=
      ntv_BindVertexBuffers_7(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; strides: IntPtr) :=
      ntv_BindVertexBuffers_8(first, count, buffers, offsets, strides);
    
    // added in gl1.4
    private BlendColor_adr := GetProcAddress('glBlendColor');
    private ntv_BlendColor_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single; alpha: single)>(BlendColor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendColor(red: single; green: single; blue: single; alpha: single) :=
      ntv_BlendColor_1(red, green, blue, alpha);
    
    // added in gl1.4
    private BlendEquation_adr := GetProcAddress('glBlendEquation');
    private ntv_BlendEquation_1 := GetProcOrNil&<procedure(mode: glBlendEquationMode)>(BlendEquation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquation(mode: glBlendEquationMode) :=
      ntv_BlendEquation_1(mode);
    
    // added in gl4.0
    private BlendEquationi_adr := GetProcAddress('glBlendEquationi');
    private ntv_BlendEquationi_1 := GetProcOrNil&<procedure(buf: UInt32; mode: glBlendEquationMode)>(BlendEquationi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationi(buf: UInt32; mode: glBlendEquationMode) :=
      ntv_BlendEquationi_1(buf, mode);
    
    // added in gl2.0
    private BlendEquationSeparate_adr := GetProcAddress('glBlendEquationSeparate');
    private ntv_BlendEquationSeparate_1 := GetProcOrNil&<procedure(modeRGB: glBlendEquationMode; modeAlpha: glBlendEquationMode)>(BlendEquationSeparate_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparate(modeRGB: glBlendEquationMode; modeAlpha: glBlendEquationMode) :=
      ntv_BlendEquationSeparate_1(modeRGB, modeAlpha);
    
    // added in gl4.0
    private BlendEquationSeparatei_adr := GetProcAddress('glBlendEquationSeparatei');
    private ntv_BlendEquationSeparatei_1 := GetProcOrNil&<procedure(buf: UInt32; modeRGB: glBlendEquationMode; modeAlpha: glBlendEquationMode)>(BlendEquationSeparatei_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparatei(buf: UInt32; modeRGB: glBlendEquationMode; modeAlpha: glBlendEquationMode) :=
      ntv_BlendEquationSeparatei_1(buf, modeRGB, modeAlpha);
    
    // added in gl1.0
    private BlendFunc_adr := GetProcAddress('glBlendFunc');
    private ntv_BlendFunc_1 := GetProcOrNil&<procedure(sfactor: glBlendingFactor; dfactor: glBlendingFactor)>(BlendFunc_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFunc(sfactor: glBlendingFactor; dfactor: glBlendingFactor) :=
      ntv_BlendFunc_1(sfactor, dfactor);
    
    // added in gl4.0
    private BlendFunci_adr := GetProcAddress('glBlendFunci');
    private ntv_BlendFunci_1 := GetProcOrNil&<procedure(buf: UInt32; src: glBlendingFactor; dst: glBlendingFactor)>(BlendFunci_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFunci(buf: UInt32; src: glBlendingFactor; dst: glBlendingFactor) :=
      ntv_BlendFunci_1(buf, src, dst);
    
    // added in gl1.4
    private BlendFuncSeparate_adr := GetProcAddress('glBlendFuncSeparate');
    private ntv_BlendFuncSeparate_1 := GetProcOrNil&<procedure(sfactorRGB: glBlendingFactor; dfactorRGB: glBlendingFactor; sfactorAlpha: glBlendingFactor; dfactorAlpha: glBlendingFactor)>(BlendFuncSeparate_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparate(sfactorRGB: glBlendingFactor; dfactorRGB: glBlendingFactor; sfactorAlpha: glBlendingFactor; dfactorAlpha: glBlendingFactor) :=
      ntv_BlendFuncSeparate_1(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    
    // added in gl4.0
    private BlendFuncSeparatei_adr := GetProcAddress('glBlendFuncSeparatei');
    private ntv_BlendFuncSeparatei_1 := GetProcOrNil&<procedure(buf: UInt32; srcRGB: glBlendingFactor; dstRGB: glBlendingFactor; srcAlpha: glBlendingFactor; dstAlpha: glBlendingFactor)>(BlendFuncSeparatei_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparatei(buf: UInt32; srcRGB: glBlendingFactor; dstRGB: glBlendingFactor; srcAlpha: glBlendingFactor; dstAlpha: glBlendingFactor) :=
      ntv_BlendFuncSeparatei_1(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    
    // added in gl3.0
    private BlitFramebuffer_adr := GetProcAddress('glBlitFramebuffer');
    private ntv_BlitFramebuffer_1 := GetProcOrNil&<procedure(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: glClearBufferMask; filter: glBlitFramebufferFilter)>(BlitFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitFramebuffer(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: glClearBufferMask; filter: glBlitFramebufferFilter) :=
      ntv_BlitFramebuffer_1(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    // added in gl4.5
    private BlitNamedFramebuffer_adr := GetProcAddress('glBlitNamedFramebuffer');
    private ntv_BlitNamedFramebuffer_1 := GetProcOrNil&<procedure(readFramebuffer: gl_framebuffer; drawFramebuffer: gl_framebuffer; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: glClearBufferMask; filter: glBlitFramebufferFilter)>(BlitNamedFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitNamedFramebuffer(readFramebuffer: gl_framebuffer; drawFramebuffer: gl_framebuffer; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: glClearBufferMask; filter: glBlitFramebufferFilter) :=
      ntv_BlitNamedFramebuffer_1(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    // added in gl1.5
    private BufferData_adr := GetProcAddress('glBufferData');
    private ntv_BufferData_1 := GetProcOrNil&<procedure(target: glBufferTarget; size: UIntPtr; var data: Byte; usage: glBufferUsage)>(BufferData_adr);
    private ntv_BufferData_2 := GetProcOrNil&<procedure(target: glBufferTarget; size: UIntPtr; data: IntPtr; usage: glBufferUsage)>(BufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferData<T>(target: glBufferTarget; size: UIntPtr; data: array of T; usage: glBufferUsage); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        BufferData(target, size, data[0], usage) else
        BufferData(target, size, PT(nil)^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferData<T>(target: glBufferTarget; size: UIntPtr; var data: T; usage: glBufferUsage); where T: record;
    begin
      ntv_BufferData_1(target, size, PByte(pointer(@data))^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferData(target: glBufferTarget; size: UIntPtr; data: IntPtr; usage: glBufferUsage) :=
      ntv_BufferData_2(target, size, data, usage);
    
    // added in gl4.4
    private BufferStorage_adr := GetProcAddress('glBufferStorage');
    private ntv_BufferStorage_1 := GetProcOrNil&<procedure(target: glBufferStorageTarget; size: UIntPtr; var data: Byte; flags: glBufferStorageMask)>(BufferStorage_adr);
    private ntv_BufferStorage_2 := GetProcOrNil&<procedure(target: glBufferStorageTarget; size: UIntPtr; data: IntPtr; flags: glBufferStorageMask)>(BufferStorage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorage<T>(target: glBufferStorageTarget; size: UIntPtr; data: array of T; flags: glBufferStorageMask); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        BufferStorage(target, size, data[0], flags) else
        BufferStorage(target, size, PT(nil)^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorage<T>(target: glBufferStorageTarget; size: UIntPtr; var data: T; flags: glBufferStorageMask); where T: record;
    begin
      ntv_BufferStorage_1(target, size, PByte(pointer(@data))^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorage(target: glBufferStorageTarget; size: UIntPtr; data: IntPtr; flags: glBufferStorageMask) :=
      ntv_BufferStorage_2(target, size, data, flags);
    
    // added in gl1.5
    private BufferSubData_adr := GetProcAddress('glBufferSubData');
    private ntv_BufferSubData_1 := GetProcOrNil&<procedure(target: glBufferTarget; offset: IntPtr; size: UIntPtr; var data: Byte)>(BufferSubData_adr);
    private ntv_BufferSubData_2 := GetProcOrNil&<procedure(target: glBufferTarget; offset: IntPtr; size: UIntPtr; data: IntPtr)>(BufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferSubData<T>(target: glBufferTarget; offset: IntPtr; size: UIntPtr; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        BufferSubData(target, offset, size, data[0]) else
        BufferSubData(target, offset, size, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferSubData<T>(target: glBufferTarget; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      ntv_BufferSubData_1(target, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferSubData(target: glBufferTarget; offset: IntPtr; size: UIntPtr; data: IntPtr) :=
      ntv_BufferSubData_2(target, offset, size, data);
    
    // added in gl3.0
    private CheckFramebufferStatus_adr := GetProcAddress('glCheckFramebufferStatus');
    private ntv_CheckFramebufferStatus_1 := GetProcOrNil&<function(target: glFramebufferTarget): glFramebufferStatus>(CheckFramebufferStatus_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CheckFramebufferStatus(target: glFramebufferTarget): glFramebufferStatus :=
      ntv_CheckFramebufferStatus_1(target);
    
    // added in gl4.5
    private CheckNamedFramebufferStatus_adr := GetProcAddress('glCheckNamedFramebufferStatus');
    private ntv_CheckNamedFramebufferStatus_1 := GetProcOrNil&<function(framebuffer: gl_framebuffer; target: glFramebufferTarget): glFramebufferStatus>(CheckNamedFramebufferStatus_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CheckNamedFramebufferStatus(framebuffer: gl_framebuffer; target: glFramebufferTarget): glFramebufferStatus :=
      ntv_CheckNamedFramebufferStatus_1(framebuffer, target);
    
    // added in gl3.0
    private ClampColor_adr := GetProcAddress('glClampColor');
    private ntv_ClampColor_1 := GetProcOrNil&<procedure(target: glClampColorTarget; clamp: glClampColorMode)>(ClampColor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClampColor(target: glClampColorTarget; clamp: glClampColorMode) :=
      ntv_ClampColor_1(target, clamp);
    
    // added in gl1.0
    private Clear_adr := GetProcAddress('glClear');
    private ntv_Clear_1 := GetProcOrNil&<procedure(mask: glClearBufferMask)>(Clear_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Clear(mask: glClearBufferMask) :=
      ntv_Clear_1(mask);
    
    // added in gl4.3
    private ClearBufferData_adr := GetProcAddress('glClearBufferData');
    private ntv_ClearBufferData_1 := GetProcOrNil&<procedure(target: glBufferStorageTarget; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; var data: Byte)>(ClearBufferData_adr);
    private ntv_ClearBufferData_2 := GetProcOrNil&<procedure(target: glBufferStorageTarget; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; data: IntPtr)>(ClearBufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferData<T>(target: glBufferStorageTarget; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearBufferData(target, internalformat, format, &type, data[0]) else
        ClearBufferData(target, internalformat, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferData<T>(target: glBufferStorageTarget; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; var data: T); where T: record;
    begin
      ntv_ClearBufferData_1(target, internalformat, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferData(target: glBufferStorageTarget; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; data: IntPtr) :=
      ntv_ClearBufferData_2(target, internalformat, format, &type, data);
    
    // added in gl3.0
    private ClearBufferfi_adr := GetProcAddress('glClearBufferfi');
    private ntv_ClearBufferfi_1 := GetProcOrNil&<procedure(buffer: glBuffer; drawbuffer: Int32; depth: single; stencil: Int32)>(ClearBufferfi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferfi(buffer: glBuffer; drawbuffer: Int32; depth: single; stencil: Int32) :=
      ntv_ClearBufferfi_1(buffer, drawbuffer, depth, stencil);
    
    // added in gl3.0
    private ClearBufferfv_adr := GetProcAddress('glClearBufferfv');
    private ntv_ClearBufferfv_1 := GetProcOrNil&<procedure(buffer: glBuffer; drawbuffer: Int32; var value: single)>(ClearBufferfv_adr);
    private ntv_ClearBufferfv_2 := GetProcOrNil&<procedure(buffer: glBuffer; drawbuffer: Int32; value: IntPtr)>(ClearBufferfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferfv(buffer: glBuffer; drawbuffer: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ClearBufferfv_1(buffer, drawbuffer, value[0]) else
        ntv_ClearBufferfv_1(buffer, drawbuffer, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferfv(buffer: glBuffer; drawbuffer: Int32; var value: single) :=
      ntv_ClearBufferfv_1(buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferfv(buffer: glBuffer; drawbuffer: Int32; value: IntPtr) :=
      ntv_ClearBufferfv_2(buffer, drawbuffer, value);
    
    // added in gl3.0
    private ClearBufferiv_adr := GetProcAddress('glClearBufferiv');
    private ntv_ClearBufferiv_1 := GetProcOrNil&<procedure(buffer: glBuffer; drawbuffer: Int32; var value: Int32)>(ClearBufferiv_adr);
    private ntv_ClearBufferiv_2 := GetProcOrNil&<procedure(buffer: glBuffer; drawbuffer: Int32; value: IntPtr)>(ClearBufferiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferiv(buffer: glBuffer; drawbuffer: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ClearBufferiv_1(buffer, drawbuffer, value[0]) else
        ntv_ClearBufferiv_1(buffer, drawbuffer, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferiv(buffer: glBuffer; drawbuffer: Int32; var value: Int32) :=
      ntv_ClearBufferiv_1(buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferiv(buffer: glBuffer; drawbuffer: Int32; value: IntPtr) :=
      ntv_ClearBufferiv_2(buffer, drawbuffer, value);
    
    // added in gl4.3
    private ClearBufferSubData_adr := GetProcAddress('glClearBufferSubData');
    private ntv_ClearBufferSubData_1 := GetProcOrNil&<procedure(target: glBufferTarget; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; var data: Byte)>(ClearBufferSubData_adr);
    private ntv_ClearBufferSubData_2 := GetProcOrNil&<procedure(target: glBufferTarget; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; data: IntPtr)>(ClearBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferSubData<T>(target: glBufferTarget; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearBufferSubData(target, internalformat, offset, size, format, &type, data[0]) else
        ClearBufferSubData(target, internalformat, offset, size, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferSubData<T>(target: glBufferTarget; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; var data: T); where T: record;
    begin
      ntv_ClearBufferSubData_1(target, internalformat, offset, size, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferSubData(target: glBufferTarget; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; data: IntPtr) :=
      ntv_ClearBufferSubData_2(target, internalformat, offset, size, format, &type, data);
    
    // added in gl3.0
    private ClearBufferuiv_adr := GetProcAddress('glClearBufferuiv');
    private ntv_ClearBufferuiv_1 := GetProcOrNil&<procedure(buffer: glBuffer; drawbuffer: Int32; var value: UInt32)>(ClearBufferuiv_adr);
    private ntv_ClearBufferuiv_2 := GetProcOrNil&<procedure(buffer: glBuffer; drawbuffer: Int32; value: IntPtr)>(ClearBufferuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferuiv(buffer: glBuffer; drawbuffer: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ClearBufferuiv_1(buffer, drawbuffer, value[0]) else
        ntv_ClearBufferuiv_1(buffer, drawbuffer, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferuiv(buffer: glBuffer; drawbuffer: Int32; var value: UInt32) :=
      ntv_ClearBufferuiv_1(buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferuiv(buffer: glBuffer; drawbuffer: Int32; value: IntPtr) :=
      ntv_ClearBufferuiv_2(buffer, drawbuffer, value);
    
    // added in gl1.0
    private ClearColor_adr := GetProcAddress('glClearColor');
    private ntv_ClearColor_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single; alpha: single)>(ClearColor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearColor(red: single; green: single; blue: single; alpha: single) :=
      ntv_ClearColor_1(red, green, blue, alpha);
    
    // added in gl1.0
    private ClearDepth_adr := GetProcAddress('glClearDepth');
    private ntv_ClearDepth_1 := GetProcOrNil&<procedure(depth: double)>(ClearDepth_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepth(depth: double) :=
      ntv_ClearDepth_1(depth);
    
    // added in gl4.1
    private ClearDepthf_adr := GetProcAddress('glClearDepthf');
    private ntv_ClearDepthf_1 := GetProcOrNil&<procedure(d: single)>(ClearDepthf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepthf(d: single) :=
      ntv_ClearDepthf_1(d);
    
    // added in gl4.5
    private ClearNamedBufferData_adr := GetProcAddress('glClearNamedBufferData');
    private ntv_ClearNamedBufferData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; var data: Byte)>(ClearNamedBufferData_adr);
    private ntv_ClearNamedBufferData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; data: IntPtr)>(ClearNamedBufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferData<T>(buffer: gl_buffer; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearNamedBufferData(buffer, internalformat, format, &type, data[0]) else
        ClearNamedBufferData(buffer, internalformat, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferData<T>(buffer: gl_buffer; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; var data: T); where T: record;
    begin
      ntv_ClearNamedBufferData_1(buffer, internalformat, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferData(buffer: gl_buffer; internalformat: glSizedInternalFormat; format: glPixelFormat; &type: glPixelType; data: IntPtr) :=
      ntv_ClearNamedBufferData_2(buffer, internalformat, format, &type, data);
    
    // added in gl4.5
    private ClearNamedBufferSubData_adr := GetProcAddress('glClearNamedBufferSubData');
    private ntv_ClearNamedBufferSubData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; var data: Byte)>(ClearNamedBufferSubData_adr);
    private ntv_ClearNamedBufferSubData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; data: IntPtr)>(ClearNamedBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubData<T>(buffer: gl_buffer; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearNamedBufferSubData(buffer, internalformat, offset, size, format, &type, data[0]) else
        ClearNamedBufferSubData(buffer, internalformat, offset, size, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubData<T>(buffer: gl_buffer; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; var data: T); where T: record;
    begin
      ntv_ClearNamedBufferSubData_1(buffer, internalformat, offset, size, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubData(buffer: gl_buffer; internalformat: glSizedInternalFormat; offset: IntPtr; size: UIntPtr; format: glPixelFormat; &type: glPixelType; data: IntPtr) :=
      ntv_ClearNamedBufferSubData_2(buffer, internalformat, offset, size, format, &type, data);
    
    // added in gl4.5
    private ClearNamedFramebufferfi_adr := GetProcAddress('glClearNamedFramebufferfi');
    private ntv_ClearNamedFramebufferfi_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; depth: single; stencil: Int32)>(ClearNamedFramebufferfi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfi(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; depth: single; stencil: Int32) :=
      ntv_ClearNamedFramebufferfi_1(framebuffer, buffer, drawbuffer, depth, stencil);
    
    // added in gl4.5
    private ClearNamedFramebufferfv_adr := GetProcAddress('glClearNamedFramebufferfv');
    private ntv_ClearNamedFramebufferfv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; var value: single)>(ClearNamedFramebufferfv_adr);
    private ntv_ClearNamedFramebufferfv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: IntPtr)>(ClearNamedFramebufferfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ClearNamedFramebufferfv_1(framebuffer, buffer, drawbuffer, value[0]) else
        ntv_ClearNamedFramebufferfv_1(framebuffer, buffer, drawbuffer, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; var value: single) :=
      ntv_ClearNamedFramebufferfv_1(framebuffer, buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: IntPtr) :=
      ntv_ClearNamedFramebufferfv_2(framebuffer, buffer, drawbuffer, value);
    
    // added in gl4.5
    private ClearNamedFramebufferiv_adr := GetProcAddress('glClearNamedFramebufferiv');
    private ntv_ClearNamedFramebufferiv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; var value: Int32)>(ClearNamedFramebufferiv_adr);
    private ntv_ClearNamedFramebufferiv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: IntPtr)>(ClearNamedFramebufferiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferiv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ClearNamedFramebufferiv_1(framebuffer, buffer, drawbuffer, value[0]) else
        ntv_ClearNamedFramebufferiv_1(framebuffer, buffer, drawbuffer, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferiv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; var value: Int32) :=
      ntv_ClearNamedFramebufferiv_1(framebuffer, buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferiv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: IntPtr) :=
      ntv_ClearNamedFramebufferiv_2(framebuffer, buffer, drawbuffer, value);
    
    // added in gl4.5
    private ClearNamedFramebufferuiv_adr := GetProcAddress('glClearNamedFramebufferuiv');
    private ntv_ClearNamedFramebufferuiv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; var value: UInt32)>(ClearNamedFramebufferuiv_adr);
    private ntv_ClearNamedFramebufferuiv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: IntPtr)>(ClearNamedFramebufferuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferuiv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ClearNamedFramebufferuiv_1(framebuffer, buffer, drawbuffer, value[0]) else
        ntv_ClearNamedFramebufferuiv_1(framebuffer, buffer, drawbuffer, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferuiv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; var value: UInt32) :=
      ntv_ClearNamedFramebufferuiv_1(framebuffer, buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferuiv(framebuffer: gl_framebuffer; buffer: glBuffer; drawbuffer: Int32; value: IntPtr) :=
      ntv_ClearNamedFramebufferuiv_2(framebuffer, buffer, drawbuffer, value);
    
    // added in gl1.0
    private ClearStencil_adr := GetProcAddress('glClearStencil');
    private ntv_ClearStencil_1 := GetProcOrNil&<procedure(s: Int32)>(ClearStencil_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearStencil(s: Int32) :=
      ntv_ClearStencil_1(s);
    
    // added in gl4.4
    private ClearTexImage_adr := GetProcAddress('glClearTexImage');
    private ntv_ClearTexImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; format: glPixelFormat; &type: glPixelType; data: IntPtr)>(ClearTexImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexImage(texture: gl_texture; level: Int32; format: glPixelFormat; &type: glPixelType; data: IntPtr) :=
      ntv_ClearTexImage_1(texture, level, format, &type, data);
    
    // added in gl4.4
    private ClearTexSubImage_adr := GetProcAddress('glClearTexSubImage');
    private ntv_ClearTexSubImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; data: IntPtr)>(ClearTexSubImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexSubImage(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; data: IntPtr) :=
      ntv_ClearTexSubImage_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, data);
    
    // added in gl3.2
    private ClientWaitSync_adr := GetProcAddress('glClientWaitSync');
    private ntv_ClientWaitSync_1 := GetProcOrNil&<function(sync: gl_sync; flags: glSyncObjectMask; timeout: UInt64): glSyncStatus>(ClientWaitSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ClientWaitSync(sync: gl_sync; flags: glSyncObjectMask; timeout: UInt64): glSyncStatus :=
      ntv_ClientWaitSync_1(sync, flags, timeout);
    
    // added in gl4.5
    private ClipControl_adr := GetProcAddress('glClipControl');
    private ntv_ClipControl_1 := GetProcOrNil&<procedure(origin: glClipControlOrigin; depth: glClipControlDepth)>(ClipControl_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipControl(origin: glClipControlOrigin; depth: glClipControlDepth) :=
      ntv_ClipControl_1(origin, depth);
    
    // added in gl1.0
    private ColorMask_adr := GetProcAddress('glColorMask');
    private ntv_ColorMask_1 := GetProcOrNil&<procedure(red: glBool8; green: glBool8; blue: glBool8; alpha: glBool8)>(ColorMask_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorMask(red: glBool8; green: glBool8; blue: glBool8; alpha: glBool8) :=
      ntv_ColorMask_1(red, green, blue, alpha);
    
    // added in gl3.0
    private ColorMaski_adr := GetProcAddress('glColorMaski');
    private ntv_ColorMaski_1 := GetProcOrNil&<procedure(index: UInt32; r: glBool8; g: glBool8; b: glBool8; a: glBool8)>(ColorMaski_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorMaski(index: UInt32; r: glBool8; g: glBool8; b: glBool8; a: glBool8) :=
      ntv_ColorMaski_1(index, r, g, b, a);
    
    // added in gl3.3
    private ColorP3ui_adr := GetProcAddress('glColorP3ui');
    private ntv_ColorP3ui_1 := GetProcOrNil&<procedure(&type: glColorPointerType; color: UInt32)>(ColorP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3ui(&type: glColorPointerType; color: UInt32) :=
      ntv_ColorP3ui_1(&type, color);
    
    // added in gl3.3
    private ColorP3uiv_adr := GetProcAddress('glColorP3uiv');
    private ntv_ColorP3uiv_1 := GetProcOrNil&<procedure(&type: glColorPointerType; var color: UInt32)>(ColorP3uiv_adr);
    private ntv_ColorP3uiv_2 := GetProcOrNil&<procedure(&type: glColorPointerType; color: IntPtr)>(ColorP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: glColorPointerType; color: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (color<>nil) and (color.Length<>0) then
        ntv_ColorP3uiv_1(&type, color[0]) else
        ntv_ColorP3uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: glColorPointerType; var color: UInt32) :=
      ntv_ColorP3uiv_1(&type, color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: glColorPointerType; color: IntPtr) :=
      ntv_ColorP3uiv_2(&type, color);
    
    // added in gl3.3
    private ColorP4ui_adr := GetProcAddress('glColorP4ui');
    private ntv_ColorP4ui_1 := GetProcOrNil&<procedure(&type: glColorPointerType; color: UInt32)>(ColorP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4ui(&type: glColorPointerType; color: UInt32) :=
      ntv_ColorP4ui_1(&type, color);
    
    // added in gl3.3
    private ColorP4uiv_adr := GetProcAddress('glColorP4uiv');
    private ntv_ColorP4uiv_1 := GetProcOrNil&<procedure(&type: glColorPointerType; var color: UInt32)>(ColorP4uiv_adr);
    private ntv_ColorP4uiv_2 := GetProcOrNil&<procedure(&type: glColorPointerType; color: IntPtr)>(ColorP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: glColorPointerType; color: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (color<>nil) and (color.Length<>0) then
        ntv_ColorP4uiv_1(&type, color[0]) else
        ntv_ColorP4uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: glColorPointerType; var color: UInt32) :=
      ntv_ColorP4uiv_1(&type, color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: glColorPointerType; color: IntPtr) :=
      ntv_ColorP4uiv_2(&type, color);
    
    // added in gl2.0
    private CompileShader_adr := GetProcAddress('glCompileShader');
    private ntv_CompileShader_1 := GetProcOrNil&<procedure(shader: gl_shader)>(CompileShader_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShader(shader: gl_shader) :=
      ntv_CompileShader_1(shader);
    
    // added in gl1.3
    private CompressedTexImage1D_adr := GetProcAddress('glCompressedTexImage1D');
    private ntv_CompressedTexImage1D_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; border: Int32; imageSize: Int32; data: IntPtr)>(CompressedTexImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage1D(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; border: Int32; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTexImage1D_1(target, level, internalformat, width, border, imageSize, data);
    
    // added in gl1.3
    private CompressedTexImage2D_adr := GetProcAddress('glCompressedTexImage2D');
    private ntv_CompressedTexImage2D_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: IntPtr)>(CompressedTexImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage2D(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTexImage2D_1(target, level, internalformat, width, height, border, imageSize, data);
    
    // added in gl1.3
    private CompressedTexImage3D_adr := GetProcAddress('glCompressedTexImage3D');
    private ntv_CompressedTexImage3D_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: IntPtr)>(CompressedTexImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage3D(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTexImage3D_1(target, level, internalformat, width, height, depth, border, imageSize, data);
    
    // added in gl1.3
    private CompressedTexSubImage1D_adr := GetProcAddress('glCompressedTexSubImage1D');
    private ntv_CompressedTexSubImage1D_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; width: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr)>(CompressedTexSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage1D(target: glTextureTarget; level: Int32; xoffset: Int32; width: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTexSubImage1D_1(target, level, xoffset, width, format, imageSize, data);
    
    // added in gl1.3
    private CompressedTexSubImage2D_adr := GetProcAddress('glCompressedTexSubImage2D');
    private ntv_CompressedTexSubImage2D_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr)>(CompressedTexSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage2D(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTexSubImage2D_1(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    
    // added in gl1.3
    private CompressedTexSubImage3D_adr := GetProcAddress('glCompressedTexSubImage3D');
    private ntv_CompressedTexSubImage3D_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr)>(CompressedTexSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage3D(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTexSubImage3D_1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    
    // added in gl4.5
    private CompressedTextureSubImage1D_adr := GetProcAddress('glCompressedTextureSubImage1D');
    private ntv_CompressedTextureSubImage1D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; width: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr)>(CompressedTextureSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage1D(texture: gl_texture; level: Int32; xoffset: Int32; width: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTextureSubImage1D_1(texture, level, xoffset, width, format, imageSize, data);
    
    // added in gl4.5
    private CompressedTextureSubImage2D_adr := GetProcAddress('glCompressedTextureSubImage2D');
    private ntv_CompressedTextureSubImage2D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr)>(CompressedTextureSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage2D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTextureSubImage2D_1(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
    
    // added in gl4.5
    private CompressedTextureSubImage3D_adr := GetProcAddress('glCompressedTextureSubImage3D');
    private ntv_CompressedTextureSubImage3D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr)>(CompressedTextureSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage3D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glInternalFormat; imageSize: Int32; data: IntPtr) :=
      ntv_CompressedTextureSubImage3D_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    
    // added in gl3.1
    private CopyBufferSubData_adr := GetProcAddress('glCopyBufferSubData');
    private ntv_CopyBufferSubData_1 := GetProcOrNil&<procedure(readTarget: glCopyBufferSubDataTarget; writeTarget: glCopyBufferSubDataTarget; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(CopyBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyBufferSubData(readTarget: glCopyBufferSubDataTarget; writeTarget: glCopyBufferSubDataTarget; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) :=
      ntv_CopyBufferSubData_1(readTarget, writeTarget, readOffset, writeOffset, size);
    
    // added in gl4.3
    private CopyImageSubData_adr := GetProcAddress('glCopyImageSubData');
    private ntv_CopyImageSubData_1 := GetProcOrNil&<procedure(srcName: UInt32; srcTarget: glCopyImageSubDataTarget; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: glCopyImageSubDataTarget; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32)>(CopyImageSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyImageSubData(srcName: UInt32; srcTarget: glCopyImageSubDataTarget; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: glCopyImageSubDataTarget; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32) :=
      ntv_CopyImageSubData_1(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    
    // added in gl4.5
    private CopyNamedBufferSubData_adr := GetProcAddress('glCopyNamedBufferSubData');
    private ntv_CopyNamedBufferSubData_1 := GetProcOrNil&<procedure(readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(CopyNamedBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyNamedBufferSubData(readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) :=
      ntv_CopyNamedBufferSubData_1(readBuffer, writeBuffer, readOffset, writeOffset, size);
    
    // added in gl1.1
    private CopyTexImage1D_adr := GetProcAddress('glCopyTexImage1D');
    private ntv_CopyTexImage1D_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; border: Int32)>(CopyTexImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexImage1D(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; border: Int32) :=
      ntv_CopyTexImage1D_1(target, level, internalformat, x, y, width, border);
    
    // added in gl1.1
    private CopyTexImage2D_adr := GetProcAddress('glCopyTexImage2D');
    private ntv_CopyTexImage2D_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32)>(CopyTexImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexImage2D(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32) :=
      ntv_CopyTexImage2D_1(target, level, internalformat, x, y, width, height, border);
    
    // added in gl1.1
    private CopyTexSubImage1D_adr := GetProcAddress('glCopyTexSubImage1D');
    private ntv_CopyTexSubImage1D_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32)>(CopyTexSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage1D(target: glTextureTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) :=
      ntv_CopyTexSubImage1D_1(target, level, xoffset, x, y, width);
    
    // added in gl1.1
    private CopyTexSubImage2D_adr := GetProcAddress('glCopyTexSubImage2D');
    private ntv_CopyTexSubImage2D_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(CopyTexSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage2D(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_CopyTexSubImage2D_1(target, level, xoffset, yoffset, x, y, width, height);
    
    // added in gl1.2
    private CopyTexSubImage3D_adr := GetProcAddress('glCopyTexSubImage3D');
    private ntv_CopyTexSubImage3D_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(CopyTexSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage3D(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_CopyTexSubImage3D_1(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    
    // added in gl4.5
    private CopyTextureSubImage1D_adr := GetProcAddress('glCopyTextureSubImage1D');
    private ntv_CopyTextureSubImage1D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32)>(CopyTextureSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage1D(texture: gl_texture; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) :=
      ntv_CopyTextureSubImage1D_1(texture, level, xoffset, x, y, width);
    
    // added in gl4.5
    private CopyTextureSubImage2D_adr := GetProcAddress('glCopyTextureSubImage2D');
    private ntv_CopyTextureSubImage2D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(CopyTextureSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage2D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_CopyTextureSubImage2D_1(texture, level, xoffset, yoffset, x, y, width, height);
    
    // added in gl4.5
    private CopyTextureSubImage3D_adr := GetProcAddress('glCopyTextureSubImage3D');
    private ntv_CopyTextureSubImage3D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(CopyTextureSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage3D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_CopyTextureSubImage3D_1(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
    
    // added in gl4.5
    private CreateBuffers_adr := GetProcAddress('glCreateBuffers');
    private ntv_CreateBuffers_1 := GetProcOrNil&<procedure(n: Int32; var buffers: gl_buffer)>(CreateBuffers_adr);
    private ntv_CreateBuffers_2 := GetProcOrNil&<procedure(n: Int32; buffers: IntPtr)>(CreateBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateBuffers(n: Int32; buffers: array of gl_buffer);
    type PGl_buffer = ^gl_buffer;
    begin
      if (buffers<>nil) and (buffers.Length<>0) then
        ntv_CreateBuffers_1(n, buffers[0]) else
        ntv_CreateBuffers_1(n, PGl_buffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateBuffers(n: Int32; var buffers: gl_buffer) :=
      ntv_CreateBuffers_1(n, buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateBuffers(n: Int32; buffers: IntPtr) :=
      ntv_CreateBuffers_2(n, buffers);
    
    // added in gl4.5
    private CreateFramebuffers_adr := GetProcAddress('glCreateFramebuffers');
    private ntv_CreateFramebuffers_1 := GetProcOrNil&<procedure(n: Int32; var framebuffers: gl_framebuffer)>(CreateFramebuffers_adr);
    private ntv_CreateFramebuffers_2 := GetProcOrNil&<procedure(n: Int32; framebuffers: IntPtr)>(CreateFramebuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateFramebuffers(n: Int32; framebuffers: array of gl_framebuffer);
    type PGl_framebuffer = ^gl_framebuffer;
    begin
      if (framebuffers<>nil) and (framebuffers.Length<>0) then
        ntv_CreateFramebuffers_1(n, framebuffers[0]) else
        ntv_CreateFramebuffers_1(n, PGl_framebuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateFramebuffers(n: Int32; var framebuffers: gl_framebuffer) :=
      ntv_CreateFramebuffers_1(n, framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateFramebuffers(n: Int32; framebuffers: IntPtr) :=
      ntv_CreateFramebuffers_2(n, framebuffers);
    
    // added in gl2.0
    private CreateProgram_adr := GetProcAddress('glCreateProgram');
    private ntv_CreateProgram_1 := GetProcOrNil&<function: gl_program>(CreateProgram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateProgram: gl_program :=
      ntv_CreateProgram_1;
    
    // added in gl4.5
    private CreateProgramPipelines_adr := GetProcAddress('glCreateProgramPipelines');
    private ntv_CreateProgramPipelines_1 := GetProcOrNil&<procedure(n: Int32; var pipelines: gl_program_pipeline)>(CreateProgramPipelines_adr);
    private ntv_CreateProgramPipelines_2 := GetProcOrNil&<procedure(n: Int32; pipelines: IntPtr)>(CreateProgramPipelines_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateProgramPipelines(n: Int32; pipelines: array of gl_program_pipeline);
    type PGl_program_pipeline = ^gl_program_pipeline;
    begin
      if (pipelines<>nil) and (pipelines.Length<>0) then
        ntv_CreateProgramPipelines_1(n, pipelines[0]) else
        ntv_CreateProgramPipelines_1(n, PGl_program_pipeline(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateProgramPipelines(n: Int32; var pipelines: gl_program_pipeline) :=
      ntv_CreateProgramPipelines_1(n, pipelines);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateProgramPipelines(n: Int32; pipelines: IntPtr) :=
      ntv_CreateProgramPipelines_2(n, pipelines);
    
    // added in gl4.5
    private CreateQueries_adr := GetProcAddress('glCreateQueries');
    private ntv_CreateQueries_1 := GetProcOrNil&<procedure(target: glQueryTarget; n: Int32; var ids: gl_query)>(CreateQueries_adr);
    private ntv_CreateQueries_2 := GetProcOrNil&<procedure(target: glQueryTarget; n: Int32; ids: IntPtr)>(CreateQueries_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateQueries(target: glQueryTarget; n: Int32; ids: array of gl_query);
    type PGl_query = ^gl_query;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_CreateQueries_1(target, n, ids[0]) else
        ntv_CreateQueries_1(target, n, PGl_query(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateQueries(target: glQueryTarget; n: Int32; var ids: gl_query) :=
      ntv_CreateQueries_1(target, n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateQueries(target: glQueryTarget; n: Int32; ids: IntPtr) :=
      ntv_CreateQueries_2(target, n, ids);
    
    // added in gl4.5
    private CreateRenderbuffers_adr := GetProcAddress('glCreateRenderbuffers');
    private ntv_CreateRenderbuffers_1 := GetProcOrNil&<procedure(n: Int32; var renderbuffers: gl_renderbuffer)>(CreateRenderbuffers_adr);
    private ntv_CreateRenderbuffers_2 := GetProcOrNil&<procedure(n: Int32; renderbuffers: IntPtr)>(CreateRenderbuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateRenderbuffers(n: Int32; renderbuffers: array of gl_renderbuffer);
    type PGl_renderbuffer = ^gl_renderbuffer;
    begin
      if (renderbuffers<>nil) and (renderbuffers.Length<>0) then
        ntv_CreateRenderbuffers_1(n, renderbuffers[0]) else
        ntv_CreateRenderbuffers_1(n, PGl_renderbuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateRenderbuffers(n: Int32; var renderbuffers: gl_renderbuffer) :=
      ntv_CreateRenderbuffers_1(n, renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateRenderbuffers(n: Int32; renderbuffers: IntPtr) :=
      ntv_CreateRenderbuffers_2(n, renderbuffers);
    
    // added in gl4.5
    private CreateSamplers_adr := GetProcAddress('glCreateSamplers');
    private ntv_CreateSamplers_1 := GetProcOrNil&<procedure(n: Int32; var samplers: gl_sampler)>(CreateSamplers_adr);
    private ntv_CreateSamplers_2 := GetProcOrNil&<procedure(n: Int32; samplers: IntPtr)>(CreateSamplers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSamplers(n: Int32; samplers: array of gl_sampler);
    type PGl_sampler = ^gl_sampler;
    begin
      if (samplers<>nil) and (samplers.Length<>0) then
        ntv_CreateSamplers_1(n, samplers[0]) else
        ntv_CreateSamplers_1(n, PGl_sampler(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSamplers(n: Int32; var samplers: gl_sampler) :=
      ntv_CreateSamplers_1(n, samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSamplers(n: Int32; samplers: IntPtr) :=
      ntv_CreateSamplers_2(n, samplers);
    
    // added in gl2.0
    private CreateShader_adr := GetProcAddress('glCreateShader');
    private ntv_CreateShader_1 := GetProcOrNil&<function(&type: glShaderType): gl_shader>(CreateShader_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShader(&type: glShaderType): gl_shader :=
      ntv_CreateShader_1(&type);
    
    // added in gl4.1
    private CreateShaderProgramv_adr := GetProcAddress('glCreateShaderProgramv');
    private ntv_CreateShaderProgramv_1 := GetProcOrNil&<function(&type: glShaderType; count: Int32; var strings: IntPtr): gl_program>(CreateShaderProgramv_adr);
    private ntv_CreateShaderProgramv_2 := GetProcOrNil&<function(&type: glShaderType; count: Int32; strings: pointer): gl_program>(CreateShaderProgramv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramv(&type: glShaderType; count: Int32; strings: array of string): gl_program;
    begin
      if (strings=nil) or (strings.Length=0) then
      begin
        Result := ntv_CreateShaderProgramv_2(&type, count, nil);
        exit;
      end;
      var strings_temp_arr: array of IntPtr;
      try
        begin
          var strings_org_el_1 := strings;
          var strings_len_1 := strings_org_el_1.Length;
          SetLength(strings_temp_arr, strings_len_1);
          var strings_tmp_el_1 := strings_temp_arr;
          for var strings_ind_1 := 0 to strings_len_1-1 do
          begin
            var strings_org_el_2 := strings_org_el_1[strings_ind_1];
            if (strings_org_el_2=nil) or (strings_org_el_2.Length=0) then continue;
            strings_tmp_el_1[strings_ind_1] := Marshal.StringToHGlobalAnsi(strings_org_el_2);
          end;
        end;
        Result := ntv_CreateShaderProgramv_1(&type, count, strings_temp_arr[0]);
      finally
         foreach var arr_el1 in strings_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramv(&type: glShaderType; count: Int32; var strings: IntPtr): gl_program :=
      ntv_CreateShaderProgramv_1(&type, count, strings);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramv(&type: glShaderType; count: Int32; strings: pointer): gl_program :=
      ntv_CreateShaderProgramv_2(&type, count, strings);
    
    // added in gl4.5
    private CreateTextures_adr := GetProcAddress('glCreateTextures');
    private ntv_CreateTextures_1 := GetProcOrNil&<procedure(target: glTextureTarget; n: Int32; var textures: gl_texture)>(CreateTextures_adr);
    private ntv_CreateTextures_2 := GetProcOrNil&<procedure(target: glTextureTarget; n: Int32; textures: IntPtr)>(CreateTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTextures(target: glTextureTarget; n: Int32; textures: array of gl_texture);
    type PGl_texture = ^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        ntv_CreateTextures_1(target, n, textures[0]) else
        ntv_CreateTextures_1(target, n, PGl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTextures(target: glTextureTarget; n: Int32; var textures: gl_texture) :=
      ntv_CreateTextures_1(target, n, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTextures(target: glTextureTarget; n: Int32; textures: IntPtr) :=
      ntv_CreateTextures_2(target, n, textures);
    
    // added in gl4.5
    private CreateTransformFeedbacks_adr := GetProcAddress('glCreateTransformFeedbacks');
    private ntv_CreateTransformFeedbacks_1 := GetProcOrNil&<procedure(n: Int32; var ids: gl_transform_feedback)>(CreateTransformFeedbacks_adr);
    private ntv_CreateTransformFeedbacks_2 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(CreateTransformFeedbacks_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTransformFeedbacks(n: Int32; ids: array of gl_transform_feedback);
    type PGl_transform_feedback = ^gl_transform_feedback;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_CreateTransformFeedbacks_1(n, ids[0]) else
        ntv_CreateTransformFeedbacks_1(n, PGl_transform_feedback(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTransformFeedbacks(n: Int32; var ids: gl_transform_feedback) :=
      ntv_CreateTransformFeedbacks_1(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTransformFeedbacks(n: Int32; ids: IntPtr) :=
      ntv_CreateTransformFeedbacks_2(n, ids);
    
    // added in gl4.5
    private CreateVertexArrays_adr := GetProcAddress('glCreateVertexArrays');
    private ntv_CreateVertexArrays_1 := GetProcOrNil&<procedure(n: Int32; var arrays: gl_vertex_array)>(CreateVertexArrays_adr);
    private ntv_CreateVertexArrays_2 := GetProcOrNil&<procedure(n: Int32; arrays: IntPtr)>(CreateVertexArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateVertexArrays(n: Int32; arrays: array of gl_vertex_array);
    type PGl_vertex_array = ^gl_vertex_array;
    begin
      if (arrays<>nil) and (arrays.Length<>0) then
        ntv_CreateVertexArrays_1(n, arrays[0]) else
        ntv_CreateVertexArrays_1(n, PGl_vertex_array(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateVertexArrays(n: Int32; var arrays: gl_vertex_array) :=
      ntv_CreateVertexArrays_1(n, arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateVertexArrays(n: Int32; arrays: IntPtr) :=
      ntv_CreateVertexArrays_2(n, arrays);
    
    // added in gl1.0
    private CullFace_adr := GetProcAddress('glCullFace');
    private ntv_CullFace_1 := GetProcOrNil&<procedure(mode: glTriangleFace)>(CullFace_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullFace(mode: glTriangleFace) :=
      ntv_CullFace_1(mode);
    
    // added in gl4.3
    private DebugMessageCallback_adr := GetProcAddress('glDebugMessageCallback');
    private ntv_DebugMessageCallback_1 := GetProcOrNil&<procedure(callback: glDebugProc; userParam: IntPtr)>(DebugMessageCallback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageCallback(callback: glDebugProc; userParam: IntPtr) :=
      ntv_DebugMessageCallback_1(callback, userParam);
    
    // added in gl4.3
    private DebugMessageControl_adr := GetProcAddress('glDebugMessageControl');
    private ntv_DebugMessageControl_1 := GetProcOrNil&<procedure(source: glDebugSource; &type: glDebugType; severity: glDebugSeverity; count: Int32; var ids: UInt32; enabled: glBool8)>(DebugMessageControl_adr);
    private ntv_DebugMessageControl_2 := GetProcOrNil&<procedure(source: glDebugSource; &type: glDebugType; severity: glDebugSeverity; count: Int32; ids: IntPtr; enabled: glBool8)>(DebugMessageControl_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControl(source: glDebugSource; &type: glDebugType; severity: glDebugSeverity; count: Int32; ids: array of UInt32; enabled: glBool8);
    type PUInt32 = ^UInt32;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_DebugMessageControl_1(source, &type, severity, count, ids[0], enabled) else
        ntv_DebugMessageControl_1(source, &type, severity, count, PUInt32(nil)^, enabled);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControl(source: glDebugSource; &type: glDebugType; severity: glDebugSeverity; count: Int32; var ids: UInt32; enabled: glBool8) :=
      ntv_DebugMessageControl_1(source, &type, severity, count, ids, enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControl(source: glDebugSource; &type: glDebugType; severity: glDebugSeverity; count: Int32; ids: IntPtr; enabled: glBool8) :=
      ntv_DebugMessageControl_2(source, &type, severity, count, ids, enabled);
    
    // added in gl4.3
    private DebugMessageInsert_adr := GetProcAddress('glDebugMessageInsert');
    private ntv_DebugMessageInsert_1 := GetProcOrNil&<procedure(source: glDebugSource; &type: glDebugType; id: UInt32; severity: glDebugSeverity; length: Int32; buf: IntPtr)>(DebugMessageInsert_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsert(source: glDebugSource; &type: glDebugType; id: UInt32; severity: glDebugSeverity; length: Int32; buf: string);
    begin
      var buf_str_ptr := Marshal.StringToHGlobalAnsi(buf);
      try
        ntv_DebugMessageInsert_1(source, &type, id, severity, length, buf_str_ptr);
      finally
        Marshal.FreeHGlobal(buf_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsert(source: glDebugSource; &type: glDebugType; id: UInt32; severity: glDebugSeverity; length: Int32; buf: IntPtr) :=
      ntv_DebugMessageInsert_1(source, &type, id, severity, length, buf);
    
    // added in gl1.5
    private DeleteBuffers_adr := GetProcAddress('glDeleteBuffers');
    private ntv_DeleteBuffers_1 := GetProcOrNil&<procedure(n: Int32; var buffers: gl_buffer)>(DeleteBuffers_adr);
    private ntv_DeleteBuffers_2 := GetProcOrNil&<procedure(n: Int32; buffers: IntPtr)>(DeleteBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffers(n: Int32; buffers: array of gl_buffer);
    type PGl_buffer = ^gl_buffer;
    begin
      if (buffers<>nil) and (buffers.Length<>0) then
        ntv_DeleteBuffers_1(n, buffers[0]) else
        ntv_DeleteBuffers_1(n, PGl_buffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffers(n: Int32; var buffers: gl_buffer) :=
      ntv_DeleteBuffers_1(n, buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffers(n: Int32; buffers: IntPtr) :=
      ntv_DeleteBuffers_2(n, buffers);
    
    // added in gl3.0
    private DeleteFramebuffers_adr := GetProcAddress('glDeleteFramebuffers');
    private ntv_DeleteFramebuffers_1 := GetProcOrNil&<procedure(n: Int32; var framebuffers: gl_framebuffer)>(DeleteFramebuffers_adr);
    private ntv_DeleteFramebuffers_2 := GetProcOrNil&<procedure(n: Int32; framebuffers: IntPtr)>(DeleteFramebuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffers(n: Int32; framebuffers: array of gl_framebuffer);
    type PGl_framebuffer = ^gl_framebuffer;
    begin
      if (framebuffers<>nil) and (framebuffers.Length<>0) then
        ntv_DeleteFramebuffers_1(n, framebuffers[0]) else
        ntv_DeleteFramebuffers_1(n, PGl_framebuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffers(n: Int32; var framebuffers: gl_framebuffer) :=
      ntv_DeleteFramebuffers_1(n, framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffers(n: Int32; framebuffers: IntPtr) :=
      ntv_DeleteFramebuffers_2(n, framebuffers);
    
    // added in gl2.0
    private DeleteProgram_adr := GetProcAddress('glDeleteProgram');
    private ntv_DeleteProgram_1 := GetProcOrNil&<procedure(&program: gl_program)>(DeleteProgram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgram(&program: gl_program) :=
      ntv_DeleteProgram_1(&program);
    
    // added in gl4.1
    private DeleteProgramPipelines_adr := GetProcAddress('glDeleteProgramPipelines');
    private ntv_DeleteProgramPipelines_1 := GetProcOrNil&<procedure(n: Int32; var pipelines: gl_program_pipeline)>(DeleteProgramPipelines_adr);
    private ntv_DeleteProgramPipelines_2 := GetProcOrNil&<procedure(n: Int32; pipelines: IntPtr)>(DeleteProgramPipelines_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelines(n: Int32; pipelines: array of gl_program_pipeline);
    type PGl_program_pipeline = ^gl_program_pipeline;
    begin
      if (pipelines<>nil) and (pipelines.Length<>0) then
        ntv_DeleteProgramPipelines_1(n, pipelines[0]) else
        ntv_DeleteProgramPipelines_1(n, PGl_program_pipeline(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelines(n: Int32; var pipelines: gl_program_pipeline) :=
      ntv_DeleteProgramPipelines_1(n, pipelines);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelines(n: Int32; pipelines: IntPtr) :=
      ntv_DeleteProgramPipelines_2(n, pipelines);
    
    // added in gl1.5
    private DeleteQueries_adr := GetProcAddress('glDeleteQueries');
    private ntv_DeleteQueries_1 := GetProcOrNil&<procedure(n: Int32; var ids: gl_query)>(DeleteQueries_adr);
    private ntv_DeleteQueries_2 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(DeleteQueries_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueries(n: Int32; ids: array of gl_query);
    type PGl_query = ^gl_query;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_DeleteQueries_1(n, ids[0]) else
        ntv_DeleteQueries_1(n, PGl_query(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueries(n: Int32; var ids: gl_query) :=
      ntv_DeleteQueries_1(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueries(n: Int32; ids: IntPtr) :=
      ntv_DeleteQueries_2(n, ids);
    
    // added in gl3.0
    private DeleteRenderbuffers_adr := GetProcAddress('glDeleteRenderbuffers');
    private ntv_DeleteRenderbuffers_1 := GetProcOrNil&<procedure(n: Int32; var renderbuffers: gl_renderbuffer)>(DeleteRenderbuffers_adr);
    private ntv_DeleteRenderbuffers_2 := GetProcOrNil&<procedure(n: Int32; renderbuffers: IntPtr)>(DeleteRenderbuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffers(n: Int32; renderbuffers: array of gl_renderbuffer);
    type PGl_renderbuffer = ^gl_renderbuffer;
    begin
      if (renderbuffers<>nil) and (renderbuffers.Length<>0) then
        ntv_DeleteRenderbuffers_1(n, renderbuffers[0]) else
        ntv_DeleteRenderbuffers_1(n, PGl_renderbuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffers(n: Int32; var renderbuffers: gl_renderbuffer) :=
      ntv_DeleteRenderbuffers_1(n, renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffers(n: Int32; renderbuffers: IntPtr) :=
      ntv_DeleteRenderbuffers_2(n, renderbuffers);
    
    // added in gl3.3
    private DeleteSamplers_adr := GetProcAddress('glDeleteSamplers');
    private ntv_DeleteSamplers_1 := GetProcOrNil&<procedure(count: Int32; var samplers: gl_sampler)>(DeleteSamplers_adr);
    private ntv_DeleteSamplers_2 := GetProcOrNil&<procedure(count: Int32; samplers: IntPtr)>(DeleteSamplers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSamplers(count: Int32; samplers: array of gl_sampler);
    type PGl_sampler = ^gl_sampler;
    begin
      if (samplers<>nil) and (samplers.Length<>0) then
        ntv_DeleteSamplers_1(count, samplers[0]) else
        ntv_DeleteSamplers_1(count, PGl_sampler(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSamplers(count: Int32; var samplers: gl_sampler) :=
      ntv_DeleteSamplers_1(count, samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSamplers(count: Int32; samplers: IntPtr) :=
      ntv_DeleteSamplers_2(count, samplers);
    
    // added in gl2.0
    private DeleteShader_adr := GetProcAddress('glDeleteShader');
    private ntv_DeleteShader_1 := GetProcOrNil&<procedure(shader: gl_shader)>(DeleteShader_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteShader(shader: gl_shader) :=
      ntv_DeleteShader_1(shader);
    
    // added in gl3.2
    private DeleteSync_adr := GetProcAddress('glDeleteSync');
    private ntv_DeleteSync_1 := GetProcOrNil&<procedure(sync: gl_sync)>(DeleteSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSync(sync: gl_sync) :=
      ntv_DeleteSync_1(sync);
    
    // added in gl1.1
    private DeleteTextures_adr := GetProcAddress('glDeleteTextures');
    private ntv_DeleteTextures_1 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture)>(DeleteTextures_adr);
    private ntv_DeleteTextures_2 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr)>(DeleteTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTextures(n: Int32; textures: array of gl_texture);
    type PGl_texture = ^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        ntv_DeleteTextures_1(n, textures[0]) else
        ntv_DeleteTextures_1(n, PGl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTextures(n: Int32; var textures: gl_texture) :=
      ntv_DeleteTextures_1(n, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTextures(n: Int32; textures: IntPtr) :=
      ntv_DeleteTextures_2(n, textures);
    
    // added in gl4.0
    private DeleteTransformFeedbacks_adr := GetProcAddress('glDeleteTransformFeedbacks');
    private ntv_DeleteTransformFeedbacks_1 := GetProcOrNil&<procedure(n: Int32; var ids: gl_transform_feedback)>(DeleteTransformFeedbacks_adr);
    private ntv_DeleteTransformFeedbacks_2 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(DeleteTransformFeedbacks_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacks(n: Int32; ids: array of gl_transform_feedback);
    type PGl_transform_feedback = ^gl_transform_feedback;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_DeleteTransformFeedbacks_1(n, ids[0]) else
        ntv_DeleteTransformFeedbacks_1(n, PGl_transform_feedback(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacks(n: Int32; var ids: gl_transform_feedback) :=
      ntv_DeleteTransformFeedbacks_1(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacks(n: Int32; ids: IntPtr) :=
      ntv_DeleteTransformFeedbacks_2(n, ids);
    
    // added in gl3.0
    private DeleteVertexArrays_adr := GetProcAddress('glDeleteVertexArrays');
    private ntv_DeleteVertexArrays_1 := GetProcOrNil&<procedure(n: Int32; var arrays: gl_vertex_array)>(DeleteVertexArrays_adr);
    private ntv_DeleteVertexArrays_2 := GetProcOrNil&<procedure(n: Int32; arrays: IntPtr)>(DeleteVertexArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArrays(n: Int32; arrays: array of gl_vertex_array);
    type PGl_vertex_array = ^gl_vertex_array;
    begin
      if (arrays<>nil) and (arrays.Length<>0) then
        ntv_DeleteVertexArrays_1(n, arrays[0]) else
        ntv_DeleteVertexArrays_1(n, PGl_vertex_array(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArrays(n: Int32; var arrays: gl_vertex_array) :=
      ntv_DeleteVertexArrays_1(n, arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArrays(n: Int32; arrays: IntPtr) :=
      ntv_DeleteVertexArrays_2(n, arrays);
    
    // added in gl1.0
    private DepthFunc_adr := GetProcAddress('glDepthFunc');
    private ntv_DepthFunc_1 := GetProcOrNil&<procedure(func: glDepthFunction)>(DepthFunc_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthFunc(func: glDepthFunction) :=
      ntv_DepthFunc_1(func);
    
    // added in gl1.0
    private DepthMask_adr := GetProcAddress('glDepthMask');
    private ntv_DepthMask_1 := GetProcOrNil&<procedure(flag: glBool8)>(DepthMask_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthMask(flag: glBool8) :=
      ntv_DepthMask_1(flag);
    
    // added in gl1.0
    private DepthRange_adr := GetProcAddress('glDepthRange');
    private ntv_DepthRange_1 := GetProcOrNil&<procedure(n: double; f: double)>(DepthRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRange(n: double; f: double) :=
      ntv_DepthRange_1(n, f);
    
    // added in gl4.1
    private DepthRangeArrayv_adr := GetProcAddress('glDepthRangeArrayv');
    private ntv_DepthRangeArrayv_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var v: double)>(DepthRangeArrayv_adr);
    private ntv_DepthRangeArrayv_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; v: IntPtr)>(DepthRangeArrayv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayv(first: UInt32; count: Int32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_DepthRangeArrayv_1(first, count, v[0]) else
        ntv_DepthRangeArrayv_1(first, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayv(first: UInt32; count: Int32; var v: double) :=
      ntv_DepthRangeArrayv_1(first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayv(first: UInt32; count: Int32; v: IntPtr) :=
      ntv_DepthRangeArrayv_2(first, count, v);
    
    // added in gl4.1
    private DepthRangef_adr := GetProcAddress('glDepthRangef');
    private ntv_DepthRangef_1 := GetProcOrNil&<procedure(n: single; f: single)>(DepthRangef_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangef(n: single; f: single) :=
      ntv_DepthRangef_1(n, f);
    
    // added in gl4.1
    private DepthRangeIndexed_adr := GetProcAddress('glDepthRangeIndexed');
    private ntv_DepthRangeIndexed_1 := GetProcOrNil&<procedure(index: UInt32; n: double; f: double)>(DepthRangeIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeIndexed(index: UInt32; n: double; f: double) :=
      ntv_DepthRangeIndexed_1(index, n, f);
    
    // added in gl2.0
    private DetachShader_adr := GetProcAddress('glDetachShader');
    private ntv_DetachShader_1 := GetProcOrNil&<procedure(&program: gl_program; shader: gl_shader)>(DetachShader_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetachShader(&program: gl_program; shader: gl_shader) :=
      ntv_DetachShader_1(&program, shader);
    
    // added in gl1.0
    private Disable_adr := GetProcAddress('glDisable');
    private ntv_Disable_1 := GetProcOrNil&<procedure(cap: glEnableCap)>(Disable_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Disable(cap: glEnableCap) :=
      ntv_Disable_1(cap);
    
    // added in gl3.0
    private Disablei_adr := GetProcAddress('glDisablei');
    private ntv_Disablei_1 := GetProcOrNil&<procedure(target: glEnableCap; index: UInt32)>(Disablei_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Disablei(target: glEnableCap; index: UInt32) :=
      ntv_Disablei_1(target, index);
    
    // added in gl4.5
    private DisableVertexArrayAttrib_adr := GetProcAddress('glDisableVertexArrayAttrib');
    private ntv_DisableVertexArrayAttrib_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32)>(DisableVertexArrayAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexArrayAttrib(vaobj: gl_vertex_array; index: UInt32) :=
      ntv_DisableVertexArrayAttrib_1(vaobj, index);
    
    // added in gl2.0
    private DisableVertexAttribArray_adr := GetProcAddress('glDisableVertexAttribArray');
    private ntv_DisableVertexAttribArray_1 := GetProcOrNil&<procedure(index: UInt32)>(DisableVertexAttribArray_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexAttribArray(index: UInt32) :=
      ntv_DisableVertexAttribArray_1(index);
    
    // added in gl4.3
    private DispatchCompute_adr := GetProcAddress('glDispatchCompute');
    private ntv_DispatchCompute_1 := GetProcOrNil&<procedure(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32)>(DispatchCompute_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DispatchCompute(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32) :=
      ntv_DispatchCompute_1(num_groups_x, num_groups_y, num_groups_z);
    
    // added in gl4.3
    private DispatchComputeIndirect_adr := GetProcAddress('glDispatchComputeIndirect');
    private ntv_DispatchComputeIndirect_1 := GetProcOrNil&<procedure(indirect: IntPtr)>(DispatchComputeIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DispatchComputeIndirect(indirect: IntPtr) :=
      ntv_DispatchComputeIndirect_1(indirect);
    
    // added in gl1.1
    private DrawArrays_adr := GetProcAddress('glDrawArrays');
    private ntv_DrawArrays_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; first: Int32; count: Int32)>(DrawArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArrays(mode: glPrimitiveType; first: Int32; count: Int32) :=
      ntv_DrawArrays_1(mode, first, count);
    
    // added in gl4.0
    private DrawArraysIndirect_adr := GetProcAddress('glDrawArraysIndirect');
    private ntv_DrawArraysIndirect_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; indirect: IntPtr)>(DrawArraysIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysIndirect(mode: glPrimitiveType; indirect: IntPtr) :=
      ntv_DrawArraysIndirect_1(mode, indirect);
    
    // added in gl3.1
    private DrawArraysInstanced_adr := GetProcAddress('glDrawArraysInstanced');
    private ntv_DrawArraysInstanced_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; first: Int32; count: Int32; instancecount: Int32)>(DrawArraysInstanced_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysInstanced(mode: glPrimitiveType; first: Int32; count: Int32; instancecount: Int32) :=
      ntv_DrawArraysInstanced_1(mode, first, count, instancecount);
    
    // added in gl4.2
    private DrawArraysInstancedBaseInstance_adr := GetProcAddress('glDrawArraysInstancedBaseInstance');
    private ntv_DrawArraysInstancedBaseInstance_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; first: Int32; count: Int32; instancecount: Int32; baseinstance: UInt32)>(DrawArraysInstancedBaseInstance_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysInstancedBaseInstance(mode: glPrimitiveType; first: Int32; count: Int32; instancecount: Int32; baseinstance: UInt32) :=
      ntv_DrawArraysInstancedBaseInstance_1(mode, first, count, instancecount, baseinstance);
    
    // added in gl1.0
    private DrawBuffer_adr := GetProcAddress('glDrawBuffer');
    private ntv_DrawBuffer_1 := GetProcOrNil&<procedure(buf: glDrawBufferMode)>(DrawBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffer(buf: glDrawBufferMode) :=
      ntv_DrawBuffer_1(buf);
    
    // added in gl2.0
    private DrawBuffers_adr := GetProcAddress('glDrawBuffers');
    private ntv_DrawBuffers_1 := GetProcOrNil&<procedure(n: Int32; var bufs: glDrawBufferMode)>(DrawBuffers_adr);
    private ntv_DrawBuffers_2 := GetProcOrNil&<procedure(n: Int32; bufs: IntPtr)>(DrawBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffers(n: Int32; bufs: array of glDrawBufferMode);
    type PGlDrawBufferMode = ^glDrawBufferMode;
    begin
      if (bufs<>nil) and (bufs.Length<>0) then
        ntv_DrawBuffers_1(n, bufs[0]) else
        ntv_DrawBuffers_1(n, PGlDrawBufferMode(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffers(n: Int32; var bufs: glDrawBufferMode) :=
      ntv_DrawBuffers_1(n, bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffers(n: Int32; bufs: IntPtr) :=
      ntv_DrawBuffers_2(n, bufs);
    
    // added in gl1.1
    private DrawElements_adr := GetProcAddress('glDrawElements');
    private ntv_DrawElements_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr)>(DrawElements_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElements(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr) :=
      ntv_DrawElements_1(mode, count, &type, indices);
    
    // added in gl3.2
    private DrawElementsBaseVertex_adr := GetProcAddress('glDrawElementsBaseVertex');
    private ntv_DrawElementsBaseVertex_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; basevertex: Int32)>(DrawElementsBaseVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsBaseVertex(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; basevertex: Int32) :=
      ntv_DrawElementsBaseVertex_1(mode, count, &type, indices, basevertex);
    
    // added in gl4.0
    private DrawElementsIndirect_adr := GetProcAddress('glDrawElementsIndirect');
    private ntv_DrawElementsIndirect_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr)>(DrawElementsIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsIndirect(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr) :=
      ntv_DrawElementsIndirect_1(mode, &type, indirect);
    
    // added in gl3.1
    private DrawElementsInstanced_adr := GetProcAddress('glDrawElementsInstanced');
    private ntv_DrawElementsInstanced_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; instancecount: Int32)>(DrawElementsInstanced_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstanced(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; instancecount: Int32) :=
      ntv_DrawElementsInstanced_1(mode, count, &type, indices, instancecount);
    
    // added in gl4.2
    private DrawElementsInstancedBaseInstance_adr := GetProcAddress('glDrawElementsInstancedBaseInstance');
    private ntv_DrawElementsInstancedBaseInstance_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; instancecount: Int32; baseinstance: UInt32)>(DrawElementsInstancedBaseInstance_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseInstance(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; instancecount: Int32; baseinstance: UInt32) :=
      ntv_DrawElementsInstancedBaseInstance_1(mode, count, &type, indices, instancecount, baseinstance);
    
    // added in gl3.2
    private DrawElementsInstancedBaseVertex_adr := GetProcAddress('glDrawElementsInstancedBaseVertex');
    private ntv_DrawElementsInstancedBaseVertex_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; instancecount: Int32; basevertex: Int32)>(DrawElementsInstancedBaseVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertex(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; instancecount: Int32; basevertex: Int32) :=
      ntv_DrawElementsInstancedBaseVertex_1(mode, count, &type, indices, instancecount, basevertex);
    
    // added in gl4.2
    private DrawElementsInstancedBaseVertexBaseInstance_adr := GetProcAddress('glDrawElementsInstancedBaseVertexBaseInstance');
    private ntv_DrawElementsInstancedBaseVertexBaseInstance_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; instancecount: Int32; basevertex: Int32; baseinstance: UInt32)>(DrawElementsInstancedBaseVertexBaseInstance_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertexBaseInstance(mode: glPrimitiveType; count: Int32; &type: glDrawElementsType; indices: IntPtr; instancecount: Int32; basevertex: Int32; baseinstance: UInt32) :=
      ntv_DrawElementsInstancedBaseVertexBaseInstance_1(mode, count, &type, indices, instancecount, basevertex, baseinstance);
    
    // added in gl1.2
    private DrawRangeElements_adr := GetProcAddress('glDrawRangeElements');
    private ntv_DrawRangeElements_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: glDrawElementsType; indices: IntPtr)>(DrawRangeElements_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElements(mode: glPrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: glDrawElementsType; indices: IntPtr) :=
      ntv_DrawRangeElements_1(mode, start, &end, count, &type, indices);
    
    // added in gl3.2
    private DrawRangeElementsBaseVertex_adr := GetProcAddress('glDrawRangeElementsBaseVertex');
    private ntv_DrawRangeElementsBaseVertex_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: glDrawElementsType; indices: IntPtr; basevertex: Int32)>(DrawRangeElementsBaseVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementsBaseVertex(mode: glPrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: glDrawElementsType; indices: IntPtr; basevertex: Int32) :=
      ntv_DrawRangeElementsBaseVertex_1(mode, start, &end, count, &type, indices, basevertex);
    
    // added in gl4.0
    private DrawTransformFeedback_adr := GetProcAddress('glDrawTransformFeedback');
    private ntv_DrawTransformFeedback_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; id: gl_transform_feedback)>(DrawTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedback(mode: glPrimitiveType; id: gl_transform_feedback) :=
      ntv_DrawTransformFeedback_1(mode, id);
    
    // added in gl4.2
    private DrawTransformFeedbackInstanced_adr := GetProcAddress('glDrawTransformFeedbackInstanced');
    private ntv_DrawTransformFeedbackInstanced_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; id: gl_transform_feedback; instancecount: Int32)>(DrawTransformFeedbackInstanced_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackInstanced(mode: glPrimitiveType; id: gl_transform_feedback; instancecount: Int32) :=
      ntv_DrawTransformFeedbackInstanced_1(mode, id, instancecount);
    
    // added in gl4.0
    private DrawTransformFeedbackStream_adr := GetProcAddress('glDrawTransformFeedbackStream');
    private ntv_DrawTransformFeedbackStream_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; id: gl_transform_feedback; stream: UInt32)>(DrawTransformFeedbackStream_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackStream(mode: glPrimitiveType; id: gl_transform_feedback; stream: UInt32) :=
      ntv_DrawTransformFeedbackStream_1(mode, id, stream);
    
    // added in gl4.2
    private DrawTransformFeedbackStreamInstanced_adr := GetProcAddress('glDrawTransformFeedbackStreamInstanced');
    private ntv_DrawTransformFeedbackStreamInstanced_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; id: gl_transform_feedback; stream: UInt32; instancecount: Int32)>(DrawTransformFeedbackStreamInstanced_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackStreamInstanced(mode: glPrimitiveType; id: gl_transform_feedback; stream: UInt32; instancecount: Int32) :=
      ntv_DrawTransformFeedbackStreamInstanced_1(mode, id, stream, instancecount);
    
    // added in gl1.0
    private Enable_adr := GetProcAddress('glEnable');
    private ntv_Enable_1 := GetProcOrNil&<procedure(cap: glEnableCap)>(Enable_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Enable(cap: glEnableCap) :=
      ntv_Enable_1(cap);
    
    // added in gl3.0
    private Enablei_adr := GetProcAddress('glEnablei');
    private ntv_Enablei_1 := GetProcOrNil&<procedure(target: glEnableCap; index: UInt32)>(Enablei_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Enablei(target: glEnableCap; index: UInt32) :=
      ntv_Enablei_1(target, index);
    
    // added in gl4.5
    private EnableVertexArrayAttrib_adr := GetProcAddress('glEnableVertexArrayAttrib');
    private ntv_EnableVertexArrayAttrib_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32)>(EnableVertexArrayAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexArrayAttrib(vaobj: gl_vertex_array; index: UInt32) :=
      ntv_EnableVertexArrayAttrib_1(vaobj, index);
    
    // added in gl2.0
    private EnableVertexAttribArray_adr := GetProcAddress('glEnableVertexAttribArray');
    private ntv_EnableVertexAttribArray_1 := GetProcOrNil&<procedure(index: UInt32)>(EnableVertexAttribArray_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexAttribArray(index: UInt32) :=
      ntv_EnableVertexAttribArray_1(index);
    
    // added in gl3.0
    private EndConditionalRender_adr := GetProcAddress('glEndConditionalRender');
    private ntv_EndConditionalRender_1 := GetProcOrNil&<procedure>(EndConditionalRender_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndConditionalRender :=
      ntv_EndConditionalRender_1;
    
    // added in gl1.5
    private EndQuery_adr := GetProcAddress('glEndQuery');
    private ntv_EndQuery_1 := GetProcOrNil&<procedure(target: glQueryTarget)>(EndQuery_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndQuery(target: glQueryTarget) :=
      ntv_EndQuery_1(target);
    
    // added in gl4.0
    private EndQueryIndexed_adr := GetProcAddress('glEndQueryIndexed');
    private ntv_EndQueryIndexed_1 := GetProcOrNil&<procedure(target: glQueryTarget; index: UInt32)>(EndQueryIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndQueryIndexed(target: glQueryTarget; index: UInt32) :=
      ntv_EndQueryIndexed_1(target, index);
    
    // added in gl3.0
    private EndTransformFeedback_adr := GetProcAddress('glEndTransformFeedback');
    private ntv_EndTransformFeedback_1 := GetProcOrNil&<procedure>(EndTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndTransformFeedback :=
      ntv_EndTransformFeedback_1;
    
    // added in gl3.2
    private FenceSync_adr := GetProcAddress('glFenceSync');
    private ntv_FenceSync_1 := GetProcOrNil&<function(condition: glSyncCondition; flags: glSyncBehaviorFlags): gl_sync>(FenceSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function FenceSync(condition: glSyncCondition; flags: glSyncBehaviorFlags): gl_sync :=
      ntv_FenceSync_1(condition, flags);
    
    // added in gl1.0
    private Finish_adr := GetProcAddress('glFinish');
    private ntv_Finish_1 := GetProcOrNil&<procedure>(Finish_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Finish :=
      ntv_Finish_1;
    
    // added in gl1.0
    private Flush_adr := GetProcAddress('glFlush');
    private ntv_Flush_1 := GetProcOrNil&<procedure>(Flush_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Flush :=
      ntv_Flush_1;
    
    // added in gl3.0
    private FlushMappedBufferRange_adr := GetProcAddress('glFlushMappedBufferRange');
    private ntv_FlushMappedBufferRange_1 := GetProcOrNil&<procedure(target: glBufferTarget; offset: IntPtr; length: UIntPtr)>(FlushMappedBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushMappedBufferRange(target: glBufferTarget; offset: IntPtr; length: UIntPtr) :=
      ntv_FlushMappedBufferRange_1(target, offset, length);
    
    // added in gl4.5
    private FlushMappedNamedBufferRange_adr := GetProcAddress('glFlushMappedNamedBufferRange');
    private ntv_FlushMappedNamedBufferRange_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; length: UIntPtr)>(FlushMappedNamedBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushMappedNamedBufferRange(buffer: gl_buffer; offset: IntPtr; length: UIntPtr) :=
      ntv_FlushMappedNamedBufferRange_1(buffer, offset, length);
    
    // added in gl4.3
    private FramebufferParameteri_adr := GetProcAddress('glFramebufferParameteri');
    private ntv_FramebufferParameteri_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; pname: glFramebufferParameterName; param: Int32)>(FramebufferParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferParameteri(target: glFramebufferTarget; pname: glFramebufferParameterName; param: Int32) :=
      ntv_FramebufferParameteri_1(target, pname, param);
    
    // added in gl3.0
    private FramebufferRenderbuffer_adr := GetProcAddress('glFramebufferRenderbuffer');
    private ntv_FramebufferRenderbuffer_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; renderbuffertarget: glRenderbufferTarget; renderbuffer: gl_renderbuffer)>(FramebufferRenderbuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferRenderbuffer(target: glFramebufferTarget; attachment: glFramebufferAttachment; renderbuffertarget: glRenderbufferTarget; renderbuffer: gl_renderbuffer) :=
      ntv_FramebufferRenderbuffer_1(target, attachment, renderbuffertarget, renderbuffer);
    
    // added in gl3.2
    private FramebufferTexture_adr := GetProcAddress('glFramebufferTexture');
    private ntv_FramebufferTexture_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32)>(FramebufferTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32) :=
      ntv_FramebufferTexture_1(target, attachment, texture, level);
    
    // added in gl3.0
    private FramebufferTexture1D_adr := GetProcAddress('glFramebufferTexture1D');
    private ntv_FramebufferTexture1D_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32)>(FramebufferTexture1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture1D(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32) :=
      ntv_FramebufferTexture1D_1(target, attachment, textarget, texture, level);
    
    // added in gl3.0
    private FramebufferTexture2D_adr := GetProcAddress('glFramebufferTexture2D');
    private ntv_FramebufferTexture2D_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32)>(FramebufferTexture2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture2D(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32) :=
      ntv_FramebufferTexture2D_1(target, attachment, textarget, texture, level);
    
    // added in gl3.0
    private FramebufferTexture3D_adr := GetProcAddress('glFramebufferTexture3D');
    private ntv_FramebufferTexture3D_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32; zoffset: Int32)>(FramebufferTexture3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture3D(target: glFramebufferTarget; attachment: glFramebufferAttachment; textarget: glTextureTarget; texture: gl_texture; level: Int32; zoffset: Int32) :=
      ntv_FramebufferTexture3D_1(target, attachment, textarget, texture, level, zoffset);
    
    // added in gl3.0
    private FramebufferTextureLayer_adr := GetProcAddress('glFramebufferTextureLayer');
    private ntv_FramebufferTextureLayer_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32)>(FramebufferTextureLayer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureLayer(target: glFramebufferTarget; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32) :=
      ntv_FramebufferTextureLayer_1(target, attachment, texture, level, layer);
    
    // added in gl1.0
    private FrontFace_adr := GetProcAddress('glFrontFace');
    private ntv_FrontFace_1 := GetProcOrNil&<procedure(mode: glFrontFaceDirection)>(FrontFace_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrontFace(mode: glFrontFaceDirection) :=
      ntv_FrontFace_1(mode);
    
    // added in gl1.5
    private GenBuffers_adr := GetProcAddress('glGenBuffers');
    private ntv_GenBuffers_1 := GetProcOrNil&<procedure(n: Int32; var buffers: gl_buffer)>(GenBuffers_adr);
    private ntv_GenBuffers_2 := GetProcOrNil&<procedure(n: Int32; buffers: IntPtr)>(GenBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffers(n: Int32; buffers: array of gl_buffer);
    type PGl_buffer = ^gl_buffer;
    begin
      if (buffers<>nil) and (buffers.Length<>0) then
        ntv_GenBuffers_1(n, buffers[0]) else
        ntv_GenBuffers_1(n, PGl_buffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffers(n: Int32; var buffers: gl_buffer) :=
      ntv_GenBuffers_1(n, buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffers(n: Int32; buffers: IntPtr) :=
      ntv_GenBuffers_2(n, buffers);
    
    // added in gl3.0
    private GenerateMipmap_adr := GetProcAddress('glGenerateMipmap');
    private ntv_GenerateMipmap_1 := GetProcOrNil&<procedure(target: glTextureTarget)>(GenerateMipmap_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateMipmap(target: glTextureTarget) :=
      ntv_GenerateMipmap_1(target);
    
    // added in gl4.5
    private GenerateTextureMipmap_adr := GetProcAddress('glGenerateTextureMipmap');
    private ntv_GenerateTextureMipmap_1 := GetProcOrNil&<procedure(texture: gl_texture)>(GenerateTextureMipmap_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateTextureMipmap(texture: gl_texture) :=
      ntv_GenerateTextureMipmap_1(texture);
    
    // added in gl3.0
    private GenFramebuffers_adr := GetProcAddress('glGenFramebuffers');
    private ntv_GenFramebuffers_1 := GetProcOrNil&<procedure(n: Int32; var framebuffers: gl_framebuffer)>(GenFramebuffers_adr);
    private ntv_GenFramebuffers_2 := GetProcOrNil&<procedure(n: Int32; framebuffers: IntPtr)>(GenFramebuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffers(n: Int32; framebuffers: array of gl_framebuffer);
    type PGl_framebuffer = ^gl_framebuffer;
    begin
      if (framebuffers<>nil) and (framebuffers.Length<>0) then
        ntv_GenFramebuffers_1(n, framebuffers[0]) else
        ntv_GenFramebuffers_1(n, PGl_framebuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffers(n: Int32; var framebuffers: gl_framebuffer) :=
      ntv_GenFramebuffers_1(n, framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffers(n: Int32; framebuffers: IntPtr) :=
      ntv_GenFramebuffers_2(n, framebuffers);
    
    // added in gl4.1
    private GenProgramPipelines_adr := GetProcAddress('glGenProgramPipelines');
    private ntv_GenProgramPipelines_1 := GetProcOrNil&<procedure(n: Int32; var pipelines: gl_program_pipeline)>(GenProgramPipelines_adr);
    private ntv_GenProgramPipelines_2 := GetProcOrNil&<procedure(n: Int32; pipelines: IntPtr)>(GenProgramPipelines_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelines(n: Int32; pipelines: array of gl_program_pipeline);
    type PGl_program_pipeline = ^gl_program_pipeline;
    begin
      if (pipelines<>nil) and (pipelines.Length<>0) then
        ntv_GenProgramPipelines_1(n, pipelines[0]) else
        ntv_GenProgramPipelines_1(n, PGl_program_pipeline(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelines(n: Int32; var pipelines: gl_program_pipeline) :=
      ntv_GenProgramPipelines_1(n, pipelines);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelines(n: Int32; pipelines: IntPtr) :=
      ntv_GenProgramPipelines_2(n, pipelines);
    
    // added in gl1.5
    private GenQueries_adr := GetProcAddress('glGenQueries');
    private ntv_GenQueries_1 := GetProcOrNil&<procedure(n: Int32; var ids: gl_query)>(GenQueries_adr);
    private ntv_GenQueries_2 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(GenQueries_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueries(n: Int32; ids: array of gl_query);
    type PGl_query = ^gl_query;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_GenQueries_1(n, ids[0]) else
        ntv_GenQueries_1(n, PGl_query(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueries(n: Int32; var ids: gl_query) :=
      ntv_GenQueries_1(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueries(n: Int32; ids: IntPtr) :=
      ntv_GenQueries_2(n, ids);
    
    // added in gl3.0
    private GenRenderbuffers_adr := GetProcAddress('glGenRenderbuffers');
    private ntv_GenRenderbuffers_1 := GetProcOrNil&<procedure(n: Int32; var renderbuffers: gl_renderbuffer)>(GenRenderbuffers_adr);
    private ntv_GenRenderbuffers_2 := GetProcOrNil&<procedure(n: Int32; renderbuffers: IntPtr)>(GenRenderbuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffers(n: Int32; renderbuffers: array of gl_renderbuffer);
    type PGl_renderbuffer = ^gl_renderbuffer;
    begin
      if (renderbuffers<>nil) and (renderbuffers.Length<>0) then
        ntv_GenRenderbuffers_1(n, renderbuffers[0]) else
        ntv_GenRenderbuffers_1(n, PGl_renderbuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffers(n: Int32; var renderbuffers: gl_renderbuffer) :=
      ntv_GenRenderbuffers_1(n, renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffers(n: Int32; renderbuffers: IntPtr) :=
      ntv_GenRenderbuffers_2(n, renderbuffers);
    
    // added in gl3.3
    private GenSamplers_adr := GetProcAddress('glGenSamplers');
    private ntv_GenSamplers_1 := GetProcOrNil&<procedure(count: Int32; var samplers: gl_sampler)>(GenSamplers_adr);
    private ntv_GenSamplers_2 := GetProcOrNil&<procedure(count: Int32; samplers: IntPtr)>(GenSamplers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSamplers(count: Int32; samplers: array of gl_sampler);
    type PGl_sampler = ^gl_sampler;
    begin
      if (samplers<>nil) and (samplers.Length<>0) then
        ntv_GenSamplers_1(count, samplers[0]) else
        ntv_GenSamplers_1(count, PGl_sampler(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSamplers(count: Int32; var samplers: gl_sampler) :=
      ntv_GenSamplers_1(count, samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSamplers(count: Int32; samplers: IntPtr) :=
      ntv_GenSamplers_2(count, samplers);
    
    // added in gl1.1
    private GenTextures_adr := GetProcAddress('glGenTextures');
    private ntv_GenTextures_1 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture)>(GenTextures_adr);
    private ntv_GenTextures_2 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr)>(GenTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTextures(n: Int32; textures: array of gl_texture);
    type PGl_texture = ^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        ntv_GenTextures_1(n, textures[0]) else
        ntv_GenTextures_1(n, PGl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTextures(n: Int32; var textures: gl_texture) :=
      ntv_GenTextures_1(n, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTextures(n: Int32; textures: IntPtr) :=
      ntv_GenTextures_2(n, textures);
    
    // added in gl4.0
    private GenTransformFeedbacks_adr := GetProcAddress('glGenTransformFeedbacks');
    private ntv_GenTransformFeedbacks_1 := GetProcOrNil&<procedure(n: Int32; var ids: gl_transform_feedback)>(GenTransformFeedbacks_adr);
    private ntv_GenTransformFeedbacks_2 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(GenTransformFeedbacks_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacks(n: Int32; ids: array of gl_transform_feedback);
    type PGl_transform_feedback = ^gl_transform_feedback;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        ntv_GenTransformFeedbacks_1(n, ids[0]) else
        ntv_GenTransformFeedbacks_1(n, PGl_transform_feedback(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacks(n: Int32; var ids: gl_transform_feedback) :=
      ntv_GenTransformFeedbacks_1(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacks(n: Int32; ids: IntPtr) :=
      ntv_GenTransformFeedbacks_2(n, ids);
    
    // added in gl3.0
    private GenVertexArrays_adr := GetProcAddress('glGenVertexArrays');
    private ntv_GenVertexArrays_1 := GetProcOrNil&<procedure(n: Int32; var arrays: gl_vertex_array)>(GenVertexArrays_adr);
    private ntv_GenVertexArrays_2 := GetProcOrNil&<procedure(n: Int32; arrays: IntPtr)>(GenVertexArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArrays(n: Int32; arrays: array of gl_vertex_array);
    type PGl_vertex_array = ^gl_vertex_array;
    begin
      if (arrays<>nil) and (arrays.Length<>0) then
        ntv_GenVertexArrays_1(n, arrays[0]) else
        ntv_GenVertexArrays_1(n, PGl_vertex_array(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArrays(n: Int32; var arrays: gl_vertex_array) :=
      ntv_GenVertexArrays_1(n, arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArrays(n: Int32; arrays: IntPtr) :=
      ntv_GenVertexArrays_2(n, arrays);
    
    // added in gl4.2
    private GetActiveAtomicCounterBufferiv_adr := GetProcAddress('glGetActiveAtomicCounterBufferiv');
    private ntv_GetActiveAtomicCounterBufferiv_1 := GetProcOrNil&<procedure(&program: gl_program; bufferIndex: UInt32; pname: glAtomicCounterBufferPName; var &params: Int32)>(GetActiveAtomicCounterBufferiv_adr);
    private ntv_GetActiveAtomicCounterBufferiv_2 := GetProcOrNil&<procedure(&program: gl_program; bufferIndex: UInt32; pname: glAtomicCounterBufferPName; &params: IntPtr)>(GetActiveAtomicCounterBufferiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAtomicCounterBufferiv(&program: gl_program; bufferIndex: UInt32; pname: glAtomicCounterBufferPName; var &params: Int32) :=
      ntv_GetActiveAtomicCounterBufferiv_1(&program, bufferIndex, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAtomicCounterBufferiv(&program: gl_program; bufferIndex: UInt32; pname: glAtomicCounterBufferPName; &params: IntPtr) :=
      ntv_GetActiveAtomicCounterBufferiv_2(&program, bufferIndex, pname, &params);
    
    // added in gl2.0
    private GetActiveAttrib_adr := GetProcAddress('glGetActiveAttrib');
    private ntv_GetActiveAttrib_1 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: glAttributeType; name: IntPtr)>(GetActiveAttrib_adr);
    private ntv_GetActiveAttrib_2 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr)>(GetActiveAttrib_adr);
    private ntv_GetActiveAttrib_3 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: glAttributeType; name: IntPtr)>(GetActiveAttrib_adr);
    private ntv_GetActiveAttrib_4 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr)>(GetActiveAttrib_adr);
    private ntv_GetActiveAttrib_5 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: glAttributeType; name: IntPtr)>(GetActiveAttrib_adr);
    private ntv_GetActiveAttrib_6 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr)>(GetActiveAttrib_adr);
    private ntv_GetActiveAttrib_7 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: glAttributeType; name: IntPtr)>(GetActiveAttrib_adr);
    private ntv_GetActiveAttrib_8 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr)>(GetActiveAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: glAttributeType; name: IntPtr) :=
      ntv_GetActiveAttrib_1(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveAttrib_2(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: glAttributeType; name: IntPtr) :=
      ntv_GetActiveAttrib_3(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveAttrib_4(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: glAttributeType; name: IntPtr) :=
      ntv_GetActiveAttrib_5(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveAttrib_6(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: glAttributeType; name: IntPtr) :=
      ntv_GetActiveAttrib_7(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveAttrib_8(&program, index, bufSize, length, size, &type, name);
    
    // added in gl4.0
    private GetActiveSubroutineName_adr := GetProcAddress('glGetActiveSubroutineName');
    private ntv_GetActiveSubroutineName_1 := GetProcOrNil&<procedure(&program: gl_program; shadertype: glShaderType; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr)>(GetActiveSubroutineName_adr);
    private ntv_GetActiveSubroutineName_2 := GetProcOrNil&<procedure(&program: gl_program; shadertype: glShaderType; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr)>(GetActiveSubroutineName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineName(&program: gl_program; shadertype: glShaderType; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr) :=
      ntv_GetActiveSubroutineName_1(&program, shadertype, index, bufSize, length, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineName(&program: gl_program; shadertype: glShaderType; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr) :=
      ntv_GetActiveSubroutineName_2(&program, shadertype, index, bufSize, length, name);
    
    // added in gl4.0
    private GetActiveSubroutineUniformiv_adr := GetProcAddress('glGetActiveSubroutineUniformiv');
    private ntv_GetActiveSubroutineUniformiv_1 := GetProcOrNil&<procedure(&program: gl_program; shadertype: glShaderType; index: UInt32; pname: glSubroutineParameterName; var values: Int32)>(GetActiveSubroutineUniformiv_adr);
    private ntv_GetActiveSubroutineUniformiv_2 := GetProcOrNil&<procedure(&program: gl_program; shadertype: glShaderType; index: UInt32; pname: glSubroutineParameterName; values: IntPtr)>(GetActiveSubroutineUniformiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformiv(&program: gl_program; shadertype: glShaderType; index: UInt32; pname: glSubroutineParameterName; var values: Int32) :=
      ntv_GetActiveSubroutineUniformiv_1(&program, shadertype, index, pname, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformiv(&program: gl_program; shadertype: glShaderType; index: UInt32; pname: glSubroutineParameterName; values: IntPtr) :=
      ntv_GetActiveSubroutineUniformiv_2(&program, shadertype, index, pname, values);
    
    // added in gl4.0
    private GetActiveSubroutineUniformName_adr := GetProcAddress('glGetActiveSubroutineUniformName');
    private ntv_GetActiveSubroutineUniformName_1 := GetProcOrNil&<procedure(&program: gl_program; shadertype: glShaderType; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr)>(GetActiveSubroutineUniformName_adr);
    private ntv_GetActiveSubroutineUniformName_2 := GetProcOrNil&<procedure(&program: gl_program; shadertype: glShaderType; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr)>(GetActiveSubroutineUniformName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformName(&program: gl_program; shadertype: glShaderType; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr) :=
      ntv_GetActiveSubroutineUniformName_1(&program, shadertype, index, bufSize, length, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformName(&program: gl_program; shadertype: glShaderType; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr) :=
      ntv_GetActiveSubroutineUniformName_2(&program, shadertype, index, bufSize, length, name);
    
    // added in gl2.0
    private GetActiveUniform_adr := GetProcAddress('glGetActiveUniform');
    private ntv_GetActiveUniform_1 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: glUniformType; name: IntPtr)>(GetActiveUniform_adr);
    private ntv_GetActiveUniform_2 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr)>(GetActiveUniform_adr);
    private ntv_GetActiveUniform_3 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: glUniformType; name: IntPtr)>(GetActiveUniform_adr);
    private ntv_GetActiveUniform_4 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr)>(GetActiveUniform_adr);
    private ntv_GetActiveUniform_5 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: glUniformType; name: IntPtr)>(GetActiveUniform_adr);
    private ntv_GetActiveUniform_6 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr)>(GetActiveUniform_adr);
    private ntv_GetActiveUniform_7 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: glUniformType; name: IntPtr)>(GetActiveUniform_adr);
    private ntv_GetActiveUniform_8 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr)>(GetActiveUniform_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: glUniformType; name: IntPtr) :=
      ntv_GetActiveUniform_1(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveUniform_2(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: glUniformType; name: IntPtr) :=
      ntv_GetActiveUniform_3(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveUniform_4(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: glUniformType; name: IntPtr) :=
      ntv_GetActiveUniform_5(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveUniform_6(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: glUniformType; name: IntPtr) :=
      ntv_GetActiveUniform_7(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr) :=
      ntv_GetActiveUniform_8(&program, index, bufSize, length, size, &type, name);
    
    // added in gl3.1
    private GetActiveUniformBlockiv_adr := GetProcAddress('glGetActiveUniformBlockiv');
    private ntv_GetActiveUniformBlockiv_1 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; pname: glUniformBlockPName; var &params: Int32)>(GetActiveUniformBlockiv_adr);
    private ntv_GetActiveUniformBlockiv_2 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; pname: glUniformBlockPName; &params: IntPtr)>(GetActiveUniformBlockiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockiv(&program: gl_program; uniformBlockIndex: UInt32; pname: glUniformBlockPName; var &params: Int32) :=
      ntv_GetActiveUniformBlockiv_1(&program, uniformBlockIndex, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockiv(&program: gl_program; uniformBlockIndex: UInt32; pname: glUniformBlockPName; &params: IntPtr) :=
      ntv_GetActiveUniformBlockiv_2(&program, uniformBlockIndex, pname, &params);
    
    // added in gl3.1
    private GetActiveUniformBlockName_adr := GetProcAddress('glGetActiveUniformBlockName');
    private ntv_GetActiveUniformBlockName_1 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; bufSize: Int32; var length: Int32; uniformBlockName: IntPtr)>(GetActiveUniformBlockName_adr);
    private ntv_GetActiveUniformBlockName_2 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; bufSize: Int32; length: IntPtr; uniformBlockName: IntPtr)>(GetActiveUniformBlockName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockName(&program: gl_program; uniformBlockIndex: UInt32; bufSize: Int32; var length: Int32; uniformBlockName: IntPtr) :=
      ntv_GetActiveUniformBlockName_1(&program, uniformBlockIndex, bufSize, length, uniformBlockName);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockName(&program: gl_program; uniformBlockIndex: UInt32; bufSize: Int32; length: IntPtr; uniformBlockName: IntPtr) :=
      ntv_GetActiveUniformBlockName_2(&program, uniformBlockIndex, bufSize, length, uniformBlockName);
    
    // added in gl3.1
    private GetActiveUniformName_adr := GetProcAddress('glGetActiveUniformName');
    private ntv_GetActiveUniformName_1 := GetProcOrNil&<procedure(&program: gl_program; uniformIndex: UInt32; bufSize: Int32; var length: Int32; uniformName: IntPtr)>(GetActiveUniformName_adr);
    private ntv_GetActiveUniformName_2 := GetProcOrNil&<procedure(&program: gl_program; uniformIndex: UInt32; bufSize: Int32; length: IntPtr; uniformName: IntPtr)>(GetActiveUniformName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformName(&program: gl_program; uniformIndex: UInt32; bufSize: Int32; var length: Int32; uniformName: IntPtr) :=
      ntv_GetActiveUniformName_1(&program, uniformIndex, bufSize, length, uniformName);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformName(&program: gl_program; uniformIndex: UInt32; bufSize: Int32; length: IntPtr; uniformName: IntPtr) :=
      ntv_GetActiveUniformName_2(&program, uniformIndex, bufSize, length, uniformName);
    
    // added in gl3.1
    private GetActiveUniformsiv_adr := GetProcAddress('glGetActiveUniformsiv');
    private ntv_GetActiveUniformsiv_1 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; var uniformIndices: UInt32; pname: glUniformPName; var &params: Int32)>(GetActiveUniformsiv_adr);
    private ntv_GetActiveUniformsiv_2 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; uniformIndices: IntPtr; pname: glUniformPName; &params: IntPtr)>(GetActiveUniformsiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformsiv(&program: gl_program; uniformCount: Int32; uniformIndices: array of UInt32; pname: glUniformPName; &params: array of Int32);
    type PUInt32 = ^UInt32;
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        if (uniformIndices<>nil) and (uniformIndices.Length<>0) then
          ntv_GetActiveUniformsiv_1(&program, uniformCount, uniformIndices[0], pname, &params[0]) else
          ntv_GetActiveUniformsiv_1(&program, uniformCount, PUInt32(nil)^, pname, &params[0]) else
        if (uniformIndices<>nil) and (uniformIndices.Length<>0) then
          ntv_GetActiveUniformsiv_1(&program, uniformCount, uniformIndices[0], pname, PInt32(nil)^) else
          ntv_GetActiveUniformsiv_1(&program, uniformCount, PUInt32(nil)^, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformsiv(&program: gl_program; uniformCount: Int32; var uniformIndices: UInt32; pname: glUniformPName; var &params: Int32) :=
      ntv_GetActiveUniformsiv_1(&program, uniformCount, uniformIndices, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformsiv(&program: gl_program; uniformCount: Int32; uniformIndices: IntPtr; pname: glUniformPName; &params: IntPtr) :=
      ntv_GetActiveUniformsiv_2(&program, uniformCount, uniformIndices, pname, &params);
    
    // added in gl2.0
    private GetAttachedShaders_adr := GetProcAddress('glGetAttachedShaders');
    private ntv_GetAttachedShaders_1 := GetProcOrNil&<procedure(&program: gl_program; maxCount: Int32; var count: Int32; var shaders: gl_shader)>(GetAttachedShaders_adr);
    private ntv_GetAttachedShaders_2 := GetProcOrNil&<procedure(&program: gl_program; maxCount: Int32; var count: Int32; shaders: IntPtr)>(GetAttachedShaders_adr);
    private ntv_GetAttachedShaders_3 := GetProcOrNil&<procedure(&program: gl_program; maxCount: Int32; count: IntPtr; var shaders: gl_shader)>(GetAttachedShaders_adr);
    private ntv_GetAttachedShaders_4 := GetProcOrNil&<procedure(&program: gl_program; maxCount: Int32; count: IntPtr; shaders: IntPtr)>(GetAttachedShaders_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedShaders(&program: gl_program; maxCount: Int32; var count: Int32; var shaders: gl_shader) :=
      ntv_GetAttachedShaders_1(&program, maxCount, count, shaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedShaders(&program: gl_program; maxCount: Int32; var count: Int32; shaders: IntPtr) :=
      ntv_GetAttachedShaders_2(&program, maxCount, count, shaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedShaders(&program: gl_program; maxCount: Int32; count: IntPtr; var shaders: gl_shader) :=
      ntv_GetAttachedShaders_3(&program, maxCount, count, shaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedShaders(&program: gl_program; maxCount: Int32; count: IntPtr; shaders: IntPtr) :=
      ntv_GetAttachedShaders_4(&program, maxCount, count, shaders);
    
    // added in gl2.0
    private GetAttribLocation_adr := GetProcAddress('glGetAttribLocation');
    private ntv_GetAttribLocation_1 := GetProcOrNil&<function(&program: gl_program; name: IntPtr): Int32>(GetAttribLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAttribLocation(&program: gl_program; name: string): Int32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetAttribLocation_1(&program, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAttribLocation(&program: gl_program; name: IntPtr): Int32 :=
      ntv_GetAttribLocation_1(&program, name);
    
    // added in gl3.0
    private GetBooleani_v_adr := GetProcAddress('glGetBooleani_v');
    private ntv_GetBooleani_v_1 := GetProcOrNil&<procedure(target: glBufferTarget; index: UInt32; var data: glBool8)>(GetBooleani_v_adr);
    private ntv_GetBooleani_v_2 := GetProcOrNil&<procedure(target: glBufferTarget; index: UInt32; data: IntPtr)>(GetBooleani_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleani_v(target: glBufferTarget; index: UInt32; var data: glBool8) :=
      ntv_GetBooleani_v_1(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleani_v(target: glBufferTarget; index: UInt32; data: IntPtr) :=
      ntv_GetBooleani_v_2(target, index, data);
    
    // added in gl1.0
    private GetBooleanv_adr := GetProcAddress('glGetBooleanv');
    private ntv_GetBooleanv_1 := GetProcOrNil&<procedure(pname: glGetPName; var data: glBool8)>(GetBooleanv_adr);
    private ntv_GetBooleanv_2 := GetProcOrNil&<procedure(pname: glGetPName; data: IntPtr)>(GetBooleanv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanv(pname: glGetPName; var data: glBool8) :=
      ntv_GetBooleanv_1(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanv(pname: glGetPName; data: IntPtr) :=
      ntv_GetBooleanv_2(pname, data);
    
    // added in gl3.2
    private GetBufferParameteri64v_adr := GetProcAddress('glGetBufferParameteri64v');
    private ntv_GetBufferParameteri64v_1 := GetProcOrNil&<procedure(target: glBufferTarget; pname: glBufferPName; var &params: Int64)>(GetBufferParameteri64v_adr);
    private ntv_GetBufferParameteri64v_2 := GetProcOrNil&<procedure(target: glBufferTarget; pname: glBufferPName; &params: IntPtr)>(GetBufferParameteri64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameteri64v(target: glBufferTarget; pname: glBufferPName; var &params: Int64) :=
      ntv_GetBufferParameteri64v_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameteri64v(target: glBufferTarget; pname: glBufferPName; &params: IntPtr) :=
      ntv_GetBufferParameteri64v_2(target, pname, &params);
    
    // added in gl1.5
    private GetBufferParameteriv_adr := GetProcAddress('glGetBufferParameteriv');
    private ntv_GetBufferParameteriv_1 := GetProcOrNil&<procedure(target: glBufferTarget; pname: glBufferPName; var &params: Int32)>(GetBufferParameteriv_adr);
    private ntv_GetBufferParameteriv_2 := GetProcOrNil&<procedure(target: glBufferTarget; pname: glBufferPName; &params: IntPtr)>(GetBufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameteriv(target: glBufferTarget; pname: glBufferPName; var &params: Int32) :=
      ntv_GetBufferParameteriv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameteriv(target: glBufferTarget; pname: glBufferPName; &params: IntPtr) :=
      ntv_GetBufferParameteriv_2(target, pname, &params);
    
    // added in gl1.5
    private GetBufferPointerv_adr := GetProcAddress('glGetBufferPointerv');
    private ntv_GetBufferPointerv_1 := GetProcOrNil&<procedure(target: glBufferTarget; pname: glBufferPointerName; var &params: IntPtr)>(GetBufferPointerv_adr);
    private ntv_GetBufferPointerv_2 := GetProcOrNil&<procedure(target: glBufferTarget; pname: glBufferPointerName; &params: pointer)>(GetBufferPointerv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferPointerv(target: glBufferTarget; pname: glBufferPointerName; var &params: IntPtr) :=
      ntv_GetBufferPointerv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferPointerv(target: glBufferTarget; pname: glBufferPointerName; &params: pointer) :=
      ntv_GetBufferPointerv_2(target, pname, &params);
    
    // added in gl1.5
    private GetBufferSubData_adr := GetProcAddress('glGetBufferSubData');
    private ntv_GetBufferSubData_1 := GetProcOrNil&<procedure(target: glBufferTarget; offset: IntPtr; size: UIntPtr; var data: Byte)>(GetBufferSubData_adr);
    private ntv_GetBufferSubData_2 := GetProcOrNil&<procedure(target: glBufferTarget; offset: IntPtr; size: UIntPtr; data: pointer)>(GetBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferSubData<T>(target: glBufferTarget; offset: IntPtr; size: UIntPtr; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        GetBufferSubData(target, offset, size, data[0]) else
        GetBufferSubData(target, offset, size, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferSubData<T>(target: glBufferTarget; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      ntv_GetBufferSubData_1(target, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferSubData(target: glBufferTarget; offset: IntPtr; size: UIntPtr; data: pointer) :=
      ntv_GetBufferSubData_2(target, offset, size, data);
    
    // added in gl1.3
    private GetCompressedTexImage_adr := GetProcAddress('glGetCompressedTexImage');
    private ntv_GetCompressedTexImage_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; img: IntPtr)>(GetCompressedTexImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTexImage(target: glTextureTarget; level: Int32; img: IntPtr) :=
      ntv_GetCompressedTexImage_1(target, level, img);
    
    // added in gl4.5
    private GetCompressedTextureImage_adr := GetProcAddress('glGetCompressedTextureImage');
    private ntv_GetCompressedTextureImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; bufSize: Int32; pixels: IntPtr)>(GetCompressedTextureImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureImage(texture: gl_texture; level: Int32; bufSize: Int32; pixels: IntPtr) :=
      ntv_GetCompressedTextureImage_1(texture, level, bufSize, pixels);
    
    // added in gl4.5
    private GetCompressedTextureSubImage_adr := GetProcAddress('glGetCompressedTextureSubImage');
    private ntv_GetCompressedTextureSubImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; bufSize: Int32; pixels: IntPtr)>(GetCompressedTextureSubImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureSubImage(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; bufSize: Int32; pixels: IntPtr) :=
      ntv_GetCompressedTextureSubImage_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
    
    // added in gl4.3
    private GetDebugMessageLog_adr := GetProcAddress('glGetDebugMessageLog');
    private ntv_GetDebugMessageLog_1 := GetProcOrNil&<function(count: UInt32; bufSize: Int32; var sources: glDebugSource; var types: glDebugType; var ids: UInt32; var severities: glDebugSeverity; var lengths: Int32; messageLog: IntPtr): UInt32>(GetDebugMessageLog_adr);
    private ntv_GetDebugMessageLog_2 := GetProcOrNil&<function(count: UInt32; bufSize: Int32; sources: IntPtr; types: IntPtr; ids: IntPtr; severities: IntPtr; lengths: IntPtr; messageLog: IntPtr): UInt32>(GetDebugMessageLog_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLog(count: UInt32; bufSize: Int32; var sources: glDebugSource; var types: glDebugType; var ids: UInt32; var severities: glDebugSeverity; var lengths: Int32; messageLog: IntPtr): UInt32 :=
      ntv_GetDebugMessageLog_1(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLog(count: UInt32; bufSize: Int32; sources: IntPtr; types: IntPtr; ids: IntPtr; severities: IntPtr; lengths: IntPtr; messageLog: IntPtr): UInt32 :=
      ntv_GetDebugMessageLog_2(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    
    // added in gl4.1
    private GetDoublei_v_adr := GetProcAddress('glGetDoublei_v');
    private ntv_GetDoublei_v_1 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; var data: double)>(GetDoublei_v_adr);
    private ntv_GetDoublei_v_2 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; data: IntPtr)>(GetDoublei_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_v(target: glGetPName; index: UInt32; var data: double) :=
      ntv_GetDoublei_v_1(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_v(target: glGetPName; index: UInt32; data: IntPtr) :=
      ntv_GetDoublei_v_2(target, index, data);
    
    // added in gl1.0
    private GetDoublev_adr := GetProcAddress('glGetDoublev');
    private ntv_GetDoublev_1 := GetProcOrNil&<procedure(pname: glGetPName; var data: double)>(GetDoublev_adr);
    private ntv_GetDoublev_2 := GetProcOrNil&<procedure(pname: glGetPName; data: IntPtr)>(GetDoublev_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublev(pname: glGetPName; var data: double) :=
      ntv_GetDoublev_1(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublev(pname: glGetPName; data: IntPtr) :=
      ntv_GetDoublev_2(pname, data);
    
    // added in gl1.0
    private GetError_adr := GetProcAddress('glGetError');
    private ntv_GetError_1 := GetProcOrNil&<function: glErrorCode>(GetError_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetError: glErrorCode :=
      ntv_GetError_1;
    
    // added in gl4.1
    private GetFloati_v_adr := GetProcAddress('glGetFloati_v');
    private ntv_GetFloati_v_1 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; var data: single)>(GetFloati_v_adr);
    private ntv_GetFloati_v_2 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; data: IntPtr)>(GetFloati_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_v(target: glGetPName; index: UInt32; var data: single) :=
      ntv_GetFloati_v_1(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_v(target: glGetPName; index: UInt32; data: IntPtr) :=
      ntv_GetFloati_v_2(target, index, data);
    
    // added in gl1.0
    private GetFloatv_adr := GetProcAddress('glGetFloatv');
    private ntv_GetFloatv_1 := GetProcOrNil&<procedure(pname: glGetPName; var data: single)>(GetFloatv_adr);
    private ntv_GetFloatv_2 := GetProcOrNil&<procedure(pname: glGetPName; data: IntPtr)>(GetFloatv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloatv(pname: glGetPName; var data: single) :=
      ntv_GetFloatv_1(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloatv(pname: glGetPName; data: IntPtr) :=
      ntv_GetFloatv_2(pname, data);
    
    // added in gl3.3
    private GetFragDataIndex_adr := GetProcAddress('glGetFragDataIndex');
    private ntv_GetFragDataIndex_1 := GetProcOrNil&<function(&program: gl_program; name: IntPtr): Int32>(GetFragDataIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataIndex(&program: gl_program; name: string): Int32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetFragDataIndex_1(&program, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataIndex(&program: gl_program; name: IntPtr): Int32 :=
      ntv_GetFragDataIndex_1(&program, name);
    
    // added in gl3.0
    private GetFragDataLocation_adr := GetProcAddress('glGetFragDataLocation');
    private ntv_GetFragDataLocation_1 := GetProcOrNil&<function(&program: gl_program; name: IntPtr): Int32>(GetFragDataLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataLocation(&program: gl_program; name: string): Int32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetFragDataLocation_1(&program, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataLocation(&program: gl_program; name: IntPtr): Int32 :=
      ntv_GetFragDataLocation_1(&program, name);
    
    // added in gl3.0
    private GetFramebufferAttachmentParameteriv_adr := GetProcAddress('glGetFramebufferAttachmentParameteriv');
    private ntv_GetFramebufferAttachmentParameteriv_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; var &params: Int32)>(GetFramebufferAttachmentParameteriv_adr);
    private ntv_GetFramebufferAttachmentParameteriv_2 := GetProcOrNil&<procedure(target: glFramebufferTarget; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; &params: IntPtr)>(GetFramebufferAttachmentParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameteriv(target: glFramebufferTarget; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; var &params: Int32) :=
      ntv_GetFramebufferAttachmentParameteriv_1(target, attachment, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameteriv(target: glFramebufferTarget; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; &params: IntPtr) :=
      ntv_GetFramebufferAttachmentParameteriv_2(target, attachment, pname, &params);
    
    // added in gl4.3
    private GetFramebufferParameteriv_adr := GetProcAddress('glGetFramebufferParameteriv');
    private ntv_GetFramebufferParameteriv_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; pname: glFramebufferAttachmentParameterName; var &params: Int32)>(GetFramebufferParameteriv_adr);
    private ntv_GetFramebufferParameteriv_2 := GetProcOrNil&<procedure(target: glFramebufferTarget; pname: glFramebufferAttachmentParameterName; &params: IntPtr)>(GetFramebufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameteriv(target: glFramebufferTarget; pname: glFramebufferAttachmentParameterName; var &params: Int32) :=
      ntv_GetFramebufferParameteriv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameteriv(target: glFramebufferTarget; pname: glFramebufferAttachmentParameterName; &params: IntPtr) :=
      ntv_GetFramebufferParameteriv_2(target, pname, &params);
    
    // added in gl4.5
    private GetGraphicsResetStatus_adr := GetProcAddress('glGetGraphicsResetStatus');
    private ntv_GetGraphicsResetStatus_1 := GetProcOrNil&<function: glGraphicsResetStatus>(GetGraphicsResetStatus_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGraphicsResetStatus: glGraphicsResetStatus :=
      ntv_GetGraphicsResetStatus_1;
    
    // added in gl3.2
    private GetInteger64i_v_adr := GetProcAddress('glGetInteger64i_v');
    private ntv_GetInteger64i_v_1 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; var data: Int64)>(GetInteger64i_v_adr);
    private ntv_GetInteger64i_v_2 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; data: IntPtr)>(GetInteger64i_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64i_v(target: glGetPName; index: UInt32; var data: Int64) :=
      ntv_GetInteger64i_v_1(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64i_v(target: glGetPName; index: UInt32; data: IntPtr) :=
      ntv_GetInteger64i_v_2(target, index, data);
    
    // added in gl3.2
    private GetInteger64v_adr := GetProcAddress('glGetInteger64v');
    private ntv_GetInteger64v_1 := GetProcOrNil&<procedure(pname: glGetPName; var data: Int64)>(GetInteger64v_adr);
    private ntv_GetInteger64v_2 := GetProcOrNil&<procedure(pname: glGetPName; data: IntPtr)>(GetInteger64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64v(pname: glGetPName; var data: Int64) :=
      ntv_GetInteger64v_1(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64v(pname: glGetPName; data: IntPtr) :=
      ntv_GetInteger64v_2(pname, data);
    
    // added in gl3.0
    private GetIntegeri_v_adr := GetProcAddress('glGetIntegeri_v');
    private ntv_GetIntegeri_v_1 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; var data: Int32)>(GetIntegeri_v_adr);
    private ntv_GetIntegeri_v_2 := GetProcOrNil&<procedure(target: glGetPName; index: UInt32; data: IntPtr)>(GetIntegeri_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegeri_v(target: glGetPName; index: UInt32; var data: Int32) :=
      ntv_GetIntegeri_v_1(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegeri_v(target: glGetPName; index: UInt32; data: IntPtr) :=
      ntv_GetIntegeri_v_2(target, index, data);
    
    // added in gl1.0
    private GetIntegerv_adr := GetProcAddress('glGetIntegerv');
    private ntv_GetIntegerv_1 := GetProcOrNil&<procedure(pname: glGetPName; var data: glContextFlagMask)>(GetIntegerv_adr);
    private ntv_GetIntegerv_2 := GetProcOrNil&<procedure(pname: glGetPName; var data: glContextProfileMask)>(GetIntegerv_adr);
    private ntv_GetIntegerv_3 := GetProcOrNil&<procedure(pname: glGetPName; var data: glSubgroupSupportedFeatures)>(GetIntegerv_adr);
    private ntv_GetIntegerv_4 := GetProcOrNil&<procedure(pname: glGetPName; var data: Int32)>(GetIntegerv_adr);
    private ntv_GetIntegerv_5 := GetProcOrNil&<procedure(pname: glGetPName; data: IntPtr)>(GetIntegerv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerv(pname: glGetPName; var data: glContextFlagMask) :=
      ntv_GetIntegerv_1(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerv(pname: glGetPName; var data: glContextProfileMask) :=
      ntv_GetIntegerv_2(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerv(pname: glGetPName; var data: glSubgroupSupportedFeatures) :=
      ntv_GetIntegerv_3(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerv(pname: glGetPName; var data: Int32) :=
      ntv_GetIntegerv_4(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerv(pname: glGetPName; data: IntPtr) :=
      ntv_GetIntegerv_5(pname, data);
    
    // added in gl4.3
    private GetInternalformati64v_adr := GetProcAddress('glGetInternalformati64v');
    private ntv_GetInternalformati64v_1 := GetProcOrNil&<procedure(target: glTextureTarget; internalformat: glInternalFormat; pname: glInternalFormatPName; count: Int32; var &params: Int64)>(GetInternalformati64v_adr);
    private ntv_GetInternalformati64v_2 := GetProcOrNil&<procedure(target: glTextureTarget; internalformat: glInternalFormat; pname: glInternalFormatPName; count: Int32; &params: IntPtr)>(GetInternalformati64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformati64v(target: glTextureTarget; internalformat: glInternalFormat; pname: glInternalFormatPName; count: Int32; var &params: Int64) :=
      ntv_GetInternalformati64v_1(target, internalformat, pname, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformati64v(target: glTextureTarget; internalformat: glInternalFormat; pname: glInternalFormatPName; count: Int32; &params: IntPtr) :=
      ntv_GetInternalformati64v_2(target, internalformat, pname, count, &params);
    
    // added in gl4.2
    private GetInternalformativ_adr := GetProcAddress('glGetInternalformativ');
    private ntv_GetInternalformativ_1 := GetProcOrNil&<procedure(target: glTextureTarget; internalformat: glInternalFormat; pname: glInternalFormatPName; count: Int32; var &params: Int32)>(GetInternalformativ_adr);
    private ntv_GetInternalformativ_2 := GetProcOrNil&<procedure(target: glTextureTarget; internalformat: glInternalFormat; pname: glInternalFormatPName; count: Int32; &params: IntPtr)>(GetInternalformativ_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformativ(target: glTextureTarget; internalformat: glInternalFormat; pname: glInternalFormatPName; count: Int32; var &params: Int32) :=
      ntv_GetInternalformativ_1(target, internalformat, pname, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformativ(target: glTextureTarget; internalformat: glInternalFormat; pname: glInternalFormatPName; count: Int32; &params: IntPtr) :=
      ntv_GetInternalformativ_2(target, internalformat, pname, count, &params);
    
    // added in gl3.2
    private GetMultisamplefv_adr := GetProcAddress('glGetMultisamplefv');
    private ntv_GetMultisamplefv_1 := GetProcOrNil&<procedure(pname: glGetMultisamplePName; index: UInt32; var val: single)>(GetMultisamplefv_adr);
    private ntv_GetMultisamplefv_2 := GetProcOrNil&<procedure(pname: glGetMultisamplePName; index: UInt32; val: IntPtr)>(GetMultisamplefv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefv(pname: glGetMultisamplePName; index: UInt32; var val: single) :=
      ntv_GetMultisamplefv_1(pname, index, val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefv(pname: glGetMultisamplePName; index: UInt32; val: IntPtr) :=
      ntv_GetMultisamplefv_2(pname, index, val);
    
    // added in gl4.5
    private GetNamedBufferParameteri64v_adr := GetProcAddress('glGetNamedBufferParameteri64v');
    private ntv_GetNamedBufferParameteri64v_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPName; var &params: Int64)>(GetNamedBufferParameteri64v_adr);
    private ntv_GetNamedBufferParameteri64v_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPName; &params: IntPtr)>(GetNamedBufferParameteri64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteri64v(buffer: gl_buffer; pname: glBufferPName; var &params: Int64) :=
      ntv_GetNamedBufferParameteri64v_1(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteri64v(buffer: gl_buffer; pname: glBufferPName; &params: IntPtr) :=
      ntv_GetNamedBufferParameteri64v_2(buffer, pname, &params);
    
    // added in gl4.5
    private GetNamedBufferParameteriv_adr := GetProcAddress('glGetNamedBufferParameteriv');
    private ntv_GetNamedBufferParameteriv_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPName; var &params: Int32)>(GetNamedBufferParameteriv_adr);
    private ntv_GetNamedBufferParameteriv_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPName; &params: IntPtr)>(GetNamedBufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteriv(buffer: gl_buffer; pname: glBufferPName; var &params: Int32) :=
      ntv_GetNamedBufferParameteriv_1(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteriv(buffer: gl_buffer; pname: glBufferPName; &params: IntPtr) :=
      ntv_GetNamedBufferParameteriv_2(buffer, pname, &params);
    
    // added in gl4.5
    private GetNamedBufferPointerv_adr := GetProcAddress('glGetNamedBufferPointerv');
    private ntv_GetNamedBufferPointerv_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPointerName; var &params: IntPtr)>(GetNamedBufferPointerv_adr);
    private ntv_GetNamedBufferPointerv_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: glBufferPointerName; &params: pointer)>(GetNamedBufferPointerv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointerv(buffer: gl_buffer; pname: glBufferPointerName; var &params: IntPtr) :=
      ntv_GetNamedBufferPointerv_1(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointerv(buffer: gl_buffer; pname: glBufferPointerName; &params: pointer) :=
      ntv_GetNamedBufferPointerv_2(buffer, pname, &params);
    
    // added in gl4.5
    private GetNamedBufferSubData_adr := GetProcAddress('glGetNamedBufferSubData');
    private ntv_GetNamedBufferSubData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: Byte)>(GetNamedBufferSubData_adr);
    private ntv_GetNamedBufferSubData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer)>(GetNamedBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubData<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        GetNamedBufferSubData(buffer, offset, size, data[0]) else
        GetNamedBufferSubData(buffer, offset, size, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubData<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      ntv_GetNamedBufferSubData_1(buffer, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubData(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer) :=
      ntv_GetNamedBufferSubData_2(buffer, offset, size, data);
    
    // added in gl4.5
    private GetNamedFramebufferAttachmentParameteriv_adr := GetProcAddress('glGetNamedFramebufferAttachmentParameteriv');
    private ntv_GetNamedFramebufferAttachmentParameteriv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; var &params: Int32)>(GetNamedFramebufferAttachmentParameteriv_adr);
    private ntv_GetNamedFramebufferAttachmentParameteriv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; &params: IntPtr)>(GetNamedFramebufferAttachmentParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; var &params: Int32) :=
      ntv_GetNamedFramebufferAttachmentParameteriv_1(framebuffer, attachment, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; pname: glFramebufferAttachmentParameterName; &params: IntPtr) :=
      ntv_GetNamedFramebufferAttachmentParameteriv_2(framebuffer, attachment, pname, &params);
    
    // added in gl4.5
    private GetNamedFramebufferParameteriv_adr := GetProcAddress('glGetNamedFramebufferParameteriv');
    private ntv_GetNamedFramebufferParameteriv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: glGetFramebufferParameter; var param: Int32)>(GetNamedFramebufferParameteriv_adr);
    private ntv_GetNamedFramebufferParameteriv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: glGetFramebufferParameter; param: IntPtr)>(GetNamedFramebufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameteriv(framebuffer: gl_framebuffer; pname: glGetFramebufferParameter; var param: Int32) :=
      ntv_GetNamedFramebufferParameteriv_1(framebuffer, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameteriv(framebuffer: gl_framebuffer; pname: glGetFramebufferParameter; param: IntPtr) :=
      ntv_GetNamedFramebufferParameteriv_2(framebuffer, pname, param);
    
    // added in gl4.5
    private GetNamedRenderbufferParameteriv_adr := GetProcAddress('glGetNamedRenderbufferParameteriv');
    private ntv_GetNamedRenderbufferParameteriv_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; pname: glRenderbufferParameterName; var &params: Int32)>(GetNamedRenderbufferParameteriv_adr);
    private ntv_GetNamedRenderbufferParameteriv_2 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; pname: glRenderbufferParameterName; &params: IntPtr)>(GetNamedRenderbufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameteriv(renderbuffer: gl_renderbuffer; pname: glRenderbufferParameterName; var &params: Int32) :=
      ntv_GetNamedRenderbufferParameteriv_1(renderbuffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameteriv(renderbuffer: gl_renderbuffer; pname: glRenderbufferParameterName; &params: IntPtr) :=
      ntv_GetNamedRenderbufferParameteriv_2(renderbuffer, pname, &params);
    
    // added in gl4.5
    private GetnColorTable_adr := GetProcAddress('glGetnColorTable');
    private ntv_GetnColorTable_1 := GetProcOrNil&<procedure(target: glColorTableTarget; format: glPixelFormat; &type: glPixelType; bufSize: Int32; table: IntPtr)>(GetnColorTable_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnColorTable(target: glColorTableTarget; format: glPixelFormat; &type: glPixelType; bufSize: Int32; table: IntPtr) :=
      ntv_GetnColorTable_1(target, format, &type, bufSize, table);
    
    // added in gl4.5
    private GetnCompressedTexImage_adr := GetProcAddress('glGetnCompressedTexImage');
    private ntv_GetnCompressedTexImage_1 := GetProcOrNil&<procedure(target: glTextureTarget; lod: Int32; bufSize: Int32; pixels: IntPtr)>(GetnCompressedTexImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnCompressedTexImage(target: glTextureTarget; lod: Int32; bufSize: Int32; pixels: IntPtr) :=
      ntv_GetnCompressedTexImage_1(target, lod, bufSize, pixels);
    
    // added in gl4.5
    private GetnConvolutionFilter_adr := GetProcAddress('glGetnConvolutionFilter');
    private ntv_GetnConvolutionFilter_1 := GetProcOrNil&<procedure(target: glConvolutionTarget; format: glPixelFormat; &type: glPixelType; bufSize: Int32; image: IntPtr)>(GetnConvolutionFilter_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnConvolutionFilter(target: glConvolutionTarget; format: glPixelFormat; &type: glPixelType; bufSize: Int32; image: IntPtr) :=
      ntv_GetnConvolutionFilter_1(target, format, &type, bufSize, image);
    
    // added in gl4.5
    private GetnHistogram_adr := GetProcAddress('glGetnHistogram');
    private ntv_GetnHistogram_1 := GetProcOrNil&<procedure(target: glHistogramTarget; reset: glBool8; format: glPixelFormat; &type: glPixelType; bufSize: Int32; values: IntPtr)>(GetnHistogram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnHistogram(target: glHistogramTarget; reset: glBool8; format: glPixelFormat; &type: glPixelType; bufSize: Int32; values: IntPtr) :=
      ntv_GetnHistogram_1(target, reset, format, &type, bufSize, values);
    
    // added in gl4.5
    private GetnMapdv_adr := GetProcAddress('glGetnMapdv');
    private ntv_GetnMapdv_1 := GetProcOrNil&<procedure(target: glMapTarget; query: glMapQuery; bufSize: Int32; var v: double)>(GetnMapdv_adr);
    private ntv_GetnMapdv_2 := GetProcOrNil&<procedure(target: glMapTarget; query: glMapQuery; bufSize: Int32; v: IntPtr)>(GetnMapdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapdv(target: glMapTarget; query: glMapQuery; bufSize: Int32; var v: double) :=
      ntv_GetnMapdv_1(target, query, bufSize, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapdv(target: glMapTarget; query: glMapQuery; bufSize: Int32; v: IntPtr) :=
      ntv_GetnMapdv_2(target, query, bufSize, v);
    
    // added in gl4.5
    private GetnMapfv_adr := GetProcAddress('glGetnMapfv');
    private ntv_GetnMapfv_1 := GetProcOrNil&<procedure(target: glMapTarget; query: glMapQuery; bufSize: Int32; var v: single)>(GetnMapfv_adr);
    private ntv_GetnMapfv_2 := GetProcOrNil&<procedure(target: glMapTarget; query: glMapQuery; bufSize: Int32; v: IntPtr)>(GetnMapfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapfv(target: glMapTarget; query: glMapQuery; bufSize: Int32; var v: single) :=
      ntv_GetnMapfv_1(target, query, bufSize, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapfv(target: glMapTarget; query: glMapQuery; bufSize: Int32; v: IntPtr) :=
      ntv_GetnMapfv_2(target, query, bufSize, v);
    
    // added in gl4.5
    private GetnMapiv_adr := GetProcAddress('glGetnMapiv');
    private ntv_GetnMapiv_1 := GetProcOrNil&<procedure(target: glMapTarget; query: glMapQuery; bufSize: Int32; var v: Int32)>(GetnMapiv_adr);
    private ntv_GetnMapiv_2 := GetProcOrNil&<procedure(target: glMapTarget; query: glMapQuery; bufSize: Int32; v: IntPtr)>(GetnMapiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapiv(target: glMapTarget; query: glMapQuery; bufSize: Int32; var v: Int32) :=
      ntv_GetnMapiv_1(target, query, bufSize, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapiv(target: glMapTarget; query: glMapQuery; bufSize: Int32; v: IntPtr) :=
      ntv_GetnMapiv_2(target, query, bufSize, v);
    
    // added in gl4.5
    private GetnMinmax_adr := GetProcAddress('glGetnMinmax');
    private ntv_GetnMinmax_1 := GetProcOrNil&<procedure(target: glMinmaxTarget; reset: glBool8; format: glPixelFormat; &type: glPixelType; bufSize: Int32; values: IntPtr)>(GetnMinmax_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMinmax(target: glMinmaxTarget; reset: glBool8; format: glPixelFormat; &type: glPixelType; bufSize: Int32; values: IntPtr) :=
      ntv_GetnMinmax_1(target, reset, format, &type, bufSize, values);
    
    // added in gl4.5
    private GetnPixelMapfv_adr := GetProcAddress('glGetnPixelMapfv');
    private ntv_GetnPixelMapfv_1 := GetProcOrNil&<procedure(map: glPixelMap; bufSize: Int32; var values: single)>(GetnPixelMapfv_adr);
    private ntv_GetnPixelMapfv_2 := GetProcOrNil&<procedure(map: glPixelMap; bufSize: Int32; values: IntPtr)>(GetnPixelMapfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapfv(map: glPixelMap; bufSize: Int32; var values: single) :=
      ntv_GetnPixelMapfv_1(map, bufSize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapfv(map: glPixelMap; bufSize: Int32; values: IntPtr) :=
      ntv_GetnPixelMapfv_2(map, bufSize, values);
    
    // added in gl4.5
    private GetnPixelMapuiv_adr := GetProcAddress('glGetnPixelMapuiv');
    private ntv_GetnPixelMapuiv_1 := GetProcOrNil&<procedure(map: glPixelMap; bufSize: Int32; var values: UInt32)>(GetnPixelMapuiv_adr);
    private ntv_GetnPixelMapuiv_2 := GetProcOrNil&<procedure(map: glPixelMap; bufSize: Int32; values: IntPtr)>(GetnPixelMapuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapuiv(map: glPixelMap; bufSize: Int32; var values: UInt32) :=
      ntv_GetnPixelMapuiv_1(map, bufSize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapuiv(map: glPixelMap; bufSize: Int32; values: IntPtr) :=
      ntv_GetnPixelMapuiv_2(map, bufSize, values);
    
    // added in gl4.5
    private GetnPixelMapusv_adr := GetProcAddress('glGetnPixelMapusv');
    private ntv_GetnPixelMapusv_1 := GetProcOrNil&<procedure(map: glPixelMap; bufSize: Int32; var values: UInt16)>(GetnPixelMapusv_adr);
    private ntv_GetnPixelMapusv_2 := GetProcOrNil&<procedure(map: glPixelMap; bufSize: Int32; values: IntPtr)>(GetnPixelMapusv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapusv(map: glPixelMap; bufSize: Int32; var values: UInt16) :=
      ntv_GetnPixelMapusv_1(map, bufSize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapusv(map: glPixelMap; bufSize: Int32; values: IntPtr) :=
      ntv_GetnPixelMapusv_2(map, bufSize, values);
    
    // added in gl4.5
    private GetnPolygonStipple_adr := GetProcAddress('glGetnPolygonStipple');
    private ntv_GetnPolygonStipple_1 := GetProcOrNil&<procedure(bufSize: Int32; var pattern: Byte)>(GetnPolygonStipple_adr);
    private ntv_GetnPolygonStipple_2 := GetProcOrNil&<procedure(bufSize: Int32; pattern: IntPtr)>(GetnPolygonStipple_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPolygonStipple(bufSize: Int32; var pattern: Byte) :=
      ntv_GetnPolygonStipple_1(bufSize, pattern);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPolygonStipple(bufSize: Int32; pattern: IntPtr) :=
      ntv_GetnPolygonStipple_2(bufSize, pattern);
    
    // added in gl4.5
    private GetnSeparableFilter_adr := GetProcAddress('glGetnSeparableFilter');
    private ntv_GetnSeparableFilter_1 := GetProcOrNil&<procedure(target: glSeparableTarget; format: glPixelFormat; &type: glPixelType; rowBufSize: Int32; row: IntPtr; columnBufSize: Int32; column: IntPtr; span: IntPtr)>(GetnSeparableFilter_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnSeparableFilter(target: glSeparableTarget; format: glPixelFormat; &type: glPixelType; rowBufSize: Int32; row: IntPtr; columnBufSize: Int32; column: IntPtr; span: IntPtr) :=
      ntv_GetnSeparableFilter_1(target, format, &type, rowBufSize, row, columnBufSize, column, span);
    
    // added in gl4.5
    private GetnTexImage_adr := GetProcAddress('glGetnTexImage');
    private ntv_GetnTexImage_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; pixels: IntPtr)>(GetnTexImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnTexImage(target: glTextureTarget; level: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; pixels: IntPtr) :=
      ntv_GetnTexImage_1(target, level, format, &type, bufSize, pixels);
    
    // added in gl4.5
    private GetnUniformdv_adr := GetProcAddress('glGetnUniformdv');
    private ntv_GetnUniformdv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: double)>(GetnUniformdv_adr);
    private ntv_GetnUniformdv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(GetnUniformdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformdv(&program: gl_program; location: Int32; bufSize: Int32; var &params: double) :=
      ntv_GetnUniformdv_1(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformdv(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
      ntv_GetnUniformdv_2(&program, location, bufSize, &params);
    
    // added in gl4.5
    private GetnUniformfv_adr := GetProcAddress('glGetnUniformfv');
    private ntv_GetnUniformfv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: single)>(GetnUniformfv_adr);
    private ntv_GetnUniformfv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(GetnUniformfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfv(&program: gl_program; location: Int32; bufSize: Int32; var &params: single) :=
      ntv_GetnUniformfv_1(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfv(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
      ntv_GetnUniformfv_2(&program, location, bufSize, &params);
    
    // added in gl4.5
    private GetnUniformiv_adr := GetProcAddress('glGetnUniformiv');
    private ntv_GetnUniformiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: Int32)>(GetnUniformiv_adr);
    private ntv_GetnUniformiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(GetnUniformiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformiv(&program: gl_program; location: Int32; bufSize: Int32; var &params: Int32) :=
      ntv_GetnUniformiv_1(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformiv(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
      ntv_GetnUniformiv_2(&program, location, bufSize, &params);
    
    // added in gl4.5
    private GetnUniformuiv_adr := GetProcAddress('glGetnUniformuiv');
    private ntv_GetnUniformuiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: UInt32)>(GetnUniformuiv_adr);
    private ntv_GetnUniformuiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(GetnUniformuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuiv(&program: gl_program; location: Int32; bufSize: Int32; var &params: UInt32) :=
      ntv_GetnUniformuiv_1(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuiv(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
      ntv_GetnUniformuiv_2(&program, location, bufSize, &params);
    
    // added in gl4.3
    private GetObjectLabel_adr := GetProcAddress('glGetObjectLabel');
    private ntv_GetObjectLabel_1 := GetProcOrNil&<procedure(identifier: glObjectIdentifier; name: UInt32; bufSize: Int32; var length: Int32; &label: IntPtr)>(GetObjectLabel_adr);
    private ntv_GetObjectLabel_2 := GetProcOrNil&<procedure(identifier: glObjectIdentifier; name: UInt32; bufSize: Int32; length: IntPtr; &label: IntPtr)>(GetObjectLabel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabel(identifier: glObjectIdentifier; name: UInt32; bufSize: Int32; var length: Int32; &label: IntPtr) :=
      ntv_GetObjectLabel_1(identifier, name, bufSize, length, &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabel(identifier: glObjectIdentifier; name: UInt32; bufSize: Int32; length: IntPtr; &label: IntPtr) :=
      ntv_GetObjectLabel_2(identifier, name, bufSize, length, &label);
    
    // added in gl4.3
    private GetObjectPtrLabel_adr := GetProcAddress('glGetObjectPtrLabel');
    private ntv_GetObjectPtrLabel_1 := GetProcOrNil&<procedure(ptr: IntPtr; bufSize: Int32; var length: Int32; &label: IntPtr)>(GetObjectPtrLabel_adr);
    private ntv_GetObjectPtrLabel_2 := GetProcOrNil&<procedure(ptr: IntPtr; bufSize: Int32; length: IntPtr; &label: IntPtr)>(GetObjectPtrLabel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabel(ptr: IntPtr; bufSize: Int32; var length: Int32; &label: IntPtr) :=
      ntv_GetObjectPtrLabel_1(ptr, bufSize, length, &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabel(ptr: IntPtr; bufSize: Int32; length: IntPtr; &label: IntPtr) :=
      ntv_GetObjectPtrLabel_2(ptr, bufSize, length, &label);
    
    // added in gl4.3
    private GetPointerv_adr := GetProcAddress('glGetPointerv');
    private ntv_GetPointerv_1 := GetProcOrNil&<procedure(pname: glGetPointervPName; var &params: IntPtr)>(GetPointerv_adr);
    private ntv_GetPointerv_2 := GetProcOrNil&<procedure(pname: glGetPointervPName; &params: pointer)>(GetPointerv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerv(pname: glGetPointervPName; var &params: IntPtr) :=
      ntv_GetPointerv_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerv(pname: glGetPointervPName; &params: pointer) :=
      ntv_GetPointerv_2(pname, &params);
    
    // added in gl4.1
    private GetProgramBinary_adr := GetProcAddress('glGetProgramBinary');
    private ntv_GetProgramBinary_1 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; var length: Int32; var binaryFormat: DummyEnum; binary: IntPtr)>(GetProgramBinary_adr);
    private ntv_GetProgramBinary_2 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; var length: Int32; binaryFormat: IntPtr; binary: IntPtr)>(GetProgramBinary_adr);
    private ntv_GetProgramBinary_3 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; length: IntPtr; var binaryFormat: DummyEnum; binary: IntPtr)>(GetProgramBinary_adr);
    private ntv_GetProgramBinary_4 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; length: IntPtr; binaryFormat: IntPtr; binary: IntPtr)>(GetProgramBinary_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: gl_program; bufSize: Int32; var length: Int32; var binaryFormat: DummyEnum; binary: IntPtr) :=
      ntv_GetProgramBinary_1(&program, bufSize, length, binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: gl_program; bufSize: Int32; var length: Int32; binaryFormat: IntPtr; binary: IntPtr) :=
      ntv_GetProgramBinary_2(&program, bufSize, length, binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: gl_program; bufSize: Int32; length: IntPtr; var binaryFormat: DummyEnum; binary: IntPtr) :=
      ntv_GetProgramBinary_3(&program, bufSize, length, binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: gl_program; bufSize: Int32; length: IntPtr; binaryFormat: IntPtr; binary: IntPtr) :=
      ntv_GetProgramBinary_4(&program, bufSize, length, binaryFormat, binary);
    
    // added in gl2.0
    private GetProgramInfoLog_adr := GetProcAddress('glGetProgramInfoLog');
    private ntv_GetProgramInfoLog_1 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; var length: Int32; infoLog: IntPtr)>(GetProgramInfoLog_adr);
    private ntv_GetProgramInfoLog_2 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; length: IntPtr; infoLog: IntPtr)>(GetProgramInfoLog_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInfoLog(&program: gl_program; bufSize: Int32; var length: Int32; infoLog: IntPtr) :=
      ntv_GetProgramInfoLog_1(&program, bufSize, length, infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInfoLog(&program: gl_program; bufSize: Int32; length: IntPtr; infoLog: IntPtr) :=
      ntv_GetProgramInfoLog_2(&program, bufSize, length, infoLog);
    
    // added in gl4.3
    private GetProgramInterfaceiv_adr := GetProcAddress('glGetProgramInterfaceiv');
    private ntv_GetProgramInterfaceiv_1 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; pname: glProgramInterfacePName; var &params: Int32)>(GetProgramInterfaceiv_adr);
    private ntv_GetProgramInterfaceiv_2 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; pname: glProgramInterfacePName; &params: IntPtr)>(GetProgramInterfaceiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInterfaceiv(&program: gl_program; programInterface: glProgramInterface; pname: glProgramInterfacePName; var &params: Int32) :=
      ntv_GetProgramInterfaceiv_1(&program, programInterface, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInterfaceiv(&program: gl_program; programInterface: glProgramInterface; pname: glProgramInterfacePName; &params: IntPtr) :=
      ntv_GetProgramInterfaceiv_2(&program, programInterface, pname, &params);
    
    // added in gl2.0
    private GetProgramiv_adr := GetProcAddress('glGetProgramiv');
    private ntv_GetProgramiv_1 := GetProcOrNil&<procedure(&program: gl_program; pname: glProgramProperty; var &params: Int32)>(GetProgramiv_adr);
    private ntv_GetProgramiv_2 := GetProcOrNil&<procedure(&program: gl_program; pname: glProgramProperty; &params: IntPtr)>(GetProgramiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramiv(&program: gl_program; pname: glProgramProperty; var &params: Int32) :=
      ntv_GetProgramiv_1(&program, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramiv(&program: gl_program; pname: glProgramProperty; &params: IntPtr) :=
      ntv_GetProgramiv_2(&program, pname, &params);
    
    // added in gl4.1
    private GetProgramPipelineInfoLog_adr := GetProcAddress('glGetProgramPipelineInfoLog');
    private ntv_GetProgramPipelineInfoLog_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; bufSize: Int32; var length: Int32; infoLog: IntPtr)>(GetProgramPipelineInfoLog_adr);
    private ntv_GetProgramPipelineInfoLog_2 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; bufSize: Int32; length: IntPtr; infoLog: IntPtr)>(GetProgramPipelineInfoLog_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLog(pipeline: gl_program_pipeline; bufSize: Int32; var length: Int32; infoLog: IntPtr) :=
      ntv_GetProgramPipelineInfoLog_1(pipeline, bufSize, length, infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLog(pipeline: gl_program_pipeline; bufSize: Int32; length: IntPtr; infoLog: IntPtr) :=
      ntv_GetProgramPipelineInfoLog_2(pipeline, bufSize, length, infoLog);
    
    // added in gl4.1
    private GetProgramPipelineiv_adr := GetProcAddress('glGetProgramPipelineiv');
    private ntv_GetProgramPipelineiv_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; pname: glPipelineParameterName; var &params: Int32)>(GetProgramPipelineiv_adr);
    private ntv_GetProgramPipelineiv_2 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; pname: glPipelineParameterName; &params: IntPtr)>(GetProgramPipelineiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineiv(pipeline: gl_program_pipeline; pname: glPipelineParameterName; var &params: Int32) :=
      ntv_GetProgramPipelineiv_1(pipeline, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineiv(pipeline: gl_program_pipeline; pname: glPipelineParameterName; &params: IntPtr) :=
      ntv_GetProgramPipelineiv_2(pipeline, pname, &params);
    
    // added in gl4.3
    private GetProgramResourceIndex_adr := GetProcAddress('glGetProgramResourceIndex');
    private ntv_GetProgramResourceIndex_1 := GetProcOrNil&<function(&program: gl_program; programInterface: glProgramInterface; name: IntPtr): UInt32>(GetProgramResourceIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceIndex(&program: gl_program; programInterface: glProgramInterface; name: string): UInt32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetProgramResourceIndex_1(&program, programInterface, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceIndex(&program: gl_program; programInterface: glProgramInterface; name: IntPtr): UInt32 :=
      ntv_GetProgramResourceIndex_1(&program, programInterface, name);
    
    // added in gl4.3
    private GetProgramResourceiv_adr := GetProcAddress('glGetProgramResourceiv');
    private ntv_GetProgramResourceiv_1 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: glProgramResourceProperty; count: Int32; var length: Int32; var &params: Int32)>(GetProgramResourceiv_adr);
    private ntv_GetProgramResourceiv_2 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: glProgramResourceProperty; count: Int32; var length: Int32; &params: IntPtr)>(GetProgramResourceiv_adr);
    private ntv_GetProgramResourceiv_3 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: glProgramResourceProperty; count: Int32; length: IntPtr; var &params: Int32)>(GetProgramResourceiv_adr);
    private ntv_GetProgramResourceiv_4 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: glProgramResourceProperty; count: Int32; length: IntPtr; &params: IntPtr)>(GetProgramResourceiv_adr);
    private ntv_GetProgramResourceiv_5 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; var &params: Int32)>(GetProgramResourceiv_adr);
    private ntv_GetProgramResourceiv_6 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; &params: IntPtr)>(GetProgramResourceiv_adr);
    private ntv_GetProgramResourceiv_7 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; var &params: Int32)>(GetProgramResourceiv_adr);
    private ntv_GetProgramResourceiv_8 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; &params: IntPtr)>(GetProgramResourceiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: array of glProgramResourceProperty; count: Int32; var length: Int32; var &params: Int32);
    type PGlProgramResourceProperty = ^glProgramResourceProperty;
    begin
      if (props<>nil) and (props.Length<>0) then
        ntv_GetProgramResourceiv_1(&program, programInterface, index, propCount, props[0], count, length, &params) else
        ntv_GetProgramResourceiv_1(&program, programInterface, index, propCount, PGlProgramResourceProperty(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: array of glProgramResourceProperty; count: Int32; var length: Int32; &params: IntPtr);
    type PGlProgramResourceProperty = ^glProgramResourceProperty;
    begin
      if (props<>nil) and (props.Length<>0) then
        ntv_GetProgramResourceiv_2(&program, programInterface, index, propCount, props[0], count, length, &params) else
        ntv_GetProgramResourceiv_2(&program, programInterface, index, propCount, PGlProgramResourceProperty(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: array of glProgramResourceProperty; count: Int32; length: IntPtr; var &params: Int32);
    type PGlProgramResourceProperty = ^glProgramResourceProperty;
    begin
      if (props<>nil) and (props.Length<>0) then
        ntv_GetProgramResourceiv_3(&program, programInterface, index, propCount, props[0], count, length, &params) else
        ntv_GetProgramResourceiv_3(&program, programInterface, index, propCount, PGlProgramResourceProperty(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: array of glProgramResourceProperty; count: Int32; length: IntPtr; &params: IntPtr);
    type PGlProgramResourceProperty = ^glProgramResourceProperty;
    begin
      if (props<>nil) and (props.Length<>0) then
        ntv_GetProgramResourceiv_4(&program, programInterface, index, propCount, props[0], count, length, &params) else
        ntv_GetProgramResourceiv_4(&program, programInterface, index, propCount, PGlProgramResourceProperty(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: glProgramResourceProperty; count: Int32; var length: Int32; var &params: Int32) :=
      ntv_GetProgramResourceiv_1(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: glProgramResourceProperty; count: Int32; var length: Int32; &params: IntPtr) :=
      ntv_GetProgramResourceiv_2(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: glProgramResourceProperty; count: Int32; length: IntPtr; var &params: Int32) :=
      ntv_GetProgramResourceiv_3(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; var props: glProgramResourceProperty; count: Int32; length: IntPtr; &params: IntPtr) :=
      ntv_GetProgramResourceiv_4(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; var &params: Int32) :=
      ntv_GetProgramResourceiv_5(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; &params: IntPtr) :=
      ntv_GetProgramResourceiv_6(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; var &params: Int32) :=
      ntv_GetProgramResourceiv_7(&program, programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; programInterface: glProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; &params: IntPtr) :=
      ntv_GetProgramResourceiv_8(&program, programInterface, index, propCount, props, count, length, &params);
    
    // added in gl4.3
    private GetProgramResourceLocation_adr := GetProcAddress('glGetProgramResourceLocation');
    private ntv_GetProgramResourceLocation_1 := GetProcOrNil&<function(&program: gl_program; programInterface: glProgramInterface; name: IntPtr): Int32>(GetProgramResourceLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocation(&program: gl_program; programInterface: glProgramInterface; name: string): Int32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetProgramResourceLocation_1(&program, programInterface, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocation(&program: gl_program; programInterface: glProgramInterface; name: IntPtr): Int32 :=
      ntv_GetProgramResourceLocation_1(&program, programInterface, name);
    
    // added in gl4.3
    private GetProgramResourceLocationIndex_adr := GetProcAddress('glGetProgramResourceLocationIndex');
    private ntv_GetProgramResourceLocationIndex_1 := GetProcOrNil&<function(&program: gl_program; programInterface: glProgramInterface; name: IntPtr): Int32>(GetProgramResourceLocationIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocationIndex(&program: gl_program; programInterface: glProgramInterface; name: string): Int32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetProgramResourceLocationIndex_1(&program, programInterface, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocationIndex(&program: gl_program; programInterface: glProgramInterface; name: IntPtr): Int32 :=
      ntv_GetProgramResourceLocationIndex_1(&program, programInterface, name);
    
    // added in gl4.3
    private GetProgramResourceName_adr := GetProcAddress('glGetProgramResourceName');
    private ntv_GetProgramResourceName_1 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr)>(GetProgramResourceName_adr);
    private ntv_GetProgramResourceName_2 := GetProcOrNil&<procedure(&program: gl_program; programInterface: glProgramInterface; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr)>(GetProgramResourceName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceName(&program: gl_program; programInterface: glProgramInterface; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr) :=
      ntv_GetProgramResourceName_1(&program, programInterface, index, bufSize, length, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceName(&program: gl_program; programInterface: glProgramInterface; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr) :=
      ntv_GetProgramResourceName_2(&program, programInterface, index, bufSize, length, name);
    
    // added in gl4.0
    private GetProgramStageiv_adr := GetProcAddress('glGetProgramStageiv');
    private ntv_GetProgramStageiv_1 := GetProcOrNil&<procedure(&program: gl_program; shadertype: glShaderType; pname: glProgramStagePName; var values: Int32)>(GetProgramStageiv_adr);
    private ntv_GetProgramStageiv_2 := GetProcOrNil&<procedure(&program: gl_program; shadertype: glShaderType; pname: glProgramStagePName; values: IntPtr)>(GetProgramStageiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStageiv(&program: gl_program; shadertype: glShaderType; pname: glProgramStagePName; var values: Int32) :=
      ntv_GetProgramStageiv_1(&program, shadertype, pname, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStageiv(&program: gl_program; shadertype: glShaderType; pname: glProgramStagePName; values: IntPtr) :=
      ntv_GetProgramStageiv_2(&program, shadertype, pname, values);
    
    // added in gl4.5
    private GetQueryBufferObjecti64v_adr := GetProcAddress('glGetQueryBufferObjecti64v');
    private ntv_GetQueryBufferObjecti64v_1 := GetProcOrNil&<procedure(id: gl_query; buffer: gl_buffer; pname: glQueryObjectParameterName; offset: IntPtr)>(GetQueryBufferObjecti64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjecti64v(id: gl_query; buffer: gl_buffer; pname: glQueryObjectParameterName; offset: IntPtr) :=
      ntv_GetQueryBufferObjecti64v_1(id, buffer, pname, offset);
    
    // added in gl4.5
    private GetQueryBufferObjectiv_adr := GetProcAddress('glGetQueryBufferObjectiv');
    private ntv_GetQueryBufferObjectiv_1 := GetProcOrNil&<procedure(id: gl_query; buffer: gl_buffer; pname: glQueryObjectParameterName; offset: IntPtr)>(GetQueryBufferObjectiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjectiv(id: gl_query; buffer: gl_buffer; pname: glQueryObjectParameterName; offset: IntPtr) :=
      ntv_GetQueryBufferObjectiv_1(id, buffer, pname, offset);
    
    // added in gl4.5
    private GetQueryBufferObjectui64v_adr := GetProcAddress('glGetQueryBufferObjectui64v');
    private ntv_GetQueryBufferObjectui64v_1 := GetProcOrNil&<procedure(id: gl_query; buffer: gl_buffer; pname: glQueryObjectParameterName; offset: IntPtr)>(GetQueryBufferObjectui64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjectui64v(id: gl_query; buffer: gl_buffer; pname: glQueryObjectParameterName; offset: IntPtr) :=
      ntv_GetQueryBufferObjectui64v_1(id, buffer, pname, offset);
    
    // added in gl4.5
    private GetQueryBufferObjectuiv_adr := GetProcAddress('glGetQueryBufferObjectuiv');
    private ntv_GetQueryBufferObjectuiv_1 := GetProcOrNil&<procedure(id: gl_query; buffer: gl_buffer; pname: glQueryObjectParameterName; offset: IntPtr)>(GetQueryBufferObjectuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjectuiv(id: gl_query; buffer: gl_buffer; pname: glQueryObjectParameterName; offset: IntPtr) :=
      ntv_GetQueryBufferObjectuiv_1(id, buffer, pname, offset);
    
    // added in gl4.0
    private GetQueryIndexediv_adr := GetProcAddress('glGetQueryIndexediv');
    private ntv_GetQueryIndexediv_1 := GetProcOrNil&<procedure(target: glQueryTarget; index: UInt32; pname: glQueryParameterName; var &params: Int32)>(GetQueryIndexediv_adr);
    private ntv_GetQueryIndexediv_2 := GetProcOrNil&<procedure(target: glQueryTarget; index: UInt32; pname: glQueryParameterName; &params: IntPtr)>(GetQueryIndexediv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryIndexediv(target: glQueryTarget; index: UInt32; pname: glQueryParameterName; var &params: Int32) :=
      ntv_GetQueryIndexediv_1(target, index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryIndexediv(target: glQueryTarget; index: UInt32; pname: glQueryParameterName; &params: IntPtr) :=
      ntv_GetQueryIndexediv_2(target, index, pname, &params);
    
    // added in gl1.5
    private GetQueryiv_adr := GetProcAddress('glGetQueryiv');
    private ntv_GetQueryiv_1 := GetProcOrNil&<procedure(target: glQueryTarget; pname: glQueryParameterName; var &params: Int32)>(GetQueryiv_adr);
    private ntv_GetQueryiv_2 := GetProcOrNil&<procedure(target: glQueryTarget; pname: glQueryParameterName; &params: IntPtr)>(GetQueryiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryiv(target: glQueryTarget; pname: glQueryParameterName; var &params: Int32) :=
      ntv_GetQueryiv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryiv(target: glQueryTarget; pname: glQueryParameterName; &params: IntPtr) :=
      ntv_GetQueryiv_2(target, pname, &params);
    
    // added in gl3.3
    private GetQueryObjecti64v_adr := GetProcAddress('glGetQueryObjecti64v');
    private ntv_GetQueryObjecti64v_1 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; var &params: Int64)>(GetQueryObjecti64v_adr);
    private ntv_GetQueryObjecti64v_2 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr)>(GetQueryObjecti64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjecti64v(id: gl_query; pname: glQueryObjectParameterName; var &params: Int64) :=
      ntv_GetQueryObjecti64v_1(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjecti64v(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr) :=
      ntv_GetQueryObjecti64v_2(id, pname, &params);
    
    // added in gl1.5
    private GetQueryObjectiv_adr := GetProcAddress('glGetQueryObjectiv');
    private ntv_GetQueryObjectiv_1 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; var &params: Int32)>(GetQueryObjectiv_adr);
    private ntv_GetQueryObjectiv_2 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr)>(GetQueryObjectiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectiv(id: gl_query; pname: glQueryObjectParameterName; var &params: Int32) :=
      ntv_GetQueryObjectiv_1(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectiv(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr) :=
      ntv_GetQueryObjectiv_2(id, pname, &params);
    
    // added in gl3.3
    private GetQueryObjectui64v_adr := GetProcAddress('glGetQueryObjectui64v');
    private ntv_GetQueryObjectui64v_1 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; var &params: UInt64)>(GetQueryObjectui64v_adr);
    private ntv_GetQueryObjectui64v_2 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr)>(GetQueryObjectui64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64v(id: gl_query; pname: glQueryObjectParameterName; var &params: UInt64) :=
      ntv_GetQueryObjectui64v_1(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64v(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr) :=
      ntv_GetQueryObjectui64v_2(id, pname, &params);
    
    // added in gl1.5
    private GetQueryObjectuiv_adr := GetProcAddress('glGetQueryObjectuiv');
    private ntv_GetQueryObjectuiv_1 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; var &params: UInt32)>(GetQueryObjectuiv_adr);
    private ntv_GetQueryObjectuiv_2 := GetProcOrNil&<procedure(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr)>(GetQueryObjectuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectuiv(id: gl_query; pname: glQueryObjectParameterName; var &params: UInt32) :=
      ntv_GetQueryObjectuiv_1(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectuiv(id: gl_query; pname: glQueryObjectParameterName; &params: IntPtr) :=
      ntv_GetQueryObjectuiv_2(id, pname, &params);
    
    // added in gl3.0
    private GetRenderbufferParameteriv_adr := GetProcAddress('glGetRenderbufferParameteriv');
    private ntv_GetRenderbufferParameteriv_1 := GetProcOrNil&<procedure(target: glRenderbufferTarget; pname: glRenderbufferParameterName; var &params: Int32)>(GetRenderbufferParameteriv_adr);
    private ntv_GetRenderbufferParameteriv_2 := GetProcOrNil&<procedure(target: glRenderbufferTarget; pname: glRenderbufferParameterName; &params: IntPtr)>(GetRenderbufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameteriv(target: glRenderbufferTarget; pname: glRenderbufferParameterName; var &params: Int32) :=
      ntv_GetRenderbufferParameteriv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameteriv(target: glRenderbufferTarget; pname: glRenderbufferParameterName; &params: IntPtr) :=
      ntv_GetRenderbufferParameteriv_2(target, pname, &params);
    
    // added in gl3.3
    private GetSamplerParameterfv_adr := GetProcAddress('glGetSamplerParameterfv');
    private ntv_GetSamplerParameterfv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterF; var &params: single)>(GetSamplerParameterfv_adr);
    private ntv_GetSamplerParameterfv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterF; &params: IntPtr)>(GetSamplerParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterfv(sampler: gl_sampler; pname: glSamplerParameterF; var &params: single) :=
      ntv_GetSamplerParameterfv_1(sampler, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterfv(sampler: gl_sampler; pname: glSamplerParameterF; &params: IntPtr) :=
      ntv_GetSamplerParameterfv_2(sampler, pname, &params);
    
    // added in gl3.3
    private GetSamplerParameterIiv_adr := GetProcAddress('glGetSamplerParameterIiv');
    private ntv_GetSamplerParameterIiv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; var &params: Int32)>(GetSamplerParameterIiv_adr);
    private ntv_GetSamplerParameterIiv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; &params: IntPtr)>(GetSamplerParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIiv(sampler: gl_sampler; pname: glSamplerParameterI; var &params: Int32) :=
      ntv_GetSamplerParameterIiv_1(sampler, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIiv(sampler: gl_sampler; pname: glSamplerParameterI; &params: IntPtr) :=
      ntv_GetSamplerParameterIiv_2(sampler, pname, &params);
    
    // added in gl3.3
    private GetSamplerParameterIuiv_adr := GetProcAddress('glGetSamplerParameterIuiv');
    private ntv_GetSamplerParameterIuiv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; var &params: UInt32)>(GetSamplerParameterIuiv_adr);
    private ntv_GetSamplerParameterIuiv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; &params: IntPtr)>(GetSamplerParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuiv(sampler: gl_sampler; pname: glSamplerParameterI; var &params: UInt32) :=
      ntv_GetSamplerParameterIuiv_1(sampler, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuiv(sampler: gl_sampler; pname: glSamplerParameterI; &params: IntPtr) :=
      ntv_GetSamplerParameterIuiv_2(sampler, pname, &params);
    
    // added in gl3.3
    private GetSamplerParameteriv_adr := GetProcAddress('glGetSamplerParameteriv');
    private ntv_GetSamplerParameteriv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; var &params: Int32)>(GetSamplerParameteriv_adr);
    private ntv_GetSamplerParameteriv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; &params: IntPtr)>(GetSamplerParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameteriv(sampler: gl_sampler; pname: glSamplerParameterI; var &params: Int32) :=
      ntv_GetSamplerParameteriv_1(sampler, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameteriv(sampler: gl_sampler; pname: glSamplerParameterI; &params: IntPtr) :=
      ntv_GetSamplerParameteriv_2(sampler, pname, &params);
    
    // added in gl2.0
    private GetShaderInfoLog_adr := GetProcAddress('glGetShaderInfoLog');
    private ntv_GetShaderInfoLog_1 := GetProcOrNil&<procedure(shader: gl_shader; bufSize: Int32; var length: Int32; infoLog: IntPtr)>(GetShaderInfoLog_adr);
    private ntv_GetShaderInfoLog_2 := GetProcOrNil&<procedure(shader: gl_shader; bufSize: Int32; length: IntPtr; infoLog: IntPtr)>(GetShaderInfoLog_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderInfoLog(shader: gl_shader; bufSize: Int32; var length: Int32; infoLog: IntPtr) :=
      ntv_GetShaderInfoLog_1(shader, bufSize, length, infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderInfoLog(shader: gl_shader; bufSize: Int32; length: IntPtr; infoLog: IntPtr) :=
      ntv_GetShaderInfoLog_2(shader, bufSize, length, infoLog);
    
    // added in gl2.0
    private GetShaderiv_adr := GetProcAddress('glGetShaderiv');
    private ntv_GetShaderiv_1 := GetProcOrNil&<procedure(shader: gl_shader; pname: glShaderParameterName; var &params: Int32)>(GetShaderiv_adr);
    private ntv_GetShaderiv_2 := GetProcOrNil&<procedure(shader: gl_shader; pname: glShaderParameterName; &params: IntPtr)>(GetShaderiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderiv(shader: gl_shader; pname: glShaderParameterName; var &params: Int32) :=
      ntv_GetShaderiv_1(shader, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderiv(shader: gl_shader; pname: glShaderParameterName; &params: IntPtr) :=
      ntv_GetShaderiv_2(shader, pname, &params);
    
    // added in gl4.1
    private GetShaderPrecisionFormat_adr := GetProcAddress('glGetShaderPrecisionFormat');
    private ntv_GetShaderPrecisionFormat_1 := GetProcOrNil&<procedure(shadertype: glShaderType; precisiontype: glPrecisionType; var range: Int32; var precision: Int32)>(GetShaderPrecisionFormat_adr);
    private ntv_GetShaderPrecisionFormat_2 := GetProcOrNil&<procedure(shadertype: glShaderType; precisiontype: glPrecisionType; var range: Int32; precision: IntPtr)>(GetShaderPrecisionFormat_adr);
    private ntv_GetShaderPrecisionFormat_3 := GetProcOrNil&<procedure(shadertype: glShaderType; precisiontype: glPrecisionType; range: IntPtr; var precision: Int32)>(GetShaderPrecisionFormat_adr);
    private ntv_GetShaderPrecisionFormat_4 := GetProcOrNil&<procedure(shadertype: glShaderType; precisiontype: glPrecisionType; range: IntPtr; precision: IntPtr)>(GetShaderPrecisionFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(shadertype: glShaderType; precisiontype: glPrecisionType; var range: Int32; var precision: Int32) :=
      ntv_GetShaderPrecisionFormat_1(shadertype, precisiontype, range, precision);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(shadertype: glShaderType; precisiontype: glPrecisionType; var range: Int32; precision: IntPtr) :=
      ntv_GetShaderPrecisionFormat_2(shadertype, precisiontype, range, precision);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(shadertype: glShaderType; precisiontype: glPrecisionType; range: IntPtr; var precision: Int32) :=
      ntv_GetShaderPrecisionFormat_3(shadertype, precisiontype, range, precision);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(shadertype: glShaderType; precisiontype: glPrecisionType; range: IntPtr; precision: IntPtr) :=
      ntv_GetShaderPrecisionFormat_4(shadertype, precisiontype, range, precision);
    
    // added in gl2.0
    private GetShaderSource_adr := GetProcAddress('glGetShaderSource');
    private ntv_GetShaderSource_1 := GetProcOrNil&<procedure(shader: gl_shader; bufSize: Int32; var length: Int32; source: IntPtr)>(GetShaderSource_adr);
    private ntv_GetShaderSource_2 := GetProcOrNil&<procedure(shader: gl_shader; bufSize: Int32; length: IntPtr; source: IntPtr)>(GetShaderSource_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSource(shader: gl_shader; bufSize: Int32; var length: Int32; source: IntPtr) :=
      ntv_GetShaderSource_1(shader, bufSize, length, source);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSource(shader: gl_shader; bufSize: Int32; length: IntPtr; source: IntPtr) :=
      ntv_GetShaderSource_2(shader, bufSize, length, source);
    
    // added in gl1.0
    private GetString_adr := GetProcAddress('glGetString');
    private ntv_GetString_1 := GetProcOrNil&<function(name: glStringName): IntPtr>(GetString_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetString(name: glStringName): string :=
      Marshal.PtrToStringAnsi(ntv_GetString_1(name));
    
    // added in gl3.0
    private GetStringi_adr := GetProcAddress('glGetStringi');
    private ntv_GetStringi_1 := GetProcOrNil&<function(name: glStringName; index: UInt32): IntPtr>(GetStringi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetStringi(name: glStringName; index: UInt32): string :=
      Marshal.PtrToStringAnsi(ntv_GetStringi_1(name, index));
    
    // added in gl4.0
    private GetSubroutineIndex_adr := GetProcAddress('glGetSubroutineIndex');
    private ntv_GetSubroutineIndex_1 := GetProcOrNil&<function(&program: gl_program; shadertype: glShaderType; name: IntPtr): UInt32>(GetSubroutineIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineIndex(&program: gl_program; shadertype: glShaderType; name: string): UInt32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetSubroutineIndex_1(&program, shadertype, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineIndex(&program: gl_program; shadertype: glShaderType; name: IntPtr): UInt32 :=
      ntv_GetSubroutineIndex_1(&program, shadertype, name);
    
    // added in gl4.0
    private GetSubroutineUniformLocation_adr := GetProcAddress('glGetSubroutineUniformLocation');
    private ntv_GetSubroutineUniformLocation_1 := GetProcOrNil&<function(&program: gl_program; shadertype: glShaderType; name: IntPtr): Int32>(GetSubroutineUniformLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineUniformLocation(&program: gl_program; shadertype: glShaderType; name: string): Int32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetSubroutineUniformLocation_1(&program, shadertype, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineUniformLocation(&program: gl_program; shadertype: glShaderType; name: IntPtr): Int32 :=
      ntv_GetSubroutineUniformLocation_1(&program, shadertype, name);
    
    // added in gl3.2
    private GetSynciv_adr := GetProcAddress('glGetSynciv');
    private ntv_GetSynciv_1 := GetProcOrNil&<procedure(sync: gl_sync; pname: glSyncParameterName; count: Int32; var length: Int32; var values: Int32)>(GetSynciv_adr);
    private ntv_GetSynciv_2 := GetProcOrNil&<procedure(sync: gl_sync; pname: glSyncParameterName; count: Int32; var length: Int32; values: IntPtr)>(GetSynciv_adr);
    private ntv_GetSynciv_3 := GetProcOrNil&<procedure(sync: gl_sync; pname: glSyncParameterName; count: Int32; length: IntPtr; var values: Int32)>(GetSynciv_adr);
    private ntv_GetSynciv_4 := GetProcOrNil&<procedure(sync: gl_sync; pname: glSyncParameterName; count: Int32; length: IntPtr; values: IntPtr)>(GetSynciv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: gl_sync; pname: glSyncParameterName; count: Int32; var length: Int32; var values: Int32) :=
      ntv_GetSynciv_1(sync, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: gl_sync; pname: glSyncParameterName; count: Int32; var length: Int32; values: IntPtr) :=
      ntv_GetSynciv_2(sync, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: gl_sync; pname: glSyncParameterName; count: Int32; length: IntPtr; var values: Int32) :=
      ntv_GetSynciv_3(sync, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: gl_sync; pname: glSyncParameterName; count: Int32; length: IntPtr; values: IntPtr) :=
      ntv_GetSynciv_4(sync, pname, count, length, values);
    
    // added in gl1.0
    private GetTexImage_adr := GetProcAddress('glGetTexImage');
    private ntv_GetTexImage_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(GetTexImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexImage(target: glTextureTarget; level: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_GetTexImage_1(target, level, format, &type, pixels);
    
    // added in gl1.0
    private GetTexLevelParameterfv_adr := GetProcAddress('glGetTexLevelParameterfv');
    private ntv_GetTexLevelParameterfv_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; pname: glGetTextureParameter; var &params: single)>(GetTexLevelParameterfv_adr);
    private ntv_GetTexLevelParameterfv_2 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; pname: glGetTextureParameter; &params: IntPtr)>(GetTexLevelParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterfv(target: glTextureTarget; level: Int32; pname: glGetTextureParameter; var &params: single) :=
      ntv_GetTexLevelParameterfv_1(target, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterfv(target: glTextureTarget; level: Int32; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTexLevelParameterfv_2(target, level, pname, &params);
    
    // added in gl1.0
    private GetTexLevelParameteriv_adr := GetProcAddress('glGetTexLevelParameteriv');
    private ntv_GetTexLevelParameteriv_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; pname: glGetTextureParameter; var &params: Int32)>(GetTexLevelParameteriv_adr);
    private ntv_GetTexLevelParameteriv_2 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; pname: glGetTextureParameter; &params: IntPtr)>(GetTexLevelParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameteriv(target: glTextureTarget; level: Int32; pname: glGetTextureParameter; var &params: Int32) :=
      ntv_GetTexLevelParameteriv_1(target, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameteriv(target: glTextureTarget; level: Int32; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTexLevelParameteriv_2(target, level, pname, &params);
    
    // added in gl1.0
    private GetTexParameterfv_adr := GetProcAddress('glGetTexParameterfv');
    private ntv_GetTexParameterfv_1 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glGetTextureParameter; var &params: single)>(GetTexParameterfv_adr);
    private ntv_GetTexParameterfv_2 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr)>(GetTexParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterfv(target: glTextureTarget; pname: glGetTextureParameter; var &params: single) :=
      ntv_GetTexParameterfv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterfv(target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTexParameterfv_2(target, pname, &params);
    
    // added in gl3.0
    private GetTexParameterIiv_adr := GetProcAddress('glGetTexParameterIiv');
    private ntv_GetTexParameterIiv_1 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glGetTextureParameter; var &params: Int32)>(GetTexParameterIiv_adr);
    private ntv_GetTexParameterIiv_2 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr)>(GetTexParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIiv(target: glTextureTarget; pname: glGetTextureParameter; var &params: Int32) :=
      ntv_GetTexParameterIiv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIiv(target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTexParameterIiv_2(target, pname, &params);
    
    // added in gl3.0
    private GetTexParameterIuiv_adr := GetProcAddress('glGetTexParameterIuiv');
    private ntv_GetTexParameterIuiv_1 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glGetTextureParameter; var &params: UInt32)>(GetTexParameterIuiv_adr);
    private ntv_GetTexParameterIuiv_2 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr)>(GetTexParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuiv(target: glTextureTarget; pname: glGetTextureParameter; var &params: UInt32) :=
      ntv_GetTexParameterIuiv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuiv(target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTexParameterIuiv_2(target, pname, &params);
    
    // added in gl1.0
    private GetTexParameteriv_adr := GetProcAddress('glGetTexParameteriv');
    private ntv_GetTexParameteriv_1 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glGetTextureParameter; var &params: Int32)>(GetTexParameteriv_adr);
    private ntv_GetTexParameteriv_2 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr)>(GetTexParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameteriv(target: glTextureTarget; pname: glGetTextureParameter; var &params: Int32) :=
      ntv_GetTexParameteriv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameteriv(target: glTextureTarget; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTexParameteriv_2(target, pname, &params);
    
    // added in gl4.5
    private GetTextureImage_adr := GetProcAddress('glGetTextureImage');
    private ntv_GetTextureImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; pixels: IntPtr)>(GetTextureImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureImage(texture: gl_texture; level: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; pixels: IntPtr) :=
      ntv_GetTextureImage_1(texture, level, format, &type, bufSize, pixels);
    
    // added in gl4.5
    private GetTextureLevelParameterfv_adr := GetProcAddress('glGetTextureLevelParameterfv');
    private ntv_GetTextureLevelParameterfv_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; pname: glGetTextureParameter; var &params: single)>(GetTextureLevelParameterfv_adr);
    private ntv_GetTextureLevelParameterfv_2 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureLevelParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterfv(texture: gl_texture; level: Int32; pname: glGetTextureParameter; var &params: single) :=
      ntv_GetTextureLevelParameterfv_1(texture, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterfv(texture: gl_texture; level: Int32; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureLevelParameterfv_2(texture, level, pname, &params);
    
    // added in gl4.5
    private GetTextureLevelParameteriv_adr := GetProcAddress('glGetTextureLevelParameteriv');
    private ntv_GetTextureLevelParameteriv_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; pname: glGetTextureParameter; var &params: Int32)>(GetTextureLevelParameteriv_adr);
    private ntv_GetTextureLevelParameteriv_2 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureLevelParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameteriv(texture: gl_texture; level: Int32; pname: glGetTextureParameter; var &params: Int32) :=
      ntv_GetTextureLevelParameteriv_1(texture, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameteriv(texture: gl_texture; level: Int32; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureLevelParameteriv_2(texture, level, pname, &params);
    
    // added in gl4.5
    private GetTextureParameterfv_adr := GetProcAddress('glGetTextureParameterfv');
    private ntv_GetTextureParameterfv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glGetTextureParameter; var &params: single)>(GetTextureParameterfv_adr);
    private ntv_GetTextureParameterfv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterfv(texture: gl_texture; pname: glGetTextureParameter; var &params: single) :=
      ntv_GetTextureParameterfv_1(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterfv(texture: gl_texture; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureParameterfv_2(texture, pname, &params);
    
    // added in gl4.5
    private GetTextureParameterIiv_adr := GetProcAddress('glGetTextureParameterIiv');
    private ntv_GetTextureParameterIiv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glGetTextureParameter; var &params: Int32)>(GetTextureParameterIiv_adr);
    private ntv_GetTextureParameterIiv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIiv(texture: gl_texture; pname: glGetTextureParameter; var &params: Int32) :=
      ntv_GetTextureParameterIiv_1(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIiv(texture: gl_texture; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureParameterIiv_2(texture, pname, &params);
    
    // added in gl4.5
    private GetTextureParameterIuiv_adr := GetProcAddress('glGetTextureParameterIuiv');
    private ntv_GetTextureParameterIuiv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glGetTextureParameter; var &params: UInt32)>(GetTextureParameterIuiv_adr);
    private ntv_GetTextureParameterIuiv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuiv(texture: gl_texture; pname: glGetTextureParameter; var &params: UInt32) :=
      ntv_GetTextureParameterIuiv_1(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuiv(texture: gl_texture; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureParameterIuiv_2(texture, pname, &params);
    
    // added in gl4.5
    private GetTextureParameteriv_adr := GetProcAddress('glGetTextureParameteriv');
    private ntv_GetTextureParameteriv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glGetTextureParameter; var &params: Int32)>(GetTextureParameteriv_adr);
    private ntv_GetTextureParameteriv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glGetTextureParameter; &params: IntPtr)>(GetTextureParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameteriv(texture: gl_texture; pname: glGetTextureParameter; var &params: Int32) :=
      ntv_GetTextureParameteriv_1(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameteriv(texture: gl_texture; pname: glGetTextureParameter; &params: IntPtr) :=
      ntv_GetTextureParameteriv_2(texture, pname, &params);
    
    // added in gl4.5
    private GetTextureSubImage_adr := GetProcAddress('glGetTextureSubImage');
    private ntv_GetTextureSubImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; pixels: IntPtr)>(GetTextureSubImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureSubImage(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; pixels: IntPtr) :=
      ntv_GetTextureSubImage_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, bufSize, pixels);
    
    // added in gl4.5
    private GetTransformFeedbacki_v_adr := GetProcAddress('glGetTransformFeedbacki_v');
    private ntv_GetTransformFeedbacki_v_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; index: UInt32; var param: Int32)>(GetTransformFeedbacki_v_adr);
    private ntv_GetTransformFeedbacki_v_2 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; index: UInt32; param: IntPtr)>(GetTransformFeedbacki_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki_v(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; index: UInt32; var param: Int32) :=
      ntv_GetTransformFeedbacki_v_1(xfb, pname, index, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki_v(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; index: UInt32; param: IntPtr) :=
      ntv_GetTransformFeedbacki_v_2(xfb, pname, index, param);
    
    // added in gl4.5
    private GetTransformFeedbacki64_v_adr := GetProcAddress('glGetTransformFeedbacki64_v');
    private ntv_GetTransformFeedbacki64_v_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; index: UInt32; var param: Int64)>(GetTransformFeedbacki64_v_adr);
    private ntv_GetTransformFeedbacki64_v_2 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; index: UInt32; param: IntPtr)>(GetTransformFeedbacki64_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki64_v(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; index: UInt32; var param: Int64) :=
      ntv_GetTransformFeedbacki64_v_1(xfb, pname, index, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki64_v(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; index: UInt32; param: IntPtr) :=
      ntv_GetTransformFeedbacki64_v_2(xfb, pname, index, param);
    
    // added in gl4.5
    private GetTransformFeedbackiv_adr := GetProcAddress('glGetTransformFeedbackiv');
    private ntv_GetTransformFeedbackiv_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; var param: Int32)>(GetTransformFeedbackiv_adr);
    private ntv_GetTransformFeedbackiv_2 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; param: IntPtr)>(GetTransformFeedbackiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackiv(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; var param: Int32) :=
      ntv_GetTransformFeedbackiv_1(xfb, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackiv(xfb: gl_transform_feedback; pname: glTransformFeedbackPName; param: IntPtr) :=
      ntv_GetTransformFeedbackiv_2(xfb, pname, param);
    
    // added in gl3.0
    private GetTransformFeedbackVarying_adr := GetProcAddress('glGetTransformFeedbackVarying');
    private ntv_GetTransformFeedbackVarying_1 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: glAttributeType; name: IntPtr)>(GetTransformFeedbackVarying_adr);
    private ntv_GetTransformFeedbackVarying_2 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr)>(GetTransformFeedbackVarying_adr);
    private ntv_GetTransformFeedbackVarying_3 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: glAttributeType; name: IntPtr)>(GetTransformFeedbackVarying_adr);
    private ntv_GetTransformFeedbackVarying_4 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr)>(GetTransformFeedbackVarying_adr);
    private ntv_GetTransformFeedbackVarying_5 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: glAttributeType; name: IntPtr)>(GetTransformFeedbackVarying_adr);
    private ntv_GetTransformFeedbackVarying_6 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr)>(GetTransformFeedbackVarying_adr);
    private ntv_GetTransformFeedbackVarying_7 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: glAttributeType; name: IntPtr)>(GetTransformFeedbackVarying_adr);
    private ntv_GetTransformFeedbackVarying_8 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr)>(GetTransformFeedbackVarying_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: glAttributeType; name: IntPtr) :=
      ntv_GetTransformFeedbackVarying_1(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr) :=
      ntv_GetTransformFeedbackVarying_2(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: glAttributeType; name: IntPtr) :=
      ntv_GetTransformFeedbackVarying_3(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr) :=
      ntv_GetTransformFeedbackVarying_4(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: glAttributeType; name: IntPtr) :=
      ntv_GetTransformFeedbackVarying_5(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr) :=
      ntv_GetTransformFeedbackVarying_6(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: glAttributeType; name: IntPtr) :=
      ntv_GetTransformFeedbackVarying_7(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr) :=
      ntv_GetTransformFeedbackVarying_8(&program, index, bufSize, length, size, &type, name);
    
    // added in gl3.1
    private GetUniformBlockIndex_adr := GetProcAddress('glGetUniformBlockIndex');
    private ntv_GetUniformBlockIndex_1 := GetProcOrNil&<function(&program: gl_program; uniformBlockName: IntPtr): UInt32>(GetUniformBlockIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformBlockIndex(&program: gl_program; uniformBlockName: string): UInt32;
    begin
      var uniformBlockName_str_ptr := Marshal.StringToHGlobalAnsi(uniformBlockName);
      try
        Result := ntv_GetUniformBlockIndex_1(&program, uniformBlockName_str_ptr);
      finally
        Marshal.FreeHGlobal(uniformBlockName_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformBlockIndex(&program: gl_program; uniformBlockName: IntPtr): UInt32 :=
      ntv_GetUniformBlockIndex_1(&program, uniformBlockName);
    
    // added in gl4.0
    private GetUniformdv_adr := GetProcAddress('glGetUniformdv');
    private ntv_GetUniformdv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: double)>(GetUniformdv_adr);
    private ntv_GetUniformdv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(GetUniformdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformdv(&program: gl_program; location: Int32; var &params: double) :=
      ntv_GetUniformdv_1(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformdv(&program: gl_program; location: Int32; &params: IntPtr) :=
      ntv_GetUniformdv_2(&program, location, &params);
    
    // added in gl2.0
    private GetUniformfv_adr := GetProcAddress('glGetUniformfv');
    private ntv_GetUniformfv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: single)>(GetUniformfv_adr);
    private ntv_GetUniformfv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(GetUniformfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformfv(&program: gl_program; location: Int32; var &params: single) :=
      ntv_GetUniformfv_1(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformfv(&program: gl_program; location: Int32; &params: IntPtr) :=
      ntv_GetUniformfv_2(&program, location, &params);
    
    // added in gl3.1
    private GetUniformIndices_adr := GetProcAddress('glGetUniformIndices');
    private ntv_GetUniformIndices_1 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; var uniformNames: IntPtr; var uniformIndices: UInt32)>(GetUniformIndices_adr);
    private ntv_GetUniformIndices_2 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; uniformNames: pointer; var uniformIndices: UInt32)>(GetUniformIndices_adr);
    private ntv_GetUniformIndices_3 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; var uniformNames: IntPtr; uniformIndices: IntPtr)>(GetUniformIndices_adr);
    private ntv_GetUniformIndices_4 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; uniformNames: pointer; uniformIndices: IntPtr)>(GetUniformIndices_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; uniformNames: array of string; var uniformIndices: UInt32);
    begin
      if (uniformNames=nil) or (uniformNames.Length=0) then
      begin
        ntv_GetUniformIndices_2(&program, uniformCount, nil, uniformIndices);
        exit;
      end;
      var uniformNames_temp_arr: array of IntPtr;
      try
        begin
          var uniformNames_org_el_1 := uniformNames;
          var uniformNames_len_1 := uniformNames_org_el_1.Length;
          SetLength(uniformNames_temp_arr, uniformNames_len_1);
          var uniformNames_tmp_el_1 := uniformNames_temp_arr;
          for var uniformNames_ind_1 := 0 to uniformNames_len_1-1 do
          begin
            var uniformNames_org_el_2 := uniformNames_org_el_1[uniformNames_ind_1];
            if (uniformNames_org_el_2=nil) or (uniformNames_org_el_2.Length=0) then continue;
            uniformNames_tmp_el_1[uniformNames_ind_1] := Marshal.StringToHGlobalAnsi(uniformNames_org_el_2);
          end;
        end;
        ntv_GetUniformIndices_1(&program, uniformCount, uniformNames_temp_arr[0], uniformIndices);
      finally
         foreach var arr_el1 in uniformNames_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; uniformNames: array of string; uniformIndices: IntPtr);
    begin
      if (uniformNames=nil) or (uniformNames.Length=0) then
      begin
        ntv_GetUniformIndices_4(&program, uniformCount, nil, uniformIndices);
        exit;
      end;
      var uniformNames_temp_arr: array of IntPtr;
      try
        begin
          var uniformNames_org_el_1 := uniformNames;
          var uniformNames_len_1 := uniformNames_org_el_1.Length;
          SetLength(uniformNames_temp_arr, uniformNames_len_1);
          var uniformNames_tmp_el_1 := uniformNames_temp_arr;
          for var uniformNames_ind_1 := 0 to uniformNames_len_1-1 do
          begin
            var uniformNames_org_el_2 := uniformNames_org_el_1[uniformNames_ind_1];
            if (uniformNames_org_el_2=nil) or (uniformNames_org_el_2.Length=0) then continue;
            uniformNames_tmp_el_1[uniformNames_ind_1] := Marshal.StringToHGlobalAnsi(uniformNames_org_el_2);
          end;
        end;
        ntv_GetUniformIndices_3(&program, uniformCount, uniformNames_temp_arr[0], uniformIndices);
      finally
         foreach var arr_el1 in uniformNames_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; var uniformNames: IntPtr; var uniformIndices: UInt32) :=
      ntv_GetUniformIndices_1(&program, uniformCount, uniformNames, uniformIndices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; var uniformNames: IntPtr; uniformIndices: IntPtr) :=
      ntv_GetUniformIndices_3(&program, uniformCount, uniformNames, uniformIndices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; uniformNames: pointer; var uniformIndices: UInt32) :=
      ntv_GetUniformIndices_2(&program, uniformCount, uniformNames, uniformIndices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; uniformNames: pointer; uniformIndices: IntPtr) :=
      ntv_GetUniformIndices_4(&program, uniformCount, uniformNames, uniformIndices);
    
    // added in gl2.0
    private GetUniformiv_adr := GetProcAddress('glGetUniformiv');
    private ntv_GetUniformiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: Int32)>(GetUniformiv_adr);
    private ntv_GetUniformiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(GetUniformiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformiv(&program: gl_program; location: Int32; var &params: Int32) :=
      ntv_GetUniformiv_1(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformiv(&program: gl_program; location: Int32; &params: IntPtr) :=
      ntv_GetUniformiv_2(&program, location, &params);
    
    // added in gl2.0
    private GetUniformLocation_adr := GetProcAddress('glGetUniformLocation');
    private ntv_GetUniformLocation_1 := GetProcOrNil&<function(&program: gl_program; name: IntPtr): Int32>(GetUniformLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformLocation(&program: gl_program; name: string): Int32;
    begin
      var name_str_ptr := Marshal.StringToHGlobalAnsi(name);
      try
        Result := ntv_GetUniformLocation_1(&program, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformLocation(&program: gl_program; name: IntPtr): Int32 :=
      ntv_GetUniformLocation_1(&program, name);
    
    // added in gl4.0
    private GetUniformSubroutineuiv_adr := GetProcAddress('glGetUniformSubroutineuiv');
    private ntv_GetUniformSubroutineuiv_1 := GetProcOrNil&<procedure(shadertype: glShaderType; location: Int32; var &params: UInt32)>(GetUniformSubroutineuiv_adr);
    private ntv_GetUniformSubroutineuiv_2 := GetProcOrNil&<procedure(shadertype: glShaderType; location: Int32; &params: IntPtr)>(GetUniformSubroutineuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformSubroutineuiv(shadertype: glShaderType; location: Int32; var &params: UInt32) :=
      ntv_GetUniformSubroutineuiv_1(shadertype, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformSubroutineuiv(shadertype: glShaderType; location: Int32; &params: IntPtr) :=
      ntv_GetUniformSubroutineuiv_2(shadertype, location, &params);
    
    // added in gl3.0
    private GetUniformuiv_adr := GetProcAddress('glGetUniformuiv');
    private ntv_GetUniformuiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: UInt32)>(GetUniformuiv_adr);
    private ntv_GetUniformuiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(GetUniformuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformuiv(&program: gl_program; location: Int32; var &params: UInt32) :=
      ntv_GetUniformuiv_1(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformuiv(&program: gl_program; location: Int32; &params: IntPtr) :=
      ntv_GetUniformuiv_2(&program, location, &params);
    
    // added in gl4.5
    private GetVertexArrayIndexed64iv_adr := GetProcAddress('glGetVertexArrayIndexed64iv');
    private ntv_GetVertexArrayIndexed64iv_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; var param: Int64)>(GetVertexArrayIndexed64iv_adr);
    private ntv_GetVertexArrayIndexed64iv_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; param: IntPtr)>(GetVertexArrayIndexed64iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexed64iv(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; var param: Int64) :=
      ntv_GetVertexArrayIndexed64iv_1(vaobj, index, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexed64iv(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; param: IntPtr) :=
      ntv_GetVertexArrayIndexed64iv_2(vaobj, index, pname, param);
    
    // added in gl4.5
    private GetVertexArrayIndexediv_adr := GetProcAddress('glGetVertexArrayIndexediv');
    private ntv_GetVertexArrayIndexediv_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; var param: Int32)>(GetVertexArrayIndexediv_adr);
    private ntv_GetVertexArrayIndexediv_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; param: IntPtr)>(GetVertexArrayIndexediv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexediv(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; var param: Int32) :=
      ntv_GetVertexArrayIndexediv_1(vaobj, index, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexediv(vaobj: gl_vertex_array; index: UInt32; pname: glVertexArrayPName; param: IntPtr) :=
      ntv_GetVertexArrayIndexediv_2(vaobj, index, pname, param);
    
    // added in gl4.5
    private GetVertexArrayiv_adr := GetProcAddress('glGetVertexArrayiv');
    private ntv_GetVertexArrayiv_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; pname: glVertexArrayPName; var param: Int32)>(GetVertexArrayiv_adr);
    private ntv_GetVertexArrayiv_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; pname: glVertexArrayPName; param: IntPtr)>(GetVertexArrayiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayiv(vaobj: gl_vertex_array; pname: glVertexArrayPName; var param: Int32) :=
      ntv_GetVertexArrayiv_1(vaobj, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayiv(vaobj: gl_vertex_array; pname: glVertexArrayPName; param: IntPtr) :=
      ntv_GetVertexArrayiv_2(vaobj, pname, param);
    
    // added in gl2.0
    private GetVertexAttribdv_adr := GetProcAddress('glGetVertexAttribdv');
    private ntv_GetVertexAttribdv_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; var &params: double)>(GetVertexAttribdv_adr);
    private ntv_GetVertexAttribdv_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr)>(GetVertexAttribdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdv(index: UInt32; pname: glVertexAttribProperty; var &params: double) :=
      ntv_GetVertexAttribdv_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdv(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr) :=
      ntv_GetVertexAttribdv_2(index, pname, &params);
    
    // added in gl2.0
    private GetVertexAttribfv_adr := GetProcAddress('glGetVertexAttribfv');
    private ntv_GetVertexAttribfv_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; var &params: single)>(GetVertexAttribfv_adr);
    private ntv_GetVertexAttribfv_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr)>(GetVertexAttribfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfv(index: UInt32; pname: glVertexAttribProperty; var &params: single) :=
      ntv_GetVertexAttribfv_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfv(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr) :=
      ntv_GetVertexAttribfv_2(index, pname, &params);
    
    // added in gl3.0
    private GetVertexAttribIiv_adr := GetProcAddress('glGetVertexAttribIiv');
    private ntv_GetVertexAttribIiv_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; var &params: Int32)>(GetVertexAttribIiv_adr);
    private ntv_GetVertexAttribIiv_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr)>(GetVertexAttribIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIiv(index: UInt32; pname: glVertexAttribEnum; var &params: Int32) :=
      ntv_GetVertexAttribIiv_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIiv(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr) :=
      ntv_GetVertexAttribIiv_2(index, pname, &params);
    
    // added in gl3.0
    private GetVertexAttribIuiv_adr := GetProcAddress('glGetVertexAttribIuiv');
    private ntv_GetVertexAttribIuiv_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; var &params: UInt32)>(GetVertexAttribIuiv_adr);
    private ntv_GetVertexAttribIuiv_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr)>(GetVertexAttribIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuiv(index: UInt32; pname: glVertexAttribEnum; var &params: UInt32) :=
      ntv_GetVertexAttribIuiv_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuiv(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr) :=
      ntv_GetVertexAttribIuiv_2(index, pname, &params);
    
    // added in gl2.0
    private GetVertexAttribiv_adr := GetProcAddress('glGetVertexAttribiv');
    private ntv_GetVertexAttribiv_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; var &params: Int32)>(GetVertexAttribiv_adr);
    private ntv_GetVertexAttribiv_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr)>(GetVertexAttribiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribiv(index: UInt32; pname: glVertexAttribProperty; var &params: Int32) :=
      ntv_GetVertexAttribiv_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribiv(index: UInt32; pname: glVertexAttribProperty; &params: IntPtr) :=
      ntv_GetVertexAttribiv_2(index, pname, &params);
    
    // added in gl4.1
    private GetVertexAttribLdv_adr := GetProcAddress('glGetVertexAttribLdv');
    private ntv_GetVertexAttribLdv_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; var &params: double)>(GetVertexAttribLdv_adr);
    private ntv_GetVertexAttribLdv_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr)>(GetVertexAttribLdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdv(index: UInt32; pname: glVertexAttribEnum; var &params: double) :=
      ntv_GetVertexAttribLdv_1(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdv(index: UInt32; pname: glVertexAttribEnum; &params: IntPtr) :=
      ntv_GetVertexAttribLdv_2(index, pname, &params);
    
    // added in gl2.0
    private GetVertexAttribPointerv_adr := GetProcAddress('glGetVertexAttribPointerv');
    private ntv_GetVertexAttribPointerv_1 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribPointerProperty; var pointer: IntPtr)>(GetVertexAttribPointerv_adr);
    private ntv_GetVertexAttribPointerv_2 := GetProcOrNil&<procedure(index: UInt32; pname: glVertexAttribPointerProperty; pointer: pointer)>(GetVertexAttribPointerv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointerv(index: UInt32; pname: glVertexAttribPointerProperty; var pointer: IntPtr) :=
      ntv_GetVertexAttribPointerv_1(index, pname, pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointerv(index: UInt32; pname: glVertexAttribPointerProperty; pointer: pointer) :=
      ntv_GetVertexAttribPointerv_2(index, pname, pointer);
    
    // added in gl1.0
    private Hint_adr := GetProcAddress('glHint');
    private ntv_Hint_1 := GetProcOrNil&<procedure(target: glHintTarget; mode: glHintMode)>(Hint_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Hint(target: glHintTarget; mode: glHintMode) :=
      ntv_Hint_1(target, mode);
    
    // added in gl4.3
    private InvalidateBufferData_adr := GetProcAddress('glInvalidateBufferData');
    private ntv_InvalidateBufferData_1 := GetProcOrNil&<procedure(buffer: gl_buffer)>(InvalidateBufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateBufferData(buffer: gl_buffer) :=
      ntv_InvalidateBufferData_1(buffer);
    
    // added in gl4.3
    private InvalidateBufferSubData_adr := GetProcAddress('glInvalidateBufferSubData');
    private ntv_InvalidateBufferSubData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; length: UIntPtr)>(InvalidateBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateBufferSubData(buffer: gl_buffer; offset: IntPtr; length: UIntPtr) :=
      ntv_InvalidateBufferSubData_1(buffer, offset, length);
    
    // added in gl4.3
    private InvalidateFramebuffer_adr := GetProcAddress('glInvalidateFramebuffer');
    private ntv_InvalidateFramebuffer_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; numAttachments: Int32; var attachments: glInvalidateFramebufferAttachment)>(InvalidateFramebuffer_adr);
    private ntv_InvalidateFramebuffer_2 := GetProcOrNil&<procedure(target: glFramebufferTarget; numAttachments: Int32; attachments: IntPtr)>(InvalidateFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateFramebuffer(target: glFramebufferTarget; numAttachments: Int32; attachments: array of glInvalidateFramebufferAttachment);
    type PGlInvalidateFramebufferAttachment = ^glInvalidateFramebufferAttachment;
    begin
      if (attachments<>nil) and (attachments.Length<>0) then
        ntv_InvalidateFramebuffer_1(target, numAttachments, attachments[0]) else
        ntv_InvalidateFramebuffer_1(target, numAttachments, PGlInvalidateFramebufferAttachment(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateFramebuffer(target: glFramebufferTarget; numAttachments: Int32; var attachments: glInvalidateFramebufferAttachment) :=
      ntv_InvalidateFramebuffer_1(target, numAttachments, attachments);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateFramebuffer(target: glFramebufferTarget; numAttachments: Int32; attachments: IntPtr) :=
      ntv_InvalidateFramebuffer_2(target, numAttachments, attachments);
    
    // added in gl4.5
    private InvalidateNamedFramebufferData_adr := GetProcAddress('glInvalidateNamedFramebufferData');
    private ntv_InvalidateNamedFramebufferData_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numAttachments: Int32; var attachments: glFramebufferAttachment)>(InvalidateNamedFramebufferData_adr);
    private ntv_InvalidateNamedFramebufferData_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: IntPtr)>(InvalidateNamedFramebufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferData(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: array of glFramebufferAttachment);
    type PGlFramebufferAttachment = ^glFramebufferAttachment;
    begin
      if (attachments<>nil) and (attachments.Length<>0) then
        ntv_InvalidateNamedFramebufferData_1(framebuffer, numAttachments, attachments[0]) else
        ntv_InvalidateNamedFramebufferData_1(framebuffer, numAttachments, PGlFramebufferAttachment(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferData(framebuffer: gl_framebuffer; numAttachments: Int32; var attachments: glFramebufferAttachment) :=
      ntv_InvalidateNamedFramebufferData_1(framebuffer, numAttachments, attachments);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferData(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: IntPtr) :=
      ntv_InvalidateNamedFramebufferData_2(framebuffer, numAttachments, attachments);
    
    // added in gl4.5
    private InvalidateNamedFramebufferSubData_adr := GetProcAddress('glInvalidateNamedFramebufferSubData');
    private ntv_InvalidateNamedFramebufferSubData_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numAttachments: Int32; var attachments: glFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32)>(InvalidateNamedFramebufferSubData_adr);
    private ntv_InvalidateNamedFramebufferSubData_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32)>(InvalidateNamedFramebufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferSubData(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: array of glFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32);
    type PGlFramebufferAttachment = ^glFramebufferAttachment;
    begin
      if (attachments<>nil) and (attachments.Length<>0) then
        ntv_InvalidateNamedFramebufferSubData_1(framebuffer, numAttachments, attachments[0], x, y, width, height) else
        ntv_InvalidateNamedFramebufferSubData_1(framebuffer, numAttachments, PGlFramebufferAttachment(nil)^, x, y, width, height);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferSubData(framebuffer: gl_framebuffer; numAttachments: Int32; var attachments: glFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_InvalidateNamedFramebufferSubData_1(framebuffer, numAttachments, attachments, x, y, width, height);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferSubData(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_InvalidateNamedFramebufferSubData_2(framebuffer, numAttachments, attachments, x, y, width, height);
    
    // added in gl4.3
    private InvalidateSubFramebuffer_adr := GetProcAddress('glInvalidateSubFramebuffer');
    private ntv_InvalidateSubFramebuffer_1 := GetProcOrNil&<procedure(target: glFramebufferTarget; numAttachments: Int32; var attachments: glInvalidateFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32)>(InvalidateSubFramebuffer_adr);
    private ntv_InvalidateSubFramebuffer_2 := GetProcOrNil&<procedure(target: glFramebufferTarget; numAttachments: Int32; attachments: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32)>(InvalidateSubFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateSubFramebuffer(target: glFramebufferTarget; numAttachments: Int32; attachments: array of glInvalidateFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32);
    type PGlInvalidateFramebufferAttachment = ^glInvalidateFramebufferAttachment;
    begin
      if (attachments<>nil) and (attachments.Length<>0) then
        ntv_InvalidateSubFramebuffer_1(target, numAttachments, attachments[0], x, y, width, height) else
        ntv_InvalidateSubFramebuffer_1(target, numAttachments, PGlInvalidateFramebufferAttachment(nil)^, x, y, width, height);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateSubFramebuffer(target: glFramebufferTarget; numAttachments: Int32; var attachments: glInvalidateFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_InvalidateSubFramebuffer_1(target, numAttachments, attachments, x, y, width, height);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateSubFramebuffer(target: glFramebufferTarget; numAttachments: Int32; attachments: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_InvalidateSubFramebuffer_2(target, numAttachments, attachments, x, y, width, height);
    
    // added in gl4.3
    private InvalidateTexImage_adr := GetProcAddress('glInvalidateTexImage');
    private ntv_InvalidateTexImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32)>(InvalidateTexImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateTexImage(texture: gl_texture; level: Int32) :=
      ntv_InvalidateTexImage_1(texture, level);
    
    // added in gl4.3
    private InvalidateTexSubImage_adr := GetProcAddress('glInvalidateTexSubImage');
    private ntv_InvalidateTexSubImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32)>(InvalidateTexSubImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateTexSubImage(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32) :=
      ntv_InvalidateTexSubImage_1(texture, level, xoffset, yoffset, zoffset, width, height, depth);
    
    // added in gl1.5
    private IsBuffer_adr := GetProcAddress('glIsBuffer');
    private ntv_IsBuffer_1 := GetProcOrNil&<function(buffer: gl_buffer): glBool8>(IsBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsBuffer(buffer: gl_buffer): glBool8 :=
      ntv_IsBuffer_1(buffer);
    
    // added in gl1.0
    private IsEnabled_adr := GetProcAddress('glIsEnabled');
    private ntv_IsEnabled_1 := GetProcOrNil&<function(cap: glEnableCap): glBool8>(IsEnabled_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabled(cap: glEnableCap): glBool8 :=
      ntv_IsEnabled_1(cap);
    
    // added in gl3.0
    private IsEnabledi_adr := GetProcAddress('glIsEnabledi');
    private ntv_IsEnabledi_1 := GetProcOrNil&<function(target: glEnableCap; index: UInt32): glBool8>(IsEnabledi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledi(target: glEnableCap; index: UInt32): glBool8 :=
      ntv_IsEnabledi_1(target, index);
    
    // added in gl3.0
    private IsFramebuffer_adr := GetProcAddress('glIsFramebuffer');
    private ntv_IsFramebuffer_1 := GetProcOrNil&<function(framebuffer: gl_framebuffer): glBool8>(IsFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsFramebuffer(framebuffer: gl_framebuffer): glBool8 :=
      ntv_IsFramebuffer_1(framebuffer);
    
    // added in gl2.0
    private IsProgram_adr := GetProcAddress('glIsProgram');
    private ntv_IsProgram_1 := GetProcOrNil&<function(&program: gl_program): glBool8>(IsProgram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsProgram(&program: gl_program): glBool8 :=
      ntv_IsProgram_1(&program);
    
    // added in gl4.1
    private IsProgramPipeline_adr := GetProcAddress('glIsProgramPipeline');
    private ntv_IsProgramPipeline_1 := GetProcOrNil&<function(pipeline: gl_program_pipeline): glBool8>(IsProgramPipeline_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsProgramPipeline(pipeline: gl_program_pipeline): glBool8 :=
      ntv_IsProgramPipeline_1(pipeline);
    
    // added in gl1.5
    private IsQuery_adr := GetProcAddress('glIsQuery');
    private ntv_IsQuery_1 := GetProcOrNil&<function(id: gl_query): glBool8>(IsQuery_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsQuery(id: gl_query): glBool8 :=
      ntv_IsQuery_1(id);
    
    // added in gl3.0
    private IsRenderbuffer_adr := GetProcAddress('glIsRenderbuffer');
    private ntv_IsRenderbuffer_1 := GetProcOrNil&<function(renderbuffer: gl_renderbuffer): glBool8>(IsRenderbuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsRenderbuffer(renderbuffer: gl_renderbuffer): glBool8 :=
      ntv_IsRenderbuffer_1(renderbuffer);
    
    // added in gl3.3
    private IsSampler_adr := GetProcAddress('glIsSampler');
    private ntv_IsSampler_1 := GetProcOrNil&<function(sampler: gl_sampler): glBool8>(IsSampler_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsSampler(sampler: gl_sampler): glBool8 :=
      ntv_IsSampler_1(sampler);
    
    // added in gl2.0
    private IsShader_adr := GetProcAddress('glIsShader');
    private ntv_IsShader_1 := GetProcOrNil&<function(shader: gl_shader): glBool8>(IsShader_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsShader(shader: gl_shader): glBool8 :=
      ntv_IsShader_1(shader);
    
    // added in gl3.2
    private IsSync_adr := GetProcAddress('glIsSync');
    private ntv_IsSync_1 := GetProcOrNil&<function(sync: gl_sync): glBool8>(IsSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsSync(sync: gl_sync): glBool8 :=
      ntv_IsSync_1(sync);
    
    // added in gl1.1
    private IsTexture_adr := GetProcAddress('glIsTexture');
    private ntv_IsTexture_1 := GetProcOrNil&<function(texture: gl_texture): glBool8>(IsTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTexture(texture: gl_texture): glBool8 :=
      ntv_IsTexture_1(texture);
    
    // added in gl4.0
    private IsTransformFeedback_adr := GetProcAddress('glIsTransformFeedback');
    private ntv_IsTransformFeedback_1 := GetProcOrNil&<function(id: gl_transform_feedback): glBool8>(IsTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTransformFeedback(id: gl_transform_feedback): glBool8 :=
      ntv_IsTransformFeedback_1(id);
    
    // added in gl3.0
    private IsVertexArray_adr := GetProcAddress('glIsVertexArray');
    private ntv_IsVertexArray_1 := GetProcOrNil&<function(&array: gl_vertex_array): glBool8>(IsVertexArray_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsVertexArray(&array: gl_vertex_array): glBool8 :=
      ntv_IsVertexArray_1(&array);
    
    // added in gl1.0
    private LineWidth_adr := GetProcAddress('glLineWidth');
    private ntv_LineWidth_1 := GetProcOrNil&<procedure(width: single)>(LineWidth_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LineWidth(width: single) :=
      ntv_LineWidth_1(width);
    
    // added in gl2.0
    private LinkProgram_adr := GetProcAddress('glLinkProgram');
    private ntv_LinkProgram_1 := GetProcOrNil&<procedure(&program: gl_program)>(LinkProgram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LinkProgram(&program: gl_program) :=
      ntv_LinkProgram_1(&program);
    
    // added in gl1.0
    private LogicOp_adr := GetProcAddress('glLogicOp');
    private ntv_LogicOp_1 := GetProcOrNil&<procedure(opcode: glLogicOp)>(LogicOp_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LogicOp(opcode: glLogicOp) :=
      ntv_LogicOp_1(opcode);
    
    // added in gl1.5
    private MapBuffer_adr := GetProcAddress('glMapBuffer');
    private ntv_MapBuffer_1 := GetProcOrNil&<function(target: glBufferTarget; access: glBufferAccess): IntPtr>(MapBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapBuffer(target: glBufferTarget; access: glBufferAccess): IntPtr :=
      ntv_MapBuffer_1(target, access);
    
    // added in gl3.0
    private MapBufferRange_adr := GetProcAddress('glMapBufferRange');
    private ntv_MapBufferRange_1 := GetProcOrNil&<function(target: glBufferTarget; offset: IntPtr; length: UIntPtr; access: glMapBufferAccessMask): IntPtr>(MapBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapBufferRange(target: glBufferTarget; offset: IntPtr; length: UIntPtr; access: glMapBufferAccessMask): IntPtr :=
      ntv_MapBufferRange_1(target, offset, length, access);
    
    // added in gl4.5
    private MapNamedBuffer_adr := GetProcAddress('glMapNamedBuffer');
    private ntv_MapNamedBuffer_1 := GetProcOrNil&<function(buffer: gl_buffer; access: glBufferAccess): IntPtr>(MapNamedBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapNamedBuffer(buffer: gl_buffer; access: glBufferAccess): IntPtr :=
      ntv_MapNamedBuffer_1(buffer, access);
    
    // added in gl4.5
    private MapNamedBufferRange_adr := GetProcAddress('glMapNamedBufferRange');
    private ntv_MapNamedBufferRange_1 := GetProcOrNil&<function(buffer: gl_buffer; offset: IntPtr; length: UIntPtr; access: glMapBufferAccessMask): IntPtr>(MapNamedBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapNamedBufferRange(buffer: gl_buffer; offset: IntPtr; length: UIntPtr; access: glMapBufferAccessMask): IntPtr :=
      ntv_MapNamedBufferRange_1(buffer, offset, length, access);
    
    // added in gl4.2
    private MemoryBarrier_adr := GetProcAddress('glMemoryBarrier');
    private ntv_MemoryBarrier_1 := GetProcOrNil&<procedure(barriers: glMemoryBarrierMask)>(MemoryBarrier_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryBarrier(barriers: glMemoryBarrierMask) :=
      ntv_MemoryBarrier_1(barriers);
    
    // added in gl4.5
    private MemoryBarrierByRegion_adr := GetProcAddress('glMemoryBarrierByRegion');
    private ntv_MemoryBarrierByRegion_1 := GetProcOrNil&<procedure(barriers: glMemoryBarrierMask)>(MemoryBarrierByRegion_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryBarrierByRegion(barriers: glMemoryBarrierMask) :=
      ntv_MemoryBarrierByRegion_1(barriers);
    
    // added in gl4.0
    private MinSampleShading_adr := GetProcAddress('glMinSampleShading');
    private ntv_MinSampleShading_1 := GetProcOrNil&<procedure(value: single)>(MinSampleShading_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MinSampleShading(value: single) :=
      ntv_MinSampleShading_1(value);
    
    // added in gl1.4
    private MultiDrawArrays_adr := GetProcAddress('glMultiDrawArrays');
    private ntv_MultiDrawArrays_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; var first: Int32; var count: Int32; drawcount: Int32)>(MultiDrawArrays_adr);
    private ntv_MultiDrawArrays_2 := GetProcOrNil&<procedure(mode: glPrimitiveType; var first: Int32; count: IntPtr; drawcount: Int32)>(MultiDrawArrays_adr);
    private ntv_MultiDrawArrays_3 := GetProcOrNil&<procedure(mode: glPrimitiveType; first: IntPtr; var count: Int32; drawcount: Int32)>(MultiDrawArrays_adr);
    private ntv_MultiDrawArrays_4 := GetProcOrNil&<procedure(mode: glPrimitiveType; first: IntPtr; count: IntPtr; drawcount: Int32)>(MultiDrawArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArrays(mode: glPrimitiveType; first: array of Int32; count: array of Int32; drawcount: Int32);
    type PInt32 = ^Int32;
    begin
      if (first<>nil) and (first.Length<>0) then
        if (count<>nil) and (count.Length<>0) then
          ntv_MultiDrawArrays_1(mode, first[0], count[0], drawcount) else
          ntv_MultiDrawArrays_1(mode, first[0], PInt32(nil)^, drawcount) else
        if (count<>nil) and (count.Length<>0) then
          ntv_MultiDrawArrays_1(mode, PInt32(nil)^, count[0], drawcount) else
          ntv_MultiDrawArrays_1(mode, PInt32(nil)^, PInt32(nil)^, drawcount);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArrays(mode: glPrimitiveType; var first: Int32; var count: Int32; drawcount: Int32) :=
      ntv_MultiDrawArrays_1(mode, first, count, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArrays(mode: glPrimitiveType; var first: Int32; count: IntPtr; drawcount: Int32) :=
      ntv_MultiDrawArrays_2(mode, first, count, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArrays(mode: glPrimitiveType; first: IntPtr; var count: Int32; drawcount: Int32) :=
      ntv_MultiDrawArrays_3(mode, first, count, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArrays(mode: glPrimitiveType; first: IntPtr; count: IntPtr; drawcount: Int32) :=
      ntv_MultiDrawArrays_4(mode, first, count, drawcount);
    
    // added in gl4.3
    private MultiDrawArraysIndirect_adr := GetProcAddress('glMultiDrawArraysIndirect');
    private ntv_MultiDrawArraysIndirect_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; indirect: IntPtr; drawcount: Int32; stride: Int32)>(MultiDrawArraysIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirect(mode: glPrimitiveType; indirect: IntPtr; drawcount: Int32; stride: Int32) :=
      ntv_MultiDrawArraysIndirect_1(mode, indirect, drawcount, stride);
    
    // added in gl4.6
    private MultiDrawArraysIndirectCount_adr := GetProcAddress('glMultiDrawArraysIndirectCount');
    private ntv_MultiDrawArraysIndirectCount_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32)>(MultiDrawArraysIndirectCount_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectCount(mode: glPrimitiveType; indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) :=
      ntv_MultiDrawArraysIndirectCount_1(mode, indirect, drawcount, maxdrawcount, stride);
    
    // added in gl1.4
    private MultiDrawElements_adr := GetProcAddress('glMultiDrawElements');
    private ntv_MultiDrawElements_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32)>(MultiDrawElements_adr);
    private ntv_MultiDrawElements_2 := GetProcOrNil&<procedure(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; indices: pointer; drawcount: Int32)>(MultiDrawElements_adr);
    private ntv_MultiDrawElements_3 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32)>(MultiDrawElements_adr);
    private ntv_MultiDrawElements_4 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; indices: pointer; drawcount: Int32)>(MultiDrawElements_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: glPrimitiveType; count: array of Int32; &type: glDrawElementsType; indices: array of IntPtr; drawcount: Int32);
    type PInt32 = ^Int32;
    type PIntPtr = ^IntPtr;
    begin
      if (count<>nil) and (count.Length<>0) then
        if (indices<>nil) and (indices.Length<>0) then
          ntv_MultiDrawElements_1(mode, count[0], &type, indices[0], drawcount) else
          ntv_MultiDrawElements_1(mode, count[0], &type, PIntPtr(nil)^, drawcount) else
        if (indices<>nil) and (indices.Length<>0) then
          ntv_MultiDrawElements_1(mode, PInt32(nil)^, &type, indices[0], drawcount) else
          ntv_MultiDrawElements_1(mode, PInt32(nil)^, &type, PIntPtr(nil)^, drawcount);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32) :=
      ntv_MultiDrawElements_1(mode, count, &type, indices, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; indices: pointer; drawcount: Int32) :=
      ntv_MultiDrawElements_2(mode, count, &type, indices, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32) :=
      ntv_MultiDrawElements_3(mode, count, &type, indices, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; indices: pointer; drawcount: Int32) :=
      ntv_MultiDrawElements_4(mode, count, &type, indices, drawcount);
    
    // added in gl3.2
    private MultiDrawElementsBaseVertex_adr := GetProcAddress('glMultiDrawElementsBaseVertex');
    private ntv_MultiDrawElementsBaseVertex_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32)>(MultiDrawElementsBaseVertex_adr);
    private ntv_MultiDrawElementsBaseVertex_2 := GetProcOrNil&<procedure(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32; basevertex: IntPtr)>(MultiDrawElementsBaseVertex_adr);
    private ntv_MultiDrawElementsBaseVertex_3 := GetProcOrNil&<procedure(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; indices: pointer; drawcount: Int32; var basevertex: Int32)>(MultiDrawElementsBaseVertex_adr);
    private ntv_MultiDrawElementsBaseVertex_4 := GetProcOrNil&<procedure(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; indices: pointer; drawcount: Int32; basevertex: IntPtr)>(MultiDrawElementsBaseVertex_adr);
    private ntv_MultiDrawElementsBaseVertex_5 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32)>(MultiDrawElementsBaseVertex_adr);
    private ntv_MultiDrawElementsBaseVertex_6 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32; basevertex: IntPtr)>(MultiDrawElementsBaseVertex_adr);
    private ntv_MultiDrawElementsBaseVertex_7 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; indices: pointer; drawcount: Int32; var basevertex: Int32)>(MultiDrawElementsBaseVertex_adr);
    private ntv_MultiDrawElementsBaseVertex_8 := GetProcOrNil&<procedure(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; indices: pointer; drawcount: Int32; basevertex: IntPtr)>(MultiDrawElementsBaseVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; count: array of Int32; &type: glDrawElementsType; indices: array of IntPtr; drawcount: Int32; basevertex: array of Int32);
    type PInt32 = ^Int32;
    type PIntPtr = ^IntPtr;
    begin
      if (basevertex<>nil) and (basevertex.Length<>0) then
        if (count<>nil) and (count.Length<>0) then
          if (indices<>nil) and (indices.Length<>0) then
            ntv_MultiDrawElementsBaseVertex_1(mode, count[0], &type, indices[0], drawcount, basevertex[0]) else
            ntv_MultiDrawElementsBaseVertex_1(mode, count[0], &type, PIntPtr(nil)^, drawcount, basevertex[0]) else
          if (indices<>nil) and (indices.Length<>0) then
            ntv_MultiDrawElementsBaseVertex_1(mode, PInt32(nil)^, &type, indices[0], drawcount, basevertex[0]) else
            ntv_MultiDrawElementsBaseVertex_1(mode, PInt32(nil)^, &type, PIntPtr(nil)^, drawcount, basevertex[0]) else
        if (count<>nil) and (count.Length<>0) then
          if (indices<>nil) and (indices.Length<>0) then
            ntv_MultiDrawElementsBaseVertex_1(mode, count[0], &type, indices[0], drawcount, PInt32(nil)^) else
            ntv_MultiDrawElementsBaseVertex_1(mode, count[0], &type, PIntPtr(nil)^, drawcount, PInt32(nil)^) else
          if (indices<>nil) and (indices.Length<>0) then
            ntv_MultiDrawElementsBaseVertex_1(mode, PInt32(nil)^, &type, indices[0], drawcount, PInt32(nil)^) else
            ntv_MultiDrawElementsBaseVertex_1(mode, PInt32(nil)^, &type, PIntPtr(nil)^, drawcount, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32) :=
      ntv_MultiDrawElementsBaseVertex_1(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32; basevertex: IntPtr) :=
      ntv_MultiDrawElementsBaseVertex_2(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; indices: pointer; drawcount: Int32; var basevertex: Int32) :=
      ntv_MultiDrawElementsBaseVertex_3(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; var count: Int32; &type: glDrawElementsType; indices: pointer; drawcount: Int32; basevertex: IntPtr) :=
      ntv_MultiDrawElementsBaseVertex_4(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32) :=
      ntv_MultiDrawElementsBaseVertex_5(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; var indices: IntPtr; drawcount: Int32; basevertex: IntPtr) :=
      ntv_MultiDrawElementsBaseVertex_6(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; indices: pointer; drawcount: Int32; var basevertex: Int32) :=
      ntv_MultiDrawElementsBaseVertex_7(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: glPrimitiveType; count: IntPtr; &type: glDrawElementsType; indices: pointer; drawcount: Int32; basevertex: IntPtr) :=
      ntv_MultiDrawElementsBaseVertex_8(mode, count, &type, indices, drawcount, basevertex);
    
    // added in gl4.3
    private MultiDrawElementsIndirect_adr := GetProcAddress('glMultiDrawElementsIndirect');
    private ntv_MultiDrawElementsIndirect_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr; drawcount: Int32; stride: Int32)>(MultiDrawElementsIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirect(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr; drawcount: Int32; stride: Int32) :=
      ntv_MultiDrawElementsIndirect_1(mode, &type, indirect, drawcount, stride);
    
    // added in gl4.6
    private MultiDrawElementsIndirectCount_adr := GetProcAddress('glMultiDrawElementsIndirectCount');
    private ntv_MultiDrawElementsIndirectCount_1 := GetProcOrNil&<procedure(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32)>(MultiDrawElementsIndirectCount_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectCount(mode: glPrimitiveType; &type: glDrawElementsType; indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) :=
      ntv_MultiDrawElementsIndirectCount_1(mode, &type, indirect, drawcount, maxdrawcount, stride);
    
    // added in gl3.3
    private MultiTexCoordP1ui_adr := GetProcAddress('glMultiTexCoordP1ui');
    private ntv_MultiTexCoordP1ui_1 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; coords: UInt32)>(MultiTexCoordP1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1ui(texture: glTextureUnit; &type: glTexCoordPointerType; coords: UInt32) :=
      ntv_MultiTexCoordP1ui_1(texture, &type, coords);
    
    // added in gl3.3
    private MultiTexCoordP1uiv_adr := GetProcAddress('glMultiTexCoordP1uiv');
    private ntv_MultiTexCoordP1uiv_1 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; var coords: UInt32)>(MultiTexCoordP1uiv_adr);
    private ntv_MultiTexCoordP1uiv_2 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; coords: IntPtr)>(MultiTexCoordP1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: glTextureUnit; &type: glTexCoordPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_MultiTexCoordP1uiv_1(texture, &type, coords[0]) else
        ntv_MultiTexCoordP1uiv_1(texture, &type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: glTextureUnit; &type: glTexCoordPointerType; var coords: UInt32) :=
      ntv_MultiTexCoordP1uiv_1(texture, &type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: glTextureUnit; &type: glTexCoordPointerType; coords: IntPtr) :=
      ntv_MultiTexCoordP1uiv_2(texture, &type, coords);
    
    // added in gl3.3
    private MultiTexCoordP2ui_adr := GetProcAddress('glMultiTexCoordP2ui');
    private ntv_MultiTexCoordP2ui_1 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; coords: UInt32)>(MultiTexCoordP2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2ui(texture: glTextureUnit; &type: glTexCoordPointerType; coords: UInt32) :=
      ntv_MultiTexCoordP2ui_1(texture, &type, coords);
    
    // added in gl3.3
    private MultiTexCoordP2uiv_adr := GetProcAddress('glMultiTexCoordP2uiv');
    private ntv_MultiTexCoordP2uiv_1 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; var coords: UInt32)>(MultiTexCoordP2uiv_adr);
    private ntv_MultiTexCoordP2uiv_2 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; coords: IntPtr)>(MultiTexCoordP2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: glTextureUnit; &type: glTexCoordPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_MultiTexCoordP2uiv_1(texture, &type, coords[0]) else
        ntv_MultiTexCoordP2uiv_1(texture, &type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: glTextureUnit; &type: glTexCoordPointerType; var coords: UInt32) :=
      ntv_MultiTexCoordP2uiv_1(texture, &type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: glTextureUnit; &type: glTexCoordPointerType; coords: IntPtr) :=
      ntv_MultiTexCoordP2uiv_2(texture, &type, coords);
    
    // added in gl3.3
    private MultiTexCoordP3ui_adr := GetProcAddress('glMultiTexCoordP3ui');
    private ntv_MultiTexCoordP3ui_1 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; coords: UInt32)>(MultiTexCoordP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3ui(texture: glTextureUnit; &type: glTexCoordPointerType; coords: UInt32) :=
      ntv_MultiTexCoordP3ui_1(texture, &type, coords);
    
    // added in gl3.3
    private MultiTexCoordP3uiv_adr := GetProcAddress('glMultiTexCoordP3uiv');
    private ntv_MultiTexCoordP3uiv_1 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; var coords: UInt32)>(MultiTexCoordP3uiv_adr);
    private ntv_MultiTexCoordP3uiv_2 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; coords: IntPtr)>(MultiTexCoordP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: glTextureUnit; &type: glTexCoordPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_MultiTexCoordP3uiv_1(texture, &type, coords[0]) else
        ntv_MultiTexCoordP3uiv_1(texture, &type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: glTextureUnit; &type: glTexCoordPointerType; var coords: UInt32) :=
      ntv_MultiTexCoordP3uiv_1(texture, &type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: glTextureUnit; &type: glTexCoordPointerType; coords: IntPtr) :=
      ntv_MultiTexCoordP3uiv_2(texture, &type, coords);
    
    // added in gl3.3
    private MultiTexCoordP4ui_adr := GetProcAddress('glMultiTexCoordP4ui');
    private ntv_MultiTexCoordP4ui_1 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; coords: UInt32)>(MultiTexCoordP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4ui(texture: glTextureUnit; &type: glTexCoordPointerType; coords: UInt32) :=
      ntv_MultiTexCoordP4ui_1(texture, &type, coords);
    
    // added in gl3.3
    private MultiTexCoordP4uiv_adr := GetProcAddress('glMultiTexCoordP4uiv');
    private ntv_MultiTexCoordP4uiv_1 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; var coords: UInt32)>(MultiTexCoordP4uiv_adr);
    private ntv_MultiTexCoordP4uiv_2 := GetProcOrNil&<procedure(texture: glTextureUnit; &type: glTexCoordPointerType; coords: IntPtr)>(MultiTexCoordP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: glTextureUnit; &type: glTexCoordPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_MultiTexCoordP4uiv_1(texture, &type, coords[0]) else
        ntv_MultiTexCoordP4uiv_1(texture, &type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: glTextureUnit; &type: glTexCoordPointerType; var coords: UInt32) :=
      ntv_MultiTexCoordP4uiv_1(texture, &type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: glTextureUnit; &type: glTexCoordPointerType; coords: IntPtr) :=
      ntv_MultiTexCoordP4uiv_2(texture, &type, coords);
    
    // added in gl4.5
    private NamedBufferData_adr := GetProcAddress('glNamedBufferData');
    private ntv_NamedBufferData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; var data: Byte; usage: glVertexBufferObjectUsage)>(NamedBufferData_adr);
    private ntv_NamedBufferData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; data: IntPtr; usage: glVertexBufferObjectUsage)>(NamedBufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferData<T>(buffer: gl_buffer; size: UIntPtr; data: array of T; usage: glVertexBufferObjectUsage); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferData(buffer, size, data[0], usage) else
        NamedBufferData(buffer, size, PT(nil)^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferData<T>(buffer: gl_buffer; size: UIntPtr; var data: T; usage: glVertexBufferObjectUsage); where T: record;
    begin
      ntv_NamedBufferData_1(buffer, size, PByte(pointer(@data))^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferData(buffer: gl_buffer; size: UIntPtr; data: IntPtr; usage: glVertexBufferObjectUsage) :=
      ntv_NamedBufferData_2(buffer, size, data, usage);
    
    // added in gl4.5
    private NamedBufferStorage_adr := GetProcAddress('glNamedBufferStorage');
    private ntv_NamedBufferStorage_1 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; var data: Byte; flags: glBufferStorageMask)>(NamedBufferStorage_adr);
    private ntv_NamedBufferStorage_2 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; data: IntPtr; flags: glBufferStorageMask)>(NamedBufferStorage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorage<T>(buffer: gl_buffer; size: UIntPtr; data: array of T; flags: glBufferStorageMask); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferStorage(buffer, size, data[0], flags) else
        NamedBufferStorage(buffer, size, PT(nil)^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorage<T>(buffer: gl_buffer; size: UIntPtr; var data: T; flags: glBufferStorageMask); where T: record;
    begin
      ntv_NamedBufferStorage_1(buffer, size, PByte(pointer(@data))^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorage(buffer: gl_buffer; size: UIntPtr; data: IntPtr; flags: glBufferStorageMask) :=
      ntv_NamedBufferStorage_2(buffer, size, data, flags);
    
    // added in gl4.5
    private NamedBufferSubData_adr := GetProcAddress('glNamedBufferSubData');
    private ntv_NamedBufferSubData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: Byte)>(NamedBufferSubData_adr);
    private ntv_NamedBufferSubData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: IntPtr)>(NamedBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubData<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: array of T); where T: record;
    type PT = ^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferSubData(buffer, offset, size, data[0]) else
        NamedBufferSubData(buffer, offset, size, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubData<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      ntv_NamedBufferSubData_1(buffer, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubData(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: IntPtr) :=
      ntv_NamedBufferSubData_2(buffer, offset, size, data);
    
    // added in gl4.5
    private NamedFramebufferDrawBuffer_adr := GetProcAddress('glNamedFramebufferDrawBuffer');
    private ntv_NamedFramebufferDrawBuffer_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buf: glColorBuffer)>(NamedFramebufferDrawBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffer(framebuffer: gl_framebuffer; buf: glColorBuffer) :=
      ntv_NamedFramebufferDrawBuffer_1(framebuffer, buf);
    
    // added in gl4.5
    private NamedFramebufferDrawBuffers_adr := GetProcAddress('glNamedFramebufferDrawBuffers');
    private ntv_NamedFramebufferDrawBuffers_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; n: Int32; var bufs: glColorBuffer)>(NamedFramebufferDrawBuffers_adr);
    private ntv_NamedFramebufferDrawBuffers_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; n: Int32; bufs: IntPtr)>(NamedFramebufferDrawBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffers(framebuffer: gl_framebuffer; n: Int32; bufs: array of glColorBuffer);
    type PGlColorBuffer = ^glColorBuffer;
    begin
      if (bufs<>nil) and (bufs.Length<>0) then
        ntv_NamedFramebufferDrawBuffers_1(framebuffer, n, bufs[0]) else
        ntv_NamedFramebufferDrawBuffers_1(framebuffer, n, PGlColorBuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffers(framebuffer: gl_framebuffer; n: Int32; var bufs: glColorBuffer) :=
      ntv_NamedFramebufferDrawBuffers_1(framebuffer, n, bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffers(framebuffer: gl_framebuffer; n: Int32; bufs: IntPtr) :=
      ntv_NamedFramebufferDrawBuffers_2(framebuffer, n, bufs);
    
    // added in gl4.5
    private NamedFramebufferParameteri_adr := GetProcAddress('glNamedFramebufferParameteri');
    private ntv_NamedFramebufferParameteri_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: glFramebufferParameterName; param: Int32)>(NamedFramebufferParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferParameteri(framebuffer: gl_framebuffer; pname: glFramebufferParameterName; param: Int32) :=
      ntv_NamedFramebufferParameteri_1(framebuffer, pname, param);
    
    // added in gl4.5
    private NamedFramebufferReadBuffer_adr := GetProcAddress('glNamedFramebufferReadBuffer');
    private ntv_NamedFramebufferReadBuffer_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; src: glColorBuffer)>(NamedFramebufferReadBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferReadBuffer(framebuffer: gl_framebuffer; src: glColorBuffer) :=
      ntv_NamedFramebufferReadBuffer_1(framebuffer, src);
    
    // added in gl4.5
    private NamedFramebufferRenderbuffer_adr := GetProcAddress('glNamedFramebufferRenderbuffer');
    private ntv_NamedFramebufferRenderbuffer_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; renderbuffertarget: glRenderbufferTarget; renderbuffer: gl_renderbuffer)>(NamedFramebufferRenderbuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferRenderbuffer(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; renderbuffertarget: glRenderbufferTarget; renderbuffer: gl_renderbuffer) :=
      ntv_NamedFramebufferRenderbuffer_1(framebuffer, attachment, renderbuffertarget, renderbuffer);
    
    // added in gl4.5
    private NamedFramebufferTexture_adr := GetProcAddress('glNamedFramebufferTexture');
    private ntv_NamedFramebufferTexture_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32)>(NamedFramebufferTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTexture(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32) :=
      ntv_NamedFramebufferTexture_1(framebuffer, attachment, texture, level);
    
    // added in gl4.5
    private NamedFramebufferTextureLayer_adr := GetProcAddress('glNamedFramebufferTextureLayer');
    private ntv_NamedFramebufferTextureLayer_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32)>(NamedFramebufferTextureLayer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTextureLayer(framebuffer: gl_framebuffer; attachment: glFramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32) :=
      ntv_NamedFramebufferTextureLayer_1(framebuffer, attachment, texture, level, layer);
    
    // added in gl4.5
    private NamedRenderbufferStorage_adr := GetProcAddress('glNamedRenderbufferStorage');
    private ntv_NamedRenderbufferStorage_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; internalformat: glInternalFormat; width: Int32; height: Int32)>(NamedRenderbufferStorage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorage(renderbuffer: gl_renderbuffer; internalformat: glInternalFormat; width: Int32; height: Int32) :=
      ntv_NamedRenderbufferStorage_1(renderbuffer, internalformat, width, height);
    
    // added in gl4.5
    private NamedRenderbufferStorageMultisample_adr := GetProcAddress('glNamedRenderbufferStorageMultisample');
    private ntv_NamedRenderbufferStorageMultisample_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32)>(NamedRenderbufferStorageMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageMultisample(renderbuffer: gl_renderbuffer; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32) :=
      ntv_NamedRenderbufferStorageMultisample_1(renderbuffer, samples, internalformat, width, height);
    
    // added in gl3.3
    private NormalP3ui_adr := GetProcAddress('glNormalP3ui');
    private ntv_NormalP3ui_1 := GetProcOrNil&<procedure(&type: glNormalPointerType; coords: UInt32)>(NormalP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3ui(&type: glNormalPointerType; coords: UInt32) :=
      ntv_NormalP3ui_1(&type, coords);
    
    // added in gl3.3
    private NormalP3uiv_adr := GetProcAddress('glNormalP3uiv');
    private ntv_NormalP3uiv_1 := GetProcOrNil&<procedure(&type: glNormalPointerType; var coords: UInt32)>(NormalP3uiv_adr);
    private ntv_NormalP3uiv_2 := GetProcOrNil&<procedure(&type: glNormalPointerType; coords: IntPtr)>(NormalP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: glNormalPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_NormalP3uiv_1(&type, coords[0]) else
        ntv_NormalP3uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: glNormalPointerType; var coords: UInt32) :=
      ntv_NormalP3uiv_1(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: glNormalPointerType; coords: IntPtr) :=
      ntv_NormalP3uiv_2(&type, coords);
    
    // added in gl4.3
    private ObjectLabel_adr := GetProcAddress('glObjectLabel');
    private ntv_ObjectLabel_1 := GetProcOrNil&<procedure(identifier: glObjectIdentifier; name: UInt32; length: Int32; &label: IntPtr)>(ObjectLabel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectLabel(identifier: glObjectIdentifier; name: UInt32; length: Int32; &label: string);
    begin
      var &label_str_ptr := Marshal.StringToHGlobalAnsi(&label);
      try
        ntv_ObjectLabel_1(identifier, name, length, &label_str_ptr);
      finally
        Marshal.FreeHGlobal(&label_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectLabel(identifier: glObjectIdentifier; name: UInt32; length: Int32; &label: IntPtr) :=
      ntv_ObjectLabel_1(identifier, name, length, &label);
    
    // added in gl4.3
    private ObjectPtrLabel_adr := GetProcAddress('glObjectPtrLabel');
    private ntv_ObjectPtrLabel_1 := GetProcOrNil&<procedure(ptr: IntPtr; length: Int32; &label: IntPtr)>(ObjectPtrLabel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabel(ptr: IntPtr; length: Int32; &label: string);
    begin
      var &label_str_ptr := Marshal.StringToHGlobalAnsi(&label);
      try
        ntv_ObjectPtrLabel_1(ptr, length, &label_str_ptr);
      finally
        Marshal.FreeHGlobal(&label_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabel(ptr: IntPtr; length: Int32; &label: IntPtr) :=
      ntv_ObjectPtrLabel_1(ptr, length, &label);
    
    // added in gl4.0
    private PatchParameterfv_adr := GetProcAddress('glPatchParameterfv');
    private ntv_PatchParameterfv_1 := GetProcOrNil&<procedure(pname: glPatchParameterName; var values: single)>(PatchParameterfv_adr);
    private ntv_PatchParameterfv_2 := GetProcOrNil&<procedure(pname: glPatchParameterName; values: IntPtr)>(PatchParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameterfv(pname: glPatchParameterName; values: array of single);
    type PSingle = ^single;
    begin
      if (values<>nil) and (values.Length<>0) then
        ntv_PatchParameterfv_1(pname, values[0]) else
        ntv_PatchParameterfv_1(pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameterfv(pname: glPatchParameterName; var values: single) :=
      ntv_PatchParameterfv_1(pname, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameterfv(pname: glPatchParameterName; values: IntPtr) :=
      ntv_PatchParameterfv_2(pname, values);
    
    // added in gl4.0
    private PatchParameteri_adr := GetProcAddress('glPatchParameteri');
    private ntv_PatchParameteri_1 := GetProcOrNil&<procedure(pname: glPatchParameterName; value: Int32)>(PatchParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameteri(pname: glPatchParameterName; value: Int32) :=
      ntv_PatchParameteri_1(pname, value);
    
    // added in gl4.0
    private PauseTransformFeedback_adr := GetProcAddress('glPauseTransformFeedback');
    private ntv_PauseTransformFeedback_1 := GetProcOrNil&<procedure>(PauseTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PauseTransformFeedback :=
      ntv_PauseTransformFeedback_1;
    
    // added in gl1.0
    private PixelStoref_adr := GetProcAddress('glPixelStoref');
    private ntv_PixelStoref_1 := GetProcOrNil&<procedure(pname: glPixelStoreParameter; param: single)>(PixelStoref_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelStoref(pname: glPixelStoreParameter; param: single) :=
      ntv_PixelStoref_1(pname, param);
    
    // added in gl1.0
    private PixelStorei_adr := GetProcAddress('glPixelStorei');
    private ntv_PixelStorei_1 := GetProcOrNil&<procedure(pname: glPixelStoreParameter; param: glPixelStoreResampleMode)>(PixelStorei_adr);
    private ntv_PixelStorei_2 := GetProcOrNil&<procedure(pname: glPixelStoreParameter; param: glPixelStoreSubsampleRate)>(PixelStorei_adr);
    private ntv_PixelStorei_3 := GetProcOrNil&<procedure(pname: glPixelStoreParameter; param: Int32)>(PixelStorei_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelStorei(pname: glPixelStoreParameter; param: glPixelStoreResampleMode) :=
      ntv_PixelStorei_1(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelStorei(pname: glPixelStoreParameter; param: glPixelStoreSubsampleRate) :=
      ntv_PixelStorei_2(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelStorei(pname: glPixelStoreParameter; param: Int32) :=
      ntv_PixelStorei_3(pname, param);
    
    // added in gl1.4
    private PointParameterf_adr := GetProcAddress('glPointParameterf');
    private ntv_PointParameterf_1 := GetProcOrNil&<procedure(pname: glPointParameterName; param: single)>(PointParameterf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterf(pname: glPointParameterName; param: single) :=
      ntv_PointParameterf_1(pname, param);
    
    // added in gl1.4
    private PointParameterfv_adr := GetProcAddress('glPointParameterfv');
    private ntv_PointParameterfv_1 := GetProcOrNil&<procedure(pname: glPointParameterName; var &params: single)>(PointParameterfv_adr);
    private ntv_PointParameterfv_2 := GetProcOrNil&<procedure(pname: glPointParameterName; &params: IntPtr)>(PointParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfv(pname: glPointParameterName; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_PointParameterfv_1(pname, &params[0]) else
        ntv_PointParameterfv_1(pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfv(pname: glPointParameterName; var &params: single) :=
      ntv_PointParameterfv_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfv(pname: glPointParameterName; &params: IntPtr) :=
      ntv_PointParameterfv_2(pname, &params);
    
    // added in gl1.4
    private PointParameteri_adr := GetProcAddress('glPointParameteri');
    private ntv_PointParameteri_1 := GetProcOrNil&<procedure(pname: glPointParameterName; param: Int32)>(PointParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameteri(pname: glPointParameterName; param: Int32) :=
      ntv_PointParameteri_1(pname, param);
    
    // added in gl1.4
    private PointParameteriv_adr := GetProcAddress('glPointParameteriv');
    private ntv_PointParameteriv_1 := GetProcOrNil&<procedure(pname: glPointParameterName; var &params: Int32)>(PointParameteriv_adr);
    private ntv_PointParameteriv_2 := GetProcOrNil&<procedure(pname: glPointParameterName; &params: IntPtr)>(PointParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameteriv(pname: glPointParameterName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_PointParameteriv_1(pname, &params[0]) else
        ntv_PointParameteriv_1(pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameteriv(pname: glPointParameterName; var &params: Int32) :=
      ntv_PointParameteriv_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameteriv(pname: glPointParameterName; &params: IntPtr) :=
      ntv_PointParameteriv_2(pname, &params);
    
    // added in gl1.0
    private PointSize_adr := GetProcAddress('glPointSize');
    private ntv_PointSize_1 := GetProcOrNil&<procedure(size: single)>(PointSize_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointSize(size: single) :=
      ntv_PointSize_1(size);
    
    // added in gl1.0
    private PolygonMode_adr := GetProcAddress('glPolygonMode');
    private ntv_PolygonMode_1 := GetProcOrNil&<procedure(face: glTriangleFace; mode: glPolygonMode)>(PolygonMode_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonMode(face: glTriangleFace; mode: glPolygonMode) :=
      ntv_PolygonMode_1(face, mode);
    
    // added in gl1.1
    private PolygonOffset_adr := GetProcAddress('glPolygonOffset');
    private ntv_PolygonOffset_1 := GetProcOrNil&<procedure(factor: single; units: single)>(PolygonOffset_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffset(factor: single; units: single) :=
      ntv_PolygonOffset_1(factor, units);
    
    // added in gl4.6
    private PolygonOffsetClamp_adr := GetProcAddress('glPolygonOffsetClamp');
    private ntv_PolygonOffsetClamp_1 := GetProcOrNil&<procedure(factor: single; units: single; clamp: single)>(PolygonOffsetClamp_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffsetClamp(factor: single; units: single; clamp: single) :=
      ntv_PolygonOffsetClamp_1(factor, units, clamp);
    
    // added in gl4.3
    private PopDebugGroup_adr := GetProcAddress('glPopDebugGroup');
    private ntv_PopDebugGroup_1 := GetProcOrNil&<procedure>(PopDebugGroup_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopDebugGroup :=
      ntv_PopDebugGroup_1;
    
    // added in gl3.1
    private PrimitiveRestartIndex_adr := GetProcAddress('glPrimitiveRestartIndex');
    private ntv_PrimitiveRestartIndex_1 := GetProcOrNil&<procedure(index: UInt32)>(PrimitiveRestartIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrimitiveRestartIndex(index: UInt32) :=
      ntv_PrimitiveRestartIndex_1(index);
    
    // added in gl4.1
    private ProgramBinary_adr := GetProcAddress('glProgramBinary');
    private ntv_ProgramBinary_1 := GetProcOrNil&<procedure(&program: gl_program; binaryFormat: DummyEnum; binary: IntPtr; length: Int32)>(ProgramBinary_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBinary(&program: gl_program; binaryFormat: DummyEnum; binary: IntPtr; length: Int32) :=
      ntv_ProgramBinary_1(&program, binaryFormat, binary, length);
    
    // added in gl4.1
    private ProgramParameteri_adr := GetProcAddress('glProgramParameteri');
    private ntv_ProgramParameteri_1 := GetProcOrNil&<procedure(&program: gl_program; pname: glProgramParameterPName; value: Int32)>(ProgramParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameteri(&program: gl_program; pname: glProgramParameterPName; value: Int32) :=
      ntv_ProgramParameteri_1(&program, pname, value);
    
    // added in gl4.1
    private ProgramUniform1d_adr := GetProcAddress('glProgramUniform1d');
    private ntv_ProgramUniform1d_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: double)>(ProgramUniform1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1d(&program: gl_program; location: Int32; v0: double) :=
      ntv_ProgramUniform1d_1(&program, location, v0);
    
    // added in gl4.1
    private ProgramUniform1dv_adr := GetProcAddress('glProgramUniform1dv');
    private ntv_ProgramUniform1dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: double)>(ProgramUniform1dv_adr);
    private ntv_ProgramUniform1dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dv(&program: gl_program; location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1dv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1dv_1(&program, location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dv(&program: gl_program; location: Int32; count: Int32; var value: double) :=
      ntv_ProgramUniform1dv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1dv_2(&program, location, count, value);
    
    // added in gl4.1
    private ProgramUniform1f_adr := GetProcAddress('glProgramUniform1f');
    private ntv_ProgramUniform1f_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single)>(ProgramUniform1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1f(&program: gl_program; location: Int32; v0: single) :=
      ntv_ProgramUniform1f_1(&program, location, v0);
    
    // added in gl4.1
    private ProgramUniform1fv_adr := GetProcAddress('glProgramUniform1fv');
    private ntv_ProgramUniform1fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(ProgramUniform1fv_adr);
    private ntv_ProgramUniform1fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fv(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1fv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1fv_1(&program, location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fv(&program: gl_program; location: Int32; count: Int32; var value: single) :=
      ntv_ProgramUniform1fv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1fv_2(&program, location, count, value);
    
    // added in gl4.1
    private ProgramUniform1i_adr := GetProcAddress('glProgramUniform1i');
    private ntv_ProgramUniform1i_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32)>(ProgramUniform1i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i(&program: gl_program; location: Int32; v0: Int32) :=
      ntv_ProgramUniform1i_1(&program, location, v0);
    
    // added in gl4.1
    private ProgramUniform1iv_adr := GetProcAddress('glProgramUniform1iv');
    private ntv_ProgramUniform1iv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(ProgramUniform1iv_adr);
    private ntv_ProgramUniform1iv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iv(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1iv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1iv_1(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iv(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
      ntv_ProgramUniform1iv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1iv_2(&program, location, count, value);
    
    // added in gl4.1
    private ProgramUniform1ui_adr := GetProcAddress('glProgramUniform1ui');
    private ntv_ProgramUniform1ui_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32)>(ProgramUniform1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui(&program: gl_program; location: Int32; v0: UInt32) :=
      ntv_ProgramUniform1ui_1(&program, location, v0);
    
    // added in gl4.1
    private ProgramUniform1uiv_adr := GetProcAddress('glProgramUniform1uiv');
    private ntv_ProgramUniform1uiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(ProgramUniform1uiv_adr);
    private ntv_ProgramUniform1uiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiv(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform1uiv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform1uiv_1(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiv(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
      ntv_ProgramUniform1uiv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform1uiv_2(&program, location, count, value);
    
    // added in gl4.1
    private ProgramUniform2d_adr := GetProcAddress('glProgramUniform2d');
    private ntv_ProgramUniform2d_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: double; v1: double)>(ProgramUniform2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2d(&program: gl_program; location: Int32; v0: double; v1: double) :=
      ntv_ProgramUniform2d_1(&program, location, v0, v1);
    
    // added in gl4.1
    private ProgramUniform2dv_adr := GetProcAddress('glProgramUniform2dv');
    private ntv_ProgramUniform2dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: double)>(ProgramUniform2dv_adr);
    private ntv_ProgramUniform2dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2d)>(ProgramUniform2dv_adr);
    private ntv_ProgramUniform2dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: gl_program; location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2dv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2dv_1(&program, location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: gl_program; location: Int32; count: Int32; var value: Vec2d) :=
      ntv_ProgramUniform2dv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: gl_program; location: Int32; count: Int32; var value: double) :=
      ntv_ProgramUniform2dv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2dv_3(&program, location, count, value);
    
    // added in gl4.1
    private ProgramUniform2f_adr := GetProcAddress('glProgramUniform2f');
    private ntv_ProgramUniform2f_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single)>(ProgramUniform2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2f(&program: gl_program; location: Int32; v0: single; v1: single) :=
      ntv_ProgramUniform2f_1(&program, location, v0, v1);
    
    // added in gl4.1
    private ProgramUniform2fv_adr := GetProcAddress('glProgramUniform2fv');
    private ntv_ProgramUniform2fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(ProgramUniform2fv_adr);
    private ntv_ProgramUniform2fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2f)>(ProgramUniform2fv_adr);
    private ntv_ProgramUniform2fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2fv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2fv_1(&program, location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: gl_program; location: Int32; count: Int32; var value: Vec2f) :=
      ntv_ProgramUniform2fv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: gl_program; location: Int32; count: Int32; var value: single) :=
      ntv_ProgramUniform2fv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2fv_3(&program, location, count, value);
    
    // added in gl4.1
    private ProgramUniform2i_adr := GetProcAddress('glProgramUniform2i');
    private ntv_ProgramUniform2i_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32)>(ProgramUniform2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i(&program: gl_program; location: Int32; v0: Int32; v1: Int32) :=
      ntv_ProgramUniform2i_1(&program, location, v0, v1);
    
    // added in gl4.1
    private ProgramUniform2iv_adr := GetProcAddress('glProgramUniform2iv');
    private ntv_ProgramUniform2iv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(ProgramUniform2iv_adr);
    private ntv_ProgramUniform2iv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2i)>(ProgramUniform2iv_adr);
    private ntv_ProgramUniform2iv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2iv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2iv_1(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: gl_program; location: Int32; count: Int32; var value: Vec2i) :=
      ntv_ProgramUniform2iv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
      ntv_ProgramUniform2iv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2iv_3(&program, location, count, value);
    
    // added in gl4.1
    private ProgramUniform2ui_adr := GetProcAddress('glProgramUniform2ui');
    private ntv_ProgramUniform2ui_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32)>(ProgramUniform2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32) :=
      ntv_ProgramUniform2ui_1(&program, location, v0, v1);
    
    // added in gl4.1
    private ProgramUniform2uiv_adr := GetProcAddress('glProgramUniform2uiv');
    private ntv_ProgramUniform2uiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(ProgramUniform2uiv_adr);
    private ntv_ProgramUniform2uiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec2ui)>(ProgramUniform2uiv_adr);
    private ntv_ProgramUniform2uiv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform2uiv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform2uiv_1(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: gl_program; location: Int32; count: Int32; var value: Vec2ui) :=
      ntv_ProgramUniform2uiv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
      ntv_ProgramUniform2uiv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform2uiv_3(&program, location, count, value);
    
    // added in gl4.1
    private ProgramUniform3d_adr := GetProcAddress('glProgramUniform3d');
    private ntv_ProgramUniform3d_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: double; v1: double; v2: double)>(ProgramUniform3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3d(&program: gl_program; location: Int32; v0: double; v1: double; v2: double) :=
      ntv_ProgramUniform3d_1(&program, location, v0, v1, v2);
    
    // added in gl4.1
    private ProgramUniform3dv_adr := GetProcAddress('glProgramUniform3dv');
    private ntv_ProgramUniform3dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: double)>(ProgramUniform3dv_adr);
    private ntv_ProgramUniform3dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3d)>(ProgramUniform3dv_adr);
    private ntv_ProgramUniform3dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: gl_program; location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3dv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3dv_1(&program, location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: gl_program; location: Int32; count: Int32; var value: Vec3d) :=
      ntv_ProgramUniform3dv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: gl_program; location: Int32; count: Int32; var value: double) :=
      ntv_ProgramUniform3dv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3dv_3(&program, location, count, value);
    
    // added in gl4.1
    private ProgramUniform3f_adr := GetProcAddress('glProgramUniform3f');
    private ntv_ProgramUniform3f_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single; v2: single)>(ProgramUniform3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3f(&program: gl_program; location: Int32; v0: single; v1: single; v2: single) :=
      ntv_ProgramUniform3f_1(&program, location, v0, v1, v2);
    
    // added in gl4.1
    private ProgramUniform3fv_adr := GetProcAddress('glProgramUniform3fv');
    private ntv_ProgramUniform3fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(ProgramUniform3fv_adr);
    private ntv_ProgramUniform3fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3f)>(ProgramUniform3fv_adr);
    private ntv_ProgramUniform3fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3fv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3fv_1(&program, location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: gl_program; location: Int32; count: Int32; var value: Vec3f) :=
      ntv_ProgramUniform3fv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: gl_program; location: Int32; count: Int32; var value: single) :=
      ntv_ProgramUniform3fv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3fv_3(&program, location, count, value);
    
    // added in gl4.1
    private ProgramUniform3i_adr := GetProcAddress('glProgramUniform3i');
    private ntv_ProgramUniform3i_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32)>(ProgramUniform3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32) :=
      ntv_ProgramUniform3i_1(&program, location, v0, v1, v2);
    
    // added in gl4.1
    private ProgramUniform3iv_adr := GetProcAddress('glProgramUniform3iv');
    private ntv_ProgramUniform3iv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(ProgramUniform3iv_adr);
    private ntv_ProgramUniform3iv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3i)>(ProgramUniform3iv_adr);
    private ntv_ProgramUniform3iv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3iv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3iv_1(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: gl_program; location: Int32; count: Int32; var value: Vec3i) :=
      ntv_ProgramUniform3iv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
      ntv_ProgramUniform3iv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3iv_3(&program, location, count, value);
    
    // added in gl4.1
    private ProgramUniform3ui_adr := GetProcAddress('glProgramUniform3ui');
    private ntv_ProgramUniform3ui_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32)>(ProgramUniform3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32) :=
      ntv_ProgramUniform3ui_1(&program, location, v0, v1, v2);
    
    // added in gl4.1
    private ProgramUniform3uiv_adr := GetProcAddress('glProgramUniform3uiv');
    private ntv_ProgramUniform3uiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(ProgramUniform3uiv_adr);
    private ntv_ProgramUniform3uiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec3ui)>(ProgramUniform3uiv_adr);
    private ntv_ProgramUniform3uiv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform3uiv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform3uiv_1(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: gl_program; location: Int32; count: Int32; var value: Vec3ui) :=
      ntv_ProgramUniform3uiv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
      ntv_ProgramUniform3uiv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform3uiv_3(&program, location, count, value);
    
    // added in gl4.1
    private ProgramUniform4d_adr := GetProcAddress('glProgramUniform4d');
    private ntv_ProgramUniform4d_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: double; v1: double; v2: double; v3: double)>(ProgramUniform4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4d(&program: gl_program; location: Int32; v0: double; v1: double; v2: double; v3: double) :=
      ntv_ProgramUniform4d_1(&program, location, v0, v1, v2, v3);
    
    // added in gl4.1
    private ProgramUniform4dv_adr := GetProcAddress('glProgramUniform4dv');
    private ntv_ProgramUniform4dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: double)>(ProgramUniform4dv_adr);
    private ntv_ProgramUniform4dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4d)>(ProgramUniform4dv_adr);
    private ntv_ProgramUniform4dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: gl_program; location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4dv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4dv_1(&program, location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: gl_program; location: Int32; count: Int32; var value: Vec4d) :=
      ntv_ProgramUniform4dv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: gl_program; location: Int32; count: Int32; var value: double) :=
      ntv_ProgramUniform4dv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4dv_3(&program, location, count, value);
    
    // added in gl4.1
    private ProgramUniform4f_adr := GetProcAddress('glProgramUniform4f');
    private ntv_ProgramUniform4f_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single; v2: single; v3: single)>(ProgramUniform4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4f(&program: gl_program; location: Int32; v0: single; v1: single; v2: single; v3: single) :=
      ntv_ProgramUniform4f_1(&program, location, v0, v1, v2, v3);
    
    // added in gl4.1
    private ProgramUniform4fv_adr := GetProcAddress('glProgramUniform4fv');
    private ntv_ProgramUniform4fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(ProgramUniform4fv_adr);
    private ntv_ProgramUniform4fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4f)>(ProgramUniform4fv_adr);
    private ntv_ProgramUniform4fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4fv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4fv_1(&program, location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: gl_program; location: Int32; count: Int32; var value: Vec4f) :=
      ntv_ProgramUniform4fv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: gl_program; location: Int32; count: Int32; var value: single) :=
      ntv_ProgramUniform4fv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4fv_3(&program, location, count, value);
    
    // added in gl4.1
    private ProgramUniform4i_adr := GetProcAddress('glProgramUniform4i');
    private ntv_ProgramUniform4i_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32)>(ProgramUniform4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32) :=
      ntv_ProgramUniform4i_1(&program, location, v0, v1, v2, v3);
    
    // added in gl4.1
    private ProgramUniform4iv_adr := GetProcAddress('glProgramUniform4iv');
    private ntv_ProgramUniform4iv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(ProgramUniform4iv_adr);
    private ntv_ProgramUniform4iv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4i)>(ProgramUniform4iv_adr);
    private ntv_ProgramUniform4iv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4iv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4iv_1(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: gl_program; location: Int32; count: Int32; var value: Vec4i) :=
      ntv_ProgramUniform4iv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
      ntv_ProgramUniform4iv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4iv_3(&program, location, count, value);
    
    // added in gl4.1
    private ProgramUniform4ui_adr := GetProcAddress('glProgramUniform4ui');
    private ntv_ProgramUniform4ui_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32)>(ProgramUniform4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32) :=
      ntv_ProgramUniform4ui_1(&program, location, v0, v1, v2, v3);
    
    // added in gl4.1
    private ProgramUniform4uiv_adr := GetProcAddress('glProgramUniform4uiv');
    private ntv_ProgramUniform4uiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(ProgramUniform4uiv_adr);
    private ntv_ProgramUniform4uiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Vec4ui)>(ProgramUniform4uiv_adr);
    private ntv_ProgramUniform4uiv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(ProgramUniform4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniform4uiv_1(&program, location, count, value[0]) else
        ntv_ProgramUniform4uiv_1(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: gl_program; location: Int32; count: Int32; var value: Vec4ui) :=
      ntv_ProgramUniform4uiv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
      ntv_ProgramUniform4uiv_1(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
      ntv_ProgramUniform4uiv_3(&program, location, count, value);
    
    // added in gl4.1
    private ProgramUniformMatrix2dv_adr := GetProcAddress('glProgramUniformMatrix2dv');
    private ntv_ProgramUniformMatrix2dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix2dv_adr);
    private ntv_ProgramUniformMatrix2dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2d)>(ProgramUniformMatrix2dv_adr);
    private ntv_ProgramUniformMatrix2dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2d) :=
      ntv_ProgramUniformMatrix2dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix2dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2dv_3(&program, location, count, transpose, value);
    
    // added in gl4.1
    private ProgramUniformMatrix2fv_adr := GetProcAddress('glProgramUniformMatrix2fv');
    private ntv_ProgramUniformMatrix2fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix2fv_adr);
    private ntv_ProgramUniformMatrix2fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2f)>(ProgramUniformMatrix2fv_adr);
    private ntv_ProgramUniformMatrix2fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2f) :=
      ntv_ProgramUniformMatrix2fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix2fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2fv_3(&program, location, count, transpose, value);
    
    // added in gl4.1
    private ProgramUniformMatrix2x3dv_adr := GetProcAddress('glProgramUniformMatrix2x3dv');
    private ntv_ProgramUniformMatrix2x3dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix2x3dv_adr);
    private ntv_ProgramUniformMatrix2x3dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3d)>(ProgramUniformMatrix2x3dv_adr);
    private ntv_ProgramUniformMatrix2x3dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2x3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2x3dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2x3dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3d) :=
      ntv_ProgramUniformMatrix2x3dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix2x3dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2x3dv_3(&program, location, count, transpose, value);
    
    // added in gl4.1
    private ProgramUniformMatrix2x3fv_adr := GetProcAddress('glProgramUniformMatrix2x3fv');
    private ntv_ProgramUniformMatrix2x3fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix2x3fv_adr);
    private ntv_ProgramUniformMatrix2x3fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3f)>(ProgramUniformMatrix2x3fv_adr);
    private ntv_ProgramUniformMatrix2x3fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2x3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2x3fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2x3fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3f) :=
      ntv_ProgramUniformMatrix2x3fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix2x3fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2x3fv_3(&program, location, count, transpose, value);
    
    // added in gl4.1
    private ProgramUniformMatrix2x4dv_adr := GetProcAddress('glProgramUniformMatrix2x4dv');
    private ntv_ProgramUniformMatrix2x4dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix2x4dv_adr);
    private ntv_ProgramUniformMatrix2x4dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4d)>(ProgramUniformMatrix2x4dv_adr);
    private ntv_ProgramUniformMatrix2x4dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2x4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2x4dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2x4dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4d) :=
      ntv_ProgramUniformMatrix2x4dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix2x4dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2x4dv_3(&program, location, count, transpose, value);
    
    // added in gl4.1
    private ProgramUniformMatrix2x4fv_adr := GetProcAddress('glProgramUniformMatrix2x4fv');
    private ntv_ProgramUniformMatrix2x4fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix2x4fv_adr);
    private ntv_ProgramUniformMatrix2x4fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4f)>(ProgramUniformMatrix2x4fv_adr);
    private ntv_ProgramUniformMatrix2x4fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix2x4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix2x4fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix2x4fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4f) :=
      ntv_ProgramUniformMatrix2x4fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix2x4fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix2x4fv_3(&program, location, count, transpose, value);
    
    // added in gl4.1
    private ProgramUniformMatrix3dv_adr := GetProcAddress('glProgramUniformMatrix3dv');
    private ntv_ProgramUniformMatrix3dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix3dv_adr);
    private ntv_ProgramUniformMatrix3dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3d)>(ProgramUniformMatrix3dv_adr);
    private ntv_ProgramUniformMatrix3dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3d) :=
      ntv_ProgramUniformMatrix3dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix3dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3dv_3(&program, location, count, transpose, value);
    
    // added in gl4.1
    private ProgramUniformMatrix3fv_adr := GetProcAddress('glProgramUniformMatrix3fv');
    private ntv_ProgramUniformMatrix3fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix3fv_adr);
    private ntv_ProgramUniformMatrix3fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3f)>(ProgramUniformMatrix3fv_adr);
    private ntv_ProgramUniformMatrix3fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3f) :=
      ntv_ProgramUniformMatrix3fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix3fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3fv_3(&program, location, count, transpose, value);
    
    // added in gl4.1
    private ProgramUniformMatrix3x2dv_adr := GetProcAddress('glProgramUniformMatrix3x2dv');
    private ntv_ProgramUniformMatrix3x2dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix3x2dv_adr);
    private ntv_ProgramUniformMatrix3x2dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2d)>(ProgramUniformMatrix3x2dv_adr);
    private ntv_ProgramUniformMatrix3x2dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3x2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3x2dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3x2dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2d) :=
      ntv_ProgramUniformMatrix3x2dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix3x2dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3x2dv_3(&program, location, count, transpose, value);
    
    // added in gl4.1
    private ProgramUniformMatrix3x2fv_adr := GetProcAddress('glProgramUniformMatrix3x2fv');
    private ntv_ProgramUniformMatrix3x2fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix3x2fv_adr);
    private ntv_ProgramUniformMatrix3x2fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2f)>(ProgramUniformMatrix3x2fv_adr);
    private ntv_ProgramUniformMatrix3x2fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3x2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3x2fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3x2fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2f) :=
      ntv_ProgramUniformMatrix3x2fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix3x2fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3x2fv_3(&program, location, count, transpose, value);
    
    // added in gl4.1
    private ProgramUniformMatrix3x4dv_adr := GetProcAddress('glProgramUniformMatrix3x4dv');
    private ntv_ProgramUniformMatrix3x4dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix3x4dv_adr);
    private ntv_ProgramUniformMatrix3x4dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4d)>(ProgramUniformMatrix3x4dv_adr);
    private ntv_ProgramUniformMatrix3x4dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3x4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3x4dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3x4dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4d) :=
      ntv_ProgramUniformMatrix3x4dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix3x4dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3x4dv_3(&program, location, count, transpose, value);
    
    // added in gl4.1
    private ProgramUniformMatrix3x4fv_adr := GetProcAddress('glProgramUniformMatrix3x4fv');
    private ntv_ProgramUniformMatrix3x4fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix3x4fv_adr);
    private ntv_ProgramUniformMatrix3x4fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4f)>(ProgramUniformMatrix3x4fv_adr);
    private ntv_ProgramUniformMatrix3x4fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix3x4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix3x4fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix3x4fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4f) :=
      ntv_ProgramUniformMatrix3x4fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix3x4fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix3x4fv_3(&program, location, count, transpose, value);
    
    // added in gl4.1
    private ProgramUniformMatrix4dv_adr := GetProcAddress('glProgramUniformMatrix4dv');
    private ntv_ProgramUniformMatrix4dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix4dv_adr);
    private ntv_ProgramUniformMatrix4dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4d)>(ProgramUniformMatrix4dv_adr);
    private ntv_ProgramUniformMatrix4dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4d) :=
      ntv_ProgramUniformMatrix4dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix4dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4dv_3(&program, location, count, transpose, value);
    
    // added in gl4.1
    private ProgramUniformMatrix4fv_adr := GetProcAddress('glProgramUniformMatrix4fv');
    private ntv_ProgramUniformMatrix4fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix4fv_adr);
    private ntv_ProgramUniformMatrix4fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4f)>(ProgramUniformMatrix4fv_adr);
    private ntv_ProgramUniformMatrix4fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4f) :=
      ntv_ProgramUniformMatrix4fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix4fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4fv_3(&program, location, count, transpose, value);
    
    // added in gl4.1
    private ProgramUniformMatrix4x2dv_adr := GetProcAddress('glProgramUniformMatrix4x2dv');
    private ntv_ProgramUniformMatrix4x2dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix4x2dv_adr);
    private ntv_ProgramUniformMatrix4x2dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2d)>(ProgramUniformMatrix4x2dv_adr);
    private ntv_ProgramUniformMatrix4x2dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4x2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4x2dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4x2dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2d) :=
      ntv_ProgramUniformMatrix4x2dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix4x2dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4x2dv_3(&program, location, count, transpose, value);
    
    // added in gl4.1
    private ProgramUniformMatrix4x2fv_adr := GetProcAddress('glProgramUniformMatrix4x2fv');
    private ntv_ProgramUniformMatrix4x2fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix4x2fv_adr);
    private ntv_ProgramUniformMatrix4x2fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2f)>(ProgramUniformMatrix4x2fv_adr);
    private ntv_ProgramUniformMatrix4x2fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4x2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4x2fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4x2fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2f) :=
      ntv_ProgramUniformMatrix4x2fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix4x2fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4x2fv_3(&program, location, count, transpose, value);
    
    // added in gl4.1
    private ProgramUniformMatrix4x3dv_adr := GetProcAddress('glProgramUniformMatrix4x3dv');
    private ntv_ProgramUniformMatrix4x3dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double)>(ProgramUniformMatrix4x3dv_adr);
    private ntv_ProgramUniformMatrix4x3dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3d)>(ProgramUniformMatrix4x3dv_adr);
    private ntv_ProgramUniformMatrix4x3dv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4x3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4x3dv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4x3dv_1(&program, location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3d) :=
      ntv_ProgramUniformMatrix4x3dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_ProgramUniformMatrix4x3dv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4x3dv_3(&program, location, count, transpose, value);
    
    // added in gl4.1
    private ProgramUniformMatrix4x3fv_adr := GetProcAddress('glProgramUniformMatrix4x3fv');
    private ntv_ProgramUniformMatrix4x3fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single)>(ProgramUniformMatrix4x3fv_adr);
    private ntv_ProgramUniformMatrix4x3fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3f)>(ProgramUniformMatrix4x3fv_adr);
    private ntv_ProgramUniformMatrix4x3fv_3 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(ProgramUniformMatrix4x3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_ProgramUniformMatrix4x3fv_1(&program, location, count, transpose, value[0]) else
        ntv_ProgramUniformMatrix4x3fv_1(&program, location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3f) :=
      ntv_ProgramUniformMatrix4x3fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_ProgramUniformMatrix4x3fv_1(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: gl_program; location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_ProgramUniformMatrix4x3fv_3(&program, location, count, transpose, value);
    
    // added in gl3.2
    private ProvokingVertex_adr := GetProcAddress('glProvokingVertex');
    private ntv_ProvokingVertex_1 := GetProcOrNil&<procedure(mode: glVertexProvokingMode)>(ProvokingVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProvokingVertex(mode: glVertexProvokingMode) :=
      ntv_ProvokingVertex_1(mode);
    
    // added in gl4.3
    private PushDebugGroup_adr := GetProcAddress('glPushDebugGroup');
    private ntv_PushDebugGroup_1 := GetProcOrNil&<procedure(source: glDebugSource; id: UInt32; length: Int32; message: IntPtr)>(PushDebugGroup_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushDebugGroup(source: glDebugSource; id: UInt32; length: Int32; message: string);
    begin
      var message_str_ptr := Marshal.StringToHGlobalAnsi(message);
      try
        ntv_PushDebugGroup_1(source, id, length, message_str_ptr);
      finally
        Marshal.FreeHGlobal(message_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushDebugGroup(source: glDebugSource; id: UInt32; length: Int32; message: IntPtr) :=
      ntv_PushDebugGroup_1(source, id, length, message);
    
    // added in gl3.3
    private QueryCounter_adr := GetProcAddress('glQueryCounter');
    private ntv_QueryCounter_1 := GetProcOrNil&<procedure(id: gl_query; target: glQueryCounterTarget)>(QueryCounter_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryCounter(id: gl_query; target: glQueryCounterTarget) :=
      ntv_QueryCounter_1(id, target);
    
    // added in gl1.0
    private ReadBuffer_adr := GetProcAddress('glReadBuffer');
    private ntv_ReadBuffer_1 := GetProcOrNil&<procedure(src: glReadBufferMode)>(ReadBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadBuffer(src: glReadBufferMode) :=
      ntv_ReadBuffer_1(src);
    
    // added in gl4.5
    private ReadnPixels_adr := GetProcAddress('glReadnPixels');
    private ntv_ReadnPixels_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; data: IntPtr)>(ReadnPixels_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadnPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; bufSize: Int32; data: IntPtr) :=
      ntv_ReadnPixels_1(x, y, width, height, format, &type, bufSize, data);
    
    // added in gl1.0
    private ReadPixels_adr := GetProcAddress('glReadPixels');
    private ntv_ReadPixels_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(ReadPixels_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_ReadPixels_1(x, y, width, height, format, &type, pixels);
    
    // added in gl4.1
    private ReleaseShaderCompiler_adr := GetProcAddress('glReleaseShaderCompiler');
    private ntv_ReleaseShaderCompiler_1 := GetProcOrNil&<procedure>(ReleaseShaderCompiler_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReleaseShaderCompiler :=
      ntv_ReleaseShaderCompiler_1;
    
    // added in gl3.0
    private RenderbufferStorage_adr := GetProcAddress('glRenderbufferStorage');
    private ntv_RenderbufferStorage_1 := GetProcOrNil&<procedure(target: glRenderbufferTarget; internalformat: glInternalFormat; width: Int32; height: Int32)>(RenderbufferStorage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorage(target: glRenderbufferTarget; internalformat: glInternalFormat; width: Int32; height: Int32) :=
      ntv_RenderbufferStorage_1(target, internalformat, width, height);
    
    // added in gl3.0
    private RenderbufferStorageMultisample_adr := GetProcAddress('glRenderbufferStorageMultisample');
    private ntv_RenderbufferStorageMultisample_1 := GetProcOrNil&<procedure(target: glRenderbufferTarget; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32)>(RenderbufferStorageMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisample(target: glRenderbufferTarget; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32) :=
      ntv_RenderbufferStorageMultisample_1(target, samples, internalformat, width, height);
    
    // added in gl4.0
    private ResumeTransformFeedback_adr := GetProcAddress('glResumeTransformFeedback');
    private ntv_ResumeTransformFeedback_1 := GetProcOrNil&<procedure>(ResumeTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResumeTransformFeedback :=
      ntv_ResumeTransformFeedback_1;
    
    // added in gl1.3
    private SampleCoverage_adr := GetProcAddress('glSampleCoverage');
    private ntv_SampleCoverage_1 := GetProcOrNil&<procedure(value: single; invert: glBool8)>(SampleCoverage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleCoverage(value: single; invert: glBool8) :=
      ntv_SampleCoverage_1(value, invert);
    
    // added in gl3.2
    private SampleMaski_adr := GetProcAddress('glSampleMaski');
    private ntv_SampleMaski_1 := GetProcOrNil&<procedure(maskNumber: UInt32; mask: DummyFlags)>(SampleMaski_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMaski(maskNumber: UInt32; mask: DummyFlags) :=
      ntv_SampleMaski_1(maskNumber, mask);
    
    // added in gl3.3
    private SamplerParameterf_adr := GetProcAddress('glSamplerParameterf');
    private ntv_SamplerParameterf_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterF; param: single)>(SamplerParameterf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterf(sampler: gl_sampler; pname: glSamplerParameterF; param: single) :=
      ntv_SamplerParameterf_1(sampler, pname, param);
    
    // added in gl3.3
    private SamplerParameterfv_adr := GetProcAddress('glSamplerParameterfv');
    private ntv_SamplerParameterfv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterF; var param: single)>(SamplerParameterfv_adr);
    private ntv_SamplerParameterfv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterF; param: IntPtr)>(SamplerParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterfv(sampler: gl_sampler; pname: glSamplerParameterF; param: array of single);
    type PSingle = ^single;
    begin
      if (param<>nil) and (param.Length<>0) then
        ntv_SamplerParameterfv_1(sampler, pname, param[0]) else
        ntv_SamplerParameterfv_1(sampler, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterfv(sampler: gl_sampler; pname: glSamplerParameterF; var param: single) :=
      ntv_SamplerParameterfv_1(sampler, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterfv(sampler: gl_sampler; pname: glSamplerParameterF; param: IntPtr) :=
      ntv_SamplerParameterfv_2(sampler, pname, param);
    
    // added in gl3.3
    private SamplerParameteri_adr := GetProcAddress('glSamplerParameteri');
    private ntv_SamplerParameteri_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; param: Int32)>(SamplerParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteri(sampler: gl_sampler; pname: glSamplerParameterI; param: Int32) :=
      ntv_SamplerParameteri_1(sampler, pname, param);
    
    // added in gl3.3
    private SamplerParameterIiv_adr := GetProcAddress('glSamplerParameterIiv');
    private ntv_SamplerParameterIiv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; var param: Int32)>(SamplerParameterIiv_adr);
    private ntv_SamplerParameterIiv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; param: IntPtr)>(SamplerParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIiv(sampler: gl_sampler; pname: glSamplerParameterI; param: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (param<>nil) and (param.Length<>0) then
        ntv_SamplerParameterIiv_1(sampler, pname, param[0]) else
        ntv_SamplerParameterIiv_1(sampler, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIiv(sampler: gl_sampler; pname: glSamplerParameterI; var param: Int32) :=
      ntv_SamplerParameterIiv_1(sampler, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIiv(sampler: gl_sampler; pname: glSamplerParameterI; param: IntPtr) :=
      ntv_SamplerParameterIiv_2(sampler, pname, param);
    
    // added in gl3.3
    private SamplerParameterIuiv_adr := GetProcAddress('glSamplerParameterIuiv');
    private ntv_SamplerParameterIuiv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; var param: UInt32)>(SamplerParameterIuiv_adr);
    private ntv_SamplerParameterIuiv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; param: IntPtr)>(SamplerParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: gl_sampler; pname: glSamplerParameterI; param: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (param<>nil) and (param.Length<>0) then
        ntv_SamplerParameterIuiv_1(sampler, pname, param[0]) else
        ntv_SamplerParameterIuiv_1(sampler, pname, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: gl_sampler; pname: glSamplerParameterI; var param: UInt32) :=
      ntv_SamplerParameterIuiv_1(sampler, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: gl_sampler; pname: glSamplerParameterI; param: IntPtr) :=
      ntv_SamplerParameterIuiv_2(sampler, pname, param);
    
    // added in gl3.3
    private SamplerParameteriv_adr := GetProcAddress('glSamplerParameteriv');
    private ntv_SamplerParameteriv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; var param: Int32)>(SamplerParameteriv_adr);
    private ntv_SamplerParameteriv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: glSamplerParameterI; param: IntPtr)>(SamplerParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteriv(sampler: gl_sampler; pname: glSamplerParameterI; param: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (param<>nil) and (param.Length<>0) then
        ntv_SamplerParameteriv_1(sampler, pname, param[0]) else
        ntv_SamplerParameteriv_1(sampler, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteriv(sampler: gl_sampler; pname: glSamplerParameterI; var param: Int32) :=
      ntv_SamplerParameteriv_1(sampler, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteriv(sampler: gl_sampler; pname: glSamplerParameterI; param: IntPtr) :=
      ntv_SamplerParameteriv_2(sampler, pname, param);
    
    // added in gl1.0
    private Scissor_adr := GetProcAddress('glScissor');
    private ntv_Scissor_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32)>(Scissor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Scissor(x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_Scissor_1(x, y, width, height);
    
    // added in gl4.1
    private ScissorArrayv_adr := GetProcAddress('glScissorArrayv');
    private ntv_ScissorArrayv_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var v: Int32)>(ScissorArrayv_adr);
    private ntv_ScissorArrayv_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; v: IntPtr)>(ScissorArrayv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayv(first: UInt32; count: Int32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_ScissorArrayv_1(first, count, v[0]) else
        ntv_ScissorArrayv_1(first, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayv(first: UInt32; count: Int32; var v: Int32) :=
      ntv_ScissorArrayv_1(first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayv(first: UInt32; count: Int32; v: IntPtr) :=
      ntv_ScissorArrayv_2(first, count, v);
    
    // added in gl4.1
    private ScissorIndexed_adr := GetProcAddress('glScissorIndexed');
    private ntv_ScissorIndexed_1 := GetProcOrNil&<procedure(index: UInt32; left: Int32; bottom: Int32; width: Int32; height: Int32)>(ScissorIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexed(index: UInt32; left: Int32; bottom: Int32; width: Int32; height: Int32) :=
      ntv_ScissorIndexed_1(index, left, bottom, width, height);
    
    // added in gl4.1
    private ScissorIndexedv_adr := GetProcAddress('glScissorIndexedv');
    private ntv_ScissorIndexedv_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(ScissorIndexedv_adr);
    private ntv_ScissorIndexedv_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(ScissorIndexedv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedv(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_ScissorIndexedv_1(index, v[0]) else
        ntv_ScissorIndexedv_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedv(index: UInt32; var v: Int32) :=
      ntv_ScissorIndexedv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedv(index: UInt32; v: IntPtr) :=
      ntv_ScissorIndexedv_2(index, v);
    
    // added in gl3.3
    private SecondaryColorP3ui_adr := GetProcAddress('glSecondaryColorP3ui');
    private ntv_SecondaryColorP3ui_1 := GetProcOrNil&<procedure(&type: glColorPointerType; color: UInt32)>(SecondaryColorP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3ui(&type: glColorPointerType; color: UInt32) :=
      ntv_SecondaryColorP3ui_1(&type, color);
    
    // added in gl3.3
    private SecondaryColorP3uiv_adr := GetProcAddress('glSecondaryColorP3uiv');
    private ntv_SecondaryColorP3uiv_1 := GetProcOrNil&<procedure(&type: glColorPointerType; var color: UInt32)>(SecondaryColorP3uiv_adr);
    private ntv_SecondaryColorP3uiv_2 := GetProcOrNil&<procedure(&type: glColorPointerType; color: IntPtr)>(SecondaryColorP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: glColorPointerType; color: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (color<>nil) and (color.Length<>0) then
        ntv_SecondaryColorP3uiv_1(&type, color[0]) else
        ntv_SecondaryColorP3uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: glColorPointerType; var color: UInt32) :=
      ntv_SecondaryColorP3uiv_1(&type, color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: glColorPointerType; color: IntPtr) :=
      ntv_SecondaryColorP3uiv_2(&type, color);
    
    // added in gl4.1
    private ShaderBinary_adr := GetProcAddress('glShaderBinary');
    private ntv_ShaderBinary_1 := GetProcOrNil&<procedure(count: Int32; var shaders: gl_shader; binaryFormat: glShaderBinaryFormat; binary: IntPtr; length: Int32)>(ShaderBinary_adr);
    private ntv_ShaderBinary_2 := GetProcOrNil&<procedure(count: Int32; shaders: IntPtr; binaryFormat: glShaderBinaryFormat; binary: IntPtr; length: Int32)>(ShaderBinary_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; shaders: array of gl_shader; binaryFormat: glShaderBinaryFormat; binary: IntPtr; length: Int32);
    type PGl_shader = ^gl_shader;
    begin
      if (shaders<>nil) and (shaders.Length<>0) then
        ntv_ShaderBinary_1(count, shaders[0], binaryFormat, binary, length) else
        ntv_ShaderBinary_1(count, PGl_shader(nil)^, binaryFormat, binary, length);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; var shaders: gl_shader; binaryFormat: glShaderBinaryFormat; binary: IntPtr; length: Int32) :=
      ntv_ShaderBinary_1(count, shaders, binaryFormat, binary, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; shaders: IntPtr; binaryFormat: glShaderBinaryFormat; binary: IntPtr; length: Int32) :=
      ntv_ShaderBinary_2(count, shaders, binaryFormat, binary, length);
    
    // added in gl2.0
    private ShaderSource_adr := GetProcAddress('glShaderSource');
    private ntv_ShaderSource_1 := GetProcOrNil&<procedure(shader: gl_shader; count: Int32; var string: IntPtr; var length: Int32)>(ShaderSource_adr);
    private ntv_ShaderSource_2 := GetProcOrNil&<procedure(shader: gl_shader; count: Int32; string: pointer; var length: Int32)>(ShaderSource_adr);
    private ntv_ShaderSource_3 := GetProcOrNil&<procedure(shader: gl_shader; count: Int32; var string: IntPtr; length: IntPtr)>(ShaderSource_adr);
    private ntv_ShaderSource_4 := GetProcOrNil&<procedure(shader: gl_shader; count: Int32; string: pointer; length: IntPtr)>(ShaderSource_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSource(shader: gl_shader; count: Int32; string: array of string; length: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (string=nil) or (string.Length=0) then
      begin
        if (length<>nil) and (length.Length<>0) then
          ntv_ShaderSource_2(shader, count, nil, length[0]) else
          ntv_ShaderSource_2(shader, count, nil, PInt32(nil)^);
        exit;
      end;
      var string_temp_arr: array of IntPtr;
      try
        begin
          var string_org_el_1 := string;
          var string_len_1 := string_org_el_1.Length;
          SetLength(string_temp_arr, string_len_1);
          var string_tmp_el_1 := string_temp_arr;
          for var string_ind_1 := 0 to string_len_1-1 do
          begin
            var string_org_el_2 := string_org_el_1[string_ind_1];
            if (string_org_el_2=nil) or (string_org_el_2.Length=0) then continue;
            string_tmp_el_1[string_ind_1] := Marshal.StringToHGlobalAnsi(string_org_el_2);
          end;
        end;
        if (length<>nil) and (length.Length<>0) then
          ntv_ShaderSource_1(shader, count, string_temp_arr[0], length[0]) else
          ntv_ShaderSource_1(shader, count, string_temp_arr[0], PInt32(nil)^);
      finally
         foreach var arr_el1 in string_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSource(shader: gl_shader; count: Int32; var string: IntPtr; var length: Int32) :=
      ntv_ShaderSource_1(shader, count, string, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSource(shader: gl_shader; count: Int32; var string: IntPtr; length: IntPtr) :=
      ntv_ShaderSource_3(shader, count, string, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSource(shader: gl_shader; count: Int32; string: pointer; var length: Int32) :=
      ntv_ShaderSource_2(shader, count, string, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSource(shader: gl_shader; count: Int32; string: pointer; length: IntPtr) :=
      ntv_ShaderSource_4(shader, count, string, length);
    
    // added in gl4.3
    private ShaderStorageBlockBinding_adr := GetProcAddress('glShaderStorageBlockBinding');
    private ntv_ShaderStorageBlockBinding_1 := GetProcOrNil&<procedure(&program: gl_program; storageBlockIndex: UInt32; storageBlockBinding: UInt32)>(ShaderStorageBlockBinding_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderStorageBlockBinding(&program: gl_program; storageBlockIndex: UInt32; storageBlockBinding: UInt32) :=
      ntv_ShaderStorageBlockBinding_1(&program, storageBlockIndex, storageBlockBinding);
    
    // added in gl4.6
    private SpecializeShader_adr := GetProcAddress('glSpecializeShader');
    private ntv_SpecializeShader_1 := GetProcOrNil&<procedure(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: UInt32)>(SpecializeShader_adr);
    private ntv_SpecializeShader_2 := GetProcOrNil&<procedure(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; pConstantValue: IntPtr)>(SpecializeShader_adr);
    private ntv_SpecializeShader_3 := GetProcOrNil&<procedure(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; var pConstantValue: UInt32)>(SpecializeShader_adr);
    private ntv_SpecializeShader_4 := GetProcOrNil&<procedure(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; pConstantValue: IntPtr)>(SpecializeShader_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (pConstantValue<>nil) and (pConstantValue.Length<>0) then
        if (pConstantIndex<>nil) and (pConstantIndex.Length<>0) then
          SpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], pConstantValue[0]) else
          SpecializeShader(shader, pEntryPoint, numSpecializationConstants, PUInt32(nil)^, pConstantValue[0]) else
        if (pConstantIndex<>nil) and (pConstantIndex.Length<>0) then
          SpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], PUInt32(nil)^) else
          SpecializeShader(shader, pEntryPoint, numSpecializationConstants, PUInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (pConstantValue<>nil) and (pConstantValue.Length<>0) then
        if (pConstantIndex<>nil) and (pConstantIndex.Length<>0) then
          ntv_SpecializeShader_1(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], pConstantValue[0]) else
          ntv_SpecializeShader_1(shader, pEntryPoint, numSpecializationConstants, PUInt32(nil)^, pConstantValue[0]) else
        if (pConstantIndex<>nil) and (pConstantIndex.Length<>0) then
          ntv_SpecializeShader_1(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], PUInt32(nil)^) else
          ntv_SpecializeShader_1(shader, pEntryPoint, numSpecializationConstants, PUInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: UInt32);
    begin
      var pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
      try
        ntv_SpecializeShader_1(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex, pConstantValue);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; pConstantValue: IntPtr);
    begin
      var pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
      try
        ntv_SpecializeShader_2(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex, pConstantValue);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; var pConstantValue: UInt32);
    begin
      var pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
      try
        ntv_SpecializeShader_3(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex, pConstantValue);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; pConstantValue: IntPtr);
    begin
      var pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
      try
        ntv_SpecializeShader_4(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex, pConstantValue);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: UInt32) :=
      ntv_SpecializeShader_1(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; pConstantValue: IntPtr) :=
      ntv_SpecializeShader_2(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; var pConstantValue: UInt32) :=
      ntv_SpecializeShader_3(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; pConstantValue: IntPtr) :=
      ntv_SpecializeShader_4(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    
    // added in gl1.0
    private StencilFunc_adr := GetProcAddress('glStencilFunc');
    private ntv_StencilFunc_1 := GetProcOrNil&<procedure(func: glStencilFunction; ref: Int32; mask: UInt32)>(StencilFunc_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFunc(func: glStencilFunction; ref: Int32; mask: UInt32) :=
      ntv_StencilFunc_1(func, ref, mask);
    
    // added in gl2.0
    private StencilFuncSeparate_adr := GetProcAddress('glStencilFuncSeparate');
    private ntv_StencilFuncSeparate_1 := GetProcOrNil&<procedure(face: glTriangleFace; func: glStencilFunction; ref: Int32; mask: UInt32)>(StencilFuncSeparate_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFuncSeparate(face: glTriangleFace; func: glStencilFunction; ref: Int32; mask: UInt32) :=
      ntv_StencilFuncSeparate_1(face, func, ref, mask);
    
    // added in gl1.0
    private StencilMask_adr := GetProcAddress('glStencilMask');
    private ntv_StencilMask_1 := GetProcOrNil&<procedure(mask: UInt32)>(StencilMask_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilMask(mask: UInt32) :=
      ntv_StencilMask_1(mask);
    
    // added in gl2.0
    private StencilMaskSeparate_adr := GetProcAddress('glStencilMaskSeparate');
    private ntv_StencilMaskSeparate_1 := GetProcOrNil&<procedure(face: glTriangleFace; mask: UInt32)>(StencilMaskSeparate_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilMaskSeparate(face: glTriangleFace; mask: UInt32) :=
      ntv_StencilMaskSeparate_1(face, mask);
    
    // added in gl1.0
    private StencilOp_adr := GetProcAddress('glStencilOp');
    private ntv_StencilOp_1 := GetProcOrNil&<procedure(fail: glStencilOp; zfail: glStencilOp; zpass: glStencilOp)>(StencilOp_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilOp(fail: glStencilOp; zfail: glStencilOp; zpass: glStencilOp) :=
      ntv_StencilOp_1(fail, zfail, zpass);
    
    // added in gl2.0
    private StencilOpSeparate_adr := GetProcAddress('glStencilOpSeparate');
    private ntv_StencilOpSeparate_1 := GetProcOrNil&<procedure(face: glTriangleFace; sfail: glStencilOp; dpfail: glStencilOp; dppass: glStencilOp)>(StencilOpSeparate_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilOpSeparate(face: glTriangleFace; sfail: glStencilOp; dpfail: glStencilOp; dppass: glStencilOp) :=
      ntv_StencilOpSeparate_1(face, sfail, dpfail, dppass);
    
    // added in gl3.1
    private TexBuffer_adr := GetProcAddress('glTexBuffer');
    private ntv_TexBuffer_1 := GetProcOrNil&<procedure(target: glTextureTarget; internalformat: glSizedInternalFormat; buffer: gl_buffer)>(TexBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBuffer(target: glTextureTarget; internalformat: glSizedInternalFormat; buffer: gl_buffer) :=
      ntv_TexBuffer_1(target, internalformat, buffer);
    
    // added in gl4.3
    private TexBufferRange_adr := GetProcAddress('glTexBufferRange');
    private ntv_TexBufferRange_1 := GetProcOrNil&<procedure(target: glTextureTarget; internalformat: glSizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(TexBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBufferRange(target: glTextureTarget; internalformat: glSizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
      ntv_TexBufferRange_1(target, internalformat, buffer, offset, size);
    
    // added in gl3.3
    private TexCoordP1ui_adr := GetProcAddress('glTexCoordP1ui');
    private ntv_TexCoordP1ui_1 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; coords: UInt32)>(TexCoordP1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1ui(&type: glTexCoordPointerType; coords: UInt32) :=
      ntv_TexCoordP1ui_1(&type, coords);
    
    // added in gl3.3
    private TexCoordP1uiv_adr := GetProcAddress('glTexCoordP1uiv');
    private ntv_TexCoordP1uiv_1 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; var coords: UInt32)>(TexCoordP1uiv_adr);
    private ntv_TexCoordP1uiv_2 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; coords: IntPtr)>(TexCoordP1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: glTexCoordPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_TexCoordP1uiv_1(&type, coords[0]) else
        ntv_TexCoordP1uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: glTexCoordPointerType; var coords: UInt32) :=
      ntv_TexCoordP1uiv_1(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: glTexCoordPointerType; coords: IntPtr) :=
      ntv_TexCoordP1uiv_2(&type, coords);
    
    // added in gl3.3
    private TexCoordP2ui_adr := GetProcAddress('glTexCoordP2ui');
    private ntv_TexCoordP2ui_1 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; coords: UInt32)>(TexCoordP2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2ui(&type: glTexCoordPointerType; coords: UInt32) :=
      ntv_TexCoordP2ui_1(&type, coords);
    
    // added in gl3.3
    private TexCoordP2uiv_adr := GetProcAddress('glTexCoordP2uiv');
    private ntv_TexCoordP2uiv_1 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; var coords: UInt32)>(TexCoordP2uiv_adr);
    private ntv_TexCoordP2uiv_2 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; coords: IntPtr)>(TexCoordP2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: glTexCoordPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_TexCoordP2uiv_1(&type, coords[0]) else
        ntv_TexCoordP2uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: glTexCoordPointerType; var coords: UInt32) :=
      ntv_TexCoordP2uiv_1(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: glTexCoordPointerType; coords: IntPtr) :=
      ntv_TexCoordP2uiv_2(&type, coords);
    
    // added in gl3.3
    private TexCoordP3ui_adr := GetProcAddress('glTexCoordP3ui');
    private ntv_TexCoordP3ui_1 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; coords: UInt32)>(TexCoordP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3ui(&type: glTexCoordPointerType; coords: UInt32) :=
      ntv_TexCoordP3ui_1(&type, coords);
    
    // added in gl3.3
    private TexCoordP3uiv_adr := GetProcAddress('glTexCoordP3uiv');
    private ntv_TexCoordP3uiv_1 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; var coords: UInt32)>(TexCoordP3uiv_adr);
    private ntv_TexCoordP3uiv_2 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; coords: IntPtr)>(TexCoordP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: glTexCoordPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_TexCoordP3uiv_1(&type, coords[0]) else
        ntv_TexCoordP3uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: glTexCoordPointerType; var coords: UInt32) :=
      ntv_TexCoordP3uiv_1(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: glTexCoordPointerType; coords: IntPtr) :=
      ntv_TexCoordP3uiv_2(&type, coords);
    
    // added in gl3.3
    private TexCoordP4ui_adr := GetProcAddress('glTexCoordP4ui');
    private ntv_TexCoordP4ui_1 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; coords: UInt32)>(TexCoordP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4ui(&type: glTexCoordPointerType; coords: UInt32) :=
      ntv_TexCoordP4ui_1(&type, coords);
    
    // added in gl3.3
    private TexCoordP4uiv_adr := GetProcAddress('glTexCoordP4uiv');
    private ntv_TexCoordP4uiv_1 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; var coords: UInt32)>(TexCoordP4uiv_adr);
    private ntv_TexCoordP4uiv_2 := GetProcOrNil&<procedure(&type: glTexCoordPointerType; coords: IntPtr)>(TexCoordP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: glTexCoordPointerType; coords: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        ntv_TexCoordP4uiv_1(&type, coords[0]) else
        ntv_TexCoordP4uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: glTexCoordPointerType; var coords: UInt32) :=
      ntv_TexCoordP4uiv_1(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: glTexCoordPointerType; coords: IntPtr) :=
      ntv_TexCoordP4uiv_2(&type, coords);
    
    // added in gl1.0
    private TexImage1D_adr := GetProcAddress('glTexImage1D');
    private ntv_TexImage1D_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TexImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage1D(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TexImage1D_1(target, level, internalformat, width, border, format, &type, pixels);
    
    // added in gl1.0
    private TexImage2D_adr := GetProcAddress('glTexImage2D');
    private ntv_TexImage2D_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TexImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage2D(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TexImage2D_1(target, level, internalformat, width, height, border, format, &type, pixels);
    
    // added in gl3.2
    private TexImage2DMultisample_adr := GetProcAddress('glTexImage2DMultisample');
    private ntv_TexImage2DMultisample_1 := GetProcOrNil&<procedure(target: glTextureTarget; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; fixedsamplelocations: glBool8)>(TexImage2DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage2DMultisample(target: glTextureTarget; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; fixedsamplelocations: glBool8) :=
      ntv_TexImage2DMultisample_1(target, samples, internalformat, width, height, fixedsamplelocations);
    
    // added in gl1.2
    private TexImage3D_adr := GetProcAddress('glTexImage3D');
    private ntv_TexImage3D_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TexImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3D(target: glTextureTarget; level: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TexImage3D_1(target, level, internalformat, width, height, depth, border, format, &type, pixels);
    
    // added in gl3.2
    private TexImage3DMultisample_adr := GetProcAddress('glTexImage3DMultisample');
    private ntv_TexImage3DMultisample_1 := GetProcOrNil&<procedure(target: glTextureTarget; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: glBool8)>(TexImage3DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3DMultisample(target: glTextureTarget; samples: Int32; internalformat: glInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: glBool8) :=
      ntv_TexImage3DMultisample_1(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    
    // added in gl1.0
    private TexParameterf_adr := GetProcAddress('glTexParameterf');
    private ntv_TexParameterf_1 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; param: single)>(TexParameterf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterf(target: glTextureTarget; pname: glTextureParameterName; param: single) :=
      ntv_TexParameterf_1(target, pname, param);
    
    // added in gl1.0
    private TexParameterfv_adr := GetProcAddress('glTexParameterfv');
    private ntv_TexParameterfv_1 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; var &params: single)>(TexParameterfv_adr);
    private ntv_TexParameterfv_2 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr)>(TexParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterfv(target: glTextureTarget; pname: glTextureParameterName; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TexParameterfv_1(target, pname, &params[0]) else
        ntv_TexParameterfv_1(target, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterfv(target: glTextureTarget; pname: glTextureParameterName; var &params: single) :=
      ntv_TexParameterfv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterfv(target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_TexParameterfv_2(target, pname, &params);
    
    // added in gl1.0
    private TexParameteri_adr := GetProcAddress('glTexParameteri');
    private ntv_TexParameteri_1 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; param: glConvolutionBorderMode)>(TexParameteri_adr);
    private ntv_TexParameteri_2 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; param: glDepthStencilTextureMode)>(TexParameteri_adr);
    private ntv_TexParameteri_3 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; param: glFoveationConfigBit)>(TexParameteri_adr);
    private ntv_TexParameteri_4 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; param: glMapTextureFormat)>(TexParameteri_adr);
    private ntv_TexParameteri_5 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; param: glTextureCompareMode)>(TexParameteri_adr);
    private ntv_TexParameteri_6 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; param: glTextureMagFilter)>(TexParameteri_adr);
    private ntv_TexParameteri_7 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; param: glTextureMinFilter)>(TexParameteri_adr);
    private ntv_TexParameteri_8 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; param: glTextureSwizzle)>(TexParameteri_adr);
    private ntv_TexParameteri_9 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; param: glTextureWrapMode)>(TexParameteri_adr);
    private ntv_TexParameteri_10 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; param: Int32)>(TexParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: glTextureTarget; pname: glTextureParameterName; param: glConvolutionBorderMode) :=
      ntv_TexParameteri_1(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: glTextureTarget; pname: glTextureParameterName; param: glDepthStencilTextureMode) :=
      ntv_TexParameteri_2(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: glTextureTarget; pname: glTextureParameterName; param: glFoveationConfigBit) :=
      ntv_TexParameteri_3(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: glTextureTarget; pname: glTextureParameterName; param: glMapTextureFormat) :=
      ntv_TexParameteri_4(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: glTextureTarget; pname: glTextureParameterName; param: glTextureCompareMode) :=
      ntv_TexParameteri_5(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: glTextureTarget; pname: glTextureParameterName; param: glTextureMagFilter) :=
      ntv_TexParameteri_6(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: glTextureTarget; pname: glTextureParameterName; param: glTextureMinFilter) :=
      ntv_TexParameteri_7(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: glTextureTarget; pname: glTextureParameterName; param: glTextureSwizzle) :=
      ntv_TexParameteri_8(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: glTextureTarget; pname: glTextureParameterName; param: glTextureWrapMode) :=
      ntv_TexParameteri_9(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: glTextureTarget; pname: glTextureParameterName; param: Int32) :=
      ntv_TexParameteri_10(target, pname, param);
    
    // added in gl3.0
    private TexParameterIiv_adr := GetProcAddress('glTexParameterIiv');
    private ntv_TexParameterIiv_1 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; var &params: Int32)>(TexParameterIiv_adr);
    private ntv_TexParameterIiv_2 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr)>(TexParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIiv(target: glTextureTarget; pname: glTextureParameterName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TexParameterIiv_1(target, pname, &params[0]) else
        ntv_TexParameterIiv_1(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIiv(target: glTextureTarget; pname: glTextureParameterName; var &params: Int32) :=
      ntv_TexParameterIiv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIiv(target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_TexParameterIiv_2(target, pname, &params);
    
    // added in gl3.0
    private TexParameterIuiv_adr := GetProcAddress('glTexParameterIuiv');
    private ntv_TexParameterIuiv_1 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; var &params: UInt32)>(TexParameterIuiv_adr);
    private ntv_TexParameterIuiv_2 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr)>(TexParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuiv(target: glTextureTarget; pname: glTextureParameterName; &params: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TexParameterIuiv_1(target, pname, &params[0]) else
        ntv_TexParameterIuiv_1(target, pname, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuiv(target: glTextureTarget; pname: glTextureParameterName; var &params: UInt32) :=
      ntv_TexParameterIuiv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuiv(target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_TexParameterIuiv_2(target, pname, &params);
    
    // added in gl1.0
    private TexParameteriv_adr := GetProcAddress('glTexParameteriv');
    private ntv_TexParameteriv_1 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; var &params: Int32)>(TexParameteriv_adr);
    private ntv_TexParameteriv_2 := GetProcOrNil&<procedure(target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr)>(TexParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteriv(target: glTextureTarget; pname: glTextureParameterName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TexParameteriv_1(target, pname, &params[0]) else
        ntv_TexParameteriv_1(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteriv(target: glTextureTarget; pname: glTextureParameterName; var &params: Int32) :=
      ntv_TexParameteriv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteriv(target: glTextureTarget; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_TexParameteriv_2(target, pname, &params);
    
    // added in gl4.2
    private TexStorage1D_adr := GetProcAddress('glTexStorage1D');
    private ntv_TexStorage1D_1 := GetProcOrNil&<procedure(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32)>(TexStorage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage1D(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32) :=
      ntv_TexStorage1D_1(target, levels, internalformat, width);
    
    // added in gl4.2
    private TexStorage2D_adr := GetProcAddress('glTexStorage2D');
    private ntv_TexStorage2D_1 := GetProcOrNil&<procedure(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32)>(TexStorage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage2D(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32) :=
      ntv_TexStorage2D_1(target, levels, internalformat, width, height);
    
    // added in gl4.3
    private TexStorage2DMultisample_adr := GetProcAddress('glTexStorage2DMultisample');
    private ntv_TexStorage2DMultisample_1 := GetProcOrNil&<procedure(target: glTextureTarget; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: glBool8)>(TexStorage2DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage2DMultisample(target: glTextureTarget; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: glBool8) :=
      ntv_TexStorage2DMultisample_1(target, samples, internalformat, width, height, fixedsamplelocations);
    
    // added in gl4.2
    private TexStorage3D_adr := GetProcAddress('glTexStorage3D');
    private ntv_TexStorage3D_1 := GetProcOrNil&<procedure(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32)>(TexStorage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage3D(target: glTextureTarget; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32) :=
      ntv_TexStorage3D_1(target, levels, internalformat, width, height, depth);
    
    // added in gl4.3
    private TexStorage3DMultisample_adr := GetProcAddress('glTexStorage3DMultisample');
    private ntv_TexStorage3DMultisample_1 := GetProcOrNil&<procedure(target: glTextureTarget; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: glBool8)>(TexStorage3DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage3DMultisample(target: glTextureTarget; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: glBool8) :=
      ntv_TexStorage3DMultisample_1(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    
    // added in gl1.1
    private TexSubImage1D_adr := GetProcAddress('glTexSubImage1D');
    private ntv_TexSubImage1D_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; width: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TexSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage1D(target: glTextureTarget; level: Int32; xoffset: Int32; width: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TexSubImage1D_1(target, level, xoffset, width, format, &type, pixels);
    
    // added in gl1.1
    private TexSubImage2D_adr := GetProcAddress('glTexSubImage2D');
    private ntv_TexSubImage2D_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TexSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage2D(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TexSubImage2D_1(target, level, xoffset, yoffset, width, height, format, &type, pixels);
    
    // added in gl1.2
    private TexSubImage3D_adr := GetProcAddress('glTexSubImage3D');
    private ntv_TexSubImage3D_1 := GetProcOrNil&<procedure(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TexSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage3D(target: glTextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TexSubImage3D_1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
    // added in gl4.5
    private TextureBarrier_adr := GetProcAddress('glTextureBarrier');
    private ntv_TextureBarrier_1 := GetProcOrNil&<procedure>(TextureBarrier_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBarrier :=
      ntv_TextureBarrier_1;
    
    // added in gl4.5
    private TextureBuffer_adr := GetProcAddress('glTextureBuffer');
    private ntv_TextureBuffer_1 := GetProcOrNil&<procedure(texture: gl_texture; internalformat: glSizedInternalFormat; buffer: gl_buffer)>(TextureBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBuffer(texture: gl_texture; internalformat: glSizedInternalFormat; buffer: gl_buffer) :=
      ntv_TextureBuffer_1(texture, internalformat, buffer);
    
    // added in gl4.5
    private TextureBufferRange_adr := GetProcAddress('glTextureBufferRange');
    private ntv_TextureBufferRange_1 := GetProcOrNil&<procedure(texture: gl_texture; internalformat: glSizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(TextureBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBufferRange(texture: gl_texture; internalformat: glSizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
      ntv_TextureBufferRange_1(texture, internalformat, buffer, offset, size);
    
    // added in gl4.5
    private TextureParameterf_adr := GetProcAddress('glTextureParameterf');
    private ntv_TextureParameterf_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: single)>(TextureParameterf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterf(texture: gl_texture; pname: glTextureParameterName; param: single) :=
      ntv_TextureParameterf_1(texture, pname, param);
    
    // added in gl4.5
    private TextureParameterfv_adr := GetProcAddress('glTextureParameterfv');
    private ntv_TextureParameterfv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; var param: single)>(TextureParameterfv_adr);
    private ntv_TextureParameterfv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: IntPtr)>(TextureParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfv(texture: gl_texture; pname: glTextureParameterName; param: array of single);
    type PSingle = ^single;
    begin
      if (param<>nil) and (param.Length<>0) then
        ntv_TextureParameterfv_1(texture, pname, param[0]) else
        ntv_TextureParameterfv_1(texture, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfv(texture: gl_texture; pname: glTextureParameterName; var param: single) :=
      ntv_TextureParameterfv_1(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfv(texture: gl_texture; pname: glTextureParameterName; param: IntPtr) :=
      ntv_TextureParameterfv_2(texture, pname, param);
    
    // added in gl4.5
    private TextureParameteri_adr := GetProcAddress('glTextureParameteri');
    private ntv_TextureParameteri_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glConvolutionBorderMode)>(TextureParameteri_adr);
    private ntv_TextureParameteri_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glDepthStencilTextureMode)>(TextureParameteri_adr);
    private ntv_TextureParameteri_3 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glFoveationConfigBit)>(TextureParameteri_adr);
    private ntv_TextureParameteri_4 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glMapTextureFormat)>(TextureParameteri_adr);
    private ntv_TextureParameteri_5 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glTextureCompareMode)>(TextureParameteri_adr);
    private ntv_TextureParameteri_6 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glTextureMagFilter)>(TextureParameteri_adr);
    private ntv_TextureParameteri_7 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glTextureMinFilter)>(TextureParameteri_adr);
    private ntv_TextureParameteri_8 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glTextureSwizzle)>(TextureParameteri_adr);
    private ntv_TextureParameteri_9 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: glTextureWrapMode)>(TextureParameteri_adr);
    private ntv_TextureParameteri_10 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: Int32)>(TextureParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glConvolutionBorderMode) :=
      ntv_TextureParameteri_1(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glDepthStencilTextureMode) :=
      ntv_TextureParameteri_2(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glFoveationConfigBit) :=
      ntv_TextureParameteri_3(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glMapTextureFormat) :=
      ntv_TextureParameteri_4(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glTextureCompareMode) :=
      ntv_TextureParameteri_5(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glTextureMagFilter) :=
      ntv_TextureParameteri_6(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glTextureMinFilter) :=
      ntv_TextureParameteri_7(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glTextureSwizzle) :=
      ntv_TextureParameteri_8(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: glTextureWrapMode) :=
      ntv_TextureParameteri_9(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: glTextureParameterName; param: Int32) :=
      ntv_TextureParameteri_10(texture, pname, param);
    
    // added in gl4.5
    private TextureParameterIiv_adr := GetProcAddress('glTextureParameterIiv');
    private ntv_TextureParameterIiv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; var &params: Int32)>(TextureParameterIiv_adr);
    private ntv_TextureParameterIiv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; &params: IntPtr)>(TextureParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIiv(texture: gl_texture; pname: glTextureParameterName; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TextureParameterIiv_1(texture, pname, &params[0]) else
        ntv_TextureParameterIiv_1(texture, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIiv(texture: gl_texture; pname: glTextureParameterName; var &params: Int32) :=
      ntv_TextureParameterIiv_1(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIiv(texture: gl_texture; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_TextureParameterIiv_2(texture, pname, &params);
    
    // added in gl4.5
    private TextureParameterIuiv_adr := GetProcAddress('glTextureParameterIuiv');
    private ntv_TextureParameterIuiv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; var &params: UInt32)>(TextureParameterIuiv_adr);
    private ntv_TextureParameterIuiv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; &params: IntPtr)>(TextureParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: gl_texture; pname: glTextureParameterName; &params: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TextureParameterIuiv_1(texture, pname, &params[0]) else
        ntv_TextureParameterIuiv_1(texture, pname, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: gl_texture; pname: glTextureParameterName; var &params: UInt32) :=
      ntv_TextureParameterIuiv_1(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: gl_texture; pname: glTextureParameterName; &params: IntPtr) :=
      ntv_TextureParameterIuiv_2(texture, pname, &params);
    
    // added in gl4.5
    private TextureParameteriv_adr := GetProcAddress('glTextureParameteriv');
    private ntv_TextureParameteriv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; var param: Int32)>(TextureParameteriv_adr);
    private ntv_TextureParameteriv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: glTextureParameterName; param: IntPtr)>(TextureParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: gl_texture; pname: glTextureParameterName; param: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (param<>nil) and (param.Length<>0) then
        ntv_TextureParameteriv_1(texture, pname, param[0]) else
        ntv_TextureParameteriv_1(texture, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: gl_texture; pname: glTextureParameterName; var param: Int32) :=
      ntv_TextureParameteriv_1(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: gl_texture; pname: glTextureParameterName; param: IntPtr) :=
      ntv_TextureParameteriv_2(texture, pname, param);
    
    // added in gl4.5
    private TextureStorage1D_adr := GetProcAddress('glTextureStorage1D');
    private ntv_TextureStorage1D_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalformat: glSizedInternalFormat; width: Int32)>(TextureStorage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage1D(texture: gl_texture; levels: Int32; internalformat: glSizedInternalFormat; width: Int32) :=
      ntv_TextureStorage1D_1(texture, levels, internalformat, width);
    
    // added in gl4.5
    private TextureStorage2D_adr := GetProcAddress('glTextureStorage2D');
    private ntv_TextureStorage2D_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32)>(TextureStorage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2D(texture: gl_texture; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32) :=
      ntv_TextureStorage2D_1(texture, levels, internalformat, width, height);
    
    // added in gl4.5
    private TextureStorage2DMultisample_adr := GetProcAddress('glTextureStorage2DMultisample');
    private ntv_TextureStorage2DMultisample_1 := GetProcOrNil&<procedure(texture: gl_texture; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: glBool8)>(TextureStorage2DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2DMultisample(texture: gl_texture; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: glBool8) :=
      ntv_TextureStorage2DMultisample_1(texture, samples, internalformat, width, height, fixedsamplelocations);
    
    // added in gl4.5
    private TextureStorage3D_adr := GetProcAddress('glTextureStorage3D');
    private ntv_TextureStorage3D_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32)>(TextureStorage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3D(texture: gl_texture; levels: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32) :=
      ntv_TextureStorage3D_1(texture, levels, internalformat, width, height, depth);
    
    // added in gl4.5
    private TextureStorage3DMultisample_adr := GetProcAddress('glTextureStorage3DMultisample');
    private ntv_TextureStorage3DMultisample_1 := GetProcOrNil&<procedure(texture: gl_texture; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: glBool8)>(TextureStorage3DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3DMultisample(texture: gl_texture; samples: Int32; internalformat: glSizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: glBool8) :=
      ntv_TextureStorage3DMultisample_1(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
    
    // added in gl4.5
    private TextureSubImage1D_adr := GetProcAddress('glTextureSubImage1D');
    private ntv_TextureSubImage1D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; width: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TextureSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage1D(texture: gl_texture; level: Int32; xoffset: Int32; width: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TextureSubImage1D_1(texture, level, xoffset, width, format, &type, pixels);
    
    // added in gl4.5
    private TextureSubImage2D_adr := GetProcAddress('glTextureSubImage2D');
    private ntv_TextureSubImage2D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TextureSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage2D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TextureSubImage2D_1(texture, level, xoffset, yoffset, width, height, format, &type, pixels);
    
    // added in gl4.5
    private TextureSubImage3D_adr := GetProcAddress('glTextureSubImage3D');
    private ntv_TextureSubImage3D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(TextureSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage3D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_TextureSubImage3D_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
    // added in gl4.3
    private TextureView_adr := GetProcAddress('glTextureView');
    private ntv_TextureView_1 := GetProcOrNil&<procedure(texture: gl_texture; target: glTextureTarget; origtexture: gl_texture; internalformat: glSizedInternalFormat; minlevel: UInt32; numlevels: UInt32; minlayer: UInt32; numlayers: UInt32)>(TextureView_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureView(texture: gl_texture; target: glTextureTarget; origtexture: gl_texture; internalformat: glSizedInternalFormat; minlevel: UInt32; numlevels: UInt32; minlayer: UInt32; numlayers: UInt32) :=
      ntv_TextureView_1(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
    
    // added in gl4.5
    private TransformFeedbackBufferBase_adr := GetProcAddress('glTransformFeedbackBufferBase');
    private ntv_TransformFeedbackBufferBase_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; index: UInt32; buffer: gl_buffer)>(TransformFeedbackBufferBase_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackBufferBase(xfb: gl_transform_feedback; index: UInt32; buffer: gl_buffer) :=
      ntv_TransformFeedbackBufferBase_1(xfb, index, buffer);
    
    // added in gl4.5
    private TransformFeedbackBufferRange_adr := GetProcAddress('glTransformFeedbackBufferRange');
    private ntv_TransformFeedbackBufferRange_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(TransformFeedbackBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackBufferRange(xfb: gl_transform_feedback; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
      ntv_TransformFeedbackBufferRange_1(xfb, index, buffer, offset, size);
    
    // added in gl3.0
    private TransformFeedbackVaryings_adr := GetProcAddress('glTransformFeedbackVaryings');
    private ntv_TransformFeedbackVaryings_1 := GetProcOrNil&<procedure(&program: gl_program; count: Int32; var varyings: IntPtr; bufferMode: glTransformFeedbackBufferMode)>(TransformFeedbackVaryings_adr);
    private ntv_TransformFeedbackVaryings_2 := GetProcOrNil&<procedure(&program: gl_program; count: Int32; varyings: pointer; bufferMode: glTransformFeedbackBufferMode)>(TransformFeedbackVaryings_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryings(&program: gl_program; count: Int32; varyings: array of string; bufferMode: glTransformFeedbackBufferMode);
    begin
      if (varyings=nil) or (varyings.Length=0) then
      begin
        ntv_TransformFeedbackVaryings_2(&program, count, nil, bufferMode);
        exit;
      end;
      var varyings_temp_arr: array of IntPtr;
      try
        begin
          var varyings_org_el_1 := varyings;
          var varyings_len_1 := varyings_org_el_1.Length;
          SetLength(varyings_temp_arr, varyings_len_1);
          var varyings_tmp_el_1 := varyings_temp_arr;
          for var varyings_ind_1 := 0 to varyings_len_1-1 do
          begin
            var varyings_org_el_2 := varyings_org_el_1[varyings_ind_1];
            if (varyings_org_el_2=nil) or (varyings_org_el_2.Length=0) then continue;
            varyings_tmp_el_1[varyings_ind_1] := Marshal.StringToHGlobalAnsi(varyings_org_el_2);
          end;
        end;
        ntv_TransformFeedbackVaryings_1(&program, count, varyings_temp_arr[0], bufferMode);
      finally
         foreach var arr_el1 in varyings_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryings(&program: gl_program; count: Int32; var varyings: IntPtr; bufferMode: glTransformFeedbackBufferMode) :=
      ntv_TransformFeedbackVaryings_1(&program, count, varyings, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryings(&program: gl_program; count: Int32; varyings: pointer; bufferMode: glTransformFeedbackBufferMode) :=
      ntv_TransformFeedbackVaryings_2(&program, count, varyings, bufferMode);
    
    // added in gl4.0
    private Uniform1d_adr := GetProcAddress('glUniform1d');
    private ntv_Uniform1d_1 := GetProcOrNil&<procedure(location: Int32; x: double)>(Uniform1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1d(location: Int32; x: double) :=
      ntv_Uniform1d_1(location, x);
    
    // added in gl4.0
    private Uniform1dv_adr := GetProcAddress('glUniform1dv');
    private ntv_Uniform1dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: double)>(Uniform1dv_adr);
    private ntv_Uniform1dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform1dv_1(location, count, value[0]) else
        ntv_Uniform1dv_1(location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; var value: double) :=
      ntv_Uniform1dv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform1dv_2(location, count, value);
    
    // added in gl2.0
    private Uniform1f_adr := GetProcAddress('glUniform1f');
    private ntv_Uniform1f_1 := GetProcOrNil&<procedure(location: Int32; v0: single)>(Uniform1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1f(location: Int32; v0: single) :=
      ntv_Uniform1f_1(location, v0);
    
    // added in gl2.0
    private Uniform1fv_adr := GetProcAddress('glUniform1fv');
    private ntv_Uniform1fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: single)>(Uniform1fv_adr);
    private ntv_Uniform1fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform1fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fv(location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform1fv_1(location, count, value[0]) else
        ntv_Uniform1fv_1(location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fv(location: Int32; count: Int32; var value: single) :=
      ntv_Uniform1fv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform1fv_2(location, count, value);
    
    // added in gl2.0
    private Uniform1i_adr := GetProcAddress('glUniform1i');
    private ntv_Uniform1i_1 := GetProcOrNil&<procedure(location: Int32; v0: Int32)>(Uniform1i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i(location: Int32; v0: Int32) :=
      ntv_Uniform1i_1(location, v0);
    
    // added in gl2.0
    private Uniform1iv_adr := GetProcAddress('glUniform1iv');
    private ntv_Uniform1iv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int32)>(Uniform1iv_adr);
    private ntv_Uniform1iv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform1iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1iv(location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform1iv_1(location, count, value[0]) else
        ntv_Uniform1iv_1(location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1iv(location: Int32; count: Int32; var value: Int32) :=
      ntv_Uniform1iv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1iv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform1iv_2(location, count, value);
    
    // added in gl3.0
    private Uniform1ui_adr := GetProcAddress('glUniform1ui');
    private ntv_Uniform1ui_1 := GetProcOrNil&<procedure(location: Int32; v0: UInt32)>(Uniform1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui(location: Int32; v0: UInt32) :=
      ntv_Uniform1ui_1(location, v0);
    
    // added in gl3.0
    private Uniform1uiv_adr := GetProcAddress('glUniform1uiv');
    private ntv_Uniform1uiv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt32)>(Uniform1uiv_adr);
    private ntv_Uniform1uiv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uiv(location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform1uiv_1(location, count, value[0]) else
        ntv_Uniform1uiv_1(location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uiv(location: Int32; count: Int32; var value: UInt32) :=
      ntv_Uniform1uiv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uiv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform1uiv_2(location, count, value);
    
    // added in gl4.0
    private Uniform2d_adr := GetProcAddress('glUniform2d');
    private ntv_Uniform2d_1 := GetProcOrNil&<procedure(location: Int32; x: double; y: double)>(Uniform2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2d(location: Int32; x: double; y: double) :=
      ntv_Uniform2d_1(location, x, y);
    
    // added in gl4.0
    private Uniform2dv_adr := GetProcAddress('glUniform2dv');
    private ntv_Uniform2dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: double)>(Uniform2dv_adr);
    private ntv_Uniform2dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2d)>(Uniform2dv_adr);
    private ntv_Uniform2dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform2dv_1(location, count, value[0]) else
        ntv_Uniform2dv_1(location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; var value: Vec2d) :=
      ntv_Uniform2dv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; var value: double) :=
      ntv_Uniform2dv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform2dv_3(location, count, value);
    
    // added in gl2.0
    private Uniform2f_adr := GetProcAddress('glUniform2f');
    private ntv_Uniform2f_1 := GetProcOrNil&<procedure(location: Int32; v0: single; v1: single)>(Uniform2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2f(location: Int32; v0: single; v1: single) :=
      ntv_Uniform2f_1(location, v0, v1);
    
    // added in gl2.0
    private Uniform2fv_adr := GetProcAddress('glUniform2fv');
    private ntv_Uniform2fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: single)>(Uniform2fv_adr);
    private ntv_Uniform2fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2f)>(Uniform2fv_adr);
    private ntv_Uniform2fv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fv(location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform2fv_1(location, count, value[0]) else
        ntv_Uniform2fv_1(location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fv(location: Int32; count: Int32; var value: Vec2f) :=
      ntv_Uniform2fv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fv(location: Int32; count: Int32; var value: single) :=
      ntv_Uniform2fv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform2fv_3(location, count, value);
    
    // added in gl2.0
    private Uniform2i_adr := GetProcAddress('glUniform2i');
    private ntv_Uniform2i_1 := GetProcOrNil&<procedure(location: Int32; v0: Int32; v1: Int32)>(Uniform2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i(location: Int32; v0: Int32; v1: Int32) :=
      ntv_Uniform2i_1(location, v0, v1);
    
    // added in gl2.0
    private Uniform2iv_adr := GetProcAddress('glUniform2iv');
    private ntv_Uniform2iv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int32)>(Uniform2iv_adr);
    private ntv_Uniform2iv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2i)>(Uniform2iv_adr);
    private ntv_Uniform2iv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2iv(location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform2iv_1(location, count, value[0]) else
        ntv_Uniform2iv_1(location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2iv(location: Int32; count: Int32; var value: Vec2i) :=
      ntv_Uniform2iv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2iv(location: Int32; count: Int32; var value: Int32) :=
      ntv_Uniform2iv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2iv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform2iv_3(location, count, value);
    
    // added in gl3.0
    private Uniform2ui_adr := GetProcAddress('glUniform2ui');
    private ntv_Uniform2ui_1 := GetProcOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32)>(Uniform2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui(location: Int32; v0: UInt32; v1: UInt32) :=
      ntv_Uniform2ui_1(location, v0, v1);
    
    // added in gl3.0
    private Uniform2uiv_adr := GetProcAddress('glUniform2uiv');
    private ntv_Uniform2uiv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt32)>(Uniform2uiv_adr);
    private ntv_Uniform2uiv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2ui)>(Uniform2uiv_adr);
    private ntv_Uniform2uiv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uiv(location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform2uiv_1(location, count, value[0]) else
        ntv_Uniform2uiv_1(location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uiv(location: Int32; count: Int32; var value: Vec2ui) :=
      ntv_Uniform2uiv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uiv(location: Int32; count: Int32; var value: UInt32) :=
      ntv_Uniform2uiv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uiv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform2uiv_3(location, count, value);
    
    // added in gl4.0
    private Uniform3d_adr := GetProcAddress('glUniform3d');
    private ntv_Uniform3d_1 := GetProcOrNil&<procedure(location: Int32; x: double; y: double; z: double)>(Uniform3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3d(location: Int32; x: double; y: double; z: double) :=
      ntv_Uniform3d_1(location, x, y, z);
    
    // added in gl4.0
    private Uniform3dv_adr := GetProcAddress('glUniform3dv');
    private ntv_Uniform3dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: double)>(Uniform3dv_adr);
    private ntv_Uniform3dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3d)>(Uniform3dv_adr);
    private ntv_Uniform3dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform3dv_1(location, count, value[0]) else
        ntv_Uniform3dv_1(location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; var value: Vec3d) :=
      ntv_Uniform3dv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; var value: double) :=
      ntv_Uniform3dv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform3dv_3(location, count, value);
    
    // added in gl2.0
    private Uniform3f_adr := GetProcAddress('glUniform3f');
    private ntv_Uniform3f_1 := GetProcOrNil&<procedure(location: Int32; v0: single; v1: single; v2: single)>(Uniform3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3f(location: Int32; v0: single; v1: single; v2: single) :=
      ntv_Uniform3f_1(location, v0, v1, v2);
    
    // added in gl2.0
    private Uniform3fv_adr := GetProcAddress('glUniform3fv');
    private ntv_Uniform3fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: single)>(Uniform3fv_adr);
    private ntv_Uniform3fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3f)>(Uniform3fv_adr);
    private ntv_Uniform3fv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fv(location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform3fv_1(location, count, value[0]) else
        ntv_Uniform3fv_1(location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fv(location: Int32; count: Int32; var value: Vec3f) :=
      ntv_Uniform3fv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fv(location: Int32; count: Int32; var value: single) :=
      ntv_Uniform3fv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform3fv_3(location, count, value);
    
    // added in gl2.0
    private Uniform3i_adr := GetProcAddress('glUniform3i');
    private ntv_Uniform3i_1 := GetProcOrNil&<procedure(location: Int32; v0: Int32; v1: Int32; v2: Int32)>(Uniform3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i(location: Int32; v0: Int32; v1: Int32; v2: Int32) :=
      ntv_Uniform3i_1(location, v0, v1, v2);
    
    // added in gl2.0
    private Uniform3iv_adr := GetProcAddress('glUniform3iv');
    private ntv_Uniform3iv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int32)>(Uniform3iv_adr);
    private ntv_Uniform3iv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3i)>(Uniform3iv_adr);
    private ntv_Uniform3iv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3iv(location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform3iv_1(location, count, value[0]) else
        ntv_Uniform3iv_1(location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3iv(location: Int32; count: Int32; var value: Vec3i) :=
      ntv_Uniform3iv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3iv(location: Int32; count: Int32; var value: Int32) :=
      ntv_Uniform3iv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3iv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform3iv_3(location, count, value);
    
    // added in gl3.0
    private Uniform3ui_adr := GetProcAddress('glUniform3ui');
    private ntv_Uniform3ui_1 := GetProcOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32)>(Uniform3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32) :=
      ntv_Uniform3ui_1(location, v0, v1, v2);
    
    // added in gl3.0
    private Uniform3uiv_adr := GetProcAddress('glUniform3uiv');
    private ntv_Uniform3uiv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt32)>(Uniform3uiv_adr);
    private ntv_Uniform3uiv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3ui)>(Uniform3uiv_adr);
    private ntv_Uniform3uiv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uiv(location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform3uiv_1(location, count, value[0]) else
        ntv_Uniform3uiv_1(location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uiv(location: Int32; count: Int32; var value: Vec3ui) :=
      ntv_Uniform3uiv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uiv(location: Int32; count: Int32; var value: UInt32) :=
      ntv_Uniform3uiv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uiv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform3uiv_3(location, count, value);
    
    // added in gl4.0
    private Uniform4d_adr := GetProcAddress('glUniform4d');
    private ntv_Uniform4d_1 := GetProcOrNil&<procedure(location: Int32; x: double; y: double; z: double; w: double)>(Uniform4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4d(location: Int32; x: double; y: double; z: double; w: double) :=
      ntv_Uniform4d_1(location, x, y, z, w);
    
    // added in gl4.0
    private Uniform4dv_adr := GetProcAddress('glUniform4dv');
    private ntv_Uniform4dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: double)>(Uniform4dv_adr);
    private ntv_Uniform4dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4d)>(Uniform4dv_adr);
    private ntv_Uniform4dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform4dv_1(location, count, value[0]) else
        ntv_Uniform4dv_1(location, count, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; var value: Vec4d) :=
      ntv_Uniform4dv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; var value: double) :=
      ntv_Uniform4dv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform4dv_3(location, count, value);
    
    // added in gl2.0
    private Uniform4f_adr := GetProcAddress('glUniform4f');
    private ntv_Uniform4f_1 := GetProcOrNil&<procedure(location: Int32; v0: single; v1: single; v2: single; v3: single)>(Uniform4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4f(location: Int32; v0: single; v1: single; v2: single; v3: single) :=
      ntv_Uniform4f_1(location, v0, v1, v2, v3);
    
    // added in gl2.0
    private Uniform4fv_adr := GetProcAddress('glUniform4fv');
    private ntv_Uniform4fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: single)>(Uniform4fv_adr);
    private ntv_Uniform4fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4f)>(Uniform4fv_adr);
    private ntv_Uniform4fv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fv(location: Int32; count: Int32; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform4fv_1(location, count, value[0]) else
        ntv_Uniform4fv_1(location, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fv(location: Int32; count: Int32; var value: Vec4f) :=
      ntv_Uniform4fv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fv(location: Int32; count: Int32; var value: single) :=
      ntv_Uniform4fv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform4fv_3(location, count, value);
    
    // added in gl2.0
    private Uniform4i_adr := GetProcAddress('glUniform4i');
    private ntv_Uniform4i_1 := GetProcOrNil&<procedure(location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32)>(Uniform4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i(location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32) :=
      ntv_Uniform4i_1(location, v0, v1, v2, v3);
    
    // added in gl2.0
    private Uniform4iv_adr := GetProcAddress('glUniform4iv');
    private ntv_Uniform4iv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int32)>(Uniform4iv_adr);
    private ntv_Uniform4iv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4i)>(Uniform4iv_adr);
    private ntv_Uniform4iv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4iv(location: Int32; count: Int32; value: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform4iv_1(location, count, value[0]) else
        ntv_Uniform4iv_1(location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4iv(location: Int32; count: Int32; var value: Vec4i) :=
      ntv_Uniform4iv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4iv(location: Int32; count: Int32; var value: Int32) :=
      ntv_Uniform4iv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4iv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform4iv_3(location, count, value);
    
    // added in gl3.0
    private Uniform4ui_adr := GetProcAddress('glUniform4ui');
    private ntv_Uniform4ui_1 := GetProcOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32)>(Uniform4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32) :=
      ntv_Uniform4ui_1(location, v0, v1, v2, v3);
    
    // added in gl3.0
    private Uniform4uiv_adr := GetProcAddress('glUniform4uiv');
    private ntv_Uniform4uiv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt32)>(Uniform4uiv_adr);
    private ntv_Uniform4uiv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4ui)>(Uniform4uiv_adr);
    private ntv_Uniform4uiv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(Uniform4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uiv(location: Int32; count: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_Uniform4uiv_1(location, count, value[0]) else
        ntv_Uniform4uiv_1(location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uiv(location: Int32; count: Int32; var value: Vec4ui) :=
      ntv_Uniform4uiv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uiv(location: Int32; count: Int32; var value: UInt32) :=
      ntv_Uniform4uiv_1(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uiv(location: Int32; count: Int32; value: IntPtr) :=
      ntv_Uniform4uiv_3(location, count, value);
    
    // added in gl3.1
    private UniformBlockBinding_adr := GetProcAddress('glUniformBlockBinding');
    private ntv_UniformBlockBinding_1 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; uniformBlockBinding: UInt32)>(UniformBlockBinding_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformBlockBinding(&program: gl_program; uniformBlockIndex: UInt32; uniformBlockBinding: UInt32) :=
      ntv_UniformBlockBinding_1(&program, uniformBlockIndex, uniformBlockBinding);
    
    // added in gl4.0
    private UniformMatrix2dv_adr := GetProcAddress('glUniformMatrix2dv');
    private ntv_UniformMatrix2dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix2dv_adr);
    private ntv_UniformMatrix2dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2d)>(UniformMatrix2dv_adr);
    private ntv_UniformMatrix2dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix2dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix2dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2d) :=
      ntv_UniformMatrix2dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix2dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix2dv_3(location, count, transpose, value);
    
    // added in gl2.0
    private UniformMatrix2fv_adr := GetProcAddress('glUniformMatrix2fv');
    private ntv_UniformMatrix2fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: single)>(UniformMatrix2fv_adr);
    private ntv_UniformMatrix2fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2f)>(UniformMatrix2fv_adr);
    private ntv_UniformMatrix2fv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix2fv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix2fv_1(location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2f) :=
      ntv_UniformMatrix2fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_UniformMatrix2fv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix2fv_3(location, count, transpose, value);
    
    // added in gl4.0
    private UniformMatrix2x3dv_adr := GetProcAddress('glUniformMatrix2x3dv');
    private ntv_UniformMatrix2x3dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix2x3dv_adr);
    private ntv_UniformMatrix2x3dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3d)>(UniformMatrix2x3dv_adr);
    private ntv_UniformMatrix2x3dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix2x3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix2x3dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix2x3dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3d) :=
      ntv_UniformMatrix2x3dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix2x3dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix2x3dv_3(location, count, transpose, value);
    
    // added in gl2.1
    private UniformMatrix2x3fv_adr := GetProcAddress('glUniformMatrix2x3fv');
    private ntv_UniformMatrix2x3fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: single)>(UniformMatrix2x3fv_adr);
    private ntv_UniformMatrix2x3fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3f)>(UniformMatrix2x3fv_adr);
    private ntv_UniformMatrix2x3fv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix2x3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix2x3fv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix2x3fv_1(location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x3f) :=
      ntv_UniformMatrix2x3fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_UniformMatrix2x3fv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix2x3fv_3(location, count, transpose, value);
    
    // added in gl4.0
    private UniformMatrix2x4dv_adr := GetProcAddress('glUniformMatrix2x4dv');
    private ntv_UniformMatrix2x4dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix2x4dv_adr);
    private ntv_UniformMatrix2x4dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4d)>(UniformMatrix2x4dv_adr);
    private ntv_UniformMatrix2x4dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix2x4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix2x4dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix2x4dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4d) :=
      ntv_UniformMatrix2x4dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix2x4dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix2x4dv_3(location, count, transpose, value);
    
    // added in gl2.1
    private UniformMatrix2x4fv_adr := GetProcAddress('glUniformMatrix2x4fv');
    private ntv_UniformMatrix2x4fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: single)>(UniformMatrix2x4fv_adr);
    private ntv_UniformMatrix2x4fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4f)>(UniformMatrix2x4fv_adr);
    private ntv_UniformMatrix2x4fv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix2x4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix2x4fv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix2x4fv_1(location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr2x4f) :=
      ntv_UniformMatrix2x4fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_UniformMatrix2x4fv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix2x4fv_3(location, count, transpose, value);
    
    // added in gl4.0
    private UniformMatrix3dv_adr := GetProcAddress('glUniformMatrix3dv');
    private ntv_UniformMatrix3dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix3dv_adr);
    private ntv_UniformMatrix3dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3d)>(UniformMatrix3dv_adr);
    private ntv_UniformMatrix3dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix3dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix3dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3d) :=
      ntv_UniformMatrix3dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix3dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix3dv_3(location, count, transpose, value);
    
    // added in gl2.0
    private UniformMatrix3fv_adr := GetProcAddress('glUniformMatrix3fv');
    private ntv_UniformMatrix3fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: single)>(UniformMatrix3fv_adr);
    private ntv_UniformMatrix3fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3f)>(UniformMatrix3fv_adr);
    private ntv_UniformMatrix3fv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix3fv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix3fv_1(location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3f) :=
      ntv_UniformMatrix3fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_UniformMatrix3fv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix3fv_3(location, count, transpose, value);
    
    // added in gl4.0
    private UniformMatrix3x2dv_adr := GetProcAddress('glUniformMatrix3x2dv');
    private ntv_UniformMatrix3x2dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix3x2dv_adr);
    private ntv_UniformMatrix3x2dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2d)>(UniformMatrix3x2dv_adr);
    private ntv_UniformMatrix3x2dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix3x2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix3x2dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix3x2dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2d) :=
      ntv_UniformMatrix3x2dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix3x2dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix3x2dv_3(location, count, transpose, value);
    
    // added in gl2.1
    private UniformMatrix3x2fv_adr := GetProcAddress('glUniformMatrix3x2fv');
    private ntv_UniformMatrix3x2fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: single)>(UniformMatrix3x2fv_adr);
    private ntv_UniformMatrix3x2fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2f)>(UniformMatrix3x2fv_adr);
    private ntv_UniformMatrix3x2fv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix3x2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix3x2fv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix3x2fv_1(location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x2f) :=
      ntv_UniformMatrix3x2fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_UniformMatrix3x2fv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix3x2fv_3(location, count, transpose, value);
    
    // added in gl4.0
    private UniformMatrix3x4dv_adr := GetProcAddress('glUniformMatrix3x4dv');
    private ntv_UniformMatrix3x4dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix3x4dv_adr);
    private ntv_UniformMatrix3x4dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4d)>(UniformMatrix3x4dv_adr);
    private ntv_UniformMatrix3x4dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix3x4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix3x4dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix3x4dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4d) :=
      ntv_UniformMatrix3x4dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix3x4dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix3x4dv_3(location, count, transpose, value);
    
    // added in gl2.1
    private UniformMatrix3x4fv_adr := GetProcAddress('glUniformMatrix3x4fv');
    private ntv_UniformMatrix3x4fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: single)>(UniformMatrix3x4fv_adr);
    private ntv_UniformMatrix3x4fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4f)>(UniformMatrix3x4fv_adr);
    private ntv_UniformMatrix3x4fv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix3x4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix3x4fv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix3x4fv_1(location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr3x4f) :=
      ntv_UniformMatrix3x4fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_UniformMatrix3x4fv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix3x4fv_3(location, count, transpose, value);
    
    // added in gl4.0
    private UniformMatrix4dv_adr := GetProcAddress('glUniformMatrix4dv');
    private ntv_UniformMatrix4dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix4dv_adr);
    private ntv_UniformMatrix4dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4d)>(UniformMatrix4dv_adr);
    private ntv_UniformMatrix4dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix4dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix4dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4d) :=
      ntv_UniformMatrix4dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix4dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix4dv_3(location, count, transpose, value);
    
    // added in gl2.0
    private UniformMatrix4fv_adr := GetProcAddress('glUniformMatrix4fv');
    private ntv_UniformMatrix4fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: single)>(UniformMatrix4fv_adr);
    private ntv_UniformMatrix4fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4f)>(UniformMatrix4fv_adr);
    private ntv_UniformMatrix4fv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix4fv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix4fv_1(location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4f) :=
      ntv_UniformMatrix4fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_UniformMatrix4fv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix4fv_3(location, count, transpose, value);
    
    // added in gl4.0
    private UniformMatrix4x2dv_adr := GetProcAddress('glUniformMatrix4x2dv');
    private ntv_UniformMatrix4x2dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix4x2dv_adr);
    private ntv_UniformMatrix4x2dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2d)>(UniformMatrix4x2dv_adr);
    private ntv_UniformMatrix4x2dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix4x2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix4x2dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix4x2dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2d) :=
      ntv_UniformMatrix4x2dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix4x2dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix4x2dv_3(location, count, transpose, value);
    
    // added in gl2.1
    private UniformMatrix4x2fv_adr := GetProcAddress('glUniformMatrix4x2fv');
    private ntv_UniformMatrix4x2fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: single)>(UniformMatrix4x2fv_adr);
    private ntv_UniformMatrix4x2fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2f)>(UniformMatrix4x2fv_adr);
    private ntv_UniformMatrix4x2fv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix4x2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix4x2fv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix4x2fv_1(location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x2f) :=
      ntv_UniformMatrix4x2fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_UniformMatrix4x2fv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix4x2fv_3(location, count, transpose, value);
    
    // added in gl4.0
    private UniformMatrix4x3dv_adr := GetProcAddress('glUniformMatrix4x3dv');
    private ntv_UniformMatrix4x3dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: double)>(UniformMatrix4x3dv_adr);
    private ntv_UniformMatrix4x3dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3d)>(UniformMatrix4x3dv_adr);
    private ntv_UniformMatrix4x3dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix4x3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: glBool8; value: array of double);
    type PDouble = ^double;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix4x3dv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix4x3dv_1(location, count, transpose, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3d) :=
      ntv_UniformMatrix4x3dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: glBool8; var value: double) :=
      ntv_UniformMatrix4x3dv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix4x3dv_3(location, count, transpose, value);
    
    // added in gl2.1
    private UniformMatrix4x3fv_adr := GetProcAddress('glUniformMatrix4x3fv');
    private ntv_UniformMatrix4x3fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: single)>(UniformMatrix4x3fv_adr);
    private ntv_UniformMatrix4x3fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3f)>(UniformMatrix4x3fv_adr);
    private ntv_UniformMatrix4x3fv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: glBool8; value: IntPtr)>(UniformMatrix4x3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: glBool8; value: array of single);
    type PSingle = ^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_UniformMatrix4x3fv_1(location, count, transpose, value[0]) else
        ntv_UniformMatrix4x3fv_1(location, count, transpose, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: glBool8; var value: Mtr4x3f) :=
      ntv_UniformMatrix4x3fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: glBool8; var value: single) :=
      ntv_UniformMatrix4x3fv_1(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: glBool8; value: IntPtr) :=
      ntv_UniformMatrix4x3fv_3(location, count, transpose, value);
    
    // added in gl4.0
    private UniformSubroutinesuiv_adr := GetProcAddress('glUniformSubroutinesuiv');
    private ntv_UniformSubroutinesuiv_1 := GetProcOrNil&<procedure(shadertype: glShaderType; count: Int32; var indices: UInt32)>(UniformSubroutinesuiv_adr);
    private ntv_UniformSubroutinesuiv_2 := GetProcOrNil&<procedure(shadertype: glShaderType; count: Int32; indices: IntPtr)>(UniformSubroutinesuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformSubroutinesuiv(shadertype: glShaderType; count: Int32; indices: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (indices<>nil) and (indices.Length<>0) then
        ntv_UniformSubroutinesuiv_1(shadertype, count, indices[0]) else
        ntv_UniformSubroutinesuiv_1(shadertype, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformSubroutinesuiv(shadertype: glShaderType; count: Int32; var indices: UInt32) :=
      ntv_UniformSubroutinesuiv_1(shadertype, count, indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformSubroutinesuiv(shadertype: glShaderType; count: Int32; indices: IntPtr) :=
      ntv_UniformSubroutinesuiv_2(shadertype, count, indices);
    
    // added in gl1.5
    private UnmapBuffer_adr := GetProcAddress('glUnmapBuffer');
    private ntv_UnmapBuffer_1 := GetProcOrNil&<function(target: glBufferTarget): glBool8>(UnmapBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UnmapBuffer(target: glBufferTarget): glBool8 :=
      ntv_UnmapBuffer_1(target);
    
    // added in gl4.5
    private UnmapNamedBuffer_adr := GetProcAddress('glUnmapNamedBuffer');
    private ntv_UnmapNamedBuffer_1 := GetProcOrNil&<function(buffer: gl_buffer): glBool8>(UnmapNamedBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UnmapNamedBuffer(buffer: gl_buffer): glBool8 :=
      ntv_UnmapNamedBuffer_1(buffer);
    
    // added in gl2.0
    private UseProgram_adr := GetProcAddress('glUseProgram');
    private ntv_UseProgram_1 := GetProcOrNil&<procedure(&program: gl_program)>(UseProgram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseProgram(&program: gl_program) :=
      ntv_UseProgram_1(&program);
    
    // added in gl4.1
    private UseProgramStages_adr := GetProcAddress('glUseProgramStages');
    private ntv_UseProgramStages_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; stages: glUseProgramStageMask; &program: gl_program)>(UseProgramStages_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseProgramStages(pipeline: gl_program_pipeline; stages: glUseProgramStageMask; &program: gl_program) :=
      ntv_UseProgramStages_1(pipeline, stages, &program);
    
    // added in gl2.0
    private ValidateProgram_adr := GetProcAddress('glValidateProgram');
    private ntv_ValidateProgram_1 := GetProcOrNil&<procedure(&program: gl_program)>(ValidateProgram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ValidateProgram(&program: gl_program) :=
      ntv_ValidateProgram_1(&program);
    
    // added in gl4.1
    private ValidateProgramPipeline_adr := GetProcAddress('glValidateProgramPipeline');
    private ntv_ValidateProgramPipeline_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline)>(ValidateProgramPipeline_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ValidateProgramPipeline(pipeline: gl_program_pipeline) :=
      ntv_ValidateProgramPipeline_1(pipeline);
    
    // added in gl4.5
    private VertexArrayAttribBinding_adr := GetProcAddress('glVertexArrayAttribBinding');
    private ntv_VertexArrayAttribBinding_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; bindingindex: UInt32)>(VertexArrayAttribBinding_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribBinding(vaobj: gl_vertex_array; attribindex: UInt32; bindingindex: UInt32) :=
      ntv_VertexArrayAttribBinding_1(vaobj, attribindex, bindingindex);
    
    // added in gl4.5
    private VertexArrayAttribFormat_adr := GetProcAddress('glVertexArrayAttribFormat');
    private ntv_VertexArrayAttribFormat_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribType; normalized: glBool8; relativeoffset: UInt32)>(VertexArrayAttribFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribFormat(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribType; normalized: glBool8; relativeoffset: UInt32) :=
      ntv_VertexArrayAttribFormat_1(vaobj, attribindex, size, &type, normalized, relativeoffset);
    
    // added in gl4.5
    private VertexArrayAttribIFormat_adr := GetProcAddress('glVertexArrayAttribIFormat');
    private ntv_VertexArrayAttribIFormat_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribIType; relativeoffset: UInt32)>(VertexArrayAttribIFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribIFormat(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribIType; relativeoffset: UInt32) :=
      ntv_VertexArrayAttribIFormat_1(vaobj, attribindex, size, &type, relativeoffset);
    
    // added in gl4.5
    private VertexArrayAttribLFormat_adr := GetProcAddress('glVertexArrayAttribLFormat');
    private ntv_VertexArrayAttribLFormat_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribLType; relativeoffset: UInt32)>(VertexArrayAttribLFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribLFormat(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: glVertexAttribLType; relativeoffset: UInt32) :=
      ntv_VertexArrayAttribLFormat_1(vaobj, attribindex, size, &type, relativeoffset);
    
    // added in gl4.5
    private VertexArrayBindingDivisor_adr := GetProcAddress('glVertexArrayBindingDivisor');
    private ntv_VertexArrayBindingDivisor_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; bindingindex: UInt32; divisor: UInt32)>(VertexArrayBindingDivisor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayBindingDivisor(vaobj: gl_vertex_array; bindingindex: UInt32; divisor: UInt32) :=
      ntv_VertexArrayBindingDivisor_1(vaobj, bindingindex, divisor);
    
    // added in gl4.5
    private VertexArrayElementBuffer_adr := GetProcAddress('glVertexArrayElementBuffer');
    private ntv_VertexArrayElementBuffer_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer)>(VertexArrayElementBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayElementBuffer(vaobj: gl_vertex_array; buffer: gl_buffer) :=
      ntv_VertexArrayElementBuffer_1(vaobj, buffer);
    
    // added in gl4.5
    private VertexArrayVertexBuffer_adr := GetProcAddress('glVertexArrayVertexBuffer');
    private ntv_VertexArrayVertexBuffer_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32)>(VertexArrayVertexBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffer(vaobj: gl_vertex_array; bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32) :=
      ntv_VertexArrayVertexBuffer_1(vaobj, bindingindex, buffer, offset, stride);
    
    // added in gl4.5
    private VertexArrayVertexBuffers_adr := GetProcAddress('glVertexArrayVertexBuffers');
    private ntv_VertexArrayVertexBuffers_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var strides: Int32)>(VertexArrayVertexBuffers_adr);
    private ntv_VertexArrayVertexBuffers_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; strides: IntPtr)>(VertexArrayVertexBuffers_adr);
    private ntv_VertexArrayVertexBuffers_3 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var strides: Int32)>(VertexArrayVertexBuffers_adr);
    private ntv_VertexArrayVertexBuffers_4 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; strides: IntPtr)>(VertexArrayVertexBuffers_adr);
    private ntv_VertexArrayVertexBuffers_5 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var strides: Int32)>(VertexArrayVertexBuffers_adr);
    private ntv_VertexArrayVertexBuffers_6 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; strides: IntPtr)>(VertexArrayVertexBuffers_adr);
    private ntv_VertexArrayVertexBuffers_7 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var strides: Int32)>(VertexArrayVertexBuffers_adr);
    private ntv_VertexArrayVertexBuffers_8 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; strides: IntPtr)>(VertexArrayVertexBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: array of gl_buffer; offsets: array of IntPtr; strides: array of Int32);
    type PGl_buffer = ^gl_buffer;
    type PIntPtr = ^IntPtr;
    type PInt32 = ^Int32;
    begin
      if (strides<>nil) and (strides.Length<>0) then
        if (buffers<>nil) and (buffers.Length<>0) then
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_VertexArrayVertexBuffers_1(vaobj, first, count, buffers[0], offsets[0], strides[0]) else
            ntv_VertexArrayVertexBuffers_1(vaobj, first, count, buffers[0], PIntPtr(nil)^, strides[0]) else
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_VertexArrayVertexBuffers_1(vaobj, first, count, PGl_buffer(nil)^, offsets[0], strides[0]) else
            ntv_VertexArrayVertexBuffers_1(vaobj, first, count, PGl_buffer(nil)^, PIntPtr(nil)^, strides[0]) else
        if (buffers<>nil) and (buffers.Length<>0) then
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_VertexArrayVertexBuffers_1(vaobj, first, count, buffers[0], offsets[0], PInt32(nil)^) else
            ntv_VertexArrayVertexBuffers_1(vaobj, first, count, buffers[0], PIntPtr(nil)^, PInt32(nil)^) else
          if (offsets<>nil) and (offsets.Length<>0) then
            ntv_VertexArrayVertexBuffers_1(vaobj, first, count, PGl_buffer(nil)^, offsets[0], PInt32(nil)^) else
            ntv_VertexArrayVertexBuffers_1(vaobj, first, count, PGl_buffer(nil)^, PIntPtr(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var strides: Int32) :=
      ntv_VertexArrayVertexBuffers_1(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; strides: IntPtr) :=
      ntv_VertexArrayVertexBuffers_2(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var strides: Int32) :=
      ntv_VertexArrayVertexBuffers_3(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; strides: IntPtr) :=
      ntv_VertexArrayVertexBuffers_4(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var strides: Int32) :=
      ntv_VertexArrayVertexBuffers_5(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; strides: IntPtr) :=
      ntv_VertexArrayVertexBuffers_6(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var strides: Int32) :=
      ntv_VertexArrayVertexBuffers_7(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; strides: IntPtr) :=
      ntv_VertexArrayVertexBuffers_8(vaobj, first, count, buffers, offsets, strides);
    
    // added in gl2.0
    private VertexAttrib1d_adr := GetProcAddress('glVertexAttrib1d');
    private ntv_VertexAttrib1d_1 := GetProcOrNil&<procedure(index: UInt32; x: double)>(VertexAttrib1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1d(index: UInt32; x: double) :=
      ntv_VertexAttrib1d_1(index, x);
    
    // added in gl2.0
    private VertexAttrib1dv_adr := GetProcAddress('glVertexAttrib1dv');
    private ntv_VertexAttrib1dv_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttrib1dv_adr);
    private ntv_VertexAttrib1dv_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dv(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib1dv_1(index, v[0]) else
        ntv_VertexAttrib1dv_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dv(index: UInt32; var v: double) :=
      ntv_VertexAttrib1dv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib1dv_2(index, v);
    
    // added in gl2.0
    private VertexAttrib1f_adr := GetProcAddress('glVertexAttrib1f');
    private ntv_VertexAttrib1f_1 := GetProcOrNil&<procedure(index: UInt32; x: single)>(VertexAttrib1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1f(index: UInt32; x: single) :=
      ntv_VertexAttrib1f_1(index, x);
    
    // added in gl2.0
    private VertexAttrib1fv_adr := GetProcAddress('glVertexAttrib1fv');
    private ntv_VertexAttrib1fv_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(VertexAttrib1fv_adr);
    private ntv_VertexAttrib1fv_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib1fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fv(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib1fv_1(index, v[0]) else
        ntv_VertexAttrib1fv_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fv(index: UInt32; var v: single) :=
      ntv_VertexAttrib1fv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib1fv_2(index, v);
    
    // added in gl2.0
    private VertexAttrib1s_adr := GetProcAddress('glVertexAttrib1s');
    private ntv_VertexAttrib1s_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16)>(VertexAttrib1s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1s(index: UInt32; x: Int16) :=
      ntv_VertexAttrib1s_1(index, x);
    
    // added in gl2.0
    private VertexAttrib1sv_adr := GetProcAddress('glVertexAttrib1sv');
    private ntv_VertexAttrib1sv_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib1sv_adr);
    private ntv_VertexAttrib1sv_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib1sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sv(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib1sv_1(index, v[0]) else
        ntv_VertexAttrib1sv_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sv(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib1sv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib1sv_2(index, v);
    
    // added in gl2.0
    private VertexAttrib2d_adr := GetProcAddress('glVertexAttrib2d');
    private ntv_VertexAttrib2d_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double)>(VertexAttrib2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2d(index: UInt32; x: double; y: double) :=
      ntv_VertexAttrib2d_1(index, x, y);
    
    // added in gl2.0
    private VertexAttrib2dv_adr := GetProcAddress('glVertexAttrib2dv');
    private ntv_VertexAttrib2dv_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttrib2dv_adr);
    private ntv_VertexAttrib2dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2d)>(VertexAttrib2dv_adr);
    private ntv_VertexAttrib2dv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dv(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib2dv_1(index, v[0]) else
        ntv_VertexAttrib2dv_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dv(index: UInt32; var v: Vec2d) :=
      ntv_VertexAttrib2dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dv(index: UInt32; var v: double) :=
      ntv_VertexAttrib2dv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib2dv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib2f_adr := GetProcAddress('glVertexAttrib2f');
    private ntv_VertexAttrib2f_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single)>(VertexAttrib2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2f(index: UInt32; x: single; y: single) :=
      ntv_VertexAttrib2f_1(index, x, y);
    
    // added in gl2.0
    private VertexAttrib2fv_adr := GetProcAddress('glVertexAttrib2fv');
    private ntv_VertexAttrib2fv_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(VertexAttrib2fv_adr);
    private ntv_VertexAttrib2fv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2f)>(VertexAttrib2fv_adr);
    private ntv_VertexAttrib2fv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fv(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib2fv_1(index, v[0]) else
        ntv_VertexAttrib2fv_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fv(index: UInt32; var v: Vec2f) :=
      ntv_VertexAttrib2fv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fv(index: UInt32; var v: single) :=
      ntv_VertexAttrib2fv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib2fv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib2s_adr := GetProcAddress('glVertexAttrib2s');
    private ntv_VertexAttrib2s_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16)>(VertexAttrib2s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2s(index: UInt32; x: Int16; y: Int16) :=
      ntv_VertexAttrib2s_1(index, x, y);
    
    // added in gl2.0
    private VertexAttrib2sv_adr := GetProcAddress('glVertexAttrib2sv');
    private ntv_VertexAttrib2sv_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib2sv_adr);
    private ntv_VertexAttrib2sv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2s)>(VertexAttrib2sv_adr);
    private ntv_VertexAttrib2sv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib2sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sv(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib2sv_1(index, v[0]) else
        ntv_VertexAttrib2sv_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sv(index: UInt32; var v: Vec2s) :=
      ntv_VertexAttrib2sv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sv(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib2sv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib2sv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib3d_adr := GetProcAddress('glVertexAttrib3d');
    private ntv_VertexAttrib3d_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double; z: double)>(VertexAttrib3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3d(index: UInt32; x: double; y: double; z: double) :=
      ntv_VertexAttrib3d_1(index, x, y, z);
    
    // added in gl2.0
    private VertexAttrib3dv_adr := GetProcAddress('glVertexAttrib3dv');
    private ntv_VertexAttrib3dv_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttrib3dv_adr);
    private ntv_VertexAttrib3dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3d)>(VertexAttrib3dv_adr);
    private ntv_VertexAttrib3dv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dv(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib3dv_1(index, v[0]) else
        ntv_VertexAttrib3dv_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dv(index: UInt32; var v: Vec3d) :=
      ntv_VertexAttrib3dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dv(index: UInt32; var v: double) :=
      ntv_VertexAttrib3dv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib3dv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib3f_adr := GetProcAddress('glVertexAttrib3f');
    private ntv_VertexAttrib3f_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; z: single)>(VertexAttrib3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3f(index: UInt32; x: single; y: single; z: single) :=
      ntv_VertexAttrib3f_1(index, x, y, z);
    
    // added in gl2.0
    private VertexAttrib3fv_adr := GetProcAddress('glVertexAttrib3fv');
    private ntv_VertexAttrib3fv_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(VertexAttrib3fv_adr);
    private ntv_VertexAttrib3fv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3f)>(VertexAttrib3fv_adr);
    private ntv_VertexAttrib3fv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fv(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib3fv_1(index, v[0]) else
        ntv_VertexAttrib3fv_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fv(index: UInt32; var v: Vec3f) :=
      ntv_VertexAttrib3fv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fv(index: UInt32; var v: single) :=
      ntv_VertexAttrib3fv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib3fv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib3s_adr := GetProcAddress('glVertexAttrib3s');
    private ntv_VertexAttrib3s_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16)>(VertexAttrib3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3s(index: UInt32; x: Int16; y: Int16; z: Int16) :=
      ntv_VertexAttrib3s_1(index, x, y, z);
    
    // added in gl2.0
    private VertexAttrib3sv_adr := GetProcAddress('glVertexAttrib3sv');
    private ntv_VertexAttrib3sv_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib3sv_adr);
    private ntv_VertexAttrib3sv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3s)>(VertexAttrib3sv_adr);
    private ntv_VertexAttrib3sv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sv(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib3sv_1(index, v[0]) else
        ntv_VertexAttrib3sv_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sv(index: UInt32; var v: Vec3s) :=
      ntv_VertexAttrib3sv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sv(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib3sv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib3sv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib4bv_adr := GetProcAddress('glVertexAttrib4bv');
    private ntv_VertexAttrib4bv_1 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(VertexAttrib4bv_adr);
    private ntv_VertexAttrib4bv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4b)>(VertexAttrib4bv_adr);
    private ntv_VertexAttrib4bv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4bv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bv(index: UInt32; v: array of SByte);
    type PSByte = ^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4bv_1(index, v[0]) else
        ntv_VertexAttrib4bv_1(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bv(index: UInt32; var v: Vec4b) :=
      ntv_VertexAttrib4bv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bv(index: UInt32; var v: SByte) :=
      ntv_VertexAttrib4bv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4bv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib4d_adr := GetProcAddress('glVertexAttrib4d');
    private ntv_VertexAttrib4d_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double; z: double; w: double)>(VertexAttrib4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4d(index: UInt32; x: double; y: double; z: double; w: double) :=
      ntv_VertexAttrib4d_1(index, x, y, z, w);
    
    // added in gl2.0
    private VertexAttrib4dv_adr := GetProcAddress('glVertexAttrib4dv');
    private ntv_VertexAttrib4dv_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttrib4dv_adr);
    private ntv_VertexAttrib4dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4d)>(VertexAttrib4dv_adr);
    private ntv_VertexAttrib4dv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dv(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4dv_1(index, v[0]) else
        ntv_VertexAttrib4dv_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dv(index: UInt32; var v: Vec4d) :=
      ntv_VertexAttrib4dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dv(index: UInt32; var v: double) :=
      ntv_VertexAttrib4dv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4dv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib4f_adr := GetProcAddress('glVertexAttrib4f');
    private ntv_VertexAttrib4f_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; z: single; w: single)>(VertexAttrib4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4f(index: UInt32; x: single; y: single; z: single; w: single) :=
      ntv_VertexAttrib4f_1(index, x, y, z, w);
    
    // added in gl2.0
    private VertexAttrib4fv_adr := GetProcAddress('glVertexAttrib4fv');
    private ntv_VertexAttrib4fv_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(VertexAttrib4fv_adr);
    private ntv_VertexAttrib4fv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4f)>(VertexAttrib4fv_adr);
    private ntv_VertexAttrib4fv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fv(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4fv_1(index, v[0]) else
        ntv_VertexAttrib4fv_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fv(index: UInt32; var v: Vec4f) :=
      ntv_VertexAttrib4fv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fv(index: UInt32; var v: single) :=
      ntv_VertexAttrib4fv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4fv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib4iv_adr := GetProcAddress('glVertexAttrib4iv');
    private ntv_VertexAttrib4iv_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttrib4iv_adr);
    private ntv_VertexAttrib4iv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4i)>(VertexAttrib4iv_adr);
    private ntv_VertexAttrib4iv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4iv(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4iv_1(index, v[0]) else
        ntv_VertexAttrib4iv_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4iv(index: UInt32; var v: Vec4i) :=
      ntv_VertexAttrib4iv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4iv(index: UInt32; var v: Int32) :=
      ntv_VertexAttrib4iv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4iv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4iv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib4Nbv_adr := GetProcAddress('glVertexAttrib4Nbv');
    private ntv_VertexAttrib4Nbv_1 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(VertexAttrib4Nbv_adr);
    private ntv_VertexAttrib4Nbv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4b)>(VertexAttrib4Nbv_adr);
    private ntv_VertexAttrib4Nbv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4Nbv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nbv(index: UInt32; v: array of SByte);
    type PSByte = ^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4Nbv_1(index, v[0]) else
        ntv_VertexAttrib4Nbv_1(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nbv(index: UInt32; var v: Vec4b) :=
      ntv_VertexAttrib4Nbv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nbv(index: UInt32; var v: SByte) :=
      ntv_VertexAttrib4Nbv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nbv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4Nbv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib4Niv_adr := GetProcAddress('glVertexAttrib4Niv');
    private ntv_VertexAttrib4Niv_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttrib4Niv_adr);
    private ntv_VertexAttrib4Niv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4i)>(VertexAttrib4Niv_adr);
    private ntv_VertexAttrib4Niv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4Niv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Niv(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4Niv_1(index, v[0]) else
        ntv_VertexAttrib4Niv_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Niv(index: UInt32; var v: Vec4i) :=
      ntv_VertexAttrib4Niv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Niv(index: UInt32; var v: Int32) :=
      ntv_VertexAttrib4Niv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Niv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4Niv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib4Nsv_adr := GetProcAddress('glVertexAttrib4Nsv');
    private ntv_VertexAttrib4Nsv_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib4Nsv_adr);
    private ntv_VertexAttrib4Nsv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4s)>(VertexAttrib4Nsv_adr);
    private ntv_VertexAttrib4Nsv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4Nsv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nsv(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4Nsv_1(index, v[0]) else
        ntv_VertexAttrib4Nsv_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nsv(index: UInt32; var v: Vec4s) :=
      ntv_VertexAttrib4Nsv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nsv(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib4Nsv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nsv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4Nsv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib4Nub_adr := GetProcAddress('glVertexAttrib4Nub');
    private ntv_VertexAttrib4Nub_1 := GetProcOrNil&<procedure(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte)>(VertexAttrib4Nub_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nub(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte) :=
      ntv_VertexAttrib4Nub_1(index, x, y, z, w);
    
    // added in gl2.0
    private VertexAttrib4Nubv_adr := GetProcAddress('glVertexAttrib4Nubv');
    private ntv_VertexAttrib4Nubv_1 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(VertexAttrib4Nubv_adr);
    private ntv_VertexAttrib4Nubv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ub)>(VertexAttrib4Nubv_adr);
    private ntv_VertexAttrib4Nubv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4Nubv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nubv(index: UInt32; v: array of Byte);
    type PByte = ^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4Nubv_1(index, v[0]) else
        ntv_VertexAttrib4Nubv_1(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nubv(index: UInt32; var v: Vec4ub) :=
      ntv_VertexAttrib4Nubv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nubv(index: UInt32; var v: Byte) :=
      ntv_VertexAttrib4Nubv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nubv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4Nubv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib4Nuiv_adr := GetProcAddress('glVertexAttrib4Nuiv');
    private ntv_VertexAttrib4Nuiv_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttrib4Nuiv_adr);
    private ntv_VertexAttrib4Nuiv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ui)>(VertexAttrib4Nuiv_adr);
    private ntv_VertexAttrib4Nuiv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4Nuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nuiv(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4Nuiv_1(index, v[0]) else
        ntv_VertexAttrib4Nuiv_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nuiv(index: UInt32; var v: Vec4ui) :=
      ntv_VertexAttrib4Nuiv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nuiv(index: UInt32; var v: UInt32) :=
      ntv_VertexAttrib4Nuiv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nuiv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4Nuiv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib4Nusv_adr := GetProcAddress('glVertexAttrib4Nusv');
    private ntv_VertexAttrib4Nusv_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(VertexAttrib4Nusv_adr);
    private ntv_VertexAttrib4Nusv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4us)>(VertexAttrib4Nusv_adr);
    private ntv_VertexAttrib4Nusv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4Nusv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nusv(index: UInt32; v: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4Nusv_1(index, v[0]) else
        ntv_VertexAttrib4Nusv_1(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nusv(index: UInt32; var v: Vec4us) :=
      ntv_VertexAttrib4Nusv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nusv(index: UInt32; var v: UInt16) :=
      ntv_VertexAttrib4Nusv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nusv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4Nusv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib4s_adr := GetProcAddress('glVertexAttrib4s');
    private ntv_VertexAttrib4s_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16)>(VertexAttrib4s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4s(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16) :=
      ntv_VertexAttrib4s_1(index, x, y, z, w);
    
    // added in gl2.0
    private VertexAttrib4sv_adr := GetProcAddress('glVertexAttrib4sv');
    private ntv_VertexAttrib4sv_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttrib4sv_adr);
    private ntv_VertexAttrib4sv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4s)>(VertexAttrib4sv_adr);
    private ntv_VertexAttrib4sv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sv(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4sv_1(index, v[0]) else
        ntv_VertexAttrib4sv_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sv(index: UInt32; var v: Vec4s) :=
      ntv_VertexAttrib4sv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sv(index: UInt32; var v: Int16) :=
      ntv_VertexAttrib4sv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4sv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib4ubv_adr := GetProcAddress('glVertexAttrib4ubv');
    private ntv_VertexAttrib4ubv_1 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(VertexAttrib4ubv_adr);
    private ntv_VertexAttrib4ubv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ub)>(VertexAttrib4ubv_adr);
    private ntv_VertexAttrib4ubv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4ubv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubv(index: UInt32; v: array of Byte);
    type PByte = ^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4ubv_1(index, v[0]) else
        ntv_VertexAttrib4ubv_1(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubv(index: UInt32; var v: Vec4ub) :=
      ntv_VertexAttrib4ubv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubv(index: UInt32; var v: Byte) :=
      ntv_VertexAttrib4ubv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4ubv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib4uiv_adr := GetProcAddress('glVertexAttrib4uiv');
    private ntv_VertexAttrib4uiv_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttrib4uiv_adr);
    private ntv_VertexAttrib4uiv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ui)>(VertexAttrib4uiv_adr);
    private ntv_VertexAttrib4uiv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uiv(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4uiv_1(index, v[0]) else
        ntv_VertexAttrib4uiv_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uiv(index: UInt32; var v: Vec4ui) :=
      ntv_VertexAttrib4uiv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uiv(index: UInt32; var v: UInt32) :=
      ntv_VertexAttrib4uiv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uiv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4uiv_3(index, v);
    
    // added in gl2.0
    private VertexAttrib4usv_adr := GetProcAddress('glVertexAttrib4usv');
    private ntv_VertexAttrib4usv_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(VertexAttrib4usv_adr);
    private ntv_VertexAttrib4usv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4us)>(VertexAttrib4usv_adr);
    private ntv_VertexAttrib4usv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttrib4usv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usv(index: UInt32; v: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttrib4usv_1(index, v[0]) else
        ntv_VertexAttrib4usv_1(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usv(index: UInt32; var v: Vec4us) :=
      ntv_VertexAttrib4usv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usv(index: UInt32; var v: UInt16) :=
      ntv_VertexAttrib4usv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttrib4usv_3(index, v);
    
    // added in gl4.3
    private VertexAttribBinding_adr := GetProcAddress('glVertexAttribBinding');
    private ntv_VertexAttribBinding_1 := GetProcOrNil&<procedure(attribindex: UInt32; bindingindex: UInt32)>(VertexAttribBinding_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribBinding(attribindex: UInt32; bindingindex: UInt32) :=
      ntv_VertexAttribBinding_1(attribindex, bindingindex);
    
    // added in gl3.3
    private VertexAttribDivisor_adr := GetProcAddress('glVertexAttribDivisor');
    private ntv_VertexAttribDivisor_1 := GetProcOrNil&<procedure(index: UInt32; divisor: UInt32)>(VertexAttribDivisor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribDivisor(index: UInt32; divisor: UInt32) :=
      ntv_VertexAttribDivisor_1(index, divisor);
    
    // added in gl4.3
    private VertexAttribFormat_adr := GetProcAddress('glVertexAttribFormat');
    private ntv_VertexAttribFormat_1 := GetProcOrNil&<procedure(attribindex: UInt32; size: Int32; &type: glVertexAttribType; normalized: glBool8; relativeoffset: UInt32)>(VertexAttribFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribFormat(attribindex: UInt32; size: Int32; &type: glVertexAttribType; normalized: glBool8; relativeoffset: UInt32) :=
      ntv_VertexAttribFormat_1(attribindex, size, &type, normalized, relativeoffset);
    
    // added in gl3.0
    private VertexAttribI1i_adr := GetProcAddress('glVertexAttribI1i');
    private ntv_VertexAttribI1i_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32)>(VertexAttribI1i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1i(index: UInt32; x: Int32) :=
      ntv_VertexAttribI1i_1(index, x);
    
    // added in gl3.0
    private VertexAttribI1iv_adr := GetProcAddress('glVertexAttribI1iv');
    private ntv_VertexAttribI1iv_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttribI1iv_adr);
    private ntv_VertexAttribI1iv_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI1iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1iv(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI1iv_1(index, v[0]) else
        ntv_VertexAttribI1iv_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1iv(index: UInt32; var v: Int32) :=
      ntv_VertexAttribI1iv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1iv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI1iv_2(index, v);
    
    // added in gl3.0
    private VertexAttribI1ui_adr := GetProcAddress('glVertexAttribI1ui');
    private ntv_VertexAttribI1ui_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32)>(VertexAttribI1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ui(index: UInt32; x: UInt32) :=
      ntv_VertexAttribI1ui_1(index, x);
    
    // added in gl3.0
    private VertexAttribI1uiv_adr := GetProcAddress('glVertexAttribI1uiv');
    private ntv_VertexAttribI1uiv_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttribI1uiv_adr);
    private ntv_VertexAttribI1uiv_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uiv(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI1uiv_1(index, v[0]) else
        ntv_VertexAttribI1uiv_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uiv(index: UInt32; var v: UInt32) :=
      ntv_VertexAttribI1uiv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uiv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI1uiv_2(index, v);
    
    // added in gl3.0
    private VertexAttribI2i_adr := GetProcAddress('glVertexAttribI2i');
    private ntv_VertexAttribI2i_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32)>(VertexAttribI2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2i(index: UInt32; x: Int32; y: Int32) :=
      ntv_VertexAttribI2i_1(index, x, y);
    
    // added in gl3.0
    private VertexAttribI2iv_adr := GetProcAddress('glVertexAttribI2iv');
    private ntv_VertexAttribI2iv_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttribI2iv_adr);
    private ntv_VertexAttribI2iv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2i)>(VertexAttribI2iv_adr);
    private ntv_VertexAttribI2iv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2iv(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI2iv_1(index, v[0]) else
        ntv_VertexAttribI2iv_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2iv(index: UInt32; var v: Vec2i) :=
      ntv_VertexAttribI2iv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2iv(index: UInt32; var v: Int32) :=
      ntv_VertexAttribI2iv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2iv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI2iv_3(index, v);
    
    // added in gl3.0
    private VertexAttribI2ui_adr := GetProcAddress('glVertexAttribI2ui');
    private ntv_VertexAttribI2ui_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32)>(VertexAttribI2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ui(index: UInt32; x: UInt32; y: UInt32) :=
      ntv_VertexAttribI2ui_1(index, x, y);
    
    // added in gl3.0
    private VertexAttribI2uiv_adr := GetProcAddress('glVertexAttribI2uiv');
    private ntv_VertexAttribI2uiv_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttribI2uiv_adr);
    private ntv_VertexAttribI2uiv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2ui)>(VertexAttribI2uiv_adr);
    private ntv_VertexAttribI2uiv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uiv(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI2uiv_1(index, v[0]) else
        ntv_VertexAttribI2uiv_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uiv(index: UInt32; var v: Vec2ui) :=
      ntv_VertexAttribI2uiv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uiv(index: UInt32; var v: UInt32) :=
      ntv_VertexAttribI2uiv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uiv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI2uiv_3(index, v);
    
    // added in gl3.0
    private VertexAttribI3i_adr := GetProcAddress('glVertexAttribI3i');
    private ntv_VertexAttribI3i_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32; z: Int32)>(VertexAttribI3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3i(index: UInt32; x: Int32; y: Int32; z: Int32) :=
      ntv_VertexAttribI3i_1(index, x, y, z);
    
    // added in gl3.0
    private VertexAttribI3iv_adr := GetProcAddress('glVertexAttribI3iv');
    private ntv_VertexAttribI3iv_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttribI3iv_adr);
    private ntv_VertexAttribI3iv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3i)>(VertexAttribI3iv_adr);
    private ntv_VertexAttribI3iv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3iv(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI3iv_1(index, v[0]) else
        ntv_VertexAttribI3iv_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3iv(index: UInt32; var v: Vec3i) :=
      ntv_VertexAttribI3iv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3iv(index: UInt32; var v: Int32) :=
      ntv_VertexAttribI3iv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3iv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI3iv_3(index, v);
    
    // added in gl3.0
    private VertexAttribI3ui_adr := GetProcAddress('glVertexAttribI3ui');
    private ntv_VertexAttribI3ui_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32; z: UInt32)>(VertexAttribI3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ui(index: UInt32; x: UInt32; y: UInt32; z: UInt32) :=
      ntv_VertexAttribI3ui_1(index, x, y, z);
    
    // added in gl3.0
    private VertexAttribI3uiv_adr := GetProcAddress('glVertexAttribI3uiv');
    private ntv_VertexAttribI3uiv_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttribI3uiv_adr);
    private ntv_VertexAttribI3uiv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3ui)>(VertexAttribI3uiv_adr);
    private ntv_VertexAttribI3uiv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uiv(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI3uiv_1(index, v[0]) else
        ntv_VertexAttribI3uiv_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uiv(index: UInt32; var v: Vec3ui) :=
      ntv_VertexAttribI3uiv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uiv(index: UInt32; var v: UInt32) :=
      ntv_VertexAttribI3uiv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uiv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI3uiv_3(index, v);
    
    // added in gl3.0
    private VertexAttribI4bv_adr := GetProcAddress('glVertexAttribI4bv');
    private ntv_VertexAttribI4bv_1 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(VertexAttribI4bv_adr);
    private ntv_VertexAttribI4bv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4b)>(VertexAttribI4bv_adr);
    private ntv_VertexAttribI4bv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4bv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bv(index: UInt32; v: array of SByte);
    type PSByte = ^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4bv_1(index, v[0]) else
        ntv_VertexAttribI4bv_1(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bv(index: UInt32; var v: Vec4b) :=
      ntv_VertexAttribI4bv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bv(index: UInt32; var v: SByte) :=
      ntv_VertexAttribI4bv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4bv_3(index, v);
    
    // added in gl3.0
    private VertexAttribI4i_adr := GetProcAddress('glVertexAttribI4i');
    private ntv_VertexAttribI4i_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>(VertexAttribI4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4i(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) :=
      ntv_VertexAttribI4i_1(index, x, y, z, w);
    
    // added in gl3.0
    private VertexAttribI4iv_adr := GetProcAddress('glVertexAttribI4iv');
    private ntv_VertexAttribI4iv_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(VertexAttribI4iv_adr);
    private ntv_VertexAttribI4iv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4i)>(VertexAttribI4iv_adr);
    private ntv_VertexAttribI4iv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4iv(index: UInt32; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4iv_1(index, v[0]) else
        ntv_VertexAttribI4iv_1(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4iv(index: UInt32; var v: Vec4i) :=
      ntv_VertexAttribI4iv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4iv(index: UInt32; var v: Int32) :=
      ntv_VertexAttribI4iv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4iv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4iv_3(index, v);
    
    // added in gl3.0
    private VertexAttribI4sv_adr := GetProcAddress('glVertexAttribI4sv');
    private ntv_VertexAttribI4sv_1 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(VertexAttribI4sv_adr);
    private ntv_VertexAttribI4sv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4s)>(VertexAttribI4sv_adr);
    private ntv_VertexAttribI4sv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4sv(index: UInt32; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4sv_1(index, v[0]) else
        ntv_VertexAttribI4sv_1(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4sv(index: UInt32; var v: Vec4s) :=
      ntv_VertexAttribI4sv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4sv(index: UInt32; var v: Int16) :=
      ntv_VertexAttribI4sv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4sv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4sv_3(index, v);
    
    // added in gl3.0
    private VertexAttribI4ubv_adr := GetProcAddress('glVertexAttribI4ubv');
    private ntv_VertexAttribI4ubv_1 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(VertexAttribI4ubv_adr);
    private ntv_VertexAttribI4ubv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ub)>(VertexAttribI4ubv_adr);
    private ntv_VertexAttribI4ubv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4ubv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubv(index: UInt32; v: array of Byte);
    type PByte = ^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4ubv_1(index, v[0]) else
        ntv_VertexAttribI4ubv_1(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubv(index: UInt32; var v: Vec4ub) :=
      ntv_VertexAttribI4ubv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubv(index: UInt32; var v: Byte) :=
      ntv_VertexAttribI4ubv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4ubv_3(index, v);
    
    // added in gl3.0
    private VertexAttribI4ui_adr := GetProcAddress('glVertexAttribI4ui');
    private ntv_VertexAttribI4ui_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>(VertexAttribI4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ui(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) :=
      ntv_VertexAttribI4ui_1(index, x, y, z, w);
    
    // added in gl3.0
    private VertexAttribI4uiv_adr := GetProcAddress('glVertexAttribI4uiv');
    private ntv_VertexAttribI4uiv_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(VertexAttribI4uiv_adr);
    private ntv_VertexAttribI4uiv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4ui)>(VertexAttribI4uiv_adr);
    private ntv_VertexAttribI4uiv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uiv(index: UInt32; v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4uiv_1(index, v[0]) else
        ntv_VertexAttribI4uiv_1(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uiv(index: UInt32; var v: Vec4ui) :=
      ntv_VertexAttribI4uiv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uiv(index: UInt32; var v: UInt32) :=
      ntv_VertexAttribI4uiv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uiv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4uiv_3(index, v);
    
    // added in gl3.0
    private VertexAttribI4usv_adr := GetProcAddress('glVertexAttribI4usv');
    private ntv_VertexAttribI4usv_1 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(VertexAttribI4usv_adr);
    private ntv_VertexAttribI4usv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4us)>(VertexAttribI4usv_adr);
    private ntv_VertexAttribI4usv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribI4usv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usv(index: UInt32; v: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribI4usv_1(index, v[0]) else
        ntv_VertexAttribI4usv_1(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usv(index: UInt32; var v: Vec4us) :=
      ntv_VertexAttribI4usv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usv(index: UInt32; var v: UInt16) :=
      ntv_VertexAttribI4usv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribI4usv_3(index, v);
    
    // added in gl4.3
    private VertexAttribIFormat_adr := GetProcAddress('glVertexAttribIFormat');
    private ntv_VertexAttribIFormat_1 := GetProcOrNil&<procedure(attribindex: UInt32; size: Int32; &type: glVertexAttribIType; relativeoffset: UInt32)>(VertexAttribIFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIFormat(attribindex: UInt32; size: Int32; &type: glVertexAttribIType; relativeoffset: UInt32) :=
      ntv_VertexAttribIFormat_1(attribindex, size, &type, relativeoffset);
    
    // added in gl3.0
    private VertexAttribIPointer_adr := GetProcAddress('glVertexAttribIPointer');
    private ntv_VertexAttribIPointer_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: glVertexAttribIType; stride: Int32; pointer: IntPtr)>(VertexAttribIPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIPointer(index: UInt32; size: Int32; &type: glVertexAttribIType; stride: Int32; pointer: IntPtr) :=
      ntv_VertexAttribIPointer_1(index, size, &type, stride, pointer);
    
    // added in gl4.1
    private VertexAttribL1d_adr := GetProcAddress('glVertexAttribL1d');
    private ntv_VertexAttribL1d_1 := GetProcOrNil&<procedure(index: UInt32; x: double)>(VertexAttribL1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1d(index: UInt32; x: double) :=
      ntv_VertexAttribL1d_1(index, x);
    
    // added in gl4.1
    private VertexAttribL1dv_adr := GetProcAddress('glVertexAttribL1dv');
    private ntv_VertexAttribL1dv_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttribL1dv_adr);
    private ntv_VertexAttribL1dv_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dv(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL1dv_1(index, v[0]) else
        ntv_VertexAttribL1dv_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dv(index: UInt32; var v: double) :=
      ntv_VertexAttribL1dv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL1dv_2(index, v);
    
    // added in gl4.1
    private VertexAttribL2d_adr := GetProcAddress('glVertexAttribL2d');
    private ntv_VertexAttribL2d_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double)>(VertexAttribL2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2d(index: UInt32; x: double; y: double) :=
      ntv_VertexAttribL2d_1(index, x, y);
    
    // added in gl4.1
    private VertexAttribL2dv_adr := GetProcAddress('glVertexAttribL2dv');
    private ntv_VertexAttribL2dv_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttribL2dv_adr);
    private ntv_VertexAttribL2dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec2d)>(VertexAttribL2dv_adr);
    private ntv_VertexAttribL2dv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL2dv_1(index, v[0]) else
        ntv_VertexAttribL2dv_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; var v: Vec2d) :=
      ntv_VertexAttribL2dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; var v: double) :=
      ntv_VertexAttribL2dv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL2dv_3(index, v);
    
    // added in gl4.1
    private VertexAttribL3d_adr := GetProcAddress('glVertexAttribL3d');
    private ntv_VertexAttribL3d_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double; z: double)>(VertexAttribL3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3d(index: UInt32; x: double; y: double; z: double) :=
      ntv_VertexAttribL3d_1(index, x, y, z);
    
    // added in gl4.1
    private VertexAttribL3dv_adr := GetProcAddress('glVertexAttribL3dv');
    private ntv_VertexAttribL3dv_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttribL3dv_adr);
    private ntv_VertexAttribL3dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec3d)>(VertexAttribL3dv_adr);
    private ntv_VertexAttribL3dv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL3dv_1(index, v[0]) else
        ntv_VertexAttribL3dv_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; var v: Vec3d) :=
      ntv_VertexAttribL3dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; var v: double) :=
      ntv_VertexAttribL3dv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL3dv_3(index, v);
    
    // added in gl4.1
    private VertexAttribL4d_adr := GetProcAddress('glVertexAttribL4d');
    private ntv_VertexAttribL4d_1 := GetProcOrNil&<procedure(index: UInt32; x: double; y: double; z: double; w: double)>(VertexAttribL4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4d(index: UInt32; x: double; y: double; z: double; w: double) :=
      ntv_VertexAttribL4d_1(index, x, y, z, w);
    
    // added in gl4.1
    private VertexAttribL4dv_adr := GetProcAddress('glVertexAttribL4dv');
    private ntv_VertexAttribL4dv_1 := GetProcOrNil&<procedure(index: UInt32; var v: double)>(VertexAttribL4dv_adr);
    private ntv_VertexAttribL4dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Vec4d)>(VertexAttribL4dv_adr);
    private ntv_VertexAttribL4dv_3 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(VertexAttribL4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_VertexAttribL4dv_1(index, v[0]) else
        ntv_VertexAttribL4dv_1(index, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; var v: Vec4d) :=
      ntv_VertexAttribL4dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; var v: double) :=
      ntv_VertexAttribL4dv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; v: IntPtr) :=
      ntv_VertexAttribL4dv_3(index, v);
    
    // added in gl4.3
    private VertexAttribLFormat_adr := GetProcAddress('glVertexAttribLFormat');
    private ntv_VertexAttribLFormat_1 := GetProcOrNil&<procedure(attribindex: UInt32; size: Int32; &type: glVertexAttribLType; relativeoffset: UInt32)>(VertexAttribLFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLFormat(attribindex: UInt32; size: Int32; &type: glVertexAttribLType; relativeoffset: UInt32) :=
      ntv_VertexAttribLFormat_1(attribindex, size, &type, relativeoffset);
    
    // added in gl4.1
    private VertexAttribLPointer_adr := GetProcAddress('glVertexAttribLPointer');
    private ntv_VertexAttribLPointer_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: glVertexAttribLType; stride: Int32; pointer: IntPtr)>(VertexAttribLPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLPointer(index: UInt32; size: Int32; &type: glVertexAttribLType; stride: Int32; pointer: IntPtr) :=
      ntv_VertexAttribLPointer_1(index, size, &type, stride, pointer);
    
    // added in gl3.3
    private VertexAttribP1ui_adr := GetProcAddress('glVertexAttribP1ui');
    private ntv_VertexAttribP1ui_1 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: UInt32)>(VertexAttribP1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1ui(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: UInt32) :=
      ntv_VertexAttribP1ui_1(index, &type, normalized, value);
    
    // added in gl3.3
    private VertexAttribP1uiv_adr := GetProcAddress('glVertexAttribP1uiv');
    private ntv_VertexAttribP1uiv_1 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; var value: UInt32)>(VertexAttribP1uiv_adr);
    private ntv_VertexAttribP1uiv_2 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: IntPtr)>(VertexAttribP1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_VertexAttribP1uiv_1(index, &type, normalized, value[0]) else
        ntv_VertexAttribP1uiv_1(index, &type, normalized, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; var value: UInt32) :=
      ntv_VertexAttribP1uiv_1(index, &type, normalized, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: IntPtr) :=
      ntv_VertexAttribP1uiv_2(index, &type, normalized, value);
    
    // added in gl3.3
    private VertexAttribP2ui_adr := GetProcAddress('glVertexAttribP2ui');
    private ntv_VertexAttribP2ui_1 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: UInt32)>(VertexAttribP2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2ui(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: UInt32) :=
      ntv_VertexAttribP2ui_1(index, &type, normalized, value);
    
    // added in gl3.3
    private VertexAttribP2uiv_adr := GetProcAddress('glVertexAttribP2uiv');
    private ntv_VertexAttribP2uiv_1 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; var value: UInt32)>(VertexAttribP2uiv_adr);
    private ntv_VertexAttribP2uiv_2 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: IntPtr)>(VertexAttribP2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_VertexAttribP2uiv_1(index, &type, normalized, value[0]) else
        ntv_VertexAttribP2uiv_1(index, &type, normalized, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; var value: UInt32) :=
      ntv_VertexAttribP2uiv_1(index, &type, normalized, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: IntPtr) :=
      ntv_VertexAttribP2uiv_2(index, &type, normalized, value);
    
    // added in gl3.3
    private VertexAttribP3ui_adr := GetProcAddress('glVertexAttribP3ui');
    private ntv_VertexAttribP3ui_1 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: UInt32)>(VertexAttribP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3ui(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: UInt32) :=
      ntv_VertexAttribP3ui_1(index, &type, normalized, value);
    
    // added in gl3.3
    private VertexAttribP3uiv_adr := GetProcAddress('glVertexAttribP3uiv');
    private ntv_VertexAttribP3uiv_1 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; var value: UInt32)>(VertexAttribP3uiv_adr);
    private ntv_VertexAttribP3uiv_2 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: IntPtr)>(VertexAttribP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_VertexAttribP3uiv_1(index, &type, normalized, value[0]) else
        ntv_VertexAttribP3uiv_1(index, &type, normalized, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; var value: UInt32) :=
      ntv_VertexAttribP3uiv_1(index, &type, normalized, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: IntPtr) :=
      ntv_VertexAttribP3uiv_2(index, &type, normalized, value);
    
    // added in gl3.3
    private VertexAttribP4ui_adr := GetProcAddress('glVertexAttribP4ui');
    private ntv_VertexAttribP4ui_1 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: UInt32)>(VertexAttribP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4ui(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: UInt32) :=
      ntv_VertexAttribP4ui_1(index, &type, normalized, value);
    
    // added in gl3.3
    private VertexAttribP4uiv_adr := GetProcAddress('glVertexAttribP4uiv');
    private ntv_VertexAttribP4uiv_1 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; var value: UInt32)>(VertexAttribP4uiv_adr);
    private ntv_VertexAttribP4uiv_2 := GetProcOrNil&<procedure(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: IntPtr)>(VertexAttribP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_VertexAttribP4uiv_1(index, &type, normalized, value[0]) else
        ntv_VertexAttribP4uiv_1(index, &type, normalized, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; var value: UInt32) :=
      ntv_VertexAttribP4uiv_1(index, &type, normalized, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4uiv(index: UInt32; &type: glVertexAttribPointerType; normalized: glBool8; value: IntPtr) :=
      ntv_VertexAttribP4uiv_2(index, &type, normalized, value);
    
    // added in gl2.0
    private VertexAttribPointer_adr := GetProcAddress('glVertexAttribPointer');
    private ntv_VertexAttribPointer_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: glVertexAttribPointerType; normalized: glBool8; stride: Int32; pointer: IntPtr)>(VertexAttribPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribPointer(index: UInt32; size: Int32; &type: glVertexAttribPointerType; normalized: glBool8; stride: Int32; pointer: IntPtr) :=
      ntv_VertexAttribPointer_1(index, size, &type, normalized, stride, pointer);
    
    // added in gl4.3
    private VertexBindingDivisor_adr := GetProcAddress('glVertexBindingDivisor');
    private ntv_VertexBindingDivisor_1 := GetProcOrNil&<procedure(bindingindex: UInt32; divisor: UInt32)>(VertexBindingDivisor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexBindingDivisor(bindingindex: UInt32; divisor: UInt32) :=
      ntv_VertexBindingDivisor_1(bindingindex, divisor);
    
    // added in gl3.3
    private VertexP2ui_adr := GetProcAddress('glVertexP2ui');
    private ntv_VertexP2ui_1 := GetProcOrNil&<procedure(&type: glVertexPointerType; value: UInt32)>(VertexP2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2ui(&type: glVertexPointerType; value: UInt32) :=
      ntv_VertexP2ui_1(&type, value);
    
    // added in gl3.3
    private VertexP2uiv_adr := GetProcAddress('glVertexP2uiv');
    private ntv_VertexP2uiv_1 := GetProcOrNil&<procedure(&type: glVertexPointerType; var value: UInt32)>(VertexP2uiv_adr);
    private ntv_VertexP2uiv_2 := GetProcOrNil&<procedure(&type: glVertexPointerType; value: IntPtr)>(VertexP2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: glVertexPointerType; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_VertexP2uiv_1(&type, value[0]) else
        ntv_VertexP2uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: glVertexPointerType; var value: UInt32) :=
      ntv_VertexP2uiv_1(&type, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: glVertexPointerType; value: IntPtr) :=
      ntv_VertexP2uiv_2(&type, value);
    
    // added in gl3.3
    private VertexP3ui_adr := GetProcAddress('glVertexP3ui');
    private ntv_VertexP3ui_1 := GetProcOrNil&<procedure(&type: glVertexPointerType; value: UInt32)>(VertexP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3ui(&type: glVertexPointerType; value: UInt32) :=
      ntv_VertexP3ui_1(&type, value);
    
    // added in gl3.3
    private VertexP3uiv_adr := GetProcAddress('glVertexP3uiv');
    private ntv_VertexP3uiv_1 := GetProcOrNil&<procedure(&type: glVertexPointerType; var value: UInt32)>(VertexP3uiv_adr);
    private ntv_VertexP3uiv_2 := GetProcOrNil&<procedure(&type: glVertexPointerType; value: IntPtr)>(VertexP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: glVertexPointerType; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_VertexP3uiv_1(&type, value[0]) else
        ntv_VertexP3uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: glVertexPointerType; var value: UInt32) :=
      ntv_VertexP3uiv_1(&type, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: glVertexPointerType; value: IntPtr) :=
      ntv_VertexP3uiv_2(&type, value);
    
    // added in gl3.3
    private VertexP4ui_adr := GetProcAddress('glVertexP4ui');
    private ntv_VertexP4ui_1 := GetProcOrNil&<procedure(&type: glVertexPointerType; value: UInt32)>(VertexP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4ui(&type: glVertexPointerType; value: UInt32) :=
      ntv_VertexP4ui_1(&type, value);
    
    // added in gl3.3
    private VertexP4uiv_adr := GetProcAddress('glVertexP4uiv');
    private ntv_VertexP4uiv_1 := GetProcOrNil&<procedure(&type: glVertexPointerType; var value: UInt32)>(VertexP4uiv_adr);
    private ntv_VertexP4uiv_2 := GetProcOrNil&<procedure(&type: glVertexPointerType; value: IntPtr)>(VertexP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: glVertexPointerType; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_VertexP4uiv_1(&type, value[0]) else
        ntv_VertexP4uiv_1(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: glVertexPointerType; var value: UInt32) :=
      ntv_VertexP4uiv_1(&type, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: glVertexPointerType; value: IntPtr) :=
      ntv_VertexP4uiv_2(&type, value);
    
    // added in gl1.0
    private Viewport_adr := GetProcAddress('glViewport');
    private ntv_Viewport_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32)>(Viewport_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Viewport(x: Int32; y: Int32; width: Int32; height: Int32) :=
      ntv_Viewport_1(x, y, width, height);
    
    // added in gl4.1
    private ViewportArrayv_adr := GetProcAddress('glViewportArrayv');
    private ntv_ViewportArrayv_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var v: single)>(ViewportArrayv_adr);
    private ntv_ViewportArrayv_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; v: IntPtr)>(ViewportArrayv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayv(first: UInt32; count: Int32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_ViewportArrayv_1(first, count, v[0]) else
        ntv_ViewportArrayv_1(first, count, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayv(first: UInt32; count: Int32; var v: single) :=
      ntv_ViewportArrayv_1(first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayv(first: UInt32; count: Int32; v: IntPtr) :=
      ntv_ViewportArrayv_2(first, count, v);
    
    // added in gl4.1
    private ViewportIndexedf_adr := GetProcAddress('glViewportIndexedf');
    private ntv_ViewportIndexedf_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; w: single; h: single)>(ViewportIndexedf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedf(index: UInt32; x: single; y: single; w: single; h: single) :=
      ntv_ViewportIndexedf_1(index, x, y, w, h);
    
    // added in gl4.1
    private ViewportIndexedfv_adr := GetProcAddress('glViewportIndexedfv');
    private ntv_ViewportIndexedfv_1 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(ViewportIndexedfv_adr);
    private ntv_ViewportIndexedfv_2 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(ViewportIndexedfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfv(index: UInt32; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_ViewportIndexedfv_1(index, v[0]) else
        ntv_ViewportIndexedfv_1(index, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfv(index: UInt32; var v: single) :=
      ntv_ViewportIndexedfv_1(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfv(index: UInt32; v: IntPtr) :=
      ntv_ViewportIndexedfv_2(index, v);
    
    // added in gl3.2
    private WaitSync_adr := GetProcAddress('glWaitSync');
    private ntv_WaitSync_1 := GetProcOrNil&<procedure(sync: gl_sync; flags: glSyncBehaviorFlags; timeout: UInt64)>(WaitSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSync(sync: gl_sync; flags: glSyncBehaviorFlags; timeout: UInt64) :=
      ntv_WaitSync_1(sync, flags, timeout);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      if fadr=IntPtr.Zero then default(T) else
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    
    // added in gl1.0, deprecated in gl3.2
    private Accum_adr := GetProcAddress('glAccum');
    private ntv_Accum_1 := GetProcOrNil&<procedure(op: glAccumOp; value: single)>(Accum_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Accum(op: glAccumOp; value: single) :=
      ntv_Accum_1(op, value);
    
    // added in gl1.0, deprecated in gl3.2
    private AlphaFunc_adr := GetProcAddress('glAlphaFunc');
    private ntv_AlphaFunc_1 := GetProcOrNil&<procedure(func: glAlphaFunction; ref: single)>(AlphaFunc_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFunc(func: glAlphaFunction; ref: single) :=
      ntv_AlphaFunc_1(func, ref);
    
    // added in gl1.1, deprecated in gl3.2
    private AreTexturesResident_adr := GetProcAddress('glAreTexturesResident');
    private ntv_AreTexturesResident_1 := GetProcOrNil&<function(n: Int32; var textures: gl_texture; var residences: glBool8): glBool8>(AreTexturesResident_adr);
    private ntv_AreTexturesResident_2 := GetProcOrNil&<function(n: Int32; var textures: gl_texture; residences: IntPtr): glBool8>(AreTexturesResident_adr);
    private ntv_AreTexturesResident_3 := GetProcOrNil&<function(n: Int32; textures: IntPtr; var residences: glBool8): glBool8>(AreTexturesResident_adr);
    private ntv_AreTexturesResident_4 := GetProcOrNil&<function(n: Int32; textures: IntPtr; residences: IntPtr): glBool8>(AreTexturesResident_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; textures: array of gl_texture; residences: array of glBool8): glBool8;
    type PGl_texture = ^gl_texture;
    type PGlBool8 = ^glBool8;
    begin
      Result := if (residences<>nil) and (residences.Length<>0) then
        if (textures<>nil) and (textures.Length<>0) then
          ntv_AreTexturesResident_1(n, textures[0], residences[0]) else
          ntv_AreTexturesResident_1(n, PGl_texture(nil)^, residences[0]) else
        if (textures<>nil) and (textures.Length<>0) then
          ntv_AreTexturesResident_1(n, textures[0], PGlBool8(nil)^) else
          ntv_AreTexturesResident_1(n, PGl_texture(nil)^, PGlBool8(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; var textures: gl_texture; var residences: glBool8): glBool8 :=
      ntv_AreTexturesResident_1(n, textures, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; var textures: gl_texture; residences: IntPtr): glBool8 :=
      ntv_AreTexturesResident_2(n, textures, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; textures: IntPtr; var residences: glBool8): glBool8 :=
      ntv_AreTexturesResident_3(n, textures, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; textures: IntPtr; residences: IntPtr): glBool8 :=
      ntv_AreTexturesResident_4(n, textures, residences);
    
    // added in gl1.1, deprecated in gl3.2
    private ArrayElement_adr := GetProcAddress('glArrayElement');
    private ntv_ArrayElement_1 := GetProcOrNil&<procedure(i: Int32)>(ArrayElement_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ArrayElement(i: Int32) :=
      ntv_ArrayElement_1(i);
    
    // added in gl1.0, deprecated in gl3.2
    private Begin_adr := GetProcAddress('glBegin');
    private ntv_Begin_1 := GetProcOrNil&<procedure(mode: glPrimitiveType)>(Begin_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure &Begin(mode: glPrimitiveType) :=
      ntv_Begin_1(mode);
    
    // added in gl1.0, deprecated in gl3.2
    private Bitmap_adr := GetProcAddress('glBitmap');
    private ntv_Bitmap_1 := GetProcOrNil&<procedure(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; var bitmap: Byte)>(Bitmap_adr);
    private ntv_Bitmap_2 := GetProcOrNil&<procedure(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; bitmap: IntPtr)>(Bitmap_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Bitmap(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; bitmap: array of Byte);
    type PByte = ^Byte;
    begin
      if (bitmap<>nil) and (bitmap.Length<>0) then
        ntv_Bitmap_1(width, height, xorig, yorig, xmove, ymove, bitmap[0]) else
        ntv_Bitmap_1(width, height, xorig, yorig, xmove, ymove, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Bitmap(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; var bitmap: Byte) :=
      ntv_Bitmap_1(width, height, xorig, yorig, xmove, ymove, bitmap);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Bitmap(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; bitmap: IntPtr) :=
      ntv_Bitmap_2(width, height, xorig, yorig, xmove, ymove, bitmap);
    
    // added in gl1.0, deprecated in gl3.2
    private CallList_adr := GetProcAddress('glCallList');
    private ntv_CallList_1 := GetProcOrNil&<procedure(list: gl_display_list)>(CallList_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CallList(list: gl_display_list) :=
      ntv_CallList_1(list);
    
    // added in gl1.0, deprecated in gl3.2
    private CallLists_adr := GetProcAddress('glCallLists');
    private ntv_CallLists_1 := GetProcOrNil&<procedure(n: Int32; &type: glListNameType; lists: IntPtr)>(CallLists_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CallLists(n: Int32; &type: glListNameType; lists: IntPtr) :=
      ntv_CallLists_1(n, &type, lists);
    
    // added in gl1.0, deprecated in gl3.2
    private ClearAccum_adr := GetProcAddress('glClearAccum');
    private ntv_ClearAccum_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single; alpha: single)>(ClearAccum_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearAccum(red: single; green: single; blue: single; alpha: single) :=
      ntv_ClearAccum_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private ClearIndex_adr := GetProcAddress('glClearIndex');
    private ntv_ClearIndex_1 := GetProcOrNil&<procedure(c: single)>(ClearIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearIndex(c: single) :=
      ntv_ClearIndex_1(c);
    
    // added in gl1.3, deprecated in gl3.2
    private ClientActiveTexture_adr := GetProcAddress('glClientActiveTexture');
    private ntv_ClientActiveTexture_1 := GetProcOrNil&<procedure(texture: glTextureUnit)>(ClientActiveTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientActiveTexture(texture: glTextureUnit) :=
      ntv_ClientActiveTexture_1(texture);
    
    // added in gl1.0, deprecated in gl3.2
    private ClipPlane_adr := GetProcAddress('glClipPlane');
    private ntv_ClipPlane_1 := GetProcOrNil&<procedure(plane: glClipPlaneName; var equation: double)>(ClipPlane_adr);
    private ntv_ClipPlane_2 := GetProcOrNil&<procedure(plane: glClipPlaneName; equation: IntPtr)>(ClipPlane_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlane(plane: glClipPlaneName; equation: array of double);
    type PDouble = ^double;
    begin
      if (equation<>nil) and (equation.Length<>0) then
        ntv_ClipPlane_1(plane, equation[0]) else
        ntv_ClipPlane_1(plane, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlane(plane: glClipPlaneName; var equation: double) :=
      ntv_ClipPlane_1(plane, equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlane(plane: glClipPlaneName; equation: IntPtr) :=
      ntv_ClipPlane_2(plane, equation);
    
    // added in gl1.0, deprecated in gl3.2
    private Color3b_adr := GetProcAddress('glColor3b');
    private ntv_Color3b_1 := GetProcOrNil&<procedure(red: SByte; green: SByte; blue: SByte)>(Color3b_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3b(red: SByte; green: SByte; blue: SByte) :=
      ntv_Color3b_1(red, green, blue);
    
    // added in gl1.0, deprecated in gl3.2
    private Color3bv_adr := GetProcAddress('glColor3bv');
    private ntv_Color3bv_1 := GetProcOrNil&<procedure(var v: SByte)>(Color3bv_adr);
    private ntv_Color3bv_2 := GetProcOrNil&<procedure(var v: Vec3b)>(Color3bv_adr);
    private ntv_Color3bv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Color3bv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3bv(v: array of SByte);
    type PSByte = ^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color3bv_1(v[0]) else
        ntv_Color3bv_1(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3bv(var v: Vec3b) :=
      ntv_Color3bv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3bv(var v: SByte) :=
      ntv_Color3bv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3bv(v: IntPtr) :=
      ntv_Color3bv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Color3d_adr := GetProcAddress('glColor3d');
    private ntv_Color3d_1 := GetProcOrNil&<procedure(red: double; green: double; blue: double)>(Color3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3d(red: double; green: double; blue: double) :=
      ntv_Color3d_1(red, green, blue);
    
    // added in gl1.0, deprecated in gl3.2
    private Color3dv_adr := GetProcAddress('glColor3dv');
    private ntv_Color3dv_1 := GetProcOrNil&<procedure(var v: double)>(Color3dv_adr);
    private ntv_Color3dv_2 := GetProcOrNil&<procedure(var v: Vec3d)>(Color3dv_adr);
    private ntv_Color3dv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Color3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3dv(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color3dv_1(v[0]) else
        ntv_Color3dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3dv(var v: Vec3d) :=
      ntv_Color3dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3dv(var v: double) :=
      ntv_Color3dv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3dv(v: IntPtr) :=
      ntv_Color3dv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Color3f_adr := GetProcAddress('glColor3f');
    private ntv_Color3f_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single)>(Color3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3f(red: single; green: single; blue: single) :=
      ntv_Color3f_1(red, green, blue);
    
    // added in gl1.0, deprecated in gl3.2
    private Color3fv_adr := GetProcAddress('glColor3fv');
    private ntv_Color3fv_1 := GetProcOrNil&<procedure(var v: single)>(Color3fv_adr);
    private ntv_Color3fv_2 := GetProcOrNil&<procedure(var v: Vec3f)>(Color3fv_adr);
    private ntv_Color3fv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Color3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fv(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color3fv_1(v[0]) else
        ntv_Color3fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fv(var v: Vec3f) :=
      ntv_Color3fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fv(var v: single) :=
      ntv_Color3fv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fv(v: IntPtr) :=
      ntv_Color3fv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Color3i_adr := GetProcAddress('glColor3i');
    private ntv_Color3i_1 := GetProcOrNil&<procedure(red: Int32; green: Int32; blue: Int32)>(Color3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3i(red: Int32; green: Int32; blue: Int32) :=
      ntv_Color3i_1(red, green, blue);
    
    // added in gl1.0, deprecated in gl3.2
    private Color3iv_adr := GetProcAddress('glColor3iv');
    private ntv_Color3iv_1 := GetProcOrNil&<procedure(var v: Int32)>(Color3iv_adr);
    private ntv_Color3iv_2 := GetProcOrNil&<procedure(var v: Vec3i)>(Color3iv_adr);
    private ntv_Color3iv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Color3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3iv(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color3iv_1(v[0]) else
        ntv_Color3iv_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3iv(var v: Vec3i) :=
      ntv_Color3iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3iv(var v: Int32) :=
      ntv_Color3iv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3iv(v: IntPtr) :=
      ntv_Color3iv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Color3s_adr := GetProcAddress('glColor3s');
    private ntv_Color3s_1 := GetProcOrNil&<procedure(red: Int16; green: Int16; blue: Int16)>(Color3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3s(red: Int16; green: Int16; blue: Int16) :=
      ntv_Color3s_1(red, green, blue);
    
    // added in gl1.0, deprecated in gl3.2
    private Color3sv_adr := GetProcAddress('glColor3sv');
    private ntv_Color3sv_1 := GetProcOrNil&<procedure(var v: Int16)>(Color3sv_adr);
    private ntv_Color3sv_2 := GetProcOrNil&<procedure(var v: Vec3s)>(Color3sv_adr);
    private ntv_Color3sv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Color3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3sv(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color3sv_1(v[0]) else
        ntv_Color3sv_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3sv(var v: Vec3s) :=
      ntv_Color3sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3sv(var v: Int16) :=
      ntv_Color3sv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3sv(v: IntPtr) :=
      ntv_Color3sv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Color3ub_adr := GetProcAddress('glColor3ub');
    private ntv_Color3ub_1 := GetProcOrNil&<procedure(red: Byte; green: Byte; blue: Byte)>(Color3ub_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3ub(red: Byte; green: Byte; blue: Byte) :=
      ntv_Color3ub_1(red, green, blue);
    
    // added in gl1.0, deprecated in gl3.2
    private Color3ubv_adr := GetProcAddress('glColor3ubv');
    private ntv_Color3ubv_1 := GetProcOrNil&<procedure(var v: Byte)>(Color3ubv_adr);
    private ntv_Color3ubv_2 := GetProcOrNil&<procedure(var v: Vec3ub)>(Color3ubv_adr);
    private ntv_Color3ubv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Color3ubv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3ubv(v: array of Byte);
    type PByte = ^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color3ubv_1(v[0]) else
        ntv_Color3ubv_1(PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3ubv(var v: Vec3ub) :=
      ntv_Color3ubv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3ubv(var v: Byte) :=
      ntv_Color3ubv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3ubv(v: IntPtr) :=
      ntv_Color3ubv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Color3ui_adr := GetProcAddress('glColor3ui');
    private ntv_Color3ui_1 := GetProcOrNil&<procedure(red: UInt32; green: UInt32; blue: UInt32)>(Color3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3ui(red: UInt32; green: UInt32; blue: UInt32) :=
      ntv_Color3ui_1(red, green, blue);
    
    // added in gl1.0, deprecated in gl3.2
    private Color3uiv_adr := GetProcAddress('glColor3uiv');
    private ntv_Color3uiv_1 := GetProcOrNil&<procedure(var v: UInt32)>(Color3uiv_adr);
    private ntv_Color3uiv_2 := GetProcOrNil&<procedure(var v: Vec3ui)>(Color3uiv_adr);
    private ntv_Color3uiv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Color3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3uiv(v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color3uiv_1(v[0]) else
        ntv_Color3uiv_1(PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3uiv(var v: Vec3ui) :=
      ntv_Color3uiv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3uiv(var v: UInt32) :=
      ntv_Color3uiv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3uiv(v: IntPtr) :=
      ntv_Color3uiv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Color3us_adr := GetProcAddress('glColor3us');
    private ntv_Color3us_1 := GetProcOrNil&<procedure(red: UInt16; green: UInt16; blue: UInt16)>(Color3us_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3us(red: UInt16; green: UInt16; blue: UInt16) :=
      ntv_Color3us_1(red, green, blue);
    
    // added in gl1.0, deprecated in gl3.2
    private Color3usv_adr := GetProcAddress('glColor3usv');
    private ntv_Color3usv_1 := GetProcOrNil&<procedure(var v: UInt16)>(Color3usv_adr);
    private ntv_Color3usv_2 := GetProcOrNil&<procedure(var v: Vec3us)>(Color3usv_adr);
    private ntv_Color3usv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Color3usv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3usv(v: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color3usv_1(v[0]) else
        ntv_Color3usv_1(PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3usv(var v: Vec3us) :=
      ntv_Color3usv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3usv(var v: UInt16) :=
      ntv_Color3usv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3usv(v: IntPtr) :=
      ntv_Color3usv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Color4b_adr := GetProcAddress('glColor4b');
    private ntv_Color4b_1 := GetProcOrNil&<procedure(red: SByte; green: SByte; blue: SByte; alpha: SByte)>(Color4b_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4b(red: SByte; green: SByte; blue: SByte; alpha: SByte) :=
      ntv_Color4b_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private Color4bv_adr := GetProcAddress('glColor4bv');
    private ntv_Color4bv_1 := GetProcOrNil&<procedure(var v: SByte)>(Color4bv_adr);
    private ntv_Color4bv_2 := GetProcOrNil&<procedure(var v: Vec4b)>(Color4bv_adr);
    private ntv_Color4bv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Color4bv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4bv(v: array of SByte);
    type PSByte = ^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color4bv_1(v[0]) else
        ntv_Color4bv_1(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4bv(var v: Vec4b) :=
      ntv_Color4bv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4bv(var v: SByte) :=
      ntv_Color4bv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4bv(v: IntPtr) :=
      ntv_Color4bv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Color4d_adr := GetProcAddress('glColor4d');
    private ntv_Color4d_1 := GetProcOrNil&<procedure(red: double; green: double; blue: double; alpha: double)>(Color4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4d(red: double; green: double; blue: double; alpha: double) :=
      ntv_Color4d_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private Color4dv_adr := GetProcAddress('glColor4dv');
    private ntv_Color4dv_1 := GetProcOrNil&<procedure(var v: double)>(Color4dv_adr);
    private ntv_Color4dv_2 := GetProcOrNil&<procedure(var v: Vec4d)>(Color4dv_adr);
    private ntv_Color4dv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Color4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4dv(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color4dv_1(v[0]) else
        ntv_Color4dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4dv(var v: Vec4d) :=
      ntv_Color4dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4dv(var v: double) :=
      ntv_Color4dv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4dv(v: IntPtr) :=
      ntv_Color4dv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Color4f_adr := GetProcAddress('glColor4f');
    private ntv_Color4f_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single; alpha: single)>(Color4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4f(red: single; green: single; blue: single; alpha: single) :=
      ntv_Color4f_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private Color4fv_adr := GetProcAddress('glColor4fv');
    private ntv_Color4fv_1 := GetProcOrNil&<procedure(var v: single)>(Color4fv_adr);
    private ntv_Color4fv_2 := GetProcOrNil&<procedure(var v: Vec4f)>(Color4fv_adr);
    private ntv_Color4fv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Color4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fv(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color4fv_1(v[0]) else
        ntv_Color4fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fv(var v: Vec4f) :=
      ntv_Color4fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fv(var v: single) :=
      ntv_Color4fv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fv(v: IntPtr) :=
      ntv_Color4fv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Color4i_adr := GetProcAddress('glColor4i');
    private ntv_Color4i_1 := GetProcOrNil&<procedure(red: Int32; green: Int32; blue: Int32; alpha: Int32)>(Color4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4i(red: Int32; green: Int32; blue: Int32; alpha: Int32) :=
      ntv_Color4i_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private Color4iv_adr := GetProcAddress('glColor4iv');
    private ntv_Color4iv_1 := GetProcOrNil&<procedure(var v: Int32)>(Color4iv_adr);
    private ntv_Color4iv_2 := GetProcOrNil&<procedure(var v: Vec4i)>(Color4iv_adr);
    private ntv_Color4iv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Color4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4iv(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color4iv_1(v[0]) else
        ntv_Color4iv_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4iv(var v: Vec4i) :=
      ntv_Color4iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4iv(var v: Int32) :=
      ntv_Color4iv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4iv(v: IntPtr) :=
      ntv_Color4iv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Color4s_adr := GetProcAddress('glColor4s');
    private ntv_Color4s_1 := GetProcOrNil&<procedure(red: Int16; green: Int16; blue: Int16; alpha: Int16)>(Color4s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4s(red: Int16; green: Int16; blue: Int16; alpha: Int16) :=
      ntv_Color4s_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private Color4sv_adr := GetProcAddress('glColor4sv');
    private ntv_Color4sv_1 := GetProcOrNil&<procedure(var v: Int16)>(Color4sv_adr);
    private ntv_Color4sv_2 := GetProcOrNil&<procedure(var v: Vec4s)>(Color4sv_adr);
    private ntv_Color4sv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Color4sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4sv(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color4sv_1(v[0]) else
        ntv_Color4sv_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4sv(var v: Vec4s) :=
      ntv_Color4sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4sv(var v: Int16) :=
      ntv_Color4sv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4sv(v: IntPtr) :=
      ntv_Color4sv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Color4ub_adr := GetProcAddress('glColor4ub');
    private ntv_Color4ub_1 := GetProcOrNil&<procedure(red: Byte; green: Byte; blue: Byte; alpha: Byte)>(Color4ub_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ub(red: Byte; green: Byte; blue: Byte; alpha: Byte) :=
      ntv_Color4ub_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private Color4ubv_adr := GetProcAddress('glColor4ubv');
    private ntv_Color4ubv_1 := GetProcOrNil&<procedure(var v: Byte)>(Color4ubv_adr);
    private ntv_Color4ubv_2 := GetProcOrNil&<procedure(var v: Vec4ub)>(Color4ubv_adr);
    private ntv_Color4ubv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Color4ubv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubv(v: array of Byte);
    type PByte = ^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color4ubv_1(v[0]) else
        ntv_Color4ubv_1(PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubv(var v: Vec4ub) :=
      ntv_Color4ubv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubv(var v: Byte) :=
      ntv_Color4ubv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubv(v: IntPtr) :=
      ntv_Color4ubv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Color4ui_adr := GetProcAddress('glColor4ui');
    private ntv_Color4ui_1 := GetProcOrNil&<procedure(red: UInt32; green: UInt32; blue: UInt32; alpha: UInt32)>(Color4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ui(red: UInt32; green: UInt32; blue: UInt32; alpha: UInt32) :=
      ntv_Color4ui_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private Color4uiv_adr := GetProcAddress('glColor4uiv');
    private ntv_Color4uiv_1 := GetProcOrNil&<procedure(var v: UInt32)>(Color4uiv_adr);
    private ntv_Color4uiv_2 := GetProcOrNil&<procedure(var v: Vec4ui)>(Color4uiv_adr);
    private ntv_Color4uiv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Color4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4uiv(v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color4uiv_1(v[0]) else
        ntv_Color4uiv_1(PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4uiv(var v: Vec4ui) :=
      ntv_Color4uiv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4uiv(var v: UInt32) :=
      ntv_Color4uiv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4uiv(v: IntPtr) :=
      ntv_Color4uiv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Color4us_adr := GetProcAddress('glColor4us');
    private ntv_Color4us_1 := GetProcOrNil&<procedure(red: UInt16; green: UInt16; blue: UInt16; alpha: UInt16)>(Color4us_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4us(red: UInt16; green: UInt16; blue: UInt16; alpha: UInt16) :=
      ntv_Color4us_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private Color4usv_adr := GetProcAddress('glColor4usv');
    private ntv_Color4usv_1 := GetProcOrNil&<procedure(var v: UInt16)>(Color4usv_adr);
    private ntv_Color4usv_2 := GetProcOrNil&<procedure(var v: Vec4us)>(Color4usv_adr);
    private ntv_Color4usv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Color4usv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4usv(v: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Color4usv_1(v[0]) else
        ntv_Color4usv_1(PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4usv(var v: Vec4us) :=
      ntv_Color4usv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4usv(var v: UInt16) :=
      ntv_Color4usv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4usv(v: IntPtr) :=
      ntv_Color4usv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private ColorMaterial_adr := GetProcAddress('glColorMaterial');
    private ntv_ColorMaterial_1 := GetProcOrNil&<procedure(face: glTriangleFace; mode: glColorMaterialParameter)>(ColorMaterial_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorMaterial(face: glTriangleFace; mode: glColorMaterialParameter) :=
      ntv_ColorMaterial_1(face, mode);
    
    // added in gl1.1, deprecated in gl3.2
    private ColorPointer_adr := GetProcAddress('glColorPointer');
    private ntv_ColorPointer_1 := GetProcOrNil&<procedure(size: Int32; &type: glColorPointerType; stride: Int32; pointer: IntPtr)>(ColorPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointer(size: Int32; &type: glColorPointerType; stride: Int32; pointer: IntPtr) :=
      ntv_ColorPointer_1(size, &type, stride, pointer);
    
    // added in gl1.0, deprecated in gl3.2
    private CopyPixels_adr := GetProcAddress('glCopyPixels');
    private ntv_CopyPixels_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32; &type: glPixelCopyType)>(CopyPixels_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyPixels(x: Int32; y: Int32; width: Int32; height: Int32; &type: glPixelCopyType) :=
      ntv_CopyPixels_1(x, y, width, height, &type);
    
    // added in gl1.0, deprecated in gl3.2
    private DeleteLists_adr := GetProcAddress('glDeleteLists');
    private ntv_DeleteLists_1 := GetProcOrNil&<procedure(list: gl_display_list; range: Int32)>(DeleteLists_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteLists(list: gl_display_list; range: Int32) :=
      ntv_DeleteLists_1(list, range);
    
    // added in gl1.1, deprecated in gl3.2
    private DisableClientState_adr := GetProcAddress('glDisableClientState');
    private ntv_DisableClientState_1 := GetProcOrNil&<procedure(&array: glEnableCap)>(DisableClientState_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableClientState(&array: glEnableCap) :=
      ntv_DisableClientState_1(&array);
    
    // added in gl1.0, deprecated in gl3.2
    private DrawPixels_adr := GetProcAddress('glDrawPixels');
    private ntv_DrawPixels_1 := GetProcOrNil&<procedure(width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr)>(DrawPixels_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawPixels(width: Int32; height: Int32; format: glPixelFormat; &type: glPixelType; pixels: IntPtr) :=
      ntv_DrawPixels_1(width, height, format, &type, pixels);
    
    // added in gl1.0, deprecated in gl3.2
    private EdgeFlag_adr := GetProcAddress('glEdgeFlag');
    private ntv_EdgeFlag_1 := GetProcOrNil&<procedure(flag: glBool8)>(EdgeFlag_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlag(flag: glBool8) :=
      ntv_EdgeFlag_1(flag);
    
    // added in gl1.1, deprecated in gl3.2
    private EdgeFlagPointer_adr := GetProcAddress('glEdgeFlagPointer');
    private ntv_EdgeFlagPointer_1 := GetProcOrNil&<procedure(stride: Int32; pointer: IntPtr)>(EdgeFlagPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointer(stride: Int32; pointer: IntPtr) :=
      ntv_EdgeFlagPointer_1(stride, pointer);
    
    // added in gl1.0, deprecated in gl3.2
    private EdgeFlagv_adr := GetProcAddress('glEdgeFlagv');
    private ntv_EdgeFlagv_1 := GetProcOrNil&<procedure(var flag: glBool8)>(EdgeFlagv_adr);
    private ntv_EdgeFlagv_2 := GetProcOrNil&<procedure(flag: IntPtr)>(EdgeFlagv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagv(flag: array of glBool8);
    type PGlBool8 = ^glBool8;
    begin
      if (flag<>nil) and (flag.Length<>0) then
        ntv_EdgeFlagv_1(flag[0]) else
        ntv_EdgeFlagv_1(PGlBool8(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagv(var flag: glBool8) :=
      ntv_EdgeFlagv_1(flag);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagv(flag: IntPtr) :=
      ntv_EdgeFlagv_2(flag);
    
    // added in gl1.1, deprecated in gl3.2
    private EnableClientState_adr := GetProcAddress('glEnableClientState');
    private ntv_EnableClientState_1 := GetProcOrNil&<procedure(&array: glEnableCap)>(EnableClientState_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableClientState(&array: glEnableCap) :=
      ntv_EnableClientState_1(&array);
    
    // added in gl1.0, deprecated in gl3.2
    private End_adr := GetProcAddress('glEnd');
    private ntv_End_1 := GetProcOrNil&<procedure>(End_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure &End :=
      ntv_End_1;
    
    // added in gl1.0, deprecated in gl3.2
    private EndList_adr := GetProcAddress('glEndList');
    private ntv_EndList_1 := GetProcOrNil&<procedure>(EndList_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndList :=
      ntv_EndList_1;
    
    // added in gl1.0, deprecated in gl3.2
    private EvalCoord1d_adr := GetProcAddress('glEvalCoord1d');
    private ntv_EvalCoord1d_1 := GetProcOrNil&<procedure(u: double)>(EvalCoord1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1d(u: double) :=
      ntv_EvalCoord1d_1(u);
    
    // added in gl1.0, deprecated in gl3.2
    private EvalCoord1dv_adr := GetProcAddress('glEvalCoord1dv');
    private ntv_EvalCoord1dv_1 := GetProcOrNil&<procedure(var u: double)>(EvalCoord1dv_adr);
    private ntv_EvalCoord1dv_2 := GetProcOrNil&<procedure(u: IntPtr)>(EvalCoord1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1dv(u: array of double);
    type PDouble = ^double;
    begin
      if (u<>nil) and (u.Length<>0) then
        ntv_EvalCoord1dv_1(u[0]) else
        ntv_EvalCoord1dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1dv(var u: double) :=
      ntv_EvalCoord1dv_1(u);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1dv(u: IntPtr) :=
      ntv_EvalCoord1dv_2(u);
    
    // added in gl1.0, deprecated in gl3.2
    private EvalCoord1f_adr := GetProcAddress('glEvalCoord1f');
    private ntv_EvalCoord1f_1 := GetProcOrNil&<procedure(u: single)>(EvalCoord1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1f(u: single) :=
      ntv_EvalCoord1f_1(u);
    
    // added in gl1.0, deprecated in gl3.2
    private EvalCoord1fv_adr := GetProcAddress('glEvalCoord1fv');
    private ntv_EvalCoord1fv_1 := GetProcOrNil&<procedure(var u: single)>(EvalCoord1fv_adr);
    private ntv_EvalCoord1fv_2 := GetProcOrNil&<procedure(u: IntPtr)>(EvalCoord1fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1fv(u: array of single);
    type PSingle = ^single;
    begin
      if (u<>nil) and (u.Length<>0) then
        ntv_EvalCoord1fv_1(u[0]) else
        ntv_EvalCoord1fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1fv(var u: single) :=
      ntv_EvalCoord1fv_1(u);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1fv(u: IntPtr) :=
      ntv_EvalCoord1fv_2(u);
    
    // added in gl1.0, deprecated in gl3.2
    private EvalCoord2d_adr := GetProcAddress('glEvalCoord2d');
    private ntv_EvalCoord2d_1 := GetProcOrNil&<procedure(u: double; v: double)>(EvalCoord2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2d(u: double; v: double) :=
      ntv_EvalCoord2d_1(u, v);
    
    // added in gl1.0, deprecated in gl3.2
    private EvalCoord2dv_adr := GetProcAddress('glEvalCoord2dv');
    private ntv_EvalCoord2dv_1 := GetProcOrNil&<procedure(var u: double)>(EvalCoord2dv_adr);
    private ntv_EvalCoord2dv_2 := GetProcOrNil&<procedure(var u: Vec2d)>(EvalCoord2dv_adr);
    private ntv_EvalCoord2dv_3 := GetProcOrNil&<procedure(u: IntPtr)>(EvalCoord2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2dv(u: array of double);
    type PDouble = ^double;
    begin
      if (u<>nil) and (u.Length<>0) then
        ntv_EvalCoord2dv_1(u[0]) else
        ntv_EvalCoord2dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2dv(var u: Vec2d) :=
      ntv_EvalCoord2dv_2(u);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2dv(var u: double) :=
      ntv_EvalCoord2dv_1(u);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2dv(u: IntPtr) :=
      ntv_EvalCoord2dv_3(u);
    
    // added in gl1.0, deprecated in gl3.2
    private EvalCoord2f_adr := GetProcAddress('glEvalCoord2f');
    private ntv_EvalCoord2f_1 := GetProcOrNil&<procedure(u: single; v: single)>(EvalCoord2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2f(u: single; v: single) :=
      ntv_EvalCoord2f_1(u, v);
    
    // added in gl1.0, deprecated in gl3.2
    private EvalCoord2fv_adr := GetProcAddress('glEvalCoord2fv');
    private ntv_EvalCoord2fv_1 := GetProcOrNil&<procedure(var u: single)>(EvalCoord2fv_adr);
    private ntv_EvalCoord2fv_2 := GetProcOrNil&<procedure(var u: Vec2f)>(EvalCoord2fv_adr);
    private ntv_EvalCoord2fv_3 := GetProcOrNil&<procedure(u: IntPtr)>(EvalCoord2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2fv(u: array of single);
    type PSingle = ^single;
    begin
      if (u<>nil) and (u.Length<>0) then
        ntv_EvalCoord2fv_1(u[0]) else
        ntv_EvalCoord2fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2fv(var u: Vec2f) :=
      ntv_EvalCoord2fv_2(u);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2fv(var u: single) :=
      ntv_EvalCoord2fv_1(u);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2fv(u: IntPtr) :=
      ntv_EvalCoord2fv_3(u);
    
    // added in gl1.0, deprecated in gl3.2
    private EvalMesh1_adr := GetProcAddress('glEvalMesh1');
    private ntv_EvalMesh1_1 := GetProcOrNil&<procedure(mode: glMeshMode1; i1: Int32; i2: Int32)>(EvalMesh1_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalMesh1(mode: glMeshMode1; i1: Int32; i2: Int32) :=
      ntv_EvalMesh1_1(mode, i1, i2);
    
    // added in gl1.0, deprecated in gl3.2
    private EvalMesh2_adr := GetProcAddress('glEvalMesh2');
    private ntv_EvalMesh2_1 := GetProcOrNil&<procedure(mode: glMeshMode2; i1: Int32; i2: Int32; j1: Int32; j2: Int32)>(EvalMesh2_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalMesh2(mode: glMeshMode2; i1: Int32; i2: Int32; j1: Int32; j2: Int32) :=
      ntv_EvalMesh2_1(mode, i1, i2, j1, j2);
    
    // added in gl1.0, deprecated in gl3.2
    private EvalPoint1_adr := GetProcAddress('glEvalPoint1');
    private ntv_EvalPoint1_1 := GetProcOrNil&<procedure(i: Int32)>(EvalPoint1_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalPoint1(i: Int32) :=
      ntv_EvalPoint1_1(i);
    
    // added in gl1.0, deprecated in gl3.2
    private EvalPoint2_adr := GetProcAddress('glEvalPoint2');
    private ntv_EvalPoint2_1 := GetProcOrNil&<procedure(i: Int32; j: Int32)>(EvalPoint2_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalPoint2(i: Int32; j: Int32) :=
      ntv_EvalPoint2_1(i, j);
    
    // added in gl1.0, deprecated in gl3.2
    private FeedbackBuffer_adr := GetProcAddress('glFeedbackBuffer');
    private ntv_FeedbackBuffer_1 := GetProcOrNil&<procedure(size: Int32; &type: glFeedbackType; var buffer: glFeedBackToken)>(FeedbackBuffer_adr);
    private ntv_FeedbackBuffer_2 := GetProcOrNil&<procedure(size: Int32; &type: glFeedbackType; buffer: IntPtr)>(FeedbackBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBuffer(size: Int32; &type: glFeedbackType; buffer: array of glFeedBackToken);
    type PGlFeedBackToken = ^glFeedBackToken;
    begin
      if (buffer<>nil) and (buffer.Length<>0) then
        ntv_FeedbackBuffer_1(size, &type, buffer[0]) else
        ntv_FeedbackBuffer_1(size, &type, PGlFeedBackToken(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBuffer(size: Int32; &type: glFeedbackType; var buffer: glFeedBackToken) :=
      ntv_FeedbackBuffer_1(size, &type, buffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBuffer(size: Int32; &type: glFeedbackType; buffer: IntPtr) :=
      ntv_FeedbackBuffer_2(size, &type, buffer);
    
    // added in gl1.4, deprecated in gl3.2
    private FogCoordd_adr := GetProcAddress('glFogCoordd');
    private ntv_FogCoordd_1 := GetProcOrNil&<procedure(coord: double)>(FogCoordd_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordd(coord: double) :=
      ntv_FogCoordd_1(coord);
    
    // added in gl1.4, deprecated in gl3.2
    private FogCoorddv_adr := GetProcAddress('glFogCoorddv');
    private ntv_FogCoorddv_1 := GetProcOrNil&<procedure(var coord: double)>(FogCoorddv_adr);
    private ntv_FogCoorddv_2 := GetProcOrNil&<procedure(coord: IntPtr)>(FogCoorddv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddv(coord: array of double);
    type PDouble = ^double;
    begin
      if (coord<>nil) and (coord.Length<>0) then
        ntv_FogCoorddv_1(coord[0]) else
        ntv_FogCoorddv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddv(var coord: double) :=
      ntv_FogCoorddv_1(coord);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddv(coord: IntPtr) :=
      ntv_FogCoorddv_2(coord);
    
    // added in gl1.4, deprecated in gl3.2
    private FogCoordf_adr := GetProcAddress('glFogCoordf');
    private ntv_FogCoordf_1 := GetProcOrNil&<procedure(coord: single)>(FogCoordf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordf(coord: single) :=
      ntv_FogCoordf_1(coord);
    
    // added in gl1.4, deprecated in gl3.2
    private FogCoordfv_adr := GetProcAddress('glFogCoordfv');
    private ntv_FogCoordfv_1 := GetProcOrNil&<procedure(var coord: single)>(FogCoordfv_adr);
    private ntv_FogCoordfv_2 := GetProcOrNil&<procedure(coord: IntPtr)>(FogCoordfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfv(coord: array of single);
    type PSingle = ^single;
    begin
      if (coord<>nil) and (coord.Length<>0) then
        ntv_FogCoordfv_1(coord[0]) else
        ntv_FogCoordfv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfv(var coord: single) :=
      ntv_FogCoordfv_1(coord);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfv(coord: IntPtr) :=
      ntv_FogCoordfv_2(coord);
    
    // added in gl1.4, deprecated in gl3.2
    private FogCoordPointer_adr := GetProcAddress('glFogCoordPointer');
    private ntv_FogCoordPointer_1 := GetProcOrNil&<procedure(&type: glFogPointerType; stride: Int32; pointer: IntPtr)>(FogCoordPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointer(&type: glFogPointerType; stride: Int32; pointer: IntPtr) :=
      ntv_FogCoordPointer_1(&type, stride, pointer);
    
    // added in gl1.0, deprecated in gl3.2
    private Fogf_adr := GetProcAddress('glFogf');
    private ntv_Fogf_1 := GetProcOrNil&<procedure(pname: glFogParameter; param: single)>(Fogf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogf(pname: glFogParameter; param: single) :=
      ntv_Fogf_1(pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private Fogfv_adr := GetProcAddress('glFogfv');
    private ntv_Fogfv_1 := GetProcOrNil&<procedure(pname: glFogParameter; var &params: single)>(Fogfv_adr);
    private ntv_Fogfv_2 := GetProcOrNil&<procedure(pname: glFogParameter; &params: IntPtr)>(Fogfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogfv(pname: glFogParameter; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_Fogfv_1(pname, &params[0]) else
        ntv_Fogfv_1(pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogfv(pname: glFogParameter; var &params: single) :=
      ntv_Fogfv_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogfv(pname: glFogParameter; &params: IntPtr) :=
      ntv_Fogfv_2(pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private Fogi_adr := GetProcAddress('glFogi');
    private ntv_Fogi_1 := GetProcOrNil&<procedure(pname: glFogParameter; param: glFogCoordSrc)>(Fogi_adr);
    private ntv_Fogi_2 := GetProcOrNil&<procedure(pname: glFogParameter; param: glFogMode)>(Fogi_adr);
    private ntv_Fogi_3 := GetProcOrNil&<procedure(pname: glFogParameter; param: Int32)>(Fogi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogi(pname: glFogParameter; param: glFogCoordSrc) :=
      ntv_Fogi_1(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogi(pname: glFogParameter; param: glFogMode) :=
      ntv_Fogi_2(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogi(pname: glFogParameter; param: Int32) :=
      ntv_Fogi_3(pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private Fogiv_adr := GetProcAddress('glFogiv');
    private ntv_Fogiv_1 := GetProcOrNil&<procedure(pname: glFogParameter; var &params: Int32)>(Fogiv_adr);
    private ntv_Fogiv_2 := GetProcOrNil&<procedure(pname: glFogParameter; &params: IntPtr)>(Fogiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogiv(pname: glFogParameter; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_Fogiv_1(pname, &params[0]) else
        ntv_Fogiv_1(pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogiv(pname: glFogParameter; var &params: Int32) :=
      ntv_Fogiv_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogiv(pname: glFogParameter; &params: IntPtr) :=
      ntv_Fogiv_2(pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private Frustum_adr := GetProcAddress('glFrustum');
    private ntv_Frustum_1 := GetProcOrNil&<procedure(left: double; right: double; bottom: double; top: double; zNear: double; zFar: double)>(Frustum_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Frustum(left: double; right: double; bottom: double; top: double; zNear: double; zFar: double) :=
      ntv_Frustum_1(left, right, bottom, top, zNear, zFar);
    
    // added in gl1.0, deprecated in gl3.2
    private GenLists_adr := GetProcAddress('glGenLists');
    private ntv_GenLists_1 := GetProcOrNil&<function(range: Int32): gl_display_list>(GenLists_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenLists(range: Int32): gl_display_list :=
      ntv_GenLists_1(range);
    
    // added in gl1.0, deprecated in gl3.2
    private GetClipPlane_adr := GetProcAddress('glGetClipPlane');
    private ntv_GetClipPlane_1 := GetProcOrNil&<procedure(plane: glClipPlaneName; var equation: double)>(GetClipPlane_adr);
    private ntv_GetClipPlane_2 := GetProcOrNil&<procedure(plane: glClipPlaneName; equation: IntPtr)>(GetClipPlane_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlane(plane: glClipPlaneName; var equation: double) :=
      ntv_GetClipPlane_1(plane, equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlane(plane: glClipPlaneName; equation: IntPtr) :=
      ntv_GetClipPlane_2(plane, equation);
    
    // added in gl1.0, deprecated in gl3.2
    private GetLightfv_adr := GetProcAddress('glGetLightfv');
    private ntv_GetLightfv_1 := GetProcOrNil&<procedure(light: glLightName; pname: glLightParameter; var &params: single)>(GetLightfv_adr);
    private ntv_GetLightfv_2 := GetProcOrNil&<procedure(light: glLightName; pname: glLightParameter; &params: IntPtr)>(GetLightfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightfv(light: glLightName; pname: glLightParameter; var &params: single) :=
      ntv_GetLightfv_1(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightfv(light: glLightName; pname: glLightParameter; &params: IntPtr) :=
      ntv_GetLightfv_2(light, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private GetLightiv_adr := GetProcAddress('glGetLightiv');
    private ntv_GetLightiv_1 := GetProcOrNil&<procedure(light: glLightName; pname: glLightParameter; var &params: Int32)>(GetLightiv_adr);
    private ntv_GetLightiv_2 := GetProcOrNil&<procedure(light: glLightName; pname: glLightParameter; &params: IntPtr)>(GetLightiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightiv(light: glLightName; pname: glLightParameter; var &params: Int32) :=
      ntv_GetLightiv_1(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightiv(light: glLightName; pname: glLightParameter; &params: IntPtr) :=
      ntv_GetLightiv_2(light, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private GetMapdv_adr := GetProcAddress('glGetMapdv');
    private ntv_GetMapdv_1 := GetProcOrNil&<procedure(target: glMapTarget; query: glGetMapQuery; var v: double)>(GetMapdv_adr);
    private ntv_GetMapdv_2 := GetProcOrNil&<procedure(target: glMapTarget; query: glGetMapQuery; v: IntPtr)>(GetMapdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapdv(target: glMapTarget; query: glGetMapQuery; var v: double) :=
      ntv_GetMapdv_1(target, query, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapdv(target: glMapTarget; query: glGetMapQuery; v: IntPtr) :=
      ntv_GetMapdv_2(target, query, v);
    
    // added in gl1.0, deprecated in gl3.2
    private GetMapfv_adr := GetProcAddress('glGetMapfv');
    private ntv_GetMapfv_1 := GetProcOrNil&<procedure(target: glMapTarget; query: glGetMapQuery; var v: single)>(GetMapfv_adr);
    private ntv_GetMapfv_2 := GetProcOrNil&<procedure(target: glMapTarget; query: glGetMapQuery; v: IntPtr)>(GetMapfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapfv(target: glMapTarget; query: glGetMapQuery; var v: single) :=
      ntv_GetMapfv_1(target, query, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapfv(target: glMapTarget; query: glGetMapQuery; v: IntPtr) :=
      ntv_GetMapfv_2(target, query, v);
    
    // added in gl1.0, deprecated in gl3.2
    private GetMapiv_adr := GetProcAddress('glGetMapiv');
    private ntv_GetMapiv_1 := GetProcOrNil&<procedure(target: glMapTarget; query: glGetMapQuery; var v: Int32)>(GetMapiv_adr);
    private ntv_GetMapiv_2 := GetProcOrNil&<procedure(target: glMapTarget; query: glGetMapQuery; v: IntPtr)>(GetMapiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapiv(target: glMapTarget; query: glGetMapQuery; var v: Int32) :=
      ntv_GetMapiv_1(target, query, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapiv(target: glMapTarget; query: glGetMapQuery; v: IntPtr) :=
      ntv_GetMapiv_2(target, query, v);
    
    // added in gl1.0, deprecated in gl3.2
    private GetMaterialfv_adr := GetProcAddress('glGetMaterialfv');
    private ntv_GetMaterialfv_1 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; var &params: single)>(GetMaterialfv_adr);
    private ntv_GetMaterialfv_2 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; &params: IntPtr)>(GetMaterialfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialfv(face: glTriangleFace; pname: glMaterialParameter; var &params: single) :=
      ntv_GetMaterialfv_1(face, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialfv(face: glTriangleFace; pname: glMaterialParameter; &params: IntPtr) :=
      ntv_GetMaterialfv_2(face, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private GetMaterialiv_adr := GetProcAddress('glGetMaterialiv');
    private ntv_GetMaterialiv_1 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; var &params: Int32)>(GetMaterialiv_adr);
    private ntv_GetMaterialiv_2 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; &params: IntPtr)>(GetMaterialiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialiv(face: glTriangleFace; pname: glMaterialParameter; var &params: Int32) :=
      ntv_GetMaterialiv_1(face, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialiv(face: glTriangleFace; pname: glMaterialParameter; &params: IntPtr) :=
      ntv_GetMaterialiv_2(face, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private GetPixelMapfv_adr := GetProcAddress('glGetPixelMapfv');
    private ntv_GetPixelMapfv_1 := GetProcOrNil&<procedure(map: glPixelMap; var values: single)>(GetPixelMapfv_adr);
    private ntv_GetPixelMapfv_2 := GetProcOrNil&<procedure(map: glPixelMap; values: IntPtr)>(GetPixelMapfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapfv(map: glPixelMap; var values: single) :=
      ntv_GetPixelMapfv_1(map, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapfv(map: glPixelMap; values: IntPtr) :=
      ntv_GetPixelMapfv_2(map, values);
    
    // added in gl1.0, deprecated in gl3.2
    private GetPixelMapuiv_adr := GetProcAddress('glGetPixelMapuiv');
    private ntv_GetPixelMapuiv_1 := GetProcOrNil&<procedure(map: glPixelMap; var values: UInt32)>(GetPixelMapuiv_adr);
    private ntv_GetPixelMapuiv_2 := GetProcOrNil&<procedure(map: glPixelMap; values: IntPtr)>(GetPixelMapuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapuiv(map: glPixelMap; var values: UInt32) :=
      ntv_GetPixelMapuiv_1(map, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapuiv(map: glPixelMap; values: IntPtr) :=
      ntv_GetPixelMapuiv_2(map, values);
    
    // added in gl1.0, deprecated in gl3.2
    private GetPixelMapusv_adr := GetProcAddress('glGetPixelMapusv');
    private ntv_GetPixelMapusv_1 := GetProcOrNil&<procedure(map: glPixelMap; var values: UInt16)>(GetPixelMapusv_adr);
    private ntv_GetPixelMapusv_2 := GetProcOrNil&<procedure(map: glPixelMap; values: IntPtr)>(GetPixelMapusv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapusv(map: glPixelMap; var values: UInt16) :=
      ntv_GetPixelMapusv_1(map, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapusv(map: glPixelMap; values: IntPtr) :=
      ntv_GetPixelMapusv_2(map, values);
    
    // added in gl1.0, deprecated in gl3.2
    private GetPolygonStipple_adr := GetProcAddress('glGetPolygonStipple');
    private ntv_GetPolygonStipple_1 := GetProcOrNil&<procedure(var mask: Byte)>(GetPolygonStipple_adr);
    private ntv_GetPolygonStipple_2 := GetProcOrNil&<procedure(mask: IntPtr)>(GetPolygonStipple_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPolygonStipple(var mask: Byte) :=
      ntv_GetPolygonStipple_1(mask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPolygonStipple(mask: IntPtr) :=
      ntv_GetPolygonStipple_2(mask);
    
    // added in gl1.0, deprecated in gl3.2
    private GetTexEnvfv_adr := GetProcAddress('glGetTexEnvfv');
    private ntv_GetTexEnvfv_1 := GetProcOrNil&<procedure(target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: single)>(GetTexEnvfv_adr);
    private ntv_GetTexEnvfv_2 := GetProcOrNil&<procedure(target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr)>(GetTexEnvfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvfv(target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: single) :=
      ntv_GetTexEnvfv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvfv(target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr) :=
      ntv_GetTexEnvfv_2(target, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private GetTexEnviv_adr := GetProcAddress('glGetTexEnviv');
    private ntv_GetTexEnviv_1 := GetProcOrNil&<procedure(target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: Int32)>(GetTexEnviv_adr);
    private ntv_GetTexEnviv_2 := GetProcOrNil&<procedure(target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr)>(GetTexEnviv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnviv(target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: Int32) :=
      ntv_GetTexEnviv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnviv(target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr) :=
      ntv_GetTexEnviv_2(target, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private GetTexGendv_adr := GetProcAddress('glGetTexGendv');
    private ntv_GetTexGendv_1 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; var &params: double)>(GetTexGendv_adr);
    private ntv_GetTexGendv_2 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr)>(GetTexGendv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGendv(coord: glTextureCoordName; pname: glTextureGenParameter; var &params: double) :=
      ntv_GetTexGendv_1(coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGendv(coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr) :=
      ntv_GetTexGendv_2(coord, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private GetTexGenfv_adr := GetProcAddress('glGetTexGenfv');
    private ntv_GetTexGenfv_1 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; var &params: single)>(GetTexGenfv_adr);
    private ntv_GetTexGenfv_2 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr)>(GetTexGenfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenfv(coord: glTextureCoordName; pname: glTextureGenParameter; var &params: single) :=
      ntv_GetTexGenfv_1(coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenfv(coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr) :=
      ntv_GetTexGenfv_2(coord, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private GetTexGeniv_adr := GetProcAddress('glGetTexGeniv');
    private ntv_GetTexGeniv_1 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; var &params: Int32)>(GetTexGeniv_adr);
    private ntv_GetTexGeniv_2 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr)>(GetTexGeniv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGeniv(coord: glTextureCoordName; pname: glTextureGenParameter; var &params: Int32) :=
      ntv_GetTexGeniv_1(coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGeniv(coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr) :=
      ntv_GetTexGeniv_2(coord, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private Indexd_adr := GetProcAddress('glIndexd');
    private ntv_Indexd_1 := GetProcOrNil&<procedure(c: double)>(Indexd_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexd(c: double) :=
      ntv_Indexd_1(c);
    
    // added in gl1.0, deprecated in gl3.2
    private Indexdv_adr := GetProcAddress('glIndexdv');
    private ntv_Indexdv_1 := GetProcOrNil&<procedure(var c: double)>(Indexdv_adr);
    private ntv_Indexdv_2 := GetProcOrNil&<procedure(c: IntPtr)>(Indexdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexdv(c: array of double);
    type PDouble = ^double;
    begin
      if (c<>nil) and (c.Length<>0) then
        ntv_Indexdv_1(c[0]) else
        ntv_Indexdv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexdv(var c: double) :=
      ntv_Indexdv_1(c);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexdv(c: IntPtr) :=
      ntv_Indexdv_2(c);
    
    // added in gl1.0, deprecated in gl3.2
    private Indexf_adr := GetProcAddress('glIndexf');
    private ntv_Indexf_1 := GetProcOrNil&<procedure(c: single)>(Indexf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexf(c: single) :=
      ntv_Indexf_1(c);
    
    // added in gl1.0, deprecated in gl3.2
    private Indexfv_adr := GetProcAddress('glIndexfv');
    private ntv_Indexfv_1 := GetProcOrNil&<procedure(var c: single)>(Indexfv_adr);
    private ntv_Indexfv_2 := GetProcOrNil&<procedure(c: IntPtr)>(Indexfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexfv(c: array of single);
    type PSingle = ^single;
    begin
      if (c<>nil) and (c.Length<>0) then
        ntv_Indexfv_1(c[0]) else
        ntv_Indexfv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexfv(var c: single) :=
      ntv_Indexfv_1(c);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexfv(c: IntPtr) :=
      ntv_Indexfv_2(c);
    
    // added in gl1.0, deprecated in gl3.2
    private Indexi_adr := GetProcAddress('glIndexi');
    private ntv_Indexi_1 := GetProcOrNil&<procedure(c: Int32)>(Indexi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexi(c: Int32) :=
      ntv_Indexi_1(c);
    
    // added in gl1.0, deprecated in gl3.2
    private Indexiv_adr := GetProcAddress('glIndexiv');
    private ntv_Indexiv_1 := GetProcOrNil&<procedure(var c: Int32)>(Indexiv_adr);
    private ntv_Indexiv_2 := GetProcOrNil&<procedure(c: IntPtr)>(Indexiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexiv(c: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (c<>nil) and (c.Length<>0) then
        ntv_Indexiv_1(c[0]) else
        ntv_Indexiv_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexiv(var c: Int32) :=
      ntv_Indexiv_1(c);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexiv(c: IntPtr) :=
      ntv_Indexiv_2(c);
    
    // added in gl1.0, deprecated in gl3.2
    private IndexMask_adr := GetProcAddress('glIndexMask');
    private ntv_IndexMask_1 := GetProcOrNil&<procedure(mask: UInt32)>(IndexMask_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexMask(mask: UInt32) :=
      ntv_IndexMask_1(mask);
    
    // added in gl1.1, deprecated in gl3.2
    private IndexPointer_adr := GetProcAddress('glIndexPointer');
    private ntv_IndexPointer_1 := GetProcOrNil&<procedure(&type: glIndexPointerType; stride: Int32; pointer: IntPtr)>(IndexPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointer(&type: glIndexPointerType; stride: Int32; pointer: IntPtr) :=
      ntv_IndexPointer_1(&type, stride, pointer);
    
    // added in gl1.0, deprecated in gl3.2
    private Indexs_adr := GetProcAddress('glIndexs');
    private ntv_Indexs_1 := GetProcOrNil&<procedure(c: Int16)>(Indexs_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexs(c: Int16) :=
      ntv_Indexs_1(c);
    
    // added in gl1.0, deprecated in gl3.2
    private Indexsv_adr := GetProcAddress('glIndexsv');
    private ntv_Indexsv_1 := GetProcOrNil&<procedure(var c: Int16)>(Indexsv_adr);
    private ntv_Indexsv_2 := GetProcOrNil&<procedure(c: IntPtr)>(Indexsv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexsv(c: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (c<>nil) and (c.Length<>0) then
        ntv_Indexsv_1(c[0]) else
        ntv_Indexsv_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexsv(var c: Int16) :=
      ntv_Indexsv_1(c);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexsv(c: IntPtr) :=
      ntv_Indexsv_2(c);
    
    // added in gl1.1, deprecated in gl3.2
    private Indexub_adr := GetProcAddress('glIndexub');
    private ntv_Indexub_1 := GetProcOrNil&<procedure(c: Byte)>(Indexub_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexub(c: Byte) :=
      ntv_Indexub_1(c);
    
    // added in gl1.1, deprecated in gl3.2
    private Indexubv_adr := GetProcAddress('glIndexubv');
    private ntv_Indexubv_1 := GetProcOrNil&<procedure(var c: Byte)>(Indexubv_adr);
    private ntv_Indexubv_2 := GetProcOrNil&<procedure(c: IntPtr)>(Indexubv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexubv(c: array of Byte);
    type PByte = ^Byte;
    begin
      if (c<>nil) and (c.Length<>0) then
        ntv_Indexubv_1(c[0]) else
        ntv_Indexubv_1(PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexubv(var c: Byte) :=
      ntv_Indexubv_1(c);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexubv(c: IntPtr) :=
      ntv_Indexubv_2(c);
    
    // added in gl1.0, deprecated in gl3.2
    private InitNames_adr := GetProcAddress('glInitNames');
    private ntv_InitNames_1 := GetProcOrNil&<procedure>(InitNames_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InitNames :=
      ntv_InitNames_1;
    
    // added in gl1.1, deprecated in gl3.2
    private InterleavedArrays_adr := GetProcAddress('glInterleavedArrays');
    private ntv_InterleavedArrays_1 := GetProcOrNil&<procedure(format: glInterleavedArrayFormat; stride: Int32; pointer: IntPtr)>(InterleavedArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InterleavedArrays(format: glInterleavedArrayFormat; stride: Int32; pointer: IntPtr) :=
      ntv_InterleavedArrays_1(format, stride, pointer);
    
    // added in gl1.0, deprecated in gl3.2
    private IsList_adr := GetProcAddress('glIsList');
    private ntv_IsList_1 := GetProcOrNil&<function(list: gl_display_list): glBool8>(IsList_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsList(list: gl_display_list): glBool8 :=
      ntv_IsList_1(list);
    
    // added in gl1.0, deprecated in gl3.2
    private Lightf_adr := GetProcAddress('glLightf');
    private ntv_Lightf_1 := GetProcOrNil&<procedure(light: glLightName; pname: glLightParameter; param: single)>(Lightf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightf(light: glLightName; pname: glLightParameter; param: single) :=
      ntv_Lightf_1(light, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private Lightfv_adr := GetProcAddress('glLightfv');
    private ntv_Lightfv_1 := GetProcOrNil&<procedure(light: glLightName; pname: glLightParameter; var &params: single)>(Lightfv_adr);
    private ntv_Lightfv_2 := GetProcOrNil&<procedure(light: glLightName; pname: glLightParameter; &params: IntPtr)>(Lightfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightfv(light: glLightName; pname: glLightParameter; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_Lightfv_1(light, pname, &params[0]) else
        ntv_Lightfv_1(light, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightfv(light: glLightName; pname: glLightParameter; var &params: single) :=
      ntv_Lightfv_1(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightfv(light: glLightName; pname: glLightParameter; &params: IntPtr) :=
      ntv_Lightfv_2(light, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private Lighti_adr := GetProcAddress('glLighti');
    private ntv_Lighti_1 := GetProcOrNil&<procedure(light: glLightName; pname: glLightParameter; param: glLightModelColorControl)>(Lighti_adr);
    private ntv_Lighti_2 := GetProcOrNil&<procedure(light: glLightName; pname: glLightParameter; param: Int32)>(Lighti_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lighti(light: glLightName; pname: glLightParameter; param: glLightModelColorControl) :=
      ntv_Lighti_1(light, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lighti(light: glLightName; pname: glLightParameter; param: Int32) :=
      ntv_Lighti_2(light, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private Lightiv_adr := GetProcAddress('glLightiv');
    private ntv_Lightiv_1 := GetProcOrNil&<procedure(light: glLightName; pname: glLightParameter; var &params: Int32)>(Lightiv_adr);
    private ntv_Lightiv_2 := GetProcOrNil&<procedure(light: glLightName; pname: glLightParameter; &params: IntPtr)>(Lightiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightiv(light: glLightName; pname: glLightParameter; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_Lightiv_1(light, pname, &params[0]) else
        ntv_Lightiv_1(light, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightiv(light: glLightName; pname: glLightParameter; var &params: Int32) :=
      ntv_Lightiv_1(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightiv(light: glLightName; pname: glLightParameter; &params: IntPtr) :=
      ntv_Lightiv_2(light, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private LightModelf_adr := GetProcAddress('glLightModelf');
    private ntv_LightModelf_1 := GetProcOrNil&<procedure(pname: glLightModelParameter; param: single)>(LightModelf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelf(pname: glLightModelParameter; param: single) :=
      ntv_LightModelf_1(pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private LightModelfv_adr := GetProcAddress('glLightModelfv');
    private ntv_LightModelfv_1 := GetProcOrNil&<procedure(pname: glLightModelParameter; var &params: single)>(LightModelfv_adr);
    private ntv_LightModelfv_2 := GetProcOrNil&<procedure(pname: glLightModelParameter; &params: IntPtr)>(LightModelfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelfv(pname: glLightModelParameter; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_LightModelfv_1(pname, &params[0]) else
        ntv_LightModelfv_1(pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelfv(pname: glLightModelParameter; var &params: single) :=
      ntv_LightModelfv_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelfv(pname: glLightModelParameter; &params: IntPtr) :=
      ntv_LightModelfv_2(pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private LightModeli_adr := GetProcAddress('glLightModeli');
    private ntv_LightModeli_1 := GetProcOrNil&<procedure(pname: glLightModelParameter; param: glLightModelColorControl)>(LightModeli_adr);
    private ntv_LightModeli_2 := GetProcOrNil&<procedure(pname: glLightModelParameter; param: Int32)>(LightModeli_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModeli(pname: glLightModelParameter; param: glLightModelColorControl) :=
      ntv_LightModeli_1(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModeli(pname: glLightModelParameter; param: Int32) :=
      ntv_LightModeli_2(pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private LightModeliv_adr := GetProcAddress('glLightModeliv');
    private ntv_LightModeliv_1 := GetProcOrNil&<procedure(pname: glLightModelParameter; var &params: Int32)>(LightModeliv_adr);
    private ntv_LightModeliv_2 := GetProcOrNil&<procedure(pname: glLightModelParameter; &params: IntPtr)>(LightModeliv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModeliv(pname: glLightModelParameter; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_LightModeliv_1(pname, &params[0]) else
        ntv_LightModeliv_1(pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModeliv(pname: glLightModelParameter; var &params: Int32) :=
      ntv_LightModeliv_1(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModeliv(pname: glLightModelParameter; &params: IntPtr) :=
      ntv_LightModeliv_2(pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private LineStipple_adr := GetProcAddress('glLineStipple');
    private ntv_LineStipple_1 := GetProcOrNil&<procedure(factor: Int32; pattern: UInt16)>(LineStipple_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LineStipple(factor: Int32; pattern: UInt16) :=
      ntv_LineStipple_1(factor, pattern);
    
    // added in gl1.0, deprecated in gl3.2
    private ListBase_adr := GetProcAddress('glListBase');
    private ntv_ListBase_1 := GetProcOrNil&<procedure(base: gl_display_list)>(ListBase_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListBase(base: gl_display_list) :=
      ntv_ListBase_1(base);
    
    // added in gl1.0, deprecated in gl3.2
    private LoadIdentity_adr := GetProcAddress('glLoadIdentity');
    private ntv_LoadIdentity_1 := GetProcOrNil&<procedure>(LoadIdentity_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadIdentity :=
      ntv_LoadIdentity_1;
    
    // added in gl1.0, deprecated in gl3.2
    private LoadMatrixd_adr := GetProcAddress('glLoadMatrixd');
    private ntv_LoadMatrixd_1 := GetProcOrNil&<procedure(var m: double)>(LoadMatrixd_adr);
    private ntv_LoadMatrixd_2 := GetProcOrNil&<procedure(m: IntPtr)>(LoadMatrixd_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixd(m: array of double);
    type PDouble = ^double;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_LoadMatrixd_1(m[0]) else
        ntv_LoadMatrixd_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixd(var m: double) :=
      ntv_LoadMatrixd_1(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixd(m: IntPtr) :=
      ntv_LoadMatrixd_2(m);
    
    // added in gl1.0, deprecated in gl3.2
    private LoadMatrixf_adr := GetProcAddress('glLoadMatrixf');
    private ntv_LoadMatrixf_1 := GetProcOrNil&<procedure(var m: single)>(LoadMatrixf_adr);
    private ntv_LoadMatrixf_2 := GetProcOrNil&<procedure(m: IntPtr)>(LoadMatrixf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixf(m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_LoadMatrixf_1(m[0]) else
        ntv_LoadMatrixf_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixf(var m: single) :=
      ntv_LoadMatrixf_1(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixf(m: IntPtr) :=
      ntv_LoadMatrixf_2(m);
    
    // added in gl1.0, deprecated in gl3.2
    private LoadName_adr := GetProcAddress('glLoadName');
    private ntv_LoadName_1 := GetProcOrNil&<procedure(name: UInt32)>(LoadName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadName(name: UInt32) :=
      ntv_LoadName_1(name);
    
    // added in gl1.3, deprecated in gl3.2
    private LoadTransposeMatrixd_adr := GetProcAddress('glLoadTransposeMatrixd');
    private ntv_LoadTransposeMatrixd_1 := GetProcOrNil&<procedure(var m: double)>(LoadTransposeMatrixd_adr);
    private ntv_LoadTransposeMatrixd_2 := GetProcOrNil&<procedure(m: IntPtr)>(LoadTransposeMatrixd_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixd(m: array of double);
    type PDouble = ^double;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_LoadTransposeMatrixd_1(m[0]) else
        ntv_LoadTransposeMatrixd_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixd(var m: double) :=
      ntv_LoadTransposeMatrixd_1(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixd(m: IntPtr) :=
      ntv_LoadTransposeMatrixd_2(m);
    
    // added in gl1.3, deprecated in gl3.2
    private LoadTransposeMatrixf_adr := GetProcAddress('glLoadTransposeMatrixf');
    private ntv_LoadTransposeMatrixf_1 := GetProcOrNil&<procedure(var m: single)>(LoadTransposeMatrixf_adr);
    private ntv_LoadTransposeMatrixf_2 := GetProcOrNil&<procedure(m: IntPtr)>(LoadTransposeMatrixf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixf(m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_LoadTransposeMatrixf_1(m[0]) else
        ntv_LoadTransposeMatrixf_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixf(var m: single) :=
      ntv_LoadTransposeMatrixf_1(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixf(m: IntPtr) :=
      ntv_LoadTransposeMatrixf_2(m);
    
    // added in gl1.0, deprecated in gl3.2
    private Map1d_adr := GetProcAddress('glMap1d');
    private ntv_Map1d_1 := GetProcOrNil&<procedure(target: glMapTarget; u1: double; u2: double; stride: Int32; order: Int32; var points: double)>(Map1d_adr);
    private ntv_Map1d_2 := GetProcOrNil&<procedure(target: glMapTarget; u1: double; u2: double; stride: Int32; order: Int32; points: IntPtr)>(Map1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1d(target: glMapTarget; u1: double; u2: double; stride: Int32; order: Int32; points: array of double);
    type PDouble = ^double;
    begin
      if (points<>nil) and (points.Length<>0) then
        ntv_Map1d_1(target, u1, u2, stride, order, points[0]) else
        ntv_Map1d_1(target, u1, u2, stride, order, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1d(target: glMapTarget; u1: double; u2: double; stride: Int32; order: Int32; var points: double) :=
      ntv_Map1d_1(target, u1, u2, stride, order, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1d(target: glMapTarget; u1: double; u2: double; stride: Int32; order: Int32; points: IntPtr) :=
      ntv_Map1d_2(target, u1, u2, stride, order, points);
    
    // added in gl1.0, deprecated in gl3.2
    private Map1f_adr := GetProcAddress('glMap1f');
    private ntv_Map1f_1 := GetProcOrNil&<procedure(target: glMapTarget; u1: single; u2: single; stride: Int32; order: Int32; var points: single)>(Map1f_adr);
    private ntv_Map1f_2 := GetProcOrNil&<procedure(target: glMapTarget; u1: single; u2: single; stride: Int32; order: Int32; points: IntPtr)>(Map1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1f(target: glMapTarget; u1: single; u2: single; stride: Int32; order: Int32; points: array of single);
    type PSingle = ^single;
    begin
      if (points<>nil) and (points.Length<>0) then
        ntv_Map1f_1(target, u1, u2, stride, order, points[0]) else
        ntv_Map1f_1(target, u1, u2, stride, order, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1f(target: glMapTarget; u1: single; u2: single; stride: Int32; order: Int32; var points: single) :=
      ntv_Map1f_1(target, u1, u2, stride, order, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1f(target: glMapTarget; u1: single; u2: single; stride: Int32; order: Int32; points: IntPtr) :=
      ntv_Map1f_2(target, u1, u2, stride, order, points);
    
    // added in gl1.0, deprecated in gl3.2
    private Map2d_adr := GetProcAddress('glMap2d');
    private ntv_Map2d_1 := GetProcOrNil&<procedure(target: glMapTarget; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; var points: double)>(Map2d_adr);
    private ntv_Map2d_2 := GetProcOrNil&<procedure(target: glMapTarget; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; points: IntPtr)>(Map2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2d(target: glMapTarget; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; points: array of double);
    type PDouble = ^double;
    begin
      if (points<>nil) and (points.Length<>0) then
        ntv_Map2d_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points[0]) else
        ntv_Map2d_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2d(target: glMapTarget; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; var points: double) :=
      ntv_Map2d_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2d(target: glMapTarget; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; points: IntPtr) :=
      ntv_Map2d_2(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
    // added in gl1.0, deprecated in gl3.2
    private Map2f_adr := GetProcAddress('glMap2f');
    private ntv_Map2f_1 := GetProcOrNil&<procedure(target: glMapTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; var points: single)>(Map2f_adr);
    private ntv_Map2f_2 := GetProcOrNil&<procedure(target: glMapTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: IntPtr)>(Map2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2f(target: glMapTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: array of single);
    type PSingle = ^single;
    begin
      if (points<>nil) and (points.Length<>0) then
        ntv_Map2f_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points[0]) else
        ntv_Map2f_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2f(target: glMapTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; var points: single) :=
      ntv_Map2f_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2f(target: glMapTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: IntPtr) :=
      ntv_Map2f_2(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
    // added in gl1.0, deprecated in gl3.2
    private MapGrid1d_adr := GetProcAddress('glMapGrid1d');
    private ntv_MapGrid1d_1 := GetProcOrNil&<procedure(un: Int32; u1: double; u2: double)>(MapGrid1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid1d(un: Int32; u1: double; u2: double) :=
      ntv_MapGrid1d_1(un, u1, u2);
    
    // added in gl1.0, deprecated in gl3.2
    private MapGrid1f_adr := GetProcAddress('glMapGrid1f');
    private ntv_MapGrid1f_1 := GetProcOrNil&<procedure(un: Int32; u1: single; u2: single)>(MapGrid1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid1f(un: Int32; u1: single; u2: single) :=
      ntv_MapGrid1f_1(un, u1, u2);
    
    // added in gl1.0, deprecated in gl3.2
    private MapGrid2d_adr := GetProcAddress('glMapGrid2d');
    private ntv_MapGrid2d_1 := GetProcOrNil&<procedure(un: Int32; u1: double; u2: double; vn: Int32; v1: double; v2: double)>(MapGrid2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid2d(un: Int32; u1: double; u2: double; vn: Int32; v1: double; v2: double) :=
      ntv_MapGrid2d_1(un, u1, u2, vn, v1, v2);
    
    // added in gl1.0, deprecated in gl3.2
    private MapGrid2f_adr := GetProcAddress('glMapGrid2f');
    private ntv_MapGrid2f_1 := GetProcOrNil&<procedure(un: Int32; u1: single; u2: single; vn: Int32; v1: single; v2: single)>(MapGrid2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid2f(un: Int32; u1: single; u2: single; vn: Int32; v1: single; v2: single) :=
      ntv_MapGrid2f_1(un, u1, u2, vn, v1, v2);
    
    // added in gl1.0, deprecated in gl3.2
    private Materialf_adr := GetProcAddress('glMaterialf');
    private ntv_Materialf_1 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; param: single)>(Materialf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialf(face: glTriangleFace; pname: glMaterialParameter; param: single) :=
      ntv_Materialf_1(face, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private Materialfv_adr := GetProcAddress('glMaterialfv');
    private ntv_Materialfv_1 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; var &params: single)>(Materialfv_adr);
    private ntv_Materialfv_2 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; &params: IntPtr)>(Materialfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialfv(face: glTriangleFace; pname: glMaterialParameter; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_Materialfv_1(face, pname, &params[0]) else
        ntv_Materialfv_1(face, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialfv(face: glTriangleFace; pname: glMaterialParameter; var &params: single) :=
      ntv_Materialfv_1(face, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialfv(face: glTriangleFace; pname: glMaterialParameter; &params: IntPtr) :=
      ntv_Materialfv_2(face, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private Materiali_adr := GetProcAddress('glMateriali');
    private ntv_Materiali_1 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; param: glLightModelColorControl)>(Materiali_adr);
    private ntv_Materiali_2 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; param: Int32)>(Materiali_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materiali(face: glTriangleFace; pname: glMaterialParameter; param: glLightModelColorControl) :=
      ntv_Materiali_1(face, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materiali(face: glTriangleFace; pname: glMaterialParameter; param: Int32) :=
      ntv_Materiali_2(face, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private Materialiv_adr := GetProcAddress('glMaterialiv');
    private ntv_Materialiv_1 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; var &params: Int32)>(Materialiv_adr);
    private ntv_Materialiv_2 := GetProcOrNil&<procedure(face: glTriangleFace; pname: glMaterialParameter; &params: IntPtr)>(Materialiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialiv(face: glTriangleFace; pname: glMaterialParameter; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_Materialiv_1(face, pname, &params[0]) else
        ntv_Materialiv_1(face, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialiv(face: glTriangleFace; pname: glMaterialParameter; var &params: Int32) :=
      ntv_Materialiv_1(face, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialiv(face: glTriangleFace; pname: glMaterialParameter; &params: IntPtr) :=
      ntv_Materialiv_2(face, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private MatrixMode_adr := GetProcAddress('glMatrixMode');
    private ntv_MatrixMode_1 := GetProcOrNil&<procedure(mode: glMatrixMode)>(MatrixMode_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMode(mode: glMatrixMode) :=
      ntv_MatrixMode_1(mode);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord1d_adr := GetProcAddress('glMultiTexCoord1d');
    private ntv_MultiTexCoord1d_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: double)>(MultiTexCoord1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1d(target: glTextureUnit; s: double) :=
      ntv_MultiTexCoord1d_1(target, s);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord1dv_adr := GetProcAddress('glMultiTexCoord1dv');
    private ntv_MultiTexCoord1dv_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: double)>(MultiTexCoord1dv_adr);
    private ntv_MultiTexCoord1dv_2 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dv(target: glTextureUnit; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord1dv_1(target, v[0]) else
        ntv_MultiTexCoord1dv_1(target, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dv(target: glTextureUnit; var v: double) :=
      ntv_MultiTexCoord1dv_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dv(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord1dv_2(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord1f_adr := GetProcAddress('glMultiTexCoord1f');
    private ntv_MultiTexCoord1f_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: single)>(MultiTexCoord1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1f(target: glTextureUnit; s: single) :=
      ntv_MultiTexCoord1f_1(target, s);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord1fv_adr := GetProcAddress('glMultiTexCoord1fv');
    private ntv_MultiTexCoord1fv_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: single)>(MultiTexCoord1fv_adr);
    private ntv_MultiTexCoord1fv_2 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord1fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fv(target: glTextureUnit; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord1fv_1(target, v[0]) else
        ntv_MultiTexCoord1fv_1(target, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fv(target: glTextureUnit; var v: single) :=
      ntv_MultiTexCoord1fv_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fv(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord1fv_2(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord1i_adr := GetProcAddress('glMultiTexCoord1i');
    private ntv_MultiTexCoord1i_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: Int32)>(MultiTexCoord1i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1i(target: glTextureUnit; s: Int32) :=
      ntv_MultiTexCoord1i_1(target, s);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord1iv_adr := GetProcAddress('glMultiTexCoord1iv');
    private ntv_MultiTexCoord1iv_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Int32)>(MultiTexCoord1iv_adr);
    private ntv_MultiTexCoord1iv_2 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord1iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1iv(target: glTextureUnit; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord1iv_1(target, v[0]) else
        ntv_MultiTexCoord1iv_1(target, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1iv(target: glTextureUnit; var v: Int32) :=
      ntv_MultiTexCoord1iv_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1iv(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord1iv_2(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord1s_adr := GetProcAddress('glMultiTexCoord1s');
    private ntv_MultiTexCoord1s_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: Int16)>(MultiTexCoord1s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1s(target: glTextureUnit; s: Int16) :=
      ntv_MultiTexCoord1s_1(target, s);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord1sv_adr := GetProcAddress('glMultiTexCoord1sv');
    private ntv_MultiTexCoord1sv_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Int16)>(MultiTexCoord1sv_adr);
    private ntv_MultiTexCoord1sv_2 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord1sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1sv(target: glTextureUnit; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord1sv_1(target, v[0]) else
        ntv_MultiTexCoord1sv_1(target, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1sv(target: glTextureUnit; var v: Int16) :=
      ntv_MultiTexCoord1sv_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1sv(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord1sv_2(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord2d_adr := GetProcAddress('glMultiTexCoord2d');
    private ntv_MultiTexCoord2d_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: double; t: double)>(MultiTexCoord2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2d(target: glTextureUnit; s: double; t: double) :=
      ntv_MultiTexCoord2d_1(target, s, t);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord2dv_adr := GetProcAddress('glMultiTexCoord2dv');
    private ntv_MultiTexCoord2dv_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: double)>(MultiTexCoord2dv_adr);
    private ntv_MultiTexCoord2dv_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec2d)>(MultiTexCoord2dv_adr);
    private ntv_MultiTexCoord2dv_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dv(target: glTextureUnit; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord2dv_1(target, v[0]) else
        ntv_MultiTexCoord2dv_1(target, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dv(target: glTextureUnit; var v: Vec2d) :=
      ntv_MultiTexCoord2dv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dv(target: glTextureUnit; var v: double) :=
      ntv_MultiTexCoord2dv_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dv(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord2dv_3(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord2f_adr := GetProcAddress('glMultiTexCoord2f');
    private ntv_MultiTexCoord2f_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: single; t: single)>(MultiTexCoord2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2f(target: glTextureUnit; s: single; t: single) :=
      ntv_MultiTexCoord2f_1(target, s, t);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord2fv_adr := GetProcAddress('glMultiTexCoord2fv');
    private ntv_MultiTexCoord2fv_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: single)>(MultiTexCoord2fv_adr);
    private ntv_MultiTexCoord2fv_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec2f)>(MultiTexCoord2fv_adr);
    private ntv_MultiTexCoord2fv_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fv(target: glTextureUnit; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord2fv_1(target, v[0]) else
        ntv_MultiTexCoord2fv_1(target, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fv(target: glTextureUnit; var v: Vec2f) :=
      ntv_MultiTexCoord2fv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fv(target: glTextureUnit; var v: single) :=
      ntv_MultiTexCoord2fv_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fv(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord2fv_3(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord2i_adr := GetProcAddress('glMultiTexCoord2i');
    private ntv_MultiTexCoord2i_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: Int32; t: Int32)>(MultiTexCoord2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2i(target: glTextureUnit; s: Int32; t: Int32) :=
      ntv_MultiTexCoord2i_1(target, s, t);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord2iv_adr := GetProcAddress('glMultiTexCoord2iv');
    private ntv_MultiTexCoord2iv_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Int32)>(MultiTexCoord2iv_adr);
    private ntv_MultiTexCoord2iv_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec2i)>(MultiTexCoord2iv_adr);
    private ntv_MultiTexCoord2iv_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2iv(target: glTextureUnit; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord2iv_1(target, v[0]) else
        ntv_MultiTexCoord2iv_1(target, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2iv(target: glTextureUnit; var v: Vec2i) :=
      ntv_MultiTexCoord2iv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2iv(target: glTextureUnit; var v: Int32) :=
      ntv_MultiTexCoord2iv_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2iv(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord2iv_3(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord2s_adr := GetProcAddress('glMultiTexCoord2s');
    private ntv_MultiTexCoord2s_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: Int16; t: Int16)>(MultiTexCoord2s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2s(target: glTextureUnit; s: Int16; t: Int16) :=
      ntv_MultiTexCoord2s_1(target, s, t);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord2sv_adr := GetProcAddress('glMultiTexCoord2sv');
    private ntv_MultiTexCoord2sv_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Int16)>(MultiTexCoord2sv_adr);
    private ntv_MultiTexCoord2sv_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec2s)>(MultiTexCoord2sv_adr);
    private ntv_MultiTexCoord2sv_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord2sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2sv(target: glTextureUnit; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord2sv_1(target, v[0]) else
        ntv_MultiTexCoord2sv_1(target, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2sv(target: glTextureUnit; var v: Vec2s) :=
      ntv_MultiTexCoord2sv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2sv(target: glTextureUnit; var v: Int16) :=
      ntv_MultiTexCoord2sv_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2sv(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord2sv_3(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord3d_adr := GetProcAddress('glMultiTexCoord3d');
    private ntv_MultiTexCoord3d_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: double; t: double; r: double)>(MultiTexCoord3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3d(target: glTextureUnit; s: double; t: double; r: double) :=
      ntv_MultiTexCoord3d_1(target, s, t, r);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord3dv_adr := GetProcAddress('glMultiTexCoord3dv');
    private ntv_MultiTexCoord3dv_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: double)>(MultiTexCoord3dv_adr);
    private ntv_MultiTexCoord3dv_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec3d)>(MultiTexCoord3dv_adr);
    private ntv_MultiTexCoord3dv_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dv(target: glTextureUnit; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord3dv_1(target, v[0]) else
        ntv_MultiTexCoord3dv_1(target, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dv(target: glTextureUnit; var v: Vec3d) :=
      ntv_MultiTexCoord3dv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dv(target: glTextureUnit; var v: double) :=
      ntv_MultiTexCoord3dv_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dv(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord3dv_3(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord3f_adr := GetProcAddress('glMultiTexCoord3f');
    private ntv_MultiTexCoord3f_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: single; t: single; r: single)>(MultiTexCoord3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3f(target: glTextureUnit; s: single; t: single; r: single) :=
      ntv_MultiTexCoord3f_1(target, s, t, r);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord3fv_adr := GetProcAddress('glMultiTexCoord3fv');
    private ntv_MultiTexCoord3fv_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: single)>(MultiTexCoord3fv_adr);
    private ntv_MultiTexCoord3fv_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec3f)>(MultiTexCoord3fv_adr);
    private ntv_MultiTexCoord3fv_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fv(target: glTextureUnit; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord3fv_1(target, v[0]) else
        ntv_MultiTexCoord3fv_1(target, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fv(target: glTextureUnit; var v: Vec3f) :=
      ntv_MultiTexCoord3fv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fv(target: glTextureUnit; var v: single) :=
      ntv_MultiTexCoord3fv_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fv(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord3fv_3(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord3i_adr := GetProcAddress('glMultiTexCoord3i');
    private ntv_MultiTexCoord3i_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: Int32; t: Int32; r: Int32)>(MultiTexCoord3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3i(target: glTextureUnit; s: Int32; t: Int32; r: Int32) :=
      ntv_MultiTexCoord3i_1(target, s, t, r);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord3iv_adr := GetProcAddress('glMultiTexCoord3iv');
    private ntv_MultiTexCoord3iv_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Int32)>(MultiTexCoord3iv_adr);
    private ntv_MultiTexCoord3iv_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec3i)>(MultiTexCoord3iv_adr);
    private ntv_MultiTexCoord3iv_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3iv(target: glTextureUnit; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord3iv_1(target, v[0]) else
        ntv_MultiTexCoord3iv_1(target, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3iv(target: glTextureUnit; var v: Vec3i) :=
      ntv_MultiTexCoord3iv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3iv(target: glTextureUnit; var v: Int32) :=
      ntv_MultiTexCoord3iv_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3iv(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord3iv_3(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord3s_adr := GetProcAddress('glMultiTexCoord3s');
    private ntv_MultiTexCoord3s_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: Int16; t: Int16; r: Int16)>(MultiTexCoord3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3s(target: glTextureUnit; s: Int16; t: Int16; r: Int16) :=
      ntv_MultiTexCoord3s_1(target, s, t, r);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord3sv_adr := GetProcAddress('glMultiTexCoord3sv');
    private ntv_MultiTexCoord3sv_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Int16)>(MultiTexCoord3sv_adr);
    private ntv_MultiTexCoord3sv_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec3s)>(MultiTexCoord3sv_adr);
    private ntv_MultiTexCoord3sv_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3sv(target: glTextureUnit; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord3sv_1(target, v[0]) else
        ntv_MultiTexCoord3sv_1(target, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3sv(target: glTextureUnit; var v: Vec3s) :=
      ntv_MultiTexCoord3sv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3sv(target: glTextureUnit; var v: Int16) :=
      ntv_MultiTexCoord3sv_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3sv(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord3sv_3(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord4d_adr := GetProcAddress('glMultiTexCoord4d');
    private ntv_MultiTexCoord4d_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: double; t: double; r: double; q: double)>(MultiTexCoord4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4d(target: glTextureUnit; s: double; t: double; r: double; q: double) :=
      ntv_MultiTexCoord4d_1(target, s, t, r, q);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord4dv_adr := GetProcAddress('glMultiTexCoord4dv');
    private ntv_MultiTexCoord4dv_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: double)>(MultiTexCoord4dv_adr);
    private ntv_MultiTexCoord4dv_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec4d)>(MultiTexCoord4dv_adr);
    private ntv_MultiTexCoord4dv_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dv(target: glTextureUnit; v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord4dv_1(target, v[0]) else
        ntv_MultiTexCoord4dv_1(target, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dv(target: glTextureUnit; var v: Vec4d) :=
      ntv_MultiTexCoord4dv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dv(target: glTextureUnit; var v: double) :=
      ntv_MultiTexCoord4dv_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dv(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord4dv_3(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord4f_adr := GetProcAddress('glMultiTexCoord4f');
    private ntv_MultiTexCoord4f_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: single; t: single; r: single; q: single)>(MultiTexCoord4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4f(target: glTextureUnit; s: single; t: single; r: single; q: single) :=
      ntv_MultiTexCoord4f_1(target, s, t, r, q);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord4fv_adr := GetProcAddress('glMultiTexCoord4fv');
    private ntv_MultiTexCoord4fv_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: single)>(MultiTexCoord4fv_adr);
    private ntv_MultiTexCoord4fv_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec4f)>(MultiTexCoord4fv_adr);
    private ntv_MultiTexCoord4fv_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fv(target: glTextureUnit; v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord4fv_1(target, v[0]) else
        ntv_MultiTexCoord4fv_1(target, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fv(target: glTextureUnit; var v: Vec4f) :=
      ntv_MultiTexCoord4fv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fv(target: glTextureUnit; var v: single) :=
      ntv_MultiTexCoord4fv_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fv(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord4fv_3(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord4i_adr := GetProcAddress('glMultiTexCoord4i');
    private ntv_MultiTexCoord4i_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: Int32; t: Int32; r: Int32; q: Int32)>(MultiTexCoord4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4i(target: glTextureUnit; s: Int32; t: Int32; r: Int32; q: Int32) :=
      ntv_MultiTexCoord4i_1(target, s, t, r, q);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord4iv_adr := GetProcAddress('glMultiTexCoord4iv');
    private ntv_MultiTexCoord4iv_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Int32)>(MultiTexCoord4iv_adr);
    private ntv_MultiTexCoord4iv_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec4i)>(MultiTexCoord4iv_adr);
    private ntv_MultiTexCoord4iv_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4iv(target: glTextureUnit; v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord4iv_1(target, v[0]) else
        ntv_MultiTexCoord4iv_1(target, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4iv(target: glTextureUnit; var v: Vec4i) :=
      ntv_MultiTexCoord4iv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4iv(target: glTextureUnit; var v: Int32) :=
      ntv_MultiTexCoord4iv_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4iv(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord4iv_3(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord4s_adr := GetProcAddress('glMultiTexCoord4s');
    private ntv_MultiTexCoord4s_1 := GetProcOrNil&<procedure(target: glTextureUnit; s: Int16; t: Int16; r: Int16; q: Int16)>(MultiTexCoord4s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4s(target: glTextureUnit; s: Int16; t: Int16; r: Int16; q: Int16) :=
      ntv_MultiTexCoord4s_1(target, s, t, r, q);
    
    // added in gl1.3, deprecated in gl3.2
    private MultiTexCoord4sv_adr := GetProcAddress('glMultiTexCoord4sv');
    private ntv_MultiTexCoord4sv_1 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Int16)>(MultiTexCoord4sv_adr);
    private ntv_MultiTexCoord4sv_2 := GetProcOrNil&<procedure(target: glTextureUnit; var v: Vec4s)>(MultiTexCoord4sv_adr);
    private ntv_MultiTexCoord4sv_3 := GetProcOrNil&<procedure(target: glTextureUnit; v: IntPtr)>(MultiTexCoord4sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4sv(target: glTextureUnit; v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_MultiTexCoord4sv_1(target, v[0]) else
        ntv_MultiTexCoord4sv_1(target, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4sv(target: glTextureUnit; var v: Vec4s) :=
      ntv_MultiTexCoord4sv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4sv(target: glTextureUnit; var v: Int16) :=
      ntv_MultiTexCoord4sv_1(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4sv(target: glTextureUnit; v: IntPtr) :=
      ntv_MultiTexCoord4sv_3(target, v);
    
    // added in gl1.0, deprecated in gl3.2
    private MultMatrixd_adr := GetProcAddress('glMultMatrixd');
    private ntv_MultMatrixd_1 := GetProcOrNil&<procedure(var m: double)>(MultMatrixd_adr);
    private ntv_MultMatrixd_2 := GetProcOrNil&<procedure(m: IntPtr)>(MultMatrixd_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixd(m: array of double);
    type PDouble = ^double;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MultMatrixd_1(m[0]) else
        ntv_MultMatrixd_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixd(var m: double) :=
      ntv_MultMatrixd_1(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixd(m: IntPtr) :=
      ntv_MultMatrixd_2(m);
    
    // added in gl1.0, deprecated in gl3.2
    private MultMatrixf_adr := GetProcAddress('glMultMatrixf');
    private ntv_MultMatrixf_1 := GetProcOrNil&<procedure(var m: single)>(MultMatrixf_adr);
    private ntv_MultMatrixf_2 := GetProcOrNil&<procedure(m: IntPtr)>(MultMatrixf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixf(m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MultMatrixf_1(m[0]) else
        ntv_MultMatrixf_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixf(var m: single) :=
      ntv_MultMatrixf_1(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixf(m: IntPtr) :=
      ntv_MultMatrixf_2(m);
    
    // added in gl1.3, deprecated in gl3.2
    private MultTransposeMatrixd_adr := GetProcAddress('glMultTransposeMatrixd');
    private ntv_MultTransposeMatrixd_1 := GetProcOrNil&<procedure(var m: double)>(MultTransposeMatrixd_adr);
    private ntv_MultTransposeMatrixd_2 := GetProcOrNil&<procedure(m: IntPtr)>(MultTransposeMatrixd_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixd(m: array of double);
    type PDouble = ^double;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MultTransposeMatrixd_1(m[0]) else
        ntv_MultTransposeMatrixd_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixd(var m: double) :=
      ntv_MultTransposeMatrixd_1(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixd(m: IntPtr) :=
      ntv_MultTransposeMatrixd_2(m);
    
    // added in gl1.3, deprecated in gl3.2
    private MultTransposeMatrixf_adr := GetProcAddress('glMultTransposeMatrixf');
    private ntv_MultTransposeMatrixf_1 := GetProcOrNil&<procedure(var m: single)>(MultTransposeMatrixf_adr);
    private ntv_MultTransposeMatrixf_2 := GetProcOrNil&<procedure(m: IntPtr)>(MultTransposeMatrixf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixf(m: array of single);
    type PSingle = ^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        ntv_MultTransposeMatrixf_1(m[0]) else
        ntv_MultTransposeMatrixf_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixf(var m: single) :=
      ntv_MultTransposeMatrixf_1(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixf(m: IntPtr) :=
      ntv_MultTransposeMatrixf_2(m);
    
    // added in gl1.0, deprecated in gl3.2
    private NewList_adr := GetProcAddress('glNewList');
    private ntv_NewList_1 := GetProcOrNil&<procedure(list: gl_display_list; mode: glListMode)>(NewList_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NewList(list: gl_display_list; mode: glListMode) :=
      ntv_NewList_1(list, mode);
    
    // added in gl1.0, deprecated in gl3.2
    private Normal3b_adr := GetProcAddress('glNormal3b');
    private ntv_Normal3b_1 := GetProcOrNil&<procedure(nx: SByte; ny: SByte; nz: SByte)>(Normal3b_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3b(nx: SByte; ny: SByte; nz: SByte) :=
      ntv_Normal3b_1(nx, ny, nz);
    
    // added in gl1.0, deprecated in gl3.2
    private Normal3bv_adr := GetProcAddress('glNormal3bv');
    private ntv_Normal3bv_1 := GetProcOrNil&<procedure(var v: SByte)>(Normal3bv_adr);
    private ntv_Normal3bv_2 := GetProcOrNil&<procedure(v: IntPtr)>(Normal3bv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3bv(v: array of SByte);
    type PSByte = ^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Normal3bv_1(v[0]) else
        ntv_Normal3bv_1(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3bv(var v: SByte) :=
      ntv_Normal3bv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3bv(v: IntPtr) :=
      ntv_Normal3bv_2(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Normal3d_adr := GetProcAddress('glNormal3d');
    private ntv_Normal3d_1 := GetProcOrNil&<procedure(nx: double; ny: double; nz: double)>(Normal3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3d(nx: double; ny: double; nz: double) :=
      ntv_Normal3d_1(nx, ny, nz);
    
    // added in gl1.0, deprecated in gl3.2
    private Normal3dv_adr := GetProcAddress('glNormal3dv');
    private ntv_Normal3dv_1 := GetProcOrNil&<procedure(var v: double)>(Normal3dv_adr);
    private ntv_Normal3dv_2 := GetProcOrNil&<procedure(var v: Vec3d)>(Normal3dv_adr);
    private ntv_Normal3dv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Normal3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3dv(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Normal3dv_1(v[0]) else
        ntv_Normal3dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3dv(var v: Vec3d) :=
      ntv_Normal3dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3dv(var v: double) :=
      ntv_Normal3dv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3dv(v: IntPtr) :=
      ntv_Normal3dv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Normal3f_adr := GetProcAddress('glNormal3f');
    private ntv_Normal3f_1 := GetProcOrNil&<procedure(nx: single; ny: single; nz: single)>(Normal3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3f(nx: single; ny: single; nz: single) :=
      ntv_Normal3f_1(nx, ny, nz);
    
    // added in gl1.0, deprecated in gl3.2
    private Normal3fv_adr := GetProcAddress('glNormal3fv');
    private ntv_Normal3fv_1 := GetProcOrNil&<procedure(var v: single)>(Normal3fv_adr);
    private ntv_Normal3fv_2 := GetProcOrNil&<procedure(var v: Vec3f)>(Normal3fv_adr);
    private ntv_Normal3fv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Normal3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fv(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Normal3fv_1(v[0]) else
        ntv_Normal3fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fv(var v: Vec3f) :=
      ntv_Normal3fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fv(var v: single) :=
      ntv_Normal3fv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fv(v: IntPtr) :=
      ntv_Normal3fv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Normal3i_adr := GetProcAddress('glNormal3i');
    private ntv_Normal3i_1 := GetProcOrNil&<procedure(nx: Int32; ny: Int32; nz: Int32)>(Normal3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3i(nx: Int32; ny: Int32; nz: Int32) :=
      ntv_Normal3i_1(nx, ny, nz);
    
    // added in gl1.0, deprecated in gl3.2
    private Normal3iv_adr := GetProcAddress('glNormal3iv');
    private ntv_Normal3iv_1 := GetProcOrNil&<procedure(var v: Int32)>(Normal3iv_adr);
    private ntv_Normal3iv_2 := GetProcOrNil&<procedure(var v: Vec3i)>(Normal3iv_adr);
    private ntv_Normal3iv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Normal3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3iv(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Normal3iv_1(v[0]) else
        ntv_Normal3iv_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3iv(var v: Vec3i) :=
      ntv_Normal3iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3iv(var v: Int32) :=
      ntv_Normal3iv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3iv(v: IntPtr) :=
      ntv_Normal3iv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Normal3s_adr := GetProcAddress('glNormal3s');
    private ntv_Normal3s_1 := GetProcOrNil&<procedure(nx: Int16; ny: Int16; nz: Int16)>(Normal3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3s(nx: Int16; ny: Int16; nz: Int16) :=
      ntv_Normal3s_1(nx, ny, nz);
    
    // added in gl1.0, deprecated in gl3.2
    private Normal3sv_adr := GetProcAddress('glNormal3sv');
    private ntv_Normal3sv_1 := GetProcOrNil&<procedure(var v: Int16)>(Normal3sv_adr);
    private ntv_Normal3sv_2 := GetProcOrNil&<procedure(var v: Vec3s)>(Normal3sv_adr);
    private ntv_Normal3sv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Normal3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3sv(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Normal3sv_1(v[0]) else
        ntv_Normal3sv_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3sv(var v: Vec3s) :=
      ntv_Normal3sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3sv(var v: Int16) :=
      ntv_Normal3sv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3sv(v: IntPtr) :=
      ntv_Normal3sv_3(v);
    
    // added in gl1.1, deprecated in gl3.2
    private NormalPointer_adr := GetProcAddress('glNormalPointer');
    private ntv_NormalPointer_1 := GetProcOrNil&<procedure(&type: glNormalPointerType; stride: Int32; pointer: IntPtr)>(NormalPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointer(&type: glNormalPointerType; stride: Int32; pointer: IntPtr) :=
      ntv_NormalPointer_1(&type, stride, pointer);
    
    // added in gl1.0, deprecated in gl3.2
    private Ortho_adr := GetProcAddress('glOrtho');
    private ntv_Ortho_1 := GetProcOrNil&<procedure(left: double; right: double; bottom: double; top: double; zNear: double; zFar: double)>(Ortho_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Ortho(left: double; right: double; bottom: double; top: double; zNear: double; zFar: double) :=
      ntv_Ortho_1(left, right, bottom, top, zNear, zFar);
    
    // added in gl1.0, deprecated in gl3.2
    private PassThrough_adr := GetProcAddress('glPassThrough');
    private ntv_PassThrough_1 := GetProcOrNil&<procedure(token: single)>(PassThrough_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PassThrough(token: single) :=
      ntv_PassThrough_1(token);
    
    // added in gl1.0, deprecated in gl3.2
    private PixelMapfv_adr := GetProcAddress('glPixelMapfv');
    private ntv_PixelMapfv_1 := GetProcOrNil&<procedure(map: glPixelMap; mapsize: Int32; var values: single)>(PixelMapfv_adr);
    private ntv_PixelMapfv_2 := GetProcOrNil&<procedure(map: glPixelMap; mapsize: Int32; values: IntPtr)>(PixelMapfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapfv(map: glPixelMap; mapsize: Int32; values: array of single);
    type PSingle = ^single;
    begin
      if (values<>nil) and (values.Length<>0) then
        ntv_PixelMapfv_1(map, mapsize, values[0]) else
        ntv_PixelMapfv_1(map, mapsize, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapfv(map: glPixelMap; mapsize: Int32; var values: single) :=
      ntv_PixelMapfv_1(map, mapsize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapfv(map: glPixelMap; mapsize: Int32; values: IntPtr) :=
      ntv_PixelMapfv_2(map, mapsize, values);
    
    // added in gl1.0, deprecated in gl3.2
    private PixelMapuiv_adr := GetProcAddress('glPixelMapuiv');
    private ntv_PixelMapuiv_1 := GetProcOrNil&<procedure(map: glPixelMap; mapsize: Int32; var values: UInt32)>(PixelMapuiv_adr);
    private ntv_PixelMapuiv_2 := GetProcOrNil&<procedure(map: glPixelMap; mapsize: Int32; values: IntPtr)>(PixelMapuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapuiv(map: glPixelMap; mapsize: Int32; values: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (values<>nil) and (values.Length<>0) then
        ntv_PixelMapuiv_1(map, mapsize, values[0]) else
        ntv_PixelMapuiv_1(map, mapsize, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapuiv(map: glPixelMap; mapsize: Int32; var values: UInt32) :=
      ntv_PixelMapuiv_1(map, mapsize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapuiv(map: glPixelMap; mapsize: Int32; values: IntPtr) :=
      ntv_PixelMapuiv_2(map, mapsize, values);
    
    // added in gl1.0, deprecated in gl3.2
    private PixelMapusv_adr := GetProcAddress('glPixelMapusv');
    private ntv_PixelMapusv_1 := GetProcOrNil&<procedure(map: glPixelMap; mapsize: Int32; var values: UInt16)>(PixelMapusv_adr);
    private ntv_PixelMapusv_2 := GetProcOrNil&<procedure(map: glPixelMap; mapsize: Int32; values: IntPtr)>(PixelMapusv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapusv(map: glPixelMap; mapsize: Int32; values: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (values<>nil) and (values.Length<>0) then
        ntv_PixelMapusv_1(map, mapsize, values[0]) else
        ntv_PixelMapusv_1(map, mapsize, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapusv(map: glPixelMap; mapsize: Int32; var values: UInt16) :=
      ntv_PixelMapusv_1(map, mapsize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapusv(map: glPixelMap; mapsize: Int32; values: IntPtr) :=
      ntv_PixelMapusv_2(map, mapsize, values);
    
    // added in gl1.0, deprecated in gl3.2
    private PixelTransferf_adr := GetProcAddress('glPixelTransferf');
    private ntv_PixelTransferf_1 := GetProcOrNil&<procedure(pname: glPixelTransferParameter; param: single)>(PixelTransferf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransferf(pname: glPixelTransferParameter; param: single) :=
      ntv_PixelTransferf_1(pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private PixelTransferi_adr := GetProcAddress('glPixelTransferi');
    private ntv_PixelTransferi_1 := GetProcOrNil&<procedure(pname: glPixelTransferParameter; param: Int32)>(PixelTransferi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransferi(pname: glPixelTransferParameter; param: Int32) :=
      ntv_PixelTransferi_1(pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private PixelZoom_adr := GetProcAddress('glPixelZoom');
    private ntv_PixelZoom_1 := GetProcOrNil&<procedure(xfactor: single; yfactor: single)>(PixelZoom_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelZoom(xfactor: single; yfactor: single) :=
      ntv_PixelZoom_1(xfactor, yfactor);
    
    // added in gl1.0, deprecated in gl3.2
    private PolygonStipple_adr := GetProcAddress('glPolygonStipple');
    private ntv_PolygonStipple_1 := GetProcOrNil&<procedure(var mask: Byte)>(PolygonStipple_adr);
    private ntv_PolygonStipple_2 := GetProcOrNil&<procedure(mask: IntPtr)>(PolygonStipple_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonStipple(mask: array of Byte);
    type PByte = ^Byte;
    begin
      if (mask<>nil) and (mask.Length<>0) then
        ntv_PolygonStipple_1(mask[0]) else
        ntv_PolygonStipple_1(PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonStipple(var mask: Byte) :=
      ntv_PolygonStipple_1(mask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonStipple(mask: IntPtr) :=
      ntv_PolygonStipple_2(mask);
    
    // added in gl1.0, deprecated in gl3.2
    private PopAttrib_adr := GetProcAddress('glPopAttrib');
    private ntv_PopAttrib_1 := GetProcOrNil&<procedure>(PopAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopAttrib :=
      ntv_PopAttrib_1;
    
    // added in gl1.1, deprecated in gl3.2
    private PopClientAttrib_adr := GetProcAddress('glPopClientAttrib');
    private ntv_PopClientAttrib_1 := GetProcOrNil&<procedure>(PopClientAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopClientAttrib :=
      ntv_PopClientAttrib_1;
    
    // added in gl1.0, deprecated in gl3.2
    private PopMatrix_adr := GetProcAddress('glPopMatrix');
    private ntv_PopMatrix_1 := GetProcOrNil&<procedure>(PopMatrix_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopMatrix :=
      ntv_PopMatrix_1;
    
    // added in gl1.0, deprecated in gl3.2
    private PopName_adr := GetProcAddress('glPopName');
    private ntv_PopName_1 := GetProcOrNil&<procedure>(PopName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopName :=
      ntv_PopName_1;
    
    // added in gl1.1, deprecated in gl3.2
    private PrioritizeTextures_adr := GetProcAddress('glPrioritizeTextures');
    private ntv_PrioritizeTextures_1 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture; var priorities: single)>(PrioritizeTextures_adr);
    private ntv_PrioritizeTextures_2 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture; priorities: IntPtr)>(PrioritizeTextures_adr);
    private ntv_PrioritizeTextures_3 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr; var priorities: single)>(PrioritizeTextures_adr);
    private ntv_PrioritizeTextures_4 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr; priorities: IntPtr)>(PrioritizeTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; textures: array of gl_texture; priorities: array of single);
    type PGl_texture = ^gl_texture;
    type PSingle = ^single;
    begin
      if (priorities<>nil) and (priorities.Length<>0) then
        if (textures<>nil) and (textures.Length<>0) then
          ntv_PrioritizeTextures_1(n, textures[0], priorities[0]) else
          ntv_PrioritizeTextures_1(n, PGl_texture(nil)^, priorities[0]) else
        if (textures<>nil) and (textures.Length<>0) then
          ntv_PrioritizeTextures_1(n, textures[0], PSingle(nil)^) else
          ntv_PrioritizeTextures_1(n, PGl_texture(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; var textures: gl_texture; var priorities: single) :=
      ntv_PrioritizeTextures_1(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; var textures: gl_texture; priorities: IntPtr) :=
      ntv_PrioritizeTextures_2(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; textures: IntPtr; var priorities: single) :=
      ntv_PrioritizeTextures_3(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; textures: IntPtr; priorities: IntPtr) :=
      ntv_PrioritizeTextures_4(n, textures, priorities);
    
    // added in gl1.0, deprecated in gl3.2
    private PushAttrib_adr := GetProcAddress('glPushAttrib');
    private ntv_PushAttrib_1 := GetProcOrNil&<procedure(mask: glAttribMask)>(PushAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushAttrib(mask: glAttribMask) :=
      ntv_PushAttrib_1(mask);
    
    // added in gl1.1, deprecated in gl3.2
    private PushClientAttrib_adr := GetProcAddress('glPushClientAttrib');
    private ntv_PushClientAttrib_1 := GetProcOrNil&<procedure(mask: glClientAttribMask)>(PushClientAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushClientAttrib(mask: glClientAttribMask) :=
      ntv_PushClientAttrib_1(mask);
    
    // added in gl1.0, deprecated in gl3.2
    private PushMatrix_adr := GetProcAddress('glPushMatrix');
    private ntv_PushMatrix_1 := GetProcOrNil&<procedure>(PushMatrix_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushMatrix :=
      ntv_PushMatrix_1;
    
    // added in gl1.0, deprecated in gl3.2
    private PushName_adr := GetProcAddress('glPushName');
    private ntv_PushName_1 := GetProcOrNil&<procedure(name: UInt32)>(PushName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushName(name: UInt32) :=
      ntv_PushName_1(name);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos2d_adr := GetProcAddress('glRasterPos2d');
    private ntv_RasterPos2d_1 := GetProcOrNil&<procedure(x: double; y: double)>(RasterPos2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2d(x: double; y: double) :=
      ntv_RasterPos2d_1(x, y);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos2dv_adr := GetProcAddress('glRasterPos2dv');
    private ntv_RasterPos2dv_1 := GetProcOrNil&<procedure(var v: double)>(RasterPos2dv_adr);
    private ntv_RasterPos2dv_2 := GetProcOrNil&<procedure(var v: Vec2d)>(RasterPos2dv_adr);
    private ntv_RasterPos2dv_3 := GetProcOrNil&<procedure(v: IntPtr)>(RasterPos2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2dv(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_RasterPos2dv_1(v[0]) else
        ntv_RasterPos2dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2dv(var v: Vec2d) :=
      ntv_RasterPos2dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2dv(var v: double) :=
      ntv_RasterPos2dv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2dv(v: IntPtr) :=
      ntv_RasterPos2dv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos2f_adr := GetProcAddress('glRasterPos2f');
    private ntv_RasterPos2f_1 := GetProcOrNil&<procedure(x: single; y: single)>(RasterPos2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2f(x: single; y: single) :=
      ntv_RasterPos2f_1(x, y);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos2fv_adr := GetProcAddress('glRasterPos2fv');
    private ntv_RasterPos2fv_1 := GetProcOrNil&<procedure(var v: single)>(RasterPos2fv_adr);
    private ntv_RasterPos2fv_2 := GetProcOrNil&<procedure(var v: Vec2f)>(RasterPos2fv_adr);
    private ntv_RasterPos2fv_3 := GetProcOrNil&<procedure(v: IntPtr)>(RasterPos2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2fv(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_RasterPos2fv_1(v[0]) else
        ntv_RasterPos2fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2fv(var v: Vec2f) :=
      ntv_RasterPos2fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2fv(var v: single) :=
      ntv_RasterPos2fv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2fv(v: IntPtr) :=
      ntv_RasterPos2fv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos2i_adr := GetProcAddress('glRasterPos2i');
    private ntv_RasterPos2i_1 := GetProcOrNil&<procedure(x: Int32; y: Int32)>(RasterPos2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2i(x: Int32; y: Int32) :=
      ntv_RasterPos2i_1(x, y);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos2iv_adr := GetProcAddress('glRasterPos2iv');
    private ntv_RasterPos2iv_1 := GetProcOrNil&<procedure(var v: Int32)>(RasterPos2iv_adr);
    private ntv_RasterPos2iv_2 := GetProcOrNil&<procedure(var v: Vec2i)>(RasterPos2iv_adr);
    private ntv_RasterPos2iv_3 := GetProcOrNil&<procedure(v: IntPtr)>(RasterPos2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2iv(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_RasterPos2iv_1(v[0]) else
        ntv_RasterPos2iv_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2iv(var v: Vec2i) :=
      ntv_RasterPos2iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2iv(var v: Int32) :=
      ntv_RasterPos2iv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2iv(v: IntPtr) :=
      ntv_RasterPos2iv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos2s_adr := GetProcAddress('glRasterPos2s');
    private ntv_RasterPos2s_1 := GetProcOrNil&<procedure(x: Int16; y: Int16)>(RasterPos2s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2s(x: Int16; y: Int16) :=
      ntv_RasterPos2s_1(x, y);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos2sv_adr := GetProcAddress('glRasterPos2sv');
    private ntv_RasterPos2sv_1 := GetProcOrNil&<procedure(var v: Int16)>(RasterPos2sv_adr);
    private ntv_RasterPos2sv_2 := GetProcOrNil&<procedure(var v: Vec2s)>(RasterPos2sv_adr);
    private ntv_RasterPos2sv_3 := GetProcOrNil&<procedure(v: IntPtr)>(RasterPos2sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2sv(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_RasterPos2sv_1(v[0]) else
        ntv_RasterPos2sv_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2sv(var v: Vec2s) :=
      ntv_RasterPos2sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2sv(var v: Int16) :=
      ntv_RasterPos2sv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2sv(v: IntPtr) :=
      ntv_RasterPos2sv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos3d_adr := GetProcAddress('glRasterPos3d');
    private ntv_RasterPos3d_1 := GetProcOrNil&<procedure(x: double; y: double; z: double)>(RasterPos3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3d(x: double; y: double; z: double) :=
      ntv_RasterPos3d_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos3dv_adr := GetProcAddress('glRasterPos3dv');
    private ntv_RasterPos3dv_1 := GetProcOrNil&<procedure(var v: double)>(RasterPos3dv_adr);
    private ntv_RasterPos3dv_2 := GetProcOrNil&<procedure(var v: Vec3d)>(RasterPos3dv_adr);
    private ntv_RasterPos3dv_3 := GetProcOrNil&<procedure(v: IntPtr)>(RasterPos3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3dv(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_RasterPos3dv_1(v[0]) else
        ntv_RasterPos3dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3dv(var v: Vec3d) :=
      ntv_RasterPos3dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3dv(var v: double) :=
      ntv_RasterPos3dv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3dv(v: IntPtr) :=
      ntv_RasterPos3dv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos3f_adr := GetProcAddress('glRasterPos3f');
    private ntv_RasterPos3f_1 := GetProcOrNil&<procedure(x: single; y: single; z: single)>(RasterPos3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3f(x: single; y: single; z: single) :=
      ntv_RasterPos3f_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos3fv_adr := GetProcAddress('glRasterPos3fv');
    private ntv_RasterPos3fv_1 := GetProcOrNil&<procedure(var v: single)>(RasterPos3fv_adr);
    private ntv_RasterPos3fv_2 := GetProcOrNil&<procedure(var v: Vec3f)>(RasterPos3fv_adr);
    private ntv_RasterPos3fv_3 := GetProcOrNil&<procedure(v: IntPtr)>(RasterPos3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3fv(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_RasterPos3fv_1(v[0]) else
        ntv_RasterPos3fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3fv(var v: Vec3f) :=
      ntv_RasterPos3fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3fv(var v: single) :=
      ntv_RasterPos3fv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3fv(v: IntPtr) :=
      ntv_RasterPos3fv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos3i_adr := GetProcAddress('glRasterPos3i');
    private ntv_RasterPos3i_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; z: Int32)>(RasterPos3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3i(x: Int32; y: Int32; z: Int32) :=
      ntv_RasterPos3i_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos3iv_adr := GetProcAddress('glRasterPos3iv');
    private ntv_RasterPos3iv_1 := GetProcOrNil&<procedure(var v: Int32)>(RasterPos3iv_adr);
    private ntv_RasterPos3iv_2 := GetProcOrNil&<procedure(var v: Vec3i)>(RasterPos3iv_adr);
    private ntv_RasterPos3iv_3 := GetProcOrNil&<procedure(v: IntPtr)>(RasterPos3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3iv(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_RasterPos3iv_1(v[0]) else
        ntv_RasterPos3iv_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3iv(var v: Vec3i) :=
      ntv_RasterPos3iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3iv(var v: Int32) :=
      ntv_RasterPos3iv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3iv(v: IntPtr) :=
      ntv_RasterPos3iv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos3s_adr := GetProcAddress('glRasterPos3s');
    private ntv_RasterPos3s_1 := GetProcOrNil&<procedure(x: Int16; y: Int16; z: Int16)>(RasterPos3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3s(x: Int16; y: Int16; z: Int16) :=
      ntv_RasterPos3s_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos3sv_adr := GetProcAddress('glRasterPos3sv');
    private ntv_RasterPos3sv_1 := GetProcOrNil&<procedure(var v: Int16)>(RasterPos3sv_adr);
    private ntv_RasterPos3sv_2 := GetProcOrNil&<procedure(var v: Vec3s)>(RasterPos3sv_adr);
    private ntv_RasterPos3sv_3 := GetProcOrNil&<procedure(v: IntPtr)>(RasterPos3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3sv(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_RasterPos3sv_1(v[0]) else
        ntv_RasterPos3sv_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3sv(var v: Vec3s) :=
      ntv_RasterPos3sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3sv(var v: Int16) :=
      ntv_RasterPos3sv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3sv(v: IntPtr) :=
      ntv_RasterPos3sv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos4d_adr := GetProcAddress('glRasterPos4d');
    private ntv_RasterPos4d_1 := GetProcOrNil&<procedure(x: double; y: double; z: double; w: double)>(RasterPos4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4d(x: double; y: double; z: double; w: double) :=
      ntv_RasterPos4d_1(x, y, z, w);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos4dv_adr := GetProcAddress('glRasterPos4dv');
    private ntv_RasterPos4dv_1 := GetProcOrNil&<procedure(var v: double)>(RasterPos4dv_adr);
    private ntv_RasterPos4dv_2 := GetProcOrNil&<procedure(var v: Vec4d)>(RasterPos4dv_adr);
    private ntv_RasterPos4dv_3 := GetProcOrNil&<procedure(v: IntPtr)>(RasterPos4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4dv(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_RasterPos4dv_1(v[0]) else
        ntv_RasterPos4dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4dv(var v: Vec4d) :=
      ntv_RasterPos4dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4dv(var v: double) :=
      ntv_RasterPos4dv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4dv(v: IntPtr) :=
      ntv_RasterPos4dv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos4f_adr := GetProcAddress('glRasterPos4f');
    private ntv_RasterPos4f_1 := GetProcOrNil&<procedure(x: single; y: single; z: single; w: single)>(RasterPos4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4f(x: single; y: single; z: single; w: single) :=
      ntv_RasterPos4f_1(x, y, z, w);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos4fv_adr := GetProcAddress('glRasterPos4fv');
    private ntv_RasterPos4fv_1 := GetProcOrNil&<procedure(var v: single)>(RasterPos4fv_adr);
    private ntv_RasterPos4fv_2 := GetProcOrNil&<procedure(var v: Vec4f)>(RasterPos4fv_adr);
    private ntv_RasterPos4fv_3 := GetProcOrNil&<procedure(v: IntPtr)>(RasterPos4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4fv(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_RasterPos4fv_1(v[0]) else
        ntv_RasterPos4fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4fv(var v: Vec4f) :=
      ntv_RasterPos4fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4fv(var v: single) :=
      ntv_RasterPos4fv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4fv(v: IntPtr) :=
      ntv_RasterPos4fv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos4i_adr := GetProcAddress('glRasterPos4i');
    private ntv_RasterPos4i_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; z: Int32; w: Int32)>(RasterPos4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4i(x: Int32; y: Int32; z: Int32; w: Int32) :=
      ntv_RasterPos4i_1(x, y, z, w);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos4iv_adr := GetProcAddress('glRasterPos4iv');
    private ntv_RasterPos4iv_1 := GetProcOrNil&<procedure(var v: Int32)>(RasterPos4iv_adr);
    private ntv_RasterPos4iv_2 := GetProcOrNil&<procedure(var v: Vec4i)>(RasterPos4iv_adr);
    private ntv_RasterPos4iv_3 := GetProcOrNil&<procedure(v: IntPtr)>(RasterPos4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4iv(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_RasterPos4iv_1(v[0]) else
        ntv_RasterPos4iv_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4iv(var v: Vec4i) :=
      ntv_RasterPos4iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4iv(var v: Int32) :=
      ntv_RasterPos4iv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4iv(v: IntPtr) :=
      ntv_RasterPos4iv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos4s_adr := GetProcAddress('glRasterPos4s');
    private ntv_RasterPos4s_1 := GetProcOrNil&<procedure(x: Int16; y: Int16; z: Int16; w: Int16)>(RasterPos4s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4s(x: Int16; y: Int16; z: Int16; w: Int16) :=
      ntv_RasterPos4s_1(x, y, z, w);
    
    // added in gl1.0, deprecated in gl3.2
    private RasterPos4sv_adr := GetProcAddress('glRasterPos4sv');
    private ntv_RasterPos4sv_1 := GetProcOrNil&<procedure(var v: Int16)>(RasterPos4sv_adr);
    private ntv_RasterPos4sv_2 := GetProcOrNil&<procedure(var v: Vec4s)>(RasterPos4sv_adr);
    private ntv_RasterPos4sv_3 := GetProcOrNil&<procedure(v: IntPtr)>(RasterPos4sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4sv(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_RasterPos4sv_1(v[0]) else
        ntv_RasterPos4sv_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4sv(var v: Vec4s) :=
      ntv_RasterPos4sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4sv(var v: Int16) :=
      ntv_RasterPos4sv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4sv(v: IntPtr) :=
      ntv_RasterPos4sv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Rectd_adr := GetProcAddress('glRectd');
    private ntv_Rectd_1 := GetProcOrNil&<procedure(x1: double; y1: double; x2: double; y2: double)>(Rectd_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectd(x1: double; y1: double; x2: double; y2: double) :=
      ntv_Rectd_1(x1, y1, x2, y2);
    
    // added in gl1.0, deprecated in gl3.2
    private Rectdv_adr := GetProcAddress('glRectdv');
    private ntv_Rectdv_1 := GetProcOrNil&<procedure(var v1: double; var v2: double)>(Rectdv_adr);
    private ntv_Rectdv_2 := GetProcOrNil&<procedure(var v1: Vec2d; var v2: Vec2d)>(Rectdv_adr);
    private ntv_Rectdv_3 := GetProcOrNil&<procedure(var v1: Vec2d; var v2: double)>(Rectdv_adr);
    private ntv_Rectdv_4 := GetProcOrNil&<procedure(var v1: Vec2d; v2: IntPtr)>(Rectdv_adr);
    private ntv_Rectdv_5 := GetProcOrNil&<procedure(var v1: double; var v2: Vec2d)>(Rectdv_adr);
    private ntv_Rectdv_6 := GetProcOrNil&<procedure(var v1: double; v2: IntPtr)>(Rectdv_adr);
    private ntv_Rectdv_7 := GetProcOrNil&<procedure(v1: IntPtr; var v2: Vec2d)>(Rectdv_adr);
    private ntv_Rectdv_8 := GetProcOrNil&<procedure(v1: IntPtr; var v2: double)>(Rectdv_adr);
    private ntv_Rectdv_9 := GetProcOrNil&<procedure(v1: IntPtr; v2: IntPtr)>(Rectdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(v1: array of double; v2: array of double);
    type PDouble = ^double;
    begin
      if (v1<>nil) and (v1.Length<>0) then
        if (v2<>nil) and (v2.Length<>0) then
          ntv_Rectdv_1(v1[0], v2[0]) else
          ntv_Rectdv_1(v1[0], PDouble(nil)^) else
        if (v2<>nil) and (v2.Length<>0) then
          ntv_Rectdv_1(PDouble(nil)^, v2[0]) else
          ntv_Rectdv_1(PDouble(nil)^, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(var v1: Vec2d; var v2: Vec2d) :=
      ntv_Rectdv_2(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(var v1: Vec2d; var v2: double) :=
      ntv_Rectdv_3(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(var v1: Vec2d; v2: IntPtr) :=
      ntv_Rectdv_4(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(var v1: double; var v2: Vec2d) :=
      ntv_Rectdv_5(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(var v1: double; var v2: double) :=
      ntv_Rectdv_1(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(var v1: double; v2: IntPtr) :=
      ntv_Rectdv_6(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(v1: IntPtr; var v2: Vec2d) :=
      ntv_Rectdv_7(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(v1: IntPtr; var v2: double) :=
      ntv_Rectdv_8(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(v1: IntPtr; v2: IntPtr) :=
      ntv_Rectdv_9(v1, v2);
    
    // added in gl1.0, deprecated in gl3.2
    private Rectf_adr := GetProcAddress('glRectf');
    private ntv_Rectf_1 := GetProcOrNil&<procedure(x1: single; y1: single; x2: single; y2: single)>(Rectf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectf(x1: single; y1: single; x2: single; y2: single) :=
      ntv_Rectf_1(x1, y1, x2, y2);
    
    // added in gl1.0, deprecated in gl3.2
    private Rectfv_adr := GetProcAddress('glRectfv');
    private ntv_Rectfv_1 := GetProcOrNil&<procedure(var v1: single; var v2: single)>(Rectfv_adr);
    private ntv_Rectfv_2 := GetProcOrNil&<procedure(var v1: Vec2f; var v2: Vec2f)>(Rectfv_adr);
    private ntv_Rectfv_3 := GetProcOrNil&<procedure(var v1: Vec2f; var v2: single)>(Rectfv_adr);
    private ntv_Rectfv_4 := GetProcOrNil&<procedure(var v1: Vec2f; v2: IntPtr)>(Rectfv_adr);
    private ntv_Rectfv_5 := GetProcOrNil&<procedure(var v1: single; var v2: Vec2f)>(Rectfv_adr);
    private ntv_Rectfv_6 := GetProcOrNil&<procedure(var v1: single; v2: IntPtr)>(Rectfv_adr);
    private ntv_Rectfv_7 := GetProcOrNil&<procedure(v1: IntPtr; var v2: Vec2f)>(Rectfv_adr);
    private ntv_Rectfv_8 := GetProcOrNil&<procedure(v1: IntPtr; var v2: single)>(Rectfv_adr);
    private ntv_Rectfv_9 := GetProcOrNil&<procedure(v1: IntPtr; v2: IntPtr)>(Rectfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(v1: array of single; v2: array of single);
    type PSingle = ^single;
    begin
      if (v1<>nil) and (v1.Length<>0) then
        if (v2<>nil) and (v2.Length<>0) then
          ntv_Rectfv_1(v1[0], v2[0]) else
          ntv_Rectfv_1(v1[0], PSingle(nil)^) else
        if (v2<>nil) and (v2.Length<>0) then
          ntv_Rectfv_1(PSingle(nil)^, v2[0]) else
          ntv_Rectfv_1(PSingle(nil)^, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(var v1: Vec2f; var v2: Vec2f) :=
      ntv_Rectfv_2(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(var v1: Vec2f; var v2: single) :=
      ntv_Rectfv_3(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(var v1: Vec2f; v2: IntPtr) :=
      ntv_Rectfv_4(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(var v1: single; var v2: Vec2f) :=
      ntv_Rectfv_5(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(var v1: single; var v2: single) :=
      ntv_Rectfv_1(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(var v1: single; v2: IntPtr) :=
      ntv_Rectfv_6(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(v1: IntPtr; var v2: Vec2f) :=
      ntv_Rectfv_7(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(v1: IntPtr; var v2: single) :=
      ntv_Rectfv_8(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(v1: IntPtr; v2: IntPtr) :=
      ntv_Rectfv_9(v1, v2);
    
    // added in gl1.0, deprecated in gl3.2
    private Recti_adr := GetProcAddress('glRecti');
    private ntv_Recti_1 := GetProcOrNil&<procedure(x1: Int32; y1: Int32; x2: Int32; y2: Int32)>(Recti_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Recti(x1: Int32; y1: Int32; x2: Int32; y2: Int32) :=
      ntv_Recti_1(x1, y1, x2, y2);
    
    // added in gl1.0, deprecated in gl3.2
    private Rectiv_adr := GetProcAddress('glRectiv');
    private ntv_Rectiv_1 := GetProcOrNil&<procedure(var v1: Int32; var v2: Int32)>(Rectiv_adr);
    private ntv_Rectiv_2 := GetProcOrNil&<procedure(var v1: Vec2i; var v2: Vec2i)>(Rectiv_adr);
    private ntv_Rectiv_3 := GetProcOrNil&<procedure(var v1: Vec2i; var v2: Int32)>(Rectiv_adr);
    private ntv_Rectiv_4 := GetProcOrNil&<procedure(var v1: Vec2i; v2: IntPtr)>(Rectiv_adr);
    private ntv_Rectiv_5 := GetProcOrNil&<procedure(var v1: Int32; var v2: Vec2i)>(Rectiv_adr);
    private ntv_Rectiv_6 := GetProcOrNil&<procedure(var v1: Int32; v2: IntPtr)>(Rectiv_adr);
    private ntv_Rectiv_7 := GetProcOrNil&<procedure(v1: IntPtr; var v2: Vec2i)>(Rectiv_adr);
    private ntv_Rectiv_8 := GetProcOrNil&<procedure(v1: IntPtr; var v2: Int32)>(Rectiv_adr);
    private ntv_Rectiv_9 := GetProcOrNil&<procedure(v1: IntPtr; v2: IntPtr)>(Rectiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(v1: array of Int32; v2: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v1<>nil) and (v1.Length<>0) then
        if (v2<>nil) and (v2.Length<>0) then
          ntv_Rectiv_1(v1[0], v2[0]) else
          ntv_Rectiv_1(v1[0], PInt32(nil)^) else
        if (v2<>nil) and (v2.Length<>0) then
          ntv_Rectiv_1(PInt32(nil)^, v2[0]) else
          ntv_Rectiv_1(PInt32(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(var v1: Vec2i; var v2: Vec2i) :=
      ntv_Rectiv_2(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(var v1: Vec2i; var v2: Int32) :=
      ntv_Rectiv_3(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(var v1: Vec2i; v2: IntPtr) :=
      ntv_Rectiv_4(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(var v1: Int32; var v2: Vec2i) :=
      ntv_Rectiv_5(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(var v1: Int32; var v2: Int32) :=
      ntv_Rectiv_1(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(var v1: Int32; v2: IntPtr) :=
      ntv_Rectiv_6(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(v1: IntPtr; var v2: Vec2i) :=
      ntv_Rectiv_7(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(v1: IntPtr; var v2: Int32) :=
      ntv_Rectiv_8(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(v1: IntPtr; v2: IntPtr) :=
      ntv_Rectiv_9(v1, v2);
    
    // added in gl1.0, deprecated in gl3.2
    private Rects_adr := GetProcAddress('glRects');
    private ntv_Rects_1 := GetProcOrNil&<procedure(x1: Int16; y1: Int16; x2: Int16; y2: Int16)>(Rects_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rects(x1: Int16; y1: Int16; x2: Int16; y2: Int16) :=
      ntv_Rects_1(x1, y1, x2, y2);
    
    // added in gl1.0, deprecated in gl3.2
    private Rectsv_adr := GetProcAddress('glRectsv');
    private ntv_Rectsv_1 := GetProcOrNil&<procedure(var v1: Int16; var v2: Int16)>(Rectsv_adr);
    private ntv_Rectsv_2 := GetProcOrNil&<procedure(var v1: Vec2s; var v2: Vec2s)>(Rectsv_adr);
    private ntv_Rectsv_3 := GetProcOrNil&<procedure(var v1: Vec2s; var v2: Int16)>(Rectsv_adr);
    private ntv_Rectsv_4 := GetProcOrNil&<procedure(var v1: Vec2s; v2: IntPtr)>(Rectsv_adr);
    private ntv_Rectsv_5 := GetProcOrNil&<procedure(var v1: Int16; var v2: Vec2s)>(Rectsv_adr);
    private ntv_Rectsv_6 := GetProcOrNil&<procedure(var v1: Int16; v2: IntPtr)>(Rectsv_adr);
    private ntv_Rectsv_7 := GetProcOrNil&<procedure(v1: IntPtr; var v2: Vec2s)>(Rectsv_adr);
    private ntv_Rectsv_8 := GetProcOrNil&<procedure(v1: IntPtr; var v2: Int16)>(Rectsv_adr);
    private ntv_Rectsv_9 := GetProcOrNil&<procedure(v1: IntPtr; v2: IntPtr)>(Rectsv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(v1: array of Int16; v2: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v1<>nil) and (v1.Length<>0) then
        if (v2<>nil) and (v2.Length<>0) then
          ntv_Rectsv_1(v1[0], v2[0]) else
          ntv_Rectsv_1(v1[0], PInt16(nil)^) else
        if (v2<>nil) and (v2.Length<>0) then
          ntv_Rectsv_1(PInt16(nil)^, v2[0]) else
          ntv_Rectsv_1(PInt16(nil)^, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(var v1: Vec2s; var v2: Vec2s) :=
      ntv_Rectsv_2(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(var v1: Vec2s; var v2: Int16) :=
      ntv_Rectsv_3(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(var v1: Vec2s; v2: IntPtr) :=
      ntv_Rectsv_4(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(var v1: Int16; var v2: Vec2s) :=
      ntv_Rectsv_5(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(var v1: Int16; var v2: Int16) :=
      ntv_Rectsv_1(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(var v1: Int16; v2: IntPtr) :=
      ntv_Rectsv_6(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(v1: IntPtr; var v2: Vec2s) :=
      ntv_Rectsv_7(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(v1: IntPtr; var v2: Int16) :=
      ntv_Rectsv_8(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(v1: IntPtr; v2: IntPtr) :=
      ntv_Rectsv_9(v1, v2);
    
    // added in gl1.0, deprecated in gl3.2
    private RenderMode_adr := GetProcAddress('glRenderMode');
    private ntv_RenderMode_1 := GetProcOrNil&<function(mode: glRenderingMode): Int32>(RenderMode_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RenderMode(mode: glRenderingMode): Int32 :=
      ntv_RenderMode_1(mode);
    
    // added in gl1.0, deprecated in gl3.2
    private Rotated_adr := GetProcAddress('glRotated');
    private ntv_Rotated_1 := GetProcOrNil&<procedure(angle: double; x: double; y: double; z: double)>(Rotated_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rotated(angle: double; x: double; y: double; z: double) :=
      ntv_Rotated_1(angle, x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private Rotatef_adr := GetProcAddress('glRotatef');
    private ntv_Rotatef_1 := GetProcOrNil&<procedure(angle: single; x: single; y: single; z: single)>(Rotatef_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rotatef(angle: single; x: single; y: single; z: single) :=
      ntv_Rotatef_1(angle, x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private Scaled_adr := GetProcAddress('glScaled');
    private ntv_Scaled_1 := GetProcOrNil&<procedure(x: double; y: double; z: double)>(Scaled_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Scaled(x: double; y: double; z: double) :=
      ntv_Scaled_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private Scalef_adr := GetProcAddress('glScalef');
    private ntv_Scalef_1 := GetProcOrNil&<procedure(x: single; y: single; z: single)>(Scalef_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Scalef(x: single; y: single; z: single) :=
      ntv_Scalef_1(x, y, z);
    
    // added in gl1.4, deprecated in gl3.2
    private SecondaryColor3b_adr := GetProcAddress('glSecondaryColor3b');
    private ntv_SecondaryColor3b_1 := GetProcOrNil&<procedure(red: SByte; green: SByte; blue: SByte)>(SecondaryColor3b_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3b(red: SByte; green: SByte; blue: SByte) :=
      ntv_SecondaryColor3b_1(red, green, blue);
    
    // added in gl1.4, deprecated in gl3.2
    private SecondaryColor3bv_adr := GetProcAddress('glSecondaryColor3bv');
    private ntv_SecondaryColor3bv_1 := GetProcOrNil&<procedure(var v: SByte)>(SecondaryColor3bv_adr);
    private ntv_SecondaryColor3bv_2 := GetProcOrNil&<procedure(var v: Vec3b)>(SecondaryColor3bv_adr);
    private ntv_SecondaryColor3bv_3 := GetProcOrNil&<procedure(v: IntPtr)>(SecondaryColor3bv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bv(v: array of SByte);
    type PSByte = ^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_SecondaryColor3bv_1(v[0]) else
        ntv_SecondaryColor3bv_1(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bv(var v: Vec3b) :=
      ntv_SecondaryColor3bv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bv(var v: SByte) :=
      ntv_SecondaryColor3bv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bv(v: IntPtr) :=
      ntv_SecondaryColor3bv_3(v);
    
    // added in gl1.4, deprecated in gl3.2
    private SecondaryColor3d_adr := GetProcAddress('glSecondaryColor3d');
    private ntv_SecondaryColor3d_1 := GetProcOrNil&<procedure(red: double; green: double; blue: double)>(SecondaryColor3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3d(red: double; green: double; blue: double) :=
      ntv_SecondaryColor3d_1(red, green, blue);
    
    // added in gl1.4, deprecated in gl3.2
    private SecondaryColor3dv_adr := GetProcAddress('glSecondaryColor3dv');
    private ntv_SecondaryColor3dv_1 := GetProcOrNil&<procedure(var v: double)>(SecondaryColor3dv_adr);
    private ntv_SecondaryColor3dv_2 := GetProcOrNil&<procedure(var v: Vec3d)>(SecondaryColor3dv_adr);
    private ntv_SecondaryColor3dv_3 := GetProcOrNil&<procedure(v: IntPtr)>(SecondaryColor3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dv(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_SecondaryColor3dv_1(v[0]) else
        ntv_SecondaryColor3dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dv(var v: Vec3d) :=
      ntv_SecondaryColor3dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dv(var v: double) :=
      ntv_SecondaryColor3dv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dv(v: IntPtr) :=
      ntv_SecondaryColor3dv_3(v);
    
    // added in gl1.4, deprecated in gl3.2
    private SecondaryColor3f_adr := GetProcAddress('glSecondaryColor3f');
    private ntv_SecondaryColor3f_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single)>(SecondaryColor3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3f(red: single; green: single; blue: single) :=
      ntv_SecondaryColor3f_1(red, green, blue);
    
    // added in gl1.4, deprecated in gl3.2
    private SecondaryColor3fv_adr := GetProcAddress('glSecondaryColor3fv');
    private ntv_SecondaryColor3fv_1 := GetProcOrNil&<procedure(var v: single)>(SecondaryColor3fv_adr);
    private ntv_SecondaryColor3fv_2 := GetProcOrNil&<procedure(var v: Vec3f)>(SecondaryColor3fv_adr);
    private ntv_SecondaryColor3fv_3 := GetProcOrNil&<procedure(v: IntPtr)>(SecondaryColor3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fv(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_SecondaryColor3fv_1(v[0]) else
        ntv_SecondaryColor3fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fv(var v: Vec3f) :=
      ntv_SecondaryColor3fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fv(var v: single) :=
      ntv_SecondaryColor3fv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fv(v: IntPtr) :=
      ntv_SecondaryColor3fv_3(v);
    
    // added in gl1.4, deprecated in gl3.2
    private SecondaryColor3i_adr := GetProcAddress('glSecondaryColor3i');
    private ntv_SecondaryColor3i_1 := GetProcOrNil&<procedure(red: Int32; green: Int32; blue: Int32)>(SecondaryColor3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3i(red: Int32; green: Int32; blue: Int32) :=
      ntv_SecondaryColor3i_1(red, green, blue);
    
    // added in gl1.4, deprecated in gl3.2
    private SecondaryColor3iv_adr := GetProcAddress('glSecondaryColor3iv');
    private ntv_SecondaryColor3iv_1 := GetProcOrNil&<procedure(var v: Int32)>(SecondaryColor3iv_adr);
    private ntv_SecondaryColor3iv_2 := GetProcOrNil&<procedure(var v: Vec3i)>(SecondaryColor3iv_adr);
    private ntv_SecondaryColor3iv_3 := GetProcOrNil&<procedure(v: IntPtr)>(SecondaryColor3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3iv(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_SecondaryColor3iv_1(v[0]) else
        ntv_SecondaryColor3iv_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3iv(var v: Vec3i) :=
      ntv_SecondaryColor3iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3iv(var v: Int32) :=
      ntv_SecondaryColor3iv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3iv(v: IntPtr) :=
      ntv_SecondaryColor3iv_3(v);
    
    // added in gl1.4, deprecated in gl3.2
    private SecondaryColor3s_adr := GetProcAddress('glSecondaryColor3s');
    private ntv_SecondaryColor3s_1 := GetProcOrNil&<procedure(red: Int16; green: Int16; blue: Int16)>(SecondaryColor3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3s(red: Int16; green: Int16; blue: Int16) :=
      ntv_SecondaryColor3s_1(red, green, blue);
    
    // added in gl1.4, deprecated in gl3.2
    private SecondaryColor3sv_adr := GetProcAddress('glSecondaryColor3sv');
    private ntv_SecondaryColor3sv_1 := GetProcOrNil&<procedure(var v: Int16)>(SecondaryColor3sv_adr);
    private ntv_SecondaryColor3sv_2 := GetProcOrNil&<procedure(var v: Vec3s)>(SecondaryColor3sv_adr);
    private ntv_SecondaryColor3sv_3 := GetProcOrNil&<procedure(v: IntPtr)>(SecondaryColor3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3sv(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_SecondaryColor3sv_1(v[0]) else
        ntv_SecondaryColor3sv_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3sv(var v: Vec3s) :=
      ntv_SecondaryColor3sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3sv(var v: Int16) :=
      ntv_SecondaryColor3sv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3sv(v: IntPtr) :=
      ntv_SecondaryColor3sv_3(v);
    
    // added in gl1.4, deprecated in gl3.2
    private SecondaryColor3ub_adr := GetProcAddress('glSecondaryColor3ub');
    private ntv_SecondaryColor3ub_1 := GetProcOrNil&<procedure(red: Byte; green: Byte; blue: Byte)>(SecondaryColor3ub_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ub(red: Byte; green: Byte; blue: Byte) :=
      ntv_SecondaryColor3ub_1(red, green, blue);
    
    // added in gl1.4, deprecated in gl3.2
    private SecondaryColor3ubv_adr := GetProcAddress('glSecondaryColor3ubv');
    private ntv_SecondaryColor3ubv_1 := GetProcOrNil&<procedure(var v: Byte)>(SecondaryColor3ubv_adr);
    private ntv_SecondaryColor3ubv_2 := GetProcOrNil&<procedure(var v: Vec3ub)>(SecondaryColor3ubv_adr);
    private ntv_SecondaryColor3ubv_3 := GetProcOrNil&<procedure(v: IntPtr)>(SecondaryColor3ubv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubv(v: array of Byte);
    type PByte = ^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_SecondaryColor3ubv_1(v[0]) else
        ntv_SecondaryColor3ubv_1(PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubv(var v: Vec3ub) :=
      ntv_SecondaryColor3ubv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubv(var v: Byte) :=
      ntv_SecondaryColor3ubv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubv(v: IntPtr) :=
      ntv_SecondaryColor3ubv_3(v);
    
    // added in gl1.4, deprecated in gl3.2
    private SecondaryColor3ui_adr := GetProcAddress('glSecondaryColor3ui');
    private ntv_SecondaryColor3ui_1 := GetProcOrNil&<procedure(red: UInt32; green: UInt32; blue: UInt32)>(SecondaryColor3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ui(red: UInt32; green: UInt32; blue: UInt32) :=
      ntv_SecondaryColor3ui_1(red, green, blue);
    
    // added in gl1.4, deprecated in gl3.2
    private SecondaryColor3uiv_adr := GetProcAddress('glSecondaryColor3uiv');
    private ntv_SecondaryColor3uiv_1 := GetProcOrNil&<procedure(var v: UInt32)>(SecondaryColor3uiv_adr);
    private ntv_SecondaryColor3uiv_2 := GetProcOrNil&<procedure(var v: Vec3ui)>(SecondaryColor3uiv_adr);
    private ntv_SecondaryColor3uiv_3 := GetProcOrNil&<procedure(v: IntPtr)>(SecondaryColor3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uiv(v: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_SecondaryColor3uiv_1(v[0]) else
        ntv_SecondaryColor3uiv_1(PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uiv(var v: Vec3ui) :=
      ntv_SecondaryColor3uiv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uiv(var v: UInt32) :=
      ntv_SecondaryColor3uiv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uiv(v: IntPtr) :=
      ntv_SecondaryColor3uiv_3(v);
    
    // added in gl1.4, deprecated in gl3.2
    private SecondaryColor3us_adr := GetProcAddress('glSecondaryColor3us');
    private ntv_SecondaryColor3us_1 := GetProcOrNil&<procedure(red: UInt16; green: UInt16; blue: UInt16)>(SecondaryColor3us_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3us(red: UInt16; green: UInt16; blue: UInt16) :=
      ntv_SecondaryColor3us_1(red, green, blue);
    
    // added in gl1.4, deprecated in gl3.2
    private SecondaryColor3usv_adr := GetProcAddress('glSecondaryColor3usv');
    private ntv_SecondaryColor3usv_1 := GetProcOrNil&<procedure(var v: UInt16)>(SecondaryColor3usv_adr);
    private ntv_SecondaryColor3usv_2 := GetProcOrNil&<procedure(var v: Vec3us)>(SecondaryColor3usv_adr);
    private ntv_SecondaryColor3usv_3 := GetProcOrNil&<procedure(v: IntPtr)>(SecondaryColor3usv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usv(v: array of UInt16);
    type PUInt16 = ^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_SecondaryColor3usv_1(v[0]) else
        ntv_SecondaryColor3usv_1(PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usv(var v: Vec3us) :=
      ntv_SecondaryColor3usv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usv(var v: UInt16) :=
      ntv_SecondaryColor3usv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usv(v: IntPtr) :=
      ntv_SecondaryColor3usv_3(v);
    
    // added in gl1.4, deprecated in gl3.2
    private SecondaryColorPointer_adr := GetProcAddress('glSecondaryColorPointer');
    private ntv_SecondaryColorPointer_1 := GetProcOrNil&<procedure(size: Int32; &type: glColorPointerType; stride: Int32; pointer: IntPtr)>(SecondaryColorPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointer(size: Int32; &type: glColorPointerType; stride: Int32; pointer: IntPtr) :=
      ntv_SecondaryColorPointer_1(size, &type, stride, pointer);
    
    // added in gl1.0, deprecated in gl3.2
    private SelectBuffer_adr := GetProcAddress('glSelectBuffer');
    private ntv_SelectBuffer_1 := GetProcOrNil&<procedure(size: Int32; var buffer: UInt32)>(SelectBuffer_adr);
    private ntv_SelectBuffer_2 := GetProcOrNil&<procedure(size: Int32; buffer: IntPtr)>(SelectBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectBuffer(size: Int32; buffer: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (buffer<>nil) and (buffer.Length<>0) then
        ntv_SelectBuffer_1(size, buffer[0]) else
        ntv_SelectBuffer_1(size, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectBuffer(size: Int32; var buffer: UInt32) :=
      ntv_SelectBuffer_1(size, buffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectBuffer(size: Int32; buffer: IntPtr) :=
      ntv_SelectBuffer_2(size, buffer);
    
    // added in gl1.0, deprecated in gl3.2
    private ShadeModel_adr := GetProcAddress('glShadeModel');
    private ntv_ShadeModel_1 := GetProcOrNil&<procedure(mode: glShadingModel)>(ShadeModel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadeModel(mode: glShadingModel) :=
      ntv_ShadeModel_1(mode);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord1d_adr := GetProcAddress('glTexCoord1d');
    private ntv_TexCoord1d_1 := GetProcOrNil&<procedure(s: double)>(TexCoord1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1d(s: double) :=
      ntv_TexCoord1d_1(s);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord1dv_adr := GetProcAddress('glTexCoord1dv');
    private ntv_TexCoord1dv_1 := GetProcOrNil&<procedure(var v: double)>(TexCoord1dv_adr);
    private ntv_TexCoord1dv_2 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1dv(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord1dv_1(v[0]) else
        ntv_TexCoord1dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1dv(var v: double) :=
      ntv_TexCoord1dv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1dv(v: IntPtr) :=
      ntv_TexCoord1dv_2(v);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord1f_adr := GetProcAddress('glTexCoord1f');
    private ntv_TexCoord1f_1 := GetProcOrNil&<procedure(s: single)>(TexCoord1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1f(s: single) :=
      ntv_TexCoord1f_1(s);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord1fv_adr := GetProcAddress('glTexCoord1fv');
    private ntv_TexCoord1fv_1 := GetProcOrNil&<procedure(var v: single)>(TexCoord1fv_adr);
    private ntv_TexCoord1fv_2 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord1fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1fv(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord1fv_1(v[0]) else
        ntv_TexCoord1fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1fv(var v: single) :=
      ntv_TexCoord1fv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1fv(v: IntPtr) :=
      ntv_TexCoord1fv_2(v);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord1i_adr := GetProcAddress('glTexCoord1i');
    private ntv_TexCoord1i_1 := GetProcOrNil&<procedure(s: Int32)>(TexCoord1i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1i(s: Int32) :=
      ntv_TexCoord1i_1(s);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord1iv_adr := GetProcAddress('glTexCoord1iv');
    private ntv_TexCoord1iv_1 := GetProcOrNil&<procedure(var v: Int32)>(TexCoord1iv_adr);
    private ntv_TexCoord1iv_2 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord1iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1iv(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord1iv_1(v[0]) else
        ntv_TexCoord1iv_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1iv(var v: Int32) :=
      ntv_TexCoord1iv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1iv(v: IntPtr) :=
      ntv_TexCoord1iv_2(v);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord1s_adr := GetProcAddress('glTexCoord1s');
    private ntv_TexCoord1s_1 := GetProcOrNil&<procedure(s: Int16)>(TexCoord1s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1s(s: Int16) :=
      ntv_TexCoord1s_1(s);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord1sv_adr := GetProcAddress('glTexCoord1sv');
    private ntv_TexCoord1sv_1 := GetProcOrNil&<procedure(var v: Int16)>(TexCoord1sv_adr);
    private ntv_TexCoord1sv_2 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord1sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1sv(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord1sv_1(v[0]) else
        ntv_TexCoord1sv_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1sv(var v: Int16) :=
      ntv_TexCoord1sv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1sv(v: IntPtr) :=
      ntv_TexCoord1sv_2(v);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord2d_adr := GetProcAddress('glTexCoord2d');
    private ntv_TexCoord2d_1 := GetProcOrNil&<procedure(s: double; t: double)>(TexCoord2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2d(s: double; t: double) :=
      ntv_TexCoord2d_1(s, t);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord2dv_adr := GetProcAddress('glTexCoord2dv');
    private ntv_TexCoord2dv_1 := GetProcOrNil&<procedure(var v: double)>(TexCoord2dv_adr);
    private ntv_TexCoord2dv_2 := GetProcOrNil&<procedure(var v: Vec2d)>(TexCoord2dv_adr);
    private ntv_TexCoord2dv_3 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2dv(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord2dv_1(v[0]) else
        ntv_TexCoord2dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2dv(var v: Vec2d) :=
      ntv_TexCoord2dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2dv(var v: double) :=
      ntv_TexCoord2dv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2dv(v: IntPtr) :=
      ntv_TexCoord2dv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord2f_adr := GetProcAddress('glTexCoord2f');
    private ntv_TexCoord2f_1 := GetProcOrNil&<procedure(s: single; t: single)>(TexCoord2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2f(s: single; t: single) :=
      ntv_TexCoord2f_1(s, t);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord2fv_adr := GetProcAddress('glTexCoord2fv');
    private ntv_TexCoord2fv_1 := GetProcOrNil&<procedure(var v: single)>(TexCoord2fv_adr);
    private ntv_TexCoord2fv_2 := GetProcOrNil&<procedure(var v: Vec2f)>(TexCoord2fv_adr);
    private ntv_TexCoord2fv_3 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fv(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord2fv_1(v[0]) else
        ntv_TexCoord2fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fv(var v: Vec2f) :=
      ntv_TexCoord2fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fv(var v: single) :=
      ntv_TexCoord2fv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fv(v: IntPtr) :=
      ntv_TexCoord2fv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord2i_adr := GetProcAddress('glTexCoord2i');
    private ntv_TexCoord2i_1 := GetProcOrNil&<procedure(s: Int32; t: Int32)>(TexCoord2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2i(s: Int32; t: Int32) :=
      ntv_TexCoord2i_1(s, t);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord2iv_adr := GetProcAddress('glTexCoord2iv');
    private ntv_TexCoord2iv_1 := GetProcOrNil&<procedure(var v: Int32)>(TexCoord2iv_adr);
    private ntv_TexCoord2iv_2 := GetProcOrNil&<procedure(var v: Vec2i)>(TexCoord2iv_adr);
    private ntv_TexCoord2iv_3 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2iv(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord2iv_1(v[0]) else
        ntv_TexCoord2iv_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2iv(var v: Vec2i) :=
      ntv_TexCoord2iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2iv(var v: Int32) :=
      ntv_TexCoord2iv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2iv(v: IntPtr) :=
      ntv_TexCoord2iv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord2s_adr := GetProcAddress('glTexCoord2s');
    private ntv_TexCoord2s_1 := GetProcOrNil&<procedure(s: Int16; t: Int16)>(TexCoord2s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2s(s: Int16; t: Int16) :=
      ntv_TexCoord2s_1(s, t);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord2sv_adr := GetProcAddress('glTexCoord2sv');
    private ntv_TexCoord2sv_1 := GetProcOrNil&<procedure(var v: Int16)>(TexCoord2sv_adr);
    private ntv_TexCoord2sv_2 := GetProcOrNil&<procedure(var v: Vec2s)>(TexCoord2sv_adr);
    private ntv_TexCoord2sv_3 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord2sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2sv(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord2sv_1(v[0]) else
        ntv_TexCoord2sv_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2sv(var v: Vec2s) :=
      ntv_TexCoord2sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2sv(var v: Int16) :=
      ntv_TexCoord2sv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2sv(v: IntPtr) :=
      ntv_TexCoord2sv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord3d_adr := GetProcAddress('glTexCoord3d');
    private ntv_TexCoord3d_1 := GetProcOrNil&<procedure(s: double; t: double; r: double)>(TexCoord3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3d(s: double; t: double; r: double) :=
      ntv_TexCoord3d_1(s, t, r);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord3dv_adr := GetProcAddress('glTexCoord3dv');
    private ntv_TexCoord3dv_1 := GetProcOrNil&<procedure(var v: double)>(TexCoord3dv_adr);
    private ntv_TexCoord3dv_2 := GetProcOrNil&<procedure(var v: Vec3d)>(TexCoord3dv_adr);
    private ntv_TexCoord3dv_3 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3dv(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord3dv_1(v[0]) else
        ntv_TexCoord3dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3dv(var v: Vec3d) :=
      ntv_TexCoord3dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3dv(var v: double) :=
      ntv_TexCoord3dv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3dv(v: IntPtr) :=
      ntv_TexCoord3dv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord3f_adr := GetProcAddress('glTexCoord3f');
    private ntv_TexCoord3f_1 := GetProcOrNil&<procedure(s: single; t: single; r: single)>(TexCoord3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3f(s: single; t: single; r: single) :=
      ntv_TexCoord3f_1(s, t, r);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord3fv_adr := GetProcAddress('glTexCoord3fv');
    private ntv_TexCoord3fv_1 := GetProcOrNil&<procedure(var v: single)>(TexCoord3fv_adr);
    private ntv_TexCoord3fv_2 := GetProcOrNil&<procedure(var v: Vec3f)>(TexCoord3fv_adr);
    private ntv_TexCoord3fv_3 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3fv(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord3fv_1(v[0]) else
        ntv_TexCoord3fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3fv(var v: Vec3f) :=
      ntv_TexCoord3fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3fv(var v: single) :=
      ntv_TexCoord3fv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3fv(v: IntPtr) :=
      ntv_TexCoord3fv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord3i_adr := GetProcAddress('glTexCoord3i');
    private ntv_TexCoord3i_1 := GetProcOrNil&<procedure(s: Int32; t: Int32; r: Int32)>(TexCoord3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3i(s: Int32; t: Int32; r: Int32) :=
      ntv_TexCoord3i_1(s, t, r);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord3iv_adr := GetProcAddress('glTexCoord3iv');
    private ntv_TexCoord3iv_1 := GetProcOrNil&<procedure(var v: Int32)>(TexCoord3iv_adr);
    private ntv_TexCoord3iv_2 := GetProcOrNil&<procedure(var v: Vec3i)>(TexCoord3iv_adr);
    private ntv_TexCoord3iv_3 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3iv(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord3iv_1(v[0]) else
        ntv_TexCoord3iv_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3iv(var v: Vec3i) :=
      ntv_TexCoord3iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3iv(var v: Int32) :=
      ntv_TexCoord3iv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3iv(v: IntPtr) :=
      ntv_TexCoord3iv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord3s_adr := GetProcAddress('glTexCoord3s');
    private ntv_TexCoord3s_1 := GetProcOrNil&<procedure(s: Int16; t: Int16; r: Int16)>(TexCoord3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3s(s: Int16; t: Int16; r: Int16) :=
      ntv_TexCoord3s_1(s, t, r);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord3sv_adr := GetProcAddress('glTexCoord3sv');
    private ntv_TexCoord3sv_1 := GetProcOrNil&<procedure(var v: Int16)>(TexCoord3sv_adr);
    private ntv_TexCoord3sv_2 := GetProcOrNil&<procedure(var v: Vec3s)>(TexCoord3sv_adr);
    private ntv_TexCoord3sv_3 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3sv(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord3sv_1(v[0]) else
        ntv_TexCoord3sv_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3sv(var v: Vec3s) :=
      ntv_TexCoord3sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3sv(var v: Int16) :=
      ntv_TexCoord3sv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3sv(v: IntPtr) :=
      ntv_TexCoord3sv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord4d_adr := GetProcAddress('glTexCoord4d');
    private ntv_TexCoord4d_1 := GetProcOrNil&<procedure(s: double; t: double; r: double; q: double)>(TexCoord4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4d(s: double; t: double; r: double; q: double) :=
      ntv_TexCoord4d_1(s, t, r, q);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord4dv_adr := GetProcAddress('glTexCoord4dv');
    private ntv_TexCoord4dv_1 := GetProcOrNil&<procedure(var v: double)>(TexCoord4dv_adr);
    private ntv_TexCoord4dv_2 := GetProcOrNil&<procedure(var v: Vec4d)>(TexCoord4dv_adr);
    private ntv_TexCoord4dv_3 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4dv(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord4dv_1(v[0]) else
        ntv_TexCoord4dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4dv(var v: Vec4d) :=
      ntv_TexCoord4dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4dv(var v: double) :=
      ntv_TexCoord4dv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4dv(v: IntPtr) :=
      ntv_TexCoord4dv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord4f_adr := GetProcAddress('glTexCoord4f');
    private ntv_TexCoord4f_1 := GetProcOrNil&<procedure(s: single; t: single; r: single; q: single)>(TexCoord4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4f(s: single; t: single; r: single; q: single) :=
      ntv_TexCoord4f_1(s, t, r, q);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord4fv_adr := GetProcAddress('glTexCoord4fv');
    private ntv_TexCoord4fv_1 := GetProcOrNil&<procedure(var v: single)>(TexCoord4fv_adr);
    private ntv_TexCoord4fv_2 := GetProcOrNil&<procedure(var v: Vec4f)>(TexCoord4fv_adr);
    private ntv_TexCoord4fv_3 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fv(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord4fv_1(v[0]) else
        ntv_TexCoord4fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fv(var v: Vec4f) :=
      ntv_TexCoord4fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fv(var v: single) :=
      ntv_TexCoord4fv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fv(v: IntPtr) :=
      ntv_TexCoord4fv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord4i_adr := GetProcAddress('glTexCoord4i');
    private ntv_TexCoord4i_1 := GetProcOrNil&<procedure(s: Int32; t: Int32; r: Int32; q: Int32)>(TexCoord4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4i(s: Int32; t: Int32; r: Int32; q: Int32) :=
      ntv_TexCoord4i_1(s, t, r, q);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord4iv_adr := GetProcAddress('glTexCoord4iv');
    private ntv_TexCoord4iv_1 := GetProcOrNil&<procedure(var v: Int32)>(TexCoord4iv_adr);
    private ntv_TexCoord4iv_2 := GetProcOrNil&<procedure(var v: Vec4i)>(TexCoord4iv_adr);
    private ntv_TexCoord4iv_3 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4iv(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord4iv_1(v[0]) else
        ntv_TexCoord4iv_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4iv(var v: Vec4i) :=
      ntv_TexCoord4iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4iv(var v: Int32) :=
      ntv_TexCoord4iv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4iv(v: IntPtr) :=
      ntv_TexCoord4iv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord4s_adr := GetProcAddress('glTexCoord4s');
    private ntv_TexCoord4s_1 := GetProcOrNil&<procedure(s: Int16; t: Int16; r: Int16; q: Int16)>(TexCoord4s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4s(s: Int16; t: Int16; r: Int16; q: Int16) :=
      ntv_TexCoord4s_1(s, t, r, q);
    
    // added in gl1.0, deprecated in gl3.2
    private TexCoord4sv_adr := GetProcAddress('glTexCoord4sv');
    private ntv_TexCoord4sv_1 := GetProcOrNil&<procedure(var v: Int16)>(TexCoord4sv_adr);
    private ntv_TexCoord4sv_2 := GetProcOrNil&<procedure(var v: Vec4s)>(TexCoord4sv_adr);
    private ntv_TexCoord4sv_3 := GetProcOrNil&<procedure(v: IntPtr)>(TexCoord4sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4sv(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_TexCoord4sv_1(v[0]) else
        ntv_TexCoord4sv_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4sv(var v: Vec4s) :=
      ntv_TexCoord4sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4sv(var v: Int16) :=
      ntv_TexCoord4sv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4sv(v: IntPtr) :=
      ntv_TexCoord4sv_3(v);
    
    // added in gl1.1, deprecated in gl3.2
    private TexCoordPointer_adr := GetProcAddress('glTexCoordPointer');
    private ntv_TexCoordPointer_1 := GetProcOrNil&<procedure(size: Int32; &type: glTexCoordPointerType; stride: Int32; pointer: IntPtr)>(TexCoordPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointer(size: Int32; &type: glTexCoordPointerType; stride: Int32; pointer: IntPtr) :=
      ntv_TexCoordPointer_1(size, &type, stride, pointer);
    
    // added in gl1.0, deprecated in gl3.2
    private TexEnvf_adr := GetProcAddress('glTexEnvf');
    private ntv_TexEnvf_1 := GetProcOrNil&<procedure(target: glTextureEnvTarget; pname: glTextureEnvParameter; param: single)>(TexEnvf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvf(target: glTextureEnvTarget; pname: glTextureEnvParameter; param: single) :=
      ntv_TexEnvf_1(target, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private TexEnvfv_adr := GetProcAddress('glTexEnvfv');
    private ntv_TexEnvfv_1 := GetProcOrNil&<procedure(target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: single)>(TexEnvfv_adr);
    private ntv_TexEnvfv_2 := GetProcOrNil&<procedure(target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr)>(TexEnvfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvfv(target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TexEnvfv_1(target, pname, &params[0]) else
        ntv_TexEnvfv_1(target, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvfv(target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: single) :=
      ntv_TexEnvfv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvfv(target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr) :=
      ntv_TexEnvfv_2(target, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private TexEnvi_adr := GetProcAddress('glTexEnvi');
    private ntv_TexEnvi_1 := GetProcOrNil&<procedure(target: glTextureEnvTarget; pname: glTextureEnvParameter; param: glTextureEnvMode)>(TexEnvi_adr);
    private ntv_TexEnvi_2 := GetProcOrNil&<procedure(target: glTextureEnvTarget; pname: glTextureEnvParameter; param: Int32)>(TexEnvi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvi(target: glTextureEnvTarget; pname: glTextureEnvParameter; param: glTextureEnvMode) :=
      ntv_TexEnvi_1(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvi(target: glTextureEnvTarget; pname: glTextureEnvParameter; param: Int32) :=
      ntv_TexEnvi_2(target, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private TexEnviv_adr := GetProcAddress('glTexEnviv');
    private ntv_TexEnviv_1 := GetProcOrNil&<procedure(target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: Int32)>(TexEnviv_adr);
    private ntv_TexEnviv_2 := GetProcOrNil&<procedure(target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr)>(TexEnviv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnviv(target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TexEnviv_1(target, pname, &params[0]) else
        ntv_TexEnviv_1(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnviv(target: glTextureEnvTarget; pname: glTextureEnvParameter; var &params: Int32) :=
      ntv_TexEnviv_1(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnviv(target: glTextureEnvTarget; pname: glTextureEnvParameter; &params: IntPtr) :=
      ntv_TexEnviv_2(target, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private TexGend_adr := GetProcAddress('glTexGend');
    private ntv_TexGend_1 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; param: double)>(TexGend_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGend(coord: glTextureCoordName; pname: glTextureGenParameter; param: double) :=
      ntv_TexGend_1(coord, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private TexGendv_adr := GetProcAddress('glTexGendv');
    private ntv_TexGendv_1 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; var &params: double)>(TexGendv_adr);
    private ntv_TexGendv_2 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr)>(TexGendv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGendv(coord: glTextureCoordName; pname: glTextureGenParameter; &params: array of double);
    type PDouble = ^double;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TexGendv_1(coord, pname, &params[0]) else
        ntv_TexGendv_1(coord, pname, PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGendv(coord: glTextureCoordName; pname: glTextureGenParameter; var &params: double) :=
      ntv_TexGendv_1(coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGendv(coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr) :=
      ntv_TexGendv_2(coord, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private TexGenf_adr := GetProcAddress('glTexGenf');
    private ntv_TexGenf_1 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; param: single)>(TexGenf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenf(coord: glTextureCoordName; pname: glTextureGenParameter; param: single) :=
      ntv_TexGenf_1(coord, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private TexGenfv_adr := GetProcAddress('glTexGenfv');
    private ntv_TexGenfv_1 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; var &params: single)>(TexGenfv_adr);
    private ntv_TexGenfv_2 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr)>(TexGenfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenfv(coord: glTextureCoordName; pname: glTextureGenParameter; &params: array of single);
    type PSingle = ^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TexGenfv_1(coord, pname, &params[0]) else
        ntv_TexGenfv_1(coord, pname, PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenfv(coord: glTextureCoordName; pname: glTextureGenParameter; var &params: single) :=
      ntv_TexGenfv_1(coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenfv(coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr) :=
      ntv_TexGenfv_2(coord, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private TexGeni_adr := GetProcAddress('glTexGeni');
    private ntv_TexGeni_1 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; param: glTextureGenMode)>(TexGeni_adr);
    private ntv_TexGeni_2 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; param: Int32)>(TexGeni_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGeni(coord: glTextureCoordName; pname: glTextureGenParameter; param: glTextureGenMode) :=
      ntv_TexGeni_1(coord, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGeni(coord: glTextureCoordName; pname: glTextureGenParameter; param: Int32) :=
      ntv_TexGeni_2(coord, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private TexGeniv_adr := GetProcAddress('glTexGeniv');
    private ntv_TexGeniv_1 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; var &params: Int32)>(TexGeniv_adr);
    private ntv_TexGeniv_2 := GetProcOrNil&<procedure(coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr)>(TexGeniv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGeniv(coord: glTextureCoordName; pname: glTextureGenParameter; &params: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        ntv_TexGeniv_1(coord, pname, &params[0]) else
        ntv_TexGeniv_1(coord, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGeniv(coord: glTextureCoordName; pname: glTextureGenParameter; var &params: Int32) :=
      ntv_TexGeniv_1(coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGeniv(coord: glTextureCoordName; pname: glTextureGenParameter; &params: IntPtr) :=
      ntv_TexGeniv_2(coord, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private Translated_adr := GetProcAddress('glTranslated');
    private ntv_Translated_1 := GetProcOrNil&<procedure(x: double; y: double; z: double)>(Translated_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Translated(x: double; y: double; z: double) :=
      ntv_Translated_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private Translatef_adr := GetProcAddress('glTranslatef');
    private ntv_Translatef_1 := GetProcOrNil&<procedure(x: single; y: single; z: single)>(Translatef_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Translatef(x: single; y: single; z: single) :=
      ntv_Translatef_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex2d_adr := GetProcAddress('glVertex2d');
    private ntv_Vertex2d_1 := GetProcOrNil&<procedure(x: double; y: double)>(Vertex2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2d(x: double; y: double) :=
      ntv_Vertex2d_1(x, y);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex2dv_adr := GetProcAddress('glVertex2dv');
    private ntv_Vertex2dv_1 := GetProcOrNil&<procedure(var v: double)>(Vertex2dv_adr);
    private ntv_Vertex2dv_2 := GetProcOrNil&<procedure(var v: Vec2d)>(Vertex2dv_adr);
    private ntv_Vertex2dv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Vertex2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2dv(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Vertex2dv_1(v[0]) else
        ntv_Vertex2dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2dv(var v: Vec2d) :=
      ntv_Vertex2dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2dv(var v: double) :=
      ntv_Vertex2dv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2dv(v: IntPtr) :=
      ntv_Vertex2dv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex2f_adr := GetProcAddress('glVertex2f');
    private ntv_Vertex2f_1 := GetProcOrNil&<procedure(x: single; y: single)>(Vertex2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2f(x: single; y: single) :=
      ntv_Vertex2f_1(x, y);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex2fv_adr := GetProcAddress('glVertex2fv');
    private ntv_Vertex2fv_1 := GetProcOrNil&<procedure(var v: single)>(Vertex2fv_adr);
    private ntv_Vertex2fv_2 := GetProcOrNil&<procedure(var v: Vec2f)>(Vertex2fv_adr);
    private ntv_Vertex2fv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Vertex2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2fv(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Vertex2fv_1(v[0]) else
        ntv_Vertex2fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2fv(var v: Vec2f) :=
      ntv_Vertex2fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2fv(var v: single) :=
      ntv_Vertex2fv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2fv(v: IntPtr) :=
      ntv_Vertex2fv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex2i_adr := GetProcAddress('glVertex2i');
    private ntv_Vertex2i_1 := GetProcOrNil&<procedure(x: Int32; y: Int32)>(Vertex2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2i(x: Int32; y: Int32) :=
      ntv_Vertex2i_1(x, y);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex2iv_adr := GetProcAddress('glVertex2iv');
    private ntv_Vertex2iv_1 := GetProcOrNil&<procedure(var v: Int32)>(Vertex2iv_adr);
    private ntv_Vertex2iv_2 := GetProcOrNil&<procedure(var v: Vec2i)>(Vertex2iv_adr);
    private ntv_Vertex2iv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Vertex2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2iv(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Vertex2iv_1(v[0]) else
        ntv_Vertex2iv_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2iv(var v: Vec2i) :=
      ntv_Vertex2iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2iv(var v: Int32) :=
      ntv_Vertex2iv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2iv(v: IntPtr) :=
      ntv_Vertex2iv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex2s_adr := GetProcAddress('glVertex2s');
    private ntv_Vertex2s_1 := GetProcOrNil&<procedure(x: Int16; y: Int16)>(Vertex2s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2s(x: Int16; y: Int16) :=
      ntv_Vertex2s_1(x, y);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex2sv_adr := GetProcAddress('glVertex2sv');
    private ntv_Vertex2sv_1 := GetProcOrNil&<procedure(var v: Int16)>(Vertex2sv_adr);
    private ntv_Vertex2sv_2 := GetProcOrNil&<procedure(var v: Vec2s)>(Vertex2sv_adr);
    private ntv_Vertex2sv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Vertex2sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2sv(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Vertex2sv_1(v[0]) else
        ntv_Vertex2sv_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2sv(var v: Vec2s) :=
      ntv_Vertex2sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2sv(var v: Int16) :=
      ntv_Vertex2sv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2sv(v: IntPtr) :=
      ntv_Vertex2sv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex3d_adr := GetProcAddress('glVertex3d');
    private ntv_Vertex3d_1 := GetProcOrNil&<procedure(x: double; y: double; z: double)>(Vertex3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3d(x: double; y: double; z: double) :=
      ntv_Vertex3d_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex3dv_adr := GetProcAddress('glVertex3dv');
    private ntv_Vertex3dv_1 := GetProcOrNil&<procedure(var v: double)>(Vertex3dv_adr);
    private ntv_Vertex3dv_2 := GetProcOrNil&<procedure(var v: Vec3d)>(Vertex3dv_adr);
    private ntv_Vertex3dv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Vertex3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3dv(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Vertex3dv_1(v[0]) else
        ntv_Vertex3dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3dv(var v: Vec3d) :=
      ntv_Vertex3dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3dv(var v: double) :=
      ntv_Vertex3dv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3dv(v: IntPtr) :=
      ntv_Vertex3dv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex3f_adr := GetProcAddress('glVertex3f');
    private ntv_Vertex3f_1 := GetProcOrNil&<procedure(x: single; y: single; z: single)>(Vertex3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3f(x: single; y: single; z: single) :=
      ntv_Vertex3f_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex3fv_adr := GetProcAddress('glVertex3fv');
    private ntv_Vertex3fv_1 := GetProcOrNil&<procedure(var v: single)>(Vertex3fv_adr);
    private ntv_Vertex3fv_2 := GetProcOrNil&<procedure(var v: Vec3f)>(Vertex3fv_adr);
    private ntv_Vertex3fv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Vertex3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3fv(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Vertex3fv_1(v[0]) else
        ntv_Vertex3fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3fv(var v: Vec3f) :=
      ntv_Vertex3fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3fv(var v: single) :=
      ntv_Vertex3fv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3fv(v: IntPtr) :=
      ntv_Vertex3fv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex3i_adr := GetProcAddress('glVertex3i');
    private ntv_Vertex3i_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; z: Int32)>(Vertex3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3i(x: Int32; y: Int32; z: Int32) :=
      ntv_Vertex3i_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex3iv_adr := GetProcAddress('glVertex3iv');
    private ntv_Vertex3iv_1 := GetProcOrNil&<procedure(var v: Int32)>(Vertex3iv_adr);
    private ntv_Vertex3iv_2 := GetProcOrNil&<procedure(var v: Vec3i)>(Vertex3iv_adr);
    private ntv_Vertex3iv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Vertex3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3iv(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Vertex3iv_1(v[0]) else
        ntv_Vertex3iv_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3iv(var v: Vec3i) :=
      ntv_Vertex3iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3iv(var v: Int32) :=
      ntv_Vertex3iv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3iv(v: IntPtr) :=
      ntv_Vertex3iv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex3s_adr := GetProcAddress('glVertex3s');
    private ntv_Vertex3s_1 := GetProcOrNil&<procedure(x: Int16; y: Int16; z: Int16)>(Vertex3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3s(x: Int16; y: Int16; z: Int16) :=
      ntv_Vertex3s_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex3sv_adr := GetProcAddress('glVertex3sv');
    private ntv_Vertex3sv_1 := GetProcOrNil&<procedure(var v: Int16)>(Vertex3sv_adr);
    private ntv_Vertex3sv_2 := GetProcOrNil&<procedure(var v: Vec3s)>(Vertex3sv_adr);
    private ntv_Vertex3sv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Vertex3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3sv(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Vertex3sv_1(v[0]) else
        ntv_Vertex3sv_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3sv(var v: Vec3s) :=
      ntv_Vertex3sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3sv(var v: Int16) :=
      ntv_Vertex3sv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3sv(v: IntPtr) :=
      ntv_Vertex3sv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex4d_adr := GetProcAddress('glVertex4d');
    private ntv_Vertex4d_1 := GetProcOrNil&<procedure(x: double; y: double; z: double; w: double)>(Vertex4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4d(x: double; y: double; z: double; w: double) :=
      ntv_Vertex4d_1(x, y, z, w);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex4dv_adr := GetProcAddress('glVertex4dv');
    private ntv_Vertex4dv_1 := GetProcOrNil&<procedure(var v: double)>(Vertex4dv_adr);
    private ntv_Vertex4dv_2 := GetProcOrNil&<procedure(var v: Vec4d)>(Vertex4dv_adr);
    private ntv_Vertex4dv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Vertex4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4dv(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Vertex4dv_1(v[0]) else
        ntv_Vertex4dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4dv(var v: Vec4d) :=
      ntv_Vertex4dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4dv(var v: double) :=
      ntv_Vertex4dv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4dv(v: IntPtr) :=
      ntv_Vertex4dv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex4f_adr := GetProcAddress('glVertex4f');
    private ntv_Vertex4f_1 := GetProcOrNil&<procedure(x: single; y: single; z: single; w: single)>(Vertex4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4f(x: single; y: single; z: single; w: single) :=
      ntv_Vertex4f_1(x, y, z, w);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex4fv_adr := GetProcAddress('glVertex4fv');
    private ntv_Vertex4fv_1 := GetProcOrNil&<procedure(var v: single)>(Vertex4fv_adr);
    private ntv_Vertex4fv_2 := GetProcOrNil&<procedure(var v: Vec4f)>(Vertex4fv_adr);
    private ntv_Vertex4fv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Vertex4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4fv(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Vertex4fv_1(v[0]) else
        ntv_Vertex4fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4fv(var v: Vec4f) :=
      ntv_Vertex4fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4fv(var v: single) :=
      ntv_Vertex4fv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4fv(v: IntPtr) :=
      ntv_Vertex4fv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex4i_adr := GetProcAddress('glVertex4i');
    private ntv_Vertex4i_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; z: Int32; w: Int32)>(Vertex4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4i(x: Int32; y: Int32; z: Int32; w: Int32) :=
      ntv_Vertex4i_1(x, y, z, w);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex4iv_adr := GetProcAddress('glVertex4iv');
    private ntv_Vertex4iv_1 := GetProcOrNil&<procedure(var v: Int32)>(Vertex4iv_adr);
    private ntv_Vertex4iv_2 := GetProcOrNil&<procedure(var v: Vec4i)>(Vertex4iv_adr);
    private ntv_Vertex4iv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Vertex4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4iv(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Vertex4iv_1(v[0]) else
        ntv_Vertex4iv_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4iv(var v: Vec4i) :=
      ntv_Vertex4iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4iv(var v: Int32) :=
      ntv_Vertex4iv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4iv(v: IntPtr) :=
      ntv_Vertex4iv_3(v);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex4s_adr := GetProcAddress('glVertex4s');
    private ntv_Vertex4s_1 := GetProcOrNil&<procedure(x: Int16; y: Int16; z: Int16; w: Int16)>(Vertex4s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4s(x: Int16; y: Int16; z: Int16; w: Int16) :=
      ntv_Vertex4s_1(x, y, z, w);
    
    // added in gl1.0, deprecated in gl3.2
    private Vertex4sv_adr := GetProcAddress('glVertex4sv');
    private ntv_Vertex4sv_1 := GetProcOrNil&<procedure(var v: Int16)>(Vertex4sv_adr);
    private ntv_Vertex4sv_2 := GetProcOrNil&<procedure(var v: Vec4s)>(Vertex4sv_adr);
    private ntv_Vertex4sv_3 := GetProcOrNil&<procedure(v: IntPtr)>(Vertex4sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4sv(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_Vertex4sv_1(v[0]) else
        ntv_Vertex4sv_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4sv(var v: Vec4s) :=
      ntv_Vertex4sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4sv(var v: Int16) :=
      ntv_Vertex4sv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4sv(v: IntPtr) :=
      ntv_Vertex4sv_3(v);
    
    // added in gl1.1, deprecated in gl3.2
    private VertexPointer_adr := GetProcAddress('glVertexPointer');
    private ntv_VertexPointer_1 := GetProcOrNil&<procedure(size: Int32; &type: glVertexPointerType; stride: Int32; pointer: IntPtr)>(VertexPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointer(size: Int32; &type: glVertexPointerType; stride: Int32; pointer: IntPtr) :=
      ntv_VertexPointer_1(size, &type, stride, pointer);
    
    // added in gl1.4, deprecated in gl3.2
    private WindowPos2d_adr := GetProcAddress('glWindowPos2d');
    private ntv_WindowPos2d_1 := GetProcOrNil&<procedure(x: double; y: double)>(WindowPos2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2d(x: double; y: double) :=
      ntv_WindowPos2d_1(x, y);
    
    // added in gl1.4, deprecated in gl3.2
    private WindowPos2dv_adr := GetProcAddress('glWindowPos2dv');
    private ntv_WindowPos2dv_1 := GetProcOrNil&<procedure(var v: double)>(WindowPos2dv_adr);
    private ntv_WindowPos2dv_2 := GetProcOrNil&<procedure(var v: Vec2d)>(WindowPos2dv_adr);
    private ntv_WindowPos2dv_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dv(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos2dv_1(v[0]) else
        ntv_WindowPos2dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dv(var v: Vec2d) :=
      ntv_WindowPos2dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dv(var v: double) :=
      ntv_WindowPos2dv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dv(v: IntPtr) :=
      ntv_WindowPos2dv_3(v);
    
    // added in gl1.4, deprecated in gl3.2
    private WindowPos2f_adr := GetProcAddress('glWindowPos2f');
    private ntv_WindowPos2f_1 := GetProcOrNil&<procedure(x: single; y: single)>(WindowPos2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2f(x: single; y: single) :=
      ntv_WindowPos2f_1(x, y);
    
    // added in gl1.4, deprecated in gl3.2
    private WindowPos2fv_adr := GetProcAddress('glWindowPos2fv');
    private ntv_WindowPos2fv_1 := GetProcOrNil&<procedure(var v: single)>(WindowPos2fv_adr);
    private ntv_WindowPos2fv_2 := GetProcOrNil&<procedure(var v: Vec2f)>(WindowPos2fv_adr);
    private ntv_WindowPos2fv_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fv(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos2fv_1(v[0]) else
        ntv_WindowPos2fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fv(var v: Vec2f) :=
      ntv_WindowPos2fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fv(var v: single) :=
      ntv_WindowPos2fv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fv(v: IntPtr) :=
      ntv_WindowPos2fv_3(v);
    
    // added in gl1.4, deprecated in gl3.2
    private WindowPos2i_adr := GetProcAddress('glWindowPos2i');
    private ntv_WindowPos2i_1 := GetProcOrNil&<procedure(x: Int32; y: Int32)>(WindowPos2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2i(x: Int32; y: Int32) :=
      ntv_WindowPos2i_1(x, y);
    
    // added in gl1.4, deprecated in gl3.2
    private WindowPos2iv_adr := GetProcAddress('glWindowPos2iv');
    private ntv_WindowPos2iv_1 := GetProcOrNil&<procedure(var v: Int32)>(WindowPos2iv_adr);
    private ntv_WindowPos2iv_2 := GetProcOrNil&<procedure(var v: Vec2i)>(WindowPos2iv_adr);
    private ntv_WindowPos2iv_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iv(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos2iv_1(v[0]) else
        ntv_WindowPos2iv_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iv(var v: Vec2i) :=
      ntv_WindowPos2iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iv(var v: Int32) :=
      ntv_WindowPos2iv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iv(v: IntPtr) :=
      ntv_WindowPos2iv_3(v);
    
    // added in gl1.4, deprecated in gl3.2
    private WindowPos2s_adr := GetProcAddress('glWindowPos2s');
    private ntv_WindowPos2s_1 := GetProcOrNil&<procedure(x: Int16; y: Int16)>(WindowPos2s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2s(x: Int16; y: Int16) :=
      ntv_WindowPos2s_1(x, y);
    
    // added in gl1.4, deprecated in gl3.2
    private WindowPos2sv_adr := GetProcAddress('glWindowPos2sv');
    private ntv_WindowPos2sv_1 := GetProcOrNil&<procedure(var v: Int16)>(WindowPos2sv_adr);
    private ntv_WindowPos2sv_2 := GetProcOrNil&<procedure(var v: Vec2s)>(WindowPos2sv_adr);
    private ntv_WindowPos2sv_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos2sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sv(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos2sv_1(v[0]) else
        ntv_WindowPos2sv_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sv(var v: Vec2s) :=
      ntv_WindowPos2sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sv(var v: Int16) :=
      ntv_WindowPos2sv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sv(v: IntPtr) :=
      ntv_WindowPos2sv_3(v);
    
    // added in gl1.4, deprecated in gl3.2
    private WindowPos3d_adr := GetProcAddress('glWindowPos3d');
    private ntv_WindowPos3d_1 := GetProcOrNil&<procedure(x: double; y: double; z: double)>(WindowPos3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3d(x: double; y: double; z: double) :=
      ntv_WindowPos3d_1(x, y, z);
    
    // added in gl1.4, deprecated in gl3.2
    private WindowPos3dv_adr := GetProcAddress('glWindowPos3dv');
    private ntv_WindowPos3dv_1 := GetProcOrNil&<procedure(var v: double)>(WindowPos3dv_adr);
    private ntv_WindowPos3dv_2 := GetProcOrNil&<procedure(var v: Vec3d)>(WindowPos3dv_adr);
    private ntv_WindowPos3dv_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dv(v: array of double);
    type PDouble = ^double;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos3dv_1(v[0]) else
        ntv_WindowPos3dv_1(PDouble(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dv(var v: Vec3d) :=
      ntv_WindowPos3dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dv(var v: double) :=
      ntv_WindowPos3dv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dv(v: IntPtr) :=
      ntv_WindowPos3dv_3(v);
    
    // added in gl1.4, deprecated in gl3.2
    private WindowPos3f_adr := GetProcAddress('glWindowPos3f');
    private ntv_WindowPos3f_1 := GetProcOrNil&<procedure(x: single; y: single; z: single)>(WindowPos3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3f(x: single; y: single; z: single) :=
      ntv_WindowPos3f_1(x, y, z);
    
    // added in gl1.4, deprecated in gl3.2
    private WindowPos3fv_adr := GetProcAddress('glWindowPos3fv');
    private ntv_WindowPos3fv_1 := GetProcOrNil&<procedure(var v: single)>(WindowPos3fv_adr);
    private ntv_WindowPos3fv_2 := GetProcOrNil&<procedure(var v: Vec3f)>(WindowPos3fv_adr);
    private ntv_WindowPos3fv_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fv(v: array of single);
    type PSingle = ^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos3fv_1(v[0]) else
        ntv_WindowPos3fv_1(PSingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fv(var v: Vec3f) :=
      ntv_WindowPos3fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fv(var v: single) :=
      ntv_WindowPos3fv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fv(v: IntPtr) :=
      ntv_WindowPos3fv_3(v);
    
    // added in gl1.4, deprecated in gl3.2
    private WindowPos3i_adr := GetProcAddress('glWindowPos3i');
    private ntv_WindowPos3i_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; z: Int32)>(WindowPos3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3i(x: Int32; y: Int32; z: Int32) :=
      ntv_WindowPos3i_1(x, y, z);
    
    // added in gl1.4, deprecated in gl3.2
    private WindowPos3iv_adr := GetProcAddress('glWindowPos3iv');
    private ntv_WindowPos3iv_1 := GetProcOrNil&<procedure(var v: Int32)>(WindowPos3iv_adr);
    private ntv_WindowPos3iv_2 := GetProcOrNil&<procedure(var v: Vec3i)>(WindowPos3iv_adr);
    private ntv_WindowPos3iv_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iv(v: array of Int32);
    type PInt32 = ^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos3iv_1(v[0]) else
        ntv_WindowPos3iv_1(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iv(var v: Vec3i) :=
      ntv_WindowPos3iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iv(var v: Int32) :=
      ntv_WindowPos3iv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iv(v: IntPtr) :=
      ntv_WindowPos3iv_3(v);
    
    // added in gl1.4, deprecated in gl3.2
    private WindowPos3s_adr := GetProcAddress('glWindowPos3s');
    private ntv_WindowPos3s_1 := GetProcOrNil&<procedure(x: Int16; y: Int16; z: Int16)>(WindowPos3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3s(x: Int16; y: Int16; z: Int16) :=
      ntv_WindowPos3s_1(x, y, z);
    
    // added in gl1.4, deprecated in gl3.2
    private WindowPos3sv_adr := GetProcAddress('glWindowPos3sv');
    private ntv_WindowPos3sv_1 := GetProcOrNil&<procedure(var v: Int16)>(WindowPos3sv_adr);
    private ntv_WindowPos3sv_2 := GetProcOrNil&<procedure(var v: Vec3s)>(WindowPos3sv_adr);
    private ntv_WindowPos3sv_3 := GetProcOrNil&<procedure(v: IntPtr)>(WindowPos3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sv(v: array of Int16);
    type PInt16 = ^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        ntv_WindowPos3sv_1(v[0]) else
        ntv_WindowPos3sv_1(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sv(var v: Vec3s) :=
      ntv_WindowPos3sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sv(var v: Int16) :=
      ntv_WindowPos3sv_1(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sv(v: IntPtr) :=
      ntv_WindowPos3sv_3(v);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  gdi = static class
    
    // added in gdi1.0
    private static function ntv_ChoosePixelFormat_1(hDc: gdi_device_context; var pPfd: gdi_pixel_format_descriptor): Int32;
    external 'gdi32.dll' name 'ChoosePixelFormat';
    private static function ntv_ChoosePixelFormat_2(hDc: gdi_device_context; pPfd: IntPtr): Int32;
    external 'gdi32.dll' name 'ChoosePixelFormat';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChoosePixelFormat(hDc: gdi_device_context; pPfd: array of gdi_pixel_format_descriptor): Int32;
    type PGdi_pixel_format_descriptor = ^gdi_pixel_format_descriptor;
    begin
      Result := if (pPfd<>nil) and (pPfd.Length<>0) then
        ntv_ChoosePixelFormat_1(hDc, pPfd[0]) else
        ntv_ChoosePixelFormat_1(hDc, PGdi_pixel_format_descriptor(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChoosePixelFormat(hDc: gdi_device_context; var pPfd: gdi_pixel_format_descriptor): Int32 :=
      ntv_ChoosePixelFormat_1(hDc, pPfd);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChoosePixelFormat(hDc: gdi_device_context; pPfd: IntPtr): Int32 :=
      ntv_ChoosePixelFormat_2(hDc, pPfd);
    
    // added in gdi1.0
    private static function ntv_DescribePixelFormat_1(hdc: gdi_device_context; ipfd: Int32; cjpfd: UInt32; var ppfd: gdi_pixel_format_descriptor): Int32;
    external 'gdi32.dll' name 'DescribePixelFormat';
    private static function ntv_DescribePixelFormat_2(hdc: gdi_device_context; ipfd: Int32; cjpfd: UInt32; ppfd: IntPtr): Int32;
    external 'gdi32.dll' name 'DescribePixelFormat';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function DescribePixelFormat(hdc: gdi_device_context; ipfd: Int32; cjpfd: UInt32; ppfd: array of gdi_pixel_format_descriptor): Int32;
    type PGdi_pixel_format_descriptor = ^gdi_pixel_format_descriptor;
    begin
      Result := if (ppfd<>nil) and (ppfd.Length<>0) then
        ntv_DescribePixelFormat_1(hdc, ipfd, cjpfd, ppfd[0]) else
        ntv_DescribePixelFormat_1(hdc, ipfd, cjpfd, PGdi_pixel_format_descriptor(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function DescribePixelFormat(hdc: gdi_device_context; ipfd: Int32; cjpfd: UInt32; var ppfd: gdi_pixel_format_descriptor): Int32 :=
      ntv_DescribePixelFormat_1(hdc, ipfd, cjpfd, ppfd);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function DescribePixelFormat(hdc: gdi_device_context; ipfd: Int32; cjpfd: UInt32; ppfd: IntPtr): Int32 :=
      ntv_DescribePixelFormat_2(hdc, ipfd, cjpfd, ppfd);
    
    // added in gdi1.0
    private static function ntv_GetEnhMetaFilePixelFormat_1(hemf: gdi_enhanced_metafile_handle; cbBuffer: UInt32; var ppfd: gdi_pixel_format_descriptor): UInt32;
    external 'gdi32.dll' name 'GetEnhMetaFilePixelFormat';
    private static function ntv_GetEnhMetaFilePixelFormat_2(hemf: gdi_enhanced_metafile_handle; cbBuffer: UInt32; ppfd: IntPtr): UInt32;
    external 'gdi32.dll' name 'GetEnhMetaFilePixelFormat';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEnhMetaFilePixelFormat(hemf: gdi_enhanced_metafile_handle; cbBuffer: UInt32; var ppfd: gdi_pixel_format_descriptor): UInt32 :=
      ntv_GetEnhMetaFilePixelFormat_1(hemf, cbBuffer, ppfd);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEnhMetaFilePixelFormat(hemf: gdi_enhanced_metafile_handle; cbBuffer: UInt32; ppfd: IntPtr): UInt32 :=
      ntv_GetEnhMetaFilePixelFormat_2(hemf, cbBuffer, ppfd);
    
    // added in gdi1.0
    private static function ntv_GetPixelFormat_1(hdc: gdi_device_context): Int32;
    external 'gdi32.dll' name 'GetPixelFormat';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPixelFormat(hdc: gdi_device_context): Int32 :=
      ntv_GetPixelFormat_1(hdc);
    
    // added in gdi1.0
    private static function ntv_SetPixelFormat_1(hdc: gdi_device_context; ipfd: Int32; var ppfd: gdi_pixel_format_descriptor): glBool32;
    external 'gdi32.dll' name 'SetPixelFormat';
    private static function ntv_SetPixelFormat_2(hdc: gdi_device_context; ipfd: Int32; ppfd: IntPtr): glBool32;
    external 'gdi32.dll' name 'SetPixelFormat';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetPixelFormat(hdc: gdi_device_context; ipfd: Int32; ppfd: array of gdi_pixel_format_descriptor): glBool32;
    type PGdi_pixel_format_descriptor = ^gdi_pixel_format_descriptor;
    begin
      Result := if (ppfd<>nil) and (ppfd.Length<>0) then
        ntv_SetPixelFormat_1(hdc, ipfd, ppfd[0]) else
        ntv_SetPixelFormat_1(hdc, ipfd, PGdi_pixel_format_descriptor(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetPixelFormat(hdc: gdi_device_context; ipfd: Int32; var ppfd: gdi_pixel_format_descriptor): glBool32 :=
      ntv_SetPixelFormat_1(hdc, ipfd, ppfd);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetPixelFormat(hdc: gdi_device_context; ipfd: Int32; ppfd: IntPtr): glBool32 :=
      ntv_SetPixelFormat_2(hdc, ipfd, ppfd);
    
    // added in gdi1.0
    private static function ntv_SwapBuffers_1(hdc: gdi_device_context): glBool32;
    external 'gdi32.dll' name 'SwapBuffers';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SwapBuffers(hdc: gdi_device_context): glBool32 :=
      ntv_SwapBuffers_1(hdc);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  glx = static class
    
    // added in glx1.3
    private static function ntv_ChooseFBConfig_1(dpy: x_display_ptr; screen: Int32; var attrib_list: Int32; var nelements: Int32): ^glx_frame_buffer_config;
    external 'libGL.so.1' name 'glXChooseFBConfig';
    private static function ntv_ChooseFBConfig_2(dpy: x_display_ptr; screen: Int32; var attrib_list: Int32; nelements: IntPtr): ^glx_frame_buffer_config;
    external 'libGL.so.1' name 'glXChooseFBConfig';
    private static function ntv_ChooseFBConfig_3(dpy: x_display_ptr; screen: Int32; attrib_list: IntPtr; var nelements: Int32): ^glx_frame_buffer_config;
    external 'libGL.so.1' name 'glXChooseFBConfig';
    private static function ntv_ChooseFBConfig_4(dpy: x_display_ptr; screen: Int32; attrib_list: IntPtr; nelements: IntPtr): ^glx_frame_buffer_config;
    external 'libGL.so.1' name 'glXChooseFBConfig';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChooseFBConfig(dpy: x_display_ptr; screen: Int32; attrib_list: array of Int32; nelements: array of Int32): ^glx_frame_buffer_config;
    type PInt32 = ^Int32;
    begin
      Result := if (nelements<>nil) and (nelements.Length<>0) then
        if (attrib_list<>nil) and (attrib_list.Length<>0) then
          ntv_ChooseFBConfig_1(dpy, screen, attrib_list[0], nelements[0]) else
          ntv_ChooseFBConfig_1(dpy, screen, PInt32(nil)^, nelements[0]) else
        if (attrib_list<>nil) and (attrib_list.Length<>0) then
          ntv_ChooseFBConfig_1(dpy, screen, attrib_list[0], PInt32(nil)^) else
          ntv_ChooseFBConfig_1(dpy, screen, PInt32(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChooseFBConfig(dpy: x_display_ptr; screen: Int32; var attrib_list: Int32; var nelements: Int32): ^glx_frame_buffer_config :=
      ntv_ChooseFBConfig_1(dpy, screen, attrib_list, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChooseFBConfig(dpy: x_display_ptr; screen: Int32; var attrib_list: Int32; nelements: IntPtr): ^glx_frame_buffer_config :=
      ntv_ChooseFBConfig_2(dpy, screen, attrib_list, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChooseFBConfig(dpy: x_display_ptr; screen: Int32; attrib_list: IntPtr; var nelements: Int32): ^glx_frame_buffer_config :=
      ntv_ChooseFBConfig_3(dpy, screen, attrib_list, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChooseFBConfig(dpy: x_display_ptr; screen: Int32; attrib_list: IntPtr; nelements: IntPtr): ^glx_frame_buffer_config :=
      ntv_ChooseFBConfig_4(dpy, screen, attrib_list, nelements);
    
    // added in glx1.0
    private static function ntv_ChooseVisual_1(dpy: x_display_ptr; screen: Int32; var attribList: Int32): x_visual_info_ptr;
    external 'libGL.so.1' name 'glXChooseVisual';
    private static function ntv_ChooseVisual_2(dpy: x_display_ptr; screen: Int32; attribList: IntPtr): x_visual_info_ptr;
    external 'libGL.so.1' name 'glXChooseVisual';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChooseVisual(dpy: x_display_ptr; screen: Int32; attribList: array of Int32): x_visual_info_ptr;
    type PInt32 = ^Int32;
    begin
      Result := if (attribList<>nil) and (attribList.Length<>0) then
        ntv_ChooseVisual_1(dpy, screen, attribList[0]) else
        ntv_ChooseVisual_1(dpy, screen, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChooseVisual(dpy: x_display_ptr; screen: Int32; var attribList: Int32): x_visual_info_ptr :=
      ntv_ChooseVisual_1(dpy, screen, attribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChooseVisual(dpy: x_display_ptr; screen: Int32; attribList: IntPtr): x_visual_info_ptr :=
      ntv_ChooseVisual_2(dpy, screen, attribList);
    
    // added in glx1.0
    private static procedure ntv_CopyContext_1(dpy: x_display_ptr; src: glx_context; dst: glx_context; mask: UInt32);
    external 'libGL.so.1' name 'glXCopyContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure CopyContext(dpy: x_display_ptr; src: glx_context; dst: glx_context; mask: UInt32) :=
      ntv_CopyContext_1(dpy, src, dst, mask);
    
    // added in glx1.0
    private static function ntv_CreateContext_1(dpy: x_display_ptr; vis: x_visual_info_ptr; shareList: glx_context; direct: glBool8): glx_context;
    external 'libGL.so.1' name 'glXCreateContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContext(dpy: x_display_ptr; vis: x_visual_info_ptr; shareList: glx_context; direct: glBool8): glx_context :=
      ntv_CreateContext_1(dpy, vis, shareList, direct);
    
    // added in glx1.0
    private static function ntv_CreateGLXPixmap_1(dpy: x_display_ptr; visual: x_visual_info_ptr; pixmap: x_pixel_map): glx_pixel_map;
    external 'libGL.so.1' name 'glXCreateGLXPixmap';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateGLXPixmap(dpy: x_display_ptr; visual: x_visual_info_ptr; pixmap: x_pixel_map): glx_pixel_map :=
      ntv_CreateGLXPixmap_1(dpy, visual, pixmap);
    
    // added in glx1.3
    private static function ntv_CreateNewContext_1(dpy: x_display_ptr; config: glx_frame_buffer_config; render_type: Int32; share_list: glx_context; direct: glBool8): glx_context;
    external 'libGL.so.1' name 'glXCreateNewContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateNewContext(dpy: x_display_ptr; config: glx_frame_buffer_config; render_type: Int32; share_list: glx_context; direct: glBool8): glx_context :=
      ntv_CreateNewContext_1(dpy, config, render_type, share_list, direct);
    
    // added in glx1.3
    private static function ntv_CreatePbuffer_1(dpy: x_display_ptr; config: glx_frame_buffer_config; var attrib_list: Int32): glx_pixel_buffer;
    external 'libGL.so.1' name 'glXCreatePbuffer';
    private static function ntv_CreatePbuffer_2(dpy: x_display_ptr; config: glx_frame_buffer_config; attrib_list: IntPtr): glx_pixel_buffer;
    external 'libGL.so.1' name 'glXCreatePbuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreatePbuffer(dpy: x_display_ptr; config: glx_frame_buffer_config; attrib_list: array of Int32): glx_pixel_buffer;
    type PInt32 = ^Int32;
    begin
      Result := if (attrib_list<>nil) and (attrib_list.Length<>0) then
        ntv_CreatePbuffer_1(dpy, config, attrib_list[0]) else
        ntv_CreatePbuffer_1(dpy, config, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreatePbuffer(dpy: x_display_ptr; config: glx_frame_buffer_config; var attrib_list: Int32): glx_pixel_buffer :=
      ntv_CreatePbuffer_1(dpy, config, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreatePbuffer(dpy: x_display_ptr; config: glx_frame_buffer_config; attrib_list: IntPtr): glx_pixel_buffer :=
      ntv_CreatePbuffer_2(dpy, config, attrib_list);
    
    // added in glx1.3
    private static function ntv_CreatePixmap_1(dpy: x_display_ptr; config: glx_frame_buffer_config; pixmap: x_pixel_map; var attrib_list: Int32): glx_pixel_map;
    external 'libGL.so.1' name 'glXCreatePixmap';
    private static function ntv_CreatePixmap_2(dpy: x_display_ptr; config: glx_frame_buffer_config; pixmap: x_pixel_map; attrib_list: IntPtr): glx_pixel_map;
    external 'libGL.so.1' name 'glXCreatePixmap';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreatePixmap(dpy: x_display_ptr; config: glx_frame_buffer_config; pixmap: x_pixel_map; attrib_list: array of Int32): glx_pixel_map;
    type PInt32 = ^Int32;
    begin
      Result := if (attrib_list<>nil) and (attrib_list.Length<>0) then
        ntv_CreatePixmap_1(dpy, config, pixmap, attrib_list[0]) else
        ntv_CreatePixmap_1(dpy, config, pixmap, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreatePixmap(dpy: x_display_ptr; config: glx_frame_buffer_config; pixmap: x_pixel_map; var attrib_list: Int32): glx_pixel_map :=
      ntv_CreatePixmap_1(dpy, config, pixmap, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreatePixmap(dpy: x_display_ptr; config: glx_frame_buffer_config; pixmap: x_pixel_map; attrib_list: IntPtr): glx_pixel_map :=
      ntv_CreatePixmap_2(dpy, config, pixmap, attrib_list);
    
    // added in glx1.3
    private static function ntv_CreateWindow_1(dpy: x_display_ptr; config: glx_frame_buffer_config; win: x_window; var attrib_list: Int32): glx_window;
    external 'libGL.so.1' name 'glXCreateWindow';
    private static function ntv_CreateWindow_2(dpy: x_display_ptr; config: glx_frame_buffer_config; win: x_window; attrib_list: IntPtr): glx_window;
    external 'libGL.so.1' name 'glXCreateWindow';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateWindow(dpy: x_display_ptr; config: glx_frame_buffer_config; win: x_window; attrib_list: array of Int32): glx_window;
    type PInt32 = ^Int32;
    begin
      Result := if (attrib_list<>nil) and (attrib_list.Length<>0) then
        ntv_CreateWindow_1(dpy, config, win, attrib_list[0]) else
        ntv_CreateWindow_1(dpy, config, win, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateWindow(dpy: x_display_ptr; config: glx_frame_buffer_config; win: x_window; var attrib_list: Int32): glx_window :=
      ntv_CreateWindow_1(dpy, config, win, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateWindow(dpy: x_display_ptr; config: glx_frame_buffer_config; win: x_window; attrib_list: IntPtr): glx_window :=
      ntv_CreateWindow_2(dpy, config, win, attrib_list);
    
    // added in glx1.0
    private static procedure ntv_DestroyContext_1(dpy: x_display_ptr; ctx: glx_context);
    external 'libGL.so.1' name 'glXDestroyContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure DestroyContext(dpy: x_display_ptr; ctx: glx_context) :=
      ntv_DestroyContext_1(dpy, ctx);
    
    // added in glx1.0
    private static procedure ntv_DestroyGLXPixmap_1(dpy: x_display_ptr; pixmap: glx_pixel_map);
    external 'libGL.so.1' name 'glXDestroyGLXPixmap';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure DestroyGLXPixmap(dpy: x_display_ptr; pixmap: glx_pixel_map) :=
      ntv_DestroyGLXPixmap_1(dpy, pixmap);
    
    // added in glx1.3
    private static procedure ntv_DestroyPbuffer_1(dpy: x_display_ptr; pbuf: glx_pixel_buffer);
    external 'libGL.so.1' name 'glXDestroyPbuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure DestroyPbuffer(dpy: x_display_ptr; pbuf: glx_pixel_buffer) :=
      ntv_DestroyPbuffer_1(dpy, pbuf);
    
    // added in glx1.3
    private static procedure ntv_DestroyPixmap_1(dpy: x_display_ptr; pixmap: glx_pixel_map);
    external 'libGL.so.1' name 'glXDestroyPixmap';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure DestroyPixmap(dpy: x_display_ptr; pixmap: glx_pixel_map) :=
      ntv_DestroyPixmap_1(dpy, pixmap);
    
    // added in glx1.3
    private static procedure ntv_DestroyWindow_1(dpy: x_display_ptr; win: glx_window);
    external 'libGL.so.1' name 'glXDestroyWindow';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure DestroyWindow(dpy: x_display_ptr; win: glx_window) :=
      ntv_DestroyWindow_1(dpy, win);
    
    // added in glx1.1
    private static function ntv_GetClientString_1(dpy: x_display_ptr; name: Int32): IntPtr;
    external 'libGL.so.1' name 'glXGetClientString';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetClientString(dpy: x_display_ptr; name: Int32): string :=
      Marshal.PtrToStringAnsi(ntv_GetClientString_1(dpy, name));
    
    // added in glx1.0
    private static function ntv_GetConfig_1(dpy: x_display_ptr; visual: x_visual_info_ptr; attrib: Int32; var value: Int32): Int32;
    external 'libGL.so.1' name 'glXGetConfig';
    private static function ntv_GetConfig_2(dpy: x_display_ptr; visual: x_visual_info_ptr; attrib: Int32; value: IntPtr): Int32;
    external 'libGL.so.1' name 'glXGetConfig';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetConfig(dpy: x_display_ptr; visual: x_visual_info_ptr; attrib: Int32; var value: Int32): Int32 :=
      ntv_GetConfig_1(dpy, visual, attrib, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetConfig(dpy: x_display_ptr; visual: x_visual_info_ptr; attrib: Int32; value: IntPtr): Int32 :=
      ntv_GetConfig_2(dpy, visual, attrib, value);
    
    // added in glx1.0
    private static function ntv_GetCurrentContext_1: glx_context;
    external 'libGL.so.1' name 'glXGetCurrentContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCurrentContext: glx_context :=
      ntv_GetCurrentContext_1;
    
    // added in glx1.2
    private static function ntv_GetCurrentDisplay_1: x_display_ptr;
    external 'libGL.so.1' name 'glXGetCurrentDisplay';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCurrentDisplay: x_display_ptr :=
      ntv_GetCurrentDisplay_1;
    
    // added in glx1.0
    private static function ntv_GetCurrentDrawable_1: glx_drawable;
    external 'libGL.so.1' name 'glXGetCurrentDrawable';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCurrentDrawable: glx_drawable :=
      ntv_GetCurrentDrawable_1;
    
    // added in glx1.3
    private static function ntv_GetCurrentReadDrawable_1: glx_drawable;
    external 'libGL.so.1' name 'glXGetCurrentReadDrawable';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCurrentReadDrawable: glx_drawable :=
      ntv_GetCurrentReadDrawable_1;
    
    // added in glx1.3
    private static function ntv_GetFBConfigAttrib_1(dpy: x_display_ptr; config: glx_frame_buffer_config; attribute: Int32; var value: Int32): Int32;
    external 'libGL.so.1' name 'glXGetFBConfigAttrib';
    private static function ntv_GetFBConfigAttrib_2(dpy: x_display_ptr; config: glx_frame_buffer_config; attribute: Int32; value: IntPtr): Int32;
    external 'libGL.so.1' name 'glXGetFBConfigAttrib';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetFBConfigAttrib(dpy: x_display_ptr; config: glx_frame_buffer_config; attribute: Int32; var value: Int32): Int32 :=
      ntv_GetFBConfigAttrib_1(dpy, config, attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetFBConfigAttrib(dpy: x_display_ptr; config: glx_frame_buffer_config; attribute: Int32; value: IntPtr): Int32 :=
      ntv_GetFBConfigAttrib_2(dpy, config, attribute, value);
    
    // added in glx1.3
    private static function ntv_GetFBConfigs_1(dpy: x_display_ptr; screen: Int32; var nelements: Int32): ^glx_frame_buffer_config;
    external 'libGL.so.1' name 'glXGetFBConfigs';
    private static function ntv_GetFBConfigs_2(dpy: x_display_ptr; screen: Int32; nelements: IntPtr): ^glx_frame_buffer_config;
    external 'libGL.so.1' name 'glXGetFBConfigs';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetFBConfigs(dpy: x_display_ptr; screen: Int32; var nelements: Int32): ^glx_frame_buffer_config :=
      ntv_GetFBConfigs_1(dpy, screen, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetFBConfigs(dpy: x_display_ptr; screen: Int32; nelements: IntPtr): ^glx_frame_buffer_config :=
      ntv_GetFBConfigs_2(dpy, screen, nelements);
    
    // added in glx1.4
    private static function ntv_GetProcAddress_1(procName: IntPtr): IntPtr;
    external 'libGL.so.1' name 'glXGetProcAddress';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProcAddress(procName: string): IntPtr;
    begin
      var procName_str_ptr := Marshal.StringToHGlobalAnsi(procName);
      try
        Result := ntv_GetProcAddress_1(procName_str_ptr);
      finally
        Marshal.FreeHGlobal(procName_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProcAddress(procName: IntPtr): IntPtr :=
      ntv_GetProcAddress_1(procName);
    
    // added in glx1.3
    private static procedure ntv_GetSelectedEvent_1(dpy: x_display_ptr; draw: glx_drawable; var event_mask: UInt32);
    external 'libGL.so.1' name 'glXGetSelectedEvent';
    private static procedure ntv_GetSelectedEvent_2(dpy: x_display_ptr; draw: glx_drawable; event_mask: IntPtr);
    external 'libGL.so.1' name 'glXGetSelectedEvent';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure GetSelectedEvent(dpy: x_display_ptr; draw: glx_drawable; var event_mask: UInt32) :=
      ntv_GetSelectedEvent_1(dpy, draw, event_mask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure GetSelectedEvent(dpy: x_display_ptr; draw: glx_drawable; event_mask: IntPtr) :=
      ntv_GetSelectedEvent_2(dpy, draw, event_mask);
    
    // added in glx1.3
    private static function ntv_GetVisualFromFBConfig_1(dpy: x_display_ptr; config: glx_frame_buffer_config): x_visual_info_ptr;
    external 'libGL.so.1' name 'glXGetVisualFromFBConfig';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetVisualFromFBConfig(dpy: x_display_ptr; config: glx_frame_buffer_config): x_visual_info_ptr :=
      ntv_GetVisualFromFBConfig_1(dpy, config);
    
    // added in glx1.0
    private static function ntv_IsDirect_1(dpy: x_display_ptr; ctx: glx_context): glBool8;
    external 'libGL.so.1' name 'glXIsDirect';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function IsDirect(dpy: x_display_ptr; ctx: glx_context): glBool8 :=
      ntv_IsDirect_1(dpy, ctx);
    
    // added in glx1.3
    private static function ntv_MakeContextCurrent_1(dpy: x_display_ptr; draw: glx_drawable; read: glx_drawable; ctx: glx_context): glBool8;
    external 'libGL.so.1' name 'glXMakeContextCurrent';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function MakeContextCurrent(dpy: x_display_ptr; draw: glx_drawable; read: glx_drawable; ctx: glx_context): glBool8 :=
      ntv_MakeContextCurrent_1(dpy, draw, read, ctx);
    
    // added in glx1.0
    private static function ntv_MakeCurrent_1(dpy: x_display_ptr; drawable: glx_drawable; ctx: glx_context): glBool8;
    external 'libGL.so.1' name 'glXMakeCurrent';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function MakeCurrent(dpy: x_display_ptr; drawable: glx_drawable; ctx: glx_context): glBool8 :=
      ntv_MakeCurrent_1(dpy, drawable, ctx);
    
    // added in glx1.3
    private static function ntv_QueryContext_1(dpy: x_display_ptr; ctx: glx_context; attribute: Int32; var value: Int32): Int32;
    external 'libGL.so.1' name 'glXQueryContext';
    private static function ntv_QueryContext_2(dpy: x_display_ptr; ctx: glx_context; attribute: Int32; value: IntPtr): Int32;
    external 'libGL.so.1' name 'glXQueryContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryContext(dpy: x_display_ptr; ctx: glx_context; attribute: Int32; value: array of Int32): Int32;
    type PInt32 = ^Int32;
    begin
      Result := if (value<>nil) and (value.Length<>0) then
        ntv_QueryContext_1(dpy, ctx, attribute, value[0]) else
        ntv_QueryContext_1(dpy, ctx, attribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryContext(dpy: x_display_ptr; ctx: glx_context; attribute: Int32; var value: Int32): Int32 :=
      ntv_QueryContext_1(dpy, ctx, attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryContext(dpy: x_display_ptr; ctx: glx_context; attribute: Int32; value: IntPtr): Int32 :=
      ntv_QueryContext_2(dpy, ctx, attribute, value);
    
    // added in glx1.3
    private static procedure ntv_QueryDrawable_1(dpy: x_display_ptr; draw: glx_drawable; attribute: Int32; var value: UInt32);
    external 'libGL.so.1' name 'glXQueryDrawable';
    private static procedure ntv_QueryDrawable_2(dpy: x_display_ptr; draw: glx_drawable; attribute: Int32; value: IntPtr);
    external 'libGL.so.1' name 'glXQueryDrawable';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure QueryDrawable(dpy: x_display_ptr; draw: glx_drawable; attribute: Int32; value: array of UInt32);
    type PUInt32 = ^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        ntv_QueryDrawable_1(dpy, draw, attribute, value[0]) else
        ntv_QueryDrawable_1(dpy, draw, attribute, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure QueryDrawable(dpy: x_display_ptr; draw: glx_drawable; attribute: Int32; var value: UInt32) :=
      ntv_QueryDrawable_1(dpy, draw, attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure QueryDrawable(dpy: x_display_ptr; draw: glx_drawable; attribute: Int32; value: IntPtr) :=
      ntv_QueryDrawable_2(dpy, draw, attribute, value);
    
    // added in glx1.0
    private static function ntv_QueryExtension_1(dpy: x_display_ptr; var errorb: Int32; var &event: Int32): glBool8;
    external 'libGL.so.1' name 'glXQueryExtension';
    private static function ntv_QueryExtension_2(dpy: x_display_ptr; var errorb: Int32; &event: IntPtr): glBool8;
    external 'libGL.so.1' name 'glXQueryExtension';
    private static function ntv_QueryExtension_3(dpy: x_display_ptr; errorb: IntPtr; var &event: Int32): glBool8;
    external 'libGL.so.1' name 'glXQueryExtension';
    private static function ntv_QueryExtension_4(dpy: x_display_ptr; errorb: IntPtr; &event: IntPtr): glBool8;
    external 'libGL.so.1' name 'glXQueryExtension';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryExtension(dpy: x_display_ptr; errorb: array of Int32; &event: array of Int32): glBool8;
    type PInt32 = ^Int32;
    begin
      Result := if (&event<>nil) and (&event.Length<>0) then
        if (errorb<>nil) and (errorb.Length<>0) then
          ntv_QueryExtension_1(dpy, errorb[0], &event[0]) else
          ntv_QueryExtension_1(dpy, PInt32(nil)^, &event[0]) else
        if (errorb<>nil) and (errorb.Length<>0) then
          ntv_QueryExtension_1(dpy, errorb[0], PInt32(nil)^) else
          ntv_QueryExtension_1(dpy, PInt32(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryExtension(dpy: x_display_ptr; var errorb: Int32; var &event: Int32): glBool8 :=
      ntv_QueryExtension_1(dpy, errorb, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryExtension(dpy: x_display_ptr; var errorb: Int32; &event: IntPtr): glBool8 :=
      ntv_QueryExtension_2(dpy, errorb, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryExtension(dpy: x_display_ptr; errorb: IntPtr; var &event: Int32): glBool8 :=
      ntv_QueryExtension_3(dpy, errorb, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryExtension(dpy: x_display_ptr; errorb: IntPtr; &event: IntPtr): glBool8 :=
      ntv_QueryExtension_4(dpy, errorb, &event);
    
    // added in glx1.1
    private static function ntv_QueryExtensionsString_1(dpy: x_display_ptr; screen: Int32): IntPtr;
    external 'libGL.so.1' name 'glXQueryExtensionsString';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryExtensionsString(dpy: x_display_ptr; screen: Int32): string :=
      Marshal.PtrToStringAnsi(ntv_QueryExtensionsString_1(dpy, screen));
    
    // added in glx1.1
    private static function ntv_QueryServerString_1(dpy: x_display_ptr; screen: Int32; name: Int32): IntPtr;
    external 'libGL.so.1' name 'glXQueryServerString';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryServerString(dpy: x_display_ptr; screen: Int32; name: Int32): string :=
      Marshal.PtrToStringAnsi(ntv_QueryServerString_1(dpy, screen, name));
    
    // added in glx1.0
    private static function ntv_QueryVersion_1(dpy: x_display_ptr; var maj: Int32; var min: Int32): glBool8;
    external 'libGL.so.1' name 'glXQueryVersion';
    private static function ntv_QueryVersion_2(dpy: x_display_ptr; var maj: Int32; min: IntPtr): glBool8;
    external 'libGL.so.1' name 'glXQueryVersion';
    private static function ntv_QueryVersion_3(dpy: x_display_ptr; maj: IntPtr; var min: Int32): glBool8;
    external 'libGL.so.1' name 'glXQueryVersion';
    private static function ntv_QueryVersion_4(dpy: x_display_ptr; maj: IntPtr; min: IntPtr): glBool8;
    external 'libGL.so.1' name 'glXQueryVersion';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryVersion(dpy: x_display_ptr; maj: array of Int32; min: array of Int32): glBool8;
    type PInt32 = ^Int32;
    begin
      Result := if (min<>nil) and (min.Length<>0) then
        if (maj<>nil) and (maj.Length<>0) then
          ntv_QueryVersion_1(dpy, maj[0], min[0]) else
          ntv_QueryVersion_1(dpy, PInt32(nil)^, min[0]) else
        if (maj<>nil) and (maj.Length<>0) then
          ntv_QueryVersion_1(dpy, maj[0], PInt32(nil)^) else
          ntv_QueryVersion_1(dpy, PInt32(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryVersion(dpy: x_display_ptr; var maj: Int32; var min: Int32): glBool8 :=
      ntv_QueryVersion_1(dpy, maj, min);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryVersion(dpy: x_display_ptr; var maj: Int32; min: IntPtr): glBool8 :=
      ntv_QueryVersion_2(dpy, maj, min);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryVersion(dpy: x_display_ptr; maj: IntPtr; var min: Int32): glBool8 :=
      ntv_QueryVersion_3(dpy, maj, min);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryVersion(dpy: x_display_ptr; maj: IntPtr; min: IntPtr): glBool8 :=
      ntv_QueryVersion_4(dpy, maj, min);
    
    // added in glx1.3
    private static procedure ntv_SelectEvent_1(dpy: x_display_ptr; draw: glx_drawable; event_mask: UInt32);
    external 'libGL.so.1' name 'glXSelectEvent';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure SelectEvent(dpy: x_display_ptr; draw: glx_drawable; event_mask: UInt32) :=
      ntv_SelectEvent_1(dpy, draw, event_mask);
    
    // added in glx1.0
    private static procedure ntv_SwapBuffers_1(dpy: x_display_ptr; drawable: glx_drawable);
    external 'libGL.so.1' name 'glXSwapBuffers';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure SwapBuffers(dpy: x_display_ptr; drawable: glx_drawable) :=
      ntv_SwapBuffers_1(dpy, drawable);
    
    // added in glx1.0
    private static procedure ntv_UseXFont_1(font: x_font; first: Int32; count: Int32; list: Int32);
    external 'libGL.so.1' name 'glXUseXFont';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure UseXFont(font: x_font; first: Int32; count: Int32; list: Int32) :=
      ntv_UseXFont_1(font, first, count, list);
    
    // added in glx1.0
    private static procedure ntv_WaitGL_1;
    external 'libGL.so.1' name 'glXWaitGL';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure WaitGL :=
      ntv_WaitGL_1;
    
    // added in glx1.0
    private static procedure ntv_WaitX_1;
    external 'libGL.so.1' name 'glXWaitX';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure WaitX :=
      ntv_WaitX_1;
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  wgl = static class
    
    // added in wgl1.0
    private static function ntv_CopyContext_1(hglrcSrc: gdi_rendering_context; hglrcDst: gdi_rendering_context; mask: glAttribMask): glBool32;
    external 'opengl32.dll' name 'wglCopyContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CopyContext(hglrcSrc: gdi_rendering_context; hglrcDst: gdi_rendering_context; mask: glAttribMask): glBool32 :=
      ntv_CopyContext_1(hglrcSrc, hglrcDst, mask);
    
    // added in wgl1.0
    private static function ntv_CreateContext_1(hDc: gdi_device_context): gdi_rendering_context;
    external 'opengl32.dll' name 'wglCreateContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContext(hDc: gdi_device_context): gdi_rendering_context :=
      ntv_CreateContext_1(hDc);
    
    // added in wgl1.0
    private static function ntv_CreateLayerContext_1(hDc: gdi_device_context; level: Int32): gdi_rendering_context;
    external 'opengl32.dll' name 'wglCreateLayerContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateLayerContext(hDc: gdi_device_context; level: Int32): gdi_rendering_context :=
      ntv_CreateLayerContext_1(hDc, level);
    
    // added in wgl1.0
    private static function ntv_DeleteContext_1(oldContext: gdi_rendering_context): glBool32;
    external 'opengl32.dll' name 'wglDeleteContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function DeleteContext(oldContext: gdi_rendering_context): glBool32 :=
      ntv_DeleteContext_1(oldContext);
    
    // added in wgl1.0
    private static function ntv_DescribeLayerPlane_1(hDc: gdi_device_context; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; var plpd: gdi_layer_plane_descriptor): glBool32;
    external 'opengl32.dll' name 'wglDescribeLayerPlane';
    private static function ntv_DescribeLayerPlane_2(hDc: gdi_device_context; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; plpd: IntPtr): glBool32;
    external 'opengl32.dll' name 'wglDescribeLayerPlane';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function DescribeLayerPlane(hDc: gdi_device_context; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; plpd: array of gdi_layer_plane_descriptor): glBool32;
    type PGdi_layer_plane_descriptor = ^gdi_layer_plane_descriptor;
    begin
      Result := if (plpd<>nil) and (plpd.Length<>0) then
        ntv_DescribeLayerPlane_1(hDc, pixelFormat, layerPlane, nBytes, plpd[0]) else
        ntv_DescribeLayerPlane_1(hDc, pixelFormat, layerPlane, nBytes, PGdi_layer_plane_descriptor(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function DescribeLayerPlane(hDc: gdi_device_context; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; var plpd: gdi_layer_plane_descriptor): glBool32 :=
      ntv_DescribeLayerPlane_1(hDc, pixelFormat, layerPlane, nBytes, plpd);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function DescribeLayerPlane(hDc: gdi_device_context; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; plpd: IntPtr): glBool32 :=
      ntv_DescribeLayerPlane_2(hDc, pixelFormat, layerPlane, nBytes, plpd);
    
    // added in wgl1.0
    private static function ntv_GetCurrentContext_1: gdi_rendering_context;
    external 'opengl32.dll' name 'wglGetCurrentContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCurrentContext: gdi_rendering_context :=
      ntv_GetCurrentContext_1;
    
    // added in wgl1.0
    private static function ntv_GetCurrentDC_1: gdi_device_context;
    external 'opengl32.dll' name 'wglGetCurrentDC';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCurrentDC: gdi_device_context :=
      ntv_GetCurrentDC_1;
    
    // added in wgl1.0
    private static function ntv_GetLayerPaletteEntries_1(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; var pcr: gdi_color_ref): Int32;
    external 'opengl32.dll' name 'wglGetLayerPaletteEntries';
    private static function ntv_GetLayerPaletteEntries_2(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: IntPtr): Int32;
    external 'opengl32.dll' name 'wglGetLayerPaletteEntries';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetLayerPaletteEntries(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; var pcr: gdi_color_ref): Int32 :=
      ntv_GetLayerPaletteEntries_1(hdc, iLayerPlane, iStart, cEntries, pcr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetLayerPaletteEntries(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: IntPtr): Int32 :=
      ntv_GetLayerPaletteEntries_2(hdc, iLayerPlane, iStart, cEntries, pcr);
    
    // added in wgl1.0
    private static function ntv_GetProcAddress_1(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProcAddress(lpszProc: string): IntPtr;
    begin
      var lpszProc_str_ptr := Marshal.StringToHGlobalAnsi(lpszProc);
      try
        Result := ntv_GetProcAddress_1(lpszProc_str_ptr);
      finally
        Marshal.FreeHGlobal(lpszProc_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProcAddress(lpszProc: IntPtr): IntPtr :=
      ntv_GetProcAddress_1(lpszProc);
    
    // added in wgl1.0
    private static function ntv_MakeCurrent_1(hDc: gdi_device_context; newContext: gdi_rendering_context): glBool32;
    external 'opengl32.dll' name 'wglMakeCurrent';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function MakeCurrent(hDc: gdi_device_context; newContext: gdi_rendering_context): glBool32 :=
      ntv_MakeCurrent_1(hDc, newContext);
    
    // added in wgl1.0
    private static function ntv_RealizeLayerPalette_1(hdc: gdi_device_context; iLayerPlane: Int32; bRealize: glBool32): glBool32;
    external 'opengl32.dll' name 'wglRealizeLayerPalette';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RealizeLayerPalette(hdc: gdi_device_context; iLayerPlane: Int32; bRealize: glBool32): glBool32 :=
      ntv_RealizeLayerPalette_1(hdc, iLayerPlane, bRealize);
    
    // added in wgl1.0
    private static function ntv_SetLayerPaletteEntries_1(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; var pcr: gdi_color_ref): Int32;
    external 'opengl32.dll' name 'wglSetLayerPaletteEntries';
    private static function ntv_SetLayerPaletteEntries_2(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: IntPtr): Int32;
    external 'opengl32.dll' name 'wglSetLayerPaletteEntries';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetLayerPaletteEntries(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: array of gdi_color_ref): Int32;
    type PGdi_color_ref = ^gdi_color_ref;
    begin
      Result := if (pcr<>nil) and (pcr.Length<>0) then
        ntv_SetLayerPaletteEntries_1(hdc, iLayerPlane, iStart, cEntries, pcr[0]) else
        ntv_SetLayerPaletteEntries_1(hdc, iLayerPlane, iStart, cEntries, PGdi_color_ref(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetLayerPaletteEntries(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; var pcr: gdi_color_ref): Int32 :=
      ntv_SetLayerPaletteEntries_1(hdc, iLayerPlane, iStart, cEntries, pcr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetLayerPaletteEntries(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: IntPtr): Int32 :=
      ntv_SetLayerPaletteEntries_2(hdc, iLayerPlane, iStart, cEntries, pcr);
    
    // added in wgl1.0
    private static function ntv_ShareLists_1(hrcSrvShare: gdi_rendering_context; hrcSrvSource: gdi_rendering_context): glBool32;
    external 'opengl32.dll' name 'wglShareLists';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ShareLists(hrcSrvShare: gdi_rendering_context; hrcSrvSource: gdi_rendering_context): glBool32 :=
      ntv_ShareLists_1(hrcSrvShare, hrcSrvSource);
    
    // added in wgl1.0
    private static function ntv_SwapLayerBuffers_1(hdc: gdi_device_context; fuFlags: wglLayerPlaneMask): glBool32;
    external 'opengl32.dll' name 'wglSwapLayerBuffers';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SwapLayerBuffers(hdc: gdi_device_context; fuFlags: wglLayerPlaneMask): glBool32 :=
      ntv_SwapLayerBuffers_1(hdc, fuFlags);
    
    // added in wgl1.0
    private static function ntv_UseFontBitmaps_1(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32): glBool32;
    external 'opengl32.dll' name 'wglUseFontBitmaps';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontBitmaps(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32): glBool32 :=
      ntv_UseFontBitmaps_1(hDC, first, count, listBase);
    
    // added in wgl1.0
    private static function ntv_UseFontBitmapsA_1(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32): glBool32;
    external 'opengl32.dll' name 'wglUseFontBitmapsA';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontBitmapsA(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32): glBool32 :=
      ntv_UseFontBitmapsA_1(hDC, first, count, listBase);
    
    // added in wgl1.0
    private static function ntv_UseFontBitmapsW_1(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32): glBool32;
    external 'opengl32.dll' name 'wglUseFontBitmapsW';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontBitmapsW(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32): glBool32 :=
      ntv_UseFontBitmapsW_1(hDC, first, count, listBase);
    
    // added in wgl1.0
    private static function ntv_UseFontOutlines_1(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: wglFontFormat; var lpgmf: gdi_glyphmetrics_float): glBool32;
    external 'opengl32.dll' name 'wglUseFontOutlines';
    private static function ntv_UseFontOutlines_2(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: wglFontFormat; lpgmf: IntPtr): glBool32;
    external 'opengl32.dll' name 'wglUseFontOutlines';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlines(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: wglFontFormat; lpgmf: array of gdi_glyphmetrics_float): glBool32;
    type PGdi_glyphmetrics_float = ^gdi_glyphmetrics_float;
    begin
      Result := if (lpgmf<>nil) and (lpgmf.Length<>0) then
        ntv_UseFontOutlines_1(hDC, first, count, listBase, deviation, extrusion, format, lpgmf[0]) else
        ntv_UseFontOutlines_1(hDC, first, count, listBase, deviation, extrusion, format, PGdi_glyphmetrics_float(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlines(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: wglFontFormat; var lpgmf: gdi_glyphmetrics_float): glBool32 :=
      ntv_UseFontOutlines_1(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlines(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: wglFontFormat; lpgmf: IntPtr): glBool32 :=
      ntv_UseFontOutlines_2(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
    
    // added in wgl1.0
    private static function ntv_UseFontOutlinesA_1(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: wglFontFormat; var lpgmf: gdi_glyphmetrics_float): glBool32;
    external 'opengl32.dll' name 'wglUseFontOutlinesA';
    private static function ntv_UseFontOutlinesA_2(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: wglFontFormat; lpgmf: IntPtr): glBool32;
    external 'opengl32.dll' name 'wglUseFontOutlinesA';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlinesA(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: wglFontFormat; lpgmf: array of gdi_glyphmetrics_float): glBool32;
    type PGdi_glyphmetrics_float = ^gdi_glyphmetrics_float;
    begin
      Result := if (lpgmf<>nil) and (lpgmf.Length<>0) then
        ntv_UseFontOutlinesA_1(hDC, first, count, listBase, deviation, extrusion, format, lpgmf[0]) else
        ntv_UseFontOutlinesA_1(hDC, first, count, listBase, deviation, extrusion, format, PGdi_glyphmetrics_float(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlinesA(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: wglFontFormat; var lpgmf: gdi_glyphmetrics_float): glBool32 :=
      ntv_UseFontOutlinesA_1(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlinesA(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: wglFontFormat; lpgmf: IntPtr): glBool32 :=
      ntv_UseFontOutlinesA_2(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
    
    // added in wgl1.0
    private static function ntv_UseFontOutlinesW_1(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: wglFontFormat; var lpgmf: gdi_glyphmetrics_float): glBool32;
    external 'opengl32.dll' name 'wglUseFontOutlinesW';
    private static function ntv_UseFontOutlinesW_2(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: wglFontFormat; lpgmf: IntPtr): glBool32;
    external 'opengl32.dll' name 'wglUseFontOutlinesW';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlinesW(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: wglFontFormat; lpgmf: array of gdi_glyphmetrics_float): glBool32;
    type PGdi_glyphmetrics_float = ^gdi_glyphmetrics_float;
    begin
      Result := if (lpgmf<>nil) and (lpgmf.Length<>0) then
        ntv_UseFontOutlinesW_1(hDC, first, count, listBase, deviation, extrusion, format, lpgmf[0]) else
        ntv_UseFontOutlinesW_1(hDC, first, count, listBase, deviation, extrusion, format, PGdi_glyphmetrics_float(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlinesW(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: wglFontFormat; var lpgmf: gdi_glyphmetrics_float): glBool32 :=
      ntv_UseFontOutlinesW_1(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlinesW(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: wglFontFormat; lpgmf: IntPtr): glBool32 :=
      ntv_UseFontOutlinesW_2(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
    
  end;
  
  
  