  
  
  
  {$ifndef DEBUG}
  [System.Security.SuppressUnmanagedCodeSecurity]
  {$endif DEBUG}
  [PCUNotRestore]
  ///
  cl = static class
    
    // added in cl1.0
    private static function ntv_BuildProgram_1(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
      external 'OpenCL' name 'clBuildProgram';
    private static function ntv_BuildProgram_2(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
      external 'OpenCL' name 'clBuildProgram';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function BuildProgram(&program: cl_program; num_devices: UInt32; device_list: array of cl_device_id; options: string; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := BuildProgram(&program, num_devices, device_list, options_str_ptr, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function BuildProgram(&program: cl_program; num_devices: UInt32; device_list: array of cl_device_id; options: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
      type PCl_device_id = ^cl_device_id;
    begin
      Result := if (device_list<>nil) and (device_list.Length<>0) then
        ntv_BuildProgram_1(&program, num_devices, device_list[0], options, pfn_notify, user_data) else
        ntv_BuildProgram_1(&program, num_devices, PCl_device_id(nil)^, options, pfn_notify, user_data);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function BuildProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: string; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_BuildProgram_1(&program, num_devices, device_list, options_str_ptr, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function BuildProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_BuildProgram_1(&program, num_devices, device_list, options, pfn_notify, user_data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function BuildProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: string; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_BuildProgram_2(&program, num_devices, device_list, options_str_ptr, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function BuildProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_BuildProgram_2(&program, num_devices, device_list, options, pfn_notify, user_data);
    
    // added in cl2.1
    private static function ntv_CloneKernel_1(source_kernel: cl_kernel; var errcode_ret: clErrorCode): cl_kernel;
      external 'OpenCL' name 'clCloneKernel';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CloneKernel(source_kernel: cl_kernel; var errcode_ret: clErrorCode): cl_kernel :=
      ntv_CloneKernel_1(source_kernel, errcode_ret);
    
    // added in cl1.2
    private static function ntv_CompileProgram_1(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_headers: UInt32; var input_headers: cl_program; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
      external 'OpenCL' name 'clCompileProgram';
    private static function ntv_CompileProgram_2(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_headers: UInt32; var input_headers: cl_program; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
      external 'OpenCL' name 'clCompileProgram';
    private static function ntv_CompileProgram_3(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_headers: UInt32; input_headers: IntPtr; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
      external 'OpenCL' name 'clCompileProgram';
    private static function ntv_CompileProgram_4(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_headers: UInt32; input_headers: IntPtr; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
      external 'OpenCL' name 'clCompileProgram';
    private static function ntv_CompileProgram_5(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_headers: UInt32; var input_headers: cl_program; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
      external 'OpenCL' name 'clCompileProgram';
    private static function ntv_CompileProgram_6(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_headers: UInt32; var input_headers: cl_program; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
      external 'OpenCL' name 'clCompileProgram';
    private static function ntv_CompileProgram_7(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_headers: UInt32; input_headers: IntPtr; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
      external 'OpenCL' name 'clCompileProgram';
    private static function ntv_CompileProgram_8(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_headers: UInt32; input_headers: IntPtr; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
      external 'OpenCL' name 'clCompileProgram';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: array of cl_device_id; options: string; num_input_headers: UInt32; input_headers: array of cl_program; header_include_names: array of string; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := CompileProgram(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: array of cl_device_id; options: IntPtr; num_input_headers: UInt32; input_headers: array of cl_program; header_include_names: array of string; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
      type PCl_device_id = ^cl_device_id;
      type PCl_program = ^cl_program;
    begin
      if (header_include_names=nil) or (header_include_names.Length=0) then
      begin
        Result := if (device_list<>nil) and (device_list.Length<>0) then
          if (input_headers<>nil) and (input_headers.Length<>0) then
            ntv_CompileProgram_2(&program, num_devices, device_list[0], options, num_input_headers, input_headers[0], nil, pfn_notify, user_data) else
            ntv_CompileProgram_2(&program, num_devices, device_list[0], options, num_input_headers, PCl_program(nil)^, nil, pfn_notify, user_data) else
          if (input_headers<>nil) and (input_headers.Length<>0) then
            ntv_CompileProgram_2(&program, num_devices, PCl_device_id(nil)^, options, num_input_headers, input_headers[0], nil, pfn_notify, user_data) else
            ntv_CompileProgram_2(&program, num_devices, PCl_device_id(nil)^, options, num_input_headers, PCl_program(nil)^, nil, pfn_notify, user_data);
        exit;
      end;
      var header_include_names_temp_arr: array of IntPtr;
      try
        begin
          var header_include_names_org_el_1 := header_include_names;
          var header_include_names_len_1 := header_include_names_org_el_1.Length;
          SetLength(header_include_names_temp_arr, header_include_names_len_1);
          var header_include_names_tmp_el_1 := header_include_names_temp_arr;
          for var header_include_names_ind_1 := 0 to header_include_names_len_1-1 do
          begin
            var header_include_names_org_el_2 := header_include_names_org_el_1[header_include_names_ind_1];
            if (header_include_names_org_el_2=nil) or (header_include_names_org_el_2.Length=0) then continue;
            header_include_names_tmp_el_1[header_include_names_ind_1] := Marshal.StringToHGlobalAnsi(header_include_names_org_el_2);
          end;
        end;
        Result := if (device_list<>nil) and (device_list.Length<>0) then
          if (input_headers<>nil) and (input_headers.Length<>0) then
            ntv_CompileProgram_1(&program, num_devices, device_list[0], options, num_input_headers, input_headers[0], header_include_names_temp_arr[0], pfn_notify, user_data) else
            ntv_CompileProgram_1(&program, num_devices, device_list[0], options, num_input_headers, PCl_program(nil)^, header_include_names_temp_arr[0], pfn_notify, user_data) else
          if (input_headers<>nil) and (input_headers.Length<>0) then
            ntv_CompileProgram_1(&program, num_devices, PCl_device_id(nil)^, options, num_input_headers, input_headers[0], header_include_names_temp_arr[0], pfn_notify, user_data) else
            ntv_CompileProgram_1(&program, num_devices, PCl_device_id(nil)^, options, num_input_headers, PCl_program(nil)^, header_include_names_temp_arr[0], pfn_notify, user_data);
      finally
         foreach var arr_el1 in header_include_names_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: string; num_input_headers: UInt32; var input_headers: cl_program; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_CompileProgram_1(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: string; num_input_headers: UInt32; var input_headers: cl_program; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_CompileProgram_2(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: string; num_input_headers: UInt32; input_headers: IntPtr; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_CompileProgram_3(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: string; num_input_headers: UInt32; input_headers: IntPtr; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_CompileProgram_4(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_headers: UInt32; var input_headers: cl_program; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_CompileProgram_1(&program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_headers: UInt32; var input_headers: cl_program; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_CompileProgram_2(&program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_headers: UInt32; input_headers: IntPtr; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_CompileProgram_3(&program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_headers: UInt32; input_headers: IntPtr; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_CompileProgram_4(&program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: string; num_input_headers: UInt32; var input_headers: cl_program; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_CompileProgram_5(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: string; num_input_headers: UInt32; var input_headers: cl_program; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_CompileProgram_6(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: string; num_input_headers: UInt32; input_headers: IntPtr; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_CompileProgram_7(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: string; num_input_headers: UInt32; input_headers: IntPtr; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_CompileProgram_8(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_headers: UInt32; var input_headers: cl_program; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_CompileProgram_5(&program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_headers: UInt32; var input_headers: cl_program; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_CompileProgram_6(&program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_headers: UInt32; input_headers: IntPtr; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_CompileProgram_7(&program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_headers: UInt32; input_headers: IntPtr; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_CompileProgram_8(&program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
    
    // added in cl1.0
    private static function ntv_CreateBuffer_1(context: cl_context; flags: clMemFlags; size: UIntPtr; var host_ptr: cl_mem_android_native_buffer_host_ptr; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateBuffer';
    private static function ntv_CreateBuffer_2(context: cl_context; flags: clMemFlags; size: UIntPtr; var host_ptr: cl_mem_ext_host_ptr; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateBuffer';
    private static function ntv_CreateBuffer_3(context: cl_context; flags: clMemFlags; size: UIntPtr; var host_ptr: cl_mem_ion_host_ptr; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateBuffer';
    private static function ntv_CreateBuffer_4(context: cl_context; flags: clMemFlags; size: UIntPtr; var host_ptr: Byte; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateBuffer';
    private static function ntv_CreateBuffer_5(context: cl_context; flags: clMemFlags; size: UIntPtr; host_ptr: pointer; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateBuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBuffer<T>(context: cl_context; flags: clMemFlags; size: UIntPtr; host_ptr: array of T; var errcode_ret: clErrorCode): cl_mem; where T: record;
      type PT = ^T;
    begin
      Result := if (host_ptr<>nil) and (host_ptr.Length<>0) then
        CreateBuffer(context, flags, size, host_ptr[0], errcode_ret) else
        CreateBuffer(context, flags, size, PT(nil)^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBuffer(context: cl_context; flags: clMemFlags; size: UIntPtr; var host_ptr: cl_mem_android_native_buffer_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateBuffer_1(context, flags, size, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBuffer(context: cl_context; flags: clMemFlags; size: UIntPtr; var host_ptr: cl_mem_ext_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateBuffer_2(context, flags, size, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBuffer(context: cl_context; flags: clMemFlags; size: UIntPtr; var host_ptr: cl_mem_ion_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateBuffer_3(context, flags, size, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBuffer<T>(context: cl_context; flags: clMemFlags; size: UIntPtr; var host_ptr: T; var errcode_ret: clErrorCode): cl_mem; where T: record;
    begin
      Result := ntv_CreateBuffer_4(context, flags, size, PByte(pointer(@host_ptr))^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBuffer(context: cl_context; flags: clMemFlags; size: UIntPtr; host_ptr: pointer; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateBuffer_5(context, flags, size, host_ptr, errcode_ret);
    
    // added in cl3.0
    private static function ntv_CreateBufferWithProperties_1(context: cl_context; var properties: clMemProperties; flags: clMemFlags; size: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateBufferWithProperties';
    private static function ntv_CreateBufferWithProperties_2(context: cl_context; properties: IntPtr; flags: clMemFlags; size: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateBufferWithProperties';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBufferWithProperties(context: cl_context; properties: array of clMemProperties; flags: clMemFlags; size: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem;
      type PClMemProperties = ^clMemProperties;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_CreateBufferWithProperties_1(context, properties[0], flags, size, host_ptr, errcode_ret) else
        ntv_CreateBufferWithProperties_1(context, PClMemProperties(nil)^, flags, size, host_ptr, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBufferWithProperties(context: cl_context; var properties: clMemProperties; flags: clMemFlags; size: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateBufferWithProperties_1(context, properties, flags, size, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBufferWithProperties(context: cl_context; properties: IntPtr; flags: clMemFlags; size: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateBufferWithProperties_2(context, properties, flags, size, host_ptr, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateCommandQueue_1(context: cl_context; device: cl_device_id; properties: clCommandQueueProperties; var errcode_ret: clErrorCode): cl_command_queue;
      external 'OpenCL' name 'clCreateCommandQueue';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateCommandQueue(context: cl_context; device: cl_device_id; properties: clCommandQueueProperties; var errcode_ret: clErrorCode): cl_command_queue :=
      ntv_CreateCommandQueue_1(context, device, properties, errcode_ret);
    
    // added in cl2.0
    private static function ntv_CreateCommandQueueWithProperties_1(context: cl_context; device: cl_device_id; var properties: clQueueProperties; var errcode_ret: clErrorCode): cl_command_queue;
      external 'OpenCL' name 'clCreateCommandQueueWithProperties';
    private static function ntv_CreateCommandQueueWithProperties_2(context: cl_context; device: cl_device_id; properties: IntPtr; var errcode_ret: clErrorCode): cl_command_queue;
      external 'OpenCL' name 'clCreateCommandQueueWithProperties';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateCommandQueueWithProperties(context: cl_context; device: cl_device_id; properties: array of clQueueProperties; var errcode_ret: clErrorCode): cl_command_queue;
      type PClQueueProperties = ^clQueueProperties;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_CreateCommandQueueWithProperties_1(context, device, properties[0], errcode_ret) else
        ntv_CreateCommandQueueWithProperties_1(context, device, PClQueueProperties(nil)^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateCommandQueueWithProperties(context: cl_context; device: cl_device_id; var properties: clQueueProperties; var errcode_ret: clErrorCode): cl_command_queue :=
      ntv_CreateCommandQueueWithProperties_1(context, device, properties, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateCommandQueueWithProperties(context: cl_context; device: cl_device_id; properties: IntPtr; var errcode_ret: clErrorCode): cl_command_queue :=
      ntv_CreateCommandQueueWithProperties_2(context, device, properties, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateContext_1(var properties: clContextProperties; num_devices: UInt32; var devices: cl_device_id; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context;
      external 'OpenCL' name 'clCreateContext';
    private static function ntv_CreateContext_2(var properties: clContextProperties; num_devices: UInt32; devices: IntPtr; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context;
      external 'OpenCL' name 'clCreateContext';
    private static function ntv_CreateContext_3(properties: IntPtr; num_devices: UInt32; var devices: cl_device_id; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context;
      external 'OpenCL' name 'clCreateContext';
    private static function ntv_CreateContext_4(properties: IntPtr; num_devices: UInt32; devices: IntPtr; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context;
      external 'OpenCL' name 'clCreateContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContext(properties: array of clContextProperties; num_devices: UInt32; devices: array of cl_device_id; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context;
      type PClContextProperties = ^clContextProperties;
      type PCl_device_id = ^cl_device_id;
    begin
      Result := if (devices<>nil) and (devices.Length<>0) then
        if (properties<>nil) and (properties.Length<>0) then
          ntv_CreateContext_1(properties[0], num_devices, devices[0], pfn_notify, user_data, errcode_ret) else
          ntv_CreateContext_1(PClContextProperties(nil)^, num_devices, devices[0], pfn_notify, user_data, errcode_ret) else
        if (properties<>nil) and (properties.Length<>0) then
          ntv_CreateContext_1(properties[0], num_devices, PCl_device_id(nil)^, pfn_notify, user_data, errcode_ret) else
          ntv_CreateContext_1(PClContextProperties(nil)^, num_devices, PCl_device_id(nil)^, pfn_notify, user_data, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContext(var properties: clContextProperties; num_devices: UInt32; var devices: cl_device_id; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context :=
      ntv_CreateContext_1(properties, num_devices, devices, pfn_notify, user_data, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContext(var properties: clContextProperties; num_devices: UInt32; devices: IntPtr; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context :=
      ntv_CreateContext_2(properties, num_devices, devices, pfn_notify, user_data, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContext(properties: IntPtr; num_devices: UInt32; var devices: cl_device_id; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context :=
      ntv_CreateContext_3(properties, num_devices, devices, pfn_notify, user_data, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContext(properties: IntPtr; num_devices: UInt32; devices: IntPtr; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context :=
      ntv_CreateContext_4(properties, num_devices, devices, pfn_notify, user_data, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateContextFromType_1(var properties: clContextProperties; device_type: clDeviceType; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context;
      external 'OpenCL' name 'clCreateContextFromType';
    private static function ntv_CreateContextFromType_2(properties: IntPtr; device_type: clDeviceType; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context;
      external 'OpenCL' name 'clCreateContextFromType';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContextFromType(properties: array of clContextProperties; device_type: clDeviceType; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context;
      type PClContextProperties = ^clContextProperties;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_CreateContextFromType_1(properties[0], device_type, pfn_notify, user_data, errcode_ret) else
        ntv_CreateContextFromType_1(PClContextProperties(nil)^, device_type, pfn_notify, user_data, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContextFromType(var properties: clContextProperties; device_type: clDeviceType; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context :=
      ntv_CreateContextFromType_1(properties, device_type, pfn_notify, user_data, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContextFromType(properties: IntPtr; device_type: clDeviceType; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context :=
      ntv_CreateContextFromType_2(properties, device_type, pfn_notify, user_data, errcode_ret);
    
    // added in cl1.2
    private static function ntv_CreateImage_1(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: cl_mem_android_native_buffer_host_ptr; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateImage';
    private static function ntv_CreateImage_2(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: cl_mem_ext_host_ptr; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateImage';
    private static function ntv_CreateImage_3(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: cl_mem_ion_host_ptr; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateImage';
    private static function ntv_CreateImage_4(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: Byte; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateImage';
    private static function ntv_CreateImage_5(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; host_ptr: pointer; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateImage';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage<T>(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; host_ptr: array of T; var errcode_ret: clErrorCode): cl_mem; where T: record;
      type PT = ^T;
    begin
      Result := if (host_ptr<>nil) and (host_ptr.Length<>0) then
        CreateImage(context, flags, image_format, image_desc, host_ptr[0], errcode_ret) else
        CreateImage(context, flags, image_format, image_desc, PT(nil)^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: cl_mem_android_native_buffer_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage_1(context, flags, image_format, image_desc, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: cl_mem_ext_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage_2(context, flags, image_format, image_desc, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: cl_mem_ion_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage_3(context, flags, image_format, image_desc, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage<T>(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: T; var errcode_ret: clErrorCode): cl_mem; where T: record;
    begin
      Result := ntv_CreateImage_4(context, flags, image_format, image_desc, PByte(pointer(@host_ptr))^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; host_ptr: pointer; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage_5(context, flags, image_format, image_desc, host_ptr, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateImage2D_1(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_row_pitch: UIntPtr; var host_ptr: cl_mem_android_native_buffer_host_ptr; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateImage2D';
    private static function ntv_CreateImage2D_2(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_row_pitch: UIntPtr; var host_ptr: cl_mem_ext_host_ptr; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateImage2D';
    private static function ntv_CreateImage2D_3(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_row_pitch: UIntPtr; var host_ptr: cl_mem_ion_host_ptr; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateImage2D';
    private static function ntv_CreateImage2D_4(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_row_pitch: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateImage2D';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage2D(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_row_pitch: UIntPtr; var host_ptr: cl_mem_android_native_buffer_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage2D_1(context, flags, image_format, image_width, image_height, image_row_pitch, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage2D(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_row_pitch: UIntPtr; var host_ptr: cl_mem_ext_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage2D_2(context, flags, image_format, image_width, image_height, image_row_pitch, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage2D(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_row_pitch: UIntPtr; var host_ptr: cl_mem_ion_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage2D_3(context, flags, image_format, image_width, image_height, image_row_pitch, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage2D(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_row_pitch: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage2D_4(context, flags, image_format, image_width, image_height, image_row_pitch, host_ptr, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateImage3D_1(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_depth: UIntPtr; image_row_pitch: UIntPtr; image_slice_pitch: UIntPtr; var host_ptr: cl_mem_ext_host_ptr; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateImage3D';
    private static function ntv_CreateImage3D_2(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_depth: UIntPtr; image_row_pitch: UIntPtr; image_slice_pitch: UIntPtr; var host_ptr: cl_mem_ion_host_ptr; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateImage3D';
    private static function ntv_CreateImage3D_3(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_depth: UIntPtr; image_row_pitch: UIntPtr; image_slice_pitch: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateImage3D';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage3D(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_depth: UIntPtr; image_row_pitch: UIntPtr; image_slice_pitch: UIntPtr; var host_ptr: cl_mem_ext_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage3D_1(context, flags, image_format, image_width, image_height, image_depth, image_row_pitch, image_slice_pitch, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage3D(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_depth: UIntPtr; image_row_pitch: UIntPtr; image_slice_pitch: UIntPtr; var host_ptr: cl_mem_ion_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage3D_2(context, flags, image_format, image_width, image_height, image_depth, image_row_pitch, image_slice_pitch, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage3D(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_depth: UIntPtr; image_row_pitch: UIntPtr; image_slice_pitch: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage3D_3(context, flags, image_format, image_width, image_height, image_depth, image_row_pitch, image_slice_pitch, host_ptr, errcode_ret);
    
    // added in cl3.0
    private static function ntv_CreateImageWithProperties_1(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: Byte; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateImageWithProperties';
    private static function ntv_CreateImageWithProperties_2(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; host_ptr: pointer; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateImageWithProperties';
    private static function ntv_CreateImageWithProperties_3(context: cl_context; properties: IntPtr; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: Byte; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateImageWithProperties';
    private static function ntv_CreateImageWithProperties_4(context: cl_context; properties: IntPtr; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; host_ptr: pointer; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateImageWithProperties';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImageWithProperties<T>(context: cl_context; properties: array of clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; host_ptr: array of T; var errcode_ret: clErrorCode): cl_mem; where T: record;
      type PClMemProperties = ^clMemProperties;
      type PT = ^T;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        if (host_ptr<>nil) and (host_ptr.Length<>0) then
          CreateImageWithProperties(context, properties[0], flags, image_format, image_desc, host_ptr[0], errcode_ret) else
          CreateImageWithProperties(context, properties[0], flags, image_format, image_desc, PT(nil)^, errcode_ret) else
        if (host_ptr<>nil) and (host_ptr.Length<>0) then
          CreateImageWithProperties(context, PClMemProperties(nil)^, flags, image_format, image_desc, host_ptr[0], errcode_ret) else
          CreateImageWithProperties(context, PClMemProperties(nil)^, flags, image_format, image_desc, PT(nil)^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImageWithProperties<T>(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: T; var errcode_ret: clErrorCode): cl_mem; where T: record;
    begin
      Result := ntv_CreateImageWithProperties_1(context, properties, flags, image_format, image_desc, PByte(pointer(@host_ptr))^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImageWithProperties(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; host_ptr: pointer; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImageWithProperties_2(context, properties, flags, image_format, image_desc, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImageWithProperties<T>(context: cl_context; properties: IntPtr; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: T; var errcode_ret: clErrorCode): cl_mem; where T: record;
    begin
      Result := ntv_CreateImageWithProperties_3(context, properties, flags, image_format, image_desc, PByte(pointer(@host_ptr))^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImageWithProperties(context: cl_context; properties: IntPtr; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; host_ptr: pointer; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImageWithProperties_4(context, properties, flags, image_format, image_desc, host_ptr, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateKernel_1(&program: cl_program; kernel_name: IntPtr; var errcode_ret: clErrorCode): cl_kernel;
      external 'OpenCL' name 'clCreateKernel';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateKernel(&program: cl_program; kernel_name: string; var errcode_ret: clErrorCode): cl_kernel;
    begin
      var kernel_name_str_ptr := Marshal.StringToHGlobalAnsi(kernel_name);
      try
        Result := ntv_CreateKernel_1(&program, kernel_name_str_ptr, errcode_ret);
      finally
        Marshal.FreeHGlobal(kernel_name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateKernel(&program: cl_program; kernel_name: IntPtr; var errcode_ret: clErrorCode): cl_kernel :=
      ntv_CreateKernel_1(&program, kernel_name, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateKernelsInProgram_1(&program: cl_program; num_kernels: UInt32; var kernels: cl_kernel; var num_kernels_ret: UInt32): clErrorCode;
      external 'OpenCL' name 'clCreateKernelsInProgram';
    private static function ntv_CreateKernelsInProgram_2(&program: cl_program; num_kernels: UInt32; var kernels: cl_kernel; num_kernels_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clCreateKernelsInProgram';
    private static function ntv_CreateKernelsInProgram_3(&program: cl_program; num_kernels: UInt32; kernels: IntPtr; var num_kernels_ret: UInt32): clErrorCode;
      external 'OpenCL' name 'clCreateKernelsInProgram';
    private static function ntv_CreateKernelsInProgram_4(&program: cl_program; num_kernels: UInt32; kernels: IntPtr; num_kernels_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clCreateKernelsInProgram';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateKernelsInProgram(&program: cl_program; num_kernels: UInt32; var kernels: cl_kernel; var num_kernels_ret: UInt32): clErrorCode :=
      ntv_CreateKernelsInProgram_1(&program, num_kernels, kernels, num_kernels_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateKernelsInProgram(&program: cl_program; num_kernels: UInt32; var kernels: cl_kernel; num_kernels_ret: IntPtr): clErrorCode :=
      ntv_CreateKernelsInProgram_2(&program, num_kernels, kernels, num_kernels_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateKernelsInProgram(&program: cl_program; num_kernels: UInt32; kernels: IntPtr; var num_kernels_ret: UInt32): clErrorCode :=
      ntv_CreateKernelsInProgram_3(&program, num_kernels, kernels, num_kernels_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateKernelsInProgram(&program: cl_program; num_kernels: UInt32; kernels: IntPtr; num_kernels_ret: IntPtr): clErrorCode :=
      ntv_CreateKernelsInProgram_4(&program, num_kernels, kernels, num_kernels_ret);
    
    // added in cl2.0
    private static function ntv_CreatePipe_1(context: cl_context; flags: clMemFlags; pipe_packet_size: UInt32; pipe_max_packets: UInt32; properties: pointer; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreatePipe';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreatePipe(context: cl_context; flags: clMemFlags; pipe_packet_size: UInt32; pipe_max_packets: UInt32; properties: pointer; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreatePipe_1(context, flags, pipe_packet_size, pipe_max_packets, properties, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateProgramWithBinary_1(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; var lengths: UIntPtr; var binaries: IntPtr; var binary_status: clErrorCode; var errcode_ret: clErrorCode): cl_program;
      external 'OpenCL' name 'clCreateProgramWithBinary';
    private static function ntv_CreateProgramWithBinary_2(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; var lengths: UIntPtr; binaries: pointer; var binary_status: clErrorCode; var errcode_ret: clErrorCode): cl_program;
      external 'OpenCL' name 'clCreateProgramWithBinary';
    private static function ntv_CreateProgramWithBinary_3(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; var lengths: UIntPtr; var binaries: IntPtr; var binary_status: clErrorCode; errcode_ret: IntPtr): cl_program;
      external 'OpenCL' name 'clCreateProgramWithBinary';
    private static function ntv_CreateProgramWithBinary_4(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; var lengths: UIntPtr; binaries: pointer; var binary_status: clErrorCode; errcode_ret: IntPtr): cl_program;
      external 'OpenCL' name 'clCreateProgramWithBinary';
    private static function ntv_CreateProgramWithBinary_5(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; var lengths: UIntPtr; var binaries: IntPtr; binary_status: IntPtr; var errcode_ret: clErrorCode): cl_program;
      external 'OpenCL' name 'clCreateProgramWithBinary';
    private static function ntv_CreateProgramWithBinary_6(context: cl_context; num_devices: UInt32; device_list: IntPtr; lengths: IntPtr; binaries: pointer; var binary_status: clErrorCode; var errcode_ret: clErrorCode): cl_program;
      external 'OpenCL' name 'clCreateProgramWithBinary';
    private static function ntv_CreateProgramWithBinary_7(context: cl_context; num_devices: UInt32; device_list: IntPtr; lengths: IntPtr; binaries: pointer; var binary_status: clErrorCode; errcode_ret: IntPtr): cl_program;
      external 'OpenCL' name 'clCreateProgramWithBinary';
    private static function ntv_CreateProgramWithBinary_8(context: cl_context; num_devices: UInt32; device_list: IntPtr; lengths: IntPtr; binaries: pointer; binary_status: IntPtr; var errcode_ret: clErrorCode): cl_program;
      external 'OpenCL' name 'clCreateProgramWithBinary';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBinary(context: cl_context; num_devices: UInt32; device_list: array of cl_device_id; lengths: array of UIntPtr; binaries: array of array of Byte; binary_status: array of clErrorCode; var errcode_ret: clErrorCode): cl_program;
      type PCl_device_id = ^cl_device_id;
      type PUIntPtr = ^UIntPtr;
      type PClErrorCode = ^clErrorCode;
    begin
      if (binaries=nil) or (binaries.Length=0) then
      begin
        Result := if (device_list<>nil) and (device_list.Length<>0) then
          if (lengths<>nil) and (lengths.Length<>0) then
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_2(context, num_devices, device_list[0], lengths[0], nil, binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_2(context, num_devices, device_list[0], lengths[0], nil, PClErrorCode(nil)^, errcode_ret) else
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_2(context, num_devices, device_list[0], PUIntPtr(nil)^, nil, binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_2(context, num_devices, device_list[0], PUIntPtr(nil)^, nil, PClErrorCode(nil)^, errcode_ret) else
          if (lengths<>nil) and (lengths.Length<>0) then
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_2(context, num_devices, PCl_device_id(nil)^, lengths[0], nil, binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_2(context, num_devices, PCl_device_id(nil)^, lengths[0], nil, PClErrorCode(nil)^, errcode_ret) else
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_2(context, num_devices, PCl_device_id(nil)^, PUIntPtr(nil)^, nil, binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_2(context, num_devices, PCl_device_id(nil)^, PUIntPtr(nil)^, nil, PClErrorCode(nil)^, errcode_ret);
        exit;
      end;
      var binaries_temp_arr: array of IntPtr;
      try
        begin
          var binaries_el_sz := Marshal.SizeOf&<Byte>;
          var binaries_org_el_1 := binaries;
          var binaries_len_1 := binaries_org_el_1.Length;
          SetLength(binaries_temp_arr, binaries_len_1);
          var binaries_tmp_el_1 := binaries_temp_arr;
          for var binaries_ind_1 := 0 to binaries_len_1-1 do
          begin
            var binaries_org_el_2 := binaries_org_el_1[binaries_ind_1];
            if (binaries_org_el_2=nil) or (binaries_org_el_2.Length=0) then continue;
            var binaries_len_2 := binaries_org_el_2.Length;
            var binaries_tmp_el_2_ptr := Marshal.AllocHGlobal(binaries_len_2 * binaries_el_sz);
            binaries_tmp_el_1[binaries_ind_1] := binaries_tmp_el_2_ptr;
            for var binaries_ind_2 := 0 to binaries_len_2-1 do
            begin
              var binaries_tmp_el_2_ptr_typed: ^Byte := binaries_tmp_el_2_ptr.ToPointer;
              binaries_tmp_el_2_ptr_typed^ := binaries_org_el_2[binaries_ind_2];
              binaries_tmp_el_2_ptr := binaries_tmp_el_2_ptr + binaries_el_sz;
            end;
          end;
        end;
        Result := if (device_list<>nil) and (device_list.Length<>0) then
          if (lengths<>nil) and (lengths.Length<>0) then
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_1(context, num_devices, device_list[0], lengths[0], binaries_temp_arr[0], binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_1(context, num_devices, device_list[0], lengths[0], binaries_temp_arr[0], PClErrorCode(nil)^, errcode_ret) else
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_1(context, num_devices, device_list[0], PUIntPtr(nil)^, binaries_temp_arr[0], binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_1(context, num_devices, device_list[0], PUIntPtr(nil)^, binaries_temp_arr[0], PClErrorCode(nil)^, errcode_ret) else
          if (lengths<>nil) and (lengths.Length<>0) then
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_1(context, num_devices, PCl_device_id(nil)^, lengths[0], binaries_temp_arr[0], binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_1(context, num_devices, PCl_device_id(nil)^, lengths[0], binaries_temp_arr[0], PClErrorCode(nil)^, errcode_ret) else
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_1(context, num_devices, PCl_device_id(nil)^, PUIntPtr(nil)^, binaries_temp_arr[0], binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_1(context, num_devices, PCl_device_id(nil)^, PUIntPtr(nil)^, binaries_temp_arr[0], PClErrorCode(nil)^, errcode_ret);
      finally
         foreach var arr_el1 in binaries_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBinary(context: cl_context; num_devices: UInt32; device_list: array of cl_device_id; lengths: array of UIntPtr; binaries: array of array of Byte; binary_status: array of clErrorCode; errcode_ret: IntPtr): cl_program;
      type PCl_device_id = ^cl_device_id;
      type PUIntPtr = ^UIntPtr;
      type PClErrorCode = ^clErrorCode;
    begin
      if (binaries=nil) or (binaries.Length=0) then
      begin
        Result := if (device_list<>nil) and (device_list.Length<>0) then
          if (lengths<>nil) and (lengths.Length<>0) then
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_4(context, num_devices, device_list[0], lengths[0], nil, binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_4(context, num_devices, device_list[0], lengths[0], nil, PClErrorCode(nil)^, errcode_ret) else
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_4(context, num_devices, device_list[0], PUIntPtr(nil)^, nil, binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_4(context, num_devices, device_list[0], PUIntPtr(nil)^, nil, PClErrorCode(nil)^, errcode_ret) else
          if (lengths<>nil) and (lengths.Length<>0) then
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_4(context, num_devices, PCl_device_id(nil)^, lengths[0], nil, binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_4(context, num_devices, PCl_device_id(nil)^, lengths[0], nil, PClErrorCode(nil)^, errcode_ret) else
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_4(context, num_devices, PCl_device_id(nil)^, PUIntPtr(nil)^, nil, binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_4(context, num_devices, PCl_device_id(nil)^, PUIntPtr(nil)^, nil, PClErrorCode(nil)^, errcode_ret);
        exit;
      end;
      var binaries_temp_arr: array of IntPtr;
      try
        begin
          var binaries_el_sz := Marshal.SizeOf&<Byte>;
          var binaries_org_el_1 := binaries;
          var binaries_len_1 := binaries_org_el_1.Length;
          SetLength(binaries_temp_arr, binaries_len_1);
          var binaries_tmp_el_1 := binaries_temp_arr;
          for var binaries_ind_1 := 0 to binaries_len_1-1 do
          begin
            var binaries_org_el_2 := binaries_org_el_1[binaries_ind_1];
            if (binaries_org_el_2=nil) or (binaries_org_el_2.Length=0) then continue;
            var binaries_len_2 := binaries_org_el_2.Length;
            var binaries_tmp_el_2_ptr := Marshal.AllocHGlobal(binaries_len_2 * binaries_el_sz);
            binaries_tmp_el_1[binaries_ind_1] := binaries_tmp_el_2_ptr;
            for var binaries_ind_2 := 0 to binaries_len_2-1 do
            begin
              var binaries_tmp_el_2_ptr_typed: ^Byte := binaries_tmp_el_2_ptr.ToPointer;
              binaries_tmp_el_2_ptr_typed^ := binaries_org_el_2[binaries_ind_2];
              binaries_tmp_el_2_ptr := binaries_tmp_el_2_ptr + binaries_el_sz;
            end;
          end;
        end;
        Result := if (device_list<>nil) and (device_list.Length<>0) then
          if (lengths<>nil) and (lengths.Length<>0) then
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_3(context, num_devices, device_list[0], lengths[0], binaries_temp_arr[0], binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_3(context, num_devices, device_list[0], lengths[0], binaries_temp_arr[0], PClErrorCode(nil)^, errcode_ret) else
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_3(context, num_devices, device_list[0], PUIntPtr(nil)^, binaries_temp_arr[0], binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_3(context, num_devices, device_list[0], PUIntPtr(nil)^, binaries_temp_arr[0], PClErrorCode(nil)^, errcode_ret) else
          if (lengths<>nil) and (lengths.Length<>0) then
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_3(context, num_devices, PCl_device_id(nil)^, lengths[0], binaries_temp_arr[0], binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_3(context, num_devices, PCl_device_id(nil)^, lengths[0], binaries_temp_arr[0], PClErrorCode(nil)^, errcode_ret) else
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_3(context, num_devices, PCl_device_id(nil)^, PUIntPtr(nil)^, binaries_temp_arr[0], binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_3(context, num_devices, PCl_device_id(nil)^, PUIntPtr(nil)^, binaries_temp_arr[0], PClErrorCode(nil)^, errcode_ret);
      finally
         foreach var arr_el1 in binaries_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBinary(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; var lengths: UIntPtr; var binaries: IntPtr; var binary_status: clErrorCode; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithBinary_1(context, num_devices, device_list, lengths, binaries, binary_status, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBinary(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; var lengths: UIntPtr; var binaries: IntPtr; var binary_status: clErrorCode; errcode_ret: IntPtr): cl_program :=
      ntv_CreateProgramWithBinary_3(context, num_devices, device_list, lengths, binaries, binary_status, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBinary(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; var lengths: UIntPtr; var binaries: IntPtr; binary_status: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithBinary_5(context, num_devices, device_list, lengths, binaries, binary_status, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBinary(context: cl_context; num_devices: UInt32; device_list: IntPtr; lengths: IntPtr; binaries: pointer; var binary_status: clErrorCode; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithBinary_6(context, num_devices, device_list, lengths, binaries, binary_status, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBinary(context: cl_context; num_devices: UInt32; device_list: IntPtr; lengths: IntPtr; binaries: pointer; var binary_status: clErrorCode; errcode_ret: IntPtr): cl_program :=
      ntv_CreateProgramWithBinary_7(context, num_devices, device_list, lengths, binaries, binary_status, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBinary(context: cl_context; num_devices: UInt32; device_list: IntPtr; lengths: IntPtr; binaries: pointer; binary_status: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithBinary_8(context, num_devices, device_list, lengths, binaries, binary_status, errcode_ret);
    
    // added in cl1.2
    private static function ntv_CreateProgramWithBuiltInKernels_1(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; kernel_names: IntPtr; var errcode_ret: clErrorCode): cl_program;
      external 'OpenCL' name 'clCreateProgramWithBuiltInKernels';
    private static function ntv_CreateProgramWithBuiltInKernels_2(context: cl_context; num_devices: UInt32; device_list: IntPtr; kernel_names: IntPtr; var errcode_ret: clErrorCode): cl_program;
      external 'OpenCL' name 'clCreateProgramWithBuiltInKernels';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBuiltInKernels(context: cl_context; num_devices: UInt32; device_list: array of cl_device_id; kernel_names: string; var errcode_ret: clErrorCode): cl_program;
    begin
      var kernel_names_str_ptr := Marshal.StringToHGlobalAnsi(kernel_names);
      try
        Result := CreateProgramWithBuiltInKernels(context, num_devices, device_list, kernel_names_str_ptr, errcode_ret);
      finally
        Marshal.FreeHGlobal(kernel_names_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBuiltInKernels(context: cl_context; num_devices: UInt32; device_list: array of cl_device_id; kernel_names: IntPtr; var errcode_ret: clErrorCode): cl_program;
      type PCl_device_id = ^cl_device_id;
    begin
      Result := if (device_list<>nil) and (device_list.Length<>0) then
        ntv_CreateProgramWithBuiltInKernels_1(context, num_devices, device_list[0], kernel_names, errcode_ret) else
        ntv_CreateProgramWithBuiltInKernels_1(context, num_devices, PCl_device_id(nil)^, kernel_names, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBuiltInKernels(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; kernel_names: string; var errcode_ret: clErrorCode): cl_program;
    begin
      var kernel_names_str_ptr := Marshal.StringToHGlobalAnsi(kernel_names);
      try
        Result := ntv_CreateProgramWithBuiltInKernels_1(context, num_devices, device_list, kernel_names_str_ptr, errcode_ret);
      finally
        Marshal.FreeHGlobal(kernel_names_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBuiltInKernels(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; kernel_names: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithBuiltInKernels_1(context, num_devices, device_list, kernel_names, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBuiltInKernels(context: cl_context; num_devices: UInt32; device_list: IntPtr; kernel_names: string; var errcode_ret: clErrorCode): cl_program;
    begin
      var kernel_names_str_ptr := Marshal.StringToHGlobalAnsi(kernel_names);
      try
        Result := ntv_CreateProgramWithBuiltInKernels_2(context, num_devices, device_list, kernel_names_str_ptr, errcode_ret);
      finally
        Marshal.FreeHGlobal(kernel_names_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBuiltInKernels(context: cl_context; num_devices: UInt32; device_list: IntPtr; kernel_names: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithBuiltInKernels_2(context, num_devices, device_list, kernel_names, errcode_ret);
    
    // added in cl2.1
    private static function ntv_CreateProgramWithIL_1(context: cl_context; var il: Byte; length: UIntPtr; var errcode_ret: clErrorCode): cl_program;
      external 'OpenCL' name 'clCreateProgramWithIL';
    private static function ntv_CreateProgramWithIL_2(context: cl_context; il: IntPtr; length: UIntPtr; var errcode_ret: clErrorCode): cl_program;
      external 'OpenCL' name 'clCreateProgramWithIL';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithIL(context: cl_context; il: array of Byte; length: UIntPtr; var errcode_ret: clErrorCode): cl_program;
      type PByte = ^Byte;
    begin
      Result := if (il<>nil) and (il.Length<>0) then
        ntv_CreateProgramWithIL_1(context, il[0], length, errcode_ret) else
        ntv_CreateProgramWithIL_1(context, PByte(nil)^, length, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithIL(context: cl_context; var il: Byte; length: UIntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithIL_1(context, il, length, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithIL(context: cl_context; il: IntPtr; length: UIntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithIL_2(context, il, length, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateProgramWithSource_1(context: cl_context; count: UInt32; var strings: IntPtr; var lengths: UIntPtr; var errcode_ret: clErrorCode): cl_program;
      external 'OpenCL' name 'clCreateProgramWithSource';
    private static function ntv_CreateProgramWithSource_2(context: cl_context; count: UInt32; strings: pointer; var lengths: UIntPtr; var errcode_ret: clErrorCode): cl_program;
      external 'OpenCL' name 'clCreateProgramWithSource';
    private static function ntv_CreateProgramWithSource_3(context: cl_context; count: UInt32; var strings: IntPtr; lengths: IntPtr; var errcode_ret: clErrorCode): cl_program;
      external 'OpenCL' name 'clCreateProgramWithSource';
    private static function ntv_CreateProgramWithSource_4(context: cl_context; count: UInt32; strings: pointer; lengths: IntPtr; var errcode_ret: clErrorCode): cl_program;
      external 'OpenCL' name 'clCreateProgramWithSource';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithSource(context: cl_context; count: UInt32; strings: array of string; lengths: array of UIntPtr; var errcode_ret: clErrorCode): cl_program;
      type PUIntPtr = ^UIntPtr;
    begin
      if (strings=nil) or (strings.Length=0) then
      begin
        Result := if (lengths<>nil) and (lengths.Length<>0) then
          ntv_CreateProgramWithSource_2(context, count, nil, lengths[0], errcode_ret) else
          ntv_CreateProgramWithSource_2(context, count, nil, PUIntPtr(nil)^, errcode_ret);
        exit;
      end;
      var strings_temp_arr: array of IntPtr;
      try
        begin
          var strings_org_el_1 := strings;
          var strings_len_1 := strings_org_el_1.Length;
          SetLength(strings_temp_arr, strings_len_1);
          var strings_tmp_el_1 := strings_temp_arr;
          for var strings_ind_1 := 0 to strings_len_1-1 do
          begin
            var strings_org_el_2 := strings_org_el_1[strings_ind_1];
            if (strings_org_el_2=nil) or (strings_org_el_2.Length=0) then continue;
            strings_tmp_el_1[strings_ind_1] := Marshal.StringToHGlobalAnsi(strings_org_el_2);
          end;
        end;
        Result := if (lengths<>nil) and (lengths.Length<>0) then
          ntv_CreateProgramWithSource_1(context, count, strings_temp_arr[0], lengths[0], errcode_ret) else
          ntv_CreateProgramWithSource_1(context, count, strings_temp_arr[0], PUIntPtr(nil)^, errcode_ret);
      finally
         foreach var arr_el1 in strings_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithSource(context: cl_context; count: UInt32; var strings: IntPtr; var lengths: UIntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithSource_1(context, count, strings, lengths, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithSource(context: cl_context; count: UInt32; var strings: IntPtr; lengths: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithSource_3(context, count, strings, lengths, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithSource(context: cl_context; count: UInt32; strings: pointer; var lengths: UIntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithSource_2(context, count, strings, lengths, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithSource(context: cl_context; count: UInt32; strings: pointer; lengths: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithSource_4(context, count, strings, lengths, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateSampler_1(context: cl_context; normalized_coords: clBool; addressing_mode: clAddressingMode; filter_mode: clFilterMode; var errcode_ret: clErrorCode): cl_sampler;
      external 'OpenCL' name 'clCreateSampler';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSampler(context: cl_context; normalized_coords: clBool; addressing_mode: clAddressingMode; filter_mode: clFilterMode; var errcode_ret: clErrorCode): cl_sampler :=
      ntv_CreateSampler_1(context, normalized_coords, addressing_mode, filter_mode, errcode_ret);
    
    // added in cl2.0
    private static function ntv_CreateSamplerWithProperties_1(context: cl_context; var sampler_properties: clSamplerProperties; var errcode_ret: clErrorCode): cl_sampler;
      external 'OpenCL' name 'clCreateSamplerWithProperties';
    private static function ntv_CreateSamplerWithProperties_2(context: cl_context; sampler_properties: IntPtr; var errcode_ret: clErrorCode): cl_sampler;
      external 'OpenCL' name 'clCreateSamplerWithProperties';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSamplerWithProperties(context: cl_context; sampler_properties: array of clSamplerProperties; var errcode_ret: clErrorCode): cl_sampler;
      type PClSamplerProperties = ^clSamplerProperties;
    begin
      Result := if (sampler_properties<>nil) and (sampler_properties.Length<>0) then
        ntv_CreateSamplerWithProperties_1(context, sampler_properties[0], errcode_ret) else
        ntv_CreateSamplerWithProperties_1(context, PClSamplerProperties(nil)^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSamplerWithProperties(context: cl_context; var sampler_properties: clSamplerProperties; var errcode_ret: clErrorCode): cl_sampler :=
      ntv_CreateSamplerWithProperties_1(context, sampler_properties, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSamplerWithProperties(context: cl_context; sampler_properties: IntPtr; var errcode_ret: clErrorCode): cl_sampler :=
      ntv_CreateSamplerWithProperties_2(context, sampler_properties, errcode_ret);
    
    // added in cl1.1
    private static function ntv_CreateSubBuffer_1(buffer: cl_mem; flags: clMemFlags; buffer_create_type: clBufferCreateType; var buffer_create_info: cl_buffer_region; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateSubBuffer';
    private static function ntv_CreateSubBuffer_2(buffer: cl_mem; flags: clMemFlags; buffer_create_type: clBufferCreateType; buffer_create_info: IntPtr; var errcode_ret: clErrorCode): cl_mem;
      external 'OpenCL' name 'clCreateSubBuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubBuffer(buffer: cl_mem; flags: clMemFlags; buffer_create_type: clBufferCreateType; var buffer_create_info: cl_buffer_region; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateSubBuffer_1(buffer, flags, buffer_create_type, buffer_create_info, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubBuffer(buffer: cl_mem; flags: clMemFlags; buffer_create_type: clBufferCreateType; buffer_create_info: IntPtr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateSubBuffer_2(buffer, flags, buffer_create_type, buffer_create_info, errcode_ret);
    
    // added in cl1.2
    private static function ntv_CreateSubDevices_1(in_device: cl_device_id; var properties: clDevicePartitionProperty; num_devices: UInt32; var out_devices: cl_device_id; var num_devices_ret: UInt32): clErrorCode;
      external 'OpenCL' name 'clCreateSubDevices';
    private static function ntv_CreateSubDevices_2(in_device: cl_device_id; var properties: clDevicePartitionProperty; num_devices: UInt32; var out_devices: cl_device_id; num_devices_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clCreateSubDevices';
    private static function ntv_CreateSubDevices_3(in_device: cl_device_id; var properties: clDevicePartitionProperty; num_devices: UInt32; out_devices: IntPtr; var num_devices_ret: UInt32): clErrorCode;
      external 'OpenCL' name 'clCreateSubDevices';
    private static function ntv_CreateSubDevices_4(in_device: cl_device_id; var properties: clDevicePartitionProperty; num_devices: UInt32; out_devices: IntPtr; num_devices_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clCreateSubDevices';
    private static function ntv_CreateSubDevices_5(in_device: cl_device_id; properties: IntPtr; num_devices: UInt32; var out_devices: cl_device_id; var num_devices_ret: UInt32): clErrorCode;
      external 'OpenCL' name 'clCreateSubDevices';
    private static function ntv_CreateSubDevices_6(in_device: cl_device_id; properties: IntPtr; num_devices: UInt32; var out_devices: cl_device_id; num_devices_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clCreateSubDevices';
    private static function ntv_CreateSubDevices_7(in_device: cl_device_id; properties: IntPtr; num_devices: UInt32; out_devices: IntPtr; var num_devices_ret: UInt32): clErrorCode;
      external 'OpenCL' name 'clCreateSubDevices';
    private static function ntv_CreateSubDevices_8(in_device: cl_device_id; properties: IntPtr; num_devices: UInt32; out_devices: IntPtr; num_devices_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clCreateSubDevices';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; properties: array of clDevicePartitionProperty; num_devices: UInt32; var out_devices: cl_device_id; var num_devices_ret: UInt32): clErrorCode;
      type PClDevicePartitionProperty = ^clDevicePartitionProperty;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_CreateSubDevices_1(in_device, properties[0], num_devices, out_devices, num_devices_ret) else
        ntv_CreateSubDevices_1(in_device, PClDevicePartitionProperty(nil)^, num_devices, out_devices, num_devices_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; properties: array of clDevicePartitionProperty; num_devices: UInt32; var out_devices: cl_device_id; num_devices_ret: IntPtr): clErrorCode;
      type PClDevicePartitionProperty = ^clDevicePartitionProperty;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_CreateSubDevices_2(in_device, properties[0], num_devices, out_devices, num_devices_ret) else
        ntv_CreateSubDevices_2(in_device, PClDevicePartitionProperty(nil)^, num_devices, out_devices, num_devices_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; properties: array of clDevicePartitionProperty; num_devices: UInt32; out_devices: IntPtr; var num_devices_ret: UInt32): clErrorCode;
      type PClDevicePartitionProperty = ^clDevicePartitionProperty;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_CreateSubDevices_3(in_device, properties[0], num_devices, out_devices, num_devices_ret) else
        ntv_CreateSubDevices_3(in_device, PClDevicePartitionProperty(nil)^, num_devices, out_devices, num_devices_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; properties: array of clDevicePartitionProperty; num_devices: UInt32; out_devices: IntPtr; num_devices_ret: IntPtr): clErrorCode;
      type PClDevicePartitionProperty = ^clDevicePartitionProperty;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_CreateSubDevices_4(in_device, properties[0], num_devices, out_devices, num_devices_ret) else
        ntv_CreateSubDevices_4(in_device, PClDevicePartitionProperty(nil)^, num_devices, out_devices, num_devices_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; var properties: clDevicePartitionProperty; num_devices: UInt32; var out_devices: cl_device_id; var num_devices_ret: UInt32): clErrorCode :=
      ntv_CreateSubDevices_1(in_device, properties, num_devices, out_devices, num_devices_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; var properties: clDevicePartitionProperty; num_devices: UInt32; var out_devices: cl_device_id; num_devices_ret: IntPtr): clErrorCode :=
      ntv_CreateSubDevices_2(in_device, properties, num_devices, out_devices, num_devices_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; var properties: clDevicePartitionProperty; num_devices: UInt32; out_devices: IntPtr; var num_devices_ret: UInt32): clErrorCode :=
      ntv_CreateSubDevices_3(in_device, properties, num_devices, out_devices, num_devices_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; var properties: clDevicePartitionProperty; num_devices: UInt32; out_devices: IntPtr; num_devices_ret: IntPtr): clErrorCode :=
      ntv_CreateSubDevices_4(in_device, properties, num_devices, out_devices, num_devices_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; properties: IntPtr; num_devices: UInt32; var out_devices: cl_device_id; var num_devices_ret: UInt32): clErrorCode :=
      ntv_CreateSubDevices_5(in_device, properties, num_devices, out_devices, num_devices_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; properties: IntPtr; num_devices: UInt32; var out_devices: cl_device_id; num_devices_ret: IntPtr): clErrorCode :=
      ntv_CreateSubDevices_6(in_device, properties, num_devices, out_devices, num_devices_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; properties: IntPtr; num_devices: UInt32; out_devices: IntPtr; var num_devices_ret: UInt32): clErrorCode :=
      ntv_CreateSubDevices_7(in_device, properties, num_devices, out_devices, num_devices_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; properties: IntPtr; num_devices: UInt32; out_devices: IntPtr; num_devices_ret: IntPtr): clErrorCode :=
      ntv_CreateSubDevices_8(in_device, properties, num_devices, out_devices, num_devices_ret);
    
    // added in cl1.1
    private static function ntv_CreateUserEvent_1(context: cl_context; var errcode_ret: clErrorCode): cl_event;
      external 'OpenCL' name 'clCreateUserEvent';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateUserEvent(context: cl_context; var errcode_ret: clErrorCode): cl_event :=
      ntv_CreateUserEvent_1(context, errcode_ret);
    
    // added in cl1.0
    private static function ntv_EnqueueBarrier_1(command_queue: cl_command_queue): clErrorCode;
      external 'OpenCL' name 'clEnqueueBarrier';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueBarrier(command_queue: cl_command_queue): clErrorCode :=
      ntv_EnqueueBarrier_1(command_queue);
    
    // added in cl1.2
    private static function ntv_EnqueueBarrierWithWaitList_1(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueBarrierWithWaitList';
    private static function ntv_EnqueueBarrierWithWaitList_2(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueBarrierWithWaitList';
    private static function ntv_EnqueueBarrierWithWaitList_3(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueBarrierWithWaitList';
    private static function ntv_EnqueueBarrierWithWaitList_4(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueBarrierWithWaitList';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueBarrierWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueBarrierWithWaitList_1(command_queue, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueBarrierWithWaitList_1(command_queue, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueBarrierWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueBarrierWithWaitList_2(command_queue, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueBarrierWithWaitList_2(command_queue, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueBarrierWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueBarrierWithWaitList_1(command_queue, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueBarrierWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueBarrierWithWaitList_2(command_queue, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueBarrierWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueBarrierWithWaitList_3(command_queue, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueBarrierWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueBarrierWithWaitList_4(command_queue, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueCopyBuffer_1(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyBuffer';
    private static function ntv_EnqueueCopyBuffer_2(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyBuffer';
    private static function ntv_EnqueueCopyBuffer_3(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyBuffer';
    private static function ntv_EnqueueCopyBuffer_4(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyBuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBuffer(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyBuffer_1(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyBuffer_1(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBuffer(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyBuffer_2(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyBuffer_2(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBuffer(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyBuffer_1(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBuffer(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyBuffer_2(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBuffer(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyBuffer_3(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBuffer(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyBuffer_4(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.1
    private static function ntv_EnqueueCopyBufferRect_1(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyBufferRect';
    private static function ntv_EnqueueCopyBufferRect_2(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyBufferRect';
    private static function ntv_EnqueueCopyBufferRect_3(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyBufferRect';
    private static function ntv_EnqueueCopyBufferRect_4(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyBufferRect';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCopyBufferRect(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCopyBufferRect(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCopyBufferRect(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCopyBufferRect(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, src_origin[0], dst_origin[0], region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, dst_origin[0], region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, src_origin[0], PUIntPtr(nil)^, region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, src_origin[0], dst_origin[0], PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, dst_origin[0], PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, src_origin[0], PUIntPtr(nil)^, PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, src_origin[0], dst_origin[0], region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, dst_origin[0], region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, src_origin[0], PUIntPtr(nil)^, region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, src_origin[0], dst_origin[0], PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, dst_origin[0], PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, src_origin[0], PUIntPtr(nil)^, PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, src_origin[0], dst_origin[0], region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, dst_origin[0], region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, src_origin[0], PUIntPtr(nil)^, region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, src_origin[0], dst_origin[0], PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, dst_origin[0], PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, src_origin[0], PUIntPtr(nil)^, PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, src_origin[0], dst_origin[0], region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, dst_origin[0], region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, src_origin[0], PUIntPtr(nil)^, region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, src_origin[0], dst_origin[0], PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, dst_origin[0], PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, src_origin[0], PUIntPtr(nil)^, PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueCopyBufferToImage_1(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyBufferToImage';
    private static function ntv_EnqueueCopyBufferToImage_2(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyBufferToImage';
    private static function ntv_EnqueueCopyBufferToImage_3(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyBufferToImage';
    private static function ntv_EnqueueCopyBufferToImage_4(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyBufferToImage';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCopyBufferToImage(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCopyBufferToImage(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCopyBufferToImage(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCopyBufferToImage(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          ntv_EnqueueCopyBufferToImage_1(command_queue, src_buffer, dst_image, src_offset, dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyBufferToImage_1(command_queue, src_buffer, dst_image, src_offset, PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          ntv_EnqueueCopyBufferToImage_1(command_queue, src_buffer, dst_image, src_offset, dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyBufferToImage_1(command_queue, src_buffer, dst_image, src_offset, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          ntv_EnqueueCopyBufferToImage_2(command_queue, src_buffer, dst_image, src_offset, dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyBufferToImage_2(command_queue, src_buffer, dst_image, src_offset, PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          ntv_EnqueueCopyBufferToImage_2(command_queue, src_buffer, dst_image, src_offset, dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyBufferToImage_2(command_queue, src_buffer, dst_image, src_offset, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          ntv_EnqueueCopyBufferToImage_3(command_queue, src_buffer, dst_image, src_offset, dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyBufferToImage_3(command_queue, src_buffer, dst_image, src_offset, PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          ntv_EnqueueCopyBufferToImage_3(command_queue, src_buffer, dst_image, src_offset, dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyBufferToImage_3(command_queue, src_buffer, dst_image, src_offset, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          ntv_EnqueueCopyBufferToImage_4(command_queue, src_buffer, dst_image, src_offset, dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyBufferToImage_4(command_queue, src_buffer, dst_image, src_offset, PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          ntv_EnqueueCopyBufferToImage_4(command_queue, src_buffer, dst_image, src_offset, dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyBufferToImage_4(command_queue, src_buffer, dst_image, src_offset, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyBufferToImage_1(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyBufferToImage_1(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyBufferToImage_2(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyBufferToImage_2(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyBufferToImage_1(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyBufferToImage_2(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyBufferToImage_3(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyBufferToImage_4(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueCopyImage_1(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyImage';
    private static function ntv_EnqueueCopyImage_2(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyImage';
    private static function ntv_EnqueueCopyImage_3(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyImage';
    private static function ntv_EnqueueCopyImage_4(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyImage';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCopyImage(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCopyImage(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCopyImage(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCopyImage(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (dst_origin<>nil) and (dst_origin.Length<>0) then
        if (src_origin<>nil) and (src_origin.Length<>0) then
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, src_origin[0], dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, src_origin[0], dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, PUIntPtr(nil)^, dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, PUIntPtr(nil)^, dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
        if (src_origin<>nil) and (src_origin.Length<>0) then
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, src_origin[0], PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, src_origin[0], PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, PUIntPtr(nil)^, PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (dst_origin<>nil) and (dst_origin.Length<>0) then
        if (src_origin<>nil) and (src_origin.Length<>0) then
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, src_origin[0], dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, src_origin[0], dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, PUIntPtr(nil)^, dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, PUIntPtr(nil)^, dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
        if (src_origin<>nil) and (src_origin.Length<>0) then
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, src_origin[0], PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, src_origin[0], PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, PUIntPtr(nil)^, PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (dst_origin<>nil) and (dst_origin.Length<>0) then
        if (src_origin<>nil) and (src_origin.Length<>0) then
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, src_origin[0], dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, src_origin[0], dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, PUIntPtr(nil)^, dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, PUIntPtr(nil)^, dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
        if (src_origin<>nil) and (src_origin.Length<>0) then
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, src_origin[0], PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, src_origin[0], PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, PUIntPtr(nil)^, PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (dst_origin<>nil) and (dst_origin.Length<>0) then
        if (src_origin<>nil) and (src_origin.Length<>0) then
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, src_origin[0], dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, src_origin[0], dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, PUIntPtr(nil)^, dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, PUIntPtr(nil)^, dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
        if (src_origin<>nil) and (src_origin.Length<>0) then
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, src_origin[0], PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, src_origin[0], PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, PUIntPtr(nil)^, PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueCopyImageToBuffer_1(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyImageToBuffer';
    private static function ntv_EnqueueCopyImageToBuffer_2(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyImageToBuffer';
    private static function ntv_EnqueueCopyImageToBuffer_3(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyImageToBuffer';
    private static function ntv_EnqueueCopyImageToBuffer_4(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueCopyImageToBuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; region: array of UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCopyImageToBuffer(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCopyImageToBuffer(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; region: array of UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCopyImageToBuffer(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCopyImageToBuffer(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; region: array of UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (src_origin<>nil) and (src_origin.Length<>0) then
          ntv_EnqueueCopyImageToBuffer_1(command_queue, src_image, dst_buffer, src_origin[0], region[0], dst_offset, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyImageToBuffer_1(command_queue, src_image, dst_buffer, PUIntPtr(nil)^, region[0], dst_offset, num_events_in_wait_list, event_wait_list, &event) else
        if (src_origin<>nil) and (src_origin.Length<>0) then
          ntv_EnqueueCopyImageToBuffer_1(command_queue, src_image, dst_buffer, src_origin[0], PUIntPtr(nil)^, dst_offset, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyImageToBuffer_1(command_queue, src_image, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, dst_offset, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; region: array of UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (src_origin<>nil) and (src_origin.Length<>0) then
          ntv_EnqueueCopyImageToBuffer_2(command_queue, src_image, dst_buffer, src_origin[0], region[0], dst_offset, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyImageToBuffer_2(command_queue, src_image, dst_buffer, PUIntPtr(nil)^, region[0], dst_offset, num_events_in_wait_list, event_wait_list, &event) else
        if (src_origin<>nil) and (src_origin.Length<>0) then
          ntv_EnqueueCopyImageToBuffer_2(command_queue, src_image, dst_buffer, src_origin[0], PUIntPtr(nil)^, dst_offset, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyImageToBuffer_2(command_queue, src_image, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, dst_offset, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; region: array of UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (src_origin<>nil) and (src_origin.Length<>0) then
          ntv_EnqueueCopyImageToBuffer_3(command_queue, src_image, dst_buffer, src_origin[0], region[0], dst_offset, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyImageToBuffer_3(command_queue, src_image, dst_buffer, PUIntPtr(nil)^, region[0], dst_offset, num_events_in_wait_list, event_wait_list, &event) else
        if (src_origin<>nil) and (src_origin.Length<>0) then
          ntv_EnqueueCopyImageToBuffer_3(command_queue, src_image, dst_buffer, src_origin[0], PUIntPtr(nil)^, dst_offset, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyImageToBuffer_3(command_queue, src_image, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, dst_offset, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; region: array of UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (src_origin<>nil) and (src_origin.Length<>0) then
          ntv_EnqueueCopyImageToBuffer_4(command_queue, src_image, dst_buffer, src_origin[0], region[0], dst_offset, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyImageToBuffer_4(command_queue, src_image, dst_buffer, PUIntPtr(nil)^, region[0], dst_offset, num_events_in_wait_list, event_wait_list, &event) else
        if (src_origin<>nil) and (src_origin.Length<>0) then
          ntv_EnqueueCopyImageToBuffer_4(command_queue, src_image, dst_buffer, src_origin[0], PUIntPtr(nil)^, dst_offset, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyImageToBuffer_4(command_queue, src_image, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, dst_offset, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyImageToBuffer_1(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyImageToBuffer_1(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyImageToBuffer_2(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyImageToBuffer_2(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyImageToBuffer_1(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyImageToBuffer_2(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyImageToBuffer_3(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyImageToBuffer_4(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.2
    private static function ntv_EnqueueFillBuffer_1(command_queue: cl_command_queue; buffer: cl_mem; var pattern: Byte; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueFillBuffer';
    private static function ntv_EnqueueFillBuffer_2(command_queue: cl_command_queue; buffer: cl_mem; var pattern: Byte; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueFillBuffer';
    private static function ntv_EnqueueFillBuffer_3(command_queue: cl_command_queue; buffer: cl_mem; var pattern: Byte; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueFillBuffer';
    private static function ntv_EnqueueFillBuffer_4(command_queue: cl_command_queue; buffer: cl_mem; var pattern: Byte; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueFillBuffer';
    private static function ntv_EnqueueFillBuffer_5(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueFillBuffer';
    private static function ntv_EnqueueFillBuffer_6(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueFillBuffer';
    private static function ntv_EnqueueFillBuffer_7(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueFillBuffer';
    private static function ntv_EnqueueFillBuffer_8(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueFillBuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; pattern: array of T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; pattern: array of T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; pattern: array of T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
      type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueFillBuffer(command_queue, buffer, pattern[0], pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueFillBuffer(command_queue, buffer, PT(nil)^, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; pattern: array of T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
      type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueFillBuffer(command_queue, buffer, pattern[0], pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueFillBuffer(command_queue, buffer, PT(nil)^, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; pattern: array of T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
      type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueFillBuffer(command_queue, buffer, pattern[0], pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueFillBuffer(command_queue, buffer, PT(nil)^, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; pattern: array of T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
      type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueFillBuffer(command_queue, buffer, pattern[0], pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueFillBuffer(command_queue, buffer, PT(nil)^, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; var pattern: T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; var pattern: T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; var pattern: T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueFillBuffer_1(command_queue, buffer, PByte(pointer(@pattern))^, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; var pattern: T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueFillBuffer_2(command_queue, buffer, PByte(pointer(@pattern))^, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; var pattern: T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueFillBuffer_3(command_queue, buffer, PByte(pointer(@pattern))^, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; var pattern: T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueFillBuffer_4(command_queue, buffer, PByte(pointer(@pattern))^, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueFillBuffer_5(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueFillBuffer_5(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueFillBuffer_6(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueFillBuffer_6(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueFillBuffer_5(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueFillBuffer_6(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueFillBuffer_7(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueFillBuffer_8(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.2
    private static function ntv_EnqueueFillImage_1(command_queue: cl_command_queue; image: cl_mem; var fill_color: Byte; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueFillImage';
    private static function ntv_EnqueueFillImage_2(command_queue: cl_command_queue; image: cl_mem; var fill_color: Byte; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueFillImage';
    private static function ntv_EnqueueFillImage_3(command_queue: cl_command_queue; image: cl_mem; var fill_color: Byte; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueFillImage';
    private static function ntv_EnqueueFillImage_4(command_queue: cl_command_queue; image: cl_mem; var fill_color: Byte; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueFillImage';
    private static function ntv_EnqueueFillImage_5(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueFillImage';
    private static function ntv_EnqueueFillImage_6(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueFillImage';
    private static function ntv_EnqueueFillImage_7(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueFillImage';
    private static function ntv_EnqueueFillImage_8(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueFillImage';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage<T>(command_queue: cl_command_queue; image: cl_mem; var fill_color: T; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueFillImage(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueFillImage(command_queue, image, fill_color, origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage<T>(command_queue: cl_command_queue; image: cl_mem; var fill_color: T; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueFillImage(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueFillImage(command_queue, image, fill_color, origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage<T>(command_queue: cl_command_queue; image: cl_mem; var fill_color: T; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueFillImage_1(command_queue, image, PByte(pointer(@fill_color))^, origin, region, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage<T>(command_queue: cl_command_queue; image: cl_mem; var fill_color: T; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueFillImage_2(command_queue, image, PByte(pointer(@fill_color))^, origin, region, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage<T>(command_queue: cl_command_queue; image: cl_mem; var fill_color: T; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueFillImage_3(command_queue, image, PByte(pointer(@fill_color))^, origin, region, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage<T>(command_queue: cl_command_queue; image: cl_mem; var fill_color: T; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueFillImage_4(command_queue, image, PByte(pointer(@fill_color))^, origin, region, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueFillImage_5(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueFillImage_5(command_queue, image, fill_color, origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueFillImage_6(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueFillImage_6(command_queue, image, fill_color, origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueFillImage_5(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueFillImage_6(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueFillImage_7(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueFillImage_8(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueMapBuffer_1(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
      external 'OpenCL' name 'clEnqueueMapBuffer';
    private static function ntv_EnqueueMapBuffer_2(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
      external 'OpenCL' name 'clEnqueueMapBuffer';
    private static function ntv_EnqueueMapBuffer_3(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
      external 'OpenCL' name 'clEnqueueMapBuffer';
    private static function ntv_EnqueueMapBuffer_4(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
      external 'OpenCL' name 'clEnqueueMapBuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMapBuffer_1(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, event_wait_list[0], &event, errcode_ret) else
        ntv_EnqueueMapBuffer_1(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, PCl_event(nil)^, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMapBuffer_2(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, event_wait_list[0], &event, errcode_ret) else
        ntv_EnqueueMapBuffer_2(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, PCl_event(nil)^, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapBuffer_1(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapBuffer_2(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapBuffer_3(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapBuffer_4(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    
    // added in cl1.0
    private static function ntv_EnqueueMapImage_1(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
      external 'OpenCL' name 'clEnqueueMapImage';
    private static function ntv_EnqueueMapImage_2(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
      external 'OpenCL' name 'clEnqueueMapImage';
    private static function ntv_EnqueueMapImage_3(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
      external 'OpenCL' name 'clEnqueueMapImage';
    private static function ntv_EnqueueMapImage_4(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
      external 'OpenCL' name 'clEnqueueMapImage';
    private static function ntv_EnqueueMapImage_5(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
      external 'OpenCL' name 'clEnqueueMapImage';
    private static function ntv_EnqueueMapImage_6(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
      external 'OpenCL' name 'clEnqueueMapImage';
    private static function ntv_EnqueueMapImage_7(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
      external 'OpenCL' name 'clEnqueueMapImage';
    private static function ntv_EnqueueMapImage_8(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
      external 'OpenCL' name 'clEnqueueMapImage';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: array of UIntPtr; region: array of UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueMapImage(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event, errcode_ret) else
        EnqueueMapImage(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: array of UIntPtr; region: array of UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueMapImage(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event, errcode_ret) else
        EnqueueMapImage(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: array of UIntPtr; region: array of UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (origin<>nil) and (origin.Length<>0) then
          ntv_EnqueueMapImage_1(command_queue, image, blocking_map, map_flags, origin[0], region[0], image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
          ntv_EnqueueMapImage_1(command_queue, image, blocking_map, map_flags, PUIntPtr(nil)^, region[0], image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
        if (origin<>nil) and (origin.Length<>0) then
          ntv_EnqueueMapImage_1(command_queue, image, blocking_map, map_flags, origin[0], PUIntPtr(nil)^, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
          ntv_EnqueueMapImage_1(command_queue, image, blocking_map, map_flags, PUIntPtr(nil)^, PUIntPtr(nil)^, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: array of UIntPtr; region: array of UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (origin<>nil) and (origin.Length<>0) then
          ntv_EnqueueMapImage_2(command_queue, image, blocking_map, map_flags, origin[0], region[0], image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
          ntv_EnqueueMapImage_2(command_queue, image, blocking_map, map_flags, PUIntPtr(nil)^, region[0], image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
        if (origin<>nil) and (origin.Length<>0) then
          ntv_EnqueueMapImage_2(command_queue, image, blocking_map, map_flags, origin[0], PUIntPtr(nil)^, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
          ntv_EnqueueMapImage_2(command_queue, image, blocking_map, map_flags, PUIntPtr(nil)^, PUIntPtr(nil)^, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: array of UIntPtr; region: array of UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (origin<>nil) and (origin.Length<>0) then
          ntv_EnqueueMapImage_3(command_queue, image, blocking_map, map_flags, origin[0], region[0], image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
          ntv_EnqueueMapImage_3(command_queue, image, blocking_map, map_flags, PUIntPtr(nil)^, region[0], image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
        if (origin<>nil) and (origin.Length<>0) then
          ntv_EnqueueMapImage_3(command_queue, image, blocking_map, map_flags, origin[0], PUIntPtr(nil)^, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
          ntv_EnqueueMapImage_3(command_queue, image, blocking_map, map_flags, PUIntPtr(nil)^, PUIntPtr(nil)^, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: array of UIntPtr; region: array of UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (origin<>nil) and (origin.Length<>0) then
          ntv_EnqueueMapImage_4(command_queue, image, blocking_map, map_flags, origin[0], region[0], image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
          ntv_EnqueueMapImage_4(command_queue, image, blocking_map, map_flags, PUIntPtr(nil)^, region[0], image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
        if (origin<>nil) and (origin.Length<>0) then
          ntv_EnqueueMapImage_4(command_queue, image, blocking_map, map_flags, origin[0], PUIntPtr(nil)^, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
          ntv_EnqueueMapImage_4(command_queue, image, blocking_map, map_flags, PUIntPtr(nil)^, PUIntPtr(nil)^, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMapImage_1(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event, errcode_ret) else
        ntv_EnqueueMapImage_1(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMapImage_2(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event, errcode_ret) else
        ntv_EnqueueMapImage_2(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapImage_1(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapImage_2(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapImage_3(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapImage_4(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMapImage_5(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event, errcode_ret) else
        ntv_EnqueueMapImage_5(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMapImage_6(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event, errcode_ret) else
        ntv_EnqueueMapImage_6(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapImage_5(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapImage_6(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapImage_7(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapImage_8(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    
    // added in cl1.0
    private static function ntv_EnqueueMarker_1(command_queue: cl_command_queue; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueMarker';
    private static function ntv_EnqueueMarker_2(command_queue: cl_command_queue; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueMarker';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMarker(command_queue: cl_command_queue; &event: array of cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (&event<>nil) and (&event.Length<>0) then
        ntv_EnqueueMarker_1(command_queue, &event[0]) else
        ntv_EnqueueMarker_1(command_queue, PCl_event(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMarker(command_queue: cl_command_queue; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMarker_1(command_queue, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMarker(command_queue: cl_command_queue; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMarker_2(command_queue, &event);
    
    // added in cl1.2
    private static function ntv_EnqueueMarkerWithWaitList_1(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueMarkerWithWaitList';
    private static function ntv_EnqueueMarkerWithWaitList_2(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueMarkerWithWaitList';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMarkerWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMarkerWithWaitList_1(command_queue, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMarkerWithWaitList_1(command_queue, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMarkerWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMarkerWithWaitList_1(command_queue, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMarkerWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMarkerWithWaitList_2(command_queue, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.2
    private static function ntv_EnqueueMigrateMemObjects_1(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueMigrateMemObjects';
    private static function ntv_EnqueueMigrateMemObjects_2(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueMigrateMemObjects';
    private static function ntv_EnqueueMigrateMemObjects_3(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueMigrateMemObjects';
    private static function ntv_EnqueueMigrateMemObjects_4(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueMigrateMemObjects';
    private static function ntv_EnqueueMigrateMemObjects_5(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueMigrateMemObjects';
    private static function ntv_EnqueueMigrateMemObjects_6(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueMigrateMemObjects';
    private static function ntv_EnqueueMigrateMemObjects_7(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueMigrateMemObjects';
    private static function ntv_EnqueueMigrateMemObjects_8(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueMigrateMemObjects';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueMigrateMemObjects(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueMigrateMemObjects(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueMigrateMemObjects(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueMigrateMemObjects(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueMigrateMemObjects_1(command_queue, num_mem_objects, mem_objects[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueMigrateMemObjects_1(command_queue, num_mem_objects, PCl_mem(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueMigrateMemObjects_2(command_queue, num_mem_objects, mem_objects[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueMigrateMemObjects_2(command_queue, num_mem_objects, PCl_mem(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueMigrateMemObjects_3(command_queue, num_mem_objects, mem_objects[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueMigrateMemObjects_3(command_queue, num_mem_objects, PCl_mem(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueMigrateMemObjects_4(command_queue, num_mem_objects, mem_objects[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueMigrateMemObjects_4(command_queue, num_mem_objects, PCl_mem(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMigrateMemObjects_1(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMigrateMemObjects_1(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMigrateMemObjects_2(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMigrateMemObjects_2(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMigrateMemObjects_1(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMigrateMemObjects_2(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMigrateMemObjects_3(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMigrateMemObjects_4(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMigrateMemObjects_5(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMigrateMemObjects_5(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMigrateMemObjects_6(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMigrateMemObjects_6(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMigrateMemObjects_5(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMigrateMemObjects_6(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMigrateMemObjects_7(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMigrateMemObjects_8(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueNativeKernel_1(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueNativeKernel';
    private static function ntv_EnqueueNativeKernel_2(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueNativeKernel';
    private static function ntv_EnqueueNativeKernel_3(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueNativeKernel';
    private static function ntv_EnqueueNativeKernel_4(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueNativeKernel';
    private static function ntv_EnqueueNativeKernel_5(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueNativeKernel';
    private static function ntv_EnqueueNativeKernel_6(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueNativeKernel';
    private static function ntv_EnqueueNativeKernel_7(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueNativeKernel';
    private static function ntv_EnqueueNativeKernel_8(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueNativeKernel';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: array of cl_mem; args_mem_loc: array of IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueNativeKernel(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueNativeKernel(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: array of cl_mem; args_mem_loc: array of IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueNativeKernel(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueNativeKernel(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: array of cl_mem; args_mem_loc: array of IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      type PCl_mem = ^cl_mem;
      type PIntPtr = ^IntPtr;
    begin
      Result := if (args_mem_loc<>nil) and (args_mem_loc.Length<>0) then
        if (mem_list<>nil) and (mem_list.Length<>0) then
          ntv_EnqueueNativeKernel_1(command_queue, user_func, args, cb_args, num_mem_objects, mem_list[0], args_mem_loc[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueNativeKernel_1(command_queue, user_func, args, cb_args, num_mem_objects, PCl_mem(nil)^, args_mem_loc[0], num_events_in_wait_list, event_wait_list, &event) else
        if (mem_list<>nil) and (mem_list.Length<>0) then
          ntv_EnqueueNativeKernel_1(command_queue, user_func, args, cb_args, num_mem_objects, mem_list[0], PIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueNativeKernel_1(command_queue, user_func, args, cb_args, num_mem_objects, PCl_mem(nil)^, PIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: array of cl_mem; args_mem_loc: array of IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      type PCl_mem = ^cl_mem;
      type PIntPtr = ^IntPtr;
    begin
      Result := if (args_mem_loc<>nil) and (args_mem_loc.Length<>0) then
        if (mem_list<>nil) and (mem_list.Length<>0) then
          ntv_EnqueueNativeKernel_2(command_queue, user_func, args, cb_args, num_mem_objects, mem_list[0], args_mem_loc[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueNativeKernel_2(command_queue, user_func, args, cb_args, num_mem_objects, PCl_mem(nil)^, args_mem_loc[0], num_events_in_wait_list, event_wait_list, &event) else
        if (mem_list<>nil) and (mem_list.Length<>0) then
          ntv_EnqueueNativeKernel_2(command_queue, user_func, args, cb_args, num_mem_objects, mem_list[0], PIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueNativeKernel_2(command_queue, user_func, args, cb_args, num_mem_objects, PCl_mem(nil)^, PIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: array of cl_mem; args_mem_loc: array of IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      type PCl_mem = ^cl_mem;
      type PIntPtr = ^IntPtr;
    begin
      Result := if (args_mem_loc<>nil) and (args_mem_loc.Length<>0) then
        if (mem_list<>nil) and (mem_list.Length<>0) then
          ntv_EnqueueNativeKernel_3(command_queue, user_func, args, cb_args, num_mem_objects, mem_list[0], args_mem_loc[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueNativeKernel_3(command_queue, user_func, args, cb_args, num_mem_objects, PCl_mem(nil)^, args_mem_loc[0], num_events_in_wait_list, event_wait_list, &event) else
        if (mem_list<>nil) and (mem_list.Length<>0) then
          ntv_EnqueueNativeKernel_3(command_queue, user_func, args, cb_args, num_mem_objects, mem_list[0], PIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueNativeKernel_3(command_queue, user_func, args, cb_args, num_mem_objects, PCl_mem(nil)^, PIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: array of cl_mem; args_mem_loc: array of IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      type PCl_mem = ^cl_mem;
      type PIntPtr = ^IntPtr;
    begin
      Result := if (args_mem_loc<>nil) and (args_mem_loc.Length<>0) then
        if (mem_list<>nil) and (mem_list.Length<>0) then
          ntv_EnqueueNativeKernel_4(command_queue, user_func, args, cb_args, num_mem_objects, mem_list[0], args_mem_loc[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueNativeKernel_4(command_queue, user_func, args, cb_args, num_mem_objects, PCl_mem(nil)^, args_mem_loc[0], num_events_in_wait_list, event_wait_list, &event) else
        if (mem_list<>nil) and (mem_list.Length<>0) then
          ntv_EnqueueNativeKernel_4(command_queue, user_func, args, cb_args, num_mem_objects, mem_list[0], PIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueNativeKernel_4(command_queue, user_func, args, cb_args, num_mem_objects, PCl_mem(nil)^, PIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNativeKernel_1(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNativeKernel_1(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNativeKernel_2(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNativeKernel_2(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNativeKernel_1(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNativeKernel_2(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNativeKernel_3(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNativeKernel_4(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNativeKernel_5(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNativeKernel_5(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNativeKernel_6(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNativeKernel_6(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNativeKernel_5(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNativeKernel_6(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNativeKernel_7(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNativeKernel_8(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueNDRangeKernel_1(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_2(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_3(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_4(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_5(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_6(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_7(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_8(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_9(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_10(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_11(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_12(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_13(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_14(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_15(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_16(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueNDRangeKernel';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: array of UIntPtr; global_work_size: array of UIntPtr; local_work_size: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueNDRangeKernel(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueNDRangeKernel(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: array of UIntPtr; global_work_size: array of UIntPtr; local_work_size: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueNDRangeKernel(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueNDRangeKernel(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: array of UIntPtr; global_work_size: array of UIntPtr; local_work_size: array of UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (global_work_size<>nil) and (global_work_size.Length<>0) then
        if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
        if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: array of UIntPtr; global_work_size: array of UIntPtr; local_work_size: array of UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (global_work_size<>nil) and (global_work_size.Length<>0) then
        if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
        if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: array of UIntPtr; global_work_size: array of UIntPtr; local_work_size: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (global_work_size<>nil) and (global_work_size.Length<>0) then
        if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
        if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: array of UIntPtr; global_work_size: array of UIntPtr; local_work_size: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (global_work_size<>nil) and (global_work_size.Length<>0) then
        if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
        if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNDRangeKernel_5(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNDRangeKernel_5(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNDRangeKernel_6(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNDRangeKernel_6(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNDRangeKernel_5(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNDRangeKernel_6(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNDRangeKernel_7(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNDRangeKernel_8(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNDRangeKernel_9(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNDRangeKernel_9(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNDRangeKernel_10(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNDRangeKernel_10(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNDRangeKernel_9(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNDRangeKernel_10(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNDRangeKernel_11(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNDRangeKernel_12(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNDRangeKernel_13(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNDRangeKernel_13(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNDRangeKernel_14(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNDRangeKernel_14(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNDRangeKernel_13(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNDRangeKernel_14(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNDRangeKernel_15(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNDRangeKernel_16(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueReadBuffer_1(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadBuffer';
    private static function ntv_EnqueueReadBuffer_2(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadBuffer';
    private static function ntv_EnqueueReadBuffer_3(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadBuffer';
    private static function ntv_EnqueueReadBuffer_4(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadBuffer';
    private static function ntv_EnqueueReadBuffer_5(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadBuffer';
    private static function ntv_EnqueueReadBuffer_6(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadBuffer';
    private static function ntv_EnqueueReadBuffer_7(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadBuffer';
    private static function ntv_EnqueueReadBuffer_8(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadBuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
      type PT = ^T;
    begin
      Result := if (ptr<>nil) and (ptr.Length<>0) then
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr[0], num_events_in_wait_list, event_wait_list, &event) else
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, PT(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
      type PT = ^T;
    begin
      Result := if (ptr<>nil) and (ptr.Length<>0) then
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr[0], num_events_in_wait_list, event_wait_list, &event) else
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, PT(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
      type PT = ^T;
    begin
      Result := if (ptr<>nil) and (ptr.Length<>0) then
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr[0], num_events_in_wait_list, event_wait_list, &event) else
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, PT(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
      type PT = ^T;
    begin
      Result := if (ptr<>nil) and (ptr.Length<>0) then
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr[0], num_events_in_wait_list, event_wait_list, &event) else
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, PT(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadBuffer_1(command_queue, buffer, blocking_read, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadBuffer_2(command_queue, buffer, blocking_read, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadBuffer_3(command_queue, buffer, blocking_read, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadBuffer_4(command_queue, buffer, blocking_read, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReadBuffer_5(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReadBuffer_5(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReadBuffer_6(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReadBuffer_6(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReadBuffer_5(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReadBuffer_6(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReadBuffer_7(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReadBuffer_8(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.1
    private static function ntv_EnqueueReadBufferRect_1(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadBufferRect';
    private static function ntv_EnqueueReadBufferRect_2(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadBufferRect';
    private static function ntv_EnqueueReadBufferRect_3(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadBufferRect';
    private static function ntv_EnqueueReadBufferRect_4(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadBufferRect';
    private static function ntv_EnqueueReadBufferRect_5(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadBufferRect';
    private static function ntv_EnqueueReadBufferRect_6(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadBufferRect';
    private static function ntv_EnqueueReadBufferRect_7(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadBufferRect';
    private static function ntv_EnqueueReadBufferRect_8(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadBufferRect';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadBufferRect(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadBufferRect(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadBufferRect(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadBufferRect(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadBufferRect_1(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadBufferRect_2(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadBufferRect_3(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadBufferRect_4(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReadBufferRect_5(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReadBufferRect_5(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReadBufferRect_6(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReadBufferRect_6(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReadBufferRect_5(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReadBufferRect_6(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReadBufferRect_7(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReadBufferRect_8(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueReadImage_1(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadImage';
    private static function ntv_EnqueueReadImage_2(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadImage';
    private static function ntv_EnqueueReadImage_3(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadImage';
    private static function ntv_EnqueueReadImage_4(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadImage';
    private static function ntv_EnqueueReadImage_5(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadImage';
    private static function ntv_EnqueueReadImage_6(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadImage';
    private static function ntv_EnqueueReadImage_7(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadImage';
    private static function ntv_EnqueueReadImage_8(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueReadImage';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadImage(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadImage(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadImage(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadImage(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadImage_1(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadImage_2(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadImage_3(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadImage_4(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReadImage_5(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReadImage_5(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReadImage_6(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReadImage_6(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReadImage_5(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReadImage_6(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReadImage_7(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReadImage_8(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl2.0
    private static function ntv_EnqueueSVMFree_1(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMFree';
    private static function ntv_EnqueueSVMFree_2(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMFree';
    private static function ntv_EnqueueSVMFree_3(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMFree';
    private static function ntv_EnqueueSVMFree_4(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMFree';
    private static function ntv_EnqueueSVMFree_5(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMFree';
    private static function ntv_EnqueueSVMFree_6(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMFree';
    private static function ntv_EnqueueSVMFree_7(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMFree';
    private static function ntv_EnqueueSVMFree_8(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMFree';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMFree(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMFree(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMFree(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMFree(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      type PIntPtr = ^IntPtr;
    begin
      Result := if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
        ntv_EnqueueSVMFree_1(command_queue, num_svm_pointers, svm_pointers[0], pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueSVMFree_1(command_queue, num_svm_pointers, PIntPtr(nil)^, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      type PIntPtr = ^IntPtr;
    begin
      Result := if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
        ntv_EnqueueSVMFree_2(command_queue, num_svm_pointers, svm_pointers[0], pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueSVMFree_2(command_queue, num_svm_pointers, PIntPtr(nil)^, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      type PIntPtr = ^IntPtr;
    begin
      Result := if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
        ntv_EnqueueSVMFree_3(command_queue, num_svm_pointers, svm_pointers[0], pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueSVMFree_3(command_queue, num_svm_pointers, PIntPtr(nil)^, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      type PIntPtr = ^IntPtr;
    begin
      Result := if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
        ntv_EnqueueSVMFree_4(command_queue, num_svm_pointers, svm_pointers[0], pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueSVMFree_4(command_queue, num_svm_pointers, PIntPtr(nil)^, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMFree_1(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMFree_1(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMFree_2(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMFree_2(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMFree_1(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMFree_2(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMFree_3(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMFree_4(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMFree_5(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMFree_5(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMFree_6(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMFree_6(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMFree_5(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMFree_6(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMFree_7(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMFree_8(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl2.0
    private static function ntv_EnqueueSVMMap_1(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMap';
    private static function ntv_EnqueueSVMMap_2(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMap';
    private static function ntv_EnqueueSVMMap_3(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMap';
    private static function ntv_EnqueueSVMMap_4(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMap';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMap(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMap_1(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMap_1(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMap(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMap_2(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMap_2(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMap(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMap_1(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMap(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMap_2(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMap(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMap_3(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMap(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMap_4(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl2.0
    private static function ntv_EnqueueSVMMemcpy_1(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMemcpy';
    private static function ntv_EnqueueSVMMemcpy_2(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMemcpy';
    private static function ntv_EnqueueSVMMemcpy_3(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMemcpy';
    private static function ntv_EnqueueSVMMemcpy_4(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMemcpy';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemcpy(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMemcpy_1(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMemcpy_1(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemcpy(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMemcpy_2(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMemcpy_2(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemcpy(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMemcpy_1(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemcpy(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMemcpy_2(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemcpy(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMemcpy_3(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemcpy(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMemcpy_4(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl2.0
    private static function ntv_EnqueueSVMMemFill_1(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: Byte; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMemFill';
    private static function ntv_EnqueueSVMMemFill_2(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: Byte; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMemFill';
    private static function ntv_EnqueueSVMMemFill_3(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: Byte; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMemFill';
    private static function ntv_EnqueueSVMMemFill_4(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: Byte; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMemFill';
    private static function ntv_EnqueueSVMMemFill_5(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMemFill';
    private static function ntv_EnqueueSVMMemFill_6(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMemFill';
    private static function ntv_EnqueueSVMMemFill_7(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMemFill';
    private static function ntv_EnqueueSVMMemFill_8(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMemFill';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
      type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern[0], pattern_size, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueSVMMemFill(command_queue, svm_ptr, PT(nil)^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
      type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern[0], pattern_size, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueSVMMemFill(command_queue, svm_ptr, PT(nil)^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
      type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern[0], pattern_size, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueSVMMemFill(command_queue, svm_ptr, PT(nil)^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
      type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern[0], pattern_size, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueSVMMemFill(command_queue, svm_ptr, PT(nil)^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueSVMMemFill_1(command_queue, svm_ptr, PByte(pointer(@pattern))^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueSVMMemFill_2(command_queue, svm_ptr, PByte(pointer(@pattern))^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueSVMMemFill_3(command_queue, svm_ptr, PByte(pointer(@pattern))^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueSVMMemFill_4(command_queue, svm_ptr, PByte(pointer(@pattern))^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMemFill_5(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMemFill_5(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMemFill_6(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMemFill_6(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMemFill_5(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMemFill_6(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMemFill_7(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMemFill_8(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl2.1
    private static function ntv_EnqueueSVMMigrateMem_1(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMigrateMem';
    private static function ntv_EnqueueSVMMigrateMem_2(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMigrateMem';
    private static function ntv_EnqueueSVMMigrateMem_3(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMigrateMem';
    private static function ntv_EnqueueSVMMigrateMem_4(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMigrateMem';
    private static function ntv_EnqueueSVMMigrateMem_5(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMigrateMem';
    private static function ntv_EnqueueSVMMigrateMem_6(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMigrateMem';
    private static function ntv_EnqueueSVMMigrateMem_7(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMigrateMem';
    private static function ntv_EnqueueSVMMigrateMem_8(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMMigrateMem';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; sizes: array of UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMMigrateMem(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMMigrateMem(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; sizes: array of UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMMigrateMem(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMMigrateMem(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; sizes: array of UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      type PIntPtr = ^IntPtr;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (sizes<>nil) and (sizes.Length<>0) then
        if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
          ntv_EnqueueSVMMigrateMem_1(command_queue, num_svm_pointers, svm_pointers[0], sizes[0], flags, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSVMMigrateMem_1(command_queue, num_svm_pointers, PIntPtr(nil)^, sizes[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
          ntv_EnqueueSVMMigrateMem_1(command_queue, num_svm_pointers, svm_pointers[0], PUIntPtr(nil)^, flags, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSVMMigrateMem_1(command_queue, num_svm_pointers, PIntPtr(nil)^, PUIntPtr(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; sizes: array of UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      type PIntPtr = ^IntPtr;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (sizes<>nil) and (sizes.Length<>0) then
        if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
          ntv_EnqueueSVMMigrateMem_2(command_queue, num_svm_pointers, svm_pointers[0], sizes[0], flags, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSVMMigrateMem_2(command_queue, num_svm_pointers, PIntPtr(nil)^, sizes[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
          ntv_EnqueueSVMMigrateMem_2(command_queue, num_svm_pointers, svm_pointers[0], PUIntPtr(nil)^, flags, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSVMMigrateMem_2(command_queue, num_svm_pointers, PIntPtr(nil)^, PUIntPtr(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; sizes: array of UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      type PIntPtr = ^IntPtr;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (sizes<>nil) and (sizes.Length<>0) then
        if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
          ntv_EnqueueSVMMigrateMem_3(command_queue, num_svm_pointers, svm_pointers[0], sizes[0], flags, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSVMMigrateMem_3(command_queue, num_svm_pointers, PIntPtr(nil)^, sizes[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
          ntv_EnqueueSVMMigrateMem_3(command_queue, num_svm_pointers, svm_pointers[0], PUIntPtr(nil)^, flags, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSVMMigrateMem_3(command_queue, num_svm_pointers, PIntPtr(nil)^, PUIntPtr(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; sizes: array of UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      type PIntPtr = ^IntPtr;
      type PUIntPtr = ^UIntPtr;
    begin
      Result := if (sizes<>nil) and (sizes.Length<>0) then
        if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
          ntv_EnqueueSVMMigrateMem_4(command_queue, num_svm_pointers, svm_pointers[0], sizes[0], flags, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSVMMigrateMem_4(command_queue, num_svm_pointers, PIntPtr(nil)^, sizes[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
          ntv_EnqueueSVMMigrateMem_4(command_queue, num_svm_pointers, svm_pointers[0], PUIntPtr(nil)^, flags, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSVMMigrateMem_4(command_queue, num_svm_pointers, PIntPtr(nil)^, PUIntPtr(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMigrateMem_1(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMigrateMem_1(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMigrateMem_2(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMigrateMem_2(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMigrateMem_1(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMigrateMem_2(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMigrateMem_3(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMigrateMem_4(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMigrateMem_5(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMigrateMem_5(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMigrateMem_6(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMigrateMem_6(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMigrateMem_5(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMigrateMem_6(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMigrateMem_7(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMigrateMem_8(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl2.0
    private static function ntv_EnqueueSVMUnmap_1(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMUnmap';
    private static function ntv_EnqueueSVMUnmap_2(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMUnmap';
    private static function ntv_EnqueueSVMUnmap_3(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMUnmap';
    private static function ntv_EnqueueSVMUnmap_4(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueSVMUnmap';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMUnmap(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMUnmap_1(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMUnmap_1(command_queue, svm_ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMUnmap(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMUnmap_2(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMUnmap_2(command_queue, svm_ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMUnmap(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMUnmap_1(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMUnmap(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMUnmap_2(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMUnmap(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMUnmap_3(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMUnmap(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMUnmap_4(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueTask_1(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueTask';
    private static function ntv_EnqueueTask_2(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueTask';
    private static function ntv_EnqueueTask_3(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueTask';
    private static function ntv_EnqueueTask_4(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueTask';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueTask(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueTask_1(command_queue, kernel, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueTask_1(command_queue, kernel, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueTask(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueTask_2(command_queue, kernel, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueTask_2(command_queue, kernel, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueTask(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueTask_1(command_queue, kernel, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueTask(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueTask_2(command_queue, kernel, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueTask(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueTask_3(command_queue, kernel, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueTask(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueTask_4(command_queue, kernel, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueUnmapMemObject_1(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueUnmapMemObject';
    private static function ntv_EnqueueUnmapMemObject_2(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueUnmapMemObject';
    private static function ntv_EnqueueUnmapMemObject_3(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueUnmapMemObject';
    private static function ntv_EnqueueUnmapMemObject_4(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueUnmapMemObject';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueUnmapMemObject(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueUnmapMemObject_1(command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueUnmapMemObject_1(command_queue, memobj, mapped_ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueUnmapMemObject(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueUnmapMemObject_2(command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueUnmapMemObject_2(command_queue, memobj, mapped_ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueUnmapMemObject(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueUnmapMemObject_1(command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueUnmapMemObject(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueUnmapMemObject_2(command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueUnmapMemObject(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueUnmapMemObject_3(command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueUnmapMemObject(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueUnmapMemObject_4(command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueWaitForEvents_1(command_queue: cl_command_queue; num_events: UInt32; var event_list: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueWaitForEvents';
    private static function ntv_EnqueueWaitForEvents_2(command_queue: cl_command_queue; num_events: UInt32; event_list: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueWaitForEvents';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWaitForEvents(command_queue: cl_command_queue; num_events: UInt32; event_list: array of cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_list<>nil) and (event_list.Length<>0) then
        ntv_EnqueueWaitForEvents_1(command_queue, num_events, event_list[0]) else
        ntv_EnqueueWaitForEvents_1(command_queue, num_events, PCl_event(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWaitForEvents(command_queue: cl_command_queue; num_events: UInt32; var event_list: cl_event): clErrorCode :=
      ntv_EnqueueWaitForEvents_1(command_queue, num_events, event_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWaitForEvents(command_queue: cl_command_queue; num_events: UInt32; event_list: IntPtr): clErrorCode :=
      ntv_EnqueueWaitForEvents_2(command_queue, num_events, event_list);
    
    // added in cl1.0
    private static function ntv_EnqueueWriteBuffer_1(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_2(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_3(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_4(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_5(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_6(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_7(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_8(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_9(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_10(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_11(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_12(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] static function temp_EnqueueWriteBuffer_1<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBuffer_1(command_queue, buffer, blocking_write, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
      type PT = ^T;
    begin
      Result := if (ptr<>nil) and (ptr.Length<>0) then
        temp_EnqueueWriteBuffer_1(command_queue, buffer, blocking_write, offset, size, ptr[0], num_events_in_wait_list, event_wait_list, &event) else
        temp_EnqueueWriteBuffer_1(command_queue, buffer, blocking_write, offset, size, PT(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] static function temp_EnqueueWriteBuffer_2<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBuffer_2(command_queue, buffer, blocking_write, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
      type PT = ^T;
    begin
      Result := if (ptr<>nil) and (ptr.Length<>0) then
        temp_EnqueueWriteBuffer_2(command_queue, buffer, blocking_write, offset, size, ptr[0], num_events_in_wait_list, event_wait_list, &event) else
        temp_EnqueueWriteBuffer_2(command_queue, buffer, blocking_write, offset, size, PT(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] static function temp_EnqueueWriteBuffer_3<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBuffer_3(command_queue, buffer, blocking_write, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
      type PT = ^T;
    begin
      Result := if (ptr<>nil) and (ptr.Length<>0) then
        temp_EnqueueWriteBuffer_3(command_queue, buffer, blocking_write, offset, size, ptr[0], num_events_in_wait_list, event_wait_list, &event) else
        temp_EnqueueWriteBuffer_3(command_queue, buffer, blocking_write, offset, size, PT(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] static function temp_EnqueueWriteBuffer_4<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBuffer_4(command_queue, buffer, blocking_write, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
      type PT = ^T;
    begin
      Result := if (ptr<>nil) and (ptr.Length<>0) then
        temp_EnqueueWriteBuffer_4(command_queue, buffer, blocking_write, offset, size, ptr[0], num_events_in_wait_list, event_wait_list, &event) else
        temp_EnqueueWriteBuffer_4(command_queue, buffer, blocking_write, offset, size, PT(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBuffer_5(command_queue, buffer, blocking_write, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBuffer_6(command_queue, buffer, blocking_write, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBuffer_7(command_queue, buffer, blocking_write, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBuffer_8(command_queue, buffer, blocking_write, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWriteBuffer_9(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWriteBuffer_9(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWriteBuffer_10(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWriteBuffer_10(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWriteBuffer_9(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWriteBuffer_10(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWriteBuffer_11(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWriteBuffer_12(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.1
    private static function ntv_EnqueueWriteBufferRect_1(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBufferRect';
    private static function ntv_EnqueueWriteBufferRect_2(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBufferRect';
    private static function ntv_EnqueueWriteBufferRect_3(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBufferRect';
    private static function ntv_EnqueueWriteBufferRect_4(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBufferRect';
    private static function ntv_EnqueueWriteBufferRect_5(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBufferRect';
    private static function ntv_EnqueueWriteBufferRect_6(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBufferRect';
    private static function ntv_EnqueueWriteBufferRect_7(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBufferRect';
    private static function ntv_EnqueueWriteBufferRect_8(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteBufferRect';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteBufferRect(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteBufferRect(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteBufferRect(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteBufferRect(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBufferRect_1(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBufferRect_2(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBufferRect_3(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBufferRect_4(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWriteBufferRect_5(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWriteBufferRect_5(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWriteBufferRect_6(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWriteBufferRect_6(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWriteBufferRect_5(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWriteBufferRect_6(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWriteBufferRect_7(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWriteBufferRect_8(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueWriteImage_1(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteImage';
    private static function ntv_EnqueueWriteImage_2(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteImage';
    private static function ntv_EnqueueWriteImage_3(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteImage';
    private static function ntv_EnqueueWriteImage_4(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteImage';
    private static function ntv_EnqueueWriteImage_5(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteImage';
    private static function ntv_EnqueueWriteImage_6(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteImage';
    private static function ntv_EnqueueWriteImage_7(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteImage';
    private static function ntv_EnqueueWriteImage_8(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
      external 'OpenCL' name 'clEnqueueWriteImage';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteImage(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteImage(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteImage(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteImage(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteImage_1(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteImage_2(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteImage_3(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteImage_4(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWriteImage_5(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWriteImage_5(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWriteImage_6(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWriteImage_6(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWriteImage_5(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWriteImage_6(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWriteImage_7(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWriteImage_8(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_Finish_1(command_queue: cl_command_queue): clErrorCode;
      external 'OpenCL' name 'clFinish';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function Finish(command_queue: cl_command_queue): clErrorCode :=
      ntv_Finish_1(command_queue);
    
    // added in cl1.0
    private static function ntv_Flush_1(command_queue: cl_command_queue): clErrorCode;
      external 'OpenCL' name 'clFlush';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function Flush(command_queue: cl_command_queue): clErrorCode :=
      ntv_Flush_1(command_queue);
    
    // added in cl1.0
    private static function ntv_GetCommandQueueInfo_1(command_queue: cl_command_queue; param_name: clCommandQueueInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetCommandQueueInfo';
    private static function ntv_GetCommandQueueInfo_2(command_queue: cl_command_queue; param_name: clCommandQueueInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetCommandQueueInfo';
    private static function ntv_GetCommandQueueInfo_3(command_queue: cl_command_queue; param_name: clCommandQueueInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetCommandQueueInfo';
    private static function ntv_GetCommandQueueInfo_4(command_queue: cl_command_queue; param_name: clCommandQueueInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetCommandQueueInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo<T>(command_queue: cl_command_queue; param_name: clCommandQueueInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetCommandQueueInfo_1(command_queue, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo<T>(command_queue: cl_command_queue; param_name: clCommandQueueInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetCommandQueueInfo_2(command_queue, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo(command_queue: cl_command_queue; param_name: clCommandQueueInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetCommandQueueInfo_3(command_queue, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo(command_queue: cl_command_queue; param_name: clCommandQueueInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetCommandQueueInfo_4(command_queue, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_CONTEXT(command_queue: cl_command_queue; var param_value: cl_context; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_context>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_CONTEXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_DEVICE(command_queue: cl_command_queue; var param_value: cl_device_id; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_device_id>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_DEVICE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_REFERENCE_COUNT(command_queue: cl_command_queue; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_PROPERTIES(command_queue: cl_command_queue; var param_value: clCommandQueueProperties; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandQueueProperties>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_PROPERTIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_SIZE(command_queue: cl_command_queue; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_DEVICE_DEFAULT(command_queue: cl_command_queue; var param_value: cl_command_queue; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_command_queue>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_DEVICE_DEFAULT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_PROPERTIES_ARRAY(command_queue: cl_command_queue; var param_value: array of clQueueProperties): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetCommandQueueInfo_3(command_queue, clCommandQueueInfo.QUEUE_PROPERTIES_ARRAY, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clQueueProperties[param_value_sz.ToUInt64 div Marshal.SizeOf&<clQueueProperties>];
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_PROPERTIES_ARRAY, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_PROPERTIES_ARRAY(command_queue: cl_command_queue; param_value_count: UInt32; var param_value: clQueueProperties): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clQueueProperties>);
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_PROPERTIES_ARRAY, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_FAMILY(command_queue: cl_command_queue; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_FAMILY, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_INDEX(command_queue: cl_command_queue; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_INDEX, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
    // added in cl1.0
    private static function ntv_GetContextInfo_1(context: cl_context; param_name: clContextInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetContextInfo';
    private static function ntv_GetContextInfo_2(context: cl_context; param_name: clContextInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetContextInfo';
    private static function ntv_GetContextInfo_3(context: cl_context; param_name: clContextInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetContextInfo';
    private static function ntv_GetContextInfo_4(context: cl_context; param_name: clContextInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetContextInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo<T>(context: cl_context; param_name: clContextInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetContextInfo_1(context, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo<T>(context: cl_context; param_name: clContextInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetContextInfo_2(context, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo(context: cl_context; param_name: clContextInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetContextInfo_3(context, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo(context: cl_context; param_name: clContextInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetContextInfo_4(context, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo_CONTEXT_REFERENCE_COUNT(context: cl_context; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetContextInfo(context, clContextInfo.CONTEXT_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo_CONTEXT_DEVICES(context: cl_context; var param_value: array of cl_device_id): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetContextInfo_3(context, clContextInfo.CONTEXT_DEVICES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_device_id[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_device_id>];
      Result := GetContextInfo(context, clContextInfo.CONTEXT_DEVICES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo_CONTEXT_DEVICES(context: cl_context; param_value_count: UInt32; var param_value: cl_device_id): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_device_id>);
      Result := GetContextInfo(context, clContextInfo.CONTEXT_DEVICES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo_CONTEXT_PROPERTIES(context: cl_context; var param_value: clContextProperties; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clContextProperties>);
      var param_value_ret_size: UIntPtr;
      Result := GetContextInfo(context, clContextInfo.CONTEXT_PROPERTIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo_CONTEXT_NUM_DEVICES(context: cl_context; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetContextInfo(context, clContextInfo.CONTEXT_NUM_DEVICES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo_CONTEXT_D3D10_PREFER_SHARED_RESOURCES(context: cl_context; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetContextInfo(context, clContextInfo.CONTEXT_D3D10_PREFER_SHARED_RESOURCES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo_CONTEXT_D3D11_PREFER_SHARED_RESOURCES(context: cl_context; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetContextInfo(context, clContextInfo.CONTEXT_D3D11_PREFER_SHARED_RESOURCES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo_CONTEXT_VA_API_DISPLAY(context: cl_context; var param_value: IntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<IntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetContextInfo(context, clContextInfo.CONTEXT_VA_API_DISPLAY, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
    // added in cl2.1
    private static function ntv_GetDeviceAndHostTimer_1(device: cl_device_id; var device_timestamp: UInt64; var host_timestamp: UInt64): clErrorCode;
      external 'OpenCL' name 'clGetDeviceAndHostTimer';
    private static function ntv_GetDeviceAndHostTimer_2(device: cl_device_id; var device_timestamp: UInt64; host_timestamp: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetDeviceAndHostTimer';
    private static function ntv_GetDeviceAndHostTimer_3(device: cl_device_id; device_timestamp: IntPtr; var host_timestamp: UInt64): clErrorCode;
      external 'OpenCL' name 'clGetDeviceAndHostTimer';
    private static function ntv_GetDeviceAndHostTimer_4(device: cl_device_id; device_timestamp: IntPtr; host_timestamp: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetDeviceAndHostTimer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceAndHostTimer(device: cl_device_id; var device_timestamp: UInt64; var host_timestamp: UInt64): clErrorCode :=
      ntv_GetDeviceAndHostTimer_1(device, device_timestamp, host_timestamp);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceAndHostTimer(device: cl_device_id; var device_timestamp: UInt64; host_timestamp: IntPtr): clErrorCode :=
      ntv_GetDeviceAndHostTimer_2(device, device_timestamp, host_timestamp);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceAndHostTimer(device: cl_device_id; device_timestamp: IntPtr; var host_timestamp: UInt64): clErrorCode :=
      ntv_GetDeviceAndHostTimer_3(device, device_timestamp, host_timestamp);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceAndHostTimer(device: cl_device_id; device_timestamp: IntPtr; host_timestamp: IntPtr): clErrorCode :=
      ntv_GetDeviceAndHostTimer_4(device, device_timestamp, host_timestamp);
    
    // added in cl1.0
    private static function ntv_GetDeviceIDs_1(platform: cl_platform_id; device_type: clDeviceType; num_entries: UInt32; var devices: cl_device_id; var num_devices: UInt32): clErrorCode;
      external 'OpenCL' name 'clGetDeviceIDs';
    private static function ntv_GetDeviceIDs_2(platform: cl_platform_id; device_type: clDeviceType; num_entries: UInt32; var devices: cl_device_id; num_devices: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetDeviceIDs';
    private static function ntv_GetDeviceIDs_3(platform: cl_platform_id; device_type: clDeviceType; num_entries: UInt32; devices: IntPtr; var num_devices: UInt32): clErrorCode;
      external 'OpenCL' name 'clGetDeviceIDs';
    private static function ntv_GetDeviceIDs_4(platform: cl_platform_id; device_type: clDeviceType; num_entries: UInt32; devices: IntPtr; num_devices: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetDeviceIDs';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceIDs(platform: cl_platform_id; device_type: clDeviceType; num_entries: UInt32; var devices: cl_device_id; var num_devices: UInt32): clErrorCode :=
      ntv_GetDeviceIDs_1(platform, device_type, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceIDs(platform: cl_platform_id; device_type: clDeviceType; num_entries: UInt32; var devices: cl_device_id; num_devices: IntPtr): clErrorCode :=
      ntv_GetDeviceIDs_2(platform, device_type, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceIDs(platform: cl_platform_id; device_type: clDeviceType; num_entries: UInt32; devices: IntPtr; var num_devices: UInt32): clErrorCode :=
      ntv_GetDeviceIDs_3(platform, device_type, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceIDs(platform: cl_platform_id; device_type: clDeviceType; num_entries: UInt32; devices: IntPtr; num_devices: IntPtr): clErrorCode :=
      ntv_GetDeviceIDs_4(platform, device_type, num_entries, devices, num_devices);
    
    // added in cl1.0
    private static function ntv_GetDeviceInfo_1(device: cl_device_id; param_name: clDeviceInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetDeviceInfo';
    private static function ntv_GetDeviceInfo_2(device: cl_device_id; param_name: clDeviceInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetDeviceInfo';
    private static function ntv_GetDeviceInfo_3(device: cl_device_id; param_name: clDeviceInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetDeviceInfo';
    private static function ntv_GetDeviceInfo_4(device: cl_device_id; param_name: clDeviceInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetDeviceInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo<T>(device: cl_device_id; param_name: clDeviceInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetDeviceInfo_1(device, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo<T>(device: cl_device_id; param_name: clDeviceInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetDeviceInfo_2(device, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo(device: cl_device_id; param_name: clDeviceInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetDeviceInfo_3(device, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo(device: cl_device_id; param_name: clDeviceInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetDeviceInfo_4(device, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_TYPE(device: cl_device_id; var param_value: clDeviceType; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceType>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_VENDOR_ID(device: cl_device_id; var param_value: clKhronosVendorId; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clKhronosVendorId>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_VENDOR_ID, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_COMPUTE_UNITS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_COMPUTE_UNITS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_WORK_ITEM_DIMENSIONS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_WORK_ITEM_DIMENSIONS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_WORK_GROUP_SIZE(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_WORK_GROUP_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_WORK_ITEM_SIZES(device: cl_device_id; var param_value: array of UIntPtr): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_MAX_WORK_ITEM_SIZES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new UIntPtr[param_value_sz.ToUInt64 div Marshal.SizeOf&<UIntPtr>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_WORK_ITEM_SIZES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_WORK_ITEM_SIZES(device: cl_device_id; param_value_count: UInt32; var param_value: UIntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UIntPtr>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_WORK_ITEM_SIZES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_VECTOR_WIDTH_CHAR, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_VECTOR_WIDTH_SHORT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_INT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_VECTOR_WIDTH_INT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_LONG(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_VECTOR_WIDTH_LONG, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_CLOCK_FREQUENCY(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_CLOCK_FREQUENCY, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ADDRESS_BITS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ADDRESS_BITS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_READ_IMAGE_ARGS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_READ_IMAGE_ARGS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_WRITE_IMAGE_ARGS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_WRITE_IMAGE_ARGS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_MEM_ALLOC_SIZE(device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_MEM_ALLOC_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE2D_MAX_WIDTH(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE2D_MAX_WIDTH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE2D_MAX_HEIGHT(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE2D_MAX_HEIGHT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE3D_MAX_WIDTH(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE3D_MAX_WIDTH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE3D_MAX_HEIGHT(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE3D_MAX_HEIGHT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE3D_MAX_DEPTH(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE3D_MAX_DEPTH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE_SUPPORT(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE_SUPPORT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_PARAMETER_SIZE(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_PARAMETER_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_SAMPLERS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_SAMPLERS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MEM_BASE_ADDR_ALIGN(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MEM_BASE_ADDR_ALIGN, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MIN_DATA_TYPE_ALIGN_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SINGLE_FP_CONFIG(device: cl_device_id; var param_value: clDeviceFPConfig; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceFPConfig>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SINGLE_FP_CONFIG, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_GLOBAL_MEM_CACHE_TYPE(device: cl_device_id; var param_value: clDeviceMemCacheType; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceMemCacheType>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_GLOBAL_MEM_CACHE_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_GLOBAL_MEM_CACHELINE_SIZE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_GLOBAL_MEM_CACHELINE_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_GLOBAL_MEM_CACHE_SIZE(device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_GLOBAL_MEM_CACHE_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_GLOBAL_MEM_SIZE(device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_GLOBAL_MEM_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_CONSTANT_BUFFER_SIZE(device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_CONSTANT_BUFFER_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_CONSTANT_ARGS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_CONSTANT_ARGS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_LOCAL_MEM_TYPE(device: cl_device_id; var param_value: clDeviceLocalMemType; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceLocalMemType>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_LOCAL_MEM_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_LOCAL_MEM_SIZE(device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_LOCAL_MEM_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ERROR_CORRECTION_SUPPORT(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ERROR_CORRECTION_SUPPORT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PROFILING_TIMER_RESOLUTION(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PROFILING_TIMER_RESOLUTION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ENDIAN_LITTLE(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ENDIAN_LITTLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_AVAILABLE(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_AVAILABLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMPILER_AVAILABLE(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMPILER_AVAILABLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_EXECUTION_CAPABILITIES(device: cl_device_id; var param_value: clDeviceExecCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceExecCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_EXECUTION_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_QUEUE_PROPERTIES(device: cl_device_id; var param_value: clCommandQueueProperties; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandQueueProperties>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_QUEUE_PROPERTIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_QUEUE_ON_HOST_PROPERTIES(device: cl_device_id; var param_value: clCommandQueueProperties; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandQueueProperties>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_QUEUE_ON_HOST_PROPERTIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NAME(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_NAME, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_NAME, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_VENDOR(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_VENDOR, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_VENDOR, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DRIVER_VERSION(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DRIVER_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DRIVER_VERSION, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PROFILE(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_PROFILE, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_PROFILE, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_VERSION(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_VERSION, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_EXTENSIONS(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_EXTENSIONS, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_EXTENSIONS, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PLATFORM(device: cl_device_id; var param_value: cl_platform_id; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_platform_id>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PLATFORM, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_DOUBLE_FP_CONFIG(device: cl_device_id; var param_value: clDeviceFPConfig; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceFPConfig>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_DOUBLE_FP_CONFIG, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_HALF_FP_CONFIG(device: cl_device_id; var param_value: clDeviceFPConfig; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceFPConfig>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_HALF_FP_CONFIG, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_HALF(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_VECTOR_WIDTH_HALF, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_HOST_UNIFIED_MEMORY(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_HOST_UNIFIED_MEMORY, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_CHAR(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NATIVE_VECTOR_WIDTH_CHAR, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_SHORT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NATIVE_VECTOR_WIDTH_SHORT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_INT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NATIVE_VECTOR_WIDTH_INT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_LONG(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NATIVE_VECTOR_WIDTH_LONG, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NATIVE_VECTOR_WIDTH_FLOAT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_HALF(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NATIVE_VECTOR_WIDTH_HALF, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_OPENCL_C_VERSION(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_OPENCL_C_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_OPENCL_C_VERSION, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_LINKER_AVAILABLE(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_LINKER_AVAILABLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_BUILT_IN_KERNELS(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_BUILT_IN_KERNELS, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_BUILT_IN_KERNELS, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE_MAX_BUFFER_SIZE(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE_MAX_BUFFER_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE_MAX_ARRAY_SIZE(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE_MAX_ARRAY_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARENT_DEVICE(device: cl_device_id; var param_value: cl_device_id; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_device_id>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARENT_DEVICE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_MAX_SUB_DEVICES(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_MAX_SUB_DEVICES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_PROPERTIES(device: cl_device_id; var param_value: array of clDevicePartitionProperty): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_PARTITION_PROPERTIES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clDevicePartitionProperty[param_value_sz.ToUInt64 div Marshal.SizeOf&<clDevicePartitionProperty>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_PROPERTIES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_PROPERTIES(device: cl_device_id; param_value_count: UInt32; var param_value: clDevicePartitionProperty): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clDevicePartitionProperty>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_PROPERTIES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_AFFINITY_DOMAIN(device: cl_device_id; var param_value: clDeviceAffinityDomain; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceAffinityDomain>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_AFFINITY_DOMAIN, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_TYPE(device: cl_device_id; var param_value: array of clDevicePartitionProperty): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_PARTITION_TYPE, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clDevicePartitionProperty[param_value_sz.ToUInt64 div Marshal.SizeOf&<clDevicePartitionProperty>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_TYPE, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_TYPE(device: cl_device_id; param_value_count: UInt32; var param_value: clDevicePartitionProperty): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clDevicePartitionProperty>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_TYPE, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_REFERENCE_COUNT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_INTEROP_USER_SYNC(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_INTEROP_USER_SYNC, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PRINTF_BUFFER_SIZE(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PRINTF_BUFFER_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE_PITCH_ALIGNMENT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE_PITCH_ALIGNMENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_READ_WRITE_IMAGE_ARGS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_READ_WRITE_IMAGE_ARGS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_GLOBAL_VARIABLE_SIZE(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_GLOBAL_VARIABLE_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_QUEUE_ON_DEVICE_PROPERTIES(device: cl_device_id; var param_value: clCommandQueueProperties; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandQueueProperties>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_QUEUE_ON_DEVICE_PROPERTIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_QUEUE_ON_DEVICE_MAX_SIZE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_QUEUE_ON_DEVICE_MAX_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_ON_DEVICE_QUEUES(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_ON_DEVICE_QUEUES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_ON_DEVICE_EVENTS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_ON_DEVICE_EVENTS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SVM_CAPABILITIES(device: cl_device_id; var param_value: clDeviceSVMCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceSVMCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SVM_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_PIPE_ARGS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_PIPE_ARGS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PIPE_MAX_PACKET_SIZE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PIPE_MAX_PACKET_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IL_VERSION(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_IL_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_IL_VERSION, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_NUM_SUB_GROUPS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_NUM_SUB_GROUPS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NUMERIC_VERSION(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NUMERIC_VERSION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_OPENCL_C_NUMERIC_VERSION(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_OPENCL_C_NUMERIC_VERSION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_EXTENSIONS_WITH_VERSION(device: cl_device_id; var param_value: array of cl_name_version): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_EXTENSIONS_WITH_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_name_version[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_name_version>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_EXTENSIONS_WITH_VERSION, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_EXTENSIONS_WITH_VERSION(device: cl_device_id; param_value_count: UInt32; var param_value: cl_name_version): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_name_version>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_EXTENSIONS_WITH_VERSION, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ILS_WITH_VERSION(device: cl_device_id; var param_value: array of cl_name_version): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_ILS_WITH_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_name_version[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_name_version>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ILS_WITH_VERSION, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ILS_WITH_VERSION(device: cl_device_id; param_value_count: UInt32; var param_value: cl_name_version): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_name_version>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ILS_WITH_VERSION, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_BUILT_IN_KERNELS_WITH_VERSION(device: cl_device_id; var param_value: array of cl_name_version): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_BUILT_IN_KERNELS_WITH_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_name_version[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_name_version>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_BUILT_IN_KERNELS_WITH_VERSION, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_BUILT_IN_KERNELS_WITH_VERSION(device: cl_device_id; param_value_count: UInt32; var param_value: cl_name_version): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_name_version>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_BUILT_IN_KERNELS_WITH_VERSION, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ATOMIC_MEMORY_CAPABILITIES(device: cl_device_id; var param_value: clDeviceAtomicCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceAtomicCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ATOMIC_MEMORY_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ATOMIC_FENCE_CAPABILITIES(device: cl_device_id; var param_value: clDeviceAtomicCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceAtomicCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ATOMIC_FENCE_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NON_UNIFORM_WORK_GROUP_SUPPORT(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NON_UNIFORM_WORK_GROUP_SUPPORT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_OPENCL_C_ALL_VERSIONS(device: cl_device_id; var param_value: array of cl_name_version): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_OPENCL_C_ALL_VERSIONS, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_name_version[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_name_version>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_OPENCL_C_ALL_VERSIONS, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_OPENCL_C_ALL_VERSIONS(device: cl_device_id; param_value_count: UInt32; var param_value: cl_name_version): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_name_version>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_OPENCL_C_ALL_VERSIONS, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_WORK_GROUP_SIZE_MULTIPLE(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_WORK_GROUP_COLLECTIVE_FUNCTIONS_SUPPORT(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_WORK_GROUP_COLLECTIVE_FUNCTIONS_SUPPORT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_UUID(device: cl_device_id; var param_value: array of Byte; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(16*Marshal.SizeOf&<Byte>);
      var param_value_temp_res := new Byte[16];
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_UUID, param_value_sz,param_value_temp_res[0],param_value_ret_size);
      param_value := param_value_temp_res;
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_UUID(device: cl_device_id; param_value_count: UInt32; var param_value: Byte; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<Byte>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_UUID, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DRIVER_UUID(device: cl_device_id; var param_value: array of Byte; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(16*Marshal.SizeOf&<Byte>);
      var param_value_temp_res := new Byte[16];
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DRIVER_UUID, param_value_sz,param_value_temp_res[0],param_value_ret_size);
      param_value := param_value_temp_res;
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DRIVER_UUID(device: cl_device_id; param_value_count: UInt32; var param_value: Byte; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<Byte>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DRIVER_UUID, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_LUID_VALID(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_LUID_VALID, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_LUID(device: cl_device_id; var param_value: array of Byte; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(8*Marshal.SizeOf&<Byte>);
      var param_value_temp_res := new Byte[8];
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_LUID, param_value_sz,param_value_temp_res[0],param_value_ret_size);
      param_value := param_value_temp_res;
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_LUID(device: cl_device_id; param_value_count: UInt32; var param_value: Byte; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<Byte>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_LUID, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NODE_MASK(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NODE_MASK, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_OPENCL_C_FEATURES(device: cl_device_id; var param_value: array of cl_name_version): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_OPENCL_C_FEATURES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_name_version[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_name_version>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_OPENCL_C_FEATURES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_OPENCL_C_FEATURES(device: cl_device_id; param_value_count: UInt32; var param_value: cl_name_version): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_name_version>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_OPENCL_C_FEATURES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_DEVICE_ENQUEUE_CAPABILITIES(device: cl_device_id; var param_value: clDeviceOnDeviceEnqueueCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceOnDeviceEnqueueCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_DEVICE_ENQUEUE_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PIPE_SUPPORT(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PIPE_SUPPORT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_LATEST_CONFORMANCE_VERSION_PASSED(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_LATEST_CONFORMANCE_VERSION_PASSED, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_LATEST_CONFORMANCE_VERSION_PASSED, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_INTEGER_DOT_PRODUCT_CAPABILITIES(device: cl_device_id; var param_value: clDeviceIntegerDotProductCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceIntegerDotProductCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_INTEGER_DOT_PRODUCT_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_8BIT(device: cl_device_id; var param_value: cl_device_integer_dot_product_acceleration_properties; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_device_integer_dot_product_acceleration_properties>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_8BIT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_4x8BIT_PACKED(device: cl_device_id; var param_value: cl_device_integer_dot_product_acceleration_properties; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_device_integer_dot_product_acceleration_properties>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_4x8BIT_PACKED, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_KERNEL_CLOCK_CAPABILITIES(device: cl_device_id; var param_value: clDeviceKernelClockCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceKernelClockCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_KERNEL_CLOCK_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMMAND_BUFFER_CAPABILITIES(device: cl_device_id; var param_value: clDeviceCommandBufferCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceCommandBufferCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMMAND_BUFFER_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES(device: cl_device_id; var param_value: clCommandQueueProperties; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandQueueProperties>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMMAND_BUFFER_NUM_SYNC_DEVICES(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMMAND_BUFFER_NUM_SYNC_DEVICES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMMAND_BUFFER_SYNC_DEVICES(device: cl_device_id; var param_value: array of cl_device_id): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_COMMAND_BUFFER_SYNC_DEVICES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_device_id[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_device_id>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMMAND_BUFFER_SYNC_DEVICES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMMAND_BUFFER_SYNC_DEVICES(device: cl_device_id; param_value_count: UInt32; var param_value: cl_device_id): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_device_id>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMMAND_BUFFER_SYNC_DEVICES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MUTABLE_DISPATCH_CAPABILITIES(device: cl_device_id; var param_value: clMutableDispatchFields; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clMutableDispatchFields>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MUTABLE_DISPATCH_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_TERMINATE_CAPABILITY(device: cl_device_id; var param_value: clDeviceTerminateCapability; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceTerminateCapability>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_TERMINATE_CAPABILITY, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_NAMED_BARRIER_COUNT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_NAMED_BARRIER_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SEMAPHORE_TYPES(device: cl_device_id; var param_value: array of clSemaphoreType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_SEMAPHORE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clSemaphoreType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clSemaphoreType>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SEMAPHORE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SEMAPHORE_TYPES(device: cl_device_id; param_value_count: UInt32; var param_value: clSemaphoreType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clSemaphoreType>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SEMAPHORE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES(device: cl_device_id; var param_value: array of clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clExternalSemaphoreHandleType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clExternalSemaphoreHandleType>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES(device: cl_device_id; param_value_count: UInt32; var param_value: clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clExternalSemaphoreHandleType>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES(device: cl_device_id; var param_value: array of clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clExternalSemaphoreHandleType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clExternalSemaphoreHandleType>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES(device: cl_device_id; param_value_count: UInt32; var param_value: clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clExternalSemaphoreHandleType>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES(device: cl_device_id; var param_value: array of clExternalMemoryHandleType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clExternalMemoryHandleType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clExternalMemoryHandleType>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES(device: cl_device_id; param_value_count: UInt32; var param_value: clExternalMemoryHandleType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clExternalMemoryHandleType>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES(device: cl_device_id; var param_value: array of clExternalMemoryHandleType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clExternalMemoryHandleType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clExternalMemoryHandleType>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES(device: cl_device_id; param_value_count: UInt32; var param_value: clExternalMemoryHandleType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clExternalMemoryHandleType>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMPUTE_CAPABILITY_MAJOR(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMPUTE_CAPABILITY_MAJOR, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMPUTE_CAPABILITY_MINOR(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMPUTE_CAPABILITY_MINOR, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_REGISTERS_PER_BLOCK(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_REGISTERS_PER_BLOCK, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_WARP_SIZE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_WARP_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_GPU_OVERLAP(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_GPU_OVERLAP, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_KERNEL_EXEC_TIMEOUT(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_KERNEL_EXEC_TIMEOUT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_INTEGRATED_MEMORY(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_INTEGRATED_MEMORY, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARENT_DEVICE_EXT(device: cl_device_id; var param_value: cl_device_id; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_device_id>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARENT_DEVICE_EXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_TYPES(device: cl_device_id; var param_value: array of clDevicePartitionProperty): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_PARTITION_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clDevicePartitionProperty[param_value_sz.ToUInt64 div Marshal.SizeOf&<clDevicePartitionProperty>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_TYPES(device: cl_device_id; param_value_count: UInt32; var param_value: clDevicePartitionProperty): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clDevicePartitionProperty>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_AFFINITY_DOMAINS(device: cl_device_id; var param_value: clDeviceAffinityDomain; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceAffinityDomain>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_AFFINITY_DOMAINS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_REFERENCE_COUNT_EXT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_REFERENCE_COUNT_EXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_STYLE(device: cl_device_id; var param_value: clDevicePartitionProperty; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDevicePartitionProperty>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_STYLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ME_VERSION(device: cl_device_id; var param_value: clDeviceMeVersion; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceMeVersion>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ME_VERSION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SVM_CAPABILITIES_ARM(device: cl_device_id; var param_value: clDeviceSVMCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceSVMCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SVM_CAPABILITIES_ARM, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMPUTE_UNITS_BITFIELD(device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMPUTE_UNITS_BITFIELD, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MEMORY_CAPABILITIES(device: cl_device_id; var param_value: clMemAllocFlagsIMG; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clMemAllocFlagsIMG>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MEMORY_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SPIR_VERSIONS(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_SPIR_VERSIONS, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_SPIR_VERSIONS, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SIMULTANEOUS_INTEROPS(device: cl_device_id; var param_value: array of UInt32): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_SIMULTANEOUS_INTEROPS, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new UInt32[param_value_sz.ToUInt64 div Marshal.SizeOf&<UInt32>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SIMULTANEOUS_INTEROPS, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SIMULTANEOUS_INTEROPS(device: cl_device_id; param_value_count: UInt32; var param_value: UInt32): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UInt32>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SIMULTANEOUS_INTEROPS, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NUM_SIMULTANEOUS_INTEROPS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NUM_SIMULTANEOUS_INTEROPS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SUB_GROUP_SIZES(device: cl_device_id; var param_value: array of UIntPtr): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_SUB_GROUP_SIZES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new UIntPtr[param_value_sz.ToUInt64 div Marshal.SizeOf&<UIntPtr>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SUB_GROUP_SIZES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SUB_GROUP_SIZES(device: cl_device_id; param_value_count: UInt32; var param_value: UIntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UIntPtr>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SUB_GROUP_SIZES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_AVC_ME_VERSION(device: cl_device_id; var param_value: clDeviceAvcMeVersion; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceAvcMeVersion>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_AVC_ME_VERSION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_AVC_ME_SUPPORTS_TEXTURE_SAMPLER_USE(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_AVC_ME_SUPPORTS_TEXTURE_SAMPLER_USE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_AVC_ME_SUPPORTS_PREEMPTION(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_AVC_ME_SUPPORTS_PREEMPTION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PCI_BUS_INFO(device: cl_device_id; var param_value: cl_device_pci_bus_info; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_device_pci_bus_info>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PCI_BUS_INFO, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PLANAR_YUV_MAX_WIDTH(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PLANAR_YUV_MAX_WIDTH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PLANAR_YUV_MAX_HEIGHT(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PLANAR_YUV_MAX_HEIGHT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_QUEUE_FAMILY_PROPERTIES(device: cl_device_id; var param_value: array of cl_queue_family_properties): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_QUEUE_FAMILY_PROPERTIES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_queue_family_properties[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_queue_family_properties>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_QUEUE_FAMILY_PROPERTIES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_QUEUE_FAMILY_PROPERTIES(device: cl_device_id; param_value_count: UInt32; var param_value: cl_queue_family_properties): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_queue_family_properties>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_QUEUE_FAMILY_PROPERTIES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_HOST_MEM_CAPABILITIES(device: cl_device_id; var param_value: clDeviceUnifiedSharedMemoryCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceUnifiedSharedMemoryCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_HOST_MEM_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_DEVICE_MEM_CAPABILITIES(device: cl_device_id; var param_value: clDeviceUnifiedSharedMemoryCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceUnifiedSharedMemoryCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_DEVICE_MEM_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SINGLE_DEVICE_SHARED_MEM_CAPABILITIES(device: cl_device_id; var param_value: clDeviceUnifiedSharedMemoryCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceUnifiedSharedMemoryCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SINGLE_DEVICE_SHARED_MEM_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_CROSS_DEVICE_SHARED_MEM_CAPABILITIES(device: cl_device_id; var param_value: clDeviceUnifiedSharedMemoryCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceUnifiedSharedMemoryCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_CROSS_DEVICE_SHARED_MEM_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SHARED_SYSTEM_MEM_CAPABILITIES(device: cl_device_id; var param_value: clDeviceUnifiedSharedMemoryCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceUnifiedSharedMemoryCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SHARED_SYSTEM_MEM_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_JOB_SLOTS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_JOB_SLOTS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SCHEDULING_CONTROLS_CAPABILITIES(device: cl_device_id; var param_value: clDeviceSchedulingControlsCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceSchedulingControlsCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SCHEDULING_CONTROLS_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_WARP_COUNT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_WARP_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SUPPORTED_REGISTER_ALLOCATIONS(device: cl_device_id; var param_value: array of Int32): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_SUPPORTED_REGISTER_ALLOCATIONS, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new Int32[param_value_sz.ToUInt64 div Marshal.SizeOf&<Int32>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SUPPORTED_REGISTER_ALLOCATIONS, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SUPPORTED_REGISTER_ALLOCATIONS(device: cl_device_id; param_value_count: UInt32; var param_value: Int32): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<Int32>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SUPPORTED_REGISTER_ALLOCATIONS, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_CONTROLLED_TERMINATION_CAPABILITIES(device: cl_device_id; var param_value: clDeviceControlledTerminationCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceControlledTerminationCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_CONTROLLED_TERMINATION_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_CXX_FOR_OPENCL_NUMERIC_VERSION(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_CXX_FOR_OPENCL_NUMERIC_VERSION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SINGLE_FP_ATOMIC_CAPABILITIES(device: cl_device_id; var param_value: clDeviceFpAtomicCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceFpAtomicCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SINGLE_FP_ATOMIC_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_DOUBLE_FP_ATOMIC_CAPABILITIES(device: cl_device_id; var param_value: clDeviceFpAtomicCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceFpAtomicCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_DOUBLE_FP_ATOMIC_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_HALF_FP_ATOMIC_CAPABILITIES(device: cl_device_id; var param_value: clDeviceFpAtomicCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceFpAtomicCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_HALF_FP_ATOMIC_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IP_VERSION(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IP_VERSION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ID(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ID, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NUM_SLICES(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NUM_SLICES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NUM_SUB_SLICES_PER_SLICE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NUM_SUB_SLICES_PER_SLICE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NUM_EUS_PER_SUB_SLICE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NUM_EUS_PER_SUB_SLICE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NUM_THREADS_PER_EU(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NUM_THREADS_PER_EU, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_FEATURE_CAPABILITIES(device: cl_device_id; var param_value: clDeviceFeatureCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceFeatureCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_FEATURE_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
    // added in cl1.0
    private static function ntv_GetEventInfo_1(&event: cl_event; param_name: clEventInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetEventInfo';
    private static function ntv_GetEventInfo_2(&event: cl_event; param_name: clEventInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetEventInfo';
    private static function ntv_GetEventInfo_3(&event: cl_event; param_name: clEventInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetEventInfo';
    private static function ntv_GetEventInfo_4(&event: cl_event; param_name: clEventInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetEventInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo<T>(&event: cl_event; param_name: clEventInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetEventInfo_1(&event, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo<T>(&event: cl_event; param_name: clEventInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetEventInfo_2(&event, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo_EVENT_COMMAND_QUEUE(&event: cl_event; var param_value: cl_command_queue; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_command_queue>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventInfo(&event, clEventInfo.EVENT_COMMAND_QUEUE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo_EVENT_COMMAND_TYPE(&event: cl_event; var param_value: clCommandType; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandType>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventInfo(&event, clEventInfo.EVENT_COMMAND_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo_EVENT_REFERENCE_COUNT(&event: cl_event; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventInfo(&event, clEventInfo.EVENT_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo_EVENT_COMMAND_EXECUTION_STATUS(&event: cl_event; var param_value: clCommandExecutionStatus; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandExecutionStatus>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventInfo(&event, clEventInfo.EVENT_COMMAND_EXECUTION_STATUS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo_EVENT_CONTEXT(&event: cl_event; var param_value: cl_context; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_context>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventInfo(&event, clEventInfo.EVENT_CONTEXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo_EVENT_COMMAND_TERMINATION_REASON(&event: cl_event; var param_value: clCommandTerminationReason; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandTerminationReason>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventInfo(&event, clEventInfo.EVENT_COMMAND_TERMINATION_REASON, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo(&event: cl_event; param_name: clEventInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetEventInfo_3(&event, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo(&event: cl_event; param_name: clEventInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetEventInfo_4(&event, param_name, param_value_size, param_value, param_value_size_ret);
    
    // added in cl1.0
    private static function ntv_GetEventProfilingInfo_1(&event: cl_event; param_name: clProfilingInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetEventProfilingInfo';
    private static function ntv_GetEventProfilingInfo_2(&event: cl_event; param_name: clProfilingInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetEventProfilingInfo';
    private static function ntv_GetEventProfilingInfo_3(&event: cl_event; param_name: clProfilingInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetEventProfilingInfo';
    private static function ntv_GetEventProfilingInfo_4(&event: cl_event; param_name: clProfilingInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetEventProfilingInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo<T>(&event: cl_event; param_name: clProfilingInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetEventProfilingInfo_1(&event, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo<T>(&event: cl_event; param_name: clProfilingInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetEventProfilingInfo_2(&event, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo_PROFILING_COMMAND_QUEUED(&event: cl_event; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventProfilingInfo(&event, clProfilingInfo.PROFILING_COMMAND_QUEUED, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo_PROFILING_COMMAND_SUBMIT(&event: cl_event; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventProfilingInfo(&event, clProfilingInfo.PROFILING_COMMAND_SUBMIT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo_PROFILING_COMMAND_START(&event: cl_event; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventProfilingInfo(&event, clProfilingInfo.PROFILING_COMMAND_START, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo_PROFILING_COMMAND_END(&event: cl_event; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventProfilingInfo(&event, clProfilingInfo.PROFILING_COMMAND_END, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo_PROFILING_COMMAND_COMPLETE(&event: cl_event; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventProfilingInfo(&event, clProfilingInfo.PROFILING_COMMAND_COMPLETE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo(&event: cl_event; param_name: clProfilingInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetEventProfilingInfo_3(&event, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo(&event: cl_event; param_name: clProfilingInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetEventProfilingInfo_4(&event, param_name, param_value_size, param_value, param_value_size_ret);
    
    // added in cl1.0
    private static function ntv_GetExtensionFunctionAddress_1(func_name: IntPtr): IntPtr;
      external 'OpenCL' name 'clGetExtensionFunctionAddress';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetExtensionFunctionAddress(func_name: string): IntPtr;
    begin
      var func_name_str_ptr := Marshal.StringToHGlobalAnsi(func_name);
      try
        Result := ntv_GetExtensionFunctionAddress_1(func_name_str_ptr);
      finally
        Marshal.FreeHGlobal(func_name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetExtensionFunctionAddress(func_name: IntPtr): IntPtr :=
      ntv_GetExtensionFunctionAddress_1(func_name);
    
    // added in cl1.2
    private static function ntv_GetExtensionFunctionAddressForPlatform_1(platform: cl_platform_id; func_name: IntPtr): IntPtr;
      external 'OpenCL' name 'clGetExtensionFunctionAddressForPlatform';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetExtensionFunctionAddressForPlatform(platform: cl_platform_id; func_name: string): IntPtr;
    begin
      var func_name_str_ptr := Marshal.StringToHGlobalAnsi(func_name);
      try
        Result := ntv_GetExtensionFunctionAddressForPlatform_1(platform, func_name_str_ptr);
      finally
        Marshal.FreeHGlobal(func_name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetExtensionFunctionAddressForPlatform(platform: cl_platform_id; func_name: IntPtr): IntPtr :=
      ntv_GetExtensionFunctionAddressForPlatform_1(platform, func_name);
    
    // added in cl2.1
    private static function ntv_GetHostTimer_1(device: cl_device_id; var host_timestamp: UInt64): clErrorCode;
      external 'OpenCL' name 'clGetHostTimer';
    private static function ntv_GetHostTimer_2(device: cl_device_id; host_timestamp: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetHostTimer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetHostTimer(device: cl_device_id; var host_timestamp: UInt64): clErrorCode :=
      ntv_GetHostTimer_1(device, host_timestamp);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetHostTimer(device: cl_device_id; host_timestamp: IntPtr): clErrorCode :=
      ntv_GetHostTimer_2(device, host_timestamp);
    
    // added in cl1.0
    private static function ntv_GetImageInfo_1(image: cl_mem; param_name: clImageInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetImageInfo';
    private static function ntv_GetImageInfo_2(image: cl_mem; param_name: clImageInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetImageInfo';
    private static function ntv_GetImageInfo_3(image: cl_mem; param_name: clImageInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetImageInfo';
    private static function ntv_GetImageInfo_4(image: cl_mem; param_name: clImageInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetImageInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo<T>(image: cl_mem; param_name: clImageInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetImageInfo_1(image, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo<T>(image: cl_mem; param_name: clImageInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetImageInfo_2(image, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_FORMAT(image: cl_mem; var param_value: cl_image_format; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_image_format>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_FORMAT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_ELEMENT_SIZE(image: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_ELEMENT_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_ROW_PITCH(image: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_ROW_PITCH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_SLICE_PITCH(image: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_SLICE_PITCH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_WIDTH(image: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_WIDTH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_HEIGHT(image: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_HEIGHT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_DEPTH(image: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_DEPTH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_ARRAY_SIZE(image: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_ARRAY_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_BUFFER(image: cl_mem; var param_value: cl_mem; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_mem>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_BUFFER, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_NUM_MIP_LEVELS(image: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_NUM_MIP_LEVELS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_NUM_SAMPLES(image: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_NUM_SAMPLES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_DX9_MEDIA_PLANE(image: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_DX9_MEDIA_PLANE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_D3D10_SUBRESOURCE(image: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_D3D10_SUBRESOURCE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_D3D11_SUBRESOURCE(image: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_D3D11_SUBRESOURCE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_DX9_PLANE(image: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_DX9_PLANE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_VA_API_PLANE(image: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_VA_API_PLANE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_EGL_YUV_PLANE(image: cl_mem; var param_value: Int32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<Int32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.EGL_YUV_PLANE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo(image: cl_mem; param_name: clImageInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetImageInfo_3(image, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo(image: cl_mem; param_name: clImageInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetImageInfo_4(image, param_name, param_value_size, param_value, param_value_size_ret);
    
    // added in cl1.2
    private static function ntv_GetKernelArgInfo_1(kernel: cl_kernel; arg_index: UInt32; param_name: clKernelArgInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelArgInfo';
    private static function ntv_GetKernelArgInfo_2(kernel: cl_kernel; arg_index: UInt32; param_name: clKernelArgInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelArgInfo';
    private static function ntv_GetKernelArgInfo_3(kernel: cl_kernel; arg_index: UInt32; param_name: clKernelArgInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelArgInfo';
    private static function ntv_GetKernelArgInfo_4(kernel: cl_kernel; arg_index: UInt32; param_name: clKernelArgInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelArgInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo<T>(kernel: cl_kernel; arg_index: UInt32; param_name: clKernelArgInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelArgInfo_1(kernel, arg_index, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo<T>(kernel: cl_kernel; arg_index: UInt32; param_name: clKernelArgInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelArgInfo_2(kernel, arg_index, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo(kernel: cl_kernel; arg_index: UInt32; param_name: clKernelArgInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetKernelArgInfo_3(kernel, arg_index, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo(kernel: cl_kernel; arg_index: UInt32; param_name: clKernelArgInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetKernelArgInfo_4(kernel, arg_index, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo_KERNEL_ARG_ADDRESS_QUALIFIER(kernel: cl_kernel; arg_index: UInt32; var param_value: clKernelArgAddressQualifier; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clKernelArgAddressQualifier>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelArgInfo(kernel, arg_index, clKernelArgInfo.KERNEL_ARG_ADDRESS_QUALIFIER, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo_KERNEL_ARG_ACCESS_QUALIFIER(kernel: cl_kernel; arg_index: UInt32; var param_value: clKernelArgAccessQualifier; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clKernelArgAccessQualifier>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelArgInfo(kernel, arg_index, clKernelArgInfo.KERNEL_ARG_ACCESS_QUALIFIER, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo_KERNEL_ARG_TYPE_NAME(kernel: cl_kernel; arg_index: UInt32; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetKernelArgInfo_3(kernel, arg_index, clKernelArgInfo.KERNEL_ARG_TYPE_NAME, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetKernelArgInfo_4(kernel, arg_index, clKernelArgInfo.KERNEL_ARG_TYPE_NAME, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo_KERNEL_ARG_TYPE_QUALIFIER(kernel: cl_kernel; arg_index: UInt32; var param_value: clKernelArgTypeQualifier; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clKernelArgTypeQualifier>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelArgInfo(kernel, arg_index, clKernelArgInfo.KERNEL_ARG_TYPE_QUALIFIER, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo_KERNEL_ARG_NAME(kernel: cl_kernel; arg_index: UInt32; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetKernelArgInfo_3(kernel, arg_index, clKernelArgInfo.KERNEL_ARG_NAME, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetKernelArgInfo_4(kernel, arg_index, clKernelArgInfo.KERNEL_ARG_NAME, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    
    // added in cl1.0
    private static function ntv_GetKernelInfo_1(kernel: cl_kernel; param_name: clKernelInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelInfo';
    private static function ntv_GetKernelInfo_2(kernel: cl_kernel; param_name: clKernelInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelInfo';
    private static function ntv_GetKernelInfo_3(kernel: cl_kernel; param_name: clKernelInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelInfo';
    private static function ntv_GetKernelInfo_4(kernel: cl_kernel; param_name: clKernelInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo<T>(kernel: cl_kernel; param_name: clKernelInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelInfo_1(kernel, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo<T>(kernel: cl_kernel; param_name: clKernelInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelInfo_2(kernel, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo(kernel: cl_kernel; param_name: clKernelInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetKernelInfo_3(kernel, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo(kernel: cl_kernel; param_name: clKernelInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetKernelInfo_4(kernel, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo_KERNEL_FUNCTION_NAME(kernel: cl_kernel; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetKernelInfo_3(kernel, clKernelInfo.KERNEL_FUNCTION_NAME, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetKernelInfo_4(kernel, clKernelInfo.KERNEL_FUNCTION_NAME, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo_KERNEL_NUM_ARGS(kernel: cl_kernel; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelInfo(kernel, clKernelInfo.KERNEL_NUM_ARGS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo_KERNEL_REFERENCE_COUNT(kernel: cl_kernel; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelInfo(kernel, clKernelInfo.KERNEL_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo_KERNEL_CONTEXT(kernel: cl_kernel; var param_value: cl_context; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_context>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelInfo(kernel, clKernelInfo.KERNEL_CONTEXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo_KERNEL_PROGRAM(kernel: cl_kernel; var param_value: cl_program; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_program>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelInfo(kernel, clKernelInfo.KERNEL_PROGRAM, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo_KERNEL_ATTRIBUTES(kernel: cl_kernel; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetKernelInfo_3(kernel, clKernelInfo.KERNEL_ATTRIBUTES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetKernelInfo_4(kernel, clKernelInfo.KERNEL_ATTRIBUTES, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo_KERNEL_MAX_WARP_COUNT(kernel: cl_kernel; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelInfo(kernel, clKernelInfo.KERNEL_MAX_WARP_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
    // added in cl2.1
    private static function ntv_GetKernelSubGroupInfo_1(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: Byte; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelSubGroupInfo';
    private static function ntv_GetKernelSubGroupInfo_2(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: Byte; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelSubGroupInfo';
    private static function ntv_GetKernelSubGroupInfo_3(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: Byte; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelSubGroupInfo';
    private static function ntv_GetKernelSubGroupInfo_4(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: Byte; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelSubGroupInfo';
    private static function ntv_GetKernelSubGroupInfo_5(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelSubGroupInfo';
    private static function ntv_GetKernelSubGroupInfo_6(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelSubGroupInfo';
    private static function ntv_GetKernelSubGroupInfo_7(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelSubGroupInfo';
    private static function ntv_GetKernelSubGroupInfo_8(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelSubGroupInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo<TInp,T>(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: TInp; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where TInp, T: record;
    begin
      Result := ntv_GetKernelSubGroupInfo_1(kernel, device, param_name, input_value_size, PByte(pointer(@input_value))^, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo<TInp,T>(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: TInp; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where TInp, T: record;
    begin
      Result := ntv_GetKernelSubGroupInfo_2(kernel, device, param_name, input_value_size, PByte(pointer(@input_value))^, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo<TInp>(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: TInp; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode; where TInp: record;
    begin
      Result := ntv_GetKernelSubGroupInfo_3(kernel, device, param_name, input_value_size, PByte(pointer(@input_value))^, param_value_size, param_value, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo<TInp>(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: TInp; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode; where TInp: record;
    begin
      Result := ntv_GetKernelSubGroupInfo_4(kernel, device, param_name, input_value_size, PByte(pointer(@input_value))^, param_value_size, param_value, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo<T>(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelSubGroupInfo_5(kernel, device, param_name, input_value_size, input_value, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo<T>(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelSubGroupInfo_6(kernel, device, param_name, input_value_size, input_value, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetKernelSubGroupInfo_7(kernel, device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetKernelSubGroupInfo_8(kernel, device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT(kernel: cl_kernel; device: cl_device_id; input_value: UIntPtr; var param_value: array of UIntPtr): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_sz: UIntPtr;
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT, input_value_sz,input_value, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new UIntPtr[param_value_sz.ToUInt64 div Marshal.SizeOf&<UIntPtr>];
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT, input_value_sz,input_value, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT(kernel: cl_kernel; device: cl_device_id; input_value: UIntPtr; param_value_count: UInt32; var param_value: UIntPtr): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UIntPtr>);
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT, input_value_sz,input_value, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_MAX_NUM_SUB_GROUPS(kernel: cl_kernel; device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_MAX_NUM_SUB_GROUPS, UIntPtr.Zero,nil, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_COMPILE_NUM_SUB_GROUPS(kernel: cl_kernel; device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_COMPILE_NUM_SUB_GROUPS, UIntPtr.Zero,nil, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE(kernel: cl_kernel; device: cl_device_id; input_value: array of UIntPtr; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(input_value.Length*Marshal.SizeOf&<UIntPtr>);
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE, input_value_sz,input_value[0], param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE(kernel: cl_kernel; device: cl_device_id; input_value_count: UInt32; var input_value: UIntPtr; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(input_value_count*Marshal.SizeOf&<UIntPtr>);
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE, input_value_sz,input_value, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE(kernel: cl_kernel; device: cl_device_id; input_value: array of UIntPtr; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(input_value.Length*Marshal.SizeOf&<UIntPtr>);
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE, input_value_sz,input_value[0], param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE(kernel: cl_kernel; device: cl_device_id; input_value_count: UInt32; var input_value: UIntPtr; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(input_value_count*Marshal.SizeOf&<UIntPtr>);
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE, input_value_sz,input_value, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_COMPILE_SUB_GROUP_SIZE(kernel: cl_kernel; device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_COMPILE_SUB_GROUP_SIZE, UIntPtr.Zero,nil, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
    // added in cl1.0
    private static function ntv_GetKernelWorkGroupInfo_1(kernel: cl_kernel; device: cl_device_id; param_name: clKernelWorkGroupInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelWorkGroupInfo';
    private static function ntv_GetKernelWorkGroupInfo_2(kernel: cl_kernel; device: cl_device_id; param_name: clKernelWorkGroupInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelWorkGroupInfo';
    private static function ntv_GetKernelWorkGroupInfo_3(kernel: cl_kernel; device: cl_device_id; param_name: clKernelWorkGroupInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelWorkGroupInfo';
    private static function ntv_GetKernelWorkGroupInfo_4(kernel: cl_kernel; device: cl_device_id; param_name: clKernelWorkGroupInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetKernelWorkGroupInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo<T>(kernel: cl_kernel; device: cl_device_id; param_name: clKernelWorkGroupInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelWorkGroupInfo_1(kernel, device, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo<T>(kernel: cl_kernel; device: cl_device_id; param_name: clKernelWorkGroupInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelWorkGroupInfo_2(kernel, device, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_WORK_GROUP_SIZE(kernel: cl_kernel; device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_WORK_GROUP_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_COMPILE_WORK_GROUP_SIZE(kernel: cl_kernel; device: cl_device_id; var param_value: array of UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(3*Marshal.SizeOf&<UIntPtr>);
      var param_value_temp_res := new UIntPtr[3];
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_COMPILE_WORK_GROUP_SIZE, param_value_sz,param_value_temp_res[0],param_value_ret_size);
      param_value := param_value_temp_res;
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_COMPILE_WORK_GROUP_SIZE(kernel: cl_kernel; device: cl_device_id; param_value_count: UInt32; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_COMPILE_WORK_GROUP_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_LOCAL_MEM_SIZE(kernel: cl_kernel; device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_LOCAL_MEM_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE(kernel: cl_kernel; device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_PRIVATE_MEM_SIZE(kernel: cl_kernel; device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_PRIVATE_MEM_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_GLOBAL_WORK_SIZE(kernel: cl_kernel; device: cl_device_id; var param_value: array of UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(3*Marshal.SizeOf&<UIntPtr>);
      var param_value_temp_res := new UIntPtr[3];
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_GLOBAL_WORK_SIZE, param_value_sz,param_value_temp_res[0],param_value_ret_size);
      param_value := param_value_temp_res;
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_GLOBAL_WORK_SIZE(kernel: cl_kernel; device: cl_device_id; param_value_count: UInt32; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_GLOBAL_WORK_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_SPILL_MEM_SIZE(kernel: cl_kernel; device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_SPILL_MEM_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo(kernel: cl_kernel; device: cl_device_id; param_name: clKernelWorkGroupInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetKernelWorkGroupInfo_3(kernel, device, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo(kernel: cl_kernel; device: cl_device_id; param_name: clKernelWorkGroupInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetKernelWorkGroupInfo_4(kernel, device, param_name, param_value_size, param_value, param_value_size_ret);
    
    // added in cl1.0
    private static function ntv_GetMemObjectInfo_1(memobj: cl_mem; param_name: clMemInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetMemObjectInfo';
    private static function ntv_GetMemObjectInfo_2(memobj: cl_mem; param_name: clMemInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetMemObjectInfo';
    private static function ntv_GetMemObjectInfo_3(memobj: cl_mem; param_name: clMemInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetMemObjectInfo';
    private static function ntv_GetMemObjectInfo_4(memobj: cl_mem; param_name: clMemInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetMemObjectInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo<T>(memobj: cl_mem; param_name: clMemInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetMemObjectInfo_1(memobj, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo<T>(memobj: cl_mem; param_name: clMemInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetMemObjectInfo_2(memobj, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo(memobj: cl_mem; param_name: clMemInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetMemObjectInfo_3(memobj, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo(memobj: cl_mem; param_name: clMemInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetMemObjectInfo_4(memobj, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_TYPE(memobj: cl_mem; var param_value: clMemObjectType; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clMemObjectType>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_FLAGS(memobj: cl_mem; var param_value: clMemFlags; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clMemFlags>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_FLAGS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_SIZE(memobj: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_HOST_PTR(memobj: cl_mem; var param_value: IntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<IntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_HOST_PTR, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_MAP_COUNT(memobj: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_MAP_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_REFERENCE_COUNT(memobj: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_CONTEXT(memobj: cl_mem; var param_value: cl_context; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_context>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_CONTEXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_ASSOCIATED_MEMOBJECT(memobj: cl_mem; var param_value: cl_mem; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_mem>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_ASSOCIATED_MEMOBJECT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_OFFSET(memobj: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_OFFSET, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_USES_SVM_POINTER(memobj: cl_mem; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_USES_SVM_POINTER, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_PROPERTIES(memobj: cl_mem; var param_value: array of clMemProperties): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetMemObjectInfo_3(memobj, clMemInfo.MEM_PROPERTIES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clMemProperties[param_value_sz.ToUInt64 div Marshal.SizeOf&<clMemProperties>];
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_PROPERTIES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_PROPERTIES(memobj: cl_mem; param_value_count: UInt32; var param_value: clMemProperties): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clMemProperties>);
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_PROPERTIES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_DEVICE_PTR(memobj: cl_mem; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_DEVICE_PTR, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_DEVICE_PTRS(memobj: cl_mem; var param_value: cl_mem_device_address_pair; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_mem_device_address_pair>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_DEVICE_PTRS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_DX9_MEDIA_ADAPTER_TYPE(memobj: cl_mem; var param_value: clDx9MediaAdapterType; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDx9MediaAdapterType>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_DX9_MEDIA_ADAPTER_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_DX9_MEDIA_SURFACE_INFO(memobj: cl_mem; var param_value: cl_dx9_surface_info; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_dx9_surface_info>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_DX9_MEDIA_SURFACE_INFO, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_D3D10_RESOURCE(memobj: cl_mem; var param_value: IntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<IntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_D3D10_RESOURCE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_D3D11_RESOURCE(memobj: cl_mem; var param_value: IntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<IntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_D3D11_RESOURCE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_DX9_RESOURCE(memobj: cl_mem; var param_value: IntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<IntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_DX9_RESOURCE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_DX9_SHARED_HANDLE(memobj: cl_mem; var param_value: IntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<IntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_DX9_SHARED_HANDLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_VA_API_MEDIA_SURFACE(memobj: cl_mem; var param_value: IntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<IntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_VA_API_MEDIA_SURFACE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_USES_SVM_POINTER_ARM(memobj: cl_mem; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_USES_SVM_POINTER_ARM, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
    // added in cl2.0
    private static function ntv_GetPipeInfo_1(pipe: cl_mem; param_name: clPipeInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetPipeInfo';
    private static function ntv_GetPipeInfo_2(pipe: cl_mem; param_name: clPipeInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetPipeInfo';
    private static function ntv_GetPipeInfo_3(pipe: cl_mem; param_name: clPipeInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetPipeInfo';
    private static function ntv_GetPipeInfo_4(pipe: cl_mem; param_name: clPipeInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetPipeInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPipeInfo<T>(pipe: cl_mem; param_name: clPipeInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetPipeInfo_1(pipe, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPipeInfo<T>(pipe: cl_mem; param_name: clPipeInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetPipeInfo_2(pipe, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPipeInfo_PIPE_PACKET_SIZE(pipe: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetPipeInfo(pipe, clPipeInfo.PIPE_PACKET_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPipeInfo_PIPE_MAX_PACKETS(pipe: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetPipeInfo(pipe, clPipeInfo.PIPE_MAX_PACKETS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPipeInfo_PIPE_PROPERTIES(pipe: cl_mem; var param_value: IntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<IntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetPipeInfo(pipe, clPipeInfo.PIPE_PROPERTIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPipeInfo(pipe: cl_mem; param_name: clPipeInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetPipeInfo_3(pipe, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPipeInfo(pipe: cl_mem; param_name: clPipeInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetPipeInfo_4(pipe, param_name, param_value_size, param_value, param_value_size_ret);
    
    // added in cl1.0
    private static function ntv_GetPlatformIDs_1(num_entries: UInt32; var platforms: cl_platform_id; var num_platforms: UInt32): clErrorCode;
      external 'OpenCL' name 'clGetPlatformIDs';
    private static function ntv_GetPlatformIDs_2(num_entries: UInt32; var platforms: cl_platform_id; num_platforms: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetPlatformIDs';
    private static function ntv_GetPlatformIDs_3(num_entries: UInt32; platforms: IntPtr; var num_platforms: UInt32): clErrorCode;
      external 'OpenCL' name 'clGetPlatformIDs';
    private static function ntv_GetPlatformIDs_4(num_entries: UInt32; platforms: IntPtr; num_platforms: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetPlatformIDs';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformIDs(num_entries: UInt32; var platforms: cl_platform_id; var num_platforms: UInt32): clErrorCode :=
      ntv_GetPlatformIDs_1(num_entries, platforms, num_platforms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformIDs(num_entries: UInt32; var platforms: cl_platform_id; num_platforms: IntPtr): clErrorCode :=
      ntv_GetPlatformIDs_2(num_entries, platforms, num_platforms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformIDs(num_entries: UInt32; platforms: IntPtr; var num_platforms: UInt32): clErrorCode :=
      ntv_GetPlatformIDs_3(num_entries, platforms, num_platforms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformIDs(num_entries: UInt32; platforms: IntPtr; num_platforms: IntPtr): clErrorCode :=
      ntv_GetPlatformIDs_4(num_entries, platforms, num_platforms);
    
    // added in cl1.0
    private static function ntv_GetPlatformInfo_1(platform: cl_platform_id; param_name: clPlatformInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetPlatformInfo';
    private static function ntv_GetPlatformInfo_2(platform: cl_platform_id; param_name: clPlatformInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetPlatformInfo';
    private static function ntv_GetPlatformInfo_3(platform: cl_platform_id; param_name: clPlatformInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetPlatformInfo';
    private static function ntv_GetPlatformInfo_4(platform: cl_platform_id; param_name: clPlatformInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetPlatformInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo<T>(platform: cl_platform_id; param_name: clPlatformInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetPlatformInfo_1(platform, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo<T>(platform: cl_platform_id; param_name: clPlatformInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetPlatformInfo_2(platform, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo(platform: cl_platform_id; param_name: clPlatformInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetPlatformInfo_3(platform, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo(platform: cl_platform_id; param_name: clPlatformInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetPlatformInfo_4(platform, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_PROFILE(platform: cl_platform_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_PROFILE, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetPlatformInfo_4(platform, clPlatformInfo.PLATFORM_PROFILE, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_VERSION(platform: cl_platform_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetPlatformInfo_4(platform, clPlatformInfo.PLATFORM_VERSION, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_NAME(platform: cl_platform_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_NAME, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetPlatformInfo_4(platform, clPlatformInfo.PLATFORM_NAME, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_VENDOR(platform: cl_platform_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_VENDOR, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetPlatformInfo_4(platform, clPlatformInfo.PLATFORM_VENDOR, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_EXTENSIONS(platform: cl_platform_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_EXTENSIONS, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetPlatformInfo_4(platform, clPlatformInfo.PLATFORM_EXTENSIONS, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_HOST_TIMER_RESOLUTION(platform: cl_platform_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_HOST_TIMER_RESOLUTION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_NUMERIC_VERSION(platform: cl_platform_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_NUMERIC_VERSION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_EXTENSIONS_WITH_VERSION(platform: cl_platform_id; var param_value: array of cl_name_version): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_EXTENSIONS_WITH_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_name_version[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_name_version>];
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_EXTENSIONS_WITH_VERSION, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_EXTENSIONS_WITH_VERSION(platform: cl_platform_id; param_value_count: UInt32; var param_value: cl_name_version): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_name_version>);
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_EXTENSIONS_WITH_VERSION, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_COMMAND_BUFFER_CAPABILITIES(platform: cl_platform_id; var param_value: clPlatformCommandBufferCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clPlatformCommandBufferCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_COMMAND_BUFFER_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_ICD_SUFFIX(platform: cl_platform_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_ICD_SUFFIX, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetPlatformInfo_4(platform, clPlatformInfo.PLATFORM_ICD_SUFFIX, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_SEMAPHORE_TYPES(platform: cl_platform_id; var param_value: array of clSemaphoreType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_SEMAPHORE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clSemaphoreType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clSemaphoreType>];
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_SEMAPHORE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_SEMAPHORE_TYPES(platform: cl_platform_id; param_value_count: UInt32; var param_value: clSemaphoreType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clSemaphoreType>);
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_SEMAPHORE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES(platform: cl_platform_id; var param_value: array of clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clExternalSemaphoreHandleType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clExternalSemaphoreHandleType>];
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES(platform: cl_platform_id; param_value_count: UInt32; var param_value: clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clExternalSemaphoreHandleType>);
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES(platform: cl_platform_id; var param_value: array of clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clExternalSemaphoreHandleType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clExternalSemaphoreHandleType>];
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES(platform: cl_platform_id; param_value_count: UInt32; var param_value: clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clExternalSemaphoreHandleType>);
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES(platform: cl_platform_id; var param_value: array of clExternalMemoryHandleType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clExternalMemoryHandleType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clExternalMemoryHandleType>];
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES(platform: cl_platform_id; param_value_count: UInt32; var param_value: clExternalMemoryHandleType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clExternalMemoryHandleType>);
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    
    // added in cl1.0
    private static function ntv_GetProgramBuildInfo_1(&program: cl_program; device: cl_device_id; param_name: clProgramBuildInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetProgramBuildInfo';
    private static function ntv_GetProgramBuildInfo_2(&program: cl_program; device: cl_device_id; param_name: clProgramBuildInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetProgramBuildInfo';
    private static function ntv_GetProgramBuildInfo_3(&program: cl_program; device: cl_device_id; param_name: clProgramBuildInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetProgramBuildInfo';
    private static function ntv_GetProgramBuildInfo_4(&program: cl_program; device: cl_device_id; param_name: clProgramBuildInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetProgramBuildInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo<T>(&program: cl_program; device: cl_device_id; param_name: clProgramBuildInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetProgramBuildInfo_1(&program, device, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo<T>(&program: cl_program; device: cl_device_id; param_name: clProgramBuildInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetProgramBuildInfo_2(&program, device, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo(&program: cl_program; device: cl_device_id; param_name: clProgramBuildInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetProgramBuildInfo_3(&program, device, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo(&program: cl_program; device: cl_device_id; param_name: clProgramBuildInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetProgramBuildInfo_4(&program, device, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo_PROGRAM_BUILD_STATUS(&program: cl_program; device: cl_device_id; var param_value: clBuildStatus; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBuildStatus>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramBuildInfo(&program, device, clProgramBuildInfo.PROGRAM_BUILD_STATUS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo_PROGRAM_BUILD_OPTIONS(&program: cl_program; device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetProgramBuildInfo_3(&program, device, clProgramBuildInfo.PROGRAM_BUILD_OPTIONS, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetProgramBuildInfo_4(&program, device, clProgramBuildInfo.PROGRAM_BUILD_OPTIONS, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo_PROGRAM_BUILD_LOG(&program: cl_program; device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetProgramBuildInfo_3(&program, device, clProgramBuildInfo.PROGRAM_BUILD_LOG, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetProgramBuildInfo_4(&program, device, clProgramBuildInfo.PROGRAM_BUILD_LOG, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo_PROGRAM_BINARY_TYPE(&program: cl_program; device: cl_device_id; var param_value: clProgramBinaryType; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clProgramBinaryType>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramBuildInfo(&program, device, clProgramBuildInfo.PROGRAM_BINARY_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo_PROGRAM_BUILD_GLOBAL_VARIABLE_TOTAL_SIZE(&program: cl_program; device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramBuildInfo(&program, device, clProgramBuildInfo.PROGRAM_BUILD_GLOBAL_VARIABLE_TOTAL_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
    // added in cl1.0
    private static function ntv_GetProgramInfo_1(&program: cl_program; param_name: clProgramInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetProgramInfo';
    private static function ntv_GetProgramInfo_2(&program: cl_program; param_name: clProgramInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetProgramInfo';
    private static function ntv_GetProgramInfo_3(&program: cl_program; param_name: clProgramInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetProgramInfo';
    private static function ntv_GetProgramInfo_4(&program: cl_program; param_name: clProgramInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetProgramInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo<T>(&program: cl_program; param_name: clProgramInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetProgramInfo_1(&program, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo<T>(&program: cl_program; param_name: clProgramInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetProgramInfo_2(&program, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo(&program: cl_program; param_name: clProgramInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetProgramInfo_3(&program, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo(&program: cl_program; param_name: clProgramInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetProgramInfo_4(&program, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_REFERENCE_COUNT(&program: cl_program; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_CONTEXT(&program: cl_program; var param_value: cl_context; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_context>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_CONTEXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_NUM_DEVICES(&program: cl_program; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_NUM_DEVICES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_DEVICES(&program: cl_program; var param_value: array of cl_device_id): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetProgramInfo_3(&program, clProgramInfo.PROGRAM_DEVICES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_device_id[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_device_id>];
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_DEVICES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_DEVICES(&program: cl_program; param_value_count: UInt32; var param_value: cl_device_id): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_device_id>);
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_DEVICES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_SOURCE(&program: cl_program; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetProgramInfo_3(&program, clProgramInfo.PROGRAM_SOURCE, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetProgramInfo_4(&program, clProgramInfo.PROGRAM_SOURCE, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_BINARY_SIZES(&program: cl_program; var param_value: array of UIntPtr): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetProgramInfo_3(&program, clProgramInfo.PROGRAM_BINARY_SIZES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new UIntPtr[param_value_sz.ToUInt64 div Marshal.SizeOf&<UIntPtr>];
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_BINARY_SIZES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_BINARY_SIZES(&program: cl_program; param_value_count: UInt32; var param_value: UIntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UIntPtr>);
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_BINARY_SIZES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_BINARIES(&program: cl_program; param_value_count: UInt32; var param_value: IntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<IntPtr>);
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_BINARIES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_NUM_KERNELS(&program: cl_program; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_NUM_KERNELS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_KERNEL_NAMES(&program: cl_program; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetProgramInfo_3(&program, clProgramInfo.PROGRAM_KERNEL_NAMES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetProgramInfo_4(&program, clProgramInfo.PROGRAM_KERNEL_NAMES, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_IL(&program: cl_program; var param_value: array of Byte): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetProgramInfo_3(&program, clProgramInfo.PROGRAM_IL, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new Byte[param_value_sz.ToUInt64 div Marshal.SizeOf&<Byte>];
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_IL, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_IL(&program: cl_program; param_value_count: UInt32; var param_value: Byte): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<Byte>);
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_IL, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_SCOPE_GLOBAL_CTORS_PRESENT(&program: cl_program; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_SCOPE_GLOBAL_CTORS_PRESENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_SCOPE_GLOBAL_DTORS_PRESENT(&program: cl_program; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_SCOPE_GLOBAL_DTORS_PRESENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_NUM_HOST_PIPES(&program: cl_program; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_NUM_HOST_PIPES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_HOST_PIPE_NAMES(&program: cl_program; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetProgramInfo_3(&program, clProgramInfo.PROGRAM_HOST_PIPE_NAMES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetProgramInfo_4(&program, clProgramInfo.PROGRAM_HOST_PIPE_NAMES, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    
    // added in cl1.0
    private static function ntv_GetSamplerInfo_1(sampler: cl_sampler; param_name: clSamplerInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetSamplerInfo';
    private static function ntv_GetSamplerInfo_2(sampler: cl_sampler; param_name: clSamplerInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetSamplerInfo';
    private static function ntv_GetSamplerInfo_3(sampler: cl_sampler; param_name: clSamplerInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
      external 'OpenCL' name 'clGetSamplerInfo';
    private static function ntv_GetSamplerInfo_4(sampler: cl_sampler; param_name: clSamplerInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetSamplerInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo<T>(sampler: cl_sampler; param_name: clSamplerInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetSamplerInfo_1(sampler, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo<T>(sampler: cl_sampler; param_name: clSamplerInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetSamplerInfo_2(sampler, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo(sampler: cl_sampler; param_name: clSamplerInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetSamplerInfo_3(sampler, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo(sampler: cl_sampler; param_name: clSamplerInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetSamplerInfo_4(sampler, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_REFERENCE_COUNT(sampler: cl_sampler; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_CONTEXT(sampler: cl_sampler; var param_value: cl_context; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_context>);
      var param_value_ret_size: UIntPtr;
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_CONTEXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_NORMALIZED_COORDS(sampler: cl_sampler; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_NORMALIZED_COORDS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_ADDRESSING_MODE(sampler: cl_sampler; var param_value: clAddressingMode; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clAddressingMode>);
      var param_value_ret_size: UIntPtr;
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_ADDRESSING_MODE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_FILTER_MODE(sampler: cl_sampler; var param_value: clFilterMode; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clFilterMode>);
      var param_value_ret_size: UIntPtr;
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_FILTER_MODE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_MIP_FILTER_MODE(sampler: cl_sampler; var param_value: clFilterMode; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clFilterMode>);
      var param_value_ret_size: UIntPtr;
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_MIP_FILTER_MODE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_LOD_MIN(sampler: cl_sampler; var param_value: single; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<single>);
      var param_value_ret_size: UIntPtr;
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_LOD_MIN, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_LOD_MAX(sampler: cl_sampler; var param_value: single; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<single>);
      var param_value_ret_size: UIntPtr;
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_LOD_MAX, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_PROPERTIES(sampler: cl_sampler; var param_value: array of clSamplerProperties): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetSamplerInfo_3(sampler, clSamplerInfo.SAMPLER_PROPERTIES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clSamplerProperties[param_value_sz.ToUInt64 div Marshal.SizeOf&<clSamplerProperties>];
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_PROPERTIES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_PROPERTIES(sampler: cl_sampler; param_value_count: UInt32; var param_value: clSamplerProperties): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clSamplerProperties>);
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_PROPERTIES, param_value_sz,param_value,IntPtr.Zero);
    end;
    
    // added in cl1.0
    private static function ntv_GetSupportedImageFormats_1(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; var image_formats: cl_image_format; var num_image_formats: UInt32): clErrorCode;
      external 'OpenCL' name 'clGetSupportedImageFormats';
    private static function ntv_GetSupportedImageFormats_2(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; var image_formats: cl_image_format; num_image_formats: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetSupportedImageFormats';
    private static function ntv_GetSupportedImageFormats_3(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; image_formats: IntPtr; var num_image_formats: UInt32): clErrorCode;
      external 'OpenCL' name 'clGetSupportedImageFormats';
    private static function ntv_GetSupportedImageFormats_4(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; image_formats: IntPtr; num_image_formats: IntPtr): clErrorCode;
      external 'OpenCL' name 'clGetSupportedImageFormats';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSupportedImageFormats(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; var image_formats: cl_image_format; var num_image_formats: UInt32): clErrorCode :=
      ntv_GetSupportedImageFormats_1(context, flags, image_type, num_entries, image_formats, num_image_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSupportedImageFormats(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; var image_formats: cl_image_format; num_image_formats: IntPtr): clErrorCode :=
      ntv_GetSupportedImageFormats_2(context, flags, image_type, num_entries, image_formats, num_image_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSupportedImageFormats(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; image_formats: IntPtr; var num_image_formats: UInt32): clErrorCode :=
      ntv_GetSupportedImageFormats_3(context, flags, image_type, num_entries, image_formats, num_image_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSupportedImageFormats(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; image_formats: IntPtr; num_image_formats: IntPtr): clErrorCode :=
      ntv_GetSupportedImageFormats_4(context, flags, image_type, num_entries, image_formats, num_image_formats);
    
    // added in cl1.2
    private static function ntv_LinkProgram_1(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_programs: UInt32; var input_programs: cl_program; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
      external 'OpenCL' name 'clLinkProgram';
    private static function ntv_LinkProgram_2(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_programs: UInt32; input_programs: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
      external 'OpenCL' name 'clLinkProgram';
    private static function ntv_LinkProgram_3(context: cl_context; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_programs: UInt32; var input_programs: cl_program; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
      external 'OpenCL' name 'clLinkProgram';
    private static function ntv_LinkProgram_4(context: cl_context; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_programs: UInt32; input_programs: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
      external 'OpenCL' name 'clLinkProgram';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; device_list: array of cl_device_id; options: string; num_input_programs: UInt32; input_programs: array of cl_program; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := LinkProgram(context, num_devices, device_list, options_str_ptr, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; device_list: array of cl_device_id; options: IntPtr; num_input_programs: UInt32; input_programs: array of cl_program; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
      type PCl_device_id = ^cl_device_id;
      type PCl_program = ^cl_program;
    begin
      Result := if (input_programs<>nil) and (input_programs.Length<>0) then
        if (device_list<>nil) and (device_list.Length<>0) then
          ntv_LinkProgram_1(context, num_devices, device_list[0], options, num_input_programs, input_programs[0], pfn_notify, user_data, errcode_ret) else
          ntv_LinkProgram_1(context, num_devices, PCl_device_id(nil)^, options, num_input_programs, input_programs[0], pfn_notify, user_data, errcode_ret) else
        if (device_list<>nil) and (device_list.Length<>0) then
          ntv_LinkProgram_1(context, num_devices, device_list[0], options, num_input_programs, PCl_program(nil)^, pfn_notify, user_data, errcode_ret) else
          ntv_LinkProgram_1(context, num_devices, PCl_device_id(nil)^, options, num_input_programs, PCl_program(nil)^, pfn_notify, user_data, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; options: string; num_input_programs: UInt32; var input_programs: cl_program; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_LinkProgram_1(context, num_devices, device_list, options_str_ptr, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; options: string; num_input_programs: UInt32; input_programs: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_LinkProgram_2(context, num_devices, device_list, options_str_ptr, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_programs: UInt32; var input_programs: cl_program; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_LinkProgram_1(context, num_devices, device_list, options, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_programs: UInt32; input_programs: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_LinkProgram_2(context, num_devices, device_list, options, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; device_list: IntPtr; options: string; num_input_programs: UInt32; var input_programs: cl_program; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_LinkProgram_3(context, num_devices, device_list, options_str_ptr, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; device_list: IntPtr; options: string; num_input_programs: UInt32; input_programs: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_LinkProgram_4(context, num_devices, device_list, options_str_ptr, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_programs: UInt32; var input_programs: cl_program; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_LinkProgram_3(context, num_devices, device_list, options, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_programs: UInt32; input_programs: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_LinkProgram_4(context, num_devices, device_list, options, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
    
    // added in cl1.0
    private static function ntv_ReleaseCommandQueue_1(command_queue: cl_command_queue): clErrorCode;
      external 'OpenCL' name 'clReleaseCommandQueue';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ReleaseCommandQueue(command_queue: cl_command_queue): clErrorCode :=
      ntv_ReleaseCommandQueue_1(command_queue);
    
    // added in cl1.0
    private static function ntv_ReleaseContext_1(context: cl_context): clErrorCode;
      external 'OpenCL' name 'clReleaseContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ReleaseContext(context: cl_context): clErrorCode :=
      ntv_ReleaseContext_1(context);
    
    // added in cl1.2
    private static function ntv_ReleaseDevice_1(device: cl_device_id): clErrorCode;
      external 'OpenCL' name 'clReleaseDevice';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ReleaseDevice(device: cl_device_id): clErrorCode :=
      ntv_ReleaseDevice_1(device);
    
    // added in cl1.0
    private static function ntv_ReleaseEvent_1(&event: cl_event): clErrorCode;
      external 'OpenCL' name 'clReleaseEvent';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ReleaseEvent(&event: cl_event): clErrorCode :=
      ntv_ReleaseEvent_1(&event);
    
    // added in cl1.0
    private static function ntv_ReleaseKernel_1(kernel: cl_kernel): clErrorCode;
      external 'OpenCL' name 'clReleaseKernel';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ReleaseKernel(kernel: cl_kernel): clErrorCode :=
      ntv_ReleaseKernel_1(kernel);
    
    // added in cl1.0
    private static function ntv_ReleaseMemObject_1(memobj: cl_mem): clErrorCode;
      external 'OpenCL' name 'clReleaseMemObject';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ReleaseMemObject(memobj: cl_mem): clErrorCode :=
      ntv_ReleaseMemObject_1(memobj);
    
    // added in cl1.0
    private static function ntv_ReleaseProgram_1(&program: cl_program): clErrorCode;
      external 'OpenCL' name 'clReleaseProgram';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ReleaseProgram(&program: cl_program): clErrorCode :=
      ntv_ReleaseProgram_1(&program);
    
    // added in cl1.0
    private static function ntv_ReleaseSampler_1(sampler: cl_sampler): clErrorCode;
      external 'OpenCL' name 'clReleaseSampler';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ReleaseSampler(sampler: cl_sampler): clErrorCode :=
      ntv_ReleaseSampler_1(sampler);
    
    // added in cl1.0
    private static function ntv_RetainCommandQueue_1(command_queue: cl_command_queue): clErrorCode;
      external 'OpenCL' name 'clRetainCommandQueue';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RetainCommandQueue(command_queue: cl_command_queue): clErrorCode :=
      ntv_RetainCommandQueue_1(command_queue);
    
    // added in cl1.0
    private static function ntv_RetainContext_1(context: cl_context): clErrorCode;
      external 'OpenCL' name 'clRetainContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RetainContext(context: cl_context): clErrorCode :=
      ntv_RetainContext_1(context);
    
    // added in cl1.2
    private static function ntv_RetainDevice_1(device: cl_device_id): clErrorCode;
      external 'OpenCL' name 'clRetainDevice';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RetainDevice(device: cl_device_id): clErrorCode :=
      ntv_RetainDevice_1(device);
    
    // added in cl1.0
    private static function ntv_RetainEvent_1(&event: cl_event): clErrorCode;
      external 'OpenCL' name 'clRetainEvent';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RetainEvent(&event: cl_event): clErrorCode :=
      ntv_RetainEvent_1(&event);
    
    // added in cl1.0
    private static function ntv_RetainKernel_1(kernel: cl_kernel): clErrorCode;
      external 'OpenCL' name 'clRetainKernel';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RetainKernel(kernel: cl_kernel): clErrorCode :=
      ntv_RetainKernel_1(kernel);
    
    // added in cl1.0
    private static function ntv_RetainMemObject_1(memobj: cl_mem): clErrorCode;
      external 'OpenCL' name 'clRetainMemObject';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RetainMemObject(memobj: cl_mem): clErrorCode :=
      ntv_RetainMemObject_1(memobj);
    
    // added in cl1.0
    private static function ntv_RetainProgram_1(&program: cl_program): clErrorCode;
      external 'OpenCL' name 'clRetainProgram';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RetainProgram(&program: cl_program): clErrorCode :=
      ntv_RetainProgram_1(&program);
    
    // added in cl1.0
    private static function ntv_RetainSampler_1(sampler: cl_sampler): clErrorCode;
      external 'OpenCL' name 'clRetainSampler';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RetainSampler(sampler: cl_sampler): clErrorCode :=
      ntv_RetainSampler_1(sampler);
    
    // added in cl1.0
    private static function ntv_SetCommandQueueProperty_1(command_queue: cl_command_queue; properties: clCommandQueueProperties; enable: clBool; var old_properties: clCommandQueueProperties): clErrorCode;
      external 'OpenCL' name 'clSetCommandQueueProperty';
    private static function ntv_SetCommandQueueProperty_2(command_queue: cl_command_queue; properties: clCommandQueueProperties; enable: clBool; old_properties: IntPtr): clErrorCode;
      external 'OpenCL' name 'clSetCommandQueueProperty';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetCommandQueueProperty(command_queue: cl_command_queue; properties: clCommandQueueProperties; enable: clBool; old_properties: array of clCommandQueueProperties): clErrorCode;
      type PClCommandQueueProperties = ^clCommandQueueProperties;
    begin
      Result := if (old_properties<>nil) and (old_properties.Length<>0) then
        ntv_SetCommandQueueProperty_1(command_queue, properties, enable, old_properties[0]) else
        ntv_SetCommandQueueProperty_1(command_queue, properties, enable, PClCommandQueueProperties(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetCommandQueueProperty(command_queue: cl_command_queue; properties: clCommandQueueProperties; enable: clBool; var old_properties: clCommandQueueProperties): clErrorCode :=
      ntv_SetCommandQueueProperty_1(command_queue, properties, enable, old_properties);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetCommandQueueProperty(command_queue: cl_command_queue; properties: clCommandQueueProperties; enable: clBool; old_properties: IntPtr): clErrorCode :=
      ntv_SetCommandQueueProperty_2(command_queue, properties, enable, old_properties);
    
    // added in cl3.0
    private static function ntv_SetContextDestructorCallback_1(context: cl_context; pfn_notify: clContextDestructorCallback; user_data: IntPtr): clErrorCode;
      external 'OpenCL' name 'clSetContextDestructorCallback';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetContextDestructorCallback(context: cl_context; pfn_notify: clContextDestructorCallback; user_data: IntPtr): clErrorCode :=
      ntv_SetContextDestructorCallback_1(context, pfn_notify, user_data);
    
    // added in cl2.1
    private static function ntv_SetDefaultDeviceCommandQueue_1(context: cl_context; device: cl_device_id; command_queue: cl_command_queue): clErrorCode;
      external 'OpenCL' name 'clSetDefaultDeviceCommandQueue';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetDefaultDeviceCommandQueue(context: cl_context; device: cl_device_id; command_queue: cl_command_queue): clErrorCode :=
      ntv_SetDefaultDeviceCommandQueue_1(context, device, command_queue);
    
    // added in cl1.1
    private static function ntv_SetEventCallback_1(&event: cl_event; command_exec_callback_type: clCommandExecutionStatus; pfn_notify: clEventCallback; user_data: IntPtr): clErrorCode;
      external 'OpenCL' name 'clSetEventCallback';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetEventCallback(&event: cl_event; command_exec_callback_type: clCommandExecutionStatus; pfn_notify: clEventCallback; user_data: IntPtr): clErrorCode :=
      ntv_SetEventCallback_1(&event, command_exec_callback_type, pfn_notify, user_data);
    
    // added in cl1.0
    private static function ntv_SetKernelArg_1(kernel: cl_kernel; arg_index: UInt32; arg_size: UIntPtr; var arg_value: Byte): clErrorCode;
      external 'OpenCL' name 'clSetKernelArg';
    private static function ntv_SetKernelArg_2(kernel: cl_kernel; arg_index: UInt32; arg_size: UIntPtr; arg_value: pointer): clErrorCode;
      external 'OpenCL' name 'clSetKernelArg';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelArg<T>(kernel: cl_kernel; arg_index: UInt32; arg_size: UIntPtr; var arg_value: T): clErrorCode; where T: record;
    begin
      Result := ntv_SetKernelArg_1(kernel, arg_index, arg_size, PByte(pointer(@arg_value))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelArg(kernel: cl_kernel; arg_index: UInt32; arg_size: UIntPtr; arg_value: pointer): clErrorCode :=
      ntv_SetKernelArg_2(kernel, arg_index, arg_size, arg_value);
    
    // added in cl2.0
    private static function ntv_SetKernelArgSVMPointer_1(kernel: cl_kernel; arg_index: UInt32; arg_value: IntPtr): clErrorCode;
      external 'OpenCL' name 'clSetKernelArgSVMPointer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelArgSVMPointer(kernel: cl_kernel; arg_index: UInt32; arg_value: IntPtr): clErrorCode :=
      ntv_SetKernelArgSVMPointer_1(kernel, arg_index, arg_value);
    
    // added in cl2.0
    private static function ntv_SetKernelExecInfo_1(kernel: cl_kernel; param_name: clKernelExecInfo; param_value_size: UIntPtr; var param_value: Byte): clErrorCode;
      external 'OpenCL' name 'clSetKernelExecInfo';
    private static function ntv_SetKernelExecInfo_2(kernel: cl_kernel; param_name: clKernelExecInfo; param_value_size: UIntPtr; param_value: pointer): clErrorCode;
      external 'OpenCL' name 'clSetKernelExecInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo<TInp>(kernel: cl_kernel; param_name: clKernelExecInfo; param_value_size: UIntPtr; var param_value: TInp): clErrorCode; where TInp: record;
    begin
      Result := ntv_SetKernelExecInfo_1(kernel, param_name, param_value_size, PByte(pointer(@param_value))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_SVM_PTRS(kernel: cl_kernel; param_value: array of IntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value.Length*Marshal.SizeOf&<IntPtr>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_SVM_PTRS, param_value_sz,param_value[0]);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_SVM_PTRS(kernel: cl_kernel; param_value_count: UInt32; var param_value: IntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<IntPtr>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_SVM_PTRS, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM(kernel: cl_kernel; param_value: clBool): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_DEVICE_PTRS(kernel: cl_kernel; param_value: UInt64): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_DEVICE_PTRS, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE(kernel: cl_kernel; param_value: UInt32): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE_MODIFIER(kernel: cl_kernel; param_value: Int32): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<Int32>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE_MODIFIER, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_WARP_COUNT_LIMIT(kernel: cl_kernel; param_value: UInt32): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_WARP_COUNT_LIMIT, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_COMPUTE_UNIT_MAX_QUEUED_BATCHES(kernel: cl_kernel; param_value: UInt32): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_COMPUTE_UNIT_MAX_QUEUED_BATCHES, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_INDIRECT_HOST_ACCESS(kernel: cl_kernel; param_value: clBool): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_INDIRECT_HOST_ACCESS, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_INDIRECT_DEVICE_ACCESS(kernel: cl_kernel; param_value: clBool): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_INDIRECT_DEVICE_ACCESS, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_INDIRECT_SHARED_ACCESS(kernel: cl_kernel; param_value: clBool): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_INDIRECT_SHARED_ACCESS, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_USM_PTRS(kernel: cl_kernel; param_value: array of IntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value.Length*Marshal.SizeOf&<IntPtr>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_USM_PTRS, param_value_sz,param_value[0]);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_USM_PTRS(kernel: cl_kernel; param_value_count: UInt32; var param_value: IntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<IntPtr>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_USM_PTRS, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo(kernel: cl_kernel; param_name: clKernelExecInfo; param_value_size: UIntPtr; param_value: pointer): clErrorCode :=
      ntv_SetKernelExecInfo_2(kernel, param_name, param_value_size, param_value);
    
    // added in cl1.1
    private static function ntv_SetMemObjectDestructorCallback_1(memobj: cl_mem; pfn_notify: clMemObjectDestructorCallback; user_data: IntPtr): clErrorCode;
      external 'OpenCL' name 'clSetMemObjectDestructorCallback';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetMemObjectDestructorCallback(memobj: cl_mem; pfn_notify: clMemObjectDestructorCallback; user_data: IntPtr): clErrorCode :=
      ntv_SetMemObjectDestructorCallback_1(memobj, pfn_notify, user_data);
    
    // added in cl2.2
    private static function ntv_SetProgramReleaseCallback_1(&program: cl_program; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
      external 'OpenCL' name 'clSetProgramReleaseCallback';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetProgramReleaseCallback(&program: cl_program; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_SetProgramReleaseCallback_1(&program, pfn_notify, user_data);
    
    // added in cl2.2
    private static function ntv_SetProgramSpecializationConstant_1(&program: cl_program; spec_id: UInt32; spec_size: UIntPtr; var spec_value: Byte): clErrorCode;
      external 'OpenCL' name 'clSetProgramSpecializationConstant';
    private static function ntv_SetProgramSpecializationConstant_2(&program: cl_program; spec_id: UInt32; spec_size: UIntPtr; spec_value: pointer): clErrorCode;
      external 'OpenCL' name 'clSetProgramSpecializationConstant';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetProgramSpecializationConstant<T>(&program: cl_program; spec_id: UInt32; spec_size: UIntPtr; spec_value: array of T): clErrorCode; where T: record;
      type PT = ^T;
    begin
      Result := if (spec_value<>nil) and (spec_value.Length<>0) then
        SetProgramSpecializationConstant(&program, spec_id, spec_size, spec_value[0]) else
        SetProgramSpecializationConstant(&program, spec_id, spec_size, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetProgramSpecializationConstant<T>(&program: cl_program; spec_id: UInt32; spec_size: UIntPtr; var spec_value: T): clErrorCode; where T: record;
    begin
      Result := ntv_SetProgramSpecializationConstant_1(&program, spec_id, spec_size, PByte(pointer(@spec_value))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetProgramSpecializationConstant(&program: cl_program; spec_id: UInt32; spec_size: UIntPtr; spec_value: pointer): clErrorCode :=
      ntv_SetProgramSpecializationConstant_2(&program, spec_id, spec_size, spec_value);
    
    // added in cl1.1
    private static function ntv_SetUserEventStatus_1(&event: cl_event; execution_status: clCommandExecutionStatus): clErrorCode;
      external 'OpenCL' name 'clSetUserEventStatus';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetUserEventStatus(&event: cl_event; execution_status: clCommandExecutionStatus): clErrorCode :=
      ntv_SetUserEventStatus_1(&event, execution_status);
    
    // added in cl2.0
    private static function ntv_SVMAlloc_1(context: cl_context; flags: clSvmMemFlags; size: UIntPtr; alignment: UInt32): IntPtr;
      external 'OpenCL' name 'clSVMAlloc';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SVMAlloc(context: cl_context; flags: clSvmMemFlags; size: UIntPtr; alignment: UInt32): IntPtr :=
      ntv_SVMAlloc_1(context, flags, size, alignment);
    
    // added in cl2.0
    private static procedure ntv_SVMFree_1(context: cl_context; svm_pointer: IntPtr);
      external 'OpenCL' name 'clSVMFree';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure SVMFree(context: cl_context; svm_pointer: IntPtr) :=
      ntv_SVMFree_1(context, svm_pointer);
    
    // added in cl1.0
    private static function ntv_UnloadCompiler_1: clErrorCode;
      external 'OpenCL' name 'clUnloadCompiler';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UnloadCompiler: clErrorCode :=
      ntv_UnloadCompiler_1;
    
    // added in cl1.2
    private static function ntv_UnloadPlatformCompiler_1(platform: cl_platform_id): clErrorCode;
      external 'OpenCL' name 'clUnloadPlatformCompiler';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UnloadPlatformCompiler(platform: cl_platform_id): clErrorCode :=
      ntv_UnloadPlatformCompiler_1(platform);
    
    // added in cl1.0
    private static function ntv_WaitForEvents_1(num_events: UInt32; var event_list: cl_event): clErrorCode;
      external 'OpenCL' name 'clWaitForEvents';
    private static function ntv_WaitForEvents_2(num_events: UInt32; event_list: IntPtr): clErrorCode;
      external 'OpenCL' name 'clWaitForEvents';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function WaitForEvents(num_events: UInt32; event_list: array of cl_event): clErrorCode;
      type PCl_event = ^cl_event;
    begin
      Result := if (event_list<>nil) and (event_list.Length<>0) then
        ntv_WaitForEvents_1(num_events, event_list[0]) else
        ntv_WaitForEvents_1(num_events, PCl_event(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function WaitForEvents(num_events: UInt32; var event_list: cl_event): clErrorCode :=
      ntv_WaitForEvents_1(num_events, event_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function WaitForEvents(num_events: UInt32; event_list: IntPtr): clErrorCode :=
      ntv_WaitForEvents_2(num_events, event_list);
    
  end;
  
  
  