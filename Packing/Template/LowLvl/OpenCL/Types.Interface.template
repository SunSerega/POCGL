  
  
  
  ///
  clAcceleratorInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACCELERATOR_DESCRIPTOR:      clAcceleratorInfo read new clAcceleratorInfo($4090);
    public static property ACCELERATOR_REFERENCE_COUNT: clAcceleratorInfo read new clAcceleratorInfo($4091);
    public static property ACCELERATOR_CONTEXT:         clAcceleratorInfo read new clAcceleratorInfo($4092);
    public static property ACCELERATOR_TYPE:            clAcceleratorInfo read new clAcceleratorInfo($4093);
    
    public function ToString: string; override;
    begin
      if ACCELERATOR_DESCRIPTOR = self then
        Result := 'ACCELERATOR_DESCRIPTOR' else
      if ACCELERATOR_REFERENCE_COUNT = self then
        Result := 'ACCELERATOR_REFERENCE_COUNT' else
      if ACCELERATOR_CONTEXT = self then
        Result := 'ACCELERATOR_CONTEXT' else
      if ACCELERATOR_TYPE = self then
        Result := 'ACCELERATOR_TYPE' else
        Result := $'clAcceleratorInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clAcceleratorType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACCELERATOR_TYPE_MOTION_ESTIMATION: clAcceleratorType read new clAcceleratorType(0);
    
    public function ToString: string; override;
    begin
      if ACCELERATOR_TYPE_MOTION_ESTIMATION = self then
        Result := 'ACCELERATOR_TYPE_MOTION_ESTIMATION' else
        Result := $'clAcceleratorType[{self.val}]';
    end;
    
  end;
  
  ///
  clAddressingMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ADDRESS_NONE:            clAddressingMode read new clAddressingMode($1130);
    public static property ADDRESS_CLAMP_TO_EDGE:   clAddressingMode read new clAddressingMode($1131);
    public static property ADDRESS_CLAMP:           clAddressingMode read new clAddressingMode($1132);
    public static property ADDRESS_REPEAT:          clAddressingMode read new clAddressingMode($1133);
    public static property ADDRESS_MIRRORED_REPEAT: clAddressingMode read new clAddressingMode($1134);
    
    public function ToString: string; override;
    begin
      if ADDRESS_NONE = self then
        Result := 'ADDRESS_NONE' else
      if ADDRESS_CLAMP_TO_EDGE = self then
        Result := 'ADDRESS_CLAMP_TO_EDGE' else
      if ADDRESS_CLAMP = self then
        Result := 'ADDRESS_CLAMP' else
      if ADDRESS_REPEAT = self then
        Result := 'ADDRESS_REPEAT' else
      if ADDRESS_MIRRORED_REPEAT = self then
        Result := 'ADDRESS_MIRRORED_REPEAT' else
        Result := $'clAddressingMode[{self.val}]';
    end;
    
  end;
  
  ///
  clAllocationType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MEM_ION_HOST_PTR:                   clAllocationType read new clAllocationType($40A8);
    public static property MEM_ANDROID_NATIVE_BUFFER_HOST_PTR: clAllocationType read new clAllocationType($40C6);
    
    public function ToString: string; override;
    begin
      if MEM_ION_HOST_PTR = self then
        Result := 'MEM_ION_HOST_PTR' else
      if MEM_ANDROID_NATIVE_BUFFER_HOST_PTR = self then
        Result := 'MEM_ANDROID_NATIVE_BUFFER_HOST_PTR' else
        Result := $'clAllocationType[{self.val}]';
    end;
    
  end;
  
  ///
  clBool = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FALSE:        clBool read new clBool(0);
    public static property NON_BLOCKING: clBool read new clBool(0);
    public static property TRUE:         clBool read new clBool($0001);
    public static property BLOCKING:     clBool read new clBool($0001);
    
    public function ToString: string; override;
    begin
      if FALSE = self then
        Result := 'FALSE' else
      if TRUE = self then
        Result := 'TRUE' else
        Result := $'clBool[{self.val}]';
    end;
    
    public static function operator implicit(b: clBool): boolean := b<>FALSE;
    public static function operator implicit(b: boolean): clBool := new clBool(UInt32(b));
    
    public static function operator not(b: clBool): clBool := if b then FALSE else TRUE;
    
  end;
  
  ///
  clBufferCreateType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BUFFER_CREATE_TYPE_REGION: clBufferCreateType read new clBufferCreateType($1220);
    
    public function ToString: string; override;
    begin
      if BUFFER_CREATE_TYPE_REGION = self then
        Result := 'BUFFER_CREATE_TYPE_REGION' else
        Result := $'clBufferCreateType[{self.val}]';
    end;
    
  end;
  
  ///
  clBuildStatus = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property BUILD_SUCCESS:     clBuildStatus read new clBuildStatus(0);
    public static property BUILD_NONE:        clBuildStatus read new clBuildStatus(-1);
    public static property BUILD_ERROR:       clBuildStatus read new clBuildStatus(-2);
    public static property BUILD_IN_PROGRESS: clBuildStatus read new clBuildStatus(-3);
    
    public function ToString: string; override;
    begin
      if BUILD_SUCCESS = self then
        Result := 'BUILD_SUCCESS' else
      if BUILD_NONE = self then
        Result := 'BUILD_NONE' else
      if BUILD_ERROR = self then
        Result := 'BUILD_ERROR' else
      if BUILD_IN_PROGRESS = self then
        Result := 'BUILD_IN_PROGRESS' else
        Result := $'clBuildStatus[{self.val}]';
    end;
    
  end;
  
  ///
  clChannelOrder = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property R:             clChannelOrder read new clChannelOrder($10B0);
    public static property A:             clChannelOrder read new clChannelOrder($10B1);
    public static property RG:            clChannelOrder read new clChannelOrder($10B2);
    public static property RA:            clChannelOrder read new clChannelOrder($10B3);
    public static property RGB:           clChannelOrder read new clChannelOrder($10B4);
    public static property RGBA:          clChannelOrder read new clChannelOrder($10B5);
    public static property BGRA:          clChannelOrder read new clChannelOrder($10B6);
    public static property ARGB:          clChannelOrder read new clChannelOrder($10B7);
    public static property INTENSITY:     clChannelOrder read new clChannelOrder($10B8);
    public static property LUMINANCE:     clChannelOrder read new clChannelOrder($10B9);
    public static property Rx:            clChannelOrder read new clChannelOrder($10BA);
    public static property RGx:           clChannelOrder read new clChannelOrder($10BB);
    public static property RGBx:          clChannelOrder read new clChannelOrder($10BC);
    public static property DEPTH:         clChannelOrder read new clChannelOrder($10BD);
    public static property DEPTH_STENCIL: clChannelOrder read new clChannelOrder($10BE);
    public static property sRGB:          clChannelOrder read new clChannelOrder($10BF);
    public static property sRGBx:         clChannelOrder read new clChannelOrder($10C0);
    public static property sRGBA:         clChannelOrder read new clChannelOrder($10C1);
    public static property sBGRA:         clChannelOrder read new clChannelOrder($10C2);
    public static property ABGR:          clChannelOrder read new clChannelOrder($10C3);
    public static property YUYV:          clChannelOrder read new clChannelOrder($4076);
    public static property UYVY:          clChannelOrder read new clChannelOrder($4077);
    public static property YVYU:          clChannelOrder read new clChannelOrder($4078);
    public static property VYUY:          clChannelOrder read new clChannelOrder($4079);
    public static property NV21:          clChannelOrder read new clChannelOrder($40D0);
    public static property YV12:          clChannelOrder read new clChannelOrder($40D1);
    public static property NV12:          clChannelOrder read new clChannelOrder($410E);
    
    public function ToString: string; override;
    begin
      if R = self then
        Result := 'R' else
      if A = self then
        Result := 'A' else
      if RG = self then
        Result := 'RG' else
      if RA = self then
        Result := 'RA' else
      if RGB = self then
        Result := 'RGB' else
      if RGBA = self then
        Result := 'RGBA' else
      if BGRA = self then
        Result := 'BGRA' else
      if ARGB = self then
        Result := 'ARGB' else
      if INTENSITY = self then
        Result := 'INTENSITY' else
      if LUMINANCE = self then
        Result := 'LUMINANCE' else
      if Rx = self then
        Result := 'Rx' else
      if RGx = self then
        Result := 'RGx' else
      if RGBx = self then
        Result := 'RGBx' else
      if DEPTH = self then
        Result := 'DEPTH' else
      if DEPTH_STENCIL = self then
        Result := 'DEPTH_STENCIL' else
      if sRGB = self then
        Result := 'sRGB' else
      if sRGBx = self then
        Result := 'sRGBx' else
      if sRGBA = self then
        Result := 'sRGBA' else
      if sBGRA = self then
        Result := 'sBGRA' else
      if ABGR = self then
        Result := 'ABGR' else
      if YUYV = self then
        Result := 'YUYV' else
      if UYVY = self then
        Result := 'UYVY' else
      if YVYU = self then
        Result := 'YVYU' else
      if VYUY = self then
        Result := 'VYUY' else
      if NV21 = self then
        Result := 'NV21' else
      if YV12 = self then
        Result := 'YV12' else
      if NV12 = self then
        Result := 'NV12' else
        Result := $'clChannelOrder[{self.val}]';
    end;
    
  end;
  
  ///
  clChannelType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SNORM_INT8:         clChannelType read new clChannelType($10D0);
    public static property SNORM_INT16:        clChannelType read new clChannelType($10D1);
    public static property UNORM_INT8:         clChannelType read new clChannelType($10D2);
    public static property UNORM_INT16:        clChannelType read new clChannelType($10D3);
    public static property UNORM_SHORT_565:    clChannelType read new clChannelType($10D4);
    public static property UNORM_SHORT_555:    clChannelType read new clChannelType($10D5);
    public static property UNORM_INT_101010:   clChannelType read new clChannelType($10D6);
    public static property SIGNED_INT8:        clChannelType read new clChannelType($10D7);
    public static property SIGNED_INT16:       clChannelType read new clChannelType($10D8);
    public static property SIGNED_INT32:       clChannelType read new clChannelType($10D9);
    public static property UNSIGNED_INT8:      clChannelType read new clChannelType($10DA);
    public static property UNSIGNED_INT16:     clChannelType read new clChannelType($10DB);
    public static property UNSIGNED_INT32:     clChannelType read new clChannelType($10DC);
    public static property HALF_FLOAT:         clChannelType read new clChannelType($10DD);
    public static property FLOAT:              clChannelType read new clChannelType($10DE);
    public static property UNORM_INT24:        clChannelType read new clChannelType($10DF);
    public static property UNORM_INT_101010_2: clChannelType read new clChannelType($10E0);
    
    public function ToString: string; override;
    begin
      if SNORM_INT8 = self then
        Result := 'SNORM_INT8' else
      if SNORM_INT16 = self then
        Result := 'SNORM_INT16' else
      if UNORM_INT8 = self then
        Result := 'UNORM_INT8' else
      if UNORM_INT16 = self then
        Result := 'UNORM_INT16' else
      if UNORM_SHORT_565 = self then
        Result := 'UNORM_SHORT_565' else
      if UNORM_SHORT_555 = self then
        Result := 'UNORM_SHORT_555' else
      if UNORM_INT_101010 = self then
        Result := 'UNORM_INT_101010' else
      if SIGNED_INT8 = self then
        Result := 'SIGNED_INT8' else
      if SIGNED_INT16 = self then
        Result := 'SIGNED_INT16' else
      if SIGNED_INT32 = self then
        Result := 'SIGNED_INT32' else
      if UNSIGNED_INT8 = self then
        Result := 'UNSIGNED_INT8' else
      if UNSIGNED_INT16 = self then
        Result := 'UNSIGNED_INT16' else
      if UNSIGNED_INT32 = self then
        Result := 'UNSIGNED_INT32' else
      if HALF_FLOAT = self then
        Result := 'HALF_FLOAT' else
      if FLOAT = self then
        Result := 'FLOAT' else
      if UNORM_INT24 = self then
        Result := 'UNORM_INT24' else
      if UNORM_INT_101010_2 = self then
        Result := 'UNORM_INT_101010_2' else
        Result := $'clChannelType[{self.val}]';
    end;
    
  end;
  
  ///
  clCommandBufferInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMMAND_BUFFER_QUEUES:           clCommandBufferInfo read new clCommandBufferInfo($1294);
    public static property COMMAND_BUFFER_NUM_QUEUES:       clCommandBufferInfo read new clCommandBufferInfo($1295);
    public static property COMMAND_BUFFER_REFERENCE_COUNT:  clCommandBufferInfo read new clCommandBufferInfo($1296);
    public static property COMMAND_BUFFER_STATE:            clCommandBufferInfo read new clCommandBufferInfo($1297);
    public static property COMMAND_BUFFER_PROPERTIES_ARRAY: clCommandBufferInfo read new clCommandBufferInfo($1298);
    public static property COMMAND_BUFFER_CONTEXT:          clCommandBufferInfo read new clCommandBufferInfo($1299);
    
    public function ToString: string; override;
    begin
      if COMMAND_BUFFER_QUEUES = self then
        Result := 'COMMAND_BUFFER_QUEUES' else
      if COMMAND_BUFFER_NUM_QUEUES = self then
        Result := 'COMMAND_BUFFER_NUM_QUEUES' else
      if COMMAND_BUFFER_REFERENCE_COUNT = self then
        Result := 'COMMAND_BUFFER_REFERENCE_COUNT' else
      if COMMAND_BUFFER_STATE = self then
        Result := 'COMMAND_BUFFER_STATE' else
      if COMMAND_BUFFER_PROPERTIES_ARRAY = self then
        Result := 'COMMAND_BUFFER_PROPERTIES_ARRAY' else
      if COMMAND_BUFFER_CONTEXT = self then
        Result := 'COMMAND_BUFFER_CONTEXT' else
        Result := $'clCommandBufferInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clCommandBufferProperties = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property COMMAND_BUFFER_FLAGS: clCommandBufferProperties read new clCommandBufferProperties($1293);
    
    public function ToString: string; override;
    begin
      if COMMAND_BUFFER_FLAGS = self then
        Result := 'COMMAND_BUFFER_FLAGS' else
        Result := $'clCommandBufferProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clCommandBufferState = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMMAND_BUFFER_STATE_RECORDING:  clCommandBufferState read new clCommandBufferState(0);
    public static property COMMAND_BUFFER_STATE_EXECUTABLE: clCommandBufferState read new clCommandBufferState($0001);
    public static property COMMAND_BUFFER_STATE_PENDING:    clCommandBufferState read new clCommandBufferState($0002);
    public static property COMMAND_BUFFER_STATE_INVALID:    clCommandBufferState read new clCommandBufferState($0003);
    
    public function ToString: string; override;
    begin
      if COMMAND_BUFFER_STATE_RECORDING = self then
        Result := 'COMMAND_BUFFER_STATE_RECORDING' else
      if COMMAND_BUFFER_STATE_EXECUTABLE = self then
        Result := 'COMMAND_BUFFER_STATE_EXECUTABLE' else
      if COMMAND_BUFFER_STATE_PENDING = self then
        Result := 'COMMAND_BUFFER_STATE_PENDING' else
      if COMMAND_BUFFER_STATE_INVALID = self then
        Result := 'COMMAND_BUFFER_STATE_INVALID' else
        Result := $'clCommandBufferState[{self.val}]';
    end;
    
  end;
  
  ///
  clCommandBufferStructureType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property STRUCTURE_TYPE_MUTABLE_BASE_CONFIG:     clCommandBufferStructureType read new clCommandBufferStructureType(0);
    public static property STRUCTURE_TYPE_MUTABLE_DISPATCH_CONFIG: clCommandBufferStructureType read new clCommandBufferStructureType($0001);
    
    public function ToString: string; override;
    begin
      if STRUCTURE_TYPE_MUTABLE_BASE_CONFIG = self then
        Result := 'STRUCTURE_TYPE_MUTABLE_BASE_CONFIG' else
      if STRUCTURE_TYPE_MUTABLE_DISPATCH_CONFIG = self then
        Result := 'STRUCTURE_TYPE_MUTABLE_DISPATCH_CONFIG' else
        Result := $'clCommandBufferStructureType[{self.val}]';
    end;
    
  end;
  
  ///
  clCommandExecutionStatus = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property COMPLETE:  clCommandExecutionStatus read new clCommandExecutionStatus(0);
    public static property RUNNING:   clCommandExecutionStatus read new clCommandExecutionStatus($0001);
    public static property SUBMITTED: clCommandExecutionStatus read new clCommandExecutionStatus($0002);
    public static property QUEUED:    clCommandExecutionStatus read new clCommandExecutionStatus($0003);
    
    public function ToString: string; override;
    begin
      if COMPLETE = self then
        Result := 'COMPLETE' else
      if RUNNING = self then
        Result := 'RUNNING' else
      if SUBMITTED = self then
        Result := 'SUBMITTED' else
      if QUEUED = self then
        Result := 'QUEUED' else
        Result := $'clCommandExecutionStatus[{self.val}]';
    end;
    
    public function IS_ERROR := val < 0;
    
  end;
  
  ///
  clCommandQueueCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property QUEUE_DEFAULT_CAPABILITIES:                    clCommandQueueCapabilities read new clCommandQueueCapabilities(0);
    public static property QUEUE_CAPABILITY_CREATE_SINGLE_QUEUE_EVENTS:   clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 0);
    public static property QUEUE_CAPABILITY_CREATE_CROSS_QUEUE_EVENTS:    clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 1);
    public static property QUEUE_CAPABILITY_SINGLE_QUEUE_EVENT_WAIT_LIST: clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 2);
    public static property QUEUE_CAPABILITY_CROSS_QUEUE_EVENT_WAIT_LIST:  clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 3);
    public static property QUEUE_CAPABILITY_TRANSFER_BUFFER:              clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 8);
    public static property QUEUE_CAPABILITY_TRANSFER_BUFFER_RECT:         clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 9);
    public static property QUEUE_CAPABILITY_MAP_BUFFER:                   clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 10);
    public static property QUEUE_CAPABILITY_FILL_BUFFER:                  clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 11);
    public static property QUEUE_CAPABILITY_TRANSFER_IMAGE:               clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 12);
    public static property QUEUE_CAPABILITY_MAP_IMAGE:                    clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 13);
    public static property QUEUE_CAPABILITY_FILL_IMAGE:                   clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 14);
    public static property QUEUE_CAPABILITY_TRANSFER_BUFFER_IMAGE:        clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 15);
    public static property QUEUE_CAPABILITY_TRANSFER_IMAGE_BUFFER:        clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 16);
    public static property QUEUE_CAPABILITY_MARKER:                       clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 24);
    public static property QUEUE_CAPABILITY_BARRIER:                      clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 25);
    public static property QUEUE_CAPABILITY_KERNEL:                       clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 26);
    
    public property ANY_FLAGS: boolean read self.val<>0;
    
    public static function operator+(v1, v2: clCommandQueueCapabilities) := new clCommandQueueCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clCommandQueueCapabilities) := new clCommandQueueCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clCommandQueueCapabilities; v2: clCommandQueueCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clCommandQueueCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'QUEUE_DEFAULT_CAPABILITIES';
        exit;
      end;
      if QUEUE_CAPABILITY_CREATE_SINGLE_QUEUE_EVENTS in self then
      begin
        res += 'QUEUE_CAPABILITY_CREATE_SINGLE_QUEUE_EVENTS+';
        left_val := left_val and not QUEUE_CAPABILITY_CREATE_SINGLE_QUEUE_EVENTS.val;
      end;
      if QUEUE_CAPABILITY_CREATE_CROSS_QUEUE_EVENTS in self then
      begin
        res += 'QUEUE_CAPABILITY_CREATE_CROSS_QUEUE_EVENTS+';
        left_val := left_val and not QUEUE_CAPABILITY_CREATE_CROSS_QUEUE_EVENTS.val;
      end;
      if QUEUE_CAPABILITY_SINGLE_QUEUE_EVENT_WAIT_LIST in self then
      begin
        res += 'QUEUE_CAPABILITY_SINGLE_QUEUE_EVENT_WAIT_LIST+';
        left_val := left_val and not QUEUE_CAPABILITY_SINGLE_QUEUE_EVENT_WAIT_LIST.val;
      end;
      if QUEUE_CAPABILITY_CROSS_QUEUE_EVENT_WAIT_LIST in self then
      begin
        res += 'QUEUE_CAPABILITY_CROSS_QUEUE_EVENT_WAIT_LIST+';
        left_val := left_val and not QUEUE_CAPABILITY_CROSS_QUEUE_EVENT_WAIT_LIST.val;
      end;
      if QUEUE_CAPABILITY_TRANSFER_BUFFER in self then
      begin
        res += 'QUEUE_CAPABILITY_TRANSFER_BUFFER+';
        left_val := left_val and not QUEUE_CAPABILITY_TRANSFER_BUFFER.val;
      end;
      if QUEUE_CAPABILITY_TRANSFER_BUFFER_RECT in self then
      begin
        res += 'QUEUE_CAPABILITY_TRANSFER_BUFFER_RECT+';
        left_val := left_val and not QUEUE_CAPABILITY_TRANSFER_BUFFER_RECT.val;
      end;
      if QUEUE_CAPABILITY_MAP_BUFFER in self then
      begin
        res += 'QUEUE_CAPABILITY_MAP_BUFFER+';
        left_val := left_val and not QUEUE_CAPABILITY_MAP_BUFFER.val;
      end;
      if QUEUE_CAPABILITY_FILL_BUFFER in self then
      begin
        res += 'QUEUE_CAPABILITY_FILL_BUFFER+';
        left_val := left_val and not QUEUE_CAPABILITY_FILL_BUFFER.val;
      end;
      if QUEUE_CAPABILITY_TRANSFER_IMAGE in self then
      begin
        res += 'QUEUE_CAPABILITY_TRANSFER_IMAGE+';
        left_val := left_val and not QUEUE_CAPABILITY_TRANSFER_IMAGE.val;
      end;
      if QUEUE_CAPABILITY_MAP_IMAGE in self then
      begin
        res += 'QUEUE_CAPABILITY_MAP_IMAGE+';
        left_val := left_val and not QUEUE_CAPABILITY_MAP_IMAGE.val;
      end;
      if QUEUE_CAPABILITY_FILL_IMAGE in self then
      begin
        res += 'QUEUE_CAPABILITY_FILL_IMAGE+';
        left_val := left_val and not QUEUE_CAPABILITY_FILL_IMAGE.val;
      end;
      if QUEUE_CAPABILITY_TRANSFER_BUFFER_IMAGE in self then
      begin
        res += 'QUEUE_CAPABILITY_TRANSFER_BUFFER_IMAGE+';
        left_val := left_val and not QUEUE_CAPABILITY_TRANSFER_BUFFER_IMAGE.val;
      end;
      if QUEUE_CAPABILITY_TRANSFER_IMAGE_BUFFER in self then
      begin
        res += 'QUEUE_CAPABILITY_TRANSFER_IMAGE_BUFFER+';
        left_val := left_val and not QUEUE_CAPABILITY_TRANSFER_IMAGE_BUFFER.val;
      end;
      if QUEUE_CAPABILITY_MARKER in self then
      begin
        res += 'QUEUE_CAPABILITY_MARKER+';
        left_val := left_val and not QUEUE_CAPABILITY_MARKER.val;
      end;
      if QUEUE_CAPABILITY_BARRIER in self then
      begin
        res += 'QUEUE_CAPABILITY_BARRIER+';
        left_val := left_val and not QUEUE_CAPABILITY_BARRIER.val;
      end;
      if QUEUE_CAPABILITY_KERNEL in self then
      begin
        res += 'QUEUE_CAPABILITY_KERNEL+';
        left_val := left_val and not QUEUE_CAPABILITY_KERNEL.val;
      end;
      if left_val<>0 then
      begin
        res += 'clCommandQueueCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clCommandQueueInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property QUEUE_CONTEXT:          clCommandQueueInfo read new clCommandQueueInfo($1090);
    public static property QUEUE_DEVICE:           clCommandQueueInfo read new clCommandQueueInfo($1091);
    public static property QUEUE_REFERENCE_COUNT:  clCommandQueueInfo read new clCommandQueueInfo($1092);
    public static property QUEUE_PROPERTIES:       clCommandQueueInfo read new clCommandQueueInfo($1093);
    public static property QUEUE_SIZE:             clCommandQueueInfo read new clCommandQueueInfo($1094);
    public static property QUEUE_DEVICE_DEFAULT:   clCommandQueueInfo read new clCommandQueueInfo($1095);
    public static property QUEUE_PROPERTIES_ARRAY: clCommandQueueInfo read new clCommandQueueInfo($1098);
    public static property QUEUE_FAMILY:           clCommandQueueInfo read new clCommandQueueInfo($418C);
    public static property QUEUE_INDEX:            clCommandQueueInfo read new clCommandQueueInfo($418D);
    
    public function ToString: string; override;
    begin
      if QUEUE_CONTEXT = self then
        Result := 'QUEUE_CONTEXT' else
      if QUEUE_DEVICE = self then
        Result := 'QUEUE_DEVICE' else
      if QUEUE_REFERENCE_COUNT = self then
        Result := 'QUEUE_REFERENCE_COUNT' else
      if QUEUE_PROPERTIES = self then
        Result := 'QUEUE_PROPERTIES' else
      if QUEUE_SIZE = self then
        Result := 'QUEUE_SIZE' else
      if QUEUE_DEVICE_DEFAULT = self then
        Result := 'QUEUE_DEVICE_DEFAULT' else
      if QUEUE_PROPERTIES_ARRAY = self then
        Result := 'QUEUE_PROPERTIES_ARRAY' else
      if QUEUE_FAMILY = self then
        Result := 'QUEUE_FAMILY' else
      if QUEUE_INDEX = self then
        Result := 'QUEUE_INDEX' else
        Result := $'clCommandQueueInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clCommandQueueProperties = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property NONE:                                clCommandQueueProperties read new clCommandQueueProperties(0);
    public static property QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE: clCommandQueueProperties read new clCommandQueueProperties(1 shl 0);
    public static property QUEUE_PROFILING_ENABLE:              clCommandQueueProperties read new clCommandQueueProperties(1 shl 1);
    public static property QUEUE_ON_DEVICE:                     clCommandQueueProperties read new clCommandQueueProperties(1 shl 2);
    public static property QUEUE_ON_DEVICE_DEFAULT:             clCommandQueueProperties read new clCommandQueueProperties(1 shl 3);
    public static property QUEUE_NO_SYNC_OPERATIONS:            clCommandQueueProperties read new clCommandQueueProperties(1 shl 29);
    public static property QUEUE_THREAD_LOCAL_EXEC_ENABLE:      clCommandQueueProperties read new clCommandQueueProperties(1 shl 31);
    
    public property ANY_FLAGS: boolean read self.val<>0;
    
    public static function operator+(v1, v2: clCommandQueueProperties) := new clCommandQueueProperties(v1.val or v2.val);
    public static function operator or(v1, v2: clCommandQueueProperties) := new clCommandQueueProperties(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clCommandQueueProperties; v2: clCommandQueueProperties) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clCommandQueueProperties) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'NONE';
        exit;
      end;
      if QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE in self then
      begin
        res += 'QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE+';
        left_val := left_val and not QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE.val;
      end;
      if QUEUE_PROFILING_ENABLE in self then
      begin
        res += 'QUEUE_PROFILING_ENABLE+';
        left_val := left_val and not QUEUE_PROFILING_ENABLE.val;
      end;
      if QUEUE_ON_DEVICE in self then
      begin
        res += 'QUEUE_ON_DEVICE+';
        left_val := left_val and not QUEUE_ON_DEVICE.val;
      end;
      if QUEUE_ON_DEVICE_DEFAULT in self then
      begin
        res += 'QUEUE_ON_DEVICE_DEFAULT+';
        left_val := left_val and not QUEUE_ON_DEVICE_DEFAULT.val;
      end;
      if QUEUE_NO_SYNC_OPERATIONS in self then
      begin
        res += 'QUEUE_NO_SYNC_OPERATIONS+';
        left_val := left_val and not QUEUE_NO_SYNC_OPERATIONS.val;
      end;
      if QUEUE_THREAD_LOCAL_EXEC_ENABLE in self then
      begin
        res += 'QUEUE_THREAD_LOCAL_EXEC_ENABLE+';
        left_val := left_val and not QUEUE_THREAD_LOCAL_EXEC_ENABLE.val;
      end;
      if left_val<>0 then
      begin
        res += 'clCommandQueueProperties[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clCommandTerminationReason = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMMAND_TERMINATION_COMPLETION:         clCommandTerminationReason read new clCommandTerminationReason(0);
    public static property COMMAND_TERMINATION_CONTROLLED_SUCCESS: clCommandTerminationReason read new clCommandTerminationReason($0001);
    public static property COMMAND_TERMINATION_CONTROLLED_FAILURE: clCommandTerminationReason read new clCommandTerminationReason($0002);
    public static property COMMAND_TERMINATION_ERROR:              clCommandTerminationReason read new clCommandTerminationReason($0003);
    
    public function ToString: string; override;
    begin
      if COMMAND_TERMINATION_COMPLETION = self then
        Result := 'COMMAND_TERMINATION_COMPLETION' else
      if COMMAND_TERMINATION_CONTROLLED_SUCCESS = self then
        Result := 'COMMAND_TERMINATION_CONTROLLED_SUCCESS' else
      if COMMAND_TERMINATION_CONTROLLED_FAILURE = self then
        Result := 'COMMAND_TERMINATION_CONTROLLED_FAILURE' else
      if COMMAND_TERMINATION_ERROR = self then
        Result := 'COMMAND_TERMINATION_ERROR' else
        Result := $'clCommandTerminationReason[{self.val}]';
    end;
    
  end;
  
  ///
  clCommandType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMMAND_NDRANGE_KERNEL:                clCommandType read new clCommandType($11F0);
    public static property COMMAND_TASK:                          clCommandType read new clCommandType($11F1);
    public static property COMMAND_NATIVE_KERNEL:                 clCommandType read new clCommandType($11F2);
    public static property COMMAND_READ_BUFFER:                   clCommandType read new clCommandType($11F3);
    public static property COMMAND_WRITE_BUFFER:                  clCommandType read new clCommandType($11F4);
    public static property COMMAND_COPY_BUFFER:                   clCommandType read new clCommandType($11F5);
    public static property COMMAND_READ_IMAGE:                    clCommandType read new clCommandType($11F6);
    public static property COMMAND_WRITE_IMAGE:                   clCommandType read new clCommandType($11F7);
    public static property COMMAND_COPY_IMAGE:                    clCommandType read new clCommandType($11F8);
    public static property COMMAND_COPY_IMAGE_TO_BUFFER:          clCommandType read new clCommandType($11F9);
    public static property COMMAND_COPY_BUFFER_TO_IMAGE:          clCommandType read new clCommandType($11FA);
    public static property COMMAND_MAP_BUFFER:                    clCommandType read new clCommandType($11FB);
    public static property COMMAND_MAP_IMAGE:                     clCommandType read new clCommandType($11FC);
    public static property COMMAND_UNMAP_MEM_OBJECT:              clCommandType read new clCommandType($11FD);
    public static property COMMAND_MARKER:                        clCommandType read new clCommandType($11FE);
    public static property COMMAND_ACQUIRE_GL_OBJECTS:            clCommandType read new clCommandType($11FF);
    public static property COMMAND_RELEASE_GL_OBJECTS:            clCommandType read new clCommandType($1200);
    public static property COMMAND_READ_BUFFER_RECT:              clCommandType read new clCommandType($1201);
    public static property COMMAND_WRITE_BUFFER_RECT:             clCommandType read new clCommandType($1202);
    public static property COMMAND_COPY_BUFFER_RECT:              clCommandType read new clCommandType($1203);
    public static property COMMAND_USER:                          clCommandType read new clCommandType($1204);
    public static property COMMAND_BARRIER:                       clCommandType read new clCommandType($1205);
    public static property COMMAND_MIGRATE_MEM_OBJECTS:           clCommandType read new clCommandType($1206);
    public static property COMMAND_FILL_BUFFER:                   clCommandType read new clCommandType($1207);
    public static property COMMAND_FILL_IMAGE:                    clCommandType read new clCommandType($1208);
    public static property COMMAND_SVM_FREE:                      clCommandType read new clCommandType($1209);
    public static property COMMAND_SVM_MEMCPY:                    clCommandType read new clCommandType($120A);
    public static property COMMAND_SVM_MEMFILL:                   clCommandType read new clCommandType($120B);
    public static property COMMAND_SVM_MAP:                       clCommandType read new clCommandType($120C);
    public static property COMMAND_SVM_UNMAP:                     clCommandType read new clCommandType($120D);
    public static property COMMAND_SVM_MIGRATE_MEM:               clCommandType read new clCommandType($120E);
    public static property COMMAND_COMMAND_BUFFER:                clCommandType read new clCommandType($12A8);
    public static property COMMAND_GL_FENCE_SYNC_OBJECT:          clCommandType read new clCommandType($200D);
    public static property COMMAND_ACQUIRE_DX9_MEDIA_SURFACES:    clCommandType read new clCommandType($202B);
    public static property COMMAND_RELEASE_DX9_MEDIA_SURFACES:    clCommandType read new clCommandType($202C);
    public static property COMMAND_ACQUIRE_EGL_OBJECTS:           clCommandType read new clCommandType($202D);
    public static property COMMAND_RELEASE_EGL_OBJECTS:           clCommandType read new clCommandType($202E);
    public static property COMMAND_EGL_FENCE_SYNC_OBJECT:         clCommandType read new clCommandType($202F);
    public static property COMMAND_SEMAPHORE_WAIT:                clCommandType read new clCommandType($2042);
    public static property COMMAND_SEMAPHORE_SIGNAL:              clCommandType read new clCommandType($2043);
    public static property COMMAND_ACQUIRE_EXTERNAL_MEM_OBJECTS:  clCommandType read new clCommandType($2047);
    public static property COMMAND_RELEASE_EXTERNAL_MEM_OBJECTS:  clCommandType read new clCommandType($2048);
    public static property COMMAND_ACQUIRE_D3D10_OBJECTS:         clCommandType read new clCommandType($4017);
    public static property COMMAND_RELEASE_D3D10_OBJECTS:         clCommandType read new clCommandType($4018);
    public static property COMMAND_ACQUIRE_D3D11_OBJECTS:         clCommandType read new clCommandType($4020);
    public static property COMMAND_RELEASE_D3D11_OBJECTS:         clCommandType read new clCommandType($4021);
    public static property COMMAND_ACQUIRE_DX9_OBJECTS:           clCommandType read new clCommandType($402A);
    public static property COMMAND_RELEASE_DX9_OBJECTS:           clCommandType read new clCommandType($402B);
    public static property COMMAND_MIGRATE_MEM_OBJECT:            clCommandType read new clCommandType($4040);
    public static property COMMAND_ACQUIRE_VA_API_MEDIA_SURFACES: clCommandType read new clCommandType($409A);
    public static property COMMAND_RELEASE_VA_API_MEDIA_SURFACES: clCommandType read new clCommandType($409B);
    public static property COMMAND_SVM_FREE_ARM:                  clCommandType read new clCommandType($40BA);
    public static property COMMAND_SVM_MEMCPY_ARM:                clCommandType read new clCommandType($40BB);
    public static property COMMAND_SVM_MEMFILL_ARM:               clCommandType read new clCommandType($40BC);
    public static property COMMAND_SVM_MAP_ARM:                   clCommandType read new clCommandType($40BD);
    public static property COMMAND_SVM_UNMAP_ARM:                 clCommandType read new clCommandType($40BE);
    public static property COMMAND_ACQUIRE_GRALLOC_OBJECTS:       clCommandType read new clCommandType($40D2);
    public static property COMMAND_RELEASE_GRALLOC_OBJECTS:       clCommandType read new clCommandType($40D3);
    public static property COMMAND_GENERATE_MIPMAP:               clCommandType read new clCommandType($40D6);
    public static property COMMAND_MEMFILL:                       clCommandType read new clCommandType($4204);
    public static property COMMAND_MEMCPY:                        clCommandType read new clCommandType($4205);
    public static property COMMAND_MIGRATEMEM:                    clCommandType read new clCommandType($4206);
    public static property COMMAND_MEMADVISE:                     clCommandType read new clCommandType($4207);
    public static property COMMAND_READ_HOST_PIPE:                clCommandType read new clCommandType($4214);
    public static property COMMAND_WRITE_HOST_PIPE:               clCommandType read new clCommandType($4215);
    
    public function ToString: string; override;
    begin
      if COMMAND_NDRANGE_KERNEL = self then
        Result := 'COMMAND_NDRANGE_KERNEL' else
      if COMMAND_TASK = self then
        Result := 'COMMAND_TASK' else
      if COMMAND_NATIVE_KERNEL = self then
        Result := 'COMMAND_NATIVE_KERNEL' else
      if COMMAND_READ_BUFFER = self then
        Result := 'COMMAND_READ_BUFFER' else
      if COMMAND_WRITE_BUFFER = self then
        Result := 'COMMAND_WRITE_BUFFER' else
      if COMMAND_COPY_BUFFER = self then
        Result := 'COMMAND_COPY_BUFFER' else
      if COMMAND_READ_IMAGE = self then
        Result := 'COMMAND_READ_IMAGE' else
      if COMMAND_WRITE_IMAGE = self then
        Result := 'COMMAND_WRITE_IMAGE' else
      if COMMAND_COPY_IMAGE = self then
        Result := 'COMMAND_COPY_IMAGE' else
      if COMMAND_COPY_IMAGE_TO_BUFFER = self then
        Result := 'COMMAND_COPY_IMAGE_TO_BUFFER' else
      if COMMAND_COPY_BUFFER_TO_IMAGE = self then
        Result := 'COMMAND_COPY_BUFFER_TO_IMAGE' else
      if COMMAND_MAP_BUFFER = self then
        Result := 'COMMAND_MAP_BUFFER' else
      if COMMAND_MAP_IMAGE = self then
        Result := 'COMMAND_MAP_IMAGE' else
      if COMMAND_UNMAP_MEM_OBJECT = self then
        Result := 'COMMAND_UNMAP_MEM_OBJECT' else
      if COMMAND_MARKER = self then
        Result := 'COMMAND_MARKER' else
      if COMMAND_ACQUIRE_GL_OBJECTS = self then
        Result := 'COMMAND_ACQUIRE_GL_OBJECTS' else
      if COMMAND_RELEASE_GL_OBJECTS = self then
        Result := 'COMMAND_RELEASE_GL_OBJECTS' else
      if COMMAND_READ_BUFFER_RECT = self then
        Result := 'COMMAND_READ_BUFFER_RECT' else
      if COMMAND_WRITE_BUFFER_RECT = self then
        Result := 'COMMAND_WRITE_BUFFER_RECT' else
      if COMMAND_COPY_BUFFER_RECT = self then
        Result := 'COMMAND_COPY_BUFFER_RECT' else
      if COMMAND_USER = self then
        Result := 'COMMAND_USER' else
      if COMMAND_BARRIER = self then
        Result := 'COMMAND_BARRIER' else
      if COMMAND_MIGRATE_MEM_OBJECTS = self then
        Result := 'COMMAND_MIGRATE_MEM_OBJECTS' else
      if COMMAND_FILL_BUFFER = self then
        Result := 'COMMAND_FILL_BUFFER' else
      if COMMAND_FILL_IMAGE = self then
        Result := 'COMMAND_FILL_IMAGE' else
      if COMMAND_SVM_FREE = self then
        Result := 'COMMAND_SVM_FREE' else
      if COMMAND_SVM_MEMCPY = self then
        Result := 'COMMAND_SVM_MEMCPY' else
      if COMMAND_SVM_MEMFILL = self then
        Result := 'COMMAND_SVM_MEMFILL' else
      if COMMAND_SVM_MAP = self then
        Result := 'COMMAND_SVM_MAP' else
      if COMMAND_SVM_UNMAP = self then
        Result := 'COMMAND_SVM_UNMAP' else
      if COMMAND_SVM_MIGRATE_MEM = self then
        Result := 'COMMAND_SVM_MIGRATE_MEM' else
      if COMMAND_COMMAND_BUFFER = self then
        Result := 'COMMAND_COMMAND_BUFFER' else
      if COMMAND_GL_FENCE_SYNC_OBJECT = self then
        Result := 'COMMAND_GL_FENCE_SYNC_OBJECT' else
      if COMMAND_ACQUIRE_DX9_MEDIA_SURFACES = self then
        Result := 'COMMAND_ACQUIRE_DX9_MEDIA_SURFACES' else
      if COMMAND_RELEASE_DX9_MEDIA_SURFACES = self then
        Result := 'COMMAND_RELEASE_DX9_MEDIA_SURFACES' else
      if COMMAND_ACQUIRE_EGL_OBJECTS = self then
        Result := 'COMMAND_ACQUIRE_EGL_OBJECTS' else
      if COMMAND_RELEASE_EGL_OBJECTS = self then
        Result := 'COMMAND_RELEASE_EGL_OBJECTS' else
      if COMMAND_EGL_FENCE_SYNC_OBJECT = self then
        Result := 'COMMAND_EGL_FENCE_SYNC_OBJECT' else
      if COMMAND_SEMAPHORE_WAIT = self then
        Result := 'COMMAND_SEMAPHORE_WAIT' else
      if COMMAND_SEMAPHORE_SIGNAL = self then
        Result := 'COMMAND_SEMAPHORE_SIGNAL' else
      if COMMAND_ACQUIRE_EXTERNAL_MEM_OBJECTS = self then
        Result := 'COMMAND_ACQUIRE_EXTERNAL_MEM_OBJECTS' else
      if COMMAND_RELEASE_EXTERNAL_MEM_OBJECTS = self then
        Result := 'COMMAND_RELEASE_EXTERNAL_MEM_OBJECTS' else
      if COMMAND_ACQUIRE_D3D10_OBJECTS = self then
        Result := 'COMMAND_ACQUIRE_D3D10_OBJECTS' else
      if COMMAND_RELEASE_D3D10_OBJECTS = self then
        Result := 'COMMAND_RELEASE_D3D10_OBJECTS' else
      if COMMAND_ACQUIRE_D3D11_OBJECTS = self then
        Result := 'COMMAND_ACQUIRE_D3D11_OBJECTS' else
      if COMMAND_RELEASE_D3D11_OBJECTS = self then
        Result := 'COMMAND_RELEASE_D3D11_OBJECTS' else
      if COMMAND_ACQUIRE_DX9_OBJECTS = self then
        Result := 'COMMAND_ACQUIRE_DX9_OBJECTS' else
      if COMMAND_RELEASE_DX9_OBJECTS = self then
        Result := 'COMMAND_RELEASE_DX9_OBJECTS' else
      if COMMAND_MIGRATE_MEM_OBJECT = self then
        Result := 'COMMAND_MIGRATE_MEM_OBJECT' else
      if COMMAND_ACQUIRE_VA_API_MEDIA_SURFACES = self then
        Result := 'COMMAND_ACQUIRE_VA_API_MEDIA_SURFACES' else
      if COMMAND_RELEASE_VA_API_MEDIA_SURFACES = self then
        Result := 'COMMAND_RELEASE_VA_API_MEDIA_SURFACES' else
      if COMMAND_SVM_FREE_ARM = self then
        Result := 'COMMAND_SVM_FREE_ARM' else
      if COMMAND_SVM_MEMCPY_ARM = self then
        Result := 'COMMAND_SVM_MEMCPY_ARM' else
      if COMMAND_SVM_MEMFILL_ARM = self then
        Result := 'COMMAND_SVM_MEMFILL_ARM' else
      if COMMAND_SVM_MAP_ARM = self then
        Result := 'COMMAND_SVM_MAP_ARM' else
      if COMMAND_SVM_UNMAP_ARM = self then
        Result := 'COMMAND_SVM_UNMAP_ARM' else
      if COMMAND_ACQUIRE_GRALLOC_OBJECTS = self then
        Result := 'COMMAND_ACQUIRE_GRALLOC_OBJECTS' else
      if COMMAND_RELEASE_GRALLOC_OBJECTS = self then
        Result := 'COMMAND_RELEASE_GRALLOC_OBJECTS' else
      if COMMAND_GENERATE_MIPMAP = self then
        Result := 'COMMAND_GENERATE_MIPMAP' else
      if COMMAND_MEMFILL = self then
        Result := 'COMMAND_MEMFILL' else
      if COMMAND_MEMCPY = self then
        Result := 'COMMAND_MEMCPY' else
      if COMMAND_MIGRATEMEM = self then
        Result := 'COMMAND_MIGRATEMEM' else
      if COMMAND_MEMADVISE = self then
        Result := 'COMMAND_MEMADVISE' else
      if COMMAND_READ_HOST_PIPE = self then
        Result := 'COMMAND_READ_HOST_PIPE' else
      if COMMAND_WRITE_HOST_PIPE = self then
        Result := 'COMMAND_WRITE_HOST_PIPE' else
        Result := $'clCommandType[{self.val}]';
    end;
    
  end;
  
  ///
  clContextInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CONTEXT_REFERENCE_COUNT:               clContextInfo read new clContextInfo($1080);
    public static property CONTEXT_DEVICES:                       clContextInfo read new clContextInfo($1081);
    public static property CONTEXT_PROPERTIES:                    clContextInfo read new clContextInfo($1082);
    public static property CONTEXT_NUM_DEVICES:                   clContextInfo read new clContextInfo($1083);
    public static property CONTEXT_D3D10_PREFER_SHARED_RESOURCES: clContextInfo read new clContextInfo($402C);
    public static property CONTEXT_D3D11_PREFER_SHARED_RESOURCES: clContextInfo read new clContextInfo($402D);
    public static property CONTEXT_VA_API_DISPLAY:                clContextInfo read new clContextInfo($4097);
    
    public function ToString: string; override;
    begin
      if CONTEXT_REFERENCE_COUNT = self then
        Result := 'CONTEXT_REFERENCE_COUNT' else
      if CONTEXT_DEVICES = self then
        Result := 'CONTEXT_DEVICES' else
      if CONTEXT_PROPERTIES = self then
        Result := 'CONTEXT_PROPERTIES' else
      if CONTEXT_NUM_DEVICES = self then
        Result := 'CONTEXT_NUM_DEVICES' else
      if CONTEXT_D3D10_PREFER_SHARED_RESOURCES = self then
        Result := 'CONTEXT_D3D10_PREFER_SHARED_RESOURCES' else
      if CONTEXT_D3D11_PREFER_SHARED_RESOURCES = self then
        Result := 'CONTEXT_D3D11_PREFER_SHARED_RESOURCES' else
      if CONTEXT_VA_API_DISPLAY = self then
        Result := 'CONTEXT_VA_API_DISPLAY' else
        Result := $'clContextInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clContextProperties = record
    public val: IntPtr;
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property CONTEXT_PLATFORM:          clContextProperties read new clContextProperties($1084);
    public static property CONTEXT_INTEROP_USER_SYNC: clContextProperties read new clContextProperties($1085);
    public static property GL_CONTEXT:                clContextProperties read new clContextProperties($2008);
    public static property EGL_DISPLAY:               clContextProperties read new clContextProperties($2009);
    public static property GLX_DISPLAY:               clContextProperties read new clContextProperties($200A);
    public static property WGL_HDC:                   clContextProperties read new clContextProperties($200B);
    public static property CGL_SHAREGROUP:            clContextProperties read new clContextProperties($200C);
    public static property CONTEXT_ADAPTER_D3D9:      clContextProperties read new clContextProperties($2025);
    public static property CONTEXT_ADAPTER_D3D9EX:    clContextProperties read new clContextProperties($2026);
    public static property CONTEXT_ADAPTER_DXVA:      clContextProperties read new clContextProperties($2027);
    public static property CONTEXT_MEMORY_INITIALIZE: clContextProperties read new clContextProperties($2030);
    public static property CONTEXT_TERMINATE:         clContextProperties read new clContextProperties($2032);
    public static property CONTEXT_D3D10_DEVICE:      clContextProperties read new clContextProperties($4014);
    public static property CONTEXT_D3D11_DEVICE:      clContextProperties read new clContextProperties($401D);
    public static property CONTEXT_D3D9_DEVICE:       clContextProperties read new clContextProperties($4026);
    public static property CONTEXT_D3D9EX_DEVICE:     clContextProperties read new clContextProperties($4072);
    public static property CONTEXT_DXVA_DEVICE:       clContextProperties read new clContextProperties($4073);
    public static property PRINTF_CALLBACK:           clContextProperties read new clContextProperties($40B0);
    public static property PRINTF_BUFFERSIZE:         clContextProperties read new clContextProperties($40B1);
    public static property CONTEXT_SHOW_DIAGNOSTICS:  clContextProperties read new clContextProperties($4106);
    
    public function ToString: string; override;
    begin
      if CONTEXT_PLATFORM = self then
        Result := 'CONTEXT_PLATFORM' else
      if CONTEXT_INTEROP_USER_SYNC = self then
        Result := 'CONTEXT_INTEROP_USER_SYNC' else
      if GL_CONTEXT = self then
        Result := 'GL_CONTEXT' else
      if EGL_DISPLAY = self then
        Result := 'EGL_DISPLAY' else
      if GLX_DISPLAY = self then
        Result := 'GLX_DISPLAY' else
      if WGL_HDC = self then
        Result := 'WGL_HDC' else
      if CGL_SHAREGROUP = self then
        Result := 'CGL_SHAREGROUP' else
      if CONTEXT_ADAPTER_D3D9 = self then
        Result := 'CONTEXT_ADAPTER_D3D9' else
      if CONTEXT_ADAPTER_D3D9EX = self then
        Result := 'CONTEXT_ADAPTER_D3D9EX' else
      if CONTEXT_ADAPTER_DXVA = self then
        Result := 'CONTEXT_ADAPTER_DXVA' else
      if CONTEXT_MEMORY_INITIALIZE = self then
        Result := 'CONTEXT_MEMORY_INITIALIZE' else
      if CONTEXT_TERMINATE = self then
        Result := 'CONTEXT_TERMINATE' else
      if CONTEXT_D3D10_DEVICE = self then
        Result := 'CONTEXT_D3D10_DEVICE' else
      if CONTEXT_D3D11_DEVICE = self then
        Result := 'CONTEXT_D3D11_DEVICE' else
      if CONTEXT_D3D9_DEVICE = self then
        Result := 'CONTEXT_D3D9_DEVICE' else
      if CONTEXT_D3D9EX_DEVICE = self then
        Result := 'CONTEXT_D3D9EX_DEVICE' else
      if CONTEXT_DXVA_DEVICE = self then
        Result := 'CONTEXT_DXVA_DEVICE' else
      if PRINTF_CALLBACK = self then
        Result := 'PRINTF_CALLBACK' else
      if PRINTF_BUFFERSIZE = self then
        Result := 'PRINTF_BUFFERSIZE' else
      if CONTEXT_SHOW_DIAGNOSTICS = self then
        Result := 'CONTEXT_SHOW_DIAGNOSTICS' else
        Result := $'clContextProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clD3D10DeviceSet = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PREFERRED_DEVICES_FOR_D3D10: clD3D10DeviceSet read new clD3D10DeviceSet($4012);
    public static property ALL_DEVICES_FOR_D3D10:       clD3D10DeviceSet read new clD3D10DeviceSet($4013);
    
    public function ToString: string; override;
    begin
      if PREFERRED_DEVICES_FOR_D3D10 = self then
        Result := 'PREFERRED_DEVICES_FOR_D3D10' else
      if ALL_DEVICES_FOR_D3D10 = self then
        Result := 'ALL_DEVICES_FOR_D3D10' else
        Result := $'clD3D10DeviceSet[{self.val}]';
    end;
    
  end;
  
  ///
  clD3D10DeviceSource = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property D3D10_DEVICE:       clD3D10DeviceSource read new clD3D10DeviceSource($4010);
    public static property D3D10_DXGI_ADAPTER: clD3D10DeviceSource read new clD3D10DeviceSource($4011);
    
    public function ToString: string; override;
    begin
      if D3D10_DEVICE = self then
        Result := 'D3D10_DEVICE' else
      if D3D10_DXGI_ADAPTER = self then
        Result := 'D3D10_DXGI_ADAPTER' else
        Result := $'clD3D10DeviceSource[{self.val}]';
    end;
    
  end;
  
  ///
  clD3D11DeviceSet = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PREFERRED_DEVICES_FOR_D3D11: clD3D11DeviceSet read new clD3D11DeviceSet($401B);
    public static property ALL_DEVICES_FOR_D3D11:       clD3D11DeviceSet read new clD3D11DeviceSet($401C);
    
    public function ToString: string; override;
    begin
      if PREFERRED_DEVICES_FOR_D3D11 = self then
        Result := 'PREFERRED_DEVICES_FOR_D3D11' else
      if ALL_DEVICES_FOR_D3D11 = self then
        Result := 'ALL_DEVICES_FOR_D3D11' else
        Result := $'clD3D11DeviceSet[{self.val}]';
    end;
    
  end;
  
  ///
  clD3D11DeviceSource = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property D3D11_DEVICE:       clD3D11DeviceSource read new clD3D11DeviceSource($4019);
    public static property D3D11_DXGI_ADAPTER: clD3D11DeviceSource read new clD3D11DeviceSource($401A);
    
    public function ToString: string; override;
    begin
      if D3D11_DEVICE = self then
        Result := 'D3D11_DEVICE' else
      if D3D11_DXGI_ADAPTER = self then
        Result := 'D3D11_DXGI_ADAPTER' else
        Result := $'clD3D11DeviceSource[{self.val}]';
    end;
    
  end;
  
  ///
  clDeviceAffinityDomain = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_AFFINITY_DOMAIN_NUMA:               clDeviceAffinityDomain read new clDeviceAffinityDomain(1 shl 0);
    public static property DEVICE_AFFINITY_DOMAIN_L4_CACHE:           clDeviceAffinityDomain read new clDeviceAffinityDomain(1 shl 1);
    public static property DEVICE_AFFINITY_DOMAIN_L3_CACHE:           clDeviceAffinityDomain read new clDeviceAffinityDomain(1 shl 2);
    public static property DEVICE_AFFINITY_DOMAIN_L2_CACHE:           clDeviceAffinityDomain read new clDeviceAffinityDomain(1 shl 3);
    public static property DEVICE_AFFINITY_DOMAIN_L1_CACHE:           clDeviceAffinityDomain read new clDeviceAffinityDomain(1 shl 4);
    public static property DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE: clDeviceAffinityDomain read new clDeviceAffinityDomain(1 shl 5);
    
    public static function operator+(v1, v2: clDeviceAffinityDomain) := new clDeviceAffinityDomain(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceAffinityDomain) := new clDeviceAffinityDomain(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceAffinityDomain; v2: clDeviceAffinityDomain) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceAffinityDomain) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceAffinityDomain[0]';
        exit;
      end;
      if DEVICE_AFFINITY_DOMAIN_NUMA in self then
      begin
        res += 'DEVICE_AFFINITY_DOMAIN_NUMA+';
        left_val := left_val and not DEVICE_AFFINITY_DOMAIN_NUMA.val;
      end;
      if DEVICE_AFFINITY_DOMAIN_L4_CACHE in self then
      begin
        res += 'DEVICE_AFFINITY_DOMAIN_L4_CACHE+';
        left_val := left_val and not DEVICE_AFFINITY_DOMAIN_L4_CACHE.val;
      end;
      if DEVICE_AFFINITY_DOMAIN_L3_CACHE in self then
      begin
        res += 'DEVICE_AFFINITY_DOMAIN_L3_CACHE+';
        left_val := left_val and not DEVICE_AFFINITY_DOMAIN_L3_CACHE.val;
      end;
      if DEVICE_AFFINITY_DOMAIN_L2_CACHE in self then
      begin
        res += 'DEVICE_AFFINITY_DOMAIN_L2_CACHE+';
        left_val := left_val and not DEVICE_AFFINITY_DOMAIN_L2_CACHE.val;
      end;
      if DEVICE_AFFINITY_DOMAIN_L1_CACHE in self then
      begin
        res += 'DEVICE_AFFINITY_DOMAIN_L1_CACHE+';
        left_val := left_val and not DEVICE_AFFINITY_DOMAIN_L1_CACHE.val;
      end;
      if DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE in self then
      begin
        res += 'DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE+';
        left_val := left_val and not DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceAffinityDomain[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceAtomicCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_ATOMIC_ORDER_RELAXED:     clDeviceAtomicCapabilities read new clDeviceAtomicCapabilities(1 shl 0);
    public static property DEVICE_ATOMIC_ORDER_ACQ_REL:     clDeviceAtomicCapabilities read new clDeviceAtomicCapabilities(1 shl 1);
    public static property DEVICE_ATOMIC_ORDER_SEQ_CST:     clDeviceAtomicCapabilities read new clDeviceAtomicCapabilities(1 shl 2);
    public static property DEVICE_ATOMIC_SCOPE_WORK_ITEM:   clDeviceAtomicCapabilities read new clDeviceAtomicCapabilities(1 shl 3);
    public static property DEVICE_ATOMIC_SCOPE_WORK_GROUP:  clDeviceAtomicCapabilities read new clDeviceAtomicCapabilities(1 shl 4);
    public static property DEVICE_ATOMIC_SCOPE_DEVICE:      clDeviceAtomicCapabilities read new clDeviceAtomicCapabilities(1 shl 5);
    public static property DEVICE_ATOMIC_SCOPE_ALL_DEVICES: clDeviceAtomicCapabilities read new clDeviceAtomicCapabilities(1 shl 6);
    
    public static function operator+(v1, v2: clDeviceAtomicCapabilities) := new clDeviceAtomicCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceAtomicCapabilities) := new clDeviceAtomicCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceAtomicCapabilities; v2: clDeviceAtomicCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceAtomicCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceAtomicCapabilities[0]';
        exit;
      end;
      if DEVICE_ATOMIC_ORDER_RELAXED in self then
      begin
        res += 'DEVICE_ATOMIC_ORDER_RELAXED+';
        left_val := left_val and not DEVICE_ATOMIC_ORDER_RELAXED.val;
      end;
      if DEVICE_ATOMIC_ORDER_ACQ_REL in self then
      begin
        res += 'DEVICE_ATOMIC_ORDER_ACQ_REL+';
        left_val := left_val and not DEVICE_ATOMIC_ORDER_ACQ_REL.val;
      end;
      if DEVICE_ATOMIC_ORDER_SEQ_CST in self then
      begin
        res += 'DEVICE_ATOMIC_ORDER_SEQ_CST+';
        left_val := left_val and not DEVICE_ATOMIC_ORDER_SEQ_CST.val;
      end;
      if DEVICE_ATOMIC_SCOPE_WORK_ITEM in self then
      begin
        res += 'DEVICE_ATOMIC_SCOPE_WORK_ITEM+';
        left_val := left_val and not DEVICE_ATOMIC_SCOPE_WORK_ITEM.val;
      end;
      if DEVICE_ATOMIC_SCOPE_WORK_GROUP in self then
      begin
        res += 'DEVICE_ATOMIC_SCOPE_WORK_GROUP+';
        left_val := left_val and not DEVICE_ATOMIC_SCOPE_WORK_GROUP.val;
      end;
      if DEVICE_ATOMIC_SCOPE_DEVICE in self then
      begin
        res += 'DEVICE_ATOMIC_SCOPE_DEVICE+';
        left_val := left_val and not DEVICE_ATOMIC_SCOPE_DEVICE.val;
      end;
      if DEVICE_ATOMIC_SCOPE_ALL_DEVICES in self then
      begin
        res += 'DEVICE_ATOMIC_SCOPE_ALL_DEVICES+';
        left_val := left_val and not DEVICE_ATOMIC_SCOPE_ALL_DEVICES.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceAtomicCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceAvcMeVersion = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property AVC_ME_VERSION_0: clDeviceAvcMeVersion read new clDeviceAvcMeVersion(0);
    public static property AVC_ME_VERSION_1: clDeviceAvcMeVersion read new clDeviceAvcMeVersion($0001);
    
    public function ToString: string; override;
    begin
      if AVC_ME_VERSION_0 = self then
        Result := 'AVC_ME_VERSION_0' else
      if AVC_ME_VERSION_1 = self then
        Result := 'AVC_ME_VERSION_1' else
        Result := $'clDeviceAvcMeVersion[{self.val}]';
    end;
    
  end;
  
  ///
  clDeviceCommandBufferCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF:       clDeviceCommandBufferCapabilities read new clDeviceCommandBufferCapabilities(1 shl 0);
    public static property COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE: clDeviceCommandBufferCapabilities read new clDeviceCommandBufferCapabilities(1 shl 1);
    public static property COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE:    clDeviceCommandBufferCapabilities read new clDeviceCommandBufferCapabilities(1 shl 2);
    public static property COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER:        clDeviceCommandBufferCapabilities read new clDeviceCommandBufferCapabilities(1 shl 3);
    public static property COMMAND_BUFFER_CAPABILITY_MULTIPLE_QUEUE:      clDeviceCommandBufferCapabilities read new clDeviceCommandBufferCapabilities(1 shl 4);
    
    public static function operator+(v1, v2: clDeviceCommandBufferCapabilities) := new clDeviceCommandBufferCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceCommandBufferCapabilities) := new clDeviceCommandBufferCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceCommandBufferCapabilities; v2: clDeviceCommandBufferCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceCommandBufferCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceCommandBufferCapabilities[0]';
        exit;
      end;
      if COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF in self then
      begin
        res += 'COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF+';
        left_val := left_val and not COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF.val;
      end;
      if COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE in self then
      begin
        res += 'COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE+';
        left_val := left_val and not COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE.val;
      end;
      if COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE in self then
      begin
        res += 'COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE+';
        left_val := left_val and not COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE.val;
      end;
      if COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER in self then
      begin
        res += 'COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER+';
        left_val := left_val and not COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER.val;
      end;
      if COMMAND_BUFFER_CAPABILITY_MULTIPLE_QUEUE in self then
      begin
        res += 'COMMAND_BUFFER_CAPABILITY_MULTIPLE_QUEUE+';
        left_val := left_val and not COMMAND_BUFFER_CAPABILITY_MULTIPLE_QUEUE.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceCommandBufferCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceControlledTerminationCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_CONTROLLED_TERMINATION_SUCCESS: clDeviceControlledTerminationCapabilities read new clDeviceControlledTerminationCapabilities(1 shl 0);
    public static property DEVICE_CONTROLLED_TERMINATION_FAILURE: clDeviceControlledTerminationCapabilities read new clDeviceControlledTerminationCapabilities(1 shl 1);
    public static property DEVICE_CONTROLLED_TERMINATION_QUERY:   clDeviceControlledTerminationCapabilities read new clDeviceControlledTerminationCapabilities(1 shl 2);
    
    public static function operator+(v1, v2: clDeviceControlledTerminationCapabilities) := new clDeviceControlledTerminationCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceControlledTerminationCapabilities) := new clDeviceControlledTerminationCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceControlledTerminationCapabilities; v2: clDeviceControlledTerminationCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceControlledTerminationCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceControlledTerminationCapabilities[0]';
        exit;
      end;
      if DEVICE_CONTROLLED_TERMINATION_SUCCESS in self then
      begin
        res += 'DEVICE_CONTROLLED_TERMINATION_SUCCESS+';
        left_val := left_val and not DEVICE_CONTROLLED_TERMINATION_SUCCESS.val;
      end;
      if DEVICE_CONTROLLED_TERMINATION_FAILURE in self then
      begin
        res += 'DEVICE_CONTROLLED_TERMINATION_FAILURE+';
        left_val := left_val and not DEVICE_CONTROLLED_TERMINATION_FAILURE.val;
      end;
      if DEVICE_CONTROLLED_TERMINATION_QUERY in self then
      begin
        res += 'DEVICE_CONTROLLED_TERMINATION_QUERY+';
        left_val := left_val and not DEVICE_CONTROLLED_TERMINATION_QUERY.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceControlledTerminationCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceExecCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property EXEC_KERNEL:        clDeviceExecCapabilities read new clDeviceExecCapabilities(1 shl 0);
    public static property EXEC_NATIVE_KERNEL: clDeviceExecCapabilities read new clDeviceExecCapabilities(1 shl 1);
    
    public static function operator+(v1, v2: clDeviceExecCapabilities) := new clDeviceExecCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceExecCapabilities) := new clDeviceExecCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceExecCapabilities; v2: clDeviceExecCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceExecCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceExecCapabilities[0]';
        exit;
      end;
      if EXEC_KERNEL in self then
      begin
        res += 'EXEC_KERNEL+';
        left_val := left_val and not EXEC_KERNEL.val;
      end;
      if EXEC_NATIVE_KERNEL in self then
      begin
        res += 'EXEC_NATIVE_KERNEL+';
        left_val := left_val and not EXEC_NATIVE_KERNEL.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceExecCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceFeatureCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_FEATURE_FLAG_DP4A: clDeviceFeatureCapabilities read new clDeviceFeatureCapabilities(1 shl 0);
    public static property DEVICE_FEATURE_FLAG_DPAS: clDeviceFeatureCapabilities read new clDeviceFeatureCapabilities(1 shl 1);
    
    public static function operator+(v1, v2: clDeviceFeatureCapabilities) := new clDeviceFeatureCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceFeatureCapabilities) := new clDeviceFeatureCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceFeatureCapabilities; v2: clDeviceFeatureCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceFeatureCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceFeatureCapabilities[0]';
        exit;
      end;
      if DEVICE_FEATURE_FLAG_DP4A in self then
      begin
        res += 'DEVICE_FEATURE_FLAG_DP4A+';
        left_val := left_val and not DEVICE_FEATURE_FLAG_DP4A.val;
      end;
      if DEVICE_FEATURE_FLAG_DPAS in self then
      begin
        res += 'DEVICE_FEATURE_FLAG_DPAS+';
        left_val := left_val and not DEVICE_FEATURE_FLAG_DPAS.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceFeatureCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceFpAtomicCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_GLOBAL_FP_ATOMIC_LOAD_STORE: clDeviceFpAtomicCapabilities read new clDeviceFpAtomicCapabilities(1 shl 0);
    public static property DEVICE_GLOBAL_FP_ATOMIC_ADD:        clDeviceFpAtomicCapabilities read new clDeviceFpAtomicCapabilities(1 shl 1);
    public static property DEVICE_GLOBAL_FP_ATOMIC_MIN_MAX:    clDeviceFpAtomicCapabilities read new clDeviceFpAtomicCapabilities(1 shl 2);
    public static property DEVICE_LOCAL_FP_ATOMIC_LOAD_STORE:  clDeviceFpAtomicCapabilities read new clDeviceFpAtomicCapabilities(1 shl 16);
    public static property DEVICE_LOCAL_FP_ATOMIC_ADD:         clDeviceFpAtomicCapabilities read new clDeviceFpAtomicCapabilities(1 shl 17);
    public static property DEVICE_LOCAL_FP_ATOMIC_MIN_MAX:     clDeviceFpAtomicCapabilities read new clDeviceFpAtomicCapabilities(1 shl 18);
    
    public static function operator+(v1, v2: clDeviceFpAtomicCapabilities) := new clDeviceFpAtomicCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceFpAtomicCapabilities) := new clDeviceFpAtomicCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceFpAtomicCapabilities; v2: clDeviceFpAtomicCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceFpAtomicCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceFpAtomicCapabilities[0]';
        exit;
      end;
      if DEVICE_GLOBAL_FP_ATOMIC_LOAD_STORE in self then
      begin
        res += 'DEVICE_GLOBAL_FP_ATOMIC_LOAD_STORE+';
        left_val := left_val and not DEVICE_GLOBAL_FP_ATOMIC_LOAD_STORE.val;
      end;
      if DEVICE_GLOBAL_FP_ATOMIC_ADD in self then
      begin
        res += 'DEVICE_GLOBAL_FP_ATOMIC_ADD+';
        left_val := left_val and not DEVICE_GLOBAL_FP_ATOMIC_ADD.val;
      end;
      if DEVICE_GLOBAL_FP_ATOMIC_MIN_MAX in self then
      begin
        res += 'DEVICE_GLOBAL_FP_ATOMIC_MIN_MAX+';
        left_val := left_val and not DEVICE_GLOBAL_FP_ATOMIC_MIN_MAX.val;
      end;
      if DEVICE_LOCAL_FP_ATOMIC_LOAD_STORE in self then
      begin
        res += 'DEVICE_LOCAL_FP_ATOMIC_LOAD_STORE+';
        left_val := left_val and not DEVICE_LOCAL_FP_ATOMIC_LOAD_STORE.val;
      end;
      if DEVICE_LOCAL_FP_ATOMIC_ADD in self then
      begin
        res += 'DEVICE_LOCAL_FP_ATOMIC_ADD+';
        left_val := left_val and not DEVICE_LOCAL_FP_ATOMIC_ADD.val;
      end;
      if DEVICE_LOCAL_FP_ATOMIC_MIN_MAX in self then
      begin
        res += 'DEVICE_LOCAL_FP_ATOMIC_MIN_MAX+';
        left_val := left_val and not DEVICE_LOCAL_FP_ATOMIC_MIN_MAX.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceFpAtomicCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceFPConfig = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property FP_DENORM:                        clDeviceFPConfig read new clDeviceFPConfig(1 shl 0);
    public static property FP_INF_NAN:                       clDeviceFPConfig read new clDeviceFPConfig(1 shl 1);
    public static property FP_ROUND_TO_NEAREST:              clDeviceFPConfig read new clDeviceFPConfig(1 shl 2);
    public static property FP_ROUND_TO_ZERO:                 clDeviceFPConfig read new clDeviceFPConfig(1 shl 3);
    public static property FP_ROUND_TO_INF:                  clDeviceFPConfig read new clDeviceFPConfig(1 shl 4);
    public static property FP_FMA:                           clDeviceFPConfig read new clDeviceFPConfig(1 shl 5);
    public static property FP_SOFT_FLOAT:                    clDeviceFPConfig read new clDeviceFPConfig(1 shl 6);
    public static property FP_CORRECTLY_ROUNDED_DIVIDE_SQRT: clDeviceFPConfig read new clDeviceFPConfig(1 shl 7);
    
    public static function operator+(v1, v2: clDeviceFPConfig) := new clDeviceFPConfig(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceFPConfig) := new clDeviceFPConfig(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceFPConfig; v2: clDeviceFPConfig) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceFPConfig) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceFPConfig[0]';
        exit;
      end;
      if FP_DENORM in self then
      begin
        res += 'FP_DENORM+';
        left_val := left_val and not FP_DENORM.val;
      end;
      if FP_INF_NAN in self then
      begin
        res += 'FP_INF_NAN+';
        left_val := left_val and not FP_INF_NAN.val;
      end;
      if FP_ROUND_TO_NEAREST in self then
      begin
        res += 'FP_ROUND_TO_NEAREST+';
        left_val := left_val and not FP_ROUND_TO_NEAREST.val;
      end;
      if FP_ROUND_TO_ZERO in self then
      begin
        res += 'FP_ROUND_TO_ZERO+';
        left_val := left_val and not FP_ROUND_TO_ZERO.val;
      end;
      if FP_ROUND_TO_INF in self then
      begin
        res += 'FP_ROUND_TO_INF+';
        left_val := left_val and not FP_ROUND_TO_INF.val;
      end;
      if FP_FMA in self then
      begin
        res += 'FP_FMA+';
        left_val := left_val and not FP_FMA.val;
      end;
      if FP_SOFT_FLOAT in self then
      begin
        res += 'FP_SOFT_FLOAT+';
        left_val := left_val and not FP_SOFT_FLOAT.val;
      end;
      if FP_CORRECTLY_ROUNDED_DIVIDE_SQRT in self then
      begin
        res += 'FP_CORRECTLY_ROUNDED_DIVIDE_SQRT+';
        left_val := left_val and not FP_CORRECTLY_ROUNDED_DIVIDE_SQRT.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceFPConfig[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DEVICE_TYPE:                                                      clDeviceInfo read new clDeviceInfo($1000);
    public static property DEVICE_VENDOR_ID:                                                 clDeviceInfo read new clDeviceInfo($1001);
    public static property DEVICE_MAX_COMPUTE_UNITS:                                         clDeviceInfo read new clDeviceInfo($1002);
    public static property DEVICE_MAX_WORK_ITEM_DIMENSIONS:                                  clDeviceInfo read new clDeviceInfo($1003);
    public static property DEVICE_MAX_WORK_GROUP_SIZE:                                       clDeviceInfo read new clDeviceInfo($1004);
    public static property DEVICE_MAX_WORK_ITEM_SIZES:                                       clDeviceInfo read new clDeviceInfo($1005);
    public static property DEVICE_PREFERRED_VECTOR_WIDTH_CHAR:                               clDeviceInfo read new clDeviceInfo($1006);
    public static property DEVICE_PREFERRED_VECTOR_WIDTH_SHORT:                              clDeviceInfo read new clDeviceInfo($1007);
    public static property DEVICE_PREFERRED_VECTOR_WIDTH_INT:                                clDeviceInfo read new clDeviceInfo($1008);
    public static property DEVICE_PREFERRED_VECTOR_WIDTH_LONG:                               clDeviceInfo read new clDeviceInfo($1009);
    public static property DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT:                              clDeviceInfo read new clDeviceInfo($100A);
    public static property DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE:                             clDeviceInfo read new clDeviceInfo($100B);
    public static property DEVICE_MAX_CLOCK_FREQUENCY:                                       clDeviceInfo read new clDeviceInfo($100C);
    public static property DEVICE_ADDRESS_BITS:                                              clDeviceInfo read new clDeviceInfo($100D);
    public static property DEVICE_MAX_READ_IMAGE_ARGS:                                       clDeviceInfo read new clDeviceInfo($100E);
    public static property DEVICE_MAX_WRITE_IMAGE_ARGS:                                      clDeviceInfo read new clDeviceInfo($100F);
    public static property DEVICE_MAX_MEM_ALLOC_SIZE:                                        clDeviceInfo read new clDeviceInfo($1010);
    public static property DEVICE_IMAGE2D_MAX_WIDTH:                                         clDeviceInfo read new clDeviceInfo($1011);
    public static property DEVICE_IMAGE2D_MAX_HEIGHT:                                        clDeviceInfo read new clDeviceInfo($1012);
    public static property DEVICE_IMAGE3D_MAX_WIDTH:                                         clDeviceInfo read new clDeviceInfo($1013);
    public static property DEVICE_IMAGE3D_MAX_HEIGHT:                                        clDeviceInfo read new clDeviceInfo($1014);
    public static property DEVICE_IMAGE3D_MAX_DEPTH:                                         clDeviceInfo read new clDeviceInfo($1015);
    public static property DEVICE_IMAGE_SUPPORT:                                             clDeviceInfo read new clDeviceInfo($1016);
    public static property DEVICE_MAX_PARAMETER_SIZE:                                        clDeviceInfo read new clDeviceInfo($1017);
    public static property DEVICE_MAX_SAMPLERS:                                              clDeviceInfo read new clDeviceInfo($1018);
    public static property DEVICE_MEM_BASE_ADDR_ALIGN:                                       clDeviceInfo read new clDeviceInfo($1019);
    public static property DEVICE_MIN_DATA_TYPE_ALIGN_SIZE:                                  clDeviceInfo read new clDeviceInfo($101A);
    public static property DEVICE_SINGLE_FP_CONFIG:                                          clDeviceInfo read new clDeviceInfo($101B);
    public static property DEVICE_GLOBAL_MEM_CACHE_TYPE:                                     clDeviceInfo read new clDeviceInfo($101C);
    public static property DEVICE_GLOBAL_MEM_CACHELINE_SIZE:                                 clDeviceInfo read new clDeviceInfo($101D);
    public static property DEVICE_GLOBAL_MEM_CACHE_SIZE:                                     clDeviceInfo read new clDeviceInfo($101E);
    public static property DEVICE_GLOBAL_MEM_SIZE:                                           clDeviceInfo read new clDeviceInfo($101F);
    public static property DEVICE_MAX_CONSTANT_BUFFER_SIZE:                                  clDeviceInfo read new clDeviceInfo($1020);
    public static property DEVICE_MAX_CONSTANT_ARGS:                                         clDeviceInfo read new clDeviceInfo($1021);
    public static property DEVICE_LOCAL_MEM_TYPE:                                            clDeviceInfo read new clDeviceInfo($1022);
    public static property DEVICE_LOCAL_MEM_SIZE:                                            clDeviceInfo read new clDeviceInfo($1023);
    public static property DEVICE_ERROR_CORRECTION_SUPPORT:                                  clDeviceInfo read new clDeviceInfo($1024);
    public static property DEVICE_PROFILING_TIMER_RESOLUTION:                                clDeviceInfo read new clDeviceInfo($1025);
    public static property DEVICE_ENDIAN_LITTLE:                                             clDeviceInfo read new clDeviceInfo($1026);
    public static property DEVICE_AVAILABLE:                                                 clDeviceInfo read new clDeviceInfo($1027);
    public static property DEVICE_COMPILER_AVAILABLE:                                        clDeviceInfo read new clDeviceInfo($1028);
    public static property DEVICE_EXECUTION_CAPABILITIES:                                    clDeviceInfo read new clDeviceInfo($1029);
    public static property DEVICE_QUEUE_PROPERTIES:                                          clDeviceInfo read new clDeviceInfo($102A);
    public static property DEVICE_QUEUE_ON_HOST_PROPERTIES:                                  clDeviceInfo read new clDeviceInfo($102A);
    public static property DEVICE_NAME:                                                      clDeviceInfo read new clDeviceInfo($102B);
    public static property DEVICE_VENDOR:                                                    clDeviceInfo read new clDeviceInfo($102C);
    public static property DRIVER_VERSION:                                                   clDeviceInfo read new clDeviceInfo($102D);
    public static property DEVICE_PROFILE:                                                   clDeviceInfo read new clDeviceInfo($102E);
    public static property DEVICE_VERSION:                                                   clDeviceInfo read new clDeviceInfo($102F);
    public static property DEVICE_EXTENSIONS:                                                clDeviceInfo read new clDeviceInfo($1030);
    public static property DEVICE_PLATFORM:                                                  clDeviceInfo read new clDeviceInfo($1031);
    public static property DEVICE_DOUBLE_FP_CONFIG:                                          clDeviceInfo read new clDeviceInfo($1032);
    public static property DEVICE_HALF_FP_CONFIG:                                            clDeviceInfo read new clDeviceInfo($1033);
    public static property DEVICE_PREFERRED_VECTOR_WIDTH_HALF:                               clDeviceInfo read new clDeviceInfo($1034);
    public static property DEVICE_HOST_UNIFIED_MEMORY:                                       clDeviceInfo read new clDeviceInfo($1035);
    public static property DEVICE_NATIVE_VECTOR_WIDTH_CHAR:                                  clDeviceInfo read new clDeviceInfo($1036);
    public static property DEVICE_NATIVE_VECTOR_WIDTH_SHORT:                                 clDeviceInfo read new clDeviceInfo($1037);
    public static property DEVICE_NATIVE_VECTOR_WIDTH_INT:                                   clDeviceInfo read new clDeviceInfo($1038);
    public static property DEVICE_NATIVE_VECTOR_WIDTH_LONG:                                  clDeviceInfo read new clDeviceInfo($1039);
    public static property DEVICE_NATIVE_VECTOR_WIDTH_FLOAT:                                 clDeviceInfo read new clDeviceInfo($103A);
    public static property DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE:                                clDeviceInfo read new clDeviceInfo($103B);
    public static property DEVICE_NATIVE_VECTOR_WIDTH_HALF:                                  clDeviceInfo read new clDeviceInfo($103C);
    public static property DEVICE_OPENCL_C_VERSION:                                          clDeviceInfo read new clDeviceInfo($103D);
    public static property DEVICE_LINKER_AVAILABLE:                                          clDeviceInfo read new clDeviceInfo($103E);
    public static property DEVICE_BUILT_IN_KERNELS:                                          clDeviceInfo read new clDeviceInfo($103F);
    public static property DEVICE_IMAGE_MAX_BUFFER_SIZE:                                     clDeviceInfo read new clDeviceInfo($1040);
    public static property DEVICE_IMAGE_MAX_ARRAY_SIZE:                                      clDeviceInfo read new clDeviceInfo($1041);
    public static property DEVICE_PARENT_DEVICE:                                             clDeviceInfo read new clDeviceInfo($1042);
    public static property DEVICE_PARTITION_MAX_SUB_DEVICES:                                 clDeviceInfo read new clDeviceInfo($1043);
    public static property DEVICE_PARTITION_PROPERTIES:                                      clDeviceInfo read new clDeviceInfo($1044);
    public static property DEVICE_PARTITION_AFFINITY_DOMAIN:                                 clDeviceInfo read new clDeviceInfo($1045);
    public static property DEVICE_PARTITION_TYPE:                                            clDeviceInfo read new clDeviceInfo($1046);
    public static property DEVICE_REFERENCE_COUNT:                                           clDeviceInfo read new clDeviceInfo($1047);
    public static property DEVICE_PREFERRED_INTEROP_USER_SYNC:                               clDeviceInfo read new clDeviceInfo($1048);
    public static property DEVICE_PRINTF_BUFFER_SIZE:                                        clDeviceInfo read new clDeviceInfo($1049);
    public static property DEVICE_IMAGE_PITCH_ALIGNMENT:                                     clDeviceInfo read new clDeviceInfo($104A);
    public static property DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT:                              clDeviceInfo read new clDeviceInfo($104B);
    public static property DEVICE_MAX_READ_WRITE_IMAGE_ARGS:                                 clDeviceInfo read new clDeviceInfo($104C);
    public static property DEVICE_MAX_GLOBAL_VARIABLE_SIZE:                                  clDeviceInfo read new clDeviceInfo($104D);
    public static property DEVICE_QUEUE_ON_DEVICE_PROPERTIES:                                clDeviceInfo read new clDeviceInfo($104E);
    public static property DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE:                            clDeviceInfo read new clDeviceInfo($104F);
    public static property DEVICE_QUEUE_ON_DEVICE_MAX_SIZE:                                  clDeviceInfo read new clDeviceInfo($1050);
    public static property DEVICE_MAX_ON_DEVICE_QUEUES:                                      clDeviceInfo read new clDeviceInfo($1051);
    public static property DEVICE_MAX_ON_DEVICE_EVENTS:                                      clDeviceInfo read new clDeviceInfo($1052);
    public static property DEVICE_SVM_CAPABILITIES:                                          clDeviceInfo read new clDeviceInfo($1053);
    public static property DEVICE_GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE:                      clDeviceInfo read new clDeviceInfo($1054);
    public static property DEVICE_MAX_PIPE_ARGS:                                             clDeviceInfo read new clDeviceInfo($1055);
    public static property DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS:                              clDeviceInfo read new clDeviceInfo($1056);
    public static property DEVICE_PIPE_MAX_PACKET_SIZE:                                      clDeviceInfo read new clDeviceInfo($1057);
    public static property DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT:                       clDeviceInfo read new clDeviceInfo($1058);
    public static property DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT:                         clDeviceInfo read new clDeviceInfo($1059);
    public static property DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT:                          clDeviceInfo read new clDeviceInfo($105A);
    public static property DEVICE_IL_VERSION:                                                clDeviceInfo read new clDeviceInfo($105B);
    public static property DEVICE_MAX_NUM_SUB_GROUPS:                                        clDeviceInfo read new clDeviceInfo($105C);
    public static property DEVICE_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS:                    clDeviceInfo read new clDeviceInfo($105D);
    public static property DEVICE_NUMERIC_VERSION:                                           clDeviceInfo read new clDeviceInfo($105E);
    public static property DEVICE_OPENCL_C_NUMERIC_VERSION:                                  clDeviceInfo read new clDeviceInfo($105F);
    public static property DEVICE_EXTENSIONS_WITH_VERSION:                                   clDeviceInfo read new clDeviceInfo($1060);
    public static property DEVICE_ILS_WITH_VERSION:                                          clDeviceInfo read new clDeviceInfo($1061);
    public static property DEVICE_BUILT_IN_KERNELS_WITH_VERSION:                             clDeviceInfo read new clDeviceInfo($1062);
    public static property DEVICE_ATOMIC_MEMORY_CAPABILITIES:                                clDeviceInfo read new clDeviceInfo($1063);
    public static property DEVICE_ATOMIC_FENCE_CAPABILITIES:                                 clDeviceInfo read new clDeviceInfo($1064);
    public static property DEVICE_NON_UNIFORM_WORK_GROUP_SUPPORT:                            clDeviceInfo read new clDeviceInfo($1065);
    public static property DEVICE_OPENCL_C_ALL_VERSIONS:                                     clDeviceInfo read new clDeviceInfo($1066);
    public static property DEVICE_PREFERRED_WORK_GROUP_SIZE_MULTIPLE:                        clDeviceInfo read new clDeviceInfo($1067);
    public static property DEVICE_WORK_GROUP_COLLECTIVE_FUNCTIONS_SUPPORT:                   clDeviceInfo read new clDeviceInfo($1068);
    public static property DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT:                             clDeviceInfo read new clDeviceInfo($1069);
    public static property DEVICE_UUID:                                                      clDeviceInfo read new clDeviceInfo($106A);
    public static property DRIVER_UUID:                                                      clDeviceInfo read new clDeviceInfo($106B);
    public static property DEVICE_LUID_VALID:                                                clDeviceInfo read new clDeviceInfo($106C);
    public static property DEVICE_LUID:                                                      clDeviceInfo read new clDeviceInfo($106D);
    public static property DEVICE_NODE_MASK:                                                 clDeviceInfo read new clDeviceInfo($106E);
    public static property DEVICE_OPENCL_C_FEATURES:                                         clDeviceInfo read new clDeviceInfo($106F);
    public static property DEVICE_DEVICE_ENQUEUE_CAPABILITIES:                               clDeviceInfo read new clDeviceInfo($1070);
    public static property DEVICE_PIPE_SUPPORT:                                              clDeviceInfo read new clDeviceInfo($1071);
    public static property DEVICE_LATEST_CONFORMANCE_VERSION_PASSED:                         clDeviceInfo read new clDeviceInfo($1072);
    public static property DEVICE_INTEGER_DOT_PRODUCT_CAPABILITIES:                          clDeviceInfo read new clDeviceInfo($1073);
    public static property DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_8BIT:          clDeviceInfo read new clDeviceInfo($1074);
    public static property DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_4x8BIT_PACKED: clDeviceInfo read new clDeviceInfo($1075);
    public static property DEVICE_COMMAND_BUFFER_CAPABILITIES:                               clDeviceInfo read new clDeviceInfo($12A9);
    public static property DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES:                  clDeviceInfo read new clDeviceInfo($12AA);
    public static property DEVICE_COMMAND_BUFFER_NUM_SYNC_DEVICES:                           clDeviceInfo read new clDeviceInfo($12AB);
    public static property DEVICE_COMMAND_BUFFER_SYNC_DEVICES:                               clDeviceInfo read new clDeviceInfo($12AC);
    public static property DEVICE_MUTABLE_DISPATCH_CAPABILITIES:                             clDeviceInfo read new clDeviceInfo($12B0);
    public static property DEVICE_TERMINATE_CAPABILITY:                                      clDeviceInfo read new clDeviceInfo($2031);
    public static property DEVICE_MAX_NAMED_BARRIER_COUNT:                                   clDeviceInfo read new clDeviceInfo($2035);
    public static property DEVICE_SEMAPHORE_TYPES:                                           clDeviceInfo read new clDeviceInfo($204C);
    public static property DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES:                             clDeviceInfo read new clDeviceInfo($204D);
    public static property DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES:                             clDeviceInfo read new clDeviceInfo($204E);
    public static property DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES:                       clDeviceInfo read new clDeviceInfo($204F);
    public static property DEVICE_COMPUTE_CAPABILITY_MAJOR:                                  clDeviceInfo read new clDeviceInfo($4000);
    public static property DEVICE_COMPUTE_CAPABILITY_MINOR:                                  clDeviceInfo read new clDeviceInfo($4001);
    public static property DEVICE_REGISTERS_PER_BLOCK:                                       clDeviceInfo read new clDeviceInfo($4002);
    public static property DEVICE_WARP_SIZE:                                                 clDeviceInfo read new clDeviceInfo($4003);
    public static property DEVICE_GPU_OVERLAP:                                               clDeviceInfo read new clDeviceInfo($4004);
    public static property DEVICE_KERNEL_EXEC_TIMEOUT:                                       clDeviceInfo read new clDeviceInfo($4005);
    public static property DEVICE_INTEGRATED_MEMORY:                                         clDeviceInfo read new clDeviceInfo($4006);
    public static property DEVICE_PREFERRED_WORK_GROUP_SIZE:                                 clDeviceInfo read new clDeviceInfo($4030);
    public static property DEVICE_MAX_WORK_GROUP_SIZE_AMD:                                   clDeviceInfo read new clDeviceInfo($4031);
    public static property DEVICE_PREFERRED_CONSTANT_BUFFER_SIZE:                            clDeviceInfo read new clDeviceInfo($4033);
    public static property DEVICE_PCIE_ID:                                                   clDeviceInfo read new clDeviceInfo($4034);
    public static property DEVICE_PROFILING_TIMER_OFFSET:                                    clDeviceInfo read new clDeviceInfo($4036);
    public static property DEVICE_TOPOLOGY:                                                  clDeviceInfo read new clDeviceInfo($4037);
    public static property DEVICE_BOARD_NAME:                                                clDeviceInfo read new clDeviceInfo($4038);
    public static property DEVICE_GLOBAL_FREE_MEMORY:                                        clDeviceInfo read new clDeviceInfo($4039);
    public static property DEVICE_SIMD_PER_COMPUTE_UNIT:                                     clDeviceInfo read new clDeviceInfo($4040);
    public static property DEVICE_SIMD_WIDTH:                                                clDeviceInfo read new clDeviceInfo($4041);
    public static property DEVICE_SIMD_INSTRUCTION_WIDTH:                                    clDeviceInfo read new clDeviceInfo($4042);
    public static property DEVICE_WAVEFRONT_WIDTH:                                           clDeviceInfo read new clDeviceInfo($4043);
    public static property DEVICE_GLOBAL_MEM_CHANNELS:                                       clDeviceInfo read new clDeviceInfo($4044);
    public static property DEVICE_GLOBAL_MEM_CHANNEL_BANKS:                                  clDeviceInfo read new clDeviceInfo($4045);
    public static property DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH:                             clDeviceInfo read new clDeviceInfo($4046);
    public static property DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT:                           clDeviceInfo read new clDeviceInfo($4047);
    public static property DEVICE_LOCAL_MEM_BANKS:                                           clDeviceInfo read new clDeviceInfo($4048);
    public static property DEVICE_THREAD_TRACE_SUPPORTED:                                    clDeviceInfo read new clDeviceInfo($4049);
    public static property DEVICE_GFXIP_MAJOR:                                               clDeviceInfo read new clDeviceInfo($404A);
    public static property DEVICE_GFXIP_MINOR:                                               clDeviceInfo read new clDeviceInfo($404B);
    public static property DEVICE_AVAILABLE_ASYNC_QUEUES:                                    clDeviceInfo read new clDeviceInfo($404C);
    public static property DEVICE_PARENT_DEVICE_EXT:                                         clDeviceInfo read new clDeviceInfo($4054);
    public static property DEVICE_PARTITION_TYPES:                                           clDeviceInfo read new clDeviceInfo($4055);
    public static property DEVICE_AFFINITY_DOMAINS:                                          clDeviceInfo read new clDeviceInfo($4056);
    public static property DEVICE_REFERENCE_COUNT_EXT:                                       clDeviceInfo read new clDeviceInfo($4057);
    public static property DEVICE_PARTITION_STYLE:                                           clDeviceInfo read new clDeviceInfo($4058);
    public static property DEVICE_ME_VERSION:                                                clDeviceInfo read new clDeviceInfo($407E);
    public static property DEVICE_EXT_MEM_PADDING_IN_BYTES:                                  clDeviceInfo read new clDeviceInfo($40A0);
    public static property DEVICE_PAGE_SIZE:                                                 clDeviceInfo read new clDeviceInfo($40A1);
    public static property DEVICE_SVM_CAPABILITIES_ARM:                                      clDeviceInfo read new clDeviceInfo($40B6);
    public static property DEVICE_COMPUTE_UNITS_BITFIELD:                                    clDeviceInfo read new clDeviceInfo($40BF);
    public static property DEVICE_SPIR_VERSIONS:                                             clDeviceInfo read new clDeviceInfo($40E0);
    public static property DEVICE_SIMULTANEOUS_INTEROPS:                                     clDeviceInfo read new clDeviceInfo($4104);
    public static property DEVICE_NUM_SIMULTANEOUS_INTEROPS:                                 clDeviceInfo read new clDeviceInfo($4105);
    public static property DEVICE_SUB_GROUP_SIZES:                                           clDeviceInfo read new clDeviceInfo($4108);
    public static property DEVICE_AVC_ME_VERSION:                                            clDeviceInfo read new clDeviceInfo($410B);
    public static property DEVICE_AVC_ME_SUPPORTS_TEXTURE_SAMPLER_USE:                       clDeviceInfo read new clDeviceInfo($410C);
    public static property DEVICE_AVC_ME_SUPPORTS_PREEMPTION:                                clDeviceInfo read new clDeviceInfo($410D);
    public static property DEVICE_PCI_BUS_INFO:                                              clDeviceInfo read new clDeviceInfo($410F);
    public static property DEVICE_PLANAR_YUV_MAX_WIDTH:                                      clDeviceInfo read new clDeviceInfo($417E);
    public static property DEVICE_PLANAR_YUV_MAX_HEIGHT:                                     clDeviceInfo read new clDeviceInfo($417F);
    public static property DEVICE_QUEUE_FAMILY_PROPERTIES:                                   clDeviceInfo read new clDeviceInfo($418B);
    public static property DEVICE_HOST_MEM_CAPABILITIES:                                     clDeviceInfo read new clDeviceInfo($4190);
    public static property DEVICE_DEVICE_MEM_CAPABILITIES:                                   clDeviceInfo read new clDeviceInfo($4191);
    public static property DEVICE_SINGLE_DEVICE_SHARED_MEM_CAPABILITIES:                     clDeviceInfo read new clDeviceInfo($4192);
    public static property DEVICE_CROSS_DEVICE_SHARED_MEM_CAPABILITIES:                      clDeviceInfo read new clDeviceInfo($4193);
    public static property DEVICE_SHARED_SYSTEM_MEM_CAPABILITIES:                            clDeviceInfo read new clDeviceInfo($4194);
    public static property DEVICE_JOB_SLOTS:                                                 clDeviceInfo read new clDeviceInfo($41E0);
    public static property DEVICE_SCHEDULING_CONTROLS_CAPABILITIES:                          clDeviceInfo read new clDeviceInfo($41E4);
    public static property DEVICE_MAX_WARP_COUNT:                                            clDeviceInfo read new clDeviceInfo($41EA);
    public static property DEVICE_SUPPORTED_REGISTER_ALLOCATIONS:                            clDeviceInfo read new clDeviceInfo($41EB);
    public static property DEVICE_CONTROLLED_TERMINATION_CAPABILITIES:                       clDeviceInfo read new clDeviceInfo($41EE);
    public static property DEVICE_CXX_FOR_OPENCL_NUMERIC_VERSION:                            clDeviceInfo read new clDeviceInfo($4230);
    public static property DEVICE_SINGLE_FP_ATOMIC_CAPABILITIES:                             clDeviceInfo read new clDeviceInfo($4231);
    public static property DEVICE_DOUBLE_FP_ATOMIC_CAPABILITIES:                             clDeviceInfo read new clDeviceInfo($4232);
    public static property DEVICE_HALF_FP_ATOMIC_CAPABILITIES:                               clDeviceInfo read new clDeviceInfo($4233);
    public static property DEVICE_IP_VERSION:                                                clDeviceInfo read new clDeviceInfo($4250);
    public static property DEVICE_ID:                                                        clDeviceInfo read new clDeviceInfo($4251);
    public static property DEVICE_NUM_SLICES:                                                clDeviceInfo read new clDeviceInfo($4252);
    public static property DEVICE_NUM_SUB_SLICES_PER_SLICE:                                  clDeviceInfo read new clDeviceInfo($4253);
    public static property DEVICE_NUM_EUS_PER_SUB_SLICE:                                     clDeviceInfo read new clDeviceInfo($4254);
    public static property DEVICE_NUM_THREADS_PER_EU:                                        clDeviceInfo read new clDeviceInfo($4255);
    public static property DEVICE_FEATURE_CAPABILITIES:                                      clDeviceInfo read new clDeviceInfo($4256);
    
    public function ToString: string; override;
    begin
      if DEVICE_TYPE = self then
        Result := 'DEVICE_TYPE' else
      if DEVICE_VENDOR_ID = self then
        Result := 'DEVICE_VENDOR_ID' else
      if DEVICE_MAX_COMPUTE_UNITS = self then
        Result := 'DEVICE_MAX_COMPUTE_UNITS' else
      if DEVICE_MAX_WORK_ITEM_DIMENSIONS = self then
        Result := 'DEVICE_MAX_WORK_ITEM_DIMENSIONS' else
      if DEVICE_MAX_WORK_GROUP_SIZE = self then
        Result := 'DEVICE_MAX_WORK_GROUP_SIZE' else
      if DEVICE_MAX_WORK_ITEM_SIZES = self then
        Result := 'DEVICE_MAX_WORK_ITEM_SIZES' else
      if DEVICE_PREFERRED_VECTOR_WIDTH_CHAR = self then
        Result := 'DEVICE_PREFERRED_VECTOR_WIDTH_CHAR' else
      if DEVICE_PREFERRED_VECTOR_WIDTH_SHORT = self then
        Result := 'DEVICE_PREFERRED_VECTOR_WIDTH_SHORT' else
      if DEVICE_PREFERRED_VECTOR_WIDTH_INT = self then
        Result := 'DEVICE_PREFERRED_VECTOR_WIDTH_INT' else
      if DEVICE_PREFERRED_VECTOR_WIDTH_LONG = self then
        Result := 'DEVICE_PREFERRED_VECTOR_WIDTH_LONG' else
      if DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT = self then
        Result := 'DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT' else
      if DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE = self then
        Result := 'DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE' else
      if DEVICE_MAX_CLOCK_FREQUENCY = self then
        Result := 'DEVICE_MAX_CLOCK_FREQUENCY' else
      if DEVICE_ADDRESS_BITS = self then
        Result := 'DEVICE_ADDRESS_BITS' else
      if DEVICE_MAX_READ_IMAGE_ARGS = self then
        Result := 'DEVICE_MAX_READ_IMAGE_ARGS' else
      if DEVICE_MAX_WRITE_IMAGE_ARGS = self then
        Result := 'DEVICE_MAX_WRITE_IMAGE_ARGS' else
      if DEVICE_MAX_MEM_ALLOC_SIZE = self then
        Result := 'DEVICE_MAX_MEM_ALLOC_SIZE' else
      if DEVICE_IMAGE2D_MAX_WIDTH = self then
        Result := 'DEVICE_IMAGE2D_MAX_WIDTH' else
      if DEVICE_IMAGE2D_MAX_HEIGHT = self then
        Result := 'DEVICE_IMAGE2D_MAX_HEIGHT' else
      if DEVICE_IMAGE3D_MAX_WIDTH = self then
        Result := 'DEVICE_IMAGE3D_MAX_WIDTH' else
      if DEVICE_IMAGE3D_MAX_HEIGHT = self then
        Result := 'DEVICE_IMAGE3D_MAX_HEIGHT' else
      if DEVICE_IMAGE3D_MAX_DEPTH = self then
        Result := 'DEVICE_IMAGE3D_MAX_DEPTH' else
      if DEVICE_IMAGE_SUPPORT = self then
        Result := 'DEVICE_IMAGE_SUPPORT' else
      if DEVICE_MAX_PARAMETER_SIZE = self then
        Result := 'DEVICE_MAX_PARAMETER_SIZE' else
      if DEVICE_MAX_SAMPLERS = self then
        Result := 'DEVICE_MAX_SAMPLERS' else
      if DEVICE_MEM_BASE_ADDR_ALIGN = self then
        Result := 'DEVICE_MEM_BASE_ADDR_ALIGN' else
      if DEVICE_MIN_DATA_TYPE_ALIGN_SIZE = self then
        Result := 'DEVICE_MIN_DATA_TYPE_ALIGN_SIZE' else
      if DEVICE_SINGLE_FP_CONFIG = self then
        Result := 'DEVICE_SINGLE_FP_CONFIG' else
      if DEVICE_GLOBAL_MEM_CACHE_TYPE = self then
        Result := 'DEVICE_GLOBAL_MEM_CACHE_TYPE' else
      if DEVICE_GLOBAL_MEM_CACHELINE_SIZE = self then
        Result := 'DEVICE_GLOBAL_MEM_CACHELINE_SIZE' else
      if DEVICE_GLOBAL_MEM_CACHE_SIZE = self then
        Result := 'DEVICE_GLOBAL_MEM_CACHE_SIZE' else
      if DEVICE_GLOBAL_MEM_SIZE = self then
        Result := 'DEVICE_GLOBAL_MEM_SIZE' else
      if DEVICE_MAX_CONSTANT_BUFFER_SIZE = self then
        Result := 'DEVICE_MAX_CONSTANT_BUFFER_SIZE' else
      if DEVICE_MAX_CONSTANT_ARGS = self then
        Result := 'DEVICE_MAX_CONSTANT_ARGS' else
      if DEVICE_LOCAL_MEM_TYPE = self then
        Result := 'DEVICE_LOCAL_MEM_TYPE' else
      if DEVICE_LOCAL_MEM_SIZE = self then
        Result := 'DEVICE_LOCAL_MEM_SIZE' else
      if DEVICE_ERROR_CORRECTION_SUPPORT = self then
        Result := 'DEVICE_ERROR_CORRECTION_SUPPORT' else
      if DEVICE_PROFILING_TIMER_RESOLUTION = self then
        Result := 'DEVICE_PROFILING_TIMER_RESOLUTION' else
      if DEVICE_ENDIAN_LITTLE = self then
        Result := 'DEVICE_ENDIAN_LITTLE' else
      if DEVICE_AVAILABLE = self then
        Result := 'DEVICE_AVAILABLE' else
      if DEVICE_COMPILER_AVAILABLE = self then
        Result := 'DEVICE_COMPILER_AVAILABLE' else
      if DEVICE_EXECUTION_CAPABILITIES = self then
        Result := 'DEVICE_EXECUTION_CAPABILITIES' else
      if DEVICE_QUEUE_PROPERTIES = self then
        Result := 'DEVICE_QUEUE_PROPERTIES' else
      if DEVICE_NAME = self then
        Result := 'DEVICE_NAME' else
      if DEVICE_VENDOR = self then
        Result := 'DEVICE_VENDOR' else
      if DRIVER_VERSION = self then
        Result := 'DRIVER_VERSION' else
      if DEVICE_PROFILE = self then
        Result := 'DEVICE_PROFILE' else
      if DEVICE_VERSION = self then
        Result := 'DEVICE_VERSION' else
      if DEVICE_EXTENSIONS = self then
        Result := 'DEVICE_EXTENSIONS' else
      if DEVICE_PLATFORM = self then
        Result := 'DEVICE_PLATFORM' else
      if DEVICE_DOUBLE_FP_CONFIG = self then
        Result := 'DEVICE_DOUBLE_FP_CONFIG' else
      if DEVICE_HALF_FP_CONFIG = self then
        Result := 'DEVICE_HALF_FP_CONFIG' else
      if DEVICE_PREFERRED_VECTOR_WIDTH_HALF = self then
        Result := 'DEVICE_PREFERRED_VECTOR_WIDTH_HALF' else
      if DEVICE_HOST_UNIFIED_MEMORY = self then
        Result := 'DEVICE_HOST_UNIFIED_MEMORY' else
      if DEVICE_NATIVE_VECTOR_WIDTH_CHAR = self then
        Result := 'DEVICE_NATIVE_VECTOR_WIDTH_CHAR' else
      if DEVICE_NATIVE_VECTOR_WIDTH_SHORT = self then
        Result := 'DEVICE_NATIVE_VECTOR_WIDTH_SHORT' else
      if DEVICE_NATIVE_VECTOR_WIDTH_INT = self then
        Result := 'DEVICE_NATIVE_VECTOR_WIDTH_INT' else
      if DEVICE_NATIVE_VECTOR_WIDTH_LONG = self then
        Result := 'DEVICE_NATIVE_VECTOR_WIDTH_LONG' else
      if DEVICE_NATIVE_VECTOR_WIDTH_FLOAT = self then
        Result := 'DEVICE_NATIVE_VECTOR_WIDTH_FLOAT' else
      if DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE = self then
        Result := 'DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE' else
      if DEVICE_NATIVE_VECTOR_WIDTH_HALF = self then
        Result := 'DEVICE_NATIVE_VECTOR_WIDTH_HALF' else
      if DEVICE_OPENCL_C_VERSION = self then
        Result := 'DEVICE_OPENCL_C_VERSION' else
      if DEVICE_LINKER_AVAILABLE = self then
        Result := 'DEVICE_LINKER_AVAILABLE' else
      if DEVICE_BUILT_IN_KERNELS = self then
        Result := 'DEVICE_BUILT_IN_KERNELS' else
      if DEVICE_IMAGE_MAX_BUFFER_SIZE = self then
        Result := 'DEVICE_IMAGE_MAX_BUFFER_SIZE' else
      if DEVICE_IMAGE_MAX_ARRAY_SIZE = self then
        Result := 'DEVICE_IMAGE_MAX_ARRAY_SIZE' else
      if DEVICE_PARENT_DEVICE = self then
        Result := 'DEVICE_PARENT_DEVICE' else
      if DEVICE_PARTITION_MAX_SUB_DEVICES = self then
        Result := 'DEVICE_PARTITION_MAX_SUB_DEVICES' else
      if DEVICE_PARTITION_PROPERTIES = self then
        Result := 'DEVICE_PARTITION_PROPERTIES' else
      if DEVICE_PARTITION_AFFINITY_DOMAIN = self then
        Result := 'DEVICE_PARTITION_AFFINITY_DOMAIN' else
      if DEVICE_PARTITION_TYPE = self then
        Result := 'DEVICE_PARTITION_TYPE' else
      if DEVICE_REFERENCE_COUNT = self then
        Result := 'DEVICE_REFERENCE_COUNT' else
      if DEVICE_PREFERRED_INTEROP_USER_SYNC = self then
        Result := 'DEVICE_PREFERRED_INTEROP_USER_SYNC' else
      if DEVICE_PRINTF_BUFFER_SIZE = self then
        Result := 'DEVICE_PRINTF_BUFFER_SIZE' else
      if DEVICE_IMAGE_PITCH_ALIGNMENT = self then
        Result := 'DEVICE_IMAGE_PITCH_ALIGNMENT' else
      if DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT = self then
        Result := 'DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT' else
      if DEVICE_MAX_READ_WRITE_IMAGE_ARGS = self then
        Result := 'DEVICE_MAX_READ_WRITE_IMAGE_ARGS' else
      if DEVICE_MAX_GLOBAL_VARIABLE_SIZE = self then
        Result := 'DEVICE_MAX_GLOBAL_VARIABLE_SIZE' else
      if DEVICE_QUEUE_ON_DEVICE_PROPERTIES = self then
        Result := 'DEVICE_QUEUE_ON_DEVICE_PROPERTIES' else
      if DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE = self then
        Result := 'DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE' else
      if DEVICE_QUEUE_ON_DEVICE_MAX_SIZE = self then
        Result := 'DEVICE_QUEUE_ON_DEVICE_MAX_SIZE' else
      if DEVICE_MAX_ON_DEVICE_QUEUES = self then
        Result := 'DEVICE_MAX_ON_DEVICE_QUEUES' else
      if DEVICE_MAX_ON_DEVICE_EVENTS = self then
        Result := 'DEVICE_MAX_ON_DEVICE_EVENTS' else
      if DEVICE_SVM_CAPABILITIES = self then
        Result := 'DEVICE_SVM_CAPABILITIES' else
      if DEVICE_GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE = self then
        Result := 'DEVICE_GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE' else
      if DEVICE_MAX_PIPE_ARGS = self then
        Result := 'DEVICE_MAX_PIPE_ARGS' else
      if DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS = self then
        Result := 'DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS' else
      if DEVICE_PIPE_MAX_PACKET_SIZE = self then
        Result := 'DEVICE_PIPE_MAX_PACKET_SIZE' else
      if DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT = self then
        Result := 'DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT' else
      if DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT = self then
        Result := 'DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT' else
      if DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT = self then
        Result := 'DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT' else
      if DEVICE_IL_VERSION = self then
        Result := 'DEVICE_IL_VERSION' else
      if DEVICE_MAX_NUM_SUB_GROUPS = self then
        Result := 'DEVICE_MAX_NUM_SUB_GROUPS' else
      if DEVICE_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS = self then
        Result := 'DEVICE_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS' else
      if DEVICE_NUMERIC_VERSION = self then
        Result := 'DEVICE_NUMERIC_VERSION' else
      if DEVICE_OPENCL_C_NUMERIC_VERSION = self then
        Result := 'DEVICE_OPENCL_C_NUMERIC_VERSION' else
      if DEVICE_EXTENSIONS_WITH_VERSION = self then
        Result := 'DEVICE_EXTENSIONS_WITH_VERSION' else
      if DEVICE_ILS_WITH_VERSION = self then
        Result := 'DEVICE_ILS_WITH_VERSION' else
      if DEVICE_BUILT_IN_KERNELS_WITH_VERSION = self then
        Result := 'DEVICE_BUILT_IN_KERNELS_WITH_VERSION' else
      if DEVICE_ATOMIC_MEMORY_CAPABILITIES = self then
        Result := 'DEVICE_ATOMIC_MEMORY_CAPABILITIES' else
      if DEVICE_ATOMIC_FENCE_CAPABILITIES = self then
        Result := 'DEVICE_ATOMIC_FENCE_CAPABILITIES' else
      if DEVICE_NON_UNIFORM_WORK_GROUP_SUPPORT = self then
        Result := 'DEVICE_NON_UNIFORM_WORK_GROUP_SUPPORT' else
      if DEVICE_OPENCL_C_ALL_VERSIONS = self then
        Result := 'DEVICE_OPENCL_C_ALL_VERSIONS' else
      if DEVICE_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = self then
        Result := 'DEVICE_PREFERRED_WORK_GROUP_SIZE_MULTIPLE' else
      if DEVICE_WORK_GROUP_COLLECTIVE_FUNCTIONS_SUPPORT = self then
        Result := 'DEVICE_WORK_GROUP_COLLECTIVE_FUNCTIONS_SUPPORT' else
      if DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT = self then
        Result := 'DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT' else
      if DEVICE_UUID = self then
        Result := 'DEVICE_UUID' else
      if DRIVER_UUID = self then
        Result := 'DRIVER_UUID' else
      if DEVICE_LUID_VALID = self then
        Result := 'DEVICE_LUID_VALID' else
      if DEVICE_LUID = self then
        Result := 'DEVICE_LUID' else
      if DEVICE_NODE_MASK = self then
        Result := 'DEVICE_NODE_MASK' else
      if DEVICE_OPENCL_C_FEATURES = self then
        Result := 'DEVICE_OPENCL_C_FEATURES' else
      if DEVICE_DEVICE_ENQUEUE_CAPABILITIES = self then
        Result := 'DEVICE_DEVICE_ENQUEUE_CAPABILITIES' else
      if DEVICE_PIPE_SUPPORT = self then
        Result := 'DEVICE_PIPE_SUPPORT' else
      if DEVICE_LATEST_CONFORMANCE_VERSION_PASSED = self then
        Result := 'DEVICE_LATEST_CONFORMANCE_VERSION_PASSED' else
      if DEVICE_INTEGER_DOT_PRODUCT_CAPABILITIES = self then
        Result := 'DEVICE_INTEGER_DOT_PRODUCT_CAPABILITIES' else
      if DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_8BIT = self then
        Result := 'DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_8BIT' else
      if DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_4x8BIT_PACKED = self then
        Result := 'DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_4x8BIT_PACKED' else
      if DEVICE_COMMAND_BUFFER_CAPABILITIES = self then
        Result := 'DEVICE_COMMAND_BUFFER_CAPABILITIES' else
      if DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES = self then
        Result := 'DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES' else
      if DEVICE_COMMAND_BUFFER_NUM_SYNC_DEVICES = self then
        Result := 'DEVICE_COMMAND_BUFFER_NUM_SYNC_DEVICES' else
      if DEVICE_COMMAND_BUFFER_SYNC_DEVICES = self then
        Result := 'DEVICE_COMMAND_BUFFER_SYNC_DEVICES' else
      if DEVICE_MUTABLE_DISPATCH_CAPABILITIES = self then
        Result := 'DEVICE_MUTABLE_DISPATCH_CAPABILITIES' else
      if DEVICE_TERMINATE_CAPABILITY = self then
        Result := 'DEVICE_TERMINATE_CAPABILITY' else
      if DEVICE_MAX_NAMED_BARRIER_COUNT = self then
        Result := 'DEVICE_MAX_NAMED_BARRIER_COUNT' else
      if DEVICE_SEMAPHORE_TYPES = self then
        Result := 'DEVICE_SEMAPHORE_TYPES' else
      if DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES = self then
        Result := 'DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES' else
      if DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES = self then
        Result := 'DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES' else
      if DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES = self then
        Result := 'DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES' else
      if DEVICE_COMPUTE_CAPABILITY_MAJOR = self then
        Result := 'DEVICE_COMPUTE_CAPABILITY_MAJOR' else
      if DEVICE_COMPUTE_CAPABILITY_MINOR = self then
        Result := 'DEVICE_COMPUTE_CAPABILITY_MINOR' else
      if DEVICE_REGISTERS_PER_BLOCK = self then
        Result := 'DEVICE_REGISTERS_PER_BLOCK' else
      if DEVICE_WARP_SIZE = self then
        Result := 'DEVICE_WARP_SIZE' else
      if DEVICE_GPU_OVERLAP = self then
        Result := 'DEVICE_GPU_OVERLAP' else
      if DEVICE_KERNEL_EXEC_TIMEOUT = self then
        Result := 'DEVICE_KERNEL_EXEC_TIMEOUT' else
      if DEVICE_INTEGRATED_MEMORY = self then
        Result := 'DEVICE_INTEGRATED_MEMORY' else
      if DEVICE_PREFERRED_WORK_GROUP_SIZE = self then
        Result := 'DEVICE_PREFERRED_WORK_GROUP_SIZE' else
      if DEVICE_MAX_WORK_GROUP_SIZE_AMD = self then
        Result := 'DEVICE_MAX_WORK_GROUP_SIZE_AMD' else
      if DEVICE_PREFERRED_CONSTANT_BUFFER_SIZE = self then
        Result := 'DEVICE_PREFERRED_CONSTANT_BUFFER_SIZE' else
      if DEVICE_PCIE_ID = self then
        Result := 'DEVICE_PCIE_ID' else
      if DEVICE_PROFILING_TIMER_OFFSET = self then
        Result := 'DEVICE_PROFILING_TIMER_OFFSET' else
      if DEVICE_TOPOLOGY = self then
        Result := 'DEVICE_TOPOLOGY' else
      if DEVICE_BOARD_NAME = self then
        Result := 'DEVICE_BOARD_NAME' else
      if DEVICE_GLOBAL_FREE_MEMORY = self then
        Result := 'DEVICE_GLOBAL_FREE_MEMORY' else
      if DEVICE_SIMD_PER_COMPUTE_UNIT = self then
        Result := 'DEVICE_SIMD_PER_COMPUTE_UNIT' else
      if DEVICE_SIMD_WIDTH = self then
        Result := 'DEVICE_SIMD_WIDTH' else
      if DEVICE_SIMD_INSTRUCTION_WIDTH = self then
        Result := 'DEVICE_SIMD_INSTRUCTION_WIDTH' else
      if DEVICE_WAVEFRONT_WIDTH = self then
        Result := 'DEVICE_WAVEFRONT_WIDTH' else
      if DEVICE_GLOBAL_MEM_CHANNELS = self then
        Result := 'DEVICE_GLOBAL_MEM_CHANNELS' else
      if DEVICE_GLOBAL_MEM_CHANNEL_BANKS = self then
        Result := 'DEVICE_GLOBAL_MEM_CHANNEL_BANKS' else
      if DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH = self then
        Result := 'DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH' else
      if DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT = self then
        Result := 'DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT' else
      if DEVICE_LOCAL_MEM_BANKS = self then
        Result := 'DEVICE_LOCAL_MEM_BANKS' else
      if DEVICE_THREAD_TRACE_SUPPORTED = self then
        Result := 'DEVICE_THREAD_TRACE_SUPPORTED' else
      if DEVICE_GFXIP_MAJOR = self then
        Result := 'DEVICE_GFXIP_MAJOR' else
      if DEVICE_GFXIP_MINOR = self then
        Result := 'DEVICE_GFXIP_MINOR' else
      if DEVICE_AVAILABLE_ASYNC_QUEUES = self then
        Result := 'DEVICE_AVAILABLE_ASYNC_QUEUES' else
      if DEVICE_PARENT_DEVICE_EXT = self then
        Result := 'DEVICE_PARENT_DEVICE_EXT' else
      if DEVICE_PARTITION_TYPES = self then
        Result := 'DEVICE_PARTITION_TYPES' else
      if DEVICE_AFFINITY_DOMAINS = self then
        Result := 'DEVICE_AFFINITY_DOMAINS' else
      if DEVICE_REFERENCE_COUNT_EXT = self then
        Result := 'DEVICE_REFERENCE_COUNT_EXT' else
      if DEVICE_PARTITION_STYLE = self then
        Result := 'DEVICE_PARTITION_STYLE' else
      if DEVICE_ME_VERSION = self then
        Result := 'DEVICE_ME_VERSION' else
      if DEVICE_EXT_MEM_PADDING_IN_BYTES = self then
        Result := 'DEVICE_EXT_MEM_PADDING_IN_BYTES' else
      if DEVICE_PAGE_SIZE = self then
        Result := 'DEVICE_PAGE_SIZE' else
      if DEVICE_SVM_CAPABILITIES_ARM = self then
        Result := 'DEVICE_SVM_CAPABILITIES_ARM' else
      if DEVICE_COMPUTE_UNITS_BITFIELD = self then
        Result := 'DEVICE_COMPUTE_UNITS_BITFIELD' else
      if DEVICE_SPIR_VERSIONS = self then
        Result := 'DEVICE_SPIR_VERSIONS' else
      if DEVICE_SIMULTANEOUS_INTEROPS = self then
        Result := 'DEVICE_SIMULTANEOUS_INTEROPS' else
      if DEVICE_NUM_SIMULTANEOUS_INTEROPS = self then
        Result := 'DEVICE_NUM_SIMULTANEOUS_INTEROPS' else
      if DEVICE_SUB_GROUP_SIZES = self then
        Result := 'DEVICE_SUB_GROUP_SIZES' else
      if DEVICE_AVC_ME_VERSION = self then
        Result := 'DEVICE_AVC_ME_VERSION' else
      if DEVICE_AVC_ME_SUPPORTS_TEXTURE_SAMPLER_USE = self then
        Result := 'DEVICE_AVC_ME_SUPPORTS_TEXTURE_SAMPLER_USE' else
      if DEVICE_AVC_ME_SUPPORTS_PREEMPTION = self then
        Result := 'DEVICE_AVC_ME_SUPPORTS_PREEMPTION' else
      if DEVICE_PCI_BUS_INFO = self then
        Result := 'DEVICE_PCI_BUS_INFO' else
      if DEVICE_PLANAR_YUV_MAX_WIDTH = self then
        Result := 'DEVICE_PLANAR_YUV_MAX_WIDTH' else
      if DEVICE_PLANAR_YUV_MAX_HEIGHT = self then
        Result := 'DEVICE_PLANAR_YUV_MAX_HEIGHT' else
      if DEVICE_QUEUE_FAMILY_PROPERTIES = self then
        Result := 'DEVICE_QUEUE_FAMILY_PROPERTIES' else
      if DEVICE_HOST_MEM_CAPABILITIES = self then
        Result := 'DEVICE_HOST_MEM_CAPABILITIES' else
      if DEVICE_DEVICE_MEM_CAPABILITIES = self then
        Result := 'DEVICE_DEVICE_MEM_CAPABILITIES' else
      if DEVICE_SINGLE_DEVICE_SHARED_MEM_CAPABILITIES = self then
        Result := 'DEVICE_SINGLE_DEVICE_SHARED_MEM_CAPABILITIES' else
      if DEVICE_CROSS_DEVICE_SHARED_MEM_CAPABILITIES = self then
        Result := 'DEVICE_CROSS_DEVICE_SHARED_MEM_CAPABILITIES' else
      if DEVICE_SHARED_SYSTEM_MEM_CAPABILITIES = self then
        Result := 'DEVICE_SHARED_SYSTEM_MEM_CAPABILITIES' else
      if DEVICE_JOB_SLOTS = self then
        Result := 'DEVICE_JOB_SLOTS' else
      if DEVICE_SCHEDULING_CONTROLS_CAPABILITIES = self then
        Result := 'DEVICE_SCHEDULING_CONTROLS_CAPABILITIES' else
      if DEVICE_MAX_WARP_COUNT = self then
        Result := 'DEVICE_MAX_WARP_COUNT' else
      if DEVICE_SUPPORTED_REGISTER_ALLOCATIONS = self then
        Result := 'DEVICE_SUPPORTED_REGISTER_ALLOCATIONS' else
      if DEVICE_CONTROLLED_TERMINATION_CAPABILITIES = self then
        Result := 'DEVICE_CONTROLLED_TERMINATION_CAPABILITIES' else
      if DEVICE_CXX_FOR_OPENCL_NUMERIC_VERSION = self then
        Result := 'DEVICE_CXX_FOR_OPENCL_NUMERIC_VERSION' else
      if DEVICE_SINGLE_FP_ATOMIC_CAPABILITIES = self then
        Result := 'DEVICE_SINGLE_FP_ATOMIC_CAPABILITIES' else
      if DEVICE_DOUBLE_FP_ATOMIC_CAPABILITIES = self then
        Result := 'DEVICE_DOUBLE_FP_ATOMIC_CAPABILITIES' else
      if DEVICE_HALF_FP_ATOMIC_CAPABILITIES = self then
        Result := 'DEVICE_HALF_FP_ATOMIC_CAPABILITIES' else
      if DEVICE_IP_VERSION = self then
        Result := 'DEVICE_IP_VERSION' else
      if DEVICE_ID = self then
        Result := 'DEVICE_ID' else
      if DEVICE_NUM_SLICES = self then
        Result := 'DEVICE_NUM_SLICES' else
      if DEVICE_NUM_SUB_SLICES_PER_SLICE = self then
        Result := 'DEVICE_NUM_SUB_SLICES_PER_SLICE' else
      if DEVICE_NUM_EUS_PER_SUB_SLICE = self then
        Result := 'DEVICE_NUM_EUS_PER_SUB_SLICE' else
      if DEVICE_NUM_THREADS_PER_EU = self then
        Result := 'DEVICE_NUM_THREADS_PER_EU' else
      if DEVICE_FEATURE_CAPABILITIES = self then
        Result := 'DEVICE_FEATURE_CAPABILITIES' else
        Result := $'clDeviceInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clDeviceIntegerDotProductCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT_PACKED: clDeviceIntegerDotProductCapabilities read new clDeviceIntegerDotProductCapabilities(1 shl 0);
    public static property DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT:        clDeviceIntegerDotProductCapabilities read new clDeviceIntegerDotProductCapabilities(1 shl 1);
    
    public static function operator+(v1, v2: clDeviceIntegerDotProductCapabilities) := new clDeviceIntegerDotProductCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceIntegerDotProductCapabilities) := new clDeviceIntegerDotProductCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceIntegerDotProductCapabilities; v2: clDeviceIntegerDotProductCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceIntegerDotProductCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceIntegerDotProductCapabilities[0]';
        exit;
      end;
      if DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT_PACKED in self then
      begin
        res += 'DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT_PACKED+';
        left_val := left_val and not DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT_PACKED.val;
      end;
      if DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT in self then
      begin
        res += 'DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT+';
        left_val := left_val and not DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceIntegerDotProductCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceLocalMemType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LOCAL:  clDeviceLocalMemType read new clDeviceLocalMemType($0001);
    public static property GLOBAL: clDeviceLocalMemType read new clDeviceLocalMemType($0002);
    
    public function ToString: string; override;
    begin
      if LOCAL = self then
        Result := 'LOCAL' else
      if GLOBAL = self then
        Result := 'GLOBAL' else
        Result := $'clDeviceLocalMemType[{self.val}]';
    end;
    
  end;
  
  ///
  clDeviceMemCacheType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:             clDeviceMemCacheType read new clDeviceMemCacheType(0);
    public static property READ_ONLY_CACHE:  clDeviceMemCacheType read new clDeviceMemCacheType($0001);
    public static property READ_WRITE_CACHE: clDeviceMemCacheType read new clDeviceMemCacheType($0002);
    
    public function ToString: string; override;
    begin
      if NONE = self then
        Result := 'NONE' else
      if READ_ONLY_CACHE = self then
        Result := 'READ_ONLY_CACHE' else
      if READ_WRITE_CACHE = self then
        Result := 'READ_WRITE_CACHE' else
        Result := $'clDeviceMemCacheType[{self.val}]';
    end;
    
  end;
  
  ///
  clDeviceMeVersion = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ME_VERSION_LEGACY:         clDeviceMeVersion read new clDeviceMeVersion(0);
    public static property ME_VERSION_ADVANCED_VER_1: clDeviceMeVersion read new clDeviceMeVersion($0001);
    public static property ME_VERSION_ADVANCED_VER_2: clDeviceMeVersion read new clDeviceMeVersion($0002);
    
    public function ToString: string; override;
    begin
      if ME_VERSION_LEGACY = self then
        Result := 'ME_VERSION_LEGACY' else
      if ME_VERSION_ADVANCED_VER_1 = self then
        Result := 'ME_VERSION_ADVANCED_VER_1' else
      if ME_VERSION_ADVANCED_VER_2 = self then
        Result := 'ME_VERSION_ADVANCED_VER_2' else
        Result := $'clDeviceMeVersion[{self.val}]';
    end;
    
  end;
  
  ///
  clDeviceOnDeviceEnqueueCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_QUEUE_SUPPORTED:           clDeviceOnDeviceEnqueueCapabilities read new clDeviceOnDeviceEnqueueCapabilities(1 shl 0);
    public static property DEVICE_QUEUE_REPLACEABLE_DEFAULT: clDeviceOnDeviceEnqueueCapabilities read new clDeviceOnDeviceEnqueueCapabilities(1 shl 1);
    
    public static function operator+(v1, v2: clDeviceOnDeviceEnqueueCapabilities) := new clDeviceOnDeviceEnqueueCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceOnDeviceEnqueueCapabilities) := new clDeviceOnDeviceEnqueueCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceOnDeviceEnqueueCapabilities; v2: clDeviceOnDeviceEnqueueCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceOnDeviceEnqueueCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceOnDeviceEnqueueCapabilities[0]';
        exit;
      end;
      if DEVICE_QUEUE_SUPPORTED in self then
      begin
        res += 'DEVICE_QUEUE_SUPPORTED+';
        left_val := left_val and not DEVICE_QUEUE_SUPPORTED.val;
      end;
      if DEVICE_QUEUE_REPLACEABLE_DEFAULT in self then
      begin
        res += 'DEVICE_QUEUE_REPLACEABLE_DEFAULT+';
        left_val := left_val and not DEVICE_QUEUE_REPLACEABLE_DEFAULT.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceOnDeviceEnqueueCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDevicePartitionProperty = record
    public val: IntPtr;
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property DEVICE_PARTITION_BY_COUNTS_LIST_END: clDevicePartitionProperty read new clDevicePartitionProperty(0);
    public static property PARTITION_BY_NAMES_LIST_END:         clDevicePartitionProperty read new clDevicePartitionProperty(-1);
    public static property DEVICE_PARTITION_EQUALLY:            clDevicePartitionProperty read new clDevicePartitionProperty($1086);
    public static property DEVICE_PARTITION_BY_COUNTS:          clDevicePartitionProperty read new clDevicePartitionProperty($1087);
    public static property DEVICE_PARTITION_BY_AFFINITY_DOMAIN: clDevicePartitionProperty read new clDevicePartitionProperty($1088);
    public static property DEVICE_PARTITION_BY_NAMES:           clDevicePartitionProperty read new clDevicePartitionProperty($4052);
    
    public function ToString: string; override;
    begin
      if DEVICE_PARTITION_BY_COUNTS_LIST_END = self then
        Result := 'DEVICE_PARTITION_BY_COUNTS_LIST_END' else
      if PARTITION_BY_NAMES_LIST_END = self then
        Result := 'PARTITION_BY_NAMES_LIST_END' else
      if DEVICE_PARTITION_EQUALLY = self then
        Result := 'DEVICE_PARTITION_EQUALLY' else
      if DEVICE_PARTITION_BY_COUNTS = self then
        Result := 'DEVICE_PARTITION_BY_COUNTS' else
      if DEVICE_PARTITION_BY_AFFINITY_DOMAIN = self then
        Result := 'DEVICE_PARTITION_BY_AFFINITY_DOMAIN' else
      if DEVICE_PARTITION_BY_NAMES = self then
        Result := 'DEVICE_PARTITION_BY_NAMES' else
        Result := $'clDevicePartitionProperty[{self.val}]';
    end;
    
  end;
  
  ///
  clDeviceSchedulingControlsCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_SCHEDULING_KERNEL_BATCHING:               clDeviceSchedulingControlsCapabilities read new clDeviceSchedulingControlsCapabilities(1 shl 0);
    public static property DEVICE_SCHEDULING_WORKGROUP_BATCH_SIZE:          clDeviceSchedulingControlsCapabilities read new clDeviceSchedulingControlsCapabilities(1 shl 1);
    public static property DEVICE_SCHEDULING_WORKGROUP_BATCH_SIZE_MODIFIER: clDeviceSchedulingControlsCapabilities read new clDeviceSchedulingControlsCapabilities(1 shl 2);
    public static property DEVICE_SCHEDULING_DEFERRED_FLUSH:                clDeviceSchedulingControlsCapabilities read new clDeviceSchedulingControlsCapabilities(1 shl 3);
    public static property DEVICE_SCHEDULING_REGISTER_ALLOCATION:           clDeviceSchedulingControlsCapabilities read new clDeviceSchedulingControlsCapabilities(1 shl 4);
    public static property DEVICE_SCHEDULING_WARP_THROTTLING:               clDeviceSchedulingControlsCapabilities read new clDeviceSchedulingControlsCapabilities(1 shl 5);
    public static property DEVICE_SCHEDULING_COMPUTE_UNIT_BATCH_QUEUE_SIZE: clDeviceSchedulingControlsCapabilities read new clDeviceSchedulingControlsCapabilities(1 shl 6);
    
    public static function operator+(v1, v2: clDeviceSchedulingControlsCapabilities) := new clDeviceSchedulingControlsCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceSchedulingControlsCapabilities) := new clDeviceSchedulingControlsCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceSchedulingControlsCapabilities; v2: clDeviceSchedulingControlsCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceSchedulingControlsCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceSchedulingControlsCapabilities[0]';
        exit;
      end;
      if DEVICE_SCHEDULING_KERNEL_BATCHING in self then
      begin
        res += 'DEVICE_SCHEDULING_KERNEL_BATCHING+';
        left_val := left_val and not DEVICE_SCHEDULING_KERNEL_BATCHING.val;
      end;
      if DEVICE_SCHEDULING_WORKGROUP_BATCH_SIZE in self then
      begin
        res += 'DEVICE_SCHEDULING_WORKGROUP_BATCH_SIZE+';
        left_val := left_val and not DEVICE_SCHEDULING_WORKGROUP_BATCH_SIZE.val;
      end;
      if DEVICE_SCHEDULING_WORKGROUP_BATCH_SIZE_MODIFIER in self then
      begin
        res += 'DEVICE_SCHEDULING_WORKGROUP_BATCH_SIZE_MODIFIER+';
        left_val := left_val and not DEVICE_SCHEDULING_WORKGROUP_BATCH_SIZE_MODIFIER.val;
      end;
      if DEVICE_SCHEDULING_DEFERRED_FLUSH in self then
      begin
        res += 'DEVICE_SCHEDULING_DEFERRED_FLUSH+';
        left_val := left_val and not DEVICE_SCHEDULING_DEFERRED_FLUSH.val;
      end;
      if DEVICE_SCHEDULING_REGISTER_ALLOCATION in self then
      begin
        res += 'DEVICE_SCHEDULING_REGISTER_ALLOCATION+';
        left_val := left_val and not DEVICE_SCHEDULING_REGISTER_ALLOCATION.val;
      end;
      if DEVICE_SCHEDULING_WARP_THROTTLING in self then
      begin
        res += 'DEVICE_SCHEDULING_WARP_THROTTLING+';
        left_val := left_val and not DEVICE_SCHEDULING_WARP_THROTTLING.val;
      end;
      if DEVICE_SCHEDULING_COMPUTE_UNIT_BATCH_QUEUE_SIZE in self then
      begin
        res += 'DEVICE_SCHEDULING_COMPUTE_UNIT_BATCH_QUEUE_SIZE+';
        left_val := left_val and not DEVICE_SCHEDULING_COMPUTE_UNIT_BATCH_QUEUE_SIZE.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceSchedulingControlsCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceSVMCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_SVM_COARSE_GRAIN_BUFFER: clDeviceSVMCapabilities read new clDeviceSVMCapabilities(1 shl 0);
    public static property DEVICE_SVM_FINE_GRAIN_BUFFER:   clDeviceSVMCapabilities read new clDeviceSVMCapabilities(1 shl 1);
    public static property DEVICE_SVM_FINE_GRAIN_SYSTEM:   clDeviceSVMCapabilities read new clDeviceSVMCapabilities(1 shl 2);
    public static property DEVICE_SVM_ATOMICS:             clDeviceSVMCapabilities read new clDeviceSVMCapabilities(1 shl 3);
    
    public static function operator+(v1, v2: clDeviceSVMCapabilities) := new clDeviceSVMCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceSVMCapabilities) := new clDeviceSVMCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceSVMCapabilities; v2: clDeviceSVMCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceSVMCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceSVMCapabilities[0]';
        exit;
      end;
      if DEVICE_SVM_COARSE_GRAIN_BUFFER in self then
      begin
        res += 'DEVICE_SVM_COARSE_GRAIN_BUFFER+';
        left_val := left_val and not DEVICE_SVM_COARSE_GRAIN_BUFFER.val;
      end;
      if DEVICE_SVM_FINE_GRAIN_BUFFER in self then
      begin
        res += 'DEVICE_SVM_FINE_GRAIN_BUFFER+';
        left_val := left_val and not DEVICE_SVM_FINE_GRAIN_BUFFER.val;
      end;
      if DEVICE_SVM_FINE_GRAIN_SYSTEM in self then
      begin
        res += 'DEVICE_SVM_FINE_GRAIN_SYSTEM+';
        left_val := left_val and not DEVICE_SVM_FINE_GRAIN_SYSTEM.val;
      end;
      if DEVICE_SVM_ATOMICS in self then
      begin
        res += 'DEVICE_SVM_ATOMICS+';
        left_val := left_val and not DEVICE_SVM_ATOMICS.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceSVMCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceTerminateCapability = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_TERMINATE_CAPABILITY_CONTEXT: clDeviceTerminateCapability read new clDeviceTerminateCapability(1 shl 0);
    
    public static function operator+(v1, v2: clDeviceTerminateCapability) := new clDeviceTerminateCapability(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceTerminateCapability) := new clDeviceTerminateCapability(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceTerminateCapability; v2: clDeviceTerminateCapability) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceTerminateCapability) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceTerminateCapability[0]';
        exit;
      end;
      if DEVICE_TERMINATE_CAPABILITY_CONTEXT in self then
      begin
        res += 'DEVICE_TERMINATE_CAPABILITY_CONTEXT+';
        left_val := left_val and not DEVICE_TERMINATE_CAPABILITY_CONTEXT.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceTerminateCapability[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceType = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_TYPE_DEFAULT:     clDeviceType read new clDeviceType(1 shl 0);
    public static property DEVICE_TYPE_CPU:         clDeviceType read new clDeviceType(1 shl 1);
    public static property DEVICE_TYPE_GPU:         clDeviceType read new clDeviceType(1 shl 2);
    public static property DEVICE_TYPE_ACCELERATOR: clDeviceType read new clDeviceType(1 shl 3);
    public static property DEVICE_TYPE_CUSTOM:      clDeviceType read new clDeviceType(1 shl 4);
    public static property DEVICE_TYPE_ALL:         clDeviceType read new clDeviceType($FFFFFFFF);
    
    public static function operator+(v1, v2: clDeviceType) := new clDeviceType(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceType) := new clDeviceType(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceType; v2: clDeviceType) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceType) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceType[0]';
        exit;
      end;
      if DEVICE_TYPE_DEFAULT in self then
      begin
        res += 'DEVICE_TYPE_DEFAULT+';
        left_val := left_val and not DEVICE_TYPE_DEFAULT.val;
      end;
      if DEVICE_TYPE_CPU in self then
      begin
        res += 'DEVICE_TYPE_CPU+';
        left_val := left_val and not DEVICE_TYPE_CPU.val;
      end;
      if DEVICE_TYPE_GPU in self then
      begin
        res += 'DEVICE_TYPE_GPU+';
        left_val := left_val and not DEVICE_TYPE_GPU.val;
      end;
      if DEVICE_TYPE_ACCELERATOR in self then
      begin
        res += 'DEVICE_TYPE_ACCELERATOR+';
        left_val := left_val and not DEVICE_TYPE_ACCELERATOR.val;
      end;
      if DEVICE_TYPE_CUSTOM in self then
      begin
        res += 'DEVICE_TYPE_CUSTOM+';
        left_val := left_val and not DEVICE_TYPE_CUSTOM.val;
      end;
      if DEVICE_TYPE_ALL in self then
      begin
        res += 'DEVICE_TYPE_ALL+';
        left_val := left_val and not DEVICE_TYPE_ALL.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceType[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceUnifiedSharedMemoryCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property UNIFIED_SHARED_MEMORY_ACCESS:                   clDeviceUnifiedSharedMemoryCapabilities read new clDeviceUnifiedSharedMemoryCapabilities(1 shl 0);
    public static property UNIFIED_SHARED_MEMORY_ATOMIC_ACCESS:            clDeviceUnifiedSharedMemoryCapabilities read new clDeviceUnifiedSharedMemoryCapabilities(1 shl 1);
    public static property UNIFIED_SHARED_MEMORY_CONCURRENT_ACCESS:        clDeviceUnifiedSharedMemoryCapabilities read new clDeviceUnifiedSharedMemoryCapabilities(1 shl 2);
    public static property UNIFIED_SHARED_MEMORY_CONCURRENT_ATOMIC_ACCESS: clDeviceUnifiedSharedMemoryCapabilities read new clDeviceUnifiedSharedMemoryCapabilities(1 shl 3);
    
    public static function operator+(v1, v2: clDeviceUnifiedSharedMemoryCapabilities) := new clDeviceUnifiedSharedMemoryCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceUnifiedSharedMemoryCapabilities) := new clDeviceUnifiedSharedMemoryCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceUnifiedSharedMemoryCapabilities; v2: clDeviceUnifiedSharedMemoryCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceUnifiedSharedMemoryCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceUnifiedSharedMemoryCapabilities[0]';
        exit;
      end;
      if UNIFIED_SHARED_MEMORY_ACCESS in self then
      begin
        res += 'UNIFIED_SHARED_MEMORY_ACCESS+';
        left_val := left_val and not UNIFIED_SHARED_MEMORY_ACCESS.val;
      end;
      if UNIFIED_SHARED_MEMORY_ATOMIC_ACCESS in self then
      begin
        res += 'UNIFIED_SHARED_MEMORY_ATOMIC_ACCESS+';
        left_val := left_val and not UNIFIED_SHARED_MEMORY_ATOMIC_ACCESS.val;
      end;
      if UNIFIED_SHARED_MEMORY_CONCURRENT_ACCESS in self then
      begin
        res += 'UNIFIED_SHARED_MEMORY_CONCURRENT_ACCESS+';
        left_val := left_val and not UNIFIED_SHARED_MEMORY_CONCURRENT_ACCESS.val;
      end;
      if UNIFIED_SHARED_MEMORY_CONCURRENT_ATOMIC_ACCESS in self then
      begin
        res += 'UNIFIED_SHARED_MEMORY_CONCURRENT_ATOMIC_ACCESS+';
        left_val := left_val and not UNIFIED_SHARED_MEMORY_CONCURRENT_ATOMIC_ACCESS.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceUnifiedSharedMemoryCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDx9DeviceSet = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PREFERRED_DEVICES_FOR_DX9: clDx9DeviceSet read new clDx9DeviceSet($4024);
    public static property ALL_DEVICES_FOR_DX9:       clDx9DeviceSet read new clDx9DeviceSet($4025);
    
    public function ToString: string; override;
    begin
      if PREFERRED_DEVICES_FOR_DX9 = self then
        Result := 'PREFERRED_DEVICES_FOR_DX9' else
      if ALL_DEVICES_FOR_DX9 = self then
        Result := 'ALL_DEVICES_FOR_DX9' else
        Result := $'clDx9DeviceSet[{self.val}]';
    end;
    
  end;
  
  ///
  clDx9DeviceSource = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property D3D9_DEVICE:   clDx9DeviceSource read new clDx9DeviceSource($4022);
    public static property D3D9EX_DEVICE: clDx9DeviceSource read new clDx9DeviceSource($4070);
    public static property DXVA_DEVICE:   clDx9DeviceSource read new clDx9DeviceSource($4071);
    
    public function ToString: string; override;
    begin
      if D3D9_DEVICE = self then
        Result := 'D3D9_DEVICE' else
      if D3D9EX_DEVICE = self then
        Result := 'D3D9EX_DEVICE' else
      if DXVA_DEVICE = self then
        Result := 'DXVA_DEVICE' else
        Result := $'clDx9DeviceSource[{self.val}]';
    end;
    
  end;
  
  ///
  clDx9MediaAdapterSet = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PREFERRED_DEVICES_FOR_DX9_MEDIA_ADAPTER: clDx9MediaAdapterSet read new clDx9MediaAdapterSet($2023);
    public static property ALL_DEVICES_FOR_DX9_MEDIA_ADAPTER:       clDx9MediaAdapterSet read new clDx9MediaAdapterSet($2024);
    
    public function ToString: string; override;
    begin
      if PREFERRED_DEVICES_FOR_DX9_MEDIA_ADAPTER = self then
        Result := 'PREFERRED_DEVICES_FOR_DX9_MEDIA_ADAPTER' else
      if ALL_DEVICES_FOR_DX9_MEDIA_ADAPTER = self then
        Result := 'ALL_DEVICES_FOR_DX9_MEDIA_ADAPTER' else
        Result := $'clDx9MediaAdapterSet[{self.val}]';
    end;
    
  end;
  
  ///
  clDx9MediaAdapterType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ADAPTER_D3D9:   clDx9MediaAdapterType read new clDx9MediaAdapterType($2020);
    public static property ADAPTER_D3D9EX: clDx9MediaAdapterType read new clDx9MediaAdapterType($2021);
    public static property ADAPTER_DXVA:   clDx9MediaAdapterType read new clDx9MediaAdapterType($2022);
    
    public function ToString: string; override;
    begin
      if ADAPTER_D3D9 = self then
        Result := 'ADAPTER_D3D9' else
      if ADAPTER_D3D9EX = self then
        Result := 'ADAPTER_D3D9EX' else
      if ADAPTER_DXVA = self then
        Result := 'ADAPTER_DXVA' else
        Result := $'clDx9MediaAdapterType[{self.val}]';
    end;
    
  end;
  
  ///
  clEglImageProperties = record
    public val: IntPtr;
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property EGL_YUV_PLANE: clEglImageProperties read new clEglImageProperties($4107);
    
    public function ToString: string; override;
    begin
      if EGL_YUV_PLANE = self then
        Result := 'EGL_YUV_PLANE' else
        Result := $'clEglImageProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clErrorCode = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property SUCCESS:                                   clErrorCode read new clErrorCode(0);
    public static property DEVICE_NOT_FOUND:                          clErrorCode read new clErrorCode(-1);
    public static property DEVICE_NOT_AVAILABLE:                      clErrorCode read new clErrorCode(-2);
    public static property COMPILER_NOT_AVAILABLE:                    clErrorCode read new clErrorCode(-3);
    public static property MEM_OBJECT_ALLOCATION_FAILURE:             clErrorCode read new clErrorCode(-4);
    public static property OUT_OF_RESOURCES:                          clErrorCode read new clErrorCode(-5);
    public static property OUT_OF_HOST_MEMORY:                        clErrorCode read new clErrorCode(-6);
    public static property PROFILING_INFO_NOT_AVAILABLE:              clErrorCode read new clErrorCode(-7);
    public static property MEM_COPY_OVERLAP:                          clErrorCode read new clErrorCode(-8);
    public static property IMAGE_FORMAT_MISMATCH:                     clErrorCode read new clErrorCode(-9);
    public static property IMAGE_FORMAT_NOT_SUPPORTED:                clErrorCode read new clErrorCode(-10);
    public static property BUILD_PROGRAM_FAILURE:                     clErrorCode read new clErrorCode(-11);
    public static property MAP_FAILURE:                               clErrorCode read new clErrorCode(-12);
    public static property MISALIGNED_SUB_BUFFER_OFFSET:              clErrorCode read new clErrorCode(-13);
    public static property EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST: clErrorCode read new clErrorCode(-14);
    public static property COMPILE_PROGRAM_FAILURE:                   clErrorCode read new clErrorCode(-15);
    public static property LINKER_NOT_AVAILABLE:                      clErrorCode read new clErrorCode(-16);
    public static property LINK_PROGRAM_FAILURE:                      clErrorCode read new clErrorCode(-17);
    public static property DEVICE_PARTITION_FAILED:                   clErrorCode read new clErrorCode(-18);
    public static property KERNEL_ARG_INFO_NOT_AVAILABLE:             clErrorCode read new clErrorCode(-19);
    public static property INVALID_VALUE:                             clErrorCode read new clErrorCode(-30);
    public static property INVALID_DEVICE_TYPE:                       clErrorCode read new clErrorCode(-31);
    public static property INVALID_PLATFORM:                          clErrorCode read new clErrorCode(-32);
    public static property INVALID_DEVICE:                            clErrorCode read new clErrorCode(-33);
    public static property INVALID_CONTEXT:                           clErrorCode read new clErrorCode(-34);
    public static property INVALID_QUEUE_PROPERTIES:                  clErrorCode read new clErrorCode(-35);
    public static property INVALID_COMMAND_QUEUE:                     clErrorCode read new clErrorCode(-36);
    public static property INVALID_HOST_PTR:                          clErrorCode read new clErrorCode(-37);
    public static property INVALID_MEM_OBJECT:                        clErrorCode read new clErrorCode(-38);
    public static property INVALID_IMAGE_FORMAT_DESCRIPTOR:           clErrorCode read new clErrorCode(-39);
    public static property INVALID_IMAGE_SIZE:                        clErrorCode read new clErrorCode(-40);
    public static property INVALID_SAMPLER:                           clErrorCode read new clErrorCode(-41);
    public static property INVALID_BINARY:                            clErrorCode read new clErrorCode(-42);
    public static property INVALID_BUILD_OPTIONS:                     clErrorCode read new clErrorCode(-43);
    public static property INVALID_PROGRAM:                           clErrorCode read new clErrorCode(-44);
    public static property INVALID_PROGRAM_EXECUTABLE:                clErrorCode read new clErrorCode(-45);
    public static property INVALID_KERNEL_NAME:                       clErrorCode read new clErrorCode(-46);
    public static property INVALID_KERNEL_DEFINITION:                 clErrorCode read new clErrorCode(-47);
    public static property INVALID_KERNEL:                            clErrorCode read new clErrorCode(-48);
    public static property INVALID_ARG_INDEX:                         clErrorCode read new clErrorCode(-49);
    public static property INVALID_ARG_VALUE:                         clErrorCode read new clErrorCode(-50);
    public static property INVALID_ARG_SIZE:                          clErrorCode read new clErrorCode(-51);
    public static property INVALID_KERNEL_ARGS:                       clErrorCode read new clErrorCode(-52);
    public static property INVALID_WORK_DIMENSION:                    clErrorCode read new clErrorCode(-53);
    public static property INVALID_WORK_GROUP_SIZE:                   clErrorCode read new clErrorCode(-54);
    public static property INVALID_WORK_ITEM_SIZE:                    clErrorCode read new clErrorCode(-55);
    public static property INVALID_GLOBAL_OFFSET:                     clErrorCode read new clErrorCode(-56);
    public static property INVALID_EVENT_WAIT_LIST:                   clErrorCode read new clErrorCode(-57);
    public static property INVALID_EVENT:                             clErrorCode read new clErrorCode(-58);
    public static property INVALID_OPERATION:                         clErrorCode read new clErrorCode(-59);
    public static property INVALID_GL_OBJECT:                         clErrorCode read new clErrorCode(-60);
    public static property INVALID_BUFFER_SIZE:                       clErrorCode read new clErrorCode(-61);
    public static property INVALID_MIP_LEVEL:                         clErrorCode read new clErrorCode(-62);
    public static property INVALID_GLOBAL_WORK_SIZE:                  clErrorCode read new clErrorCode(-63);
    public static property INVALID_PROPERTY:                          clErrorCode read new clErrorCode(-64);
    public static property INVALID_IMAGE_DESCRIPTOR:                  clErrorCode read new clErrorCode(-65);
    public static property INVALID_COMPILER_OPTIONS:                  clErrorCode read new clErrorCode(-66);
    public static property INVALID_LINKER_OPTIONS:                    clErrorCode read new clErrorCode(-67);
    public static property INVALID_DEVICE_PARTITION_COUNT:            clErrorCode read new clErrorCode(-68);
    public static property INVALID_PIPE_SIZE:                         clErrorCode read new clErrorCode(-69);
    public static property INVALID_DEVICE_QUEUE:                      clErrorCode read new clErrorCode(-70);
    public static property INVALID_SPEC_ID:                           clErrorCode read new clErrorCode(-71);
    public static property MAX_SIZE_RESTRICTION_EXCEEDED:             clErrorCode read new clErrorCode(-72);
    public static property INVALID_GL_SHAREGROUP_REFERENCE:           clErrorCode read new clErrorCode(-1000);
    public static property PLATFORM_NOT_FOUND:                        clErrorCode read new clErrorCode(-1001);
    public static property INVALID_D3D10_DEVICE:                      clErrorCode read new clErrorCode(-1002);
    public static property INVALID_D3D10_RESOURCE:                    clErrorCode read new clErrorCode(-1003);
    public static property D3D10_RESOURCE_ALREADY_ACQUIRED:           clErrorCode read new clErrorCode(-1004);
    public static property D3D10_RESOURCE_NOT_ACQUIRED:               clErrorCode read new clErrorCode(-1005);
    public static property INVALID_D3D11_DEVICE:                      clErrorCode read new clErrorCode(-1006);
    public static property INVALID_D3D11_RESOURCE:                    clErrorCode read new clErrorCode(-1007);
    public static property D3D11_RESOURCE_ALREADY_ACQUIRED:           clErrorCode read new clErrorCode(-1008);
    public static property D3D11_RESOURCE_NOT_ACQUIRED:               clErrorCode read new clErrorCode(-1009);
    public static property INVALID_DX9_MEDIA_ADAPTER:                 clErrorCode read new clErrorCode(-1010);
    public static property INVALID_DX9_DEVICE:                        clErrorCode read new clErrorCode(-1010);
    public static property INVALID_DX9_MEDIA_SURFACE:                 clErrorCode read new clErrorCode(-1011);
    public static property INVALID_DX9_RESOURCE:                      clErrorCode read new clErrorCode(-1011);
    public static property DX9_MEDIA_SURFACE_ALREADY_ACQUIRED:        clErrorCode read new clErrorCode(-1012);
    public static property DX9_RESOURCE_ALREADY_ACQUIRED:             clErrorCode read new clErrorCode(-1012);
    public static property DX9_MEDIA_SURFACE_NOT_ACQUIRED:            clErrorCode read new clErrorCode(-1013);
    public static property DX9_RESOURCE_NOT_ACQUIRED:                 clErrorCode read new clErrorCode(-1013);
    public static property DEVICE_PARTITION_FAILED_EXT:               clErrorCode read new clErrorCode(-1057);
    public static property INVALID_PARTITION_COUNT:                   clErrorCode read new clErrorCode(-1058);
    public static property INVALID_PARTITION_NAME:                    clErrorCode read new clErrorCode(-1059);
    public static property EGL_RESOURCE_NOT_ACQUIRED:                 clErrorCode read new clErrorCode(-1092);
    public static property INVALID_EGL_OBJECT:                        clErrorCode read new clErrorCode(-1093);
    public static property INVALID_ACCELERATOR:                       clErrorCode read new clErrorCode(-1094);
    public static property INVALID_ACCELERATOR_TYPE:                  clErrorCode read new clErrorCode(-1095);
    public static property INVALID_ACCELERATOR_DESCRIPTOR:            clErrorCode read new clErrorCode(-1096);
    public static property ACCELERATOR_TYPE_NOT_SUPPORTED:            clErrorCode read new clErrorCode(-1097);
    public static property INVALID_VA_API_MEDIA_ADAPTER:              clErrorCode read new clErrorCode(-1098);
    public static property INVALID_VA_API_MEDIA_SURFACE:              clErrorCode read new clErrorCode(-1099);
    public static property VA_API_MEDIA_SURFACE_ALREADY_ACQUIRED:     clErrorCode read new clErrorCode(-1100);
    public static property VA_API_MEDIA_SURFACE_NOT_ACQUIRED:         clErrorCode read new clErrorCode(-1101);
    public static property COMMAND_TERMINATED_ITSELF_WITH_FAILURE:    clErrorCode read new clErrorCode(-1108);
    public static property CONTEXT_TERMINATED:                        clErrorCode read new clErrorCode(-1121);
    public static property INVALID_COMMAND_BUFFER:                    clErrorCode read new clErrorCode(-1138);
    public static property INVALID_SYNC_POINT_WAIT_LIST:              clErrorCode read new clErrorCode(-1139);
    public static property INCOMPATIBLE_COMMAND_QUEUE:                clErrorCode read new clErrorCode(-1140);
    public static property INVALID_MUTABLE_COMMAND:                   clErrorCode read new clErrorCode(-1141);
    public static property INVALID_SEMAPHORE:                         clErrorCode read new clErrorCode(-1142);
    public static property KERNEL_ILLEGAL_BUFFER_READ_WRITE:          clErrorCode read new clErrorCode(-9999);
    public static property GRALLOC_RESOURCE_NOT_ACQUIRED:             clErrorCode read new clErrorCode($40D4);
    public static property INVALID_GRALLOC_OBJECT:                    clErrorCode read new clErrorCode($40D5);
    
    public function ToString: string; override;
    begin
      if SUCCESS = self then
        Result := 'SUCCESS' else
      if DEVICE_NOT_FOUND = self then
        Result := 'DEVICE_NOT_FOUND' else
      if DEVICE_NOT_AVAILABLE = self then
        Result := 'DEVICE_NOT_AVAILABLE' else
      if COMPILER_NOT_AVAILABLE = self then
        Result := 'COMPILER_NOT_AVAILABLE' else
      if MEM_OBJECT_ALLOCATION_FAILURE = self then
        Result := 'MEM_OBJECT_ALLOCATION_FAILURE' else
      if OUT_OF_RESOURCES = self then
        Result := 'OUT_OF_RESOURCES' else
      if OUT_OF_HOST_MEMORY = self then
        Result := 'OUT_OF_HOST_MEMORY' else
      if PROFILING_INFO_NOT_AVAILABLE = self then
        Result := 'PROFILING_INFO_NOT_AVAILABLE' else
      if MEM_COPY_OVERLAP = self then
        Result := 'MEM_COPY_OVERLAP' else
      if IMAGE_FORMAT_MISMATCH = self then
        Result := 'IMAGE_FORMAT_MISMATCH' else
      if IMAGE_FORMAT_NOT_SUPPORTED = self then
        Result := 'IMAGE_FORMAT_NOT_SUPPORTED' else
      if BUILD_PROGRAM_FAILURE = self then
        Result := 'BUILD_PROGRAM_FAILURE' else
      if MAP_FAILURE = self then
        Result := 'MAP_FAILURE' else
      if MISALIGNED_SUB_BUFFER_OFFSET = self then
        Result := 'MISALIGNED_SUB_BUFFER_OFFSET' else
      if EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST = self then
        Result := 'EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST' else
      if COMPILE_PROGRAM_FAILURE = self then
        Result := 'COMPILE_PROGRAM_FAILURE' else
      if LINKER_NOT_AVAILABLE = self then
        Result := 'LINKER_NOT_AVAILABLE' else
      if LINK_PROGRAM_FAILURE = self then
        Result := 'LINK_PROGRAM_FAILURE' else
      if DEVICE_PARTITION_FAILED = self then
        Result := 'DEVICE_PARTITION_FAILED' else
      if KERNEL_ARG_INFO_NOT_AVAILABLE = self then
        Result := 'KERNEL_ARG_INFO_NOT_AVAILABLE' else
      if INVALID_VALUE = self then
        Result := 'INVALID_VALUE' else
      if INVALID_DEVICE_TYPE = self then
        Result := 'INVALID_DEVICE_TYPE' else
      if INVALID_PLATFORM = self then
        Result := 'INVALID_PLATFORM' else
      if INVALID_DEVICE = self then
        Result := 'INVALID_DEVICE' else
      if INVALID_CONTEXT = self then
        Result := 'INVALID_CONTEXT' else
      if INVALID_QUEUE_PROPERTIES = self then
        Result := 'INVALID_QUEUE_PROPERTIES' else
      if INVALID_COMMAND_QUEUE = self then
        Result := 'INVALID_COMMAND_QUEUE' else
      if INVALID_HOST_PTR = self then
        Result := 'INVALID_HOST_PTR' else
      if INVALID_MEM_OBJECT = self then
        Result := 'INVALID_MEM_OBJECT' else
      if INVALID_IMAGE_FORMAT_DESCRIPTOR = self then
        Result := 'INVALID_IMAGE_FORMAT_DESCRIPTOR' else
      if INVALID_IMAGE_SIZE = self then
        Result := 'INVALID_IMAGE_SIZE' else
      if INVALID_SAMPLER = self then
        Result := 'INVALID_SAMPLER' else
      if INVALID_BINARY = self then
        Result := 'INVALID_BINARY' else
      if INVALID_BUILD_OPTIONS = self then
        Result := 'INVALID_BUILD_OPTIONS' else
      if INVALID_PROGRAM = self then
        Result := 'INVALID_PROGRAM' else
      if INVALID_PROGRAM_EXECUTABLE = self then
        Result := 'INVALID_PROGRAM_EXECUTABLE' else
      if INVALID_KERNEL_NAME = self then
        Result := 'INVALID_KERNEL_NAME' else
      if INVALID_KERNEL_DEFINITION = self then
        Result := 'INVALID_KERNEL_DEFINITION' else
      if INVALID_KERNEL = self then
        Result := 'INVALID_KERNEL' else
      if INVALID_ARG_INDEX = self then
        Result := 'INVALID_ARG_INDEX' else
      if INVALID_ARG_VALUE = self then
        Result := 'INVALID_ARG_VALUE' else
      if INVALID_ARG_SIZE = self then
        Result := 'INVALID_ARG_SIZE' else
      if INVALID_KERNEL_ARGS = self then
        Result := 'INVALID_KERNEL_ARGS' else
      if INVALID_WORK_DIMENSION = self then
        Result := 'INVALID_WORK_DIMENSION' else
      if INVALID_WORK_GROUP_SIZE = self then
        Result := 'INVALID_WORK_GROUP_SIZE' else
      if INVALID_WORK_ITEM_SIZE = self then
        Result := 'INVALID_WORK_ITEM_SIZE' else
      if INVALID_GLOBAL_OFFSET = self then
        Result := 'INVALID_GLOBAL_OFFSET' else
      if INVALID_EVENT_WAIT_LIST = self then
        Result := 'INVALID_EVENT_WAIT_LIST' else
      if INVALID_EVENT = self then
        Result := 'INVALID_EVENT' else
      if INVALID_OPERATION = self then
        Result := 'INVALID_OPERATION' else
      if INVALID_GL_OBJECT = self then
        Result := 'INVALID_GL_OBJECT' else
      if INVALID_BUFFER_SIZE = self then
        Result := 'INVALID_BUFFER_SIZE' else
      if INVALID_MIP_LEVEL = self then
        Result := 'INVALID_MIP_LEVEL' else
      if INVALID_GLOBAL_WORK_SIZE = self then
        Result := 'INVALID_GLOBAL_WORK_SIZE' else
      if INVALID_PROPERTY = self then
        Result := 'INVALID_PROPERTY' else
      if INVALID_IMAGE_DESCRIPTOR = self then
        Result := 'INVALID_IMAGE_DESCRIPTOR' else
      if INVALID_COMPILER_OPTIONS = self then
        Result := 'INVALID_COMPILER_OPTIONS' else
      if INVALID_LINKER_OPTIONS = self then
        Result := 'INVALID_LINKER_OPTIONS' else
      if INVALID_DEVICE_PARTITION_COUNT = self then
        Result := 'INVALID_DEVICE_PARTITION_COUNT' else
      if INVALID_PIPE_SIZE = self then
        Result := 'INVALID_PIPE_SIZE' else
      if INVALID_DEVICE_QUEUE = self then
        Result := 'INVALID_DEVICE_QUEUE' else
      if INVALID_SPEC_ID = self then
        Result := 'INVALID_SPEC_ID' else
      if MAX_SIZE_RESTRICTION_EXCEEDED = self then
        Result := 'MAX_SIZE_RESTRICTION_EXCEEDED' else
      if INVALID_GL_SHAREGROUP_REFERENCE = self then
        Result := 'INVALID_GL_SHAREGROUP_REFERENCE' else
      if PLATFORM_NOT_FOUND = self then
        Result := 'PLATFORM_NOT_FOUND' else
      if INVALID_D3D10_DEVICE = self then
        Result := 'INVALID_D3D10_DEVICE' else
      if INVALID_D3D10_RESOURCE = self then
        Result := 'INVALID_D3D10_RESOURCE' else
      if D3D10_RESOURCE_ALREADY_ACQUIRED = self then
        Result := 'D3D10_RESOURCE_ALREADY_ACQUIRED' else
      if D3D10_RESOURCE_NOT_ACQUIRED = self then
        Result := 'D3D10_RESOURCE_NOT_ACQUIRED' else
      if INVALID_D3D11_DEVICE = self then
        Result := 'INVALID_D3D11_DEVICE' else
      if INVALID_D3D11_RESOURCE = self then
        Result := 'INVALID_D3D11_RESOURCE' else
      if D3D11_RESOURCE_ALREADY_ACQUIRED = self then
        Result := 'D3D11_RESOURCE_ALREADY_ACQUIRED' else
      if D3D11_RESOURCE_NOT_ACQUIRED = self then
        Result := 'D3D11_RESOURCE_NOT_ACQUIRED' else
      if INVALID_DX9_MEDIA_ADAPTER = self then
        Result := 'INVALID_DX9_MEDIA_ADAPTER' else
      if INVALID_DX9_MEDIA_SURFACE = self then
        Result := 'INVALID_DX9_MEDIA_SURFACE' else
      if DX9_MEDIA_SURFACE_ALREADY_ACQUIRED = self then
        Result := 'DX9_MEDIA_SURFACE_ALREADY_ACQUIRED' else
      if DX9_MEDIA_SURFACE_NOT_ACQUIRED = self then
        Result := 'DX9_MEDIA_SURFACE_NOT_ACQUIRED' else
      if DEVICE_PARTITION_FAILED_EXT = self then
        Result := 'DEVICE_PARTITION_FAILED_EXT' else
      if INVALID_PARTITION_COUNT = self then
        Result := 'INVALID_PARTITION_COUNT' else
      if INVALID_PARTITION_NAME = self then
        Result := 'INVALID_PARTITION_NAME' else
      if EGL_RESOURCE_NOT_ACQUIRED = self then
        Result := 'EGL_RESOURCE_NOT_ACQUIRED' else
      if INVALID_EGL_OBJECT = self then
        Result := 'INVALID_EGL_OBJECT' else
      if INVALID_ACCELERATOR = self then
        Result := 'INVALID_ACCELERATOR' else
      if INVALID_ACCELERATOR_TYPE = self then
        Result := 'INVALID_ACCELERATOR_TYPE' else
      if INVALID_ACCELERATOR_DESCRIPTOR = self then
        Result := 'INVALID_ACCELERATOR_DESCRIPTOR' else
      if ACCELERATOR_TYPE_NOT_SUPPORTED = self then
        Result := 'ACCELERATOR_TYPE_NOT_SUPPORTED' else
      if INVALID_VA_API_MEDIA_ADAPTER = self then
        Result := 'INVALID_VA_API_MEDIA_ADAPTER' else
      if INVALID_VA_API_MEDIA_SURFACE = self then
        Result := 'INVALID_VA_API_MEDIA_SURFACE' else
      if VA_API_MEDIA_SURFACE_ALREADY_ACQUIRED = self then
        Result := 'VA_API_MEDIA_SURFACE_ALREADY_ACQUIRED' else
      if VA_API_MEDIA_SURFACE_NOT_ACQUIRED = self then
        Result := 'VA_API_MEDIA_SURFACE_NOT_ACQUIRED' else
      if COMMAND_TERMINATED_ITSELF_WITH_FAILURE = self then
        Result := 'COMMAND_TERMINATED_ITSELF_WITH_FAILURE' else
      if CONTEXT_TERMINATED = self then
        Result := 'CONTEXT_TERMINATED' else
      if INVALID_COMMAND_BUFFER = self then
        Result := 'INVALID_COMMAND_BUFFER' else
      if INVALID_SYNC_POINT_WAIT_LIST = self then
        Result := 'INVALID_SYNC_POINT_WAIT_LIST' else
      if INCOMPATIBLE_COMMAND_QUEUE = self then
        Result := 'INCOMPATIBLE_COMMAND_QUEUE' else
      if INVALID_MUTABLE_COMMAND = self then
        Result := 'INVALID_MUTABLE_COMMAND' else
      if INVALID_SEMAPHORE = self then
        Result := 'INVALID_SEMAPHORE' else
      if KERNEL_ILLEGAL_BUFFER_READ_WRITE = self then
        Result := 'KERNEL_ILLEGAL_BUFFER_READ_WRITE' else
      if GRALLOC_RESOURCE_NOT_ACQUIRED = self then
        Result := 'GRALLOC_RESOURCE_NOT_ACQUIRED' else
      if INVALID_GRALLOC_OBJECT = self then
        Result := 'INVALID_GRALLOC_OBJECT' else
        Result := $'clErrorCode[{self.val}]';
    end;
    
    public function IS_ERROR := val<>0;
    
    public procedure RaiseIfError;
    
    public static function operator explicit(st: clCommandExecutionStatus): clErrorCode := new clErrorCode(st.val);
    public static function operator explicit(ec: clErrorCode): clCommandExecutionStatus := new clCommandExecutionStatus(ec.val);
    
  end;
  
  ///
  clEventInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property EVENT_COMMAND_QUEUE:              clEventInfo read new clEventInfo($11D0);
    public static property EVENT_COMMAND_TYPE:               clEventInfo read new clEventInfo($11D1);
    public static property EVENT_REFERENCE_COUNT:            clEventInfo read new clEventInfo($11D2);
    public static property EVENT_COMMAND_EXECUTION_STATUS:   clEventInfo read new clEventInfo($11D3);
    public static property EVENT_CONTEXT:                    clEventInfo read new clEventInfo($11D4);
    public static property EVENT_COMMAND_TERMINATION_REASON: clEventInfo read new clEventInfo($41ED);
    
    public function ToString: string; override;
    begin
      if EVENT_COMMAND_QUEUE = self then
        Result := 'EVENT_COMMAND_QUEUE' else
      if EVENT_COMMAND_TYPE = self then
        Result := 'EVENT_COMMAND_TYPE' else
      if EVENT_REFERENCE_COUNT = self then
        Result := 'EVENT_REFERENCE_COUNT' else
      if EVENT_COMMAND_EXECUTION_STATUS = self then
        Result := 'EVENT_COMMAND_EXECUTION_STATUS' else
      if EVENT_CONTEXT = self then
        Result := 'EVENT_CONTEXT' else
      if EVENT_COMMAND_TERMINATION_REASON = self then
        Result := 'EVENT_COMMAND_TERMINATION_REASON' else
        Result := $'clEventInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clExternalMemoryHandleType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property EXTERNAL_MEMORY_HANDLE_OPAQUE_FD:         clExternalMemoryHandleType read new clExternalMemoryHandleType($2060);
    public static property EXTERNAL_MEMORY_HANDLE_OPAQUE_WIN32:      clExternalMemoryHandleType read new clExternalMemoryHandleType($2061);
    public static property EXTERNAL_MEMORY_HANDLE_OPAQUE_WIN32_KMT:  clExternalMemoryHandleType read new clExternalMemoryHandleType($2062);
    public static property EXTERNAL_MEMORY_HANDLE_D3D11_TEXTURE:     clExternalMemoryHandleType read new clExternalMemoryHandleType($2063);
    public static property EXTERNAL_MEMORY_HANDLE_D3D11_TEXTURE_KMT: clExternalMemoryHandleType read new clExternalMemoryHandleType($2064);
    public static property EXTERNAL_MEMORY_HANDLE_D3D12_HEAP:        clExternalMemoryHandleType read new clExternalMemoryHandleType($2065);
    public static property EXTERNAL_MEMORY_HANDLE_D3D12_RESOURCE:    clExternalMemoryHandleType read new clExternalMemoryHandleType($2066);
    public static property EXTERNAL_MEMORY_HANDLE_DMA_BUF:           clExternalMemoryHandleType read new clExternalMemoryHandleType($2067);
    
    public function ToString: string; override;
    begin
      if EXTERNAL_MEMORY_HANDLE_OPAQUE_FD = self then
        Result := 'EXTERNAL_MEMORY_HANDLE_OPAQUE_FD' else
      if EXTERNAL_MEMORY_HANDLE_OPAQUE_WIN32 = self then
        Result := 'EXTERNAL_MEMORY_HANDLE_OPAQUE_WIN32' else
      if EXTERNAL_MEMORY_HANDLE_OPAQUE_WIN32_KMT = self then
        Result := 'EXTERNAL_MEMORY_HANDLE_OPAQUE_WIN32_KMT' else
      if EXTERNAL_MEMORY_HANDLE_D3D11_TEXTURE = self then
        Result := 'EXTERNAL_MEMORY_HANDLE_D3D11_TEXTURE' else
      if EXTERNAL_MEMORY_HANDLE_D3D11_TEXTURE_KMT = self then
        Result := 'EXTERNAL_MEMORY_HANDLE_D3D11_TEXTURE_KMT' else
      if EXTERNAL_MEMORY_HANDLE_D3D12_HEAP = self then
        Result := 'EXTERNAL_MEMORY_HANDLE_D3D12_HEAP' else
      if EXTERNAL_MEMORY_HANDLE_D3D12_RESOURCE = self then
        Result := 'EXTERNAL_MEMORY_HANDLE_D3D12_RESOURCE' else
      if EXTERNAL_MEMORY_HANDLE_DMA_BUF = self then
        Result := 'EXTERNAL_MEMORY_HANDLE_DMA_BUF' else
        Result := $'clExternalMemoryHandleType[{self.val}]';
    end;
    
  end;
  
  ///
  clExternalSemaphoreHandleType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SEMAPHORE_HANDLE_OPAQUE_FD:        clExternalSemaphoreHandleType read new clExternalSemaphoreHandleType($2055);
    public static property SEMAPHORE_HANDLE_OPAQUE_WIN32:     clExternalSemaphoreHandleType read new clExternalSemaphoreHandleType($2056);
    public static property SEMAPHORE_HANDLE_OPAQUE_WIN32_KMT: clExternalSemaphoreHandleType read new clExternalSemaphoreHandleType($2057);
    public static property SEMAPHORE_HANDLE_SYNC_FD:          clExternalSemaphoreHandleType read new clExternalSemaphoreHandleType($2058);
    public static property SEMAPHORE_HANDLE_D3D12_FENCE:      clExternalSemaphoreHandleType read new clExternalSemaphoreHandleType($2059);
    
    public function ToString: string; override;
    begin
      if SEMAPHORE_HANDLE_OPAQUE_FD = self then
        Result := 'SEMAPHORE_HANDLE_OPAQUE_FD' else
      if SEMAPHORE_HANDLE_OPAQUE_WIN32 = self then
        Result := 'SEMAPHORE_HANDLE_OPAQUE_WIN32' else
      if SEMAPHORE_HANDLE_OPAQUE_WIN32_KMT = self then
        Result := 'SEMAPHORE_HANDLE_OPAQUE_WIN32_KMT' else
      if SEMAPHORE_HANDLE_SYNC_FD = self then
        Result := 'SEMAPHORE_HANDLE_SYNC_FD' else
      if SEMAPHORE_HANDLE_D3D12_FENCE = self then
        Result := 'SEMAPHORE_HANDLE_D3D12_FENCE' else
        Result := $'clExternalSemaphoreHandleType[{self.val}]';
    end;
    
  end;
  
  ///
  clFilterMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FILTER_NEAREST: clFilterMode read new clFilterMode($1140);
    public static property FILTER_LINEAR:  clFilterMode read new clFilterMode($1141);
    
    public function ToString: string; override;
    begin
      if FILTER_NEAREST = self then
        Result := 'FILTER_NEAREST' else
      if FILTER_LINEAR = self then
        Result := 'FILTER_LINEAR' else
        Result := $'clFilterMode[{self.val}]';
    end;
    
  end;
  
  ///
  clGlContextInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CURRENT_DEVICE_FOR_GL_CONTEXT: clGlContextInfo read new clGlContextInfo($2006);
    public static property DEVICES_FOR_GL_CONTEXT:        clGlContextInfo read new clGlContextInfo($2007);
    
    public function ToString: string; override;
    begin
      if CURRENT_DEVICE_FOR_GL_CONTEXT = self then
        Result := 'CURRENT_DEVICE_FOR_GL_CONTEXT' else
      if DEVICES_FOR_GL_CONTEXT = self then
        Result := 'DEVICES_FOR_GL_CONTEXT' else
        Result := $'clGlContextInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clGlObjectType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_OBJECT_BUFFER:          clGlObjectType read new clGlObjectType($2000);
    public static property GL_OBJECT_TEXTURE2D:       clGlObjectType read new clGlObjectType($2001);
    public static property GL_OBJECT_TEXTURE3D:       clGlObjectType read new clGlObjectType($2002);
    public static property GL_OBJECT_RENDERBUFFER:    clGlObjectType read new clGlObjectType($2003);
    public static property GL_OBJECT_TEXTURE2D_ARRAY: clGlObjectType read new clGlObjectType($200E);
    public static property GL_OBJECT_TEXTURE1D:       clGlObjectType read new clGlObjectType($200F);
    public static property GL_OBJECT_TEXTURE1D_ARRAY: clGlObjectType read new clGlObjectType($2010);
    public static property GL_OBJECT_TEXTURE_BUFFER:  clGlObjectType read new clGlObjectType($2011);
    
    public function ToString: string; override;
    begin
      if GL_OBJECT_BUFFER = self then
        Result := 'GL_OBJECT_BUFFER' else
      if GL_OBJECT_TEXTURE2D = self then
        Result := 'GL_OBJECT_TEXTURE2D' else
      if GL_OBJECT_TEXTURE3D = self then
        Result := 'GL_OBJECT_TEXTURE3D' else
      if GL_OBJECT_RENDERBUFFER = self then
        Result := 'GL_OBJECT_RENDERBUFFER' else
      if GL_OBJECT_TEXTURE2D_ARRAY = self then
        Result := 'GL_OBJECT_TEXTURE2D_ARRAY' else
      if GL_OBJECT_TEXTURE1D = self then
        Result := 'GL_OBJECT_TEXTURE1D' else
      if GL_OBJECT_TEXTURE1D_ARRAY = self then
        Result := 'GL_OBJECT_TEXTURE1D_ARRAY' else
      if GL_OBJECT_TEXTURE_BUFFER = self then
        Result := 'GL_OBJECT_TEXTURE_BUFFER' else
        Result := $'clGlObjectType[{self.val}]';
    end;
    
  end;
  
  ///
  clGlTextureInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_TEXTURE_TARGET: clGlTextureInfo read new clGlTextureInfo($2004);
    public static property GL_MIPMAP_LEVEL:   clGlTextureInfo read new clGlTextureInfo($2005);
    public static property GL_NUM_SAMPLES:    clGlTextureInfo read new clGlTextureInfo($2012);
    
    public function ToString: string; override;
    begin
      if GL_TEXTURE_TARGET = self then
        Result := 'GL_TEXTURE_TARGET' else
      if GL_MIPMAP_LEVEL = self then
        Result := 'GL_MIPMAP_LEVEL' else
      if GL_NUM_SAMPLES = self then
        Result := 'GL_NUM_SAMPLES' else
        Result := $'clGlTextureInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clHostCachePolicy = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MEM_HOST_UNCACHED:        clHostCachePolicy read new clHostCachePolicy($40A4);
    public static property MEM_HOST_WRITEBACK:       clHostCachePolicy read new clHostCachePolicy($40A5);
    public static property MEM_HOST_WRITETHROUGH:    clHostCachePolicy read new clHostCachePolicy($40A6);
    public static property MEM_HOST_WRITE_COMBINING: clHostCachePolicy read new clHostCachePolicy($40A7);
    public static property MEM_HOST_IOCOHERENT:      clHostCachePolicy read new clHostCachePolicy($40A9);
    
    public function ToString: string; override;
    begin
      if MEM_HOST_UNCACHED = self then
        Result := 'MEM_HOST_UNCACHED' else
      if MEM_HOST_WRITEBACK = self then
        Result := 'MEM_HOST_WRITEBACK' else
      if MEM_HOST_WRITETHROUGH = self then
        Result := 'MEM_HOST_WRITETHROUGH' else
      if MEM_HOST_WRITE_COMBINING = self then
        Result := 'MEM_HOST_WRITE_COMBINING' else
      if MEM_HOST_IOCOHERENT = self then
        Result := 'MEM_HOST_IOCOHERENT' else
        Result := $'clHostCachePolicy[{self.val}]';
    end;
    
  end;
  
  ///
  clIcdlInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ICDL_OCL_VERSION: clIcdlInfo read new clIcdlInfo($0001);
    public static property ICDL_VERSION:     clIcdlInfo read new clIcdlInfo($0002);
    public static property ICDL_NAME:        clIcdlInfo read new clIcdlInfo($0003);
    public static property ICDL_VENDOR:      clIcdlInfo read new clIcdlInfo($0004);
    
    public function ToString: string; override;
    begin
      if ICDL_OCL_VERSION = self then
        Result := 'ICDL_OCL_VERSION' else
      if ICDL_VERSION = self then
        Result := 'ICDL_VERSION' else
      if ICDL_NAME = self then
        Result := 'ICDL_NAME' else
      if ICDL_VENDOR = self then
        Result := 'ICDL_VENDOR' else
        Result := $'clIcdlInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clImageInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property IMAGE_FORMAT:            clImageInfo read new clImageInfo($1110);
    public static property IMAGE_ELEMENT_SIZE:      clImageInfo read new clImageInfo($1111);
    public static property IMAGE_ROW_PITCH:         clImageInfo read new clImageInfo($1112);
    public static property IMAGE_SLICE_PITCH:       clImageInfo read new clImageInfo($1113);
    public static property IMAGE_WIDTH:             clImageInfo read new clImageInfo($1114);
    public static property IMAGE_HEIGHT:            clImageInfo read new clImageInfo($1115);
    public static property IMAGE_DEPTH:             clImageInfo read new clImageInfo($1116);
    public static property IMAGE_ARRAY_SIZE:        clImageInfo read new clImageInfo($1117);
    public static property IMAGE_BUFFER:            clImageInfo read new clImageInfo($1118);
    public static property IMAGE_NUM_MIP_LEVELS:    clImageInfo read new clImageInfo($1119);
    public static property IMAGE_NUM_SAMPLES:       clImageInfo read new clImageInfo($111A);
    public static property IMAGE_DX9_MEDIA_PLANE:   clImageInfo read new clImageInfo($202A);
    public static property IMAGE_D3D10_SUBRESOURCE: clImageInfo read new clImageInfo($4016);
    public static property IMAGE_D3D11_SUBRESOURCE: clImageInfo read new clImageInfo($401F);
    public static property IMAGE_DX9_PLANE:         clImageInfo read new clImageInfo($4075);
    public static property IMAGE_VA_API_PLANE:      clImageInfo read new clImageInfo($4099);
    public static property EGL_YUV_PLANE:           clImageInfo read new clImageInfo($4107);
    
    public function ToString: string; override;
    begin
      if IMAGE_FORMAT = self then
        Result := 'IMAGE_FORMAT' else
      if IMAGE_ELEMENT_SIZE = self then
        Result := 'IMAGE_ELEMENT_SIZE' else
      if IMAGE_ROW_PITCH = self then
        Result := 'IMAGE_ROW_PITCH' else
      if IMAGE_SLICE_PITCH = self then
        Result := 'IMAGE_SLICE_PITCH' else
      if IMAGE_WIDTH = self then
        Result := 'IMAGE_WIDTH' else
      if IMAGE_HEIGHT = self then
        Result := 'IMAGE_HEIGHT' else
      if IMAGE_DEPTH = self then
        Result := 'IMAGE_DEPTH' else
      if IMAGE_ARRAY_SIZE = self then
        Result := 'IMAGE_ARRAY_SIZE' else
      if IMAGE_BUFFER = self then
        Result := 'IMAGE_BUFFER' else
      if IMAGE_NUM_MIP_LEVELS = self then
        Result := 'IMAGE_NUM_MIP_LEVELS' else
      if IMAGE_NUM_SAMPLES = self then
        Result := 'IMAGE_NUM_SAMPLES' else
      if IMAGE_DX9_MEDIA_PLANE = self then
        Result := 'IMAGE_DX9_MEDIA_PLANE' else
      if IMAGE_D3D10_SUBRESOURCE = self then
        Result := 'IMAGE_D3D10_SUBRESOURCE' else
      if IMAGE_D3D11_SUBRESOURCE = self then
        Result := 'IMAGE_D3D11_SUBRESOURCE' else
      if IMAGE_DX9_PLANE = self then
        Result := 'IMAGE_DX9_PLANE' else
      if IMAGE_VA_API_PLANE = self then
        Result := 'IMAGE_VA_API_PLANE' else
      if EGL_YUV_PLANE = self then
        Result := 'EGL_YUV_PLANE' else
        Result := $'clImageInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clImagePitchInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property IMAGE_ROW_PITCH:       clImagePitchInfo read new clImagePitchInfo($1112);
    public static property IMAGE_SLICE_PITCH:     clImagePitchInfo read new clImagePitchInfo($1113);
    public static property IMAGE_ROW_ALIGNMENT:   clImagePitchInfo read new clImagePitchInfo($40A2);
    public static property IMAGE_SLICE_ALIGNMENT: clImagePitchInfo read new clImagePitchInfo($40A3);
    
    public function ToString: string; override;
    begin
      if IMAGE_ROW_PITCH = self then
        Result := 'IMAGE_ROW_PITCH' else
      if IMAGE_SLICE_PITCH = self then
        Result := 'IMAGE_SLICE_PITCH' else
      if IMAGE_ROW_ALIGNMENT = self then
        Result := 'IMAGE_ROW_ALIGNMENT' else
      if IMAGE_SLICE_ALIGNMENT = self then
        Result := 'IMAGE_SLICE_ALIGNMENT' else
        Result := $'clImagePitchInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clImageRequirementsInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property IMAGE_REQUIREMENTS_ROW_PITCH_ALIGNMENT:    clImageRequirementsInfo read new clImageRequirementsInfo($1290);
    public static property IMAGE_REQUIREMENTS_SLICE_PITCH_ALIGNMENT:  clImageRequirementsInfo read new clImageRequirementsInfo($1291);
    public static property IMAGE_REQUIREMENTS_BASE_ADDRESS_ALIGNMENT: clImageRequirementsInfo read new clImageRequirementsInfo($1292);
    public static property IMAGE_REQUIREMENTS_SIZE:                   clImageRequirementsInfo read new clImageRequirementsInfo($12B2);
    public static property IMAGE_REQUIREMENTS_MAX_WIDTH:              clImageRequirementsInfo read new clImageRequirementsInfo($12B3);
    public static property IMAGE_REQUIREMENTS_MAX_HEIGHT:             clImageRequirementsInfo read new clImageRequirementsInfo($12B4);
    public static property IMAGE_REQUIREMENTS_MAX_DEPTH:              clImageRequirementsInfo read new clImageRequirementsInfo($12B5);
    public static property IMAGE_REQUIREMENTS_MAX_ARRAY_SIZE:         clImageRequirementsInfo read new clImageRequirementsInfo($12B6);
    
    public function ToString: string; override;
    begin
      if IMAGE_REQUIREMENTS_ROW_PITCH_ALIGNMENT = self then
        Result := 'IMAGE_REQUIREMENTS_ROW_PITCH_ALIGNMENT' else
      if IMAGE_REQUIREMENTS_SLICE_PITCH_ALIGNMENT = self then
        Result := 'IMAGE_REQUIREMENTS_SLICE_PITCH_ALIGNMENT' else
      if IMAGE_REQUIREMENTS_BASE_ADDRESS_ALIGNMENT = self then
        Result := 'IMAGE_REQUIREMENTS_BASE_ADDRESS_ALIGNMENT' else
      if IMAGE_REQUIREMENTS_SIZE = self then
        Result := 'IMAGE_REQUIREMENTS_SIZE' else
      if IMAGE_REQUIREMENTS_MAX_WIDTH = self then
        Result := 'IMAGE_REQUIREMENTS_MAX_WIDTH' else
      if IMAGE_REQUIREMENTS_MAX_HEIGHT = self then
        Result := 'IMAGE_REQUIREMENTS_MAX_HEIGHT' else
      if IMAGE_REQUIREMENTS_MAX_DEPTH = self then
        Result := 'IMAGE_REQUIREMENTS_MAX_DEPTH' else
      if IMAGE_REQUIREMENTS_MAX_ARRAY_SIZE = self then
        Result := 'IMAGE_REQUIREMENTS_MAX_ARRAY_SIZE' else
        Result := $'clImageRequirementsInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clImportProperties = record
    public val: IntPtr;
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property IMPORT_TYPE:                                clImportProperties read new clImportProperties($40B2);
    public static property IMPORT_TYPE_PROTECTED:                      clImportProperties read new clImportProperties($40B5);
    public static property IMPORT_DMA_BUF_DATA_CONSISTENCY_WITH_HOST:  clImportProperties read new clImportProperties($41E3);
    public static property IMPORT_ANDROID_HARDWARE_BUFFER_PLANE_INDEX: clImportProperties read new clImportProperties($41EF);
    public static property IMPORT_ANDROID_HARDWARE_BUFFER_LAYER_INDEX: clImportProperties read new clImportProperties($41F0);
    
    public function ToString: string; override;
    begin
      if IMPORT_TYPE = self then
        Result := 'IMPORT_TYPE' else
      if IMPORT_TYPE_PROTECTED = self then
        Result := 'IMPORT_TYPE_PROTECTED' else
      if IMPORT_DMA_BUF_DATA_CONSISTENCY_WITH_HOST = self then
        Result := 'IMPORT_DMA_BUF_DATA_CONSISTENCY_WITH_HOST' else
      if IMPORT_ANDROID_HARDWARE_BUFFER_PLANE_INDEX = self then
        Result := 'IMPORT_ANDROID_HARDWARE_BUFFER_PLANE_INDEX' else
      if IMPORT_ANDROID_HARDWARE_BUFFER_LAYER_INDEX = self then
        Result := 'IMPORT_ANDROID_HARDWARE_BUFFER_LAYER_INDEX' else
        Result := $'clImportProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clKernelArgAccessQualifier = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KERNEL_ARG_ACCESS_READ_ONLY:  clKernelArgAccessQualifier read new clKernelArgAccessQualifier($11A0);
    public static property KERNEL_ARG_ACCESS_WRITE_ONLY: clKernelArgAccessQualifier read new clKernelArgAccessQualifier($11A1);
    public static property KERNEL_ARG_ACCESS_READ_WRITE: clKernelArgAccessQualifier read new clKernelArgAccessQualifier($11A2);
    public static property KERNEL_ARG_ACCESS_NONE:       clKernelArgAccessQualifier read new clKernelArgAccessQualifier($11A3);
    
    public function ToString: string; override;
    begin
      if KERNEL_ARG_ACCESS_READ_ONLY = self then
        Result := 'KERNEL_ARG_ACCESS_READ_ONLY' else
      if KERNEL_ARG_ACCESS_WRITE_ONLY = self then
        Result := 'KERNEL_ARG_ACCESS_WRITE_ONLY' else
      if KERNEL_ARG_ACCESS_READ_WRITE = self then
        Result := 'KERNEL_ARG_ACCESS_READ_WRITE' else
      if KERNEL_ARG_ACCESS_NONE = self then
        Result := 'KERNEL_ARG_ACCESS_NONE' else
        Result := $'clKernelArgAccessQualifier[{self.val}]';
    end;
    
  end;
  
  ///
  clKernelArgAddressQualifier = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KERNEL_ARG_ADDRESS_GLOBAL:   clKernelArgAddressQualifier read new clKernelArgAddressQualifier($119B);
    public static property KERNEL_ARG_ADDRESS_LOCAL:    clKernelArgAddressQualifier read new clKernelArgAddressQualifier($119C);
    public static property KERNEL_ARG_ADDRESS_CONSTANT: clKernelArgAddressQualifier read new clKernelArgAddressQualifier($119D);
    public static property KERNEL_ARG_ADDRESS_PRIVATE:  clKernelArgAddressQualifier read new clKernelArgAddressQualifier($119E);
    
    public function ToString: string; override;
    begin
      if KERNEL_ARG_ADDRESS_GLOBAL = self then
        Result := 'KERNEL_ARG_ADDRESS_GLOBAL' else
      if KERNEL_ARG_ADDRESS_LOCAL = self then
        Result := 'KERNEL_ARG_ADDRESS_LOCAL' else
      if KERNEL_ARG_ADDRESS_CONSTANT = self then
        Result := 'KERNEL_ARG_ADDRESS_CONSTANT' else
      if KERNEL_ARG_ADDRESS_PRIVATE = self then
        Result := 'KERNEL_ARG_ADDRESS_PRIVATE' else
        Result := $'clKernelArgAddressQualifier[{self.val}]';
    end;
    
  end;
  
  ///
  clKernelArgInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KERNEL_ARG_ADDRESS_QUALIFIER: clKernelArgInfo read new clKernelArgInfo($1196);
    public static property KERNEL_ARG_ACCESS_QUALIFIER:  clKernelArgInfo read new clKernelArgInfo($1197);
    public static property KERNEL_ARG_TYPE_NAME:         clKernelArgInfo read new clKernelArgInfo($1198);
    public static property KERNEL_ARG_TYPE_QUALIFIER:    clKernelArgInfo read new clKernelArgInfo($1199);
    public static property KERNEL_ARG_NAME:              clKernelArgInfo read new clKernelArgInfo($119A);
    
    public function ToString: string; override;
    begin
      if KERNEL_ARG_ADDRESS_QUALIFIER = self then
        Result := 'KERNEL_ARG_ADDRESS_QUALIFIER' else
      if KERNEL_ARG_ACCESS_QUALIFIER = self then
        Result := 'KERNEL_ARG_ACCESS_QUALIFIER' else
      if KERNEL_ARG_TYPE_NAME = self then
        Result := 'KERNEL_ARG_TYPE_NAME' else
      if KERNEL_ARG_TYPE_QUALIFIER = self then
        Result := 'KERNEL_ARG_TYPE_QUALIFIER' else
      if KERNEL_ARG_NAME = self then
        Result := 'KERNEL_ARG_NAME' else
        Result := $'clKernelArgInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clKernelArgTypeQualifier = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property KERNEL_ARG_TYPE_NONE:     clKernelArgTypeQualifier read new clKernelArgTypeQualifier(0);
    public static property KERNEL_ARG_TYPE_CONST:    clKernelArgTypeQualifier read new clKernelArgTypeQualifier(1 shl 0);
    public static property KERNEL_ARG_TYPE_RESTRICT: clKernelArgTypeQualifier read new clKernelArgTypeQualifier(1 shl 1);
    public static property KERNEL_ARG_TYPE_VOLATILE: clKernelArgTypeQualifier read new clKernelArgTypeQualifier(1 shl 2);
    public static property KERNEL_ARG_TYPE_PIPE:     clKernelArgTypeQualifier read new clKernelArgTypeQualifier(1 shl 3);
    
    public property ANY_FLAGS: boolean read self.val<>0;
    
    public static function operator+(v1, v2: clKernelArgTypeQualifier) := new clKernelArgTypeQualifier(v1.val or v2.val);
    public static function operator or(v1, v2: clKernelArgTypeQualifier) := new clKernelArgTypeQualifier(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clKernelArgTypeQualifier; v2: clKernelArgTypeQualifier) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clKernelArgTypeQualifier) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'KERNEL_ARG_TYPE_NONE';
        exit;
      end;
      if KERNEL_ARG_TYPE_CONST in self then
      begin
        res += 'KERNEL_ARG_TYPE_CONST+';
        left_val := left_val and not KERNEL_ARG_TYPE_CONST.val;
      end;
      if KERNEL_ARG_TYPE_RESTRICT in self then
      begin
        res += 'KERNEL_ARG_TYPE_RESTRICT+';
        left_val := left_val and not KERNEL_ARG_TYPE_RESTRICT.val;
      end;
      if KERNEL_ARG_TYPE_VOLATILE in self then
      begin
        res += 'KERNEL_ARG_TYPE_VOLATILE+';
        left_val := left_val and not KERNEL_ARG_TYPE_VOLATILE.val;
      end;
      if KERNEL_ARG_TYPE_PIPE in self then
      begin
        res += 'KERNEL_ARG_TYPE_PIPE+';
        left_val := left_val and not KERNEL_ARG_TYPE_PIPE.val;
      end;
      if left_val<>0 then
      begin
        res += 'clKernelArgTypeQualifier[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clKernelExecInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KERNEL_EXEC_INFO_SVM_PTRS:                        clKernelExecInfo read new clKernelExecInfo($11B6);
    public static property KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM:           clKernelExecInfo read new clKernelExecInfo($11B7);
    public static property KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE:            clKernelExecInfo read new clKernelExecInfo($41E5);
    public static property KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE_MODIFIER:   clKernelExecInfo read new clKernelExecInfo($41E6);
    public static property KERNEL_EXEC_INFO_WARP_COUNT_LIMIT:                clKernelExecInfo read new clKernelExecInfo($41E8);
    public static property KERNEL_EXEC_INFO_COMPUTE_UNIT_MAX_QUEUED_BATCHES: clKernelExecInfo read new clKernelExecInfo($41F1);
    public static property KERNEL_EXEC_INFO_INDIRECT_HOST_ACCESS:            clKernelExecInfo read new clKernelExecInfo($4200);
    public static property KERNEL_EXEC_INFO_INDIRECT_DEVICE_ACCESS:          clKernelExecInfo read new clKernelExecInfo($4201);
    public static property KERNEL_EXEC_INFO_INDIRECT_SHARED_ACCESS:          clKernelExecInfo read new clKernelExecInfo($4202);
    public static property KERNEL_EXEC_INFO_USM_PTRS:                        clKernelExecInfo read new clKernelExecInfo($4203);
    
    public function ToString: string; override;
    begin
      if KERNEL_EXEC_INFO_SVM_PTRS = self then
        Result := 'KERNEL_EXEC_INFO_SVM_PTRS' else
      if KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM = self then
        Result := 'KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM' else
      if KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE = self then
        Result := 'KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE' else
      if KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE_MODIFIER = self then
        Result := 'KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE_MODIFIER' else
      if KERNEL_EXEC_INFO_WARP_COUNT_LIMIT = self then
        Result := 'KERNEL_EXEC_INFO_WARP_COUNT_LIMIT' else
      if KERNEL_EXEC_INFO_COMPUTE_UNIT_MAX_QUEUED_BATCHES = self then
        Result := 'KERNEL_EXEC_INFO_COMPUTE_UNIT_MAX_QUEUED_BATCHES' else
      if KERNEL_EXEC_INFO_INDIRECT_HOST_ACCESS = self then
        Result := 'KERNEL_EXEC_INFO_INDIRECT_HOST_ACCESS' else
      if KERNEL_EXEC_INFO_INDIRECT_DEVICE_ACCESS = self then
        Result := 'KERNEL_EXEC_INFO_INDIRECT_DEVICE_ACCESS' else
      if KERNEL_EXEC_INFO_INDIRECT_SHARED_ACCESS = self then
        Result := 'KERNEL_EXEC_INFO_INDIRECT_SHARED_ACCESS' else
      if KERNEL_EXEC_INFO_USM_PTRS = self then
        Result := 'KERNEL_EXEC_INFO_USM_PTRS' else
        Result := $'clKernelExecInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clKernelInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KERNEL_FUNCTION_NAME:   clKernelInfo read new clKernelInfo($1190);
    public static property KERNEL_NUM_ARGS:        clKernelInfo read new clKernelInfo($1191);
    public static property KERNEL_REFERENCE_COUNT: clKernelInfo read new clKernelInfo($1192);
    public static property KERNEL_CONTEXT:         clKernelInfo read new clKernelInfo($1193);
    public static property KERNEL_PROGRAM:         clKernelInfo read new clKernelInfo($1194);
    public static property KERNEL_ATTRIBUTES:      clKernelInfo read new clKernelInfo($1195);
    public static property KERNEL_MAX_WARP_COUNT:  clKernelInfo read new clKernelInfo($41E9);
    
    public function ToString: string; override;
    begin
      if KERNEL_FUNCTION_NAME = self then
        Result := 'KERNEL_FUNCTION_NAME' else
      if KERNEL_NUM_ARGS = self then
        Result := 'KERNEL_NUM_ARGS' else
      if KERNEL_REFERENCE_COUNT = self then
        Result := 'KERNEL_REFERENCE_COUNT' else
      if KERNEL_CONTEXT = self then
        Result := 'KERNEL_CONTEXT' else
      if KERNEL_PROGRAM = self then
        Result := 'KERNEL_PROGRAM' else
      if KERNEL_ATTRIBUTES = self then
        Result := 'KERNEL_ATTRIBUTES' else
      if KERNEL_MAX_WARP_COUNT = self then
        Result := 'KERNEL_MAX_WARP_COUNT' else
        Result := $'clKernelInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clKernelSubGroupInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT: clKernelSubGroupInfo read new clKernelSubGroupInfo($11B8);
    public static property KERNEL_MAX_NUM_SUB_GROUPS:             clKernelSubGroupInfo read new clKernelSubGroupInfo($11B9);
    public static property KERNEL_COMPILE_NUM_SUB_GROUPS:         clKernelSubGroupInfo read new clKernelSubGroupInfo($11BA);
    public static property KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE: clKernelSubGroupInfo read new clKernelSubGroupInfo($2033);
    public static property KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE:    clKernelSubGroupInfo read new clKernelSubGroupInfo($2034);
    public static property KERNEL_COMPILE_SUB_GROUP_SIZE:         clKernelSubGroupInfo read new clKernelSubGroupInfo($410A);
    
    public function ToString: string; override;
    begin
      if KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT = self then
        Result := 'KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT' else
      if KERNEL_MAX_NUM_SUB_GROUPS = self then
        Result := 'KERNEL_MAX_NUM_SUB_GROUPS' else
      if KERNEL_COMPILE_NUM_SUB_GROUPS = self then
        Result := 'KERNEL_COMPILE_NUM_SUB_GROUPS' else
      if KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE = self then
        Result := 'KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE' else
      if KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE = self then
        Result := 'KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE' else
      if KERNEL_COMPILE_SUB_GROUP_SIZE = self then
        Result := 'KERNEL_COMPILE_SUB_GROUP_SIZE' else
        Result := $'clKernelSubGroupInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clKernelWorkGroupInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KERNEL_WORK_GROUP_SIZE:                    clKernelWorkGroupInfo read new clKernelWorkGroupInfo($11B0);
    public static property KERNEL_COMPILE_WORK_GROUP_SIZE:            clKernelWorkGroupInfo read new clKernelWorkGroupInfo($11B1);
    public static property KERNEL_LOCAL_MEM_SIZE:                     clKernelWorkGroupInfo read new clKernelWorkGroupInfo($11B2);
    public static property KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE: clKernelWorkGroupInfo read new clKernelWorkGroupInfo($11B3);
    public static property KERNEL_PRIVATE_MEM_SIZE:                   clKernelWorkGroupInfo read new clKernelWorkGroupInfo($11B4);
    public static property KERNEL_GLOBAL_WORK_SIZE:                   clKernelWorkGroupInfo read new clKernelWorkGroupInfo($11B5);
    public static property KERNEL_SPILL_MEM_SIZE:                     clKernelWorkGroupInfo read new clKernelWorkGroupInfo($4109);
    
    public function ToString: string; override;
    begin
      if KERNEL_WORK_GROUP_SIZE = self then
        Result := 'KERNEL_WORK_GROUP_SIZE' else
      if KERNEL_COMPILE_WORK_GROUP_SIZE = self then
        Result := 'KERNEL_COMPILE_WORK_GROUP_SIZE' else
      if KERNEL_LOCAL_MEM_SIZE = self then
        Result := 'KERNEL_LOCAL_MEM_SIZE' else
      if KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = self then
        Result := 'KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE' else
      if KERNEL_PRIVATE_MEM_SIZE = self then
        Result := 'KERNEL_PRIVATE_MEM_SIZE' else
      if KERNEL_GLOBAL_WORK_SIZE = self then
        Result := 'KERNEL_GLOBAL_WORK_SIZE' else
      if KERNEL_SPILL_MEM_SIZE = self then
        Result := 'KERNEL_SPILL_MEM_SIZE' else
        Result := $'clKernelWorkGroupInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clKhronosVendorId = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KHRONOS_VENDOR_ID_CODEPLAY: clKhronosVendorId read new clKhronosVendorId($10004);
    public static property KHRONOS_VENDOR_ID:          clKhronosVendorId read new clKhronosVendorId($10006);
    
    public function ToString: string; override;
    begin
      if KHRONOS_VENDOR_ID_CODEPLAY = self then
        Result := 'KHRONOS_VENDOR_ID_CODEPLAY' else
      if KHRONOS_VENDOR_ID = self then
        Result := 'KHRONOS_VENDOR_ID' else
        Result := $'clKhronosVendorId[{self.val}]';
    end;
    
  end;
  
  ///
  clLayerInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LAYER_API_VERSION: clLayerInfo read new clLayerInfo($4240);
    public static property LAYER_NAME:        clLayerInfo read new clLayerInfo($4241);
    
    public function ToString: string; override;
    begin
      if LAYER_API_VERSION = self then
        Result := 'LAYER_API_VERSION' else
      if LAYER_NAME = self then
        Result := 'LAYER_NAME' else
        Result := $'clLayerInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clMapFlags = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MAP_READ:                    clMapFlags read new clMapFlags(1 shl 0);
    public static property MAP_WRITE:                   clMapFlags read new clMapFlags(1 shl 1);
    public static property MAP_WRITE_INVALIDATE_REGION: clMapFlags read new clMapFlags(1 shl 2);
    
    public static function operator+(v1, v2: clMapFlags) := new clMapFlags(v1.val or v2.val);
    public static function operator or(v1, v2: clMapFlags) := new clMapFlags(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clMapFlags; v2: clMapFlags) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clMapFlags) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clMapFlags[0]';
        exit;
      end;
      if MAP_READ in self then
      begin
        res += 'MAP_READ+';
        left_val := left_val and not MAP_READ.val;
      end;
      if MAP_WRITE in self then
      begin
        res += 'MAP_WRITE+';
        left_val := left_val and not MAP_WRITE.val;
      end;
      if MAP_WRITE_INVALIDATE_REGION in self then
      begin
        res += 'MAP_WRITE_INVALIDATE_REGION+';
        left_val := left_val and not MAP_WRITE_INVALIDATE_REGION.val;
      end;
      if left_val<>0 then
      begin
        res += 'clMapFlags[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clMbBlockType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ME_MB_TYPE_16x16: clMbBlockType read new clMbBlockType(0);
    public static property ME_MB_TYPE_8x8:   clMbBlockType read new clMbBlockType($0001);
    public static property ME_MB_TYPE_4x4:   clMbBlockType read new clMbBlockType($0002);
    
    public function ToString: string; override;
    begin
      if ME_MB_TYPE_16x16 = self then
        Result := 'ME_MB_TYPE_16x16' else
      if ME_MB_TYPE_8x8 = self then
        Result := 'ME_MB_TYPE_8x8' else
      if ME_MB_TYPE_4x4 = self then
        Result := 'ME_MB_TYPE_4x4' else
        Result := $'clMbBlockType[{self.val}]';
    end;
    
  end;
  
  ///
  clMemFlags = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MEM_READ_WRITE:                clMemFlags read new clMemFlags(1 shl 0);
    public static property MEM_WRITE_ONLY:                clMemFlags read new clMemFlags(1 shl 1);
    public static property MEM_READ_ONLY:                 clMemFlags read new clMemFlags(1 shl 2);
    public static property MEM_USE_HOST_PTR:              clMemFlags read new clMemFlags(1 shl 3);
    public static property MEM_ALLOC_HOST_PTR:            clMemFlags read new clMemFlags(1 shl 4);
    public static property MEM_COPY_HOST_PTR:             clMemFlags read new clMemFlags(1 shl 5);
    public static property MEM_HOST_WRITE_ONLY:           clMemFlags read new clMemFlags(1 shl 7);
    public static property MEM_HOST_READ_ONLY:            clMemFlags read new clMemFlags(1 shl 8);
    public static property MEM_HOST_NO_ACCESS:            clMemFlags read new clMemFlags(1 shl 9);
    public static property MEM_SVM_FINE_GRAIN_BUFFER:     clMemFlags read new clMemFlags(1 shl 10);
    public static property MEM_SVM_ATOMICS:               clMemFlags read new clMemFlags(1 shl 11);
    public static property MEM_KERNEL_READ_AND_WRITE:     clMemFlags read new clMemFlags(1 shl 12);
    public static property MEM_FORCE_HOST_MEMORY:         clMemFlags read new clMemFlags(1 shl 20);
    public static property MEM_NO_ACCESS:                 clMemFlags read new clMemFlags(1 shl 24);
    public static property MEM_ACCESS_FLAGS_UNRESTRICTED: clMemFlags read new clMemFlags(1 shl 25);
    public static property MEM_USE_UNCACHED_CPU_MEMORY:   clMemFlags read new clMemFlags(1 shl 26);
    public static property MEM_USE_CACHED_CPU_MEMORY:     clMemFlags read new clMemFlags(1 shl 27);
    public static property MEM_USE_GRALLOC_PTR:           clMemFlags read new clMemFlags(1 shl 28);
    public static property MEM_EXT_HOST_PTR:              clMemFlags read new clMemFlags(1 shl 29);
    public static property MEM_PROTECTED_ALLOC:           clMemFlags read new clMemFlags(1 shl 36);
    
    public static function operator+(v1, v2: clMemFlags) := new clMemFlags(v1.val or v2.val);
    public static function operator or(v1, v2: clMemFlags) := new clMemFlags(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clMemFlags; v2: clMemFlags) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clMemFlags) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clMemFlags[0]';
        exit;
      end;
      if MEM_READ_WRITE in self then
      begin
        res += 'MEM_READ_WRITE+';
        left_val := left_val and not MEM_READ_WRITE.val;
      end;
      if MEM_WRITE_ONLY in self then
      begin
        res += 'MEM_WRITE_ONLY+';
        left_val := left_val and not MEM_WRITE_ONLY.val;
      end;
      if MEM_READ_ONLY in self then
      begin
        res += 'MEM_READ_ONLY+';
        left_val := left_val and not MEM_READ_ONLY.val;
      end;
      if MEM_USE_HOST_PTR in self then
      begin
        res += 'MEM_USE_HOST_PTR+';
        left_val := left_val and not MEM_USE_HOST_PTR.val;
      end;
      if MEM_ALLOC_HOST_PTR in self then
      begin
        res += 'MEM_ALLOC_HOST_PTR+';
        left_val := left_val and not MEM_ALLOC_HOST_PTR.val;
      end;
      if MEM_COPY_HOST_PTR in self then
      begin
        res += 'MEM_COPY_HOST_PTR+';
        left_val := left_val and not MEM_COPY_HOST_PTR.val;
      end;
      if MEM_HOST_WRITE_ONLY in self then
      begin
        res += 'MEM_HOST_WRITE_ONLY+';
        left_val := left_val and not MEM_HOST_WRITE_ONLY.val;
      end;
      if MEM_HOST_READ_ONLY in self then
      begin
        res += 'MEM_HOST_READ_ONLY+';
        left_val := left_val and not MEM_HOST_READ_ONLY.val;
      end;
      if MEM_HOST_NO_ACCESS in self then
      begin
        res += 'MEM_HOST_NO_ACCESS+';
        left_val := left_val and not MEM_HOST_NO_ACCESS.val;
      end;
      if MEM_SVM_FINE_GRAIN_BUFFER in self then
      begin
        res += 'MEM_SVM_FINE_GRAIN_BUFFER+';
        left_val := left_val and not MEM_SVM_FINE_GRAIN_BUFFER.val;
      end;
      if MEM_SVM_ATOMICS in self then
      begin
        res += 'MEM_SVM_ATOMICS+';
        left_val := left_val and not MEM_SVM_ATOMICS.val;
      end;
      if MEM_KERNEL_READ_AND_WRITE in self then
      begin
        res += 'MEM_KERNEL_READ_AND_WRITE+';
        left_val := left_val and not MEM_KERNEL_READ_AND_WRITE.val;
      end;
      if MEM_FORCE_HOST_MEMORY in self then
      begin
        res += 'MEM_FORCE_HOST_MEMORY+';
        left_val := left_val and not MEM_FORCE_HOST_MEMORY.val;
      end;
      if MEM_NO_ACCESS in self then
      begin
        res += 'MEM_NO_ACCESS+';
        left_val := left_val and not MEM_NO_ACCESS.val;
      end;
      if MEM_ACCESS_FLAGS_UNRESTRICTED in self then
      begin
        res += 'MEM_ACCESS_FLAGS_UNRESTRICTED+';
        left_val := left_val and not MEM_ACCESS_FLAGS_UNRESTRICTED.val;
      end;
      if MEM_USE_UNCACHED_CPU_MEMORY in self then
      begin
        res += 'MEM_USE_UNCACHED_CPU_MEMORY+';
        left_val := left_val and not MEM_USE_UNCACHED_CPU_MEMORY.val;
      end;
      if MEM_USE_CACHED_CPU_MEMORY in self then
      begin
        res += 'MEM_USE_CACHED_CPU_MEMORY+';
        left_val := left_val and not MEM_USE_CACHED_CPU_MEMORY.val;
      end;
      if MEM_USE_GRALLOC_PTR in self then
      begin
        res += 'MEM_USE_GRALLOC_PTR+';
        left_val := left_val and not MEM_USE_GRALLOC_PTR.val;
      end;
      if MEM_EXT_HOST_PTR in self then
      begin
        res += 'MEM_EXT_HOST_PTR+';
        left_val := left_val and not MEM_EXT_HOST_PTR.val;
      end;
      if MEM_PROTECTED_ALLOC in self then
      begin
        res += 'MEM_PROTECTED_ALLOC+';
        left_val := left_val and not MEM_PROTECTED_ALLOC.val;
      end;
      if left_val<>0 then
      begin
        res += 'clMemFlags[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clMemInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MEM_TYPE:                   clMemInfo read new clMemInfo($1100);
    public static property MEM_FLAGS:                  clMemInfo read new clMemInfo($1101);
    public static property MEM_SIZE:                   clMemInfo read new clMemInfo($1102);
    public static property MEM_HOST_PTR:               clMemInfo read new clMemInfo($1103);
    public static property MEM_MAP_COUNT:              clMemInfo read new clMemInfo($1104);
    public static property MEM_REFERENCE_COUNT:        clMemInfo read new clMemInfo($1105);
    public static property MEM_CONTEXT:                clMemInfo read new clMemInfo($1106);
    public static property MEM_ASSOCIATED_MEMOBJECT:   clMemInfo read new clMemInfo($1107);
    public static property MEM_OFFSET:                 clMemInfo read new clMemInfo($1108);
    public static property MEM_USES_SVM_POINTER:       clMemInfo read new clMemInfo($1109);
    public static property MEM_PROPERTIES:             clMemInfo read new clMemInfo($110A);
    public static property MEM_DX9_MEDIA_ADAPTER_TYPE: clMemInfo read new clMemInfo($2028);
    public static property MEM_DX9_MEDIA_SURFACE_INFO: clMemInfo read new clMemInfo($2029);
    public static property MEM_D3D10_RESOURCE:         clMemInfo read new clMemInfo($4015);
    public static property MEM_D3D11_RESOURCE:         clMemInfo read new clMemInfo($401E);
    public static property MEM_DX9_RESOURCE:           clMemInfo read new clMemInfo($4027);
    public static property MEM_DX9_SHARED_HANDLE:      clMemInfo read new clMemInfo($4074);
    public static property MEM_VA_API_MEDIA_SURFACE:   clMemInfo read new clMemInfo($4098);
    public static property MEM_USES_SVM_POINTER_ARM:   clMemInfo read new clMemInfo($40B7);
    public static property MEM_ALLOC_FLAGS_INTEL:      clMemInfo read new clMemInfo($4195);
    public static property MEM_ALLOC_TYPE:             clMemInfo read new clMemInfo($419A);
    public static property MEM_ALLOC_BASE_PTR:         clMemInfo read new clMemInfo($419B);
    public static property MEM_ALLOC_SIZE:             clMemInfo read new clMemInfo($419C);
    public static property MEM_ALLOC_DEVICE:           clMemInfo read new clMemInfo($419D);
    
    public function ToString: string; override;
    begin
      if MEM_TYPE = self then
        Result := 'MEM_TYPE' else
      if MEM_FLAGS = self then
        Result := 'MEM_FLAGS' else
      if MEM_SIZE = self then
        Result := 'MEM_SIZE' else
      if MEM_HOST_PTR = self then
        Result := 'MEM_HOST_PTR' else
      if MEM_MAP_COUNT = self then
        Result := 'MEM_MAP_COUNT' else
      if MEM_REFERENCE_COUNT = self then
        Result := 'MEM_REFERENCE_COUNT' else
      if MEM_CONTEXT = self then
        Result := 'MEM_CONTEXT' else
      if MEM_ASSOCIATED_MEMOBJECT = self then
        Result := 'MEM_ASSOCIATED_MEMOBJECT' else
      if MEM_OFFSET = self then
        Result := 'MEM_OFFSET' else
      if MEM_USES_SVM_POINTER = self then
        Result := 'MEM_USES_SVM_POINTER' else
      if MEM_PROPERTIES = self then
        Result := 'MEM_PROPERTIES' else
      if MEM_DX9_MEDIA_ADAPTER_TYPE = self then
        Result := 'MEM_DX9_MEDIA_ADAPTER_TYPE' else
      if MEM_DX9_MEDIA_SURFACE_INFO = self then
        Result := 'MEM_DX9_MEDIA_SURFACE_INFO' else
      if MEM_D3D10_RESOURCE = self then
        Result := 'MEM_D3D10_RESOURCE' else
      if MEM_D3D11_RESOURCE = self then
        Result := 'MEM_D3D11_RESOURCE' else
      if MEM_DX9_RESOURCE = self then
        Result := 'MEM_DX9_RESOURCE' else
      if MEM_DX9_SHARED_HANDLE = self then
        Result := 'MEM_DX9_SHARED_HANDLE' else
      if MEM_VA_API_MEDIA_SURFACE = self then
        Result := 'MEM_VA_API_MEDIA_SURFACE' else
      if MEM_USES_SVM_POINTER_ARM = self then
        Result := 'MEM_USES_SVM_POINTER_ARM' else
      if MEM_ALLOC_FLAGS_INTEL = self then
        Result := 'MEM_ALLOC_FLAGS_INTEL' else
      if MEM_ALLOC_TYPE = self then
        Result := 'MEM_ALLOC_TYPE' else
      if MEM_ALLOC_BASE_PTR = self then
        Result := 'MEM_ALLOC_BASE_PTR' else
      if MEM_ALLOC_SIZE = self then
        Result := 'MEM_ALLOC_SIZE' else
      if MEM_ALLOC_DEVICE = self then
        Result := 'MEM_ALLOC_DEVICE' else
        Result := $'clMemInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clMemMigrationFlags = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MIGRATE_MEM_OBJECT_HOST:              clMemMigrationFlags read new clMemMigrationFlags(1 shl 0);
    public static property MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED: clMemMigrationFlags read new clMemMigrationFlags(1 shl 1);
    
    public static function operator+(v1, v2: clMemMigrationFlags) := new clMemMigrationFlags(v1.val or v2.val);
    public static function operator or(v1, v2: clMemMigrationFlags) := new clMemMigrationFlags(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clMemMigrationFlags; v2: clMemMigrationFlags) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clMemMigrationFlags) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clMemMigrationFlags[0]';
        exit;
      end;
      if MIGRATE_MEM_OBJECT_HOST in self then
      begin
        res += 'MIGRATE_MEM_OBJECT_HOST+';
        left_val := left_val and not MIGRATE_MEM_OBJECT_HOST.val;
      end;
      if MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED in self then
      begin
        res += 'MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED+';
        left_val := left_val and not MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED.val;
      end;
      if left_val<>0 then
      begin
        res += 'clMemMigrationFlags[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clMemObjectType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MEM_OBJECT_BUFFER:         clMemObjectType read new clMemObjectType($10F0);
    public static property MEM_OBJECT_IMAGE2D:        clMemObjectType read new clMemObjectType($10F1);
    public static property MEM_OBJECT_IMAGE3D:        clMemObjectType read new clMemObjectType($10F2);
    public static property MEM_OBJECT_IMAGE2D_ARRAY:  clMemObjectType read new clMemObjectType($10F3);
    public static property MEM_OBJECT_IMAGE1D:        clMemObjectType read new clMemObjectType($10F4);
    public static property MEM_OBJECT_IMAGE1D_ARRAY:  clMemObjectType read new clMemObjectType($10F5);
    public static property MEM_OBJECT_IMAGE1D_BUFFER: clMemObjectType read new clMemObjectType($10F6);
    public static property MEM_OBJECT_PIPE:           clMemObjectType read new clMemObjectType($10F7);
    
    public function ToString: string; override;
    begin
      if MEM_OBJECT_BUFFER = self then
        Result := 'MEM_OBJECT_BUFFER' else
      if MEM_OBJECT_IMAGE2D = self then
        Result := 'MEM_OBJECT_IMAGE2D' else
      if MEM_OBJECT_IMAGE3D = self then
        Result := 'MEM_OBJECT_IMAGE3D' else
      if MEM_OBJECT_IMAGE2D_ARRAY = self then
        Result := 'MEM_OBJECT_IMAGE2D_ARRAY' else
      if MEM_OBJECT_IMAGE1D = self then
        Result := 'MEM_OBJECT_IMAGE1D' else
      if MEM_OBJECT_IMAGE1D_ARRAY = self then
        Result := 'MEM_OBJECT_IMAGE1D_ARRAY' else
      if MEM_OBJECT_IMAGE1D_BUFFER = self then
        Result := 'MEM_OBJECT_IMAGE1D_BUFFER' else
      if MEM_OBJECT_PIPE = self then
        Result := 'MEM_OBJECT_PIPE' else
        Result := $'clMemObjectType[{self.val}]';
    end;
    
  end;
  
  ///
  clMemProperties = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_HANDLE_LIST_END:        clMemProperties read new clMemProperties(0);
    public static property DEVICE_HANDLE_LIST:            clMemProperties read new clMemProperties($2051);
    public static property MEM_ALLOC_FLAGS_IMG:           clMemProperties read new clMemProperties($40D7);
    public static property MEM_LOCALLY_UNCACHED_RESOURCE: clMemProperties read new clMemProperties($4218);
    public static property MEM_DEVICE_ID:                 clMemProperties read new clMemProperties($4219);
    
    public function ToString: string; override;
    begin
      if DEVICE_HANDLE_LIST_END = self then
        Result := 'DEVICE_HANDLE_LIST_END' else
      if DEVICE_HANDLE_LIST = self then
        Result := 'DEVICE_HANDLE_LIST' else
      if MEM_ALLOC_FLAGS_IMG = self then
        Result := 'MEM_ALLOC_FLAGS_IMG' else
      if MEM_LOCALLY_UNCACHED_RESOURCE = self then
        Result := 'MEM_LOCALLY_UNCACHED_RESOURCE' else
      if MEM_DEVICE_ID = self then
        Result := 'MEM_DEVICE_ID' else
        Result := $'clMemProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clMipmapFilterMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MIPMAP_FILTER_ANY: clMipmapFilterMode read new clMipmapFilterMode(0);
    public static property MIPMAP_FILTER_BOX: clMipmapFilterMode read new clMipmapFilterMode($0001);
    
    public function ToString: string; override;
    begin
      if MIPMAP_FILTER_ANY = self then
        Result := 'MIPMAP_FILTER_ANY' else
      if MIPMAP_FILTER_BOX = self then
        Result := 'MIPMAP_FILTER_BOX' else
        Result := $'clMipmapFilterMode[{self.val}]';
    end;
    
  end;
  
  ///
  clMutableCommandInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MUTABLE_COMMAND_COMMAND_QUEUE:       clMutableCommandInfo read new clMutableCommandInfo($12A0);
    public static property MUTABLE_COMMAND_COMMAND_BUFFER:      clMutableCommandInfo read new clMutableCommandInfo($12A1);
    public static property MUTABLE_DISPATCH_PROPERTIES_ARRAY:   clMutableCommandInfo read new clMutableCommandInfo($12A2);
    public static property MUTABLE_DISPATCH_KERNEL:             clMutableCommandInfo read new clMutableCommandInfo($12A3);
    public static property MUTABLE_DISPATCH_DIMENSIONS:         clMutableCommandInfo read new clMutableCommandInfo($12A4);
    public static property MUTABLE_DISPATCH_GLOBAL_WORK_OFFSET: clMutableCommandInfo read new clMutableCommandInfo($12A5);
    public static property MUTABLE_DISPATCH_GLOBAL_WORK_SIZE:   clMutableCommandInfo read new clMutableCommandInfo($12A6);
    public static property MUTABLE_DISPATCH_LOCAL_WORK_SIZE:    clMutableCommandInfo read new clMutableCommandInfo($12A7);
    public static property MUTABLE_COMMAND_COMMAND_TYPE:        clMutableCommandInfo read new clMutableCommandInfo($12AD);
    
    public function ToString: string; override;
    begin
      if MUTABLE_COMMAND_COMMAND_QUEUE = self then
        Result := 'MUTABLE_COMMAND_COMMAND_QUEUE' else
      if MUTABLE_COMMAND_COMMAND_BUFFER = self then
        Result := 'MUTABLE_COMMAND_COMMAND_BUFFER' else
      if MUTABLE_DISPATCH_PROPERTIES_ARRAY = self then
        Result := 'MUTABLE_DISPATCH_PROPERTIES_ARRAY' else
      if MUTABLE_DISPATCH_KERNEL = self then
        Result := 'MUTABLE_DISPATCH_KERNEL' else
      if MUTABLE_DISPATCH_DIMENSIONS = self then
        Result := 'MUTABLE_DISPATCH_DIMENSIONS' else
      if MUTABLE_DISPATCH_GLOBAL_WORK_OFFSET = self then
        Result := 'MUTABLE_DISPATCH_GLOBAL_WORK_OFFSET' else
      if MUTABLE_DISPATCH_GLOBAL_WORK_SIZE = self then
        Result := 'MUTABLE_DISPATCH_GLOBAL_WORK_SIZE' else
      if MUTABLE_DISPATCH_LOCAL_WORK_SIZE = self then
        Result := 'MUTABLE_DISPATCH_LOCAL_WORK_SIZE' else
      if MUTABLE_COMMAND_COMMAND_TYPE = self then
        Result := 'MUTABLE_COMMAND_COMMAND_TYPE' else
        Result := $'clMutableCommandInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clMutableDispatchFields = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MUTABLE_DISPATCH_GLOBAL_OFFSET: clMutableDispatchFields read new clMutableDispatchFields(1 shl 0);
    public static property MUTABLE_DISPATCH_GLOBAL_SIZE:   clMutableDispatchFields read new clMutableDispatchFields(1 shl 1);
    public static property MUTABLE_DISPATCH_LOCAL_SIZE:    clMutableDispatchFields read new clMutableDispatchFields(1 shl 2);
    public static property MUTABLE_DISPATCH_ARGUMENTS:     clMutableDispatchFields read new clMutableDispatchFields(1 shl 3);
    public static property MUTABLE_DISPATCH_EXEC_INFO:     clMutableDispatchFields read new clMutableDispatchFields(1 shl 4);
    
    public static function operator+(v1, v2: clMutableDispatchFields) := new clMutableDispatchFields(v1.val or v2.val);
    public static function operator or(v1, v2: clMutableDispatchFields) := new clMutableDispatchFields(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clMutableDispatchFields; v2: clMutableDispatchFields) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clMutableDispatchFields) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clMutableDispatchFields[0]';
        exit;
      end;
      if MUTABLE_DISPATCH_GLOBAL_OFFSET in self then
      begin
        res += 'MUTABLE_DISPATCH_GLOBAL_OFFSET+';
        left_val := left_val and not MUTABLE_DISPATCH_GLOBAL_OFFSET.val;
      end;
      if MUTABLE_DISPATCH_GLOBAL_SIZE in self then
      begin
        res += 'MUTABLE_DISPATCH_GLOBAL_SIZE+';
        left_val := left_val and not MUTABLE_DISPATCH_GLOBAL_SIZE.val;
      end;
      if MUTABLE_DISPATCH_LOCAL_SIZE in self then
      begin
        res += 'MUTABLE_DISPATCH_LOCAL_SIZE+';
        left_val := left_val and not MUTABLE_DISPATCH_LOCAL_SIZE.val;
      end;
      if MUTABLE_DISPATCH_ARGUMENTS in self then
      begin
        res += 'MUTABLE_DISPATCH_ARGUMENTS+';
        left_val := left_val and not MUTABLE_DISPATCH_ARGUMENTS.val;
      end;
      if MUTABLE_DISPATCH_EXEC_INFO in self then
      begin
        res += 'MUTABLE_DISPATCH_EXEC_INFO+';
        left_val := left_val and not MUTABLE_DISPATCH_EXEC_INFO.val;
      end;
      if left_val<>0 then
      begin
        res += 'clMutableDispatchFields[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clNDRangeKernelCommandProperties = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MUTABLE_DISPATCH_UPDATABLE_FIELDS: clNDRangeKernelCommandProperties read new clNDRangeKernelCommandProperties($12B1);
    
    public function ToString: string; override;
    begin
      if MUTABLE_DISPATCH_UPDATABLE_FIELDS = self then
        Result := 'MUTABLE_DISPATCH_UPDATABLE_FIELDS' else
        Result := $'clNDRangeKernelCommandProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clPipeInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PIPE_PACKET_SIZE: clPipeInfo read new clPipeInfo($1120);
    public static property PIPE_MAX_PACKETS: clPipeInfo read new clPipeInfo($1121);
    public static property PIPE_PROPERTIES:  clPipeInfo read new clPipeInfo($1122);
    
    public function ToString: string; override;
    begin
      if PIPE_PACKET_SIZE = self then
        Result := 'PIPE_PACKET_SIZE' else
      if PIPE_MAX_PACKETS = self then
        Result := 'PIPE_MAX_PACKETS' else
      if PIPE_PROPERTIES = self then
        Result := 'PIPE_PROPERTIES' else
        Result := $'clPipeInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clPlatformCommandBufferCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property COMMAND_BUFFER_PLATFORM_UNIVERSAL_SYNC:  clPlatformCommandBufferCapabilities read new clPlatformCommandBufferCapabilities(1 shl 0);
    public static property COMMAND_BUFFER_PLATFORM_REMAP_QUEUES:    clPlatformCommandBufferCapabilities read new clPlatformCommandBufferCapabilities(1 shl 1);
    public static property COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP: clPlatformCommandBufferCapabilities read new clPlatformCommandBufferCapabilities(1 shl 2);
    
    public static function operator+(v1, v2: clPlatformCommandBufferCapabilities) := new clPlatformCommandBufferCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clPlatformCommandBufferCapabilities) := new clPlatformCommandBufferCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clPlatformCommandBufferCapabilities; v2: clPlatformCommandBufferCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clPlatformCommandBufferCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clPlatformCommandBufferCapabilities[0]';
        exit;
      end;
      if COMMAND_BUFFER_PLATFORM_UNIVERSAL_SYNC in self then
      begin
        res += 'COMMAND_BUFFER_PLATFORM_UNIVERSAL_SYNC+';
        left_val := left_val and not COMMAND_BUFFER_PLATFORM_UNIVERSAL_SYNC.val;
      end;
      if COMMAND_BUFFER_PLATFORM_REMAP_QUEUES in self then
      begin
        res += 'COMMAND_BUFFER_PLATFORM_REMAP_QUEUES+';
        left_val := left_val and not COMMAND_BUFFER_PLATFORM_REMAP_QUEUES.val;
      end;
      if COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP in self then
      begin
        res += 'COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP+';
        left_val := left_val and not COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP.val;
      end;
      if left_val<>0 then
      begin
        res += 'clPlatformCommandBufferCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clPlatformInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PLATFORM_PROFILE:                             clPlatformInfo read new clPlatformInfo($0900);
    public static property PLATFORM_VERSION:                             clPlatformInfo read new clPlatformInfo($0901);
    public static property PLATFORM_NAME:                                clPlatformInfo read new clPlatformInfo($0902);
    public static property PLATFORM_VENDOR:                              clPlatformInfo read new clPlatformInfo($0903);
    public static property PLATFORM_EXTENSIONS:                          clPlatformInfo read new clPlatformInfo($0904);
    public static property PLATFORM_HOST_TIMER_RESOLUTION:               clPlatformInfo read new clPlatformInfo($0905);
    public static property PLATFORM_NUMERIC_VERSION:                     clPlatformInfo read new clPlatformInfo($0906);
    public static property PLATFORM_EXTENSIONS_WITH_VERSION:             clPlatformInfo read new clPlatformInfo($0907);
    public static property PLATFORM_COMMAND_BUFFER_CAPABILITIES:         clPlatformInfo read new clPlatformInfo($0908);
    public static property PLATFORM_ICD_SUFFIX:                          clPlatformInfo read new clPlatformInfo($0920);
    public static property PLATFORM_SEMAPHORE_TYPES:                     clPlatformInfo read new clPlatformInfo($2036);
    public static property PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES:       clPlatformInfo read new clPlatformInfo($2037);
    public static property PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES:       clPlatformInfo read new clPlatformInfo($2038);
    public static property PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES: clPlatformInfo read new clPlatformInfo($2044);
    
    public function ToString: string; override;
    begin
      if PLATFORM_PROFILE = self then
        Result := 'PLATFORM_PROFILE' else
      if PLATFORM_VERSION = self then
        Result := 'PLATFORM_VERSION' else
      if PLATFORM_NAME = self then
        Result := 'PLATFORM_NAME' else
      if PLATFORM_VENDOR = self then
        Result := 'PLATFORM_VENDOR' else
      if PLATFORM_EXTENSIONS = self then
        Result := 'PLATFORM_EXTENSIONS' else
      if PLATFORM_HOST_TIMER_RESOLUTION = self then
        Result := 'PLATFORM_HOST_TIMER_RESOLUTION' else
      if PLATFORM_NUMERIC_VERSION = self then
        Result := 'PLATFORM_NUMERIC_VERSION' else
      if PLATFORM_EXTENSIONS_WITH_VERSION = self then
        Result := 'PLATFORM_EXTENSIONS_WITH_VERSION' else
      if PLATFORM_COMMAND_BUFFER_CAPABILITIES = self then
        Result := 'PLATFORM_COMMAND_BUFFER_CAPABILITIES' else
      if PLATFORM_ICD_SUFFIX = self then
        Result := 'PLATFORM_ICD_SUFFIX' else
      if PLATFORM_SEMAPHORE_TYPES = self then
        Result := 'PLATFORM_SEMAPHORE_TYPES' else
      if PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES = self then
        Result := 'PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES' else
      if PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES = self then
        Result := 'PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES' else
      if PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES = self then
        Result := 'PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES' else
        Result := $'clPlatformInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clProfilingInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROFILING_COMMAND_QUEUED:   clProfilingInfo read new clProfilingInfo($1280);
    public static property PROFILING_COMMAND_SUBMIT:   clProfilingInfo read new clProfilingInfo($1281);
    public static property PROFILING_COMMAND_START:    clProfilingInfo read new clProfilingInfo($1282);
    public static property PROFILING_COMMAND_END:      clProfilingInfo read new clProfilingInfo($1283);
    public static property PROFILING_COMMAND_COMPLETE: clProfilingInfo read new clProfilingInfo($1284);
    
    public function ToString: string; override;
    begin
      if PROFILING_COMMAND_QUEUED = self then
        Result := 'PROFILING_COMMAND_QUEUED' else
      if PROFILING_COMMAND_SUBMIT = self then
        Result := 'PROFILING_COMMAND_SUBMIT' else
      if PROFILING_COMMAND_START = self then
        Result := 'PROFILING_COMMAND_START' else
      if PROFILING_COMMAND_END = self then
        Result := 'PROFILING_COMMAND_END' else
      if PROFILING_COMMAND_COMPLETE = self then
        Result := 'PROFILING_COMMAND_COMPLETE' else
        Result := $'clProfilingInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clProgramBinaryType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROGRAM_BINARY_TYPE_NONE:            clProgramBinaryType read new clProgramBinaryType(0);
    public static property PROGRAM_BINARY_TYPE_COMPILED_OBJECT: clProgramBinaryType read new clProgramBinaryType($0001);
    public static property PROGRAM_BINARY_TYPE_LIBRARY:         clProgramBinaryType read new clProgramBinaryType($0002);
    public static property PROGRAM_BINARY_TYPE_EXECUTABLE:      clProgramBinaryType read new clProgramBinaryType($0004);
    public static property PROGRAM_BINARY_TYPE_INTERMEDIATE:    clProgramBinaryType read new clProgramBinaryType($40E1);
    
    public function ToString: string; override;
    begin
      if PROGRAM_BINARY_TYPE_NONE = self then
        Result := 'PROGRAM_BINARY_TYPE_NONE' else
      if PROGRAM_BINARY_TYPE_COMPILED_OBJECT = self then
        Result := 'PROGRAM_BINARY_TYPE_COMPILED_OBJECT' else
      if PROGRAM_BINARY_TYPE_LIBRARY = self then
        Result := 'PROGRAM_BINARY_TYPE_LIBRARY' else
      if PROGRAM_BINARY_TYPE_EXECUTABLE = self then
        Result := 'PROGRAM_BINARY_TYPE_EXECUTABLE' else
      if PROGRAM_BINARY_TYPE_INTERMEDIATE = self then
        Result := 'PROGRAM_BINARY_TYPE_INTERMEDIATE' else
        Result := $'clProgramBinaryType[{self.val}]';
    end;
    
  end;
  
  ///
  clProgramBuildInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROGRAM_BUILD_STATUS:                     clProgramBuildInfo read new clProgramBuildInfo($1181);
    public static property PROGRAM_BUILD_OPTIONS:                    clProgramBuildInfo read new clProgramBuildInfo($1182);
    public static property PROGRAM_BUILD_LOG:                        clProgramBuildInfo read new clProgramBuildInfo($1183);
    public static property PROGRAM_BINARY_TYPE:                      clProgramBuildInfo read new clProgramBuildInfo($1184);
    public static property PROGRAM_BUILD_GLOBAL_VARIABLE_TOTAL_SIZE: clProgramBuildInfo read new clProgramBuildInfo($1185);
    
    public function ToString: string; override;
    begin
      if PROGRAM_BUILD_STATUS = self then
        Result := 'PROGRAM_BUILD_STATUS' else
      if PROGRAM_BUILD_OPTIONS = self then
        Result := 'PROGRAM_BUILD_OPTIONS' else
      if PROGRAM_BUILD_LOG = self then
        Result := 'PROGRAM_BUILD_LOG' else
      if PROGRAM_BINARY_TYPE = self then
        Result := 'PROGRAM_BINARY_TYPE' else
      if PROGRAM_BUILD_GLOBAL_VARIABLE_TOTAL_SIZE = self then
        Result := 'PROGRAM_BUILD_GLOBAL_VARIABLE_TOTAL_SIZE' else
        Result := $'clProgramBuildInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clProgramInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROGRAM_REFERENCE_COUNT:            clProgramInfo read new clProgramInfo($1160);
    public static property PROGRAM_CONTEXT:                    clProgramInfo read new clProgramInfo($1161);
    public static property PROGRAM_NUM_DEVICES:                clProgramInfo read new clProgramInfo($1162);
    public static property PROGRAM_DEVICES:                    clProgramInfo read new clProgramInfo($1163);
    public static property PROGRAM_SOURCE:                     clProgramInfo read new clProgramInfo($1164);
    public static property PROGRAM_BINARY_SIZES:               clProgramInfo read new clProgramInfo($1165);
    public static property PROGRAM_BINARIES:                   clProgramInfo read new clProgramInfo($1166);
    public static property PROGRAM_NUM_KERNELS:                clProgramInfo read new clProgramInfo($1167);
    public static property PROGRAM_KERNEL_NAMES:               clProgramInfo read new clProgramInfo($1168);
    public static property PROGRAM_IL:                         clProgramInfo read new clProgramInfo($1169);
    public static property PROGRAM_SCOPE_GLOBAL_CTORS_PRESENT: clProgramInfo read new clProgramInfo($116A);
    public static property PROGRAM_SCOPE_GLOBAL_DTORS_PRESENT: clProgramInfo read new clProgramInfo($116B);
    public static property PROGRAM_NUM_HOST_PIPES:             clProgramInfo read new clProgramInfo($4216);
    public static property PROGRAM_HOST_PIPE_NAMES:            clProgramInfo read new clProgramInfo($4217);
    
    public function ToString: string; override;
    begin
      if PROGRAM_REFERENCE_COUNT = self then
        Result := 'PROGRAM_REFERENCE_COUNT' else
      if PROGRAM_CONTEXT = self then
        Result := 'PROGRAM_CONTEXT' else
      if PROGRAM_NUM_DEVICES = self then
        Result := 'PROGRAM_NUM_DEVICES' else
      if PROGRAM_DEVICES = self then
        Result := 'PROGRAM_DEVICES' else
      if PROGRAM_SOURCE = self then
        Result := 'PROGRAM_SOURCE' else
      if PROGRAM_BINARY_SIZES = self then
        Result := 'PROGRAM_BINARY_SIZES' else
      if PROGRAM_BINARIES = self then
        Result := 'PROGRAM_BINARIES' else
      if PROGRAM_NUM_KERNELS = self then
        Result := 'PROGRAM_NUM_KERNELS' else
      if PROGRAM_KERNEL_NAMES = self then
        Result := 'PROGRAM_KERNEL_NAMES' else
      if PROGRAM_IL = self then
        Result := 'PROGRAM_IL' else
      if PROGRAM_SCOPE_GLOBAL_CTORS_PRESENT = self then
        Result := 'PROGRAM_SCOPE_GLOBAL_CTORS_PRESENT' else
      if PROGRAM_SCOPE_GLOBAL_DTORS_PRESENT = self then
        Result := 'PROGRAM_SCOPE_GLOBAL_DTORS_PRESENT' else
      if PROGRAM_NUM_HOST_PIPES = self then
        Result := 'PROGRAM_NUM_HOST_PIPES' else
      if PROGRAM_HOST_PIPE_NAMES = self then
        Result := 'PROGRAM_HOST_PIPE_NAMES' else
        Result := $'clProgramInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clQueueProperties = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property QUEUE_PRIORITY:        clQueueProperties read new clQueueProperties($1096);
    public static property QUEUE_THROTTLE:        clQueueProperties read new clQueueProperties($1097);
    public static property QUEUE_FAMILY:          clQueueProperties read new clQueueProperties($418C);
    public static property QUEUE_INDEX:           clQueueProperties read new clQueueProperties($418D);
    public static property QUEUE_JOB_SLOT:        clQueueProperties read new clQueueProperties($41E1);
    public static property QUEUE_KERNEL_BATCHING: clQueueProperties read new clQueueProperties($41E7);
    public static property QUEUE_DEFERRED_FLUSH:  clQueueProperties read new clQueueProperties($41EC);
    
    public function ToString: string; override;
    begin
      if QUEUE_PRIORITY = self then
        Result := 'QUEUE_PRIORITY' else
      if QUEUE_THROTTLE = self then
        Result := 'QUEUE_THROTTLE' else
      if QUEUE_FAMILY = self then
        Result := 'QUEUE_FAMILY' else
      if QUEUE_INDEX = self then
        Result := 'QUEUE_INDEX' else
      if QUEUE_JOB_SLOT = self then
        Result := 'QUEUE_JOB_SLOT' else
      if QUEUE_KERNEL_BATCHING = self then
        Result := 'QUEUE_KERNEL_BATCHING' else
      if QUEUE_DEFERRED_FLUSH = self then
        Result := 'QUEUE_DEFERRED_FLUSH' else
        Result := $'clQueueProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clSadAdjustMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ME_SAD_ADJUST_MODE_NONE: clSadAdjustMode read new clSadAdjustMode(0);
    public static property ME_SAD_ADJUST_MODE_HAAR: clSadAdjustMode read new clSadAdjustMode($0001);
    
    public function ToString: string; override;
    begin
      if ME_SAD_ADJUST_MODE_NONE = self then
        Result := 'ME_SAD_ADJUST_MODE_NONE' else
      if ME_SAD_ADJUST_MODE_HAAR = self then
        Result := 'ME_SAD_ADJUST_MODE_HAAR' else
        Result := $'clSadAdjustMode[{self.val}]';
    end;
    
  end;
  
  ///
  clSamplerInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SAMPLER_REFERENCE_COUNT:   clSamplerInfo read new clSamplerInfo($1150);
    public static property SAMPLER_CONTEXT:           clSamplerInfo read new clSamplerInfo($1151);
    public static property SAMPLER_NORMALIZED_COORDS: clSamplerInfo read new clSamplerInfo($1152);
    public static property SAMPLER_ADDRESSING_MODE:   clSamplerInfo read new clSamplerInfo($1153);
    public static property SAMPLER_FILTER_MODE:       clSamplerInfo read new clSamplerInfo($1154);
    public static property SAMPLER_MIP_FILTER_MODE:   clSamplerInfo read new clSamplerInfo($1155);
    public static property SAMPLER_LOD_MIN:           clSamplerInfo read new clSamplerInfo($1156);
    public static property SAMPLER_LOD_MAX:           clSamplerInfo read new clSamplerInfo($1157);
    public static property SAMPLER_PROPERTIES:        clSamplerInfo read new clSamplerInfo($1158);
    
    public function ToString: string; override;
    begin
      if SAMPLER_REFERENCE_COUNT = self then
        Result := 'SAMPLER_REFERENCE_COUNT' else
      if SAMPLER_CONTEXT = self then
        Result := 'SAMPLER_CONTEXT' else
      if SAMPLER_NORMALIZED_COORDS = self then
        Result := 'SAMPLER_NORMALIZED_COORDS' else
      if SAMPLER_ADDRESSING_MODE = self then
        Result := 'SAMPLER_ADDRESSING_MODE' else
      if SAMPLER_FILTER_MODE = self then
        Result := 'SAMPLER_FILTER_MODE' else
      if SAMPLER_MIP_FILTER_MODE = self then
        Result := 'SAMPLER_MIP_FILTER_MODE' else
      if SAMPLER_LOD_MIN = self then
        Result := 'SAMPLER_LOD_MIN' else
      if SAMPLER_LOD_MAX = self then
        Result := 'SAMPLER_LOD_MAX' else
      if SAMPLER_PROPERTIES = self then
        Result := 'SAMPLER_PROPERTIES' else
        Result := $'clSamplerInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clSamplerProperties = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property SAMPLER_MIP_FILTER_MODE: clSamplerProperties read new clSamplerProperties($1155);
    public static property SAMPLER_LOD_MIN:         clSamplerProperties read new clSamplerProperties($1156);
    public static property SAMPLER_LOD_MAX:         clSamplerProperties read new clSamplerProperties($1157);
    
    public function ToString: string; override;
    begin
      if SAMPLER_MIP_FILTER_MODE = self then
        Result := 'SAMPLER_MIP_FILTER_MODE' else
      if SAMPLER_LOD_MIN = self then
        Result := 'SAMPLER_LOD_MIN' else
      if SAMPLER_LOD_MAX = self then
        Result := 'SAMPLER_LOD_MAX' else
        Result := $'clSamplerProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clSearchPathType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ME_SEARCH_PATH_RADIUS_2_2:   clSearchPathType read new clSearchPathType(0);
    public static property ME_SEARCH_PATH_RADIUS_4_4:   clSearchPathType read new clSearchPathType($0001);
    public static property ME_SEARCH_PATH_RADIUS_16_12: clSearchPathType read new clSearchPathType($0005);
    
    public function ToString: string; override;
    begin
      if ME_SEARCH_PATH_RADIUS_2_2 = self then
        Result := 'ME_SEARCH_PATH_RADIUS_2_2' else
      if ME_SEARCH_PATH_RADIUS_4_4 = self then
        Result := 'ME_SEARCH_PATH_RADIUS_4_4' else
      if ME_SEARCH_PATH_RADIUS_16_12 = self then
        Result := 'ME_SEARCH_PATH_RADIUS_16_12' else
        Result := $'clSearchPathType[{self.val}]';
    end;
    
  end;
  
  ///
  clSemaphoreInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SEMAPHORE_CONTEXT:             clSemaphoreInfo read new clSemaphoreInfo($2039);
    public static property SEMAPHORE_REFERENCE_COUNT:     clSemaphoreInfo read new clSemaphoreInfo($203A);
    public static property SEMAPHORE_PROPERTIES:          clSemaphoreInfo read new clSemaphoreInfo($203B);
    public static property SEMAPHORE_PAYLOAD:             clSemaphoreInfo read new clSemaphoreInfo($203C);
    public static property SEMAPHORE_TYPE:                clSemaphoreInfo read new clSemaphoreInfo($203D);
    public static property SEMAPHORE_EXPORT_HANDLE_TYPES: clSemaphoreInfo read new clSemaphoreInfo($203F);
    public static property DEVICE_HANDLE_LIST:            clSemaphoreInfo read new clSemaphoreInfo($2051);
    
    public function ToString: string; override;
    begin
      if SEMAPHORE_CONTEXT = self then
        Result := 'SEMAPHORE_CONTEXT' else
      if SEMAPHORE_REFERENCE_COUNT = self then
        Result := 'SEMAPHORE_REFERENCE_COUNT' else
      if SEMAPHORE_PROPERTIES = self then
        Result := 'SEMAPHORE_PROPERTIES' else
      if SEMAPHORE_PAYLOAD = self then
        Result := 'SEMAPHORE_PAYLOAD' else
      if SEMAPHORE_TYPE = self then
        Result := 'SEMAPHORE_TYPE' else
      if SEMAPHORE_EXPORT_HANDLE_TYPES = self then
        Result := 'SEMAPHORE_EXPORT_HANDLE_TYPES' else
      if DEVICE_HANDLE_LIST = self then
        Result := 'DEVICE_HANDLE_LIST' else
        Result := $'clSemaphoreInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clSemaphoreProperties = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property SEMAPHORE_EXPORT_HANDLE_TYPES_LIST_END: clSemaphoreProperties read new clSemaphoreProperties(0);
    public static property DEVICE_HANDLE_LIST_END:                 clSemaphoreProperties read new clSemaphoreProperties(0);
    public static property SEMAPHORE_TYPE:                         clSemaphoreProperties read new clSemaphoreProperties($203D);
    public static property SEMAPHORE_EXPORT_HANDLE_TYPES:          clSemaphoreProperties read new clSemaphoreProperties($203F);
    public static property DEVICE_HANDLE_LIST:                     clSemaphoreProperties read new clSemaphoreProperties($2051);
    
    public function ToString: string; override;
    begin
      if SEMAPHORE_EXPORT_HANDLE_TYPES_LIST_END = self then
        Result := 'SEMAPHORE_EXPORT_HANDLE_TYPES_LIST_END' else
      if SEMAPHORE_TYPE = self then
        Result := 'SEMAPHORE_TYPE' else
      if SEMAPHORE_EXPORT_HANDLE_TYPES = self then
        Result := 'SEMAPHORE_EXPORT_HANDLE_TYPES' else
      if DEVICE_HANDLE_LIST = self then
        Result := 'DEVICE_HANDLE_LIST' else
        Result := $'clSemaphoreProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clSemaphoreType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SEMAPHORE_TYPE_BINARY: clSemaphoreType read new clSemaphoreType($0001);
    
    public function ToString: string; override;
    begin
      if SEMAPHORE_TYPE_BINARY = self then
        Result := 'SEMAPHORE_TYPE_BINARY' else
        Result := $'clSemaphoreType[{self.val}]';
    end;
    
  end;
  
  ///
  clSubpixelMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ME_SUBPIXEL_MODE_INTEGER: clSubpixelMode read new clSubpixelMode(0);
    public static property ME_SUBPIXEL_MODE_HPEL:    clSubpixelMode read new clSubpixelMode($0001);
    public static property ME_SUBPIXEL_MODE_QPEL:    clSubpixelMode read new clSubpixelMode($0002);
    
    public function ToString: string; override;
    begin
      if ME_SUBPIXEL_MODE_INTEGER = self then
        Result := 'ME_SUBPIXEL_MODE_INTEGER' else
      if ME_SUBPIXEL_MODE_HPEL = self then
        Result := 'ME_SUBPIXEL_MODE_HPEL' else
      if ME_SUBPIXEL_MODE_QPEL = self then
        Result := 'ME_SUBPIXEL_MODE_QPEL' else
        Result := $'clSubpixelMode[{self.val}]';
    end;
    
  end;
  
  ///
  clSvmMemFlags = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MEM_READ_WRITE:            clSvmMemFlags read new clSvmMemFlags(1 shl 0);
    public static property MEM_WRITE_ONLY:            clSvmMemFlags read new clSvmMemFlags(1 shl 1);
    public static property MEM_READ_ONLY:             clSvmMemFlags read new clSvmMemFlags(1 shl 2);
    public static property MEM_USE_HOST_PTR:          clSvmMemFlags read new clSvmMemFlags(1 shl 3);
    public static property MEM_ALLOC_HOST_PTR:        clSvmMemFlags read new clSvmMemFlags(1 shl 4);
    public static property MEM_COPY_HOST_PTR:         clSvmMemFlags read new clSvmMemFlags(1 shl 5);
    public static property MEM_HOST_WRITE_ONLY:       clSvmMemFlags read new clSvmMemFlags(1 shl 7);
    public static property MEM_HOST_READ_ONLY:        clSvmMemFlags read new clSvmMemFlags(1 shl 8);
    public static property MEM_HOST_NO_ACCESS:        clSvmMemFlags read new clSvmMemFlags(1 shl 9);
    public static property MEM_SVM_FINE_GRAIN_BUFFER: clSvmMemFlags read new clSvmMemFlags(1 shl 10);
    public static property MEM_SVM_ATOMICS:           clSvmMemFlags read new clSvmMemFlags(1 shl 11);
    public static property MEM_KERNEL_READ_AND_WRITE: clSvmMemFlags read new clSvmMemFlags(1 shl 12);
    
    public static function operator+(v1, v2: clSvmMemFlags) := new clSvmMemFlags(v1.val or v2.val);
    public static function operator or(v1, v2: clSvmMemFlags) := new clSvmMemFlags(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clSvmMemFlags; v2: clSvmMemFlags) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clSvmMemFlags) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clSvmMemFlags[0]';
        exit;
      end;
      if MEM_READ_WRITE in self then
      begin
        res += 'MEM_READ_WRITE+';
        left_val := left_val and not MEM_READ_WRITE.val;
      end;
      if MEM_WRITE_ONLY in self then
      begin
        res += 'MEM_WRITE_ONLY+';
        left_val := left_val and not MEM_WRITE_ONLY.val;
      end;
      if MEM_READ_ONLY in self then
      begin
        res += 'MEM_READ_ONLY+';
        left_val := left_val and not MEM_READ_ONLY.val;
      end;
      if MEM_USE_HOST_PTR in self then
      begin
        res += 'MEM_USE_HOST_PTR+';
        left_val := left_val and not MEM_USE_HOST_PTR.val;
      end;
      if MEM_ALLOC_HOST_PTR in self then
      begin
        res += 'MEM_ALLOC_HOST_PTR+';
        left_val := left_val and not MEM_ALLOC_HOST_PTR.val;
      end;
      if MEM_COPY_HOST_PTR in self then
      begin
        res += 'MEM_COPY_HOST_PTR+';
        left_val := left_val and not MEM_COPY_HOST_PTR.val;
      end;
      if MEM_HOST_WRITE_ONLY in self then
      begin
        res += 'MEM_HOST_WRITE_ONLY+';
        left_val := left_val and not MEM_HOST_WRITE_ONLY.val;
      end;
      if MEM_HOST_READ_ONLY in self then
      begin
        res += 'MEM_HOST_READ_ONLY+';
        left_val := left_val and not MEM_HOST_READ_ONLY.val;
      end;
      if MEM_HOST_NO_ACCESS in self then
      begin
        res += 'MEM_HOST_NO_ACCESS+';
        left_val := left_val and not MEM_HOST_NO_ACCESS.val;
      end;
      if MEM_SVM_FINE_GRAIN_BUFFER in self then
      begin
        res += 'MEM_SVM_FINE_GRAIN_BUFFER+';
        left_val := left_val and not MEM_SVM_FINE_GRAIN_BUFFER.val;
      end;
      if MEM_SVM_ATOMICS in self then
      begin
        res += 'MEM_SVM_ATOMICS+';
        left_val := left_val and not MEM_SVM_ATOMICS.val;
      end;
      if MEM_KERNEL_READ_AND_WRITE in self then
      begin
        res += 'MEM_KERNEL_READ_AND_WRITE+';
        left_val := left_val and not MEM_KERNEL_READ_AND_WRITE.val;
      end;
      if left_val<>0 then
      begin
        res += 'clSvmMemFlags[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clUnifiedSharedMemoryType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MEM_TYPE_UNKNOWN: clUnifiedSharedMemoryType read new clUnifiedSharedMemoryType($4196);
    public static property MEM_TYPE_HOST:    clUnifiedSharedMemoryType read new clUnifiedSharedMemoryType($4197);
    public static property MEM_TYPE_DEVICE:  clUnifiedSharedMemoryType read new clUnifiedSharedMemoryType($4198);
    public static property MEM_TYPE_SHARED:  clUnifiedSharedMemoryType read new clUnifiedSharedMemoryType($4199);
    
    public function ToString: string; override;
    begin
      if MEM_TYPE_UNKNOWN = self then
        Result := 'MEM_TYPE_UNKNOWN' else
      if MEM_TYPE_HOST = self then
        Result := 'MEM_TYPE_HOST' else
      if MEM_TYPE_DEVICE = self then
        Result := 'MEM_TYPE_DEVICE' else
      if MEM_TYPE_SHARED = self then
        Result := 'MEM_TYPE_SHARED' else
        Result := $'clUnifiedSharedMemoryType[{self.val}]';
    end;
    
  end;
  
  ///
  clVaApiDeviceSet = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PREFERRED_DEVICES_FOR_VA_API: clVaApiDeviceSet read new clVaApiDeviceSet($4095);
    public static property ALL_DEVICES_FOR_VA_API:       clVaApiDeviceSet read new clVaApiDeviceSet($4096);
    
    public function ToString: string; override;
    begin
      if PREFERRED_DEVICES_FOR_VA_API = self then
        Result := 'PREFERRED_DEVICES_FOR_VA_API' else
      if ALL_DEVICES_FOR_VA_API = self then
        Result := 'ALL_DEVICES_FOR_VA_API' else
        Result := $'clVaApiDeviceSet[{self.val}]';
    end;
    
  end;
  
  ///
  clVaApiDeviceSource = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VA_API_DISPLAY: clVaApiDeviceSource read new clVaApiDeviceSource($4094);
    
    public function ToString: string; override;
    begin
      if VA_API_DISPLAY = self then
        Result := 'VA_API_DISPLAY' else
        Result := $'clVaApiDeviceSource[{self.val}]';
    end;
    
  end;
  
  ///
  clKernelExecInfoARM = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KERNEL_EXEC_INFO_SVM_PTRS_ARM:              clKernelExecInfoARM read new clKernelExecInfoARM($40B8);
    public static property KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM_ARM: clKernelExecInfoARM read new clKernelExecInfoARM($40B9);
    
    public function ToString: string; override;
    begin
      if KERNEL_EXEC_INFO_SVM_PTRS_ARM = self then
        Result := 'KERNEL_EXEC_INFO_SVM_PTRS_ARM' else
      if KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM_ARM = self then
        Result := 'KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM_ARM' else
        Result := $'clKernelExecInfoARM[{self.val}]';
    end;
    
  end;
  
  ///
  clDevicePartitionPropertyEXT = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property PARTITION_BY_COUNTS_LIST_END:            clDevicePartitionPropertyEXT read new clDevicePartitionPropertyEXT(0);
    public static property PROPERTIES_LIST_END:                     clDevicePartitionPropertyEXT read new clDevicePartitionPropertyEXT(0);
    public static property PARTITION_BY_NAMES_LIST_END:             clDevicePartitionPropertyEXT read new clDevicePartitionPropertyEXT(-1);
    public static property DEVICE_PARTITION_EQUALLY_EXT:            clDevicePartitionPropertyEXT read new clDevicePartitionPropertyEXT($4050);
    public static property DEVICE_PARTITION_BY_COUNTS_EXT:          clDevicePartitionPropertyEXT read new clDevicePartitionPropertyEXT($4051);
    public static property DEVICE_PARTITION_BY_NAMES:               clDevicePartitionPropertyEXT read new clDevicePartitionPropertyEXT($4052);
    public static property DEVICE_PARTITION_BY_AFFINITY_DOMAIN_EXT: clDevicePartitionPropertyEXT read new clDevicePartitionPropertyEXT($4053);
    
    public function ToString: string; override;
    begin
      if PARTITION_BY_COUNTS_LIST_END = self then
        Result := 'PARTITION_BY_COUNTS_LIST_END' else
      if PARTITION_BY_NAMES_LIST_END = self then
        Result := 'PARTITION_BY_NAMES_LIST_END' else
      if DEVICE_PARTITION_EQUALLY_EXT = self then
        Result := 'DEVICE_PARTITION_EQUALLY_EXT' else
      if DEVICE_PARTITION_BY_COUNTS_EXT = self then
        Result := 'DEVICE_PARTITION_BY_COUNTS_EXT' else
      if DEVICE_PARTITION_BY_NAMES = self then
        Result := 'DEVICE_PARTITION_BY_NAMES' else
      if DEVICE_PARTITION_BY_AFFINITY_DOMAIN_EXT = self then
        Result := 'DEVICE_PARTITION_BY_AFFINITY_DOMAIN_EXT' else
        Result := $'clDevicePartitionPropertyEXT[{self.val}]';
    end;
    
  end;
  
  ///
  clMemAllocFlagsINTEL = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MEM_ALLOC_WRITE_COMBINED:           clMemAllocFlagsINTEL read new clMemAllocFlagsINTEL(1 shl 0);
    public static property MEM_ALLOC_INITIAL_PLACEMENT_DEVICE: clMemAllocFlagsINTEL read new clMemAllocFlagsINTEL(1 shl 1);
    public static property MEM_ALLOC_INITIAL_PLACEMENT_HOST:   clMemAllocFlagsINTEL read new clMemAllocFlagsINTEL(1 shl 2);
    
    public static function operator+(v1, v2: clMemAllocFlagsINTEL) := new clMemAllocFlagsINTEL(v1.val or v2.val);
    public static function operator or(v1, v2: clMemAllocFlagsINTEL) := new clMemAllocFlagsINTEL(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clMemAllocFlagsINTEL; v2: clMemAllocFlagsINTEL) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clMemAllocFlagsINTEL) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clMemAllocFlagsINTEL[0]';
        exit;
      end;
      if MEM_ALLOC_WRITE_COMBINED in self then
      begin
        res += 'MEM_ALLOC_WRITE_COMBINED+';
        left_val := left_val and not MEM_ALLOC_WRITE_COMBINED.val;
      end;
      if MEM_ALLOC_INITIAL_PLACEMENT_DEVICE in self then
      begin
        res += 'MEM_ALLOC_INITIAL_PLACEMENT_DEVICE+';
        left_val := left_val and not MEM_ALLOC_INITIAL_PLACEMENT_DEVICE.val;
      end;
      if MEM_ALLOC_INITIAL_PLACEMENT_HOST in self then
      begin
        res += 'MEM_ALLOC_INITIAL_PLACEMENT_HOST+';
        left_val := left_val and not MEM_ALLOC_INITIAL_PLACEMENT_HOST.val;
      end;
      if left_val<>0 then
      begin
        res += 'clMemAllocFlagsINTEL[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clMemInfoINTEL = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MEM_ALLOC_BUFFER_LOCATION: clMemInfoINTEL read new clMemInfoINTEL($419E);
    
    public function ToString: string; override;
    begin
      if MEM_ALLOC_BUFFER_LOCATION = self then
        Result := 'MEM_ALLOC_BUFFER_LOCATION' else
        Result := $'clMemInfoINTEL[{self.val}]';
    end;
    
  end;
  
  ///
  clMemPropertiesINTEL = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MEM_ALLOC_FLAGS_INTEL:     clMemPropertiesINTEL read new clMemPropertiesINTEL($4195);
    public static property MEM_ALLOC_BUFFER_LOCATION: clMemPropertiesINTEL read new clMemPropertiesINTEL($419E);
    public static property MEM_CHANNEL:               clMemPropertiesINTEL read new clMemPropertiesINTEL($4213);
    
    public function ToString: string; override;
    begin
      if MEM_ALLOC_FLAGS_INTEL = self then
        Result := 'MEM_ALLOC_FLAGS_INTEL' else
      if MEM_ALLOC_BUFFER_LOCATION = self then
        Result := 'MEM_ALLOC_BUFFER_LOCATION' else
      if MEM_CHANNEL = self then
        Result := 'MEM_CHANNEL' else
        Result := $'clMemPropertiesINTEL[{self.val}]';
    end;
    
  end;
  
  ///%cl_accelerator%
  cl_accelerator = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_accelerator read default(cl_accelerator);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_accelerator[{self.val}]';
    
  end;
  
  ///%cl_command_buffer%
  cl_command_buffer = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_command_buffer read default(cl_command_buffer);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_command_buffer[{self.val}]';
    
  end;
  
  ///%cl_command_queue%
  cl_command_queue = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_command_queue read default(cl_command_queue);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_command_queue[{self.val}]';
    
  end;
  
  ///%cl_context%
  cl_context = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_context read default(cl_context);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_context[{self.val}]';
    
  end;
  
  ///%cl_device_id%
  cl_device_id = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_device_id read default(cl_device_id);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_device_id[{self.val}]';
    
  end;
  
  ///%cl_eglDisplay%
  cl_eglDisplay = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_eglDisplay read default(cl_eglDisplay);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_eglDisplay[{self.val}]';
    
  end;
  
  ///%cl_eglImage%
  cl_eglImage = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_eglImage read default(cl_eglImage);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_eglImage[{self.val}]';
    
  end;
  
  ///%cl_eglSync%
  cl_eglSync = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_eglSync read default(cl_eglSync);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_eglSync[{self.val}]';
    
  end;
  
  ///%cl_event%
  cl_event = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_event read default(cl_event);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_event[{self.val}]';
    
  end;
  
  ///%cl_GLsync%
  cl_GLsync = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_GLsync read default(cl_GLsync);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_GLsync[{self.val}]';
    
  end;
  
  ///%cl_icd_dispatch%
  cl_icd_dispatch = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_icd_dispatch read default(cl_icd_dispatch);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_icd_dispatch[{self.val}]';
    
  end;
  
  ///%cl_kernel%
  cl_kernel = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_kernel read default(cl_kernel);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_kernel[{self.val}]';
    
  end;
  
  ///%cl_mem%
  cl_mem = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_mem read default(cl_mem);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_mem[{self.val}]';
    
  end;
  
  ///%cl_mutable_command%
  cl_mutable_command = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_mutable_command read default(cl_mutable_command);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_mutable_command[{self.val}]';
    
  end;
  
  ///%cl_platform_id%
  cl_platform_id = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_platform_id read default(cl_platform_id);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_platform_id[{self.val}]';
    
  end;
  
  ///%cl_program%
  cl_program = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_program read default(cl_program);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_program[{self.val}]';
    
  end;
  
  ///%cl_sampler%
  cl_sampler = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_sampler read default(cl_sampler);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_sampler[{self.val}]';
    
  end;
  
  ///%cl_semaphore%
  cl_semaphore = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_semaphore read default(cl_semaphore);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_semaphore[{self.val}]';
    
  end;
  
  ///%va_image_format%
  va_image_format = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: va_image_format read default(va_image_format);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'va_image_format[{self.val}]';
    
  end;
  
  ///%va_surface_id%
  va_surface_id = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: va_surface_id read default(va_surface_id);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'va_surface_id[{self.val}]';
    
  end;
  
  ///%d3d_pixel_format%
  d3d_pixel_format = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: d3d_pixel_format read default(d3d_pixel_format);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'d3d_pixel_format[{self.val}]';
    
  end;
  
  ///%d3d_surface9%
  d3d_surface9 = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: d3d_surface9 read default(d3d_surface9);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'d3d_surface9[{self.val}]';
    
  end;
  
  ///%d3d10_buffer%
  d3d10_buffer = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: d3d10_buffer read default(d3d10_buffer);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'d3d10_buffer[{self.val}]';
    
  end;
  
  ///%d3d10_texture_2d%
  d3d10_texture_2d = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: d3d10_texture_2d read default(d3d10_texture_2d);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'d3d10_texture_2d[{self.val}]';
    
  end;
  
  ///%d3d10_texture_3d%
  d3d10_texture_3d = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: d3d10_texture_3d read default(d3d10_texture_3d);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'d3d10_texture_3d[{self.val}]';
    
  end;
  
  ///%d3d11_buffer%
  d3d11_buffer = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: d3d11_buffer read default(d3d11_buffer);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'d3d11_buffer[{self.val}]';
    
  end;
  
  ///%d3d11_texture_2d%
  d3d11_texture_2d = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: d3d11_texture_2d read default(d3d11_texture_2d);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'d3d11_texture_2d[{self.val}]';
    
  end;
  
  ///%d3d11_texture_3d%
  d3d11_texture_3d = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: d3d11_texture_3d read default(d3d11_texture_3d);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'d3d11_texture_3d[{self.val}]';
    
  end;
  
  [StructLayout(LayoutKind.Explicit, Size = 64)]
  ///
  value_ansi_string_64 = record
    
    public property AnsiChars[i: integer]: Byte
      read Marshal.ReadByte(new IntPtr(@self), i)
      write Marshal.WriteByte(new IntPtr(@self), i, value); default;
    public property Chars[i: integer]: char read char(AnsiChars[i]) write AnsiChars[i] := Byte(value);
    
    public constructor(s: string; allow_trim: boolean := false);
    begin
      var len := s.Length;
      if len>63 then
        if allow_trim then
          len := 63 else
          raise new System.OverflowException;
      
      self.AnsiChars[len] := 0;
      for var i := 0 to len-1 do
        self.Chars[i] := s[i];
      
    end;
    
    public function ToString: string; override;
    begin
      var copy := self;
      Result := Marshal.PtrToStringAnsi(new IntPtr(@copy));
    end;
    
    public static function operator implicit(s: string): value_ansi_string_64 := new value_ansi_string_64(s);
    public static function operator explicit(s: string): value_ansi_string_64 := new value_ansi_string_64(s, true);
    
    public static function operator implicit(s: value_ansi_string_64): string := s.ToString;
    
  end;
  
  ///
  cl_buffer_region = record
    public origin: UIntPtr;
    public size: UIntPtr;
    
    public constructor(origin: UIntPtr; size: UIntPtr);
    begin
      self.origin := origin;
      self.size   := size;
    end;
    
  end;
  
  ///
  cl_device_integer_dot_product_acceleration_properties = record
    public signed_accelerated: clBool;
    public unsigned_accelerated: clBool;
    public mixed_signedness_accelerated: clBool;
    public accumulating_saturating_signed_accelerated: clBool;
    public accumulating_saturating_unsigned_accelerated: clBool;
    public accumulating_saturating_mixed_signedness_accelerated: clBool;
    
    public constructor(signed_accelerated: clBool; unsigned_accelerated: clBool; mixed_signedness_accelerated: clBool; accumulating_saturating_signed_accelerated: clBool; accumulating_saturating_unsigned_accelerated: clBool; accumulating_saturating_mixed_signedness_accelerated: clBool);
    begin
      self.signed_accelerated                                   := signed_accelerated;
      self.unsigned_accelerated                                 := unsigned_accelerated;
      self.mixed_signedness_accelerated                         := mixed_signedness_accelerated;
      self.accumulating_saturating_signed_accelerated           := accumulating_saturating_signed_accelerated;
      self.accumulating_saturating_unsigned_accelerated         := accumulating_saturating_unsigned_accelerated;
      self.accumulating_saturating_mixed_signedness_accelerated := accumulating_saturating_mixed_signedness_accelerated;
    end;
    
  end;
  
  ///
  cl_device_pci_bus_info = record
    public pci_domain: UInt32;
    public pci_bus: UInt32;
    public pci_device: UInt32;
    public pci_function: UInt32;
    
    public constructor(pci_domain: UInt32; pci_bus: UInt32; pci_device: UInt32; pci_function: UInt32);
    begin
      self.pci_domain   := pci_domain;
      self.pci_bus      := pci_bus;
      self.pci_device   := pci_device;
      self.pci_function := pci_function;
    end;
    
  end;
  
  ///
  cl_dx9_surface_info = record
    public resource: d3d_surface9;
    public shared_handle: IntPtr;
    
    public constructor(resource: d3d_surface9; shared_handle: IntPtr);
    begin
      self.resource      := resource;
      self.shared_handle := shared_handle;
    end;
    
  end;
  
  ///
  cl_image_desc = record
    public image_type: clMemObjectType;
    public image_width: UIntPtr;
    public image_height: UIntPtr;
    public image_depth: UIntPtr;
    public image_array_size: UIntPtr;
    public image_row_pitch: UIntPtr;
    public image_slice_pitch: UIntPtr;
    public num_mip_levels: UInt32;
    public num_samples: UInt32;
    public mem_object: cl_mem;
    
    public constructor(image_type: clMemObjectType; image_width: UIntPtr; image_height: UIntPtr; image_depth: UIntPtr; image_array_size: UIntPtr; image_row_pitch: UIntPtr; image_slice_pitch: UIntPtr; num_mip_levels: UInt32; num_samples: UInt32; mem_object: cl_mem);
    begin
      self.image_type        := image_type;
      self.image_width       := image_width;
      self.image_height      := image_height;
      self.image_depth       := image_depth;
      self.image_array_size  := image_array_size;
      self.image_row_pitch   := image_row_pitch;
      self.image_slice_pitch := image_slice_pitch;
      self.num_mip_levels    := num_mip_levels;
      self.num_samples       := num_samples;
      self.mem_object        := mem_object;
    end;
    
  end;
  
  ///
  cl_image_format = record
    public image_channel_order: clChannelOrder;
    public image_channel_data_type: clChannelType;
    
    public constructor(image_channel_order: clChannelOrder; image_channel_data_type: clChannelType);
    begin
      self.image_channel_order     := image_channel_order;
      self.image_channel_data_type := image_channel_data_type;
    end;
    
  end;
  
  ///
  cl_mem_ext_host_ptr = record
    public allocation_type: clAllocationType;
    public host_cache_policy: clHostCachePolicy;
    
    public constructor(allocation_type: clAllocationType; host_cache_policy: clHostCachePolicy);
    begin
      self.allocation_type   := allocation_type;
      self.host_cache_policy := host_cache_policy;
    end;
    
  end;
  
  ///
  cl_mem_android_native_buffer_host_ptr = record
    public ext_host_ptr: cl_mem_ext_host_ptr;
    public anb_ptr: IntPtr;
    
    public constructor(ext_host_ptr: cl_mem_ext_host_ptr; anb_ptr: IntPtr);
    begin
      self.ext_host_ptr := ext_host_ptr;
      self.anb_ptr      := anb_ptr;
    end;
    
  end;
  
  ///
  cl_mem_ion_host_ptr = record
    public ext_host_ptr: cl_mem_ext_host_ptr;
    public ion_filedesc: Int32;
    public ion_hostptr: IntPtr;
    
    public constructor(ext_host_ptr: cl_mem_ext_host_ptr; ion_filedesc: Int32; ion_hostptr: IntPtr);
    begin
      self.ext_host_ptr := ext_host_ptr;
      self.ion_filedesc := ion_filedesc;
      self.ion_hostptr  := ion_hostptr;
    end;
    
  end;
  
  ///
  cl_motion_estimation_desc = record
    public mb_block_type: clMbBlockType;
    public subpixel_mode: clSubpixelMode;
    public sad_adjust_mode: clSadAdjustMode;
    public search_path_type: clSearchPathType;
    
    public constructor(mb_block_type: clMbBlockType; subpixel_mode: clSubpixelMode; sad_adjust_mode: clSadAdjustMode; search_path_type: clSearchPathType);
    begin
      self.mb_block_type    := mb_block_type;
      self.subpixel_mode    := subpixel_mode;
      self.sad_adjust_mode  := sad_adjust_mode;
      self.search_path_type := search_path_type;
    end;
    
  end;
  
  ///
  cl_mutable_dispatch_arg = record
    public arg_index: UInt32;
    public arg_size: UIntPtr;
    public arg_value: IntPtr;
    
    public constructor(arg_index: UInt32; arg_size: UIntPtr; arg_value: IntPtr);
    begin
      self.arg_index := arg_index;
      self.arg_size  := arg_size;
      self.arg_value := arg_value;
    end;
    
  end;
  
  ///
  cl_mutable_dispatch_exec_info = record
    public param_name: UInt32;
    public param_value_size: UIntPtr;
    public param_value: IntPtr;
    
    public constructor(param_name: UInt32; param_value_size: UIntPtr; param_value: IntPtr);
    begin
      self.param_name       := param_name;
      self.param_value_size := param_value_size;
      self.param_value      := param_value;
    end;
    
  end;
  
  ///
  cl_mutable_dispatch_config = record
    public &type: clCommandBufferStructureType;
    public next: IntPtr;
    public command: cl_mutable_command;
    public num_args: UInt32;
    public num_svm_args: UInt32;
    public num_exec_infos: UInt32;
    public work_dim: UInt32;
    public arg_list: ^cl_mutable_dispatch_arg;
    public arg_svm_list: ^cl_mutable_dispatch_arg;
    public exec_info_list: ^cl_mutable_dispatch_exec_info;
    public global_work_offset: ^UIntPtr;
    public global_work_size: ^UIntPtr;
    public local_work_size: ^UIntPtr;
    
    public constructor(&type: clCommandBufferStructureType; next: IntPtr; command: cl_mutable_command; num_args: UInt32; num_svm_args: UInt32; num_exec_infos: UInt32; work_dim: UInt32; arg_list: ^cl_mutable_dispatch_arg; arg_svm_list: ^cl_mutable_dispatch_arg; exec_info_list: ^cl_mutable_dispatch_exec_info; global_work_offset: ^UIntPtr; global_work_size: ^UIntPtr; local_work_size: ^UIntPtr);
    begin
      self.type               := &type;
      self.next               := next;
      self.command            := command;
      self.num_args           := num_args;
      self.num_svm_args       := num_svm_args;
      self.num_exec_infos     := num_exec_infos;
      self.work_dim           := work_dim;
      self.arg_list           := arg_list;
      self.arg_svm_list       := arg_svm_list;
      self.exec_info_list     := exec_info_list;
      self.global_work_offset := global_work_offset;
      self.global_work_size   := global_work_size;
      self.local_work_size    := local_work_size;
    end;
    
  end;
  
  ///
  cl_mutable_base_config = record
    public &type: clCommandBufferStructureType;
    public next: IntPtr;
    public num_mutable_dispatch: UInt32;
    public mutable_dispatch_list: ^cl_mutable_dispatch_config;
    
    public constructor(&type: clCommandBufferStructureType; next: IntPtr; num_mutable_dispatch: UInt32; mutable_dispatch_list: ^cl_mutable_dispatch_config);
    begin
      self.type                  := &type;
      self.next                  := next;
      self.num_mutable_dispatch  := num_mutable_dispatch;
      self.mutable_dispatch_list := mutable_dispatch_list;
    end;
    
  end;
  
  ///
  cl_name_version = record
    public version: UInt32;
    public name: value_ansi_string_64;
    
    public constructor(version: UInt32; name: value_ansi_string_64);
    begin
      self.version := version;
      self.name    := name;
    end;
    
    public function ToString: string; override;
      const v_major_bits = 10;
      const v_minor_bits = 10;
      const v_patch_bits = 12;
    begin
      var sb := new StringBuilder;
      sb += '(';
      
      sb += 'v=';
      sb.Append(version shr (v_minor_bits+v_patch_bits));
      sb += '.';
      sb.Append(version shr v_patch_bits and (1 shl v_minor_bits - 1));
      sb += ':';
      sb.Append(version and (1 shl v_patch_bits - 1));
      
      sb += ' name="';
      sb += name.ToString;
      sb += '"';
      
      sb += ')';
      Result := sb.ToString;
    end;
    
  end;
  
  ///
  cl_queue_family_properties = record
    public properties: clCommandQueueProperties;
    public capabilities: clCommandQueueCapabilities;
    public count: UInt32;
    public name: value_ansi_string_64;
    
    public constructor(properties: clCommandQueueProperties; capabilities: clCommandQueueCapabilities; count: UInt32; name: value_ansi_string_64);
    begin
      self.properties   := properties;
      self.capabilities := capabilities;
      self.count        := count;
      self.name         := name;
    end;
    
  end;
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  ///
  clContextDestructorCallback = procedure(context: cl_context; user_data: IntPtr);
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  ///
  clCreateContextCallback = procedure(errinfo: string; private_info: IntPtr; cb: UIntPtr; user_data: IntPtr);
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  ///
  clEnqueueNativeKernelCallback = procedure(user_data: IntPtr);
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  ///
  clEnqueueSVMFreeCallback = procedure(queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: ^IntPtr; user_data: IntPtr);
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  ///
  clEventCallback = procedure(&event: cl_event; event_command_status: clCommandExecutionStatus; user_data: IntPtr);
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  ///
  clMemObjectDestructorCallback = procedure(memobj: cl_mem; user_data: IntPtr);
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  ///
  clProgramCallback = procedure(&program: cl_program; user_data: IntPtr);
  
  
  