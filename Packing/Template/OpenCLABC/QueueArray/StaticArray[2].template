  
  
  
  {$region Common}
  
  CommandQueueArray2WithWork<TInp1,TInp2,TRes, TDelegate> = abstract class(CommandQueue<TRes>)  where TDelegate: ISimpleDelegateContainer;
    protected q1: CommandQueue<TInp1>;
    protected q2: CommandQueue<TInp2>;
    protected d: TDelegate;
    
    public constructor(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; d: TDelegate);
    begin
      self.q1 := q1;
      self.q2 := q2;
      self.d := d;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override :=
    begin
      q1.InitBeforeInvoke(g, inited_hubs);
      q2.InitBeforeInvoke(g, inited_hubs);
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      q1.ToString(sb, tabs, index, delayed);
      q2.ToString(sb, tabs, index, delayed);
      sb.Append(#9, tabs);
      d.ToStringB(sb);
      sb += #10;
    end;
    
  end;
  
  ISimpleFunc2Container<TInp1,TInp2,TRes> = interface(ISimpleDelegateContainer)
    
    function Invoke(inp1: TInp1; inp2: TInp2; c: CLContext): TRes;
    
  end;
  
  SimpleFunc2Container<TInp1,TInp2,TRes> = record(ISimpleFunc2Container<TInp1,TInp2,TRes>)
    private d: (TInp1,TInp2)->TRes;
    
    public static function operator implicit(d: (TInp1,TInp2)->TRes): SimpleFunc2Container<TInp1,TInp2,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp1: TInp1; inp2: TInp2; c: CLContext) := d(inp1,inp2);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleFunc2ContainerC<TInp1,TInp2,TRes> = record(ISimpleFunc2Container<TInp1,TInp2,TRes>)
    private d: (TInp1,TInp2, CLContext)->TRes;
    
    public static function operator implicit(d: (TInp1,TInp2, CLContext)->TRes): SimpleFunc2ContainerC<TInp1,TInp2,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp1: TInp1; inp2: TInp2; c: CLContext) := d(inp1,inp2,c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  ISimpleProc2Container<TInp1,TInp2> = interface(ISimpleDelegateContainer)
    
    procedure Invoke(inp1: TInp1; inp2: TInp2; c: CLContext);
    
  end;
  
  SimpleProc2Container<TInp1,TInp2> = record(ISimpleProc2Container<TInp1,TInp2>)
    private d: (TInp1,TInp2)->();
    
    public static function operator implicit(d: (TInp1,TInp2)->()): SimpleProc2Container<TInp1,TInp2>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp1: TInp1; inp2: TInp2; c: CLContext) := d(inp1,inp2);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleProc2ContainerC<TInp1,TInp2> = record(ISimpleProc2Container<TInp1,TInp2>)
    private d: (TInp1,TInp2, CLContext)->();
    
    public static function operator implicit(d: (TInp1,TInp2, CLContext)->()): SimpleProc2ContainerC<TInp1,TInp2>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp1: TInp1; inp2: TInp2; c: CLContext) := d(inp1,inp2,c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  {$endregion Common}
  
  {$region Invokers}
  
  QueueArray2InvokerData<TInp1,TInp2> = record
    public all_qrs_const := true;
    public next_l: CLTaskLocalData;
    public qr1: QueueRes<TInp1>;
    public qr2: QueueRes<TInp2>;
  end;
  
  IQueueArray2Invoker = interface
    
    function Invoke<TInp1,TInp2>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray2InvokerData<TInp1,TInp2>;
    
  end;
  
  QueueArray2SyncInvoker = record(IQueueArray2Invoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TInp1,TInp2>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray2InvokerData<TInp1,TInp2>;
    begin
      
      Result.qr1 := q1.InvokeToAny(g, l);
      if not Result.qr1.IsConst then Result.all_qrs_const := false;
      l := Result.qr1.TakeBaseOut;
      
      Result.qr2 := q2.InvokeToAny(g, l);
      if not Result.qr2.IsConst then Result.all_qrs_const := false;
      l := Result.qr2.TakeBaseOut;
      
      Result.next_l := l;
    end;
    
  end;
  
  QueueArray2AsyncInvoker = record(IQueueArray2Invoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TInp1,TInp2>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray2InvokerData<TInp1,TInp2>;
    begin
      
      var res: QueueArray2InvokerData<TInp1,TInp2>;
      g.ParallelInvoke(l, 2, invoker->
      begin
        res.qr1 := invoker.InvokeBranch(q1.InvokeToAny);
        res.qr2 := invoker.InvokeBranch(q2.InvokeToAny);
      end);
      Result := res;
      
      Result.all_qrs_const := Result.qr1.IsConst and Result.qr2.IsConst;
      Result.next_l := new CLTaskLocalData(EventList.Combine(|Result.qr1.AttachInvokeActions(g), Result.qr2.AttachInvokeActions(g)|));
    end;
    
  end;
  
  {$endregion Invokers}
  
  {$region Work}
  
  IQueueArray2Work<TInp1,TInp2,TRes, TDelegate> = interface
  where TDelegate: ISimpleDelegateContainer;
    
    function Invoke(d: TDelegate; err_handler: CLTaskErrHandler; inp1: TInp1; inp2: TInp2; c: CLContext): TRes;
    
  end;
  
  QueueArray2WorkConvert<TInp1,TInp2,TRes, TFunc> = record(IQueueArray2Work<TInp1,TInp2,TRes, TFunc>)
  where TFunc: ISimpleFunc2Container<TInp1,TInp2,TRes>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(f: TFunc; err_handler: CLTaskErrHandler; inp1: TInp1; inp2: TInp2; c: CLContext): TRes;
    begin
      if err_handler.HadError then exit;
      try
        Result := f.Invoke(inp1,inp2, c);
      except
        on e: Exception do err_handler.AddErr(e)
      end;
    end;
    
  end;
  
  QueueArray2WorkUse<TInp1,TInp2, TProc> = record(IQueueArray2Work<TInp1,TInp2,ValueTuple<TInp1,TInp2>, TProc>)
  where TProc: ISimpleProc2Container<TInp1,TInp2>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(p: TProc; err_handler: CLTaskErrHandler; inp1: TInp1; inp2: TInp2; c: CLContext): ValueTuple<TInp1,TInp2>;
    begin
      if err_handler.HadError then exit;
      try
        p.Invoke(inp1,inp2, c);
        Result := ValueTuple.Create(inp1,inp2);
      except
        on e: Exception do err_handler.AddErr(e)
      end;
    end;
    
  end;
  
  {$endregion Work}
  
  {$region Quick}
  
  CommandQueueQuickArray2<TInp1,TInp2,TRes, TInv, TDelegate, TWork, FPreCall> = sealed class(CommandQueueArray2WithWork<TInp1,TInp2,TRes, TDelegate>)
  where TInv: IQueueArray2Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray2Work<TInp1,TInp2,TRes, TDelegate>, constructor;
  where FPreCall: IBooleanFlag, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; factory: IQueueResDirectFactory<TRes,TR>): TR; where TR: IQueueRes;
    begin
      var inv_data := TInv.Create.Invoke(q1,q2, g, l);
      l := inv_data.next_l;
      
      var should_make_const := if FPreCall.Create.val then
        inv_data.all_qrs_const else
        l.ShouldInstaCallAction;
      
      var err_handler := g.curr_err_handler;
      var qr1 := inv_data.qr1;
      var qr2 := inv_data.qr2;
      Result := if should_make_const then
        factory.MakeConst(l, TWork.Create.Invoke(d,
          err_handler, qr1.GetResDirect,qr2.GetResDirect, g.c
        )) else
        factory.MakeDelayed(l, qr->c->qr.SetRes(TWork.Create.Invoke(d,
          err_handler, qr1.GetResDirect,qr2.GetResDirect, c
        )));
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory);
    
  end;
  
  CommandQueueConvertQuickArray2<TInp1,TInp2,TRes, TInv, TFunc, FPreCall> = CommandQueueQuickArray2<TInp1,TInp2,TRes, TInv, TFunc, QueueArray2WorkConvert<TInp1,TInp2,TRes, TFunc>, FPreCall>;
  CommandQueueUseQuickArray2    <TInp1,TInp2,      TInv, TProc, FPreCall> = CommandQueueQuickArray2<TInp1,TInp2,ValueTuple<TInp1,TInp2>, TInv, TProc, QueueArray2WorkUse<TInp1,TInp2, TProc>, FPreCall>;
  
  {$endregion Quick}
  
  {$region Threaded}
  
  DCommandQueueThreadedArray2MakeBody<TInp1,TInp2, TR> = function(acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; err_handler: CLTaskErrHandler; c: CLContext; own_qr: TR): Action;
  CommandQueueThreadedArray2<TInp1,TInp2,TRes, TInv, TDelegate, TWork> = sealed class(CommandQueueArray2WithWork<TInp1,TInp2,TRes, TDelegate>)
  where TInv: IQueueArray2Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray2Work<TInp1,TInp2,TRes, TDelegate>, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeNilBody    (acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; err_handler: CLTaskErrHandler; c: CLContext; own_qr: QueueResNil): Action;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        TWork.Create.Invoke(d, err_handler, qr1.GetResDirect, qr2.GetResDirect, c);
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeResBody<TR>(acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; err_handler: CLTaskErrHandler; c: CLContext; own_qr: TR): Action; where TR: QueueRes<TRes>;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        own_qr.SetRes(TWork.Create.Invoke(d, err_handler, qr1.GetResDirect, qr2.GetResDirect, c));
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; make_qr: Func<TR,CLTaskLocalData>->TR; make_body: DCommandQueueThreadedArray2MakeBody<TInp1,TInp2, TR>): TR; where TR: IQueueRes;
    begin
      var inv_data := TInv.Create.Invoke(q1,q2, g, l);
      l := inv_data.next_l;
      
      var prev_ev := l.prev_ev;
      var acts := l.prev_delegate;
      var qr1 := inv_data.qr1;
      var qr2 := inv_data.qr2;
      Result := make_qr(qr->new CLTaskLocalData(UserEvent.StartWorkThread(
        prev_ev, make_body(acts, qr1,qr2, g.curr_err_handler, g.c, qr), g.cl_c
        {$ifdef EventDebug}, $'body of {TypeName(self)}'{$endif}
      )));
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory.MakeDelayed, MakeNilBody);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory.MakeDelayed, MakeResBody&<QueueResValDirect<TRes>>);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory.MakeDelayed, MakeResBody&<QueueResPtr<TRes>>);
    
  end;
  
  CommandQueueConvertThreadedArray2<TInp1,TInp2,TRes, TInv, TFunc> = CommandQueueThreadedArray2<TInp1,TInp2,TRes, TInv, TFunc, QueueArray2WorkConvert<TInp1,TInp2,TRes, TFunc>>;
  CommandQueueUseThreadedArray2    <TInp1,TInp2,      TInv, TProc> = CommandQueueThreadedArray2<TInp1,TInp2,ValueTuple<TInp1,TInp2>, TInv, TProc, QueueArray2WorkUse<TInp1,TInp2, TProc>>;
  
  {$endregion Threaded}
  
  
  