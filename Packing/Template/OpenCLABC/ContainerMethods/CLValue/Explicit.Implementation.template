


{$region 1#Write&Read}

{$region WriteValue}

type
  CLValueCommandWriteValue<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private val := new NativeValueArea<&T>(true);
    
    protected procedure Finalize; override;
    begin
      val.Release;
    end;
    
    public function EnqEvCapacity: integer; override := 0;
    
    public constructor(val: &T);
    begin
      self.val.Value := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLValue<T>>; override;
    begin
      
      Result := (o, cq, evs)->
      begin
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(Marshal.SizeOf(default(T))),
          val.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      sb.Append(val.Value);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenWriteValue(val: &T): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandWriteValue<T>(val));
end;

{$endregion WriteValue}

{$region WriteValue!Q}

type
  CLValueCommandWriteValueQ<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private val: CommandQueue<&T>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(val: CommandQueue<&T>);
    begin
      self.val := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLValue<T>>; override;
    begin
      var val_qr: QueueResPtr<&T>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        val_qr := invoker.InvokeBranch&<QueueResPtr<&T>>(val.InvokeToPtr); enq_evs.AddL2(val_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var val := val_qr.GetResPtrDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(Marshal.SizeOf(default(T))),
          new IntPtr(val),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenWriteValue(val: CommandQueue<&T>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandWriteValueQ<T>(val));
end;

{$endregion WriteValue!Q}

{$region WriteNativeValueArea}

type
  CLValueCommandWriteNativeValueArea<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValueArea<&T>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeValueArea<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLValue<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<&T>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValueArea<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, native_data.ByteSize,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenWriteNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandWriteNativeValueArea<T>(native_data));
end;

{$endregion WriteNativeValueArea}

{$region WriteNativeValue}

type
  CLValueCommandWriteNativeValue<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValue<&T>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeValue<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLValue<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<&T>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValue<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, native_data.Area.ByteSize,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenWriteNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandWriteNativeValue<T>(native_data));
end;

{$endregion WriteNativeValue}

{$region ReadNativeValueArea}

type
  CLValueCommandReadNativeValueArea<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValueArea<&T>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeValueArea<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLValue<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<&T>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValueArea<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, native_data.ByteSize,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenReadNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandReadNativeValueArea<T>(native_data));
end;

{$endregion ReadNativeValueArea}

{$region ReadNativeValue}

type
  CLValueCommandReadNativeValue<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValue<&T>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeValue<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLValue<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<&T>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValue<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, native_data.Area.ByteSize,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenReadNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandReadNativeValue<T>(native_data));
end;

{$endregion ReadNativeValue}

{$endregion 1#Write&Read}

{$region 3#Copy}

{$region CopyTo!CLMemorySegment}

function CLValueCCQ<T>.ThenCopyTo(mem: CommandQueue<CLMemorySegment>): CLValueCCQ<T>;
begin
  Result := ThenCopyTo(mem, 0);
end;

{$endregion CopyTo!CLMemorySegment}

{$region CopyFrom!CLMemorySegment}

function CLValueCCQ<T>.ThenCopyFrom(mem: CommandQueue<CLMemorySegment>): CLValueCCQ<T>;
begin
  Result := ThenCopyFrom(mem, 0);
end;

{$endregion CopyFrom!CLMemorySegment}

{$region CopyTo}

type
  CLValueCommandCopyTo<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private        mem: CommandQueue<CLMemorySegment>;
    private mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(mem: CommandQueue<CLMemorySegment>; mem_offset: CommandQueue<integer>);
    begin
      self.       mem :=        mem;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
             mem.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLValue<T>>; override;
    begin
      var        mem_qr: QueueRes<CLMemorySegment>;
      var mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
               mem_qr := invoker.InvokeBranch&<QueueRes<CLMemorySegment>>(       mem.InvokeToAny); if mem_qr.IsConst then enq_evs.AddL2(mem_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_qr.AttachInvokeActions(g));
        mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var        mem :=        mem_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,mem.Native,
          UIntPtr.Zero,new UIntPtr(mem_offset),
          new UIntPtr(Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenCopyTo(mem: CommandQueue<CLMemorySegment>; mem_offset: CommandQueue<integer>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandCopyTo<T>(mem, mem_offset));
end;

{$endregion CopyTo}

{$region CopyFrom}

type
  CLValueCommandCopyFrom<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private        mem: CommandQueue<CLMemorySegment>;
    private mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(mem: CommandQueue<CLMemorySegment>; mem_offset: CommandQueue<integer>);
    begin
      self.       mem :=        mem;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
             mem.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLValue<T>>; override;
    begin
      var        mem_qr: QueueRes<CLMemorySegment>;
      var mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
               mem_qr := invoker.InvokeBranch&<QueueRes<CLMemorySegment>>(       mem.InvokeToAny); if mem_qr.IsConst then enq_evs.AddL2(mem_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_qr.AttachInvokeActions(g));
        mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var        mem :=        mem_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, mem.Native,o.Native,
          new UIntPtr(mem_offset),UIntPtr.Zero,
          new UIntPtr(Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenCopyFrom(mem: CommandQueue<CLMemorySegment>; mem_offset: CommandQueue<integer>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandCopyFrom<T>(mem, mem_offset));
end;

{$endregion CopyFrom}

{$region CopyTo!CLValue}

type
  CLValueCommandCopyToCLValue<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private val: CommandQueue<CLValue<&T>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(val: CommandQueue<CLValue<&T>>);
    begin
      self.val := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLValue<T>>; override;
    begin
      var val_qr: QueueRes<CLValue<&T>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        val_qr := invoker.InvokeBranch&<QueueRes<CLValue<&T>>>(val.InvokeToAny); if val_qr.IsConst then enq_evs.AddL2(val_qr.AttachInvokeActions(g)) else enq_evs.AddL1(val_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var val := val_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,val.Native,
          UIntPtr.Zero, UIntPtr.Zero,
          new UIntPtr(Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenCopyTo(val: CommandQueue<CLValue<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandCopyToCLValue<T>(val));
end;

{$endregion CopyTo!CLValue}

{$region CopyFrom!CLValue}

type
  CLValueCommandCopyFromCLValue<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private val: CommandQueue<CLValue<&T>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(val: CommandQueue<CLValue<&T>>);
    begin
      self.val := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLValue<T>>; override;
    begin
      var val_qr: QueueRes<CLValue<&T>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        val_qr := invoker.InvokeBranch&<QueueRes<CLValue<&T>>>(val.InvokeToAny); if val_qr.IsConst then enq_evs.AddL2(val_qr.AttachInvokeActions(g)) else enq_evs.AddL1(val_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var val := val_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, val.Native,o.Native,
          UIntPtr.Zero, UIntPtr.Zero,
          new UIntPtr(Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenCopyFrom(val: CommandQueue<CLValue<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandCopyFromCLValue<T>(val));
end;

{$endregion CopyFrom!CLValue}

{$endregion 3#Copy}


