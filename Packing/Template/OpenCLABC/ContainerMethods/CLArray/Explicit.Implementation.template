


{$region 1#Write&Read}

{$region WriteValue}

type
  CLArrayCommandWriteValue<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val := new NativeValueArea<&T>(true);
    private ind: CommandQueue<integer>;
    
    protected procedure Finalize; override;
    begin
      val.Release;
    end;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(val: &T; ind: CommandQueue<integer>);
    begin
      self.val.Value := val;
      self.ind       := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var ind := ind_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))), new UIntPtr(Marshal.SizeOf(default(T))),
          val.Pointer,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      sb.Append(val.Value);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteValue(val: &T; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteValue<T>(val, ind));
end;

{$endregion WriteValue}

{$region WriteValue!Q}

type
  CLArrayCommandWriteValueQ<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: CommandQueue<&T>;
    private ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(val: CommandQueue<&T>; ind: CommandQueue<integer>);
    begin
      self.val := val;
      self.ind := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var val_qr: QueueResPtr<&T>;
      var ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        val_qr := invoker.InvokeBranch&<QueueResPtr<&T>>(val.InvokeToPtr); enq_evs.AddL2(val_qr.AttachInvokeActions(g));
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var val := val_qr.GetResPtrDirect;
        var ind := ind_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))), new UIntPtr(Marshal.SizeOf(default(T))),
          val,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteValue(val: CommandQueue<&T>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteValueQ<T>(val, ind));
end;

{$endregion WriteValue!Q}

{$region WriteArray!AutoSize}

type
  CLArrayCommandWriteArrayAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array of &T>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(a: CommandQueue<array of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array of &T>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array of &T>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          a[0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteArray(a: CommandQueue<array of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteArrayAutoSize<T>(a));
end;

{$endregion WriteArray!AutoSize}

{$region WriteArray2!AutoSize}

type
  CLArrayCommandWriteArray2AutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array[,] of &T>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(a: CommandQueue<array[,] of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array[,] of &T>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array[,] of &T>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          a[0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteArray2(a: CommandQueue<array[,] of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteArray2AutoSize<T>(a));
end;

{$endregion WriteArray2!AutoSize}

{$region WriteArray3!AutoSize}

type
  CLArrayCommandWriteArray3AutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array[,,] of &T>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(a: CommandQueue<array[,,] of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array[,,] of &T>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array[,,] of &T>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          a[0,0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteArray3(a: CommandQueue<array[,,] of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteArray3AutoSize<T>(a));
end;

{$endregion WriteArray3!AutoSize}

{$region ReadArray!AutoSize}

type
  CLArrayCommandReadArrayAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array of &T>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(a: CommandQueue<array of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array of &T>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array of &T>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          a[0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadArray(a: CommandQueue<array of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadArrayAutoSize<T>(a));
end;

{$endregion ReadArray!AutoSize}

{$region ReadArray2!AutoSize}

type
  CLArrayCommandReadArray2AutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array[,] of &T>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(a: CommandQueue<array[,] of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array[,] of &T>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array[,] of &T>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          a[0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadArray2(a: CommandQueue<array[,] of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadArray2AutoSize<T>(a));
end;

{$endregion ReadArray2!AutoSize}

{$region ReadArray3!AutoSize}

type
  CLArrayCommandReadArray3AutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array[,,] of &T>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(a: CommandQueue<array[,,] of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array[,,] of &T>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array[,,] of &T>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          a[0,0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadArray3(a: CommandQueue<array[,,] of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadArray3AutoSize<T>(a));
end;

{$endregion ReadArray3!AutoSize}

{$region WriteArray}

type
  CLArrayCommandWriteArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private     a: CommandQueue<array of &T>;
    private a_ind: CommandQueue<integer>;
    private   len: CommandQueue<integer>;
    private   ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 4;
    
    public constructor(a: CommandQueue<array of &T>; a_ind, len, ind: CommandQueue<integer>);
    begin
      self.    a :=     a;
      self.a_ind := a_ind;
      self.  len :=   len;
      self.  ind :=   ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
          a.InitBeforeInvoke(g, prev_hubs);
      a_ind.InitBeforeInvoke(g, prev_hubs);
        len.InitBeforeInvoke(g, prev_hubs);
        ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var     a_qr: QueueRes<array of &T>;
      var a_ind_qr: QueueRes<integer>;
      var   len_qr: QueueRes<integer>;
      var   ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
            a_qr := invoker.InvokeBranch&<QueueRes<array of &T>>(    a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
        a_ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(a_ind.InvokeToAny); if a_ind_qr.IsConst then enq_evs.AddL2(a_ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind_qr.AttachInvokeActions(g));
          len_qr := invoker.InvokeBranch&<QueueRes<integer>>(  len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
          ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(  ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var     a :=     a_qr.GetResDirect;
        var a_ind := a_ind_qr.GetResDirect;
        var   len :=   len_qr.GetResDirect;
        var   ind :=   ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))), new UIntPtr(len * Marshal.SizeOf(default(T))),
          a[a_ind],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind:';
      sb += ' ';
      a_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteArray(a: CommandQueue<array of &T>; a_ind, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteArray<T>(a, a_ind, len, ind));
end;

{$endregion WriteArray}

{$region WriteArray2}

type
  CLArrayCommandWriteArray2<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private      a: CommandQueue<array[,] of &T>;
    private a_ind1: CommandQueue<integer>;
    private a_ind2: CommandQueue<integer>;
    private    len: CommandQueue<integer>;
    private    ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 5;
    
    public constructor(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, len, ind: CommandQueue<integer>);
    begin
      self.     a :=      a;
      self.a_ind1 := a_ind1;
      self.a_ind2 := a_ind2;
      self.   len :=    len;
      self.   ind :=    ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
           a.InitBeforeInvoke(g, prev_hubs);
      a_ind1.InitBeforeInvoke(g, prev_hubs);
      a_ind2.InitBeforeInvoke(g, prev_hubs);
         len.InitBeforeInvoke(g, prev_hubs);
         ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var      a_qr: QueueRes<array[,] of &T>;
      var a_ind1_qr: QueueRes<integer>;
      var a_ind2_qr: QueueRes<integer>;
      var    len_qr: QueueRes<integer>;
      var    ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
             a_qr := invoker.InvokeBranch&<QueueRes<array[,] of &T>>(     a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
        a_ind1_qr := invoker.InvokeBranch&<QueueRes<integer>>(a_ind1.InvokeToAny); if a_ind1_qr.IsConst then enq_evs.AddL2(a_ind1_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind1_qr.AttachInvokeActions(g));
        a_ind2_qr := invoker.InvokeBranch&<QueueRes<integer>>(a_ind2.InvokeToAny); if a_ind2_qr.IsConst then enq_evs.AddL2(a_ind2_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind2_qr.AttachInvokeActions(g));
           len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
           ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(   ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var      a :=      a_qr.GetResDirect;
        var a_ind1 := a_ind1_qr.GetResDirect;
        var a_ind2 := a_ind2_qr.GetResDirect;
        var    len :=    len_qr.GetResDirect;
        var    ind :=    ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))), new UIntPtr(len * Marshal.SizeOf(default(T))),
          a[a_ind1,a_ind2],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteArray2(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteArray2<T>(a, a_ind1, a_ind2, len, ind));
end;

{$endregion WriteArray2}

{$region WriteArray3}

type
  CLArrayCommandWriteArray3<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private      a: CommandQueue<array[,,] of &T>;
    private a_ind1: CommandQueue<integer>;
    private a_ind2: CommandQueue<integer>;
    private a_ind3: CommandQueue<integer>;
    private    len: CommandQueue<integer>;
    private    ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 6;
    
    public constructor(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, len, ind: CommandQueue<integer>);
    begin
      self.     a :=      a;
      self.a_ind1 := a_ind1;
      self.a_ind2 := a_ind2;
      self.a_ind3 := a_ind3;
      self.   len :=    len;
      self.   ind :=    ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
           a.InitBeforeInvoke(g, prev_hubs);
      a_ind1.InitBeforeInvoke(g, prev_hubs);
      a_ind2.InitBeforeInvoke(g, prev_hubs);
      a_ind3.InitBeforeInvoke(g, prev_hubs);
         len.InitBeforeInvoke(g, prev_hubs);
         ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var      a_qr: QueueRes<array[,,] of &T>;
      var a_ind1_qr: QueueRes<integer>;
      var a_ind2_qr: QueueRes<integer>;
      var a_ind3_qr: QueueRes<integer>;
      var    len_qr: QueueRes<integer>;
      var    ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
             a_qr := invoker.InvokeBranch&<QueueRes<array[,,] of &T>>(     a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
        a_ind1_qr := invoker.InvokeBranch&<QueueRes<integer>>(a_ind1.InvokeToAny); if a_ind1_qr.IsConst then enq_evs.AddL2(a_ind1_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind1_qr.AttachInvokeActions(g));
        a_ind2_qr := invoker.InvokeBranch&<QueueRes<integer>>(a_ind2.InvokeToAny); if a_ind2_qr.IsConst then enq_evs.AddL2(a_ind2_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind2_qr.AttachInvokeActions(g));
        a_ind3_qr := invoker.InvokeBranch&<QueueRes<integer>>(a_ind3.InvokeToAny); if a_ind3_qr.IsConst then enq_evs.AddL2(a_ind3_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind3_qr.AttachInvokeActions(g));
           len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
           ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(   ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var      a :=      a_qr.GetResDirect;
        var a_ind1 := a_ind1_qr.GetResDirect;
        var a_ind2 := a_ind2_qr.GetResDirect;
        var a_ind3 := a_ind3_qr.GetResDirect;
        var    len :=    len_qr.GetResDirect;
        var    ind :=    ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))), new UIntPtr(len * Marshal.SizeOf(default(T))),
          a[a_ind1,a_ind2,a_ind3],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind3:';
      sb += ' ';
      a_ind3.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteArray3(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteArray3<T>(a, a_ind1, a_ind2, a_ind3, len, ind));
end;

{$endregion WriteArray3}

{$region ReadArray}

type
  CLArrayCommandReadArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private     a: CommandQueue<array of &T>;
    private a_ind: CommandQueue<integer>;
    private   len: CommandQueue<integer>;
    private   ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 4;
    
    public constructor(a: CommandQueue<array of &T>; a_ind, len, ind: CommandQueue<integer>);
    begin
      self.    a :=     a;
      self.a_ind := a_ind;
      self.  len :=   len;
      self.  ind :=   ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
          a.InitBeforeInvoke(g, prev_hubs);
      a_ind.InitBeforeInvoke(g, prev_hubs);
        len.InitBeforeInvoke(g, prev_hubs);
        ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var     a_qr: QueueRes<array of &T>;
      var a_ind_qr: QueueRes<integer>;
      var   len_qr: QueueRes<integer>;
      var   ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
            a_qr := invoker.InvokeBranch&<QueueRes<array of &T>>(    a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
        a_ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(a_ind.InvokeToAny); if a_ind_qr.IsConst then enq_evs.AddL2(a_ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind_qr.AttachInvokeActions(g));
          len_qr := invoker.InvokeBranch&<QueueRes<integer>>(  len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
          ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(  ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var     a :=     a_qr.GetResDirect;
        var a_ind := a_ind_qr.GetResDirect;
        var   len :=   len_qr.GetResDirect;
        var   ind :=   ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))), new UIntPtr(len * Marshal.SizeOf(default(T))),
          a[a_ind],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind:';
      sb += ' ';
      a_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadArray(a: CommandQueue<array of &T>; a_ind, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadArray<T>(a, a_ind, len, ind));
end;

{$endregion ReadArray}

{$region ReadArray2}

type
  CLArrayCommandReadArray2<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private      a: CommandQueue<array[,] of &T>;
    private a_ind1: CommandQueue<integer>;
    private a_ind2: CommandQueue<integer>;
    private    len: CommandQueue<integer>;
    private    ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 5;
    
    public constructor(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, len, ind: CommandQueue<integer>);
    begin
      self.     a :=      a;
      self.a_ind1 := a_ind1;
      self.a_ind2 := a_ind2;
      self.   len :=    len;
      self.   ind :=    ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
           a.InitBeforeInvoke(g, prev_hubs);
      a_ind1.InitBeforeInvoke(g, prev_hubs);
      a_ind2.InitBeforeInvoke(g, prev_hubs);
         len.InitBeforeInvoke(g, prev_hubs);
         ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var      a_qr: QueueRes<array[,] of &T>;
      var a_ind1_qr: QueueRes<integer>;
      var a_ind2_qr: QueueRes<integer>;
      var    len_qr: QueueRes<integer>;
      var    ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
             a_qr := invoker.InvokeBranch&<QueueRes<array[,] of &T>>(     a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
        a_ind1_qr := invoker.InvokeBranch&<QueueRes<integer>>(a_ind1.InvokeToAny); if a_ind1_qr.IsConst then enq_evs.AddL2(a_ind1_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind1_qr.AttachInvokeActions(g));
        a_ind2_qr := invoker.InvokeBranch&<QueueRes<integer>>(a_ind2.InvokeToAny); if a_ind2_qr.IsConst then enq_evs.AddL2(a_ind2_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind2_qr.AttachInvokeActions(g));
           len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
           ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(   ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var      a :=      a_qr.GetResDirect;
        var a_ind1 := a_ind1_qr.GetResDirect;
        var a_ind2 := a_ind2_qr.GetResDirect;
        var    len :=    len_qr.GetResDirect;
        var    ind :=    ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))), new UIntPtr(len * Marshal.SizeOf(default(T))),
          a[a_ind1,a_ind2],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadArray2(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadArray2<T>(a, a_ind1, a_ind2, len, ind));
end;

{$endregion ReadArray2}

{$region ReadArray3}

type
  CLArrayCommandReadArray3<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private      a: CommandQueue<array[,,] of &T>;
    private a_ind1: CommandQueue<integer>;
    private a_ind2: CommandQueue<integer>;
    private a_ind3: CommandQueue<integer>;
    private    len: CommandQueue<integer>;
    private    ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 6;
    
    public constructor(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, len, ind: CommandQueue<integer>);
    begin
      self.     a :=      a;
      self.a_ind1 := a_ind1;
      self.a_ind2 := a_ind2;
      self.a_ind3 := a_ind3;
      self.   len :=    len;
      self.   ind :=    ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
           a.InitBeforeInvoke(g, prev_hubs);
      a_ind1.InitBeforeInvoke(g, prev_hubs);
      a_ind2.InitBeforeInvoke(g, prev_hubs);
      a_ind3.InitBeforeInvoke(g, prev_hubs);
         len.InitBeforeInvoke(g, prev_hubs);
         ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var      a_qr: QueueRes<array[,,] of &T>;
      var a_ind1_qr: QueueRes<integer>;
      var a_ind2_qr: QueueRes<integer>;
      var a_ind3_qr: QueueRes<integer>;
      var    len_qr: QueueRes<integer>;
      var    ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
             a_qr := invoker.InvokeBranch&<QueueRes<array[,,] of &T>>(     a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
        a_ind1_qr := invoker.InvokeBranch&<QueueRes<integer>>(a_ind1.InvokeToAny); if a_ind1_qr.IsConst then enq_evs.AddL2(a_ind1_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind1_qr.AttachInvokeActions(g));
        a_ind2_qr := invoker.InvokeBranch&<QueueRes<integer>>(a_ind2.InvokeToAny); if a_ind2_qr.IsConst then enq_evs.AddL2(a_ind2_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind2_qr.AttachInvokeActions(g));
        a_ind3_qr := invoker.InvokeBranch&<QueueRes<integer>>(a_ind3.InvokeToAny); if a_ind3_qr.IsConst then enq_evs.AddL2(a_ind3_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind3_qr.AttachInvokeActions(g));
           len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
           ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(   ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var      a :=      a_qr.GetResDirect;
        var a_ind1 := a_ind1_qr.GetResDirect;
        var a_ind2 := a_ind2_qr.GetResDirect;
        var a_ind3 := a_ind3_qr.GetResDirect;
        var    len :=    len_qr.GetResDirect;
        var    ind :=    ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))), new UIntPtr(len * Marshal.SizeOf(default(T))),
          a[a_ind1,a_ind2,a_ind3],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind3:';
      sb += ' ';
      a_ind3.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadArray3(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadArray3<T>(a, a_ind1, a_ind2, a_ind3, len, ind));
end;

{$endregion ReadArray3}

{$region WriteArraySegment}

function CLArrayCCQ<T>.ThenWriteArraySegment(a: CommandQueue<ArraySegment<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenWriteArraySegment(a, 0);
end;

{$endregion WriteArraySegment}

{$region ReadArraySegment}

function CLArrayCCQ<T>.ThenReadArraySegment(a: CommandQueue<ArraySegment<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenReadArraySegment(a, 0);
end;

{$endregion ReadArraySegment}

{$region WriteArraySegment}

type
  CLArrayCommandWriteArraySegment<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private   a: CommandQueue<ArraySegment<&T>>;
    private ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(a: CommandQueue<ArraySegment<&T>>; ind: CommandQueue<integer>);
    begin
      self.  a :=   a;
      self.ind := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
        a.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var   a_qr: QueueRes<ArraySegment<&T>>;
      var ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
          a_qr := invoker.InvokeBranch&<QueueRes<ArraySegment<&T>>>(  a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var   a :=   a_qr.GetResDirect;
        var ind := ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a.Array, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind*Marshal.SizeOf(default(T))),
          new UIntPtr(a.Count * Marshal.SizeOf(default(T))),
          a.Array[a.Offset],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteArraySegment(a: CommandQueue<ArraySegment<&T>>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteArraySegment<T>(a, ind));
end;

{$endregion WriteArraySegment}

{$region ReadArraySegment}

type
  CLArrayCommandReadArraySegment<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private   a: CommandQueue<ArraySegment<&T>>;
    private ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(a: CommandQueue<ArraySegment<&T>>; ind: CommandQueue<integer>);
    begin
      self.  a :=   a;
      self.ind := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
        a.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var   a_qr: QueueRes<ArraySegment<&T>>;
      var ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
          a_qr := invoker.InvokeBranch&<QueueRes<ArraySegment<&T>>>(  a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var   a :=   a_qr.GetResDirect;
        var ind := ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a.Array, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind*Marshal.SizeOf(default(T))),
          new UIntPtr(a.Count * Marshal.SizeOf(default(T))),
          a.Array[a.Offset],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadArraySegment(a: CommandQueue<ArraySegment<&T>>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadArraySegment<T>(a, ind));
end;

{$endregion ReadArraySegment}

{$region WriteData!AutoSize}

type
  CLArrayCommandWriteDataAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private ptr: CommandQueue<IntPtr>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(ptr: CommandQueue<IntPtr>);
    begin
      self.ptr := ptr;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      ptr.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var ptr_qr: QueueRes<IntPtr>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var ptr := ptr_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(0),
          new UIntPtr(o.ByteSize),
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteData(ptr: CommandQueue<IntPtr>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteDataAutoSize<T>(ptr));
end;

{$endregion WriteData!AutoSize}

{$region WriteData}

type
  CLArrayCommandWriteData<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private ptr: CommandQueue<IntPtr>;
    private ind: CommandQueue<integer>;
    private len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    public constructor(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>);
    begin
      self.ptr := ptr;
      self.ind := ind;
      self.len := len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      ptr.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
      len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var ptr_qr: QueueRes<IntPtr>;
      var ind_qr: QueueRes<integer>;
      var len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
        len_qr := invoker.InvokeBranch&<QueueRes<integer>>(len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var ptr := ptr_qr.GetResDirect;
        var ind := ind_qr.GetResDirect;
        var len := len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))),
          new UIntPtr(len*Marshal.SizeOf(default(T))),
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteData(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteData<T>(ptr, ind, len));
end;

{$endregion WriteData}

{$region ReadData!AutoSize}

type
  CLArrayCommandReadDataAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private ptr: CommandQueue<IntPtr>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(ptr: CommandQueue<IntPtr>);
    begin
      self.ptr := ptr;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      ptr.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var ptr_qr: QueueRes<IntPtr>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var ptr := ptr_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(0),
          new UIntPtr(o.ByteSize),
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadData(ptr: CommandQueue<IntPtr>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadDataAutoSize<T>(ptr));
end;

{$endregion ReadData!AutoSize}

{$region ReadData}

type
  CLArrayCommandReadData<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private ptr: CommandQueue<IntPtr>;
    private ind: CommandQueue<integer>;
    private len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    public constructor(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>);
    begin
      self.ptr := ptr;
      self.ind := ind;
      self.len := len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      ptr.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
      len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var ptr_qr: QueueRes<IntPtr>;
      var ind_qr: QueueRes<integer>;
      var len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
        len_qr := invoker.InvokeBranch&<QueueRes<integer>>(len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var ptr := ptr_qr.GetResDirect;
        var ind := ind_qr.GetResDirect;
        var len := len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))),
          new UIntPtr(len*Marshal.SizeOf(default(T))),
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadData(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadData<T>(ptr, ind, len));
end;

{$endregion ReadData}

{$region WriteData!AutoSize}

function CLArrayCCQ<T>.ThenWriteData(ptr: pointer): CLArrayCCQ<T>;
begin
  Result := ThenWriteData(IntPtr(ptr));
end;

{$endregion WriteData!AutoSize}

{$region WriteData}

function CLArrayCCQ<T>.ThenWriteData(ptr: pointer; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenWriteData(IntPtr(ptr), ind, len);
end;

{$endregion WriteData}

{$region ReadData!AutoSize}

function CLArrayCCQ<T>.ThenReadData(ptr: pointer): CLArrayCCQ<T>;
begin
  Result := ThenReadData(IntPtr(ptr));
end;

{$endregion ReadData!AutoSize}

{$region ReadData}

function CLArrayCCQ<T>.ThenReadData(ptr: pointer; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenReadData(IntPtr(ptr), ind, len);
end;

{$endregion ReadData}

{$region WriteNativeMemoryArea}

function CLArrayCCQ<T>.ThenWriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLArrayCCQ<T>;
begin
  Result := ThenWriteNativeMemoryArea(native_data, 0);
end;

{$endregion WriteNativeMemoryArea}

{$region WriteNativeMemory}

function CLArrayCCQ<T>.ThenWriteNativeMemory(native_data: CommandQueue<NativeMemory>): CLArrayCCQ<T>;
begin
  Result := ThenWriteNativeMemory(native_data, 0);
end;

{$endregion WriteNativeMemory}

{$region WriteNativeValueArea}

function CLArrayCCQ<T>.ThenWriteNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenWriteNativeValueArea(native_data, 0);
end;

{$endregion WriteNativeValueArea}

{$region WriteNativeValue}

function CLArrayCCQ<T>.ThenWriteNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenWriteNativeValue(native_data, 0);
end;

{$endregion WriteNativeValue}

{$region WriteNativeArrayArea}

function CLArrayCCQ<T>.ThenWriteNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenWriteNativeArrayArea(native_data, 0);
end;

{$endregion WriteNativeArrayArea}

{$region WriteNativeArray}

function CLArrayCCQ<T>.ThenWriteNativeArray(native_data: CommandQueue<NativeArray<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenWriteNativeArray(native_data, 0);
end;

{$endregion WriteNativeArray}

{$region ReadNativeMemoryArea}

function CLArrayCCQ<T>.ThenReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLArrayCCQ<T>;
begin
  Result := ThenReadNativeMemoryArea(native_data, 0);
end;

{$endregion ReadNativeMemoryArea}

{$region ReadNativeMemory}

function CLArrayCCQ<T>.ThenReadNativeMemory(native_data: CommandQueue<NativeMemory>): CLArrayCCQ<T>;
begin
  Result := ThenReadNativeMemory(native_data, 0);
end;

{$endregion ReadNativeMemory}

{$region ReadNativeValueArea}

function CLArrayCCQ<T>.ThenReadNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenReadNativeValueArea(native_data, 0);
end;

{$endregion ReadNativeValueArea}

{$region ReadNativeValue}

function CLArrayCCQ<T>.ThenReadNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenReadNativeValue(native_data, 0);
end;

{$endregion ReadNativeValue}

{$region ReadNativeArrayArea}

function CLArrayCCQ<T>.ThenReadNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenReadNativeArrayArea(native_data, 0);
end;

{$endregion ReadNativeArrayArea}

{$region ReadNativeArray}

function CLArrayCCQ<T>.ThenReadNativeArray(native_data: CommandQueue<NativeArray<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenReadNativeArray(native_data, 0);
end;

{$endregion ReadNativeArray}

{$region WriteNativeMemoryArea}

type
  CLArrayCommandWriteNativeMemoryArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeMemoryArea>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeMemoryArea>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeMemoryArea>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.sz,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteNativeMemoryArea<T>(native_data, mem_offset));
end;

{$endregion WriteNativeMemoryArea}

{$region WriteNativeMemory}

type
  CLArrayCommandWriteNativeMemory<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeMemory>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeMemory>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeMemory>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.sz,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteNativeMemory<T>(native_data, mem_offset));
end;

{$endregion WriteNativeMemory}

{$region WriteNativeValueArea}

type
  CLArrayCommandWriteNativeValueArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValueArea<&T>>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeValueArea<&T>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<&T>>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValueArea<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.ByteSize,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteNativeValueArea<T>(native_data, mem_offset));
end;

{$endregion WriteNativeValueArea}

{$region WriteNativeValue}

type
  CLArrayCommandWriteNativeValue<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValue<&T>>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeValue<&T>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<&T>>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValue<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.ByteSize,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteNativeValue(native_data: CommandQueue<NativeValue<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteNativeValue<T>(native_data, mem_offset));
end;

{$endregion WriteNativeValue}

{$region WriteNativeArrayArea}

type
  CLArrayCommandWriteNativeArrayArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeArrayArea<&T>>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeArrayArea<&T>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeArrayArea<&T>>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeArrayArea<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.ByteSize,
          native_data.first_ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteNativeArrayArea<T>(native_data, mem_offset));
end;

{$endregion WriteNativeArrayArea}

{$region WriteNativeArray}

type
  CLArrayCommandWriteNativeArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeArray<&T>>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeArray<&T>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeArray<&T>>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeArray<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.ByteSize,
          native_data.Area.first_ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteNativeArray(native_data: CommandQueue<NativeArray<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteNativeArray<T>(native_data, mem_offset));
end;

{$endregion WriteNativeArray}

{$region ReadNativeMemoryArea}

type
  CLArrayCommandReadNativeMemoryArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeMemoryArea>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeMemoryArea>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeMemoryArea>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.sz,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadNativeMemoryArea<T>(native_data, mem_offset));
end;

{$endregion ReadNativeMemoryArea}

{$region ReadNativeMemory}

type
  CLArrayCommandReadNativeMemory<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeMemory>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeMemory>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeMemory>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.sz,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadNativeMemory<T>(native_data, mem_offset));
end;

{$endregion ReadNativeMemory}

{$region ReadNativeValueArea}

type
  CLArrayCommandReadNativeValueArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValueArea<&T>>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeValueArea<&T>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<&T>>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValueArea<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.ByteSize,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadNativeValueArea<T>(native_data, mem_offset));
end;

{$endregion ReadNativeValueArea}

{$region ReadNativeValue}

type
  CLArrayCommandReadNativeValue<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValue<&T>>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeValue<&T>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<&T>>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValue<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.ByteSize,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadNativeValue(native_data: CommandQueue<NativeValue<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadNativeValue<T>(native_data, mem_offset));
end;

{$endregion ReadNativeValue}

{$region ReadNativeArrayArea}

type
  CLArrayCommandReadNativeArrayArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeArrayArea<&T>>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeArrayArea<&T>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeArrayArea<&T>>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeArrayArea<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.ByteSize,
          native_data.first_ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadNativeArrayArea<T>(native_data, mem_offset));
end;

{$endregion ReadNativeArrayArea}

{$region ReadNativeArray}

type
  CLArrayCommandReadNativeArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeArray<&T>>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeArray<&T>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeArray<&T>>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeArray<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.ByteSize,
          native_data.Area.first_ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadNativeArray(native_data: CommandQueue<NativeArray<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadNativeArray<T>(native_data, mem_offset));
end;

{$endregion ReadNativeArray}

{$endregion 1#Write&Read}

{$region 2#Fill}

{$region FillValue!AutoSize}

type
  CLArrayCommandFillValueAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val := new NativeValueArea<&T>(true);
    
    protected procedure Finalize; override;
    begin
      val.Release;
    end;
    
    public function EnqEvCapacity: integer; override := 0;
    
    public constructor(val: &T);
    begin
      self.val.Value := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      
      Result := (o, cq, evs)->
      begin
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          val.Pointer, new UIntPtr(Marshal.SizeOf(default(T))),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      sb.Append(val.Value);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillValue(val: &T): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillValueAutoSize<T>(val));
end;

{$endregion FillValue!AutoSize}

{$region FillValue!AutoSizeQ}

type
  CLArrayCommandFillValueAutoSizeQ<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: CommandQueue<&T>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(val: CommandQueue<&T>);
    begin
      self.val := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var val_qr: QueueResPtr<&T>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        val_qr := invoker.InvokeBranch&<QueueResPtr<&T>>(val.InvokeToPtr); enq_evs.AddL2(val_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var val := val_qr.GetResPtrDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          val, new UIntPtr(Marshal.SizeOf(default(T))),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillValue(val: CommandQueue<&T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillValueAutoSizeQ<T>(val));
end;

{$endregion FillValue!AutoSizeQ}

{$region FillValue}

type
  CLArrayCommandFillValue<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val := new NativeValueArea<&T>(true);
    private ind: CommandQueue<integer>;
    private len: CommandQueue<integer>;
    
    protected procedure Finalize; override;
    begin
      val.Release;
    end;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(val: &T; ind, len: CommandQueue<integer>);
    begin
      self.val.Value := val;
      self.ind       := ind;
      self.len       := len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      ind.InitBeforeInvoke(g, prev_hubs);
      len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var ind_qr: QueueRes<integer>;
      var len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
        len_qr := invoker.InvokeBranch&<QueueRes<integer>>(len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var ind := ind_qr.GetResDirect;
        var len := len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          val.Pointer, new UIntPtr(Marshal.SizeOf(default(T))),
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      sb.Append(val.Value);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillValue(val: &T; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillValue<T>(val, ind, len));
end;

{$endregion FillValue}

{$region FillValue!Q}

type
  CLArrayCommandFillValueQ<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: CommandQueue<&T>;
    private ind: CommandQueue<integer>;
    private len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    public constructor(val: CommandQueue<&T>; ind, len: CommandQueue<integer>);
    begin
      self.val := val;
      self.ind := ind;
      self.len := len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
      len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var val_qr: QueueResPtr<&T>;
      var ind_qr: QueueRes<integer>;
      var len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        val_qr := invoker.InvokeBranch&<QueueResPtr<&T>>(val.InvokeToPtr); enq_evs.AddL2(val_qr.AttachInvokeActions(g));
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
        len_qr := invoker.InvokeBranch&<QueueRes<integer>>(len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var val := val_qr.GetResPtrDirect;
        var ind := ind_qr.GetResDirect;
        var len := len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          val, new UIntPtr(Marshal.SizeOf(default(T))),
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillValue(val: CommandQueue<&T>; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillValueQ<T>(val, ind, len));
end;

{$endregion FillValue!Q}

{$region FillArray!AutoSize}

type
  CLArrayCommandFillArrayAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array of &T>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(a: CommandQueue<array of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array of &T>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array of &T>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[0], new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArray(a: CommandQueue<array of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArrayAutoSize<T>(a));
end;

{$endregion FillArray!AutoSize}

{$region FillArray2!AutoSize}

type
  CLArrayCommandFillArray2AutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array[,] of &T>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(a: CommandQueue<array[,] of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array[,] of &T>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array[,] of &T>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[0,0], new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArray2(a: CommandQueue<array[,] of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArray2AutoSize<T>(a));
end;

{$endregion FillArray2!AutoSize}

{$region FillArray3!AutoSize}

type
  CLArrayCommandFillArray3AutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array[,,] of &T>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(a: CommandQueue<array[,,] of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array[,,] of &T>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array[,,] of &T>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[0,0,0], new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArray3(a: CommandQueue<array[,,] of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArray3AutoSize<T>(a));
end;

{$endregion FillArray3!AutoSize}

{$region FillArray}

type
  CLArrayCommandFillArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private           a: CommandQueue<array of &T>;
    private       a_ind: CommandQueue<integer>;
    private pattern_len: CommandQueue<integer>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 5;
    
    public constructor(a: CommandQueue<array of &T>; a_ind, pattern_len, ind, fill_len: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.      a_ind :=       a_ind;
      self.pattern_len := pattern_len;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
                a.InitBeforeInvoke(g, prev_hubs);
            a_ind.InitBeforeInvoke(g, prev_hubs);
      pattern_len.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var           a_qr: QueueRes<array of &T>;
      var       a_ind_qr: QueueRes<integer>;
      var pattern_len_qr: QueueRes<integer>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                  a_qr := invoker.InvokeBranch&<QueueRes<array of &T>>(          a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
              a_ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(      a_ind.InvokeToAny); if a_ind_qr.IsConst then enq_evs.AddL2(a_ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind_qr.AttachInvokeActions(g));
        pattern_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(pattern_len.InvokeToAny); if pattern_len_qr.IsConst then enq_evs.AddL2(pattern_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(pattern_len_qr.AttachInvokeActions(g));
                ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(        ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
           fill_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   fill_len.InvokeToAny); if fill_len_qr.IsConst then enq_evs.AddL2(fill_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var           a :=           a_qr.GetResDirect;
        var       a_ind :=       a_ind_qr.GetResDirect;
        var pattern_len := pattern_len_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[a_ind], new UIntPtr(pattern_len * Marshal.SizeOf(default(T))),
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind:';
      sb += ' ';
      a_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_len:';
      sb += ' ';
      pattern_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArray(a: CommandQueue<array of &T>; a_ind, pattern_len, ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArray<T>(a, a_ind, pattern_len, ind, fill_len));
end;

{$endregion FillArray}

{$region FillArray2}

type
  CLArrayCommandFillArray2<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private           a: CommandQueue<array[,] of &T>;
    private      a_ind1: CommandQueue<integer>;
    private      a_ind2: CommandQueue<integer>;
    private pattern_len: CommandQueue<integer>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 6;
    
    public constructor(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, pattern_len, ind, fill_len: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.     a_ind1 :=      a_ind1;
      self.     a_ind2 :=      a_ind2;
      self.pattern_len := pattern_len;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
                a.InitBeforeInvoke(g, prev_hubs);
           a_ind1.InitBeforeInvoke(g, prev_hubs);
           a_ind2.InitBeforeInvoke(g, prev_hubs);
      pattern_len.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var           a_qr: QueueRes<array[,] of &T>;
      var      a_ind1_qr: QueueRes<integer>;
      var      a_ind2_qr: QueueRes<integer>;
      var pattern_len_qr: QueueRes<integer>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                  a_qr := invoker.InvokeBranch&<QueueRes<array[,] of &T>>(          a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
             a_ind1_qr := invoker.InvokeBranch&<QueueRes<integer>>(     a_ind1.InvokeToAny); if a_ind1_qr.IsConst then enq_evs.AddL2(a_ind1_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind1_qr.AttachInvokeActions(g));
             a_ind2_qr := invoker.InvokeBranch&<QueueRes<integer>>(     a_ind2.InvokeToAny); if a_ind2_qr.IsConst then enq_evs.AddL2(a_ind2_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind2_qr.AttachInvokeActions(g));
        pattern_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(pattern_len.InvokeToAny); if pattern_len_qr.IsConst then enq_evs.AddL2(pattern_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(pattern_len_qr.AttachInvokeActions(g));
                ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(        ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
           fill_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   fill_len.InvokeToAny); if fill_len_qr.IsConst then enq_evs.AddL2(fill_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var           a :=           a_qr.GetResDirect;
        var      a_ind1 :=      a_ind1_qr.GetResDirect;
        var      a_ind2 :=      a_ind2_qr.GetResDirect;
        var pattern_len := pattern_len_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[a_ind1,a_ind2], new UIntPtr(pattern_len * Marshal.SizeOf(default(T))),
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_len:';
      sb += ' ';
      pattern_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArray2(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, pattern_len, ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArray2<T>(a, a_ind1, a_ind2, pattern_len, ind, fill_len));
end;

{$endregion FillArray2}

{$region FillArray3}

type
  CLArrayCommandFillArray3<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private           a: CommandQueue<array[,,] of &T>;
    private      a_ind1: CommandQueue<integer>;
    private      a_ind2: CommandQueue<integer>;
    private      a_ind3: CommandQueue<integer>;
    private pattern_len: CommandQueue<integer>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 7;
    
    public constructor(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, pattern_len, ind, fill_len: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.     a_ind1 :=      a_ind1;
      self.     a_ind2 :=      a_ind2;
      self.     a_ind3 :=      a_ind3;
      self.pattern_len := pattern_len;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
                a.InitBeforeInvoke(g, prev_hubs);
           a_ind1.InitBeforeInvoke(g, prev_hubs);
           a_ind2.InitBeforeInvoke(g, prev_hubs);
           a_ind3.InitBeforeInvoke(g, prev_hubs);
      pattern_len.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var           a_qr: QueueRes<array[,,] of &T>;
      var      a_ind1_qr: QueueRes<integer>;
      var      a_ind2_qr: QueueRes<integer>;
      var      a_ind3_qr: QueueRes<integer>;
      var pattern_len_qr: QueueRes<integer>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                  a_qr := invoker.InvokeBranch&<QueueRes<array[,,] of &T>>(          a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
             a_ind1_qr := invoker.InvokeBranch&<QueueRes<integer>>(     a_ind1.InvokeToAny); if a_ind1_qr.IsConst then enq_evs.AddL2(a_ind1_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind1_qr.AttachInvokeActions(g));
             a_ind2_qr := invoker.InvokeBranch&<QueueRes<integer>>(     a_ind2.InvokeToAny); if a_ind2_qr.IsConst then enq_evs.AddL2(a_ind2_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind2_qr.AttachInvokeActions(g));
             a_ind3_qr := invoker.InvokeBranch&<QueueRes<integer>>(     a_ind3.InvokeToAny); if a_ind3_qr.IsConst then enq_evs.AddL2(a_ind3_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind3_qr.AttachInvokeActions(g));
        pattern_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(pattern_len.InvokeToAny); if pattern_len_qr.IsConst then enq_evs.AddL2(pattern_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(pattern_len_qr.AttachInvokeActions(g));
                ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(        ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
           fill_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   fill_len.InvokeToAny); if fill_len_qr.IsConst then enq_evs.AddL2(fill_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var           a :=           a_qr.GetResDirect;
        var      a_ind1 :=      a_ind1_qr.GetResDirect;
        var      a_ind2 :=      a_ind2_qr.GetResDirect;
        var      a_ind3 :=      a_ind3_qr.GetResDirect;
        var pattern_len := pattern_len_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[a_ind1,a_ind2,a_ind3], new UIntPtr(pattern_len * Marshal.SizeOf(default(T))),
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind3:';
      sb += ' ';
      a_ind3.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_len:';
      sb += ' ';
      pattern_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArray3(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, pattern_len, ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArray3<T>(a, a_ind1, a_ind2, a_ind3, pattern_len, ind, fill_len));
end;

{$endregion FillArray3}

{$region FillArraySegment!AutoSize}

type
  CLArrayCommandFillArraySegmentAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<ArraySegment<&T>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(a: CommandQueue<ArraySegment<&T>>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<ArraySegment<&T>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<ArraySegment<&T>>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a.Array, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a.Array[a.Offset], new UIntPtr(a.Count * Marshal.SizeOf(default(T))),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArraySegment(a: CommandQueue<ArraySegment<&T>>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArraySegmentAutoSize<T>(a));
end;

{$endregion FillArraySegment!AutoSize}

{$region FillArraySegment}

type
  CLArrayCommandFillArraySegment<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private        a: CommandQueue<ArraySegment<&T>>;
    private      ind: CommandQueue<integer>;
    private fill_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    public constructor(a: CommandQueue<ArraySegment<&T>>; ind, fill_len: CommandQueue<integer>);
    begin
      self.       a :=        a;
      self.     ind :=      ind;
      self.fill_len := fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
             a.InitBeforeInvoke(g, prev_hubs);
           ind.InitBeforeInvoke(g, prev_hubs);
      fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var        a_qr: QueueRes<ArraySegment<&T>>;
      var      ind_qr: QueueRes<integer>;
      var fill_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
               a_qr := invoker.InvokeBranch&<QueueRes<ArraySegment<&T>>>(       a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
             ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(     ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
        fill_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(fill_len.InvokeToAny); if fill_len_qr.IsConst then enq_evs.AddL2(fill_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var        a :=        a_qr.GetResDirect;
        var      ind :=      ind_qr.GetResDirect;
        var fill_len := fill_len_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a.Array, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a.Array[a.Offset], new UIntPtr(a.Count * Marshal.SizeOf(default(T))),
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArraySegment(a: CommandQueue<ArraySegment<&T>>; ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArraySegment<T>(a, ind, fill_len));
end;

{$endregion FillArraySegment}

{$region FillData!AutoSize}

type
  CLArrayCommandFillDataAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private         ptr: CommandQueue<IntPtr>;
    private pattern_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(ptr: CommandQueue<IntPtr>; pattern_len: CommandQueue<integer>);
    begin
      self.        ptr :=         ptr;
      self.pattern_len := pattern_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
              ptr.InitBeforeInvoke(g, prev_hubs);
      pattern_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var         ptr_qr: QueueRes<IntPtr>;
      var pattern_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(        ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
        pattern_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(pattern_len.InvokeToAny); if pattern_len_qr.IsConst then enq_evs.AddL2(pattern_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(pattern_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var         ptr :=         ptr_qr.GetResDirect;
        var pattern_len := pattern_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          ptr, new UIntPtr(pattern_len*Marshal.SizeOf(default(T))),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_len:';
      sb += ' ';
      pattern_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillData(ptr: CommandQueue<IntPtr>; pattern_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillDataAutoSize<T>(ptr, pattern_len));
end;

{$endregion FillData!AutoSize}

{$region FillData}

type
  CLArrayCommandFillData<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private         ptr: CommandQueue<IntPtr>;
    private pattern_len: CommandQueue<integer>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 4;
    
    public constructor(ptr: CommandQueue<IntPtr>; pattern_len, ind, fill_len: CommandQueue<integer>);
    begin
      self.        ptr :=         ptr;
      self.pattern_len := pattern_len;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
              ptr.InitBeforeInvoke(g, prev_hubs);
      pattern_len.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var         ptr_qr: QueueRes<IntPtr>;
      var pattern_len_qr: QueueRes<integer>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(        ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
        pattern_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(pattern_len.InvokeToAny); if pattern_len_qr.IsConst then enq_evs.AddL2(pattern_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(pattern_len_qr.AttachInvokeActions(g));
                ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(        ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
           fill_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   fill_len.InvokeToAny); if fill_len_qr.IsConst then enq_evs.AddL2(fill_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var         ptr :=         ptr_qr.GetResDirect;
        var pattern_len := pattern_len_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          ptr, new UIntPtr(pattern_len*Marshal.SizeOf(default(T))),
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_len:';
      sb += ' ';
      pattern_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillData(ptr: CommandQueue<IntPtr>; pattern_len, ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillData<T>(ptr, pattern_len, ind, fill_len));
end;

{$endregion FillData}

{$region FillData!AutoSize}

function CLArrayCCQ<T>.ThenFillData(ptr: pointer; pattern_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillData(IntPtr(ptr), pattern_len);
end;

{$endregion FillData!AutoSize}

{$region FillData}

function CLArrayCCQ<T>.ThenFillData(ptr: pointer; pattern_len, ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillData(IntPtr(ptr), pattern_len, ind, fill_len);
end;

{$endregion FillData}

{$region FillNativeMemoryArea!AutoSize}

function CLArrayCCQ<T>.ThenFillNativeMemoryArea(native_data: NativeMemoryArea): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeMemoryArea(CQ(native_data));
end;

{$endregion FillNativeMemoryArea!AutoSize}

{$region FillNativeMemoryArea}

function CLArrayCCQ<T>.ThenFillNativeMemoryArea(native_data: NativeMemoryArea; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeMemoryArea(CQ(native_data),ind,fill_len);
end;

{$endregion FillNativeMemoryArea}

{$region FillNativeMemory!AutoSize}

function CLArrayCCQ<T>.ThenFillNativeMemory(native_data: NativeMemory): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeMemory(CQ(native_data));
end;

{$endregion FillNativeMemory!AutoSize}

{$region FillNativeMemory}

function CLArrayCCQ<T>.ThenFillNativeMemory(native_data: NativeMemory; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeMemory(CQ(native_data),ind,fill_len);
end;

{$endregion FillNativeMemory}

{$region FillNativeValueArea!AutoSize}

function CLArrayCCQ<T>.ThenFillNativeValueArea(native_data: NativeValueArea<&T>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeValueArea(CQ(native_data));
end;

{$endregion FillNativeValueArea!AutoSize}

{$region FillNativeValueArea}

function CLArrayCCQ<T>.ThenFillNativeValueArea(native_data: NativeValueArea<&T>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeValueArea(CQ(native_data),ind,fill_len);
end;

{$endregion FillNativeValueArea}

{$region FillNativeValue!AutoSize}

function CLArrayCCQ<T>.ThenFillNativeValue(native_data: NativeValue<&T>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeValue(CQ(native_data));
end;

{$endregion FillNativeValue!AutoSize}

{$region FillNativeValue}

function CLArrayCCQ<T>.ThenFillNativeValue(native_data: NativeValue<&T>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeValue(CQ(native_data),ind,fill_len);
end;

{$endregion FillNativeValue}

{$region FillNativeArrayArea!AutoSize}

function CLArrayCCQ<T>.ThenFillNativeArrayArea(native_data: NativeArrayArea<&T>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeArrayArea(CQ(native_data));
end;

{$endregion FillNativeArrayArea!AutoSize}

{$region FillNativeArrayArea}

function CLArrayCCQ<T>.ThenFillNativeArrayArea(native_data: NativeArrayArea<&T>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeArrayArea(CQ(native_data),ind,fill_len);
end;

{$endregion FillNativeArrayArea}

{$region FillNativeArray!AutoSize}

function CLArrayCCQ<T>.ThenFillNativeArray(native_data: NativeArray<&T>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeArray(CQ(native_data));
end;

{$endregion FillNativeArray!AutoSize}

{$region FillNativeArray}

function CLArrayCCQ<T>.ThenFillNativeArray(native_data: NativeArray<&T>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeArray(CQ(native_data),ind,fill_len);
end;

{$endregion FillNativeArray}

{$region FillNativeMemoryArea!AutoSize}

type
  CLArrayCommandFillNativeMemoryAreaAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeMemoryArea>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeMemoryArea>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeMemoryArea>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeMemoryArea>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.ptr,
          native_data.sz,
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeMemoryAreaAutoSize<T>(native_data));
end;

{$endregion FillNativeMemoryArea!AutoSize}

{$region FillNativeMemoryArea}

type
  CLArrayCommandFillNativeMemoryArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeMemoryArea>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    public constructor(native_data: CommandQueue<NativeMemoryArea>; ind,fill_len: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeMemoryArea>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeMemoryArea>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
                ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(        ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
           fill_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   fill_len.InvokeToAny); if fill_len_qr.IsConst then enq_evs.AddL2(fill_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.ptr,
          native_data.sz,
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeMemoryArea<T>(native_data, ind, fill_len));
end;

{$endregion FillNativeMemoryArea}

{$region FillNativeMemory!AutoSize}

type
  CLArrayCommandFillNativeMemoryAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeMemory>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeMemory>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeMemory>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeMemory>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.ptr,
          native_data.Area.sz,
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeMemory(native_data: CommandQueue<NativeMemory>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeMemoryAutoSize<T>(native_data));
end;

{$endregion FillNativeMemory!AutoSize}

{$region FillNativeMemory}

type
  CLArrayCommandFillNativeMemory<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeMemory>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    public constructor(native_data: CommandQueue<NativeMemory>; ind,fill_len: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeMemory>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeMemory>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
                ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(        ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
           fill_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   fill_len.InvokeToAny); if fill_len_qr.IsConst then enq_evs.AddL2(fill_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.ptr,
          native_data.Area.sz,
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeMemory(native_data: CommandQueue<NativeMemory>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeMemory<T>(native_data, ind, fill_len));
end;

{$endregion FillNativeMemory}

{$region FillNativeValueArea!AutoSize}

type
  CLArrayCommandFillNativeValueAreaAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValueArea<&T>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeValueArea<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<&T>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValueArea<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.ptr,
          native_data.ByteSize,
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeValueAreaAutoSize<T>(native_data));
end;

{$endregion FillNativeValueArea!AutoSize}

{$region FillNativeValueArea}

type
  CLArrayCommandFillNativeValueArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValueArea<&T>>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    public constructor(native_data: CommandQueue<NativeValueArea<&T>>; ind,fill_len: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<&T>>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValueArea<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
                ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(        ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
           fill_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   fill_len.InvokeToAny); if fill_len_qr.IsConst then enq_evs.AddL2(fill_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.ptr,
          native_data.ByteSize,
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeValueArea<T>(native_data, ind, fill_len));
end;

{$endregion FillNativeValueArea}

{$region FillNativeValue!AutoSize}

type
  CLArrayCommandFillNativeValueAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValue<&T>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeValue<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<&T>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValue<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.ptr,
          native_data.Area.ByteSize,
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeValueAutoSize<T>(native_data));
end;

{$endregion FillNativeValue!AutoSize}

{$region FillNativeValue}

type
  CLArrayCommandFillNativeValue<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValue<&T>>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    public constructor(native_data: CommandQueue<NativeValue<&T>>; ind,fill_len: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<&T>>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValue<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
                ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(        ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
           fill_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   fill_len.InvokeToAny); if fill_len_qr.IsConst then enq_evs.AddL2(fill_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.ptr,
          native_data.Area.ByteSize,
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeValue(native_data: CommandQueue<NativeValue<&T>>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeValue<T>(native_data, ind, fill_len));
end;

{$endregion FillNativeValue}

{$region FillNativeArrayArea!AutoSize}

type
  CLArrayCommandFillNativeArrayAreaAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeArrayArea<&T>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeArrayArea<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeArrayArea<&T>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeArrayArea<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.first_ptr,
          native_data.ByteSize,
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeArrayAreaAutoSize<T>(native_data));
end;

{$endregion FillNativeArrayArea!AutoSize}

{$region FillNativeArrayArea}

type
  CLArrayCommandFillNativeArrayArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeArrayArea<&T>>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    public constructor(native_data: CommandQueue<NativeArrayArea<&T>>; ind,fill_len: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeArrayArea<&T>>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeArrayArea<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
                ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(        ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
           fill_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   fill_len.InvokeToAny); if fill_len_qr.IsConst then enq_evs.AddL2(fill_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.first_ptr,
          native_data.ByteSize,
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeArrayArea<T>(native_data, ind, fill_len));
end;

{$endregion FillNativeArrayArea}

{$region FillNativeArray!AutoSize}

type
  CLArrayCommandFillNativeArrayAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeArray<&T>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeArray<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeArray<&T>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeArray<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.first_ptr,
          native_data.Area.ByteSize,
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeArray(native_data: CommandQueue<NativeArray<&T>>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeArrayAutoSize<T>(native_data));
end;

{$endregion FillNativeArray!AutoSize}

{$region FillNativeArray}

type
  CLArrayCommandFillNativeArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeArray<&T>>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    public constructor(native_data: CommandQueue<NativeArray<&T>>; ind,fill_len: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeArray<&T>>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeArray<&T>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
                ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(        ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
           fill_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   fill_len.InvokeToAny); if fill_len_qr.IsConst then enq_evs.AddL2(fill_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.first_ptr,
          native_data.Area.ByteSize,
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeArray(native_data: CommandQueue<NativeArray<&T>>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeArray<T>(native_data, ind, fill_len));
end;

{$endregion FillNativeArray}

{$endregion 2#Fill}

{$region 3#Copy}

{$region CopyTo!CLMemoryAutoSize}

type
  CLArrayCommandCopyToCLMemoryAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private mem: CommandQueue<CLMemory>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(mem: CommandQueue<CLMemory>);
    begin
      self.mem := mem;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      mem.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var mem_qr: QueueRes<CLMemory>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        mem_qr := invoker.InvokeBranch&<QueueRes<CLMemory>>(mem.InvokeToAny); if mem_qr.IsConst then enq_evs.AddL2(mem_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var mem := mem_qr.GetResDirect;
        var res_ev: cl_event;
        
        var uptr_mem_offset := UIntPtr.Zero;
        var uptr_own_offset := UIntPtr.Zero;
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,mem.Native,
          uptr_own_offset,uptr_mem_offset,
          new UIntPtr(Min(o.ByteSize, mem.Size64)),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyTo(mem: CommandQueue<CLMemory>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyToCLMemoryAutoSize<T>(mem));
end;

{$endregion CopyTo!CLMemoryAutoSize}

{$region CopyTo!CLMemory}

type
  CLArrayCommandCopyToCLMemory<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private        mem: CommandQueue<CLMemory>;
    private mem_offset: CommandQueue<integer>;
    private        ind: CommandQueue<integer>;
    private        len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 4;
    
    public constructor(mem: CommandQueue<CLMemory>; mem_offset, ind, len: CommandQueue<integer>);
    begin
      self.       mem :=        mem;
      self.mem_offset := mem_offset;
      self.       ind :=        ind;
      self.       len :=        len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
             mem.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
             ind.InitBeforeInvoke(g, prev_hubs);
             len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var        mem_qr: QueueRes<CLMemory>;
      var mem_offset_qr: QueueRes<integer>;
      var        ind_qr: QueueRes<integer>;
      var        len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
               mem_qr := invoker.InvokeBranch&<QueueRes<CLMemory>>(       mem.InvokeToAny); if mem_qr.IsConst then enq_evs.AddL2(mem_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_qr.AttachInvokeActions(g));
        mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
               ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(       ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
               len_qr := invoker.InvokeBranch&<QueueRes<integer>>(       len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var        mem :=        mem_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var        ind :=        ind_qr.GetResDirect;
        var        len :=        len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var uptr_mem_offset := new UIntPtr(mem_offset);
        var uptr_own_offset := new UIntPtr(ind*Marshal.SizeOf(default(T)));
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,mem.Native,
          uptr_own_offset,uptr_mem_offset,
          new UIntPtr(len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyTo(mem: CommandQueue<CLMemory>; mem_offset, ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyToCLMemory<T>(mem, mem_offset, ind, len));
end;

{$endregion CopyTo!CLMemory}

{$region CopyFrom!CLMemoryAutoSize}

type
  CLArrayCommandCopyFromCLMemoryAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private mem: CommandQueue<CLMemory>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(mem: CommandQueue<CLMemory>);
    begin
      self.mem := mem;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      mem.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var mem_qr: QueueRes<CLMemory>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        mem_qr := invoker.InvokeBranch&<QueueRes<CLMemory>>(mem.InvokeToAny); if mem_qr.IsConst then enq_evs.AddL2(mem_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var mem := mem_qr.GetResDirect;
        var res_ev: cl_event;
        
        var uptr_mem_offset := UIntPtr.Zero;
        var uptr_own_offset := UIntPtr.Zero;
        var ec := cl.EnqueueCopyBuffer(
          cq, mem.Native,o.Native,
          uptr_mem_offset,uptr_own_offset,
          new UIntPtr(Min(o.ByteSize, mem.Size64)),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyFrom(mem: CommandQueue<CLMemory>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyFromCLMemoryAutoSize<T>(mem));
end;

{$endregion CopyFrom!CLMemoryAutoSize}

{$region CopyFrom!CLMemory}

type
  CLArrayCommandCopyFromCLMemory<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private        mem: CommandQueue<CLMemory>;
    private mem_offset: CommandQueue<integer>;
    private        ind: CommandQueue<integer>;
    private        len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 4;
    
    public constructor(mem: CommandQueue<CLMemory>; mem_offset, ind, len: CommandQueue<integer>);
    begin
      self.       mem :=        mem;
      self.mem_offset := mem_offset;
      self.       ind :=        ind;
      self.       len :=        len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
             mem.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
             ind.InitBeforeInvoke(g, prev_hubs);
             len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var        mem_qr: QueueRes<CLMemory>;
      var mem_offset_qr: QueueRes<integer>;
      var        ind_qr: QueueRes<integer>;
      var        len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
               mem_qr := invoker.InvokeBranch&<QueueRes<CLMemory>>(       mem.InvokeToAny); if mem_qr.IsConst then enq_evs.AddL2(mem_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_qr.AttachInvokeActions(g));
        mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
               ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(       ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
               len_qr := invoker.InvokeBranch&<QueueRes<integer>>(       len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var        mem :=        mem_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var        ind :=        ind_qr.GetResDirect;
        var        len :=        len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var uptr_mem_offset := new UIntPtr(mem_offset);
        var uptr_own_offset := new UIntPtr(ind*Marshal.SizeOf(default(T)));
        var ec := cl.EnqueueCopyBuffer(
          cq, mem.Native,o.Native,
          uptr_mem_offset,uptr_own_offset,
          new UIntPtr(len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyFrom(mem: CommandQueue<CLMemory>; mem_offset, ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyFromCLMemory<T>(mem, mem_offset, ind, len));
end;

{$endregion CopyFrom!CLMemory}

{$region CopyTo!CLValue}

type
  CLArrayCommandCopyToCLValue<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: CommandQueue<CLValue<&T>>;
    private ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(val: CommandQueue<CLValue<&T>>; ind: CommandQueue<integer>);
    begin
      self.val := val;
      self.ind := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var val_qr: QueueRes<CLValue<&T>>;
      var ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        val_qr := invoker.InvokeBranch&<QueueRes<CLValue<&T>>>(val.InvokeToAny); if val_qr.IsConst then enq_evs.AddL2(val_qr.AttachInvokeActions(g)) else enq_evs.AddL1(val_qr.AttachInvokeActions(g));
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var val := val_qr.GetResDirect;
        var ind := ind_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,val.Native,
          new UIntPtr(ind*Marshal.SizeOf(default(T))),UIntPtr.Zero,
          new UIntPtr(Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyTo(val: CommandQueue<CLValue<&T>>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyToCLValue<T>(val, ind));
end;

{$endregion CopyTo!CLValue}

{$region CopyFrom!CLValue}

type
  CLArrayCommandCopyFromCLValue<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: CommandQueue<CLValue<&T>>;
    private ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(val: CommandQueue<CLValue<&T>>; ind: CommandQueue<integer>);
    begin
      self.val := val;
      self.ind := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var val_qr: QueueRes<CLValue<&T>>;
      var ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        val_qr := invoker.InvokeBranch&<QueueRes<CLValue<&T>>>(val.InvokeToAny); if val_qr.IsConst then enq_evs.AddL2(val_qr.AttachInvokeActions(g)) else enq_evs.AddL1(val_qr.AttachInvokeActions(g));
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var val := val_qr.GetResDirect;
        var ind := ind_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, val.Native,o.Native,
          UIntPtr.Zero,new UIntPtr(ind*Marshal.SizeOf(default(T))),
          new UIntPtr(Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyFrom(val: CommandQueue<CLValue<&T>>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyFromCLValue<T>(val, ind));
end;

{$endregion CopyFrom!CLValue}

{$region CopyTo!CLArrayAutoSize}

type
  CLArrayCommandCopyToCLArrayAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<CLArray<&T>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(a: CommandQueue<CLArray<&T>>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<CLArray<&T>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<CLArray<&T>>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,a.Native,
          UIntPtr.Zero, UIntPtr.Zero,
          new UIntPtr(Min(o.ByteSize, a.ByteSize)),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyTo(a: CommandQueue<CLArray<&T>>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyToCLArrayAutoSize<T>(a));
end;

{$endregion CopyTo!CLArrayAutoSize}

{$region CopyTo!CLArray}

type
  CLArrayCommandCopyToCLArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private        a: CommandQueue<CLArray<&T>>;
    private from_ind: CommandQueue<integer>;
    private   to_ind: CommandQueue<integer>;
    private      len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 4;
    
    public constructor(a: CommandQueue<CLArray<&T>>; from_ind, to_ind, len: CommandQueue<integer>);
    begin
      self.       a :=        a;
      self.from_ind := from_ind;
      self.  to_ind :=   to_ind;
      self.     len :=      len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
             a.InitBeforeInvoke(g, prev_hubs);
      from_ind.InitBeforeInvoke(g, prev_hubs);
        to_ind.InitBeforeInvoke(g, prev_hubs);
           len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var        a_qr: QueueRes<CLArray<&T>>;
      var from_ind_qr: QueueRes<integer>;
      var   to_ind_qr: QueueRes<integer>;
      var      len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
               a_qr := invoker.InvokeBranch&<QueueRes<CLArray<&T>>>(       a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
        from_ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(from_ind.InvokeToAny); if from_ind_qr.IsConst then enq_evs.AddL2(from_ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(from_ind_qr.AttachInvokeActions(g));
          to_ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(  to_ind.InvokeToAny); if to_ind_qr.IsConst then enq_evs.AddL2(to_ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(to_ind_qr.AttachInvokeActions(g));
             len_qr := invoker.InvokeBranch&<QueueRes<integer>>(     len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var        a :=        a_qr.GetResDirect;
        var from_ind := from_ind_qr.GetResDirect;
        var   to_ind :=   to_ind_qr.GetResDirect;
        var      len :=      len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,a.Native,
          new UIntPtr(from_ind*Marshal.SizeOf(default(T))), new UIntPtr(to_ind*Marshal.SizeOf(default(T))),
          new UIntPtr(len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'from_ind:';
      sb += ' ';
      from_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'to_ind:';
      sb += ' ';
      to_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyTo(a: CommandQueue<CLArray<&T>>; from_ind, to_ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyToCLArray<T>(a, from_ind, to_ind, len));
end;

{$endregion CopyTo!CLArray}

{$region CopyFrom!CLArrayAutoSize}

type
  CLArrayCommandCopyFromCLArrayAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<CLArray<&T>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(a: CommandQueue<CLArray<&T>>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<CLArray<&T>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<CLArray<&T>>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, a.Native,o.Native,
          UIntPtr.Zero, UIntPtr.Zero,
          new UIntPtr(Min(o.ByteSize, a.ByteSize)),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyFrom(a: CommandQueue<CLArray<&T>>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyFromCLArrayAutoSize<T>(a));
end;

{$endregion CopyFrom!CLArrayAutoSize}

{$region CopyFrom!CLArray}

type
  CLArrayCommandCopyFromCLArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private        a: CommandQueue<CLArray<&T>>;
    private from_ind: CommandQueue<integer>;
    private   to_ind: CommandQueue<integer>;
    private      len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 4;
    
    public constructor(a: CommandQueue<CLArray<&T>>; from_ind, to_ind, len: CommandQueue<integer>);
    begin
      self.       a :=        a;
      self.from_ind := from_ind;
      self.  to_ind :=   to_ind;
      self.     len :=      len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
             a.InitBeforeInvoke(g, prev_hubs);
      from_ind.InitBeforeInvoke(g, prev_hubs);
        to_ind.InitBeforeInvoke(g, prev_hubs);
           len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLArray<T>>; override;
    begin
      var        a_qr: QueueRes<CLArray<&T>>;
      var from_ind_qr: QueueRes<integer>;
      var   to_ind_qr: QueueRes<integer>;
      var      len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
               a_qr := invoker.InvokeBranch&<QueueRes<CLArray<&T>>>(       a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
        from_ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(from_ind.InvokeToAny); if from_ind_qr.IsConst then enq_evs.AddL2(from_ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(from_ind_qr.AttachInvokeActions(g));
          to_ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(  to_ind.InvokeToAny); if to_ind_qr.IsConst then enq_evs.AddL2(to_ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(to_ind_qr.AttachInvokeActions(g));
             len_qr := invoker.InvokeBranch&<QueueRes<integer>>(     len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var        a :=        a_qr.GetResDirect;
        var from_ind := from_ind_qr.GetResDirect;
        var   to_ind :=   to_ind_qr.GetResDirect;
        var      len :=      len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, a.Native,o.Native,
          new UIntPtr(from_ind*Marshal.SizeOf(default(T))), new UIntPtr(to_ind*Marshal.SizeOf(default(T))),
          new UIntPtr(len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'from_ind:';
      sb += ' ';
      from_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'to_ind:';
      sb += ' ';
      to_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyFrom(a: CommandQueue<CLArray<&T>>; from_ind, to_ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyFromCLArray<T>(a, from_ind, to_ind, len));
end;

{$endregion CopyFrom!CLArray}

{$endregion 3#Copy}


