


constructor CLMemoryCCQ.Create(o: CLMemory) := inherited;
constructor CLMemoryCCQ.Create(q: CommandQueue<CLMemory>) := inherited;
constructor CLMemoryCCQ.Create := inherited;

function MakeCCQ(self: CommandQueue<CLMemory>): CLMemoryCCQ; extensionmethod;
begin
  Result := new CLMemoryCCQ(self);
end;

{$region Special .Add's}

function CLMemoryCCQ.ThenQueue(q: CommandQueueBase): CLMemoryCCQ;
begin
  var comm := QueueCommandFactory&<CLMemory>.Make(q);
  Result := if comm=nil then self else AddCommand(self, comm);
end;

function CLMemoryCCQ.ThenConstProc(p: CLMemory->()) := AddCommand(self, ProcCommandFactory&<CLMemory>.MakeConst&<SimpleProcContainer<CLMemory>>(p));
function CLMemoryCCQ.ThenConstProc(p: (CLMemory, CLContext)->()) := AddCommand(self, ProcCommandFactory&<CLMemory>.MakeConst&<SimpleProcContainerC<CLMemory>>(p));
function CLMemoryCCQ.ThenQuickProc(p: CLMemory->()) := AddCommand(self, ProcCommandFactory&<CLMemory>.MakeQuick&<SimpleProcContainer<CLMemory>>(p));
function CLMemoryCCQ.ThenQuickProc(p: (CLMemory, CLContext)->()) := AddCommand(self, ProcCommandFactory&<CLMemory>.MakeQuick&<SimpleProcContainerC<CLMemory>>(p));
function CLMemoryCCQ.ThenThreadedProc(p: CLMemory->()) := AddCommand(self, ProcCommandFactory&<CLMemory>.MakeThreaded&<SimpleProcContainer<CLMemory>>(p));
function CLMemoryCCQ.ThenThreadedProc(p: (CLMemory, CLContext)->()) := AddCommand(self, ProcCommandFactory&<CLMemory>.MakeThreaded&<SimpleProcContainerC<CLMemory>>(p));

function CLMemoryCCQ.ThenWait(marker: WaitMarker) := AddCommand(self, WaitCommandFactory&<CLMemory>.Make(marker));

{$endregion Special .Add's}


