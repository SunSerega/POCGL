


constructor CLArrayCCQ<T>.Create(q: CommandQueue<CLArray<T>>) := inherited;
constructor CLArrayCCQ<T>.Create := inherited;

function MakeCCQ<T>(self: CommandQueue<CLArray<T>>): CLArrayCCQ<T>; extensionmethod; where T: record;
begin
  Result := new CLArrayCCQ<T>(self);
end;

{$region Special .Add's}

function CLArrayCCQ<T>.ThenQueue(q: CommandQueueBase): CLArrayCCQ<T>;
begin
  var comm := QueueCommandConstructor&<CLArray<T>>.Make(q);
  Result := if comm=nil then self else AddCommand(self, comm);
end;

function CLArrayCCQ<T>.ThenProc(p: CLArray<T>->(); need_own_thread, can_pre_calc: boolean) := AddCommand(self, ProcCommandConstructor&<CLArray<T>>.Make&<SimpleProcContainer<CLArray<T>>>(p, need_own_thread, can_pre_calc));
function CLArrayCCQ<T>.ThenProc(p: (CLArray<T>, CLContext)->(); need_own_thread, can_pre_calc: boolean) := AddCommand(self, ProcCommandConstructor&<CLArray<T>>.Make&<SimpleProcContainerC<CLArray<T>>>(p, need_own_thread, can_pre_calc));

function CLArrayCCQ<T>.ThenWait(marker: WaitMarker) := AddCommand(self, WaitCommandConstructor&<CLArray<T>>.Make(marker));

{$endregion Special .Add's}


