


constructor CLArrayCCQ<T>.Create(o: CLArray<T>) := inherited;
constructor CLArrayCCQ<T>.Create(q: CommandQueue<CLArray<T>>) := inherited;
constructor CLArrayCCQ<T>.Create := inherited;

{$region Special .Add's}

function CLArrayCCQ<T>.ThenQueue(q: CommandQueueBase): CLArrayCCQ<T>;
begin
  var comm := QueueCommandFactory&<CLArray<T>>.Make(q);
  Result := if comm=nil then self else AddCommand(self, comm);
end;

function CLArrayCCQ<T>.ThenConstProc(p: CLArray<T>->()) := AddCommand(self, ProcCommandFactory&<CLArray<T>>.MakeConst&<SimpleProcContainer<CLArray<T>>>(p));
function CLArrayCCQ<T>.ThenConstProc(p: (CLArray<T>, CLContext)->()) := AddCommand(self, ProcCommandFactory&<CLArray<T>>.MakeConst&<SimpleProcContainerC<CLArray<T>>>(p));
function CLArrayCCQ<T>.ThenQuickProc(p: CLArray<T>->()) := AddCommand(self, ProcCommandFactory&<CLArray<T>>.MakeQuick&<SimpleProcContainer<CLArray<T>>>(p));
function CLArrayCCQ<T>.ThenQuickProc(p: (CLArray<T>, CLContext)->()) := AddCommand(self, ProcCommandFactory&<CLArray<T>>.MakeQuick&<SimpleProcContainerC<CLArray<T>>>(p));
function CLArrayCCQ<T>.ThenThreadedProc(p: CLArray<T>->()) := AddCommand(self, ProcCommandFactory&<CLArray<T>>.MakeThreaded&<SimpleProcContainer<CLArray<T>>>(p));
function CLArrayCCQ<T>.ThenThreadedProc(p: (CLArray<T>, CLContext)->()) := AddCommand(self, ProcCommandFactory&<CLArray<T>>.MakeThreaded&<SimpleProcContainerC<CLArray<T>>>(p));

function CLArrayCCQ<T>.ThenWait(marker: WaitMarker) := AddCommand(self, WaitCommandFactory&<CLArray<T>>.Make(marker));

{$endregion Special .Add's}


