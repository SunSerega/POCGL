


constructor CLKernelCCQ.Create(q: CommandQueue<CLKernel>) := inherited;
constructor CLKernelCCQ.Create := inherited;

/// %CommandQueue<CLKernel>.MakeCCQ%
function MakeCCQ(self: CommandQueue<CLKernel>): CLKernelCCQ; extensionmethod;
begin
  Result := new CLKernelCCQ(self);
end;

{$region Special .Add's}

function CLKernelCCQ.ThenQueue(q: CommandQueueBase): CLKernelCCQ;
begin
  var comm := QueueCommandConstructor&<CLKernel>.Make(q);
  Result := if comm=nil then self else AddCommand(self, comm);
end;

function CLKernelCCQ.ThenProc(p: CLKernel->(); need_own_thread, can_pre_calc: boolean) := AddCommand(self, ProcCommandConstructor&<CLKernel>.Make&<SimpleProcContainer<CLKernel>>(p, need_own_thread, can_pre_calc));
function CLKernelCCQ.ThenProc(p: (CLKernel, CLContext)->(); need_own_thread, can_pre_calc: boolean) := AddCommand(self, ProcCommandConstructor&<CLKernel>.Make&<SimpleProcContainerC<CLKernel>>(p, need_own_thread, can_pre_calc));

function CLKernelCCQ.ThenWait(marker: WaitMarker) := AddCommand(self, WaitCommandConstructor&<CLKernel>.Make(marker));

{$endregion Special .Add's}


