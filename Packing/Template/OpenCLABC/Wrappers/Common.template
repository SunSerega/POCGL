  
  
  
  Platform = partial class
    
    public property Native: cl_platform_id read ntv;
    
    private prop: PlatformProperties;
    private function GetProperties: PlatformProperties;
    begin
      if prop=nil then prop := new PlatformProperties(ntv);
      Result := prop;
    end;
    public property Properties: PlatformProperties read GetProperties;
    
    public static function operator=(wr1, wr2: Platform): boolean :=
    if ReferenceEquals(wr1,nil) then ReferenceEquals(wr2,nil) else not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: Platform): boolean := false=
    if ReferenceEquals(wr1,nil) then ReferenceEquals(wr2,nil) else not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is Platform(var wr)) and (self = wr);
    
    public procedure ToString(res: StringBuilder);
    begin
      TypeName(self, res);
      res += '[';
      res += ntv.val.ToString;
      res += ']';
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      self.ToString(res);
      Result := res.ToString;
    end;
    
  end;
  
  Device = partial class
    
    public property Native: cl_device_id read ntv;
    
    private prop: DeviceProperties;
    private function GetProperties: DeviceProperties;
    begin
      if prop=nil then prop := new DeviceProperties(ntv);
      Result := prop;
    end;
    public property Properties: DeviceProperties read GetProperties;
    
    public static function operator=(wr1, wr2: Device): boolean :=
    if ReferenceEquals(wr1,nil) then ReferenceEquals(wr2,nil) else not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: Device): boolean := false=
    if ReferenceEquals(wr1,nil) then ReferenceEquals(wr2,nil) else not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is Device(var wr)) and (self = wr);
    
    public procedure ToString(res: StringBuilder);
    begin
      TypeName(self, res);
      res += '[';
      res += ntv.val.ToString;
      res += ']';
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      self.ToString(res);
      Result := res.ToString;
    end;
    
  end;
  
  SubDevice = partial class(Device)
    
    private prop: SubDeviceProperties;
    private function GetProperties: SubDeviceProperties;
    begin
      if prop=nil then prop := new SubDeviceProperties(ntv);
      Result := prop;
    end;
    public property Properties: SubDeviceProperties read GetProperties;
    
    public procedure ToString(res: StringBuilder);
    begin
      inherited;
      res += ' of ';
      Parent.ToString(res);
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      self.ToString(res);
      Result := res.ToString;
    end;
    
  end;
  
  Context = partial class
    
    public property Native: cl_context read ntv;
    
    private prop: ContextProperties;
    private function GetProperties: ContextProperties;
    begin
      if prop=nil then prop := new ContextProperties(ntv);
      Result := prop;
    end;
    public property Properties: ContextProperties read GetProperties;
    
    public static function operator=(wr1, wr2: Context): boolean :=
    if ReferenceEquals(wr1,nil) then ReferenceEquals(wr2,nil) else not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: Context): boolean := false=
    if ReferenceEquals(wr1,nil) then ReferenceEquals(wr2,nil) else not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is Context(var wr)) and (self = wr);
    
    public procedure ToString(res: StringBuilder);
    begin
      TypeName(self, res);
      res += '[';
      res += ntv.val.ToString;
      res += '] on devices: [';
      var sep := ', ';
      foreach var d in AllDevices do
      begin
        d.ToString(res);
        res += sep;
      end;
      if AllDevices.Count<>0 then res.Length-=sep.Length;
      res += ']; Main device: ';
      MainDevice.ToString(res);
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      self.ToString(res);
      Result := res.ToString;
    end;
    
  end;
  
  ProgramCode = partial class
    
    public property Native: cl_program read ntv;
    
    private prop: ProgramCodeProperties;
    private function GetProperties: ProgramCodeProperties;
    begin
      if prop=nil then prop := new ProgramCodeProperties(ntv);
      Result := prop;
    end;
    public property Properties: ProgramCodeProperties read GetProperties;
    
    public static function operator=(wr1, wr2: ProgramCode): boolean :=
    if ReferenceEquals(wr1,nil) then ReferenceEquals(wr2,nil) else not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: ProgramCode): boolean := false=
    if ReferenceEquals(wr1,nil) then ReferenceEquals(wr2,nil) else not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is ProgramCode(var wr)) and (self = wr);
    
    public procedure ToString(res: StringBuilder);
    begin
      TypeName(self, res);
      res += '[';
      res += ntv.val.ToString;
      res += ']';
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      self.ToString(res);
      Result := res.ToString;
    end;
    
  end;
  
  Kernel = partial class
    
    public property Native: cl_kernel read ntv;
    
    private prop: KernelProperties;
    private function GetProperties: KernelProperties;
    begin
      if prop=nil then prop := new KernelProperties(ntv);
      Result := prop;
    end;
    public property Properties: KernelProperties read GetProperties;
    
    public static function operator=(wr1, wr2: Kernel): boolean :=
    if ReferenceEquals(wr1,nil) then ReferenceEquals(wr2,nil) else not ReferenceEquals(wr2,nil) and (wr1.Name=wr2.Name) and (wr1.CodeContainer=wr2.CodeContainer);
    public static function operator<>(wr1, wr2: Kernel): boolean := false=
    if ReferenceEquals(wr1,nil) then ReferenceEquals(wr2,nil) else not ReferenceEquals(wr2,nil) and (wr1.Name=wr2.Name) and (wr1.CodeContainer=wr2.CodeContainer);
    
    public function Equals(obj: object): boolean; override :=
    (obj is Kernel(var wr)) and (self = wr);
    
    public procedure ToString(res: StringBuilder);
    begin
      TypeName(self, res);
      res += '[';
      res += Name;
      res += '] from ';
      code.ToString(res);
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      self.ToString(res);
      Result := res.ToString;
    end;
    
  end;
  
  CLMemory = partial class
    
    public property Native: cl_mem read ntv;
    
    private prop: CLMemoryProperties;
    private function GetProperties: CLMemoryProperties;
    begin
      if prop=nil then prop := new CLMemoryProperties(ntv);
      Result := prop;
    end;
    public property Properties: CLMemoryProperties read GetProperties;
    
    public static function operator=(wr1, wr2: CLMemory): boolean :=
    if ReferenceEquals(wr1,nil) then ReferenceEquals(wr2,nil) else not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: CLMemory): boolean := false=
    if ReferenceEquals(wr1,nil) then ReferenceEquals(wr2,nil) else not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is CLMemory(var wr)) and (self = wr);
    
    public procedure ToString(res: StringBuilder);
    begin
      TypeName(self, res);
      res += '[';
      res += ntv.val.ToString;
      res += '] of size ';
      res += Size.ToString;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      self.ToString(res);
      Result := res.ToString;
    end;
    
  end;
  
  CLMemorySubSegment = partial class(CLMemory)
    
    private prop: CLMemorySubSegmentProperties;
    private function GetProperties: CLMemorySubSegmentProperties;
    begin
      if prop=nil then prop := new CLMemorySubSegmentProperties(ntv);
      Result := prop;
    end;
    public property Properties: CLMemorySubSegmentProperties read GetProperties;
    
    public procedure ToString(res: StringBuilder);
    begin
      inherited;
      res += ' inside ';
      Parent.ToString(res);
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      self.ToString(res);
      Result := res.ToString;
    end;
    
  end;
  
  CLValue<T> = partial class
    
    public property Native: cl_mem read ntv;
    
    private prop: CLValueProperties;
    private function GetProperties: CLValueProperties;
    begin
      if prop=nil then prop := new CLValueProperties(ntv);
      Result := prop;
    end;
    public property Properties: CLValueProperties read GetProperties;
    
    public static function operator=(wr1, wr2: CLValue<T>): boolean :=
    if ReferenceEquals(wr1,nil) then ReferenceEquals(wr2,nil) else not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: CLValue<T>): boolean := false=
    if ReferenceEquals(wr1,nil) then ReferenceEquals(wr2,nil) else not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is CLValue<T>(var wr)) and (self = wr);
    
    public procedure ToString(res: StringBuilder);
    begin
      TypeName(self, res);
      res += '[';
      res += ntv.val.ToString;
      res += ']';
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      self.ToString(res);
      Result := res.ToString;
    end;
    
  end;
  
  CLArray<T> = partial class
    
    public property Native: cl_mem read ntv;
    
    private prop: CLArrayProperties;
    private function GetProperties: CLArrayProperties;
    begin
      if prop=nil then prop := new CLArrayProperties(ntv);
      Result := prop;
    end;
    public property Properties: CLArrayProperties read GetProperties;
    
    public static function operator=(wr1, wr2: CLArray<T>): boolean :=
    if ReferenceEquals(wr1,nil) then ReferenceEquals(wr2,nil) else not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: CLArray<T>): boolean := false=
    if ReferenceEquals(wr1,nil) then ReferenceEquals(wr2,nil) else not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is CLArray<T>(var wr)) and (self = wr);
    
    public procedure ToString(res: StringBuilder);
    begin
      TypeName(self, res);
      res += '[';
      res += ntv.val.ToString;
      res += '] of length ';
      res += Length.ToString;
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      self.ToString(res);
      Result := res.ToString;
    end;
    
  end;
  
  
  