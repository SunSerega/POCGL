


{$region Sync}

{$region Simple}

function CombineSyncQueue(params qs: array of CommandQueueBase) := QueueArrayUtils.ConstructSync&<CommandQueueBase>(qs.Cast&<CommandQueueBase>);
function CombineSyncQueue(params qs: array of CommandQueueNil) := QueueArrayUtils.ConstructSync&<CommandQueueNil>(qs.Cast&<CommandQueueBase>);
function CombineSyncQueue<T>(params qs: array of CommandQueue<T>) := QueueArrayUtils.ConstructSync&<CommandQueue<T>>(qs.Cast&<CommandQueueBase>);

function CombineSyncQueue<TQ>(qs: array of TQ; last: CommandQueueBase) := QueueArrayUtils.ConstructSync&<CommandQueueBase>(qs.Cast&<CommandQueueBase>.Append&<CommandQueueBase>(last));
function CombineSyncQueue<TQ>(qs: array of TQ; last: CommandQueueNil) := QueueArrayUtils.ConstructSync&<CommandQueueNil>(qs.Cast&<CommandQueueBase>.Append&<CommandQueueBase>(last));
function CombineSyncQueue<T, TQ>(qs: array of TQ; last: CommandQueue<T>) := QueueArrayUtils.ConstructSync&<CommandQueue<T>>(qs.Cast&<CommandQueueBase>.Append&<CommandQueueBase>(last));

{$endregion Simple}

{$region Conv}

{$region NonContext}

function CombineConvSyncQueue<TInp, TRes>(conv: Func<array of TInp, TRes>; qs: array of CommandQueue<TInp>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if qs.All(q->q.IsConstResDepEmpty) then
  begin
    var inp := qs.ConvertAll(q->q.expected_const_res);
    Result := if can_pre_calc then
      CQ(conv(inp)) else
      HFQ(()->conv(inp), need_own_thread);
    Result := CombineSyncQueue(qs, Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray<TInp, TRes, QueueArraySyncInvoker, SimpleFuncContainer<array of TInp, TRes>>(qs.ToArray, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray   <TInp, TRes, QueueArraySyncInvoker, SimpleFuncContainer<array of TInp, TRes>>(qs.ToArray, conv, can_pre_calc);
end;

function CombineConvSyncQueueN2<TInp1,TInp2, TRes>(conv: Func<TInp1, TInp2, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2)) else
      HFQ(()->conv(inp1,inp2), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray2<TInp1,TInp2, TRes, QueueArray2SyncInvoker, SimpleFunc2Container<TInp1, TInp2, TRes>>(q1,q2, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray2   <TInp1,TInp2, TRes, QueueArray2SyncInvoker, SimpleFunc2Container<TInp1, TInp2, TRes>>(q1,q2, conv, can_pre_calc);
end;
function CombineConvSyncQueueN3<TInp1,TInp2,TInp3, TRes>(conv: Func<TInp1, TInp2, TInp3, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3)) else
      HFQ(()->conv(inp1,inp2,inp3), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray3<TInp1,TInp2,TInp3, TRes, QueueArray3SyncInvoker, SimpleFunc3Container<TInp1, TInp2, TInp3, TRes>>(q1,q2,q3, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray3   <TInp1,TInp2,TInp3, TRes, QueueArray3SyncInvoker, SimpleFunc3Container<TInp1, TInp2, TInp3, TRes>>(q1,q2,q3, conv, can_pre_calc);
end;
function CombineConvSyncQueueN4<TInp1,TInp2,TInp3,TInp4, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4)) else
      HFQ(()->conv(inp1,inp2,inp3,inp4), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray4<TInp1,TInp2,TInp3,TInp4, TRes, QueueArray4SyncInvoker, SimpleFunc4Container<TInp1, TInp2, TInp3, TInp4, TRes>>(q1,q2,q3,q4, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray4   <TInp1,TInp2,TInp3,TInp4, TRes, QueueArray4SyncInvoker, SimpleFunc4Container<TInp1, TInp2, TInp3, TInp4, TRes>>(q1,q2,q3,q4, conv, can_pre_calc);
end;
function CombineConvSyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5)) else
      HFQ(()->conv(inp1,inp2,inp3,inp4,inp5), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes, QueueArray5SyncInvoker, SimpleFunc5Container<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>>(q1,q2,q3,q4,q5, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray5   <TInp1,TInp2,TInp3,TInp4,TInp5, TRes, QueueArray5SyncInvoker, SimpleFunc5Container<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>>(q1,q2,q3,q4,q5, conv, can_pre_calc);
end;
function CombineConvSyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5,inp6)) else
      HFQ(()->conv(inp1,inp2,inp3,inp4,inp5,inp6), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes, QueueArray6SyncInvoker, SimpleFunc6Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>>(q1,q2,q3,q4,q5,q6, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray6   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes, QueueArray6SyncInvoker, SimpleFunc6Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>>(q1,q2,q3,q4,q5,q6, conv, can_pre_calc);
end;
function CombineConvSyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty and q7.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    var inp7 := q7.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5,inp6,inp7)) else
      HFQ(()->conv(inp1,inp2,inp3,inp4,inp5,inp6,inp7), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6,q7), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes, QueueArray7SyncInvoker, SimpleFunc7Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>>(q1,q2,q3,q4,q5,q6,q7, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray7   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes, QueueArray7SyncInvoker, SimpleFunc7Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>>(q1,q2,q3,q4,q5,q6,q7, conv, can_pre_calc);
end;

{$endregion NonContext}

{$region Context}

function CombineConvSyncQueue<TInp, TRes>(conv: Func<array of TInp, CLContext, TRes>; qs: array of CommandQueue<TInp>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if qs.All(q->q.IsConstResDepEmpty) then
  begin
    var inp := qs.ConvertAll(q->q.expected_const_res);
    Result := if can_pre_calc then
      CQ(conv(inp, nil)) else
      HFQ(c->conv(inp, c), need_own_thread);
    Result := CombineSyncQueue(qs, Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray<TInp, TRes, QueueArraySyncInvoker, SimpleFuncContainerC<array of TInp, TRes>>(qs.ToArray, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray   <TInp, TRes, QueueArraySyncInvoker, SimpleFuncContainerC<array of TInp, TRes>>(qs.ToArray, conv, can_pre_calc);
end;

function CombineConvSyncQueueN2<TInp1,TInp2, TRes>(conv: Func<TInp1, TInp2, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2, nil)) else
      HFQ(c->conv(inp1,inp2, c), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray2<TInp1,TInp2, TRes, QueueArray2SyncInvoker, SimpleFunc2ContainerC<TInp1, TInp2, TRes>>(q1,q2, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray2   <TInp1,TInp2, TRes, QueueArray2SyncInvoker, SimpleFunc2ContainerC<TInp1, TInp2, TRes>>(q1,q2, conv, can_pre_calc);
end;
function CombineConvSyncQueueN3<TInp1,TInp2,TInp3, TRes>(conv: Func<TInp1, TInp2, TInp3, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3, nil)) else
      HFQ(c->conv(inp1,inp2,inp3, c), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray3<TInp1,TInp2,TInp3, TRes, QueueArray3SyncInvoker, SimpleFunc3ContainerC<TInp1, TInp2, TInp3, TRes>>(q1,q2,q3, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray3   <TInp1,TInp2,TInp3, TRes, QueueArray3SyncInvoker, SimpleFunc3ContainerC<TInp1, TInp2, TInp3, TRes>>(q1,q2,q3, conv, can_pre_calc);
end;
function CombineConvSyncQueueN4<TInp1,TInp2,TInp3,TInp4, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4, nil)) else
      HFQ(c->conv(inp1,inp2,inp3,inp4, c), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray4<TInp1,TInp2,TInp3,TInp4, TRes, QueueArray4SyncInvoker, SimpleFunc4ContainerC<TInp1, TInp2, TInp3, TInp4, TRes>>(q1,q2,q3,q4, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray4   <TInp1,TInp2,TInp3,TInp4, TRes, QueueArray4SyncInvoker, SimpleFunc4ContainerC<TInp1, TInp2, TInp3, TInp4, TRes>>(q1,q2,q3,q4, conv, can_pre_calc);
end;
function CombineConvSyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5, nil)) else
      HFQ(c->conv(inp1,inp2,inp3,inp4,inp5, c), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes, QueueArray5SyncInvoker, SimpleFunc5ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>>(q1,q2,q3,q4,q5, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray5   <TInp1,TInp2,TInp3,TInp4,TInp5, TRes, QueueArray5SyncInvoker, SimpleFunc5ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>>(q1,q2,q3,q4,q5, conv, can_pre_calc);
end;
function CombineConvSyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5,inp6, nil)) else
      HFQ(c->conv(inp1,inp2,inp3,inp4,inp5,inp6, c), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes, QueueArray6SyncInvoker, SimpleFunc6ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>>(q1,q2,q3,q4,q5,q6, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray6   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes, QueueArray6SyncInvoker, SimpleFunc6ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>>(q1,q2,q3,q4,q5,q6, conv, can_pre_calc);
end;
function CombineConvSyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty and q7.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    var inp7 := q7.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5,inp6,inp7, nil)) else
      HFQ(c->conv(inp1,inp2,inp3,inp4,inp5,inp6,inp7, c), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6,q7), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes, QueueArray7SyncInvoker, SimpleFunc7ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>>(q1,q2,q3,q4,q5,q6,q7, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray7   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes, QueueArray7SyncInvoker, SimpleFunc7ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>>(q1,q2,q3,q4,q5,q6,q7, conv, can_pre_calc);
end;

{$endregion Context}

{$endregion Conv}

{$region Use}

{$region NonContext}

function CombineUseSyncQueue<TInp>(use: Action<array of TInp>; qs: array of CommandQueue<TInp>; need_own_thread, can_pre_calc: boolean): CommandQueue<array of TInp>;
begin
  if qs.All(q->q.IsConstResDepEmpty) then
  begin
    var inp := qs.ConvertAll(q->q.expected_const_res);
    Result := CQ(inp);
    if can_pre_calc then
      use(inp) else
      Result := HPQ(()->use(inp), need_own_thread) + Result;
    Result := CombineSyncQueue(qs, Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray<TInp, QueueArraySyncInvoker, SimpleProcContainer<array of TInp>>(qs.ToArray, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray   <TInp, QueueArraySyncInvoker, SimpleProcContainer<array of TInp>>(qs.ToArray, use, can_pre_calc);
end;

function CombineUseSyncQueueN2<TInp1,TInp2>(use: Action<TInp1, TInp2>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2));
    if can_pre_calc then
      use(inp1,inp2) else
      Result := HPQ(()->use(inp1,inp2), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray2<TInp1,TInp2, QueueArray2SyncInvoker, SimpleProc2Container<TInp1, TInp2>>(q1,q2, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray2   <TInp1,TInp2, QueueArray2SyncInvoker, SimpleProc2Container<TInp1, TInp2>>(q1,q2, use, can_pre_calc);
end;
function CombineUseSyncQueueN3<TInp1,TInp2,TInp3>(use: Action<TInp1, TInp2, TInp3>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3));
    if can_pre_calc then
      use(inp1,inp2,inp3) else
      Result := HPQ(()->use(inp1,inp2,inp3), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray3<TInp1,TInp2,TInp3, QueueArray3SyncInvoker, SimpleProc3Container<TInp1, TInp2, TInp3>>(q1,q2,q3, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray3   <TInp1,TInp2,TInp3, QueueArray3SyncInvoker, SimpleProc3Container<TInp1, TInp2, TInp3>>(q1,q2,q3, use, can_pre_calc);
end;
function CombineUseSyncQueueN4<TInp1,TInp2,TInp3,TInp4>(use: Action<TInp1, TInp2, TInp3, TInp4>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4) else
      Result := HPQ(()->use(inp1,inp2,inp3,inp4), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray4<TInp1,TInp2,TInp3,TInp4, QueueArray4SyncInvoker, SimpleProc4Container<TInp1, TInp2, TInp3, TInp4>>(q1,q2,q3,q4, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray4   <TInp1,TInp2,TInp3,TInp4, QueueArray4SyncInvoker, SimpleProc4Container<TInp1, TInp2, TInp3, TInp4>>(q1,q2,q3,q4, use, can_pre_calc);
end;
function CombineUseSyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5) else
      Result := HPQ(()->use(inp1,inp2,inp3,inp4,inp5), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5, QueueArray5SyncInvoker, SimpleProc5Container<TInp1, TInp2, TInp3, TInp4, TInp5>>(q1,q2,q3,q4,q5, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray5   <TInp1,TInp2,TInp3,TInp4,TInp5, QueueArray5SyncInvoker, SimpleProc5Container<TInp1, TInp2, TInp3, TInp4, TInp5>>(q1,q2,q3,q4,q5, use, can_pre_calc);
end;
function CombineUseSyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5, inp6));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5,inp6) else
      Result := HPQ(()->use(inp1,inp2,inp3,inp4,inp5,inp6), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, QueueArray6SyncInvoker, SimpleProc6Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(q1,q2,q3,q4,q5,q6, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray6   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, QueueArray6SyncInvoker, SimpleProc6Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(q1,q2,q3,q4,q5,q6, use, can_pre_calc);
end;
function CombineUseSyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty and q7.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    var inp7 := q7.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5, inp6, inp7));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5,inp6,inp7) else
      Result := HPQ(()->use(inp1,inp2,inp3,inp4,inp5,inp6,inp7), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6,q7), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, QueueArray7SyncInvoker, SimpleProc7Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>>(q1,q2,q3,q4,q5,q6,q7, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray7   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, QueueArray7SyncInvoker, SimpleProc7Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>>(q1,q2,q3,q4,q5,q6,q7, use, can_pre_calc);
end;

{$endregion NonContext}

{$region Context}

function CombineUseSyncQueue<TInp>(use: Action<array of TInp, CLContext>; qs: array of CommandQueue<TInp>; need_own_thread, can_pre_calc: boolean): CommandQueue<array of TInp>;
begin
  if qs.All(q->q.IsConstResDepEmpty) then
  begin
    var inp := qs.ConvertAll(q->q.expected_const_res);
    Result := CQ(inp);
    if can_pre_calc then
      use(inp, nil) else
      Result := HPQ(c->use(inp, c), need_own_thread) + Result;
    Result := CombineSyncQueue(qs, Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray<TInp, QueueArraySyncInvoker, SimpleProcContainerC<array of TInp>>(qs.ToArray, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray   <TInp, QueueArraySyncInvoker, SimpleProcContainerC<array of TInp>>(qs.ToArray, use, can_pre_calc);
end;

function CombineUseSyncQueueN2<TInp1,TInp2>(use: Action<TInp1, TInp2, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2));
    if can_pre_calc then
      use(inp1,inp2, nil) else
      Result := HPQ(c->use(inp1,inp2, c), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray2<TInp1,TInp2, QueueArray2SyncInvoker, SimpleProc2ContainerC<TInp1, TInp2>>(q1,q2, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray2   <TInp1,TInp2, QueueArray2SyncInvoker, SimpleProc2ContainerC<TInp1, TInp2>>(q1,q2, use, can_pre_calc);
end;
function CombineUseSyncQueueN3<TInp1,TInp2,TInp3>(use: Action<TInp1, TInp2, TInp3, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3));
    if can_pre_calc then
      use(inp1,inp2,inp3, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3, c), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray3<TInp1,TInp2,TInp3, QueueArray3SyncInvoker, SimpleProc3ContainerC<TInp1, TInp2, TInp3>>(q1,q2,q3, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray3   <TInp1,TInp2,TInp3, QueueArray3SyncInvoker, SimpleProc3ContainerC<TInp1, TInp2, TInp3>>(q1,q2,q3, use, can_pre_calc);
end;
function CombineUseSyncQueueN4<TInp1,TInp2,TInp3,TInp4>(use: Action<TInp1, TInp2, TInp3, TInp4, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3,inp4, c), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray4<TInp1,TInp2,TInp3,TInp4, QueueArray4SyncInvoker, SimpleProc4ContainerC<TInp1, TInp2, TInp3, TInp4>>(q1,q2,q3,q4, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray4   <TInp1,TInp2,TInp3,TInp4, QueueArray4SyncInvoker, SimpleProc4ContainerC<TInp1, TInp2, TInp3, TInp4>>(q1,q2,q3,q4, use, can_pre_calc);
end;
function CombineUseSyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3,inp4,inp5, c), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5, QueueArray5SyncInvoker, SimpleProc5ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5>>(q1,q2,q3,q4,q5, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray5   <TInp1,TInp2,TInp3,TInp4,TInp5, QueueArray5SyncInvoker, SimpleProc5ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5>>(q1,q2,q3,q4,q5, use, can_pre_calc);
end;
function CombineUseSyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5, inp6));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5,inp6, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3,inp4,inp5,inp6, c), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, QueueArray6SyncInvoker, SimpleProc6ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(q1,q2,q3,q4,q5,q6, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray6   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, QueueArray6SyncInvoker, SimpleProc6ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(q1,q2,q3,q4,q5,q6, use, can_pre_calc);
end;
function CombineUseSyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty and q7.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    var inp7 := q7.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5, inp6, inp7));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5,inp6,inp7, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3,inp4,inp5,inp6,inp7, c), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6,q7), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, QueueArray7SyncInvoker, SimpleProc7ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>>(q1,q2,q3,q4,q5,q6,q7, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray7   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, QueueArray7SyncInvoker, SimpleProc7ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>>(q1,q2,q3,q4,q5,q6,q7, use, can_pre_calc);
end;

{$endregion Context}

{$endregion Use}

{$endregion Sync}

{$region Async}

{$region Simple}

function CombineAsyncQueue(params qs: array of CommandQueueBase) := QueueArrayUtils.ConstructAsync&<CommandQueueBase>(qs.Cast&<CommandQueueBase>);
function CombineAsyncQueue(params qs: array of CommandQueueNil) := QueueArrayUtils.ConstructAsync&<CommandQueueNil>(qs.Cast&<CommandQueueBase>);
function CombineAsyncQueue<T>(params qs: array of CommandQueue<T>) := QueueArrayUtils.ConstructAsync&<CommandQueue<T>>(qs.Cast&<CommandQueueBase>);

function CombineAsyncQueue<TQ>(qs: array of TQ; last: CommandQueueBase) := QueueArrayUtils.ConstructAsync&<CommandQueueBase>(qs.Cast&<CommandQueueBase>.Append&<CommandQueueBase>(last));
function CombineAsyncQueue<TQ>(qs: array of TQ; last: CommandQueueNil) := QueueArrayUtils.ConstructAsync&<CommandQueueNil>(qs.Cast&<CommandQueueBase>.Append&<CommandQueueBase>(last));
function CombineAsyncQueue<T, TQ>(qs: array of TQ; last: CommandQueue<T>) := QueueArrayUtils.ConstructAsync&<CommandQueue<T>>(qs.Cast&<CommandQueueBase>.Append&<CommandQueueBase>(last));

{$endregion Simple}

{$region Conv}

{$region NonContext}

function CombineConvAsyncQueue<TInp, TRes>(conv: Func<array of TInp, TRes>; qs: array of CommandQueue<TInp>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if qs.All(q->q.IsConstResDepEmpty) then
  begin
    var inp := qs.ConvertAll(q->q.expected_const_res);
    Result := if can_pre_calc then
      CQ(conv(inp)) else
      HFQ(()->conv(inp), need_own_thread);
    Result := CombineAsyncQueue(qs, Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray<TInp, TRes, QueueArrayAsyncInvoker, SimpleFuncContainer<array of TInp, TRes>>(qs.ToArray, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray   <TInp, TRes, QueueArrayAsyncInvoker, SimpleFuncContainer<array of TInp, TRes>>(qs.ToArray, conv, can_pre_calc);
end;

function CombineConvAsyncQueueN2<TInp1,TInp2, TRes>(conv: Func<TInp1, TInp2, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2)) else
      HFQ(()->conv(inp1,inp2), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray2<TInp1,TInp2, TRes, QueueArray2AsyncInvoker, SimpleFunc2Container<TInp1, TInp2, TRes>>(q1,q2, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray2   <TInp1,TInp2, TRes, QueueArray2AsyncInvoker, SimpleFunc2Container<TInp1, TInp2, TRes>>(q1,q2, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN3<TInp1,TInp2,TInp3, TRes>(conv: Func<TInp1, TInp2, TInp3, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3)) else
      HFQ(()->conv(inp1,inp2,inp3), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray3<TInp1,TInp2,TInp3, TRes, QueueArray3AsyncInvoker, SimpleFunc3Container<TInp1, TInp2, TInp3, TRes>>(q1,q2,q3, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray3   <TInp1,TInp2,TInp3, TRes, QueueArray3AsyncInvoker, SimpleFunc3Container<TInp1, TInp2, TInp3, TRes>>(q1,q2,q3, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN4<TInp1,TInp2,TInp3,TInp4, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4)) else
      HFQ(()->conv(inp1,inp2,inp3,inp4), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray4<TInp1,TInp2,TInp3,TInp4, TRes, QueueArray4AsyncInvoker, SimpleFunc4Container<TInp1, TInp2, TInp3, TInp4, TRes>>(q1,q2,q3,q4, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray4   <TInp1,TInp2,TInp3,TInp4, TRes, QueueArray4AsyncInvoker, SimpleFunc4Container<TInp1, TInp2, TInp3, TInp4, TRes>>(q1,q2,q3,q4, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5)) else
      HFQ(()->conv(inp1,inp2,inp3,inp4,inp5), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes, QueueArray5AsyncInvoker, SimpleFunc5Container<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>>(q1,q2,q3,q4,q5, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray5   <TInp1,TInp2,TInp3,TInp4,TInp5, TRes, QueueArray5AsyncInvoker, SimpleFunc5Container<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>>(q1,q2,q3,q4,q5, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5,inp6)) else
      HFQ(()->conv(inp1,inp2,inp3,inp4,inp5,inp6), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes, QueueArray6AsyncInvoker, SimpleFunc6Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>>(q1,q2,q3,q4,q5,q6, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray6   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes, QueueArray6AsyncInvoker, SimpleFunc6Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>>(q1,q2,q3,q4,q5,q6, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty and q7.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    var inp7 := q7.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5,inp6,inp7)) else
      HFQ(()->conv(inp1,inp2,inp3,inp4,inp5,inp6,inp7), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6,q7), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes, QueueArray7AsyncInvoker, SimpleFunc7Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>>(q1,q2,q3,q4,q5,q6,q7, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray7   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes, QueueArray7AsyncInvoker, SimpleFunc7Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>>(q1,q2,q3,q4,q5,q6,q7, conv, can_pre_calc);
end;

{$endregion NonContext}

{$region Context}

function CombineConvAsyncQueue<TInp, TRes>(conv: Func<array of TInp, CLContext, TRes>; qs: array of CommandQueue<TInp>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if qs.All(q->q.IsConstResDepEmpty) then
  begin
    var inp := qs.ConvertAll(q->q.expected_const_res);
    Result := if can_pre_calc then
      CQ(conv(inp, nil)) else
      HFQ(c->conv(inp, c), need_own_thread);
    Result := CombineAsyncQueue(qs, Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray<TInp, TRes, QueueArrayAsyncInvoker, SimpleFuncContainerC<array of TInp, TRes>>(qs.ToArray, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray   <TInp, TRes, QueueArrayAsyncInvoker, SimpleFuncContainerC<array of TInp, TRes>>(qs.ToArray, conv, can_pre_calc);
end;

function CombineConvAsyncQueueN2<TInp1,TInp2, TRes>(conv: Func<TInp1, TInp2, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2, nil)) else
      HFQ(c->conv(inp1,inp2, c), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray2<TInp1,TInp2, TRes, QueueArray2AsyncInvoker, SimpleFunc2ContainerC<TInp1, TInp2, TRes>>(q1,q2, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray2   <TInp1,TInp2, TRes, QueueArray2AsyncInvoker, SimpleFunc2ContainerC<TInp1, TInp2, TRes>>(q1,q2, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN3<TInp1,TInp2,TInp3, TRes>(conv: Func<TInp1, TInp2, TInp3, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3, nil)) else
      HFQ(c->conv(inp1,inp2,inp3, c), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray3<TInp1,TInp2,TInp3, TRes, QueueArray3AsyncInvoker, SimpleFunc3ContainerC<TInp1, TInp2, TInp3, TRes>>(q1,q2,q3, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray3   <TInp1,TInp2,TInp3, TRes, QueueArray3AsyncInvoker, SimpleFunc3ContainerC<TInp1, TInp2, TInp3, TRes>>(q1,q2,q3, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN4<TInp1,TInp2,TInp3,TInp4, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4, nil)) else
      HFQ(c->conv(inp1,inp2,inp3,inp4, c), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray4<TInp1,TInp2,TInp3,TInp4, TRes, QueueArray4AsyncInvoker, SimpleFunc4ContainerC<TInp1, TInp2, TInp3, TInp4, TRes>>(q1,q2,q3,q4, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray4   <TInp1,TInp2,TInp3,TInp4, TRes, QueueArray4AsyncInvoker, SimpleFunc4ContainerC<TInp1, TInp2, TInp3, TInp4, TRes>>(q1,q2,q3,q4, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5, nil)) else
      HFQ(c->conv(inp1,inp2,inp3,inp4,inp5, c), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes, QueueArray5AsyncInvoker, SimpleFunc5ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>>(q1,q2,q3,q4,q5, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray5   <TInp1,TInp2,TInp3,TInp4,TInp5, TRes, QueueArray5AsyncInvoker, SimpleFunc5ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>>(q1,q2,q3,q4,q5, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5,inp6, nil)) else
      HFQ(c->conv(inp1,inp2,inp3,inp4,inp5,inp6, c), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes, QueueArray6AsyncInvoker, SimpleFunc6ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>>(q1,q2,q3,q4,q5,q6, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray6   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes, QueueArray6AsyncInvoker, SimpleFunc6ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>>(q1,q2,q3,q4,q5,q6, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty and q7.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    var inp7 := q7.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5,inp6,inp7, nil)) else
      HFQ(c->conv(inp1,inp2,inp3,inp4,inp5,inp6,inp7, c), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6,q7), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes, QueueArray7AsyncInvoker, SimpleFunc7ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>>(q1,q2,q3,q4,q5,q6,q7, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray7   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes, QueueArray7AsyncInvoker, SimpleFunc7ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>>(q1,q2,q3,q4,q5,q6,q7, conv, can_pre_calc);
end;

{$endregion Context}

{$endregion Conv}

{$region Use}

{$region NonContext}

function CombineUseAsyncQueue<TInp>(use: Action<array of TInp>; qs: array of CommandQueue<TInp>; need_own_thread, can_pre_calc: boolean): CommandQueue<array of TInp>;
begin
  if qs.All(q->q.IsConstResDepEmpty) then
  begin
    var inp := qs.ConvertAll(q->q.expected_const_res);
    Result := CQ(inp);
    if can_pre_calc then
      use(inp) else
      Result := HPQ(()->use(inp), need_own_thread) + Result;
    Result := CombineAsyncQueue(qs, Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray<TInp, QueueArrayAsyncInvoker, SimpleProcContainer<array of TInp>>(qs.ToArray, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray   <TInp, QueueArrayAsyncInvoker, SimpleProcContainer<array of TInp>>(qs.ToArray, use, can_pre_calc);
end;

function CombineUseAsyncQueueN2<TInp1,TInp2>(use: Action<TInp1, TInp2>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2));
    if can_pre_calc then
      use(inp1,inp2) else
      Result := HPQ(()->use(inp1,inp2), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray2<TInp1,TInp2, QueueArray2AsyncInvoker, SimpleProc2Container<TInp1, TInp2>>(q1,q2, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray2   <TInp1,TInp2, QueueArray2AsyncInvoker, SimpleProc2Container<TInp1, TInp2>>(q1,q2, use, can_pre_calc);
end;
function CombineUseAsyncQueueN3<TInp1,TInp2,TInp3>(use: Action<TInp1, TInp2, TInp3>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3));
    if can_pre_calc then
      use(inp1,inp2,inp3) else
      Result := HPQ(()->use(inp1,inp2,inp3), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray3<TInp1,TInp2,TInp3, QueueArray3AsyncInvoker, SimpleProc3Container<TInp1, TInp2, TInp3>>(q1,q2,q3, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray3   <TInp1,TInp2,TInp3, QueueArray3AsyncInvoker, SimpleProc3Container<TInp1, TInp2, TInp3>>(q1,q2,q3, use, can_pre_calc);
end;
function CombineUseAsyncQueueN4<TInp1,TInp2,TInp3,TInp4>(use: Action<TInp1, TInp2, TInp3, TInp4>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4) else
      Result := HPQ(()->use(inp1,inp2,inp3,inp4), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray4<TInp1,TInp2,TInp3,TInp4, QueueArray4AsyncInvoker, SimpleProc4Container<TInp1, TInp2, TInp3, TInp4>>(q1,q2,q3,q4, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray4   <TInp1,TInp2,TInp3,TInp4, QueueArray4AsyncInvoker, SimpleProc4Container<TInp1, TInp2, TInp3, TInp4>>(q1,q2,q3,q4, use, can_pre_calc);
end;
function CombineUseAsyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5) else
      Result := HPQ(()->use(inp1,inp2,inp3,inp4,inp5), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5, QueueArray5AsyncInvoker, SimpleProc5Container<TInp1, TInp2, TInp3, TInp4, TInp5>>(q1,q2,q3,q4,q5, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray5   <TInp1,TInp2,TInp3,TInp4,TInp5, QueueArray5AsyncInvoker, SimpleProc5Container<TInp1, TInp2, TInp3, TInp4, TInp5>>(q1,q2,q3,q4,q5, use, can_pre_calc);
end;
function CombineUseAsyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5, inp6));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5,inp6) else
      Result := HPQ(()->use(inp1,inp2,inp3,inp4,inp5,inp6), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, QueueArray6AsyncInvoker, SimpleProc6Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(q1,q2,q3,q4,q5,q6, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray6   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, QueueArray6AsyncInvoker, SimpleProc6Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(q1,q2,q3,q4,q5,q6, use, can_pre_calc);
end;
function CombineUseAsyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty and q7.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    var inp7 := q7.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5, inp6, inp7));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5,inp6,inp7) else
      Result := HPQ(()->use(inp1,inp2,inp3,inp4,inp5,inp6,inp7), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6,q7), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, QueueArray7AsyncInvoker, SimpleProc7Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>>(q1,q2,q3,q4,q5,q6,q7, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray7   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, QueueArray7AsyncInvoker, SimpleProc7Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>>(q1,q2,q3,q4,q5,q6,q7, use, can_pre_calc);
end;

{$endregion NonContext}

{$region Context}

function CombineUseAsyncQueue<TInp>(use: Action<array of TInp, CLContext>; qs: array of CommandQueue<TInp>; need_own_thread, can_pre_calc: boolean): CommandQueue<array of TInp>;
begin
  if qs.All(q->q.IsConstResDepEmpty) then
  begin
    var inp := qs.ConvertAll(q->q.expected_const_res);
    Result := CQ(inp);
    if can_pre_calc then
      use(inp, nil) else
      Result := HPQ(c->use(inp, c), need_own_thread) + Result;
    Result := CombineAsyncQueue(qs, Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray<TInp, QueueArrayAsyncInvoker, SimpleProcContainerC<array of TInp>>(qs.ToArray, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray   <TInp, QueueArrayAsyncInvoker, SimpleProcContainerC<array of TInp>>(qs.ToArray, use, can_pre_calc);
end;

function CombineUseAsyncQueueN2<TInp1,TInp2>(use: Action<TInp1, TInp2, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2));
    if can_pre_calc then
      use(inp1,inp2, nil) else
      Result := HPQ(c->use(inp1,inp2, c), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray2<TInp1,TInp2, QueueArray2AsyncInvoker, SimpleProc2ContainerC<TInp1, TInp2>>(q1,q2, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray2   <TInp1,TInp2, QueueArray2AsyncInvoker, SimpleProc2ContainerC<TInp1, TInp2>>(q1,q2, use, can_pre_calc);
end;
function CombineUseAsyncQueueN3<TInp1,TInp2,TInp3>(use: Action<TInp1, TInp2, TInp3, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3));
    if can_pre_calc then
      use(inp1,inp2,inp3, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3, c), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray3<TInp1,TInp2,TInp3, QueueArray3AsyncInvoker, SimpleProc3ContainerC<TInp1, TInp2, TInp3>>(q1,q2,q3, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray3   <TInp1,TInp2,TInp3, QueueArray3AsyncInvoker, SimpleProc3ContainerC<TInp1, TInp2, TInp3>>(q1,q2,q3, use, can_pre_calc);
end;
function CombineUseAsyncQueueN4<TInp1,TInp2,TInp3,TInp4>(use: Action<TInp1, TInp2, TInp3, TInp4, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3,inp4, c), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray4<TInp1,TInp2,TInp3,TInp4, QueueArray4AsyncInvoker, SimpleProc4ContainerC<TInp1, TInp2, TInp3, TInp4>>(q1,q2,q3,q4, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray4   <TInp1,TInp2,TInp3,TInp4, QueueArray4AsyncInvoker, SimpleProc4ContainerC<TInp1, TInp2, TInp3, TInp4>>(q1,q2,q3,q4, use, can_pre_calc);
end;
function CombineUseAsyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3,inp4,inp5, c), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5, QueueArray5AsyncInvoker, SimpleProc5ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5>>(q1,q2,q3,q4,q5, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray5   <TInp1,TInp2,TInp3,TInp4,TInp5, QueueArray5AsyncInvoker, SimpleProc5ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5>>(q1,q2,q3,q4,q5, use, can_pre_calc);
end;
function CombineUseAsyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5, inp6));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5,inp6, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3,inp4,inp5,inp6, c), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, QueueArray6AsyncInvoker, SimpleProc6ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(q1,q2,q3,q4,q5,q6, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray6   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, QueueArray6AsyncInvoker, SimpleProc6ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(q1,q2,q3,q4,q5,q6, use, can_pre_calc);
end;
function CombineUseAsyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty and q7.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    var inp7 := q7.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5, inp6, inp7));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5,inp6,inp7, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3,inp4,inp5,inp6,inp7, c), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6,q7), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, QueueArray7AsyncInvoker, SimpleProc7ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>>(q1,q2,q3,q4,q5,q6,q7, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray7   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, QueueArray7AsyncInvoker, SimpleProc7ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>>(q1,q2,q3,q4,q5,q6,q7, use, can_pre_calc);
end;

{$endregion Context}

{$endregion Use}

{$endregion Async}


