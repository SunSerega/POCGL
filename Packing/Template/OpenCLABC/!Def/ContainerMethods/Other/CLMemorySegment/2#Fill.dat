


# FillValue![%AutoSize:AutoSize,%][%Q:,Q%]
val: {%Q?TRecord:CommandQueue<TRecord>%}{%AutoSize?:; mem_offset, fill_byte_len\: CommandQueue<integer>%}
!Enqueue
var ec := cl.EnqueueFillBuffer(
  cq, o.Native,
  new IntPtr(!val:ptr!), new UIntPtr(Marshal.SizeOf&<TRecord>),
  {%AutoSize? UIntPtr.Zero, o.Size : new UIntPtr(!mem_offset!), new UIntPtr(!fill_byte_len!) %},
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);



# FillArray[%rank:1,2,3%]!AutoSize
a: array{%rank? : [,] : [,,] %} of TRecord
!ShortDef
FillArray{%rank%}(CQ(a));

# FillArray[%rank:1,2,3%]
a: array{%rank? : [,] : [,,] %} of TRecord; {%rank? a_ind : a_ind1,a_ind2 : a_ind1,a_ind2,a_ind3 %}, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>
!ShortDef
FillArray{%rank%}(CQ(a), {%rank? a_ind : a_ind1,a_ind2 : a_ind1,a_ind2,a_ind3 %}, pattern_byte_len, mem_offset, fill_byte_len);

# FillArray[%rank:1,2,3%]!AutoSize
a: CommandQueue<array{%rank? : [,] : [,,] %} of TRecord>
!Enqueue
//TODO unable to merge this Enqueue with non-AutoSize, because %rank would be nested in %AutoSize
var ec := cl.EnqueueFillBuffer(
  cq, o.Native,
  !a:pinn![{%rank? 0 : 0,0 : 0,0,0 %}], new UIntPtr(!a:pinn!.Length*Marshal.SizeOf&<TRecord>),
  UIntPtr.Zero, o.Size,
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);

# FillArray[%rank:1,2,3%]
a: CommandQueue<array{%rank? : [,] : [,,] %} of TRecord>; {%rank? a_ind : a_ind1,a_ind2 : a_ind1,a_ind2,a_ind3 %}, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>
!Enqueue
var ec := cl.EnqueueFillBuffer(
  cq, o.Native,
  !a:pinn![{%rank? !a_ind! : !a_ind1!,!a_ind2! : !a_ind1!,!a_ind2!,!a_ind3! %}], new UIntPtr(!pattern_byte_len!),
  new UIntPtr(!mem_offset!), new UIntPtr(!fill_byte_len!),
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);



# FillArraySegment![%AutoSize:AutoSize,%]
a: ArraySegment<TRecord>{%AutoSize?: ; mem_offset, fill_byte_len\: CommandQueue<integer> %}
!Enqueue
var ec := cl.EnqueueFillBuffer(
  cq, o.Native,
  !a:pinn!.Array[!a:pinn!.Offset], new UIntPtr(!a:pinn!.Count * Marshal.SizeOf&<TRecord>),
  {%AutoSize? UIntPtr.Zero,o.Size : new UIntPtr(!mem_offset!),new UIntPtr(!fill_byte_len!) %},
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);










# FillData![%AutoSize:AutoSize,%]
ptr: CommandQueue<IntPtr>; pattern_byte_len{%AutoSize?:, mem_offset, fill_byte_len%}: CommandQueue<integer>
!Enqueue
var ec := cl.EnqueueFillBuffer(
  cq, o.Native,
  !ptr!, new UIntPtr(!pattern_byte_len!),
  {%AutoSize? UIntPtr.Zero, o.Size : new UIntPtr(!mem_offset!), new UIntPtr(!fill_byte_len!) %},
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);

# FillData![%AutoSize:AutoSize,%]
ptr: pointer; pattern_byte_len{%AutoSize?:, mem_offset, fill_byte_len%}: CommandQueue<integer>
!ShortDef
FillData(IntPtr(ptr), pattern_byte_len{%AutoSize?:, mem_offset, fill_byte_len%});



# FillNative[%MemT:Memory,Value,Array%][%Area:Area,%]![%AutoSize:AutoSize,%]
native_data: Native{%MemT%}{%Area%}{%MemT?:<TRecord>:<TRecord>%}{%AutoSize?: ; mem_offset, fill_byte_len\: CommandQueue<integer> %}
!ShortDef
FillNative{%MemT%}{%Area%}(CQ(native_data){%AutoSize?: ,mem_offset,fill_byte_len %});

# FillNative[%MemT:Memory,Value,Array%][%Area:Area,%]![%AutoSize:AutoSize,%]
native_data: CommandQueue<Native{%MemT%}{%Area%}{%MemT?:<TRecord>:<TRecord>%}>{%AutoSize?: ; mem_offset, fill_byte_len\: CommandQueue<integer> %}
!Enqueue
var ec := cl.EnqueueFillBuffer(
  cq, o.Native,
  !native_data!{%Area?:.Area%}.{%MemT?ptr:ptr:first_ptr%},
  !native_data!{%Area?:.Area%}.{%MemT?sz:ByteSize:ByteSize%},
  {%AutoSize? UIntPtr.Zero, o.Size : new UIntPtr(!mem_offset!), new UIntPtr(!fill_byte_len!) %},
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);


