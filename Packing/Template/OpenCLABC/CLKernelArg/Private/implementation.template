


{$region Managed}

{$region Array}

type
  CLKernelArgPrivateSetterArray<T> = sealed class(CLKernelArgSetterTyped<array of T>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, new UIntPtr(UInt32(self.o.Length)*uint64(Marshal.SizeOf(default(T)))), self.o[0]) );
    
  end;
  CLKernelArgPrivateArray<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<array of T>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:Array%');
    
    public constructor(a: CommandQueue<array of T>) :=
    data := new CLKernelArgPrivateCommon<array of T>(a);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<array of T>(var c_q) then
      new CLKernelArgPrivateSetterArray<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterArray<T>(o), ()->new CLKernelArgPrivateSetterArray<T>);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromArray<T>(a: CommandQueue<array of T>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateArray<T>(a) end;

{$endregion Array}

{$region Array2}

type
  CLKernelArgPrivateSetterArray2<T> = sealed class(CLKernelArgSetterTyped<array[,] of T>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, new UIntPtr(UInt32(self.o.Length)*uint64(Marshal.SizeOf(default(T)))), self.o[0,0]) );
    
  end;
  CLKernelArgPrivateArray2<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<array[,] of T>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:Array2%');
    
    public constructor(a2: CommandQueue<array[,] of T>) :=
    data := new CLKernelArgPrivateCommon<array[,] of T>(a2);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<array[,] of T>(var c_q) then
      new CLKernelArgPrivateSetterArray2<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterArray2<T>(o), ()->new CLKernelArgPrivateSetterArray2<T>);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromArray2<T>(a2: CommandQueue<array[,] of T>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateArray2<T>(a2) end;

{$endregion Array2}

{$region Array3}

type
  CLKernelArgPrivateSetterArray3<T> = sealed class(CLKernelArgSetterTyped<array[,,] of T>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, new UIntPtr(UInt32(self.o.Length)*uint64(Marshal.SizeOf(default(T)))), self.o[0,0,0]) );
    
  end;
  CLKernelArgPrivateArray3<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<array[,,] of T>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:Array3%');
    
    public constructor(a3: CommandQueue<array[,,] of T>) :=
    data := new CLKernelArgPrivateCommon<array[,,] of T>(a3);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<array[,,] of T>(var c_q) then
      new CLKernelArgPrivateSetterArray3<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterArray3<T>(o), ()->new CLKernelArgPrivateSetterArray3<T>);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromArray3<T>(a3: CommandQueue<array[,,] of T>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateArray3<T>(a3) end;

{$endregion Array3}

{$region ArraySegment}

type
  CLKernelArgPrivateSetterArraySegment<T> = sealed class(CLKernelArgSetterTyped<ArraySegment<T>>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, new UIntPtr(UInt32(self.o.Count)*uint64(Marshal.SizeOf(default(T)))), self.o.Array[self.o.Offset]) );
    
  end;
  CLKernelArgPrivateArraySegment<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<ArraySegment<T>>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:ArraySegment%');
    
    public constructor(seg: CommandQueue<ArraySegment<T>>) :=
    data := new CLKernelArgPrivateCommon<ArraySegment<T>>(seg);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<ArraySegment<T>>(var c_q) then
      new CLKernelArgPrivateSetterArraySegment<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterArraySegment<T>(o), ()->new CLKernelArgPrivateSetterArraySegment<T>);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromArraySegment<T>(seg: CommandQueue<ArraySegment<T>>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateArraySegment<T>(seg) end;

{$endregion ArraySegment}

{$endregion Managed}

{$region NativeArea}

{$region NativeMemoryArea}

type
  CLKernelArgPrivateSetterNativeMemoryArea = sealed class(CLKernelArgSetterTyped<NativeMemoryArea>)
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, self.o.sz, self.o.ptr) );
    
  end;
  CLKernelArgPrivateNativeMemoryArea = sealed class(CLKernelArgPrivate)
    private data: CLKernelArgPrivateCommon<NativeMemoryArea>;
    
    public constructor(ntv_mem_area: CommandQueue<NativeMemoryArea>) :=
    data := new CLKernelArgPrivateCommon<NativeMemoryArea>(ntv_mem_area);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<NativeMemoryArea>(var c_q) then
      new CLKernelArgPrivateSetterNativeMemoryArea(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterNativeMemoryArea(o), ()->new CLKernelArgPrivateSetterNativeMemoryArea);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromNativeMemoryArea(ntv_mem_area: CommandQueue<NativeMemoryArea>): CLKernelArgPrivate;
begin Result := new CLKernelArgPrivateNativeMemoryArea(ntv_mem_area) end;

{$endregion NativeMemoryArea}

{$region NativeValueArea}

type
  CLKernelArgPrivateSetterNativeValueArea<T> = sealed class(CLKernelArgSetterTyped<NativeValueArea<T>>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, self.o.ByteSize, self.o.ptr) );
    
  end;
  CLKernelArgPrivateNativeValueArea<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<NativeValueArea<T>>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:NativeValueArea%');
    
    public constructor(ntv_val_area: CommandQueue<NativeValueArea<T>>) :=
    data := new CLKernelArgPrivateCommon<NativeValueArea<T>>(ntv_val_area);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<NativeValueArea<T>>(var c_q) then
      new CLKernelArgPrivateSetterNativeValueArea<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterNativeValueArea<T>(o), ()->new CLKernelArgPrivateSetterNativeValueArea<T>);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromNativeValueArea<T>(ntv_val_area: CommandQueue<NativeValueArea<T>>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateNativeValueArea<T>(ntv_val_area) end;

{$endregion NativeValueArea}

{$region NativeArrayArea}

type
  CLKernelArgPrivateSetterNativeArrayArea<T> = sealed class(CLKernelArgSetterTyped<NativeArrayArea<T>>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, self.o.ByteSize, self.o.first_ptr) );
    
  end;
  CLKernelArgPrivateNativeArrayArea<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<NativeArrayArea<T>>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:NativeArrayArea%');
    
    public constructor(ntv_arr_area: CommandQueue<NativeArrayArea<T>>) :=
    data := new CLKernelArgPrivateCommon<NativeArrayArea<T>>(ntv_arr_area);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<NativeArrayArea<T>>(var c_q) then
      new CLKernelArgPrivateSetterNativeArrayArea<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterNativeArrayArea<T>(o), ()->new CLKernelArgPrivateSetterNativeArrayArea<T>);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromNativeArrayArea<T>(ntv_arr_area: CommandQueue<NativeArrayArea<T>>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateNativeArrayArea<T>(ntv_arr_area) end;

{$endregion NativeArrayArea}

{$endregion NativeArea}

{$region Native}

{$region NativeMemory}

type
  CLKernelArgPrivateSetterNativeMemory = sealed class(CLKernelArgSetterTyped<NativeMemory>)
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, self.o.Area.sz, self.o.Area.ptr) );
    
  end;
  CLKernelArgPrivateNativeMemory = sealed class(CLKernelArgPrivate)
    private data: CLKernelArgPrivateCommon<NativeMemory>;
    
    public constructor(ntv_mem: CommandQueue<NativeMemory>) :=
    data := new CLKernelArgPrivateCommon<NativeMemory>(ntv_mem);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<NativeMemory>(var c_q) then
      new CLKernelArgPrivateSetterNativeMemory(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterNativeMemory(o), ()->new CLKernelArgPrivateSetterNativeMemory);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromNativeMemory(ntv_mem: CommandQueue<NativeMemory>): CLKernelArgPrivate;
begin Result := new CLKernelArgPrivateNativeMemory(ntv_mem) end;

{$endregion NativeMemory}

{$region NativeValue}

type
  CLKernelArgPrivateSetterNativeValue<T> = sealed class(CLKernelArgSetterTyped<NativeValue<T>>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, self.o.Area.ByteSize, self.o.Area.ptr) );
    
  end;
  CLKernelArgPrivateNativeValue<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<NativeValue<T>>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:NativeValue%');
    
    public constructor(ntv_val: CommandQueue<NativeValue<T>>) :=
    data := new CLKernelArgPrivateCommon<NativeValue<T>>(ntv_val);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<NativeValue<T>>(var c_q) then
      new CLKernelArgPrivateSetterNativeValue<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterNativeValue<T>(o), ()->new CLKernelArgPrivateSetterNativeValue<T>);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromNativeValue<T>(ntv_val: CommandQueue<NativeValue<T>>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateNativeValue<T>(ntv_val) end;

{$endregion NativeValue}

{$region NativeArray}

type
  CLKernelArgPrivateSetterNativeArray<T> = sealed class(CLKernelArgSetterTyped<NativeArray<T>>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, self.o.Area.ByteSize, self.o.Area.first_ptr) );
    
  end;
  CLKernelArgPrivateNativeArray<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<NativeArray<T>>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:NativeArray%');
    
    public constructor(ntv_arr: CommandQueue<NativeArray<T>>) :=
    data := new CLKernelArgPrivateCommon<NativeArray<T>>(ntv_arr);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<NativeArray<T>>(var c_q) then
      new CLKernelArgPrivateSetterNativeArray<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterNativeArray<T>(o), ()->new CLKernelArgPrivateSetterNativeArray<T>);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromNativeArray<T>(ntv_arr: CommandQueue<NativeArray<T>>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateNativeArray<T>(ntv_arr) end;

{$endregion NativeArray}

{$endregion Native}

{$region Value}

type
  CLKernelArgPrivateSetterValue<T> = sealed class(CLKernelArgSetterTyped<T>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, new UIntPtr(Marshal.SizeOf(default(T))), self.o) );
    
  end;
  CLKernelArgPrivateValue<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<T>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:Value%');
    
    public constructor(val: CommandQueue<T>) :=
    data := new CLKernelArgPrivateCommon<T>(val);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<T>(var c_q) then
      new CLKernelArgPrivateSetterValue<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterValue<T>(o), ()->new CLKernelArgPrivateSetterValue<T>);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromValue<T>(val: CommandQueue<T>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateValue<T>(val) end;

{$endregion Value}


