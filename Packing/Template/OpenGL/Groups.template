  
  
  
  AccumOp = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACCUM:  AccumOp read new AccumOp($0100);
    public static property LOAD:   AccumOp read new AccumOp($0101);
    public static property RETURN: AccumOp read new AccumOp($0102);
    public static property MULT:   AccumOp read new AccumOp($0103);
    public static property ADD:    AccumOp read new AccumOp($0104);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0100) then Result := 'ACCUM' else
      if self.val = UInt32($0101) then Result := 'LOAD' else
      if self.val = UInt32($0102) then Result := 'RETURN' else
      if self.val = UInt32($0103) then Result := 'MULT' else
      if self.val = UInt32($0104) then Result := 'ADD' else
        Result := $'AccumOp[{self.val}]';
    end;
    
  end;
  
  AlphaFunction = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEVER:    AlphaFunction read new AlphaFunction($0200);
    public static property LESS:     AlphaFunction read new AlphaFunction($0201);
    public static property EQUAL:    AlphaFunction read new AlphaFunction($0202);
    public static property LEQUAL:   AlphaFunction read new AlphaFunction($0203);
    public static property GREATER:  AlphaFunction read new AlphaFunction($0204);
    public static property NOTEQUAL: AlphaFunction read new AlphaFunction($0205);
    public static property GEQUAL:   AlphaFunction read new AlphaFunction($0206);
    public static property ALWAYS:   AlphaFunction read new AlphaFunction($0207);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0200) then Result := 'NEVER' else
      if self.val = UInt32($0201) then Result := 'LESS' else
      if self.val = UInt32($0202) then Result := 'EQUAL' else
      if self.val = UInt32($0203) then Result := 'LEQUAL' else
      if self.val = UInt32($0204) then Result := 'GREATER' else
      if self.val = UInt32($0205) then Result := 'NOTEQUAL' else
      if self.val = UInt32($0206) then Result := 'GEQUAL' else
      if self.val = UInt32($0207) then Result := 'ALWAYS' else
        Result := $'AlphaFunction[{self.val}]';
    end;
    
  end;
  
  ArrayObjectPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property OBJECT_BUFFER_SIZE:  ArrayObjectPName read new ArrayObjectPName($8764);
    public static property OBJECT_BUFFER_USAGE: ArrayObjectPName read new ArrayObjectPName($8765);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8764) then Result := 'OBJECT_BUFFER_SIZE' else
      if self.val = UInt32($8765) then Result := 'OBJECT_BUFFER_USAGE' else
        Result := $'ArrayObjectPName[{self.val}]';
    end;
    
  end;
  
  ArrayObjectUsage = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property &STATIC: ArrayObjectUsage read new ArrayObjectUsage($8760);
    public static property DYNAMIC: ArrayObjectUsage read new ArrayObjectUsage($8761);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8760) then Result := 'STATIC' else
      if self.val = UInt32($8761) then Result := 'DYNAMIC' else
        Result := $'ArrayObjectUsage[{self.val}]';
    end;
    
  end;
  
  AtomicCounterBufferPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER:         AtomicCounterBufferPName read new AtomicCounterBufferPName($90ED);
    public static property ATOMIC_COUNTER_BUFFER_BINDING:                              AtomicCounterBufferPName read new AtomicCounterBufferPName($92C1);
    public static property ATOMIC_COUNTER_BUFFER_DATA_SIZE:                            AtomicCounterBufferPName read new AtomicCounterBufferPName($92C4);
    public static property ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS:               AtomicCounterBufferPName read new AtomicCounterBufferPName($92C5);
    public static property ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES:        AtomicCounterBufferPName read new AtomicCounterBufferPName($92C6);
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER:          AtomicCounterBufferPName read new AtomicCounterBufferPName($92C7);
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER:    AtomicCounterBufferPName read new AtomicCounterBufferPName($92C8);
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER: AtomicCounterBufferPName read new AtomicCounterBufferPName($92C9);
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER:        AtomicCounterBufferPName read new AtomicCounterBufferPName($92CA);
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER:        AtomicCounterBufferPName read new AtomicCounterBufferPName($92CB);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($90ED) then Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER' else
      if self.val = UInt32($92C1) then Result := 'ATOMIC_COUNTER_BUFFER_BINDING' else
      if self.val = UInt32($92C4) then Result := 'ATOMIC_COUNTER_BUFFER_DATA_SIZE' else
      if self.val = UInt32($92C5) then Result := 'ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS' else
      if self.val = UInt32($92C6) then Result := 'ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES' else
      if self.val = UInt32($92C7) then Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER' else
      if self.val = UInt32($92C8) then Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER' else
      if self.val = UInt32($92C9) then Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER' else
      if self.val = UInt32($92CA) then Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER' else
      if self.val = UInt32($92CB) then Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER' else
        Result := $'AtomicCounterBufferPName[{self.val}]';
    end;
    
  end;
  
  AttribMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CURRENT_BIT:         AttribMask read new AttribMask($0001);
    public static property POINT_BIT:           AttribMask read new AttribMask($0002);
    public static property LINE_BIT:            AttribMask read new AttribMask($0004);
    public static property POLYGON_BIT:         AttribMask read new AttribMask($0008);
    public static property POLYGON_STIPPLE_BIT: AttribMask read new AttribMask($0010);
    public static property PIXEL_MODE_BIT:      AttribMask read new AttribMask($0020);
    public static property LIGHTING_BIT:        AttribMask read new AttribMask($0040);
    public static property FOG_BIT:             AttribMask read new AttribMask($0080);
    public static property DEPTH_BUFFER_BIT:    AttribMask read new AttribMask($0100);
    public static property ACCUM_BUFFER_BIT:    AttribMask read new AttribMask($0200);
    public static property STENCIL_BUFFER_BIT:  AttribMask read new AttribMask($0400);
    public static property VIEWPORT_BIT:        AttribMask read new AttribMask($0800);
    public static property TRANSFORM_BIT:       AttribMask read new AttribMask($1000);
    public static property ENABLE_BIT:          AttribMask read new AttribMask($2000);
    public static property COLOR_BUFFER_BIT:    AttribMask read new AttribMask($4000);
    public static property HINT_BIT:            AttribMask read new AttribMask($8000);
    public static property EVAL_BIT:            AttribMask read new AttribMask($10000);
    public static property LIST_BIT:            AttribMask read new AttribMask($20000);
    public static property TEXTURE_BIT:         AttribMask read new AttribMask($40000);
    public static property SCISSOR_BIT:         AttribMask read new AttribMask($80000);
    public static property MULTISAMPLE_BIT:     AttribMask read new AttribMask($20000000);
    public static property ALL_ATTRIB_BITS:     AttribMask read new AttribMask($FFFFFFFF);
    
    public static function operator+(f1,f2: AttribMask) := new AttribMask(f1.val or f2.val);
    public static function operator or(f1,f2: AttribMask) := f1+f2;
    
    public static procedure operator+=(var f1: AttribMask; f2: AttribMask) := f1 := f1+f2;
    
    public property HAS_FLAG_CURRENT_BIT:         boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_POINT_BIT:           boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_LINE_BIT:            boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_POLYGON_BIT:         boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_POLYGON_STIPPLE_BIT: boolean read self.val and $0010 <> 0;
    public property HAS_FLAG_PIXEL_MODE_BIT:      boolean read self.val and $0020 <> 0;
    public property HAS_FLAG_LIGHTING_BIT:        boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_FOG_BIT:             boolean read self.val and $0080 <> 0;
    public property HAS_FLAG_DEPTH_BUFFER_BIT:    boolean read self.val and $0100 <> 0;
    public property HAS_FLAG_ACCUM_BUFFER_BIT:    boolean read self.val and $0200 <> 0;
    public property HAS_FLAG_STENCIL_BUFFER_BIT:  boolean read self.val and $0400 <> 0;
    public property HAS_FLAG_VIEWPORT_BIT:        boolean read self.val and $0800 <> 0;
    public property HAS_FLAG_TRANSFORM_BIT:       boolean read self.val and $1000 <> 0;
    public property HAS_FLAG_ENABLE_BIT:          boolean read self.val and $2000 <> 0;
    public property HAS_FLAG_COLOR_BUFFER_BIT:    boolean read self.val and $4000 <> 0;
    public property HAS_FLAG_HINT_BIT:            boolean read self.val and $8000 <> 0;
    public property HAS_FLAG_EVAL_BIT:            boolean read self.val and $10000 <> 0;
    public property HAS_FLAG_LIST_BIT:            boolean read self.val and $20000 <> 0;
    public property HAS_FLAG_TEXTURE_BIT:         boolean read self.val and $40000 <> 0;
    public property HAS_FLAG_SCISSOR_BIT:         boolean read self.val and $80000 <> 0;
    public property HAS_FLAG_MULTISAMPLE_BIT:     boolean read self.val and $20000000 <> 0;
    public property HAS_FLAG_ALL_ATTRIB_BITS:     boolean read self.val and $FFFFFFFF <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'CURRENT_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'POINT_BIT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'LINE_BIT+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'POLYGON_BIT+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'POLYGON_STIPPLE_BIT+';
      if self.val and UInt32($0020) = UInt32($0020) then res += 'PIXEL_MODE_BIT+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'LIGHTING_BIT+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'FOG_BIT+';
      if self.val and UInt32($0100) = UInt32($0100) then res += 'DEPTH_BUFFER_BIT+';
      if self.val and UInt32($0200) = UInt32($0200) then res += 'ACCUM_BUFFER_BIT+';
      if self.val and UInt32($0400) = UInt32($0400) then res += 'STENCIL_BUFFER_BIT+';
      if self.val and UInt32($0800) = UInt32($0800) then res += 'VIEWPORT_BIT+';
      if self.val and UInt32($1000) = UInt32($1000) then res += 'TRANSFORM_BIT+';
      if self.val and UInt32($2000) = UInt32($2000) then res += 'ENABLE_BIT+';
      if self.val and UInt32($4000) = UInt32($4000) then res += 'COLOR_BUFFER_BIT+';
      if self.val and UInt32($8000) = UInt32($8000) then res += 'HINT_BIT+';
      if self.val and UInt32($10000) = UInt32($10000) then res += 'EVAL_BIT+';
      if self.val and UInt32($20000) = UInt32($20000) then res += 'LIST_BIT+';
      if self.val and UInt32($40000) = UInt32($40000) then res += 'TEXTURE_BIT+';
      if self.val and UInt32($80000) = UInt32($80000) then res += 'SCISSOR_BIT+';
      if self.val and UInt32($20000000) = UInt32($20000000) then res += 'MULTISAMPLE_BIT+';
      if self.val and UInt32($FFFFFFFF) = UInt32($FFFFFFFF) then res += 'ALL_ATTRIB_BITS+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'AttribMask[{self.val}]';
    end;
    
  end;
  
  AttributeType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property INT:                                       AttributeType read new AttributeType($1404);
    public static property UNSIGNED_INT:                              AttributeType read new AttributeType($1405);
    public static property FLOAT:                                     AttributeType read new AttributeType($1406);
    public static property DOUBLE:                                    AttributeType read new AttributeType($140A);
    public static property INT64:                                     AttributeType read new AttributeType($140E);
    public static property UNSIGNED_INT64:                            AttributeType read new AttributeType($140F);
    public static property FLOAT_VEC2:                                AttributeType read new AttributeType($8B50);
    public static property FLOAT_VEC3:                                AttributeType read new AttributeType($8B51);
    public static property FLOAT_VEC4:                                AttributeType read new AttributeType($8B52);
    public static property INT_VEC2:                                  AttributeType read new AttributeType($8B53);
    public static property INT_VEC3:                                  AttributeType read new AttributeType($8B54);
    public static property INT_VEC4:                                  AttributeType read new AttributeType($8B55);
    public static property BOOL:                                      AttributeType read new AttributeType($8B56);
    public static property BOOL_VEC2:                                 AttributeType read new AttributeType($8B57);
    public static property BOOL_VEC3:                                 AttributeType read new AttributeType($8B58);
    public static property BOOL_VEC4:                                 AttributeType read new AttributeType($8B59);
    public static property FLOAT_MAT2:                                AttributeType read new AttributeType($8B5A);
    public static property FLOAT_MAT3:                                AttributeType read new AttributeType($8B5B);
    public static property FLOAT_MAT4:                                AttributeType read new AttributeType($8B5C);
    public static property SAMPLER_1D:                                AttributeType read new AttributeType($8B5D);
    public static property SAMPLER_2D:                                AttributeType read new AttributeType($8B5E);
    public static property SAMPLER_3D:                                AttributeType read new AttributeType($8B5F);
    public static property SAMPLER_CUBE:                              AttributeType read new AttributeType($8B60);
    public static property SAMPLER_1D_SHADOW:                         AttributeType read new AttributeType($8B61);
    public static property SAMPLER_2D_SHADOW:                         AttributeType read new AttributeType($8B62);
    public static property SAMPLER_2D_RECT:                           AttributeType read new AttributeType($8B63);
    public static property SAMPLER_2D_RECT_SHADOW:                    AttributeType read new AttributeType($8B64);
    public static property FLOAT_MAT2x3:                              AttributeType read new AttributeType($8B65);
    public static property FLOAT_MAT2x4:                              AttributeType read new AttributeType($8B66);
    public static property FLOAT_MAT3x2:                              AttributeType read new AttributeType($8B67);
    public static property FLOAT_MAT3x4:                              AttributeType read new AttributeType($8B68);
    public static property FLOAT_MAT4x2:                              AttributeType read new AttributeType($8B69);
    public static property FLOAT_MAT4x3:                              AttributeType read new AttributeType($8B6A);
    public static property SAMPLER_BUFFER:                            AttributeType read new AttributeType($8DC2);
    public static property SAMPLER_1D_ARRAY_SHADOW:                   AttributeType read new AttributeType($8DC3);
    public static property SAMPLER_2D_ARRAY_SHADOW:                   AttributeType read new AttributeType($8DC4);
    public static property SAMPLER_CUBE_SHADOW:                       AttributeType read new AttributeType($8DC5);
    public static property UNSIGNED_INT_VEC2:                         AttributeType read new AttributeType($8DC6);
    public static property UNSIGNED_INT_VEC3:                         AttributeType read new AttributeType($8DC7);
    public static property UNSIGNED_INT_VEC4:                         AttributeType read new AttributeType($8DC8);
    public static property INT_SAMPLER_1D:                            AttributeType read new AttributeType($8DC9);
    public static property INT_SAMPLER_2D:                            AttributeType read new AttributeType($8DCA);
    public static property INT_SAMPLER_3D:                            AttributeType read new AttributeType($8DCB);
    public static property INT_SAMPLER_CUBE:                          AttributeType read new AttributeType($8DCC);
    public static property INT_SAMPLER_2D_RECT:                       AttributeType read new AttributeType($8DCD);
    public static property INT_SAMPLER_1D_ARRAY:                      AttributeType read new AttributeType($8DCE);
    public static property INT_SAMPLER_2D_ARRAY:                      AttributeType read new AttributeType($8DCF);
    public static property INT_SAMPLER_BUFFER:                        AttributeType read new AttributeType($8DD0);
    public static property UNSIGNED_INT_SAMPLER_1D:                   AttributeType read new AttributeType($8DD1);
    public static property UNSIGNED_INT_SAMPLER_2D:                   AttributeType read new AttributeType($8DD2);
    public static property UNSIGNED_INT_SAMPLER_3D:                   AttributeType read new AttributeType($8DD3);
    public static property UNSIGNED_INT_SAMPLER_CUBE:                 AttributeType read new AttributeType($8DD4);
    public static property UNSIGNED_INT_SAMPLER_2D_RECT:              AttributeType read new AttributeType($8DD5);
    public static property UNSIGNED_INT_SAMPLER_1D_ARRAY:             AttributeType read new AttributeType($8DD6);
    public static property UNSIGNED_INT_SAMPLER_2D_ARRAY:             AttributeType read new AttributeType($8DD7);
    public static property UNSIGNED_INT_SAMPLER_BUFFER:               AttributeType read new AttributeType($8DD8);
    public static property DOUBLE_MAT2:                               AttributeType read new AttributeType($8F46);
    public static property DOUBLE_MAT3:                               AttributeType read new AttributeType($8F47);
    public static property DOUBLE_MAT4:                               AttributeType read new AttributeType($8F48);
    public static property DOUBLE_MAT2x3:                             AttributeType read new AttributeType($8F49);
    public static property DOUBLE_MAT2x4:                             AttributeType read new AttributeType($8F4A);
    public static property DOUBLE_MAT3x2:                             AttributeType read new AttributeType($8F4B);
    public static property DOUBLE_MAT3x4:                             AttributeType read new AttributeType($8F4C);
    public static property DOUBLE_MAT4x2:                             AttributeType read new AttributeType($8F4D);
    public static property DOUBLE_MAT4x3:                             AttributeType read new AttributeType($8F4E);
    public static property INT64_VEC2:                                AttributeType read new AttributeType($8FE9);
    public static property INT64_VEC3:                                AttributeType read new AttributeType($8FEA);
    public static property INT64_VEC4:                                AttributeType read new AttributeType($8FEB);
    public static property UNSIGNED_INT64_VEC2:                       AttributeType read new AttributeType($8FF5);
    public static property UNSIGNED_INT64_VEC3:                       AttributeType read new AttributeType($8FF6);
    public static property UNSIGNED_INT64_VEC4:                       AttributeType read new AttributeType($8FF7);
    public static property DOUBLE_VEC2:                               AttributeType read new AttributeType($8FFC);
    public static property DOUBLE_VEC3:                               AttributeType read new AttributeType($8FFD);
    public static property DOUBLE_VEC4:                               AttributeType read new AttributeType($8FFE);
    public static property SAMPLER_CUBE_MAP_ARRAY:                    AttributeType read new AttributeType($900C);
    public static property SAMPLER_CUBE_MAP_ARRAY_SHADOW:             AttributeType read new AttributeType($900D);
    public static property INT_SAMPLER_CUBE_MAP_ARRAY:                AttributeType read new AttributeType($900E);
    public static property UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY:       AttributeType read new AttributeType($900F);
    public static property IMAGE_1D:                                  AttributeType read new AttributeType($904C);
    public static property IMAGE_2D:                                  AttributeType read new AttributeType($904D);
    public static property IMAGE_3D:                                  AttributeType read new AttributeType($904E);
    public static property IMAGE_2D_RECT:                             AttributeType read new AttributeType($904F);
    public static property IMAGE_CUBE:                                AttributeType read new AttributeType($9050);
    public static property IMAGE_BUFFER:                              AttributeType read new AttributeType($9051);
    public static property IMAGE_1D_ARRAY:                            AttributeType read new AttributeType($9052);
    public static property IMAGE_2D_ARRAY:                            AttributeType read new AttributeType($9053);
    public static property IMAGE_CUBE_MAP_ARRAY:                      AttributeType read new AttributeType($9054);
    public static property IMAGE_2D_MULTISAMPLE:                      AttributeType read new AttributeType($9055);
    public static property IMAGE_2D_MULTISAMPLE_ARRAY:                AttributeType read new AttributeType($9056);
    public static property INT_IMAGE_1D:                              AttributeType read new AttributeType($9057);
    public static property INT_IMAGE_2D:                              AttributeType read new AttributeType($9058);
    public static property INT_IMAGE_3D:                              AttributeType read new AttributeType($9059);
    public static property INT_IMAGE_2D_RECT:                         AttributeType read new AttributeType($905A);
    public static property INT_IMAGE_CUBE:                            AttributeType read new AttributeType($905B);
    public static property INT_IMAGE_BUFFER:                          AttributeType read new AttributeType($905C);
    public static property INT_IMAGE_1D_ARRAY:                        AttributeType read new AttributeType($905D);
    public static property INT_IMAGE_2D_ARRAY:                        AttributeType read new AttributeType($905E);
    public static property INT_IMAGE_CUBE_MAP_ARRAY:                  AttributeType read new AttributeType($905F);
    public static property INT_IMAGE_2D_MULTISAMPLE:                  AttributeType read new AttributeType($9060);
    public static property INT_IMAGE_2D_MULTISAMPLE_ARRAY:            AttributeType read new AttributeType($9061);
    public static property UNSIGNED_INT_IMAGE_1D:                     AttributeType read new AttributeType($9062);
    public static property UNSIGNED_INT_IMAGE_2D:                     AttributeType read new AttributeType($9063);
    public static property UNSIGNED_INT_IMAGE_3D:                     AttributeType read new AttributeType($9064);
    public static property UNSIGNED_INT_IMAGE_2D_RECT:                AttributeType read new AttributeType($9065);
    public static property UNSIGNED_INT_IMAGE_CUBE:                   AttributeType read new AttributeType($9066);
    public static property UNSIGNED_INT_IMAGE_BUFFER:                 AttributeType read new AttributeType($9067);
    public static property UNSIGNED_INT_IMAGE_1D_ARRAY:               AttributeType read new AttributeType($9068);
    public static property UNSIGNED_INT_IMAGE_2D_ARRAY:               AttributeType read new AttributeType($9069);
    public static property UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY:         AttributeType read new AttributeType($906A);
    public static property UNSIGNED_INT_IMAGE_2D_MULTISAMPLE:         AttributeType read new AttributeType($906B);
    public static property UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY:   AttributeType read new AttributeType($906C);
    public static property SAMPLER_2D_MULTISAMPLE:                    AttributeType read new AttributeType($9108);
    public static property INT_SAMPLER_2D_MULTISAMPLE:                AttributeType read new AttributeType($9109);
    public static property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE:       AttributeType read new AttributeType($910A);
    public static property SAMPLER_2D_MULTISAMPLE_ARRAY:              AttributeType read new AttributeType($910B);
    public static property INT_SAMPLER_2D_MULTISAMPLE_ARRAY:          AttributeType read new AttributeType($910C);
    public static property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: AttributeType read new AttributeType($910D);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
      if self.val = UInt32($140E) then Result := 'INT64' else
      if self.val = UInt32($140F) then Result := 'UNSIGNED_INT64' else
      if self.val = UInt32($8B50) then Result := 'FLOAT_VEC2' else
      if self.val = UInt32($8B51) then Result := 'FLOAT_VEC3' else
      if self.val = UInt32($8B52) then Result := 'FLOAT_VEC4' else
      if self.val = UInt32($8B53) then Result := 'INT_VEC2' else
      if self.val = UInt32($8B54) then Result := 'INT_VEC3' else
      if self.val = UInt32($8B55) then Result := 'INT_VEC4' else
      if self.val = UInt32($8B56) then Result := 'BOOL' else
      if self.val = UInt32($8B57) then Result := 'BOOL_VEC2' else
      if self.val = UInt32($8B58) then Result := 'BOOL_VEC3' else
      if self.val = UInt32($8B59) then Result := 'BOOL_VEC4' else
      if self.val = UInt32($8B5A) then Result := 'FLOAT_MAT2' else
      if self.val = UInt32($8B5B) then Result := 'FLOAT_MAT3' else
      if self.val = UInt32($8B5C) then Result := 'FLOAT_MAT4' else
      if self.val = UInt32($8B5D) then Result := 'SAMPLER_1D' else
      if self.val = UInt32($8B5E) then Result := 'SAMPLER_2D' else
      if self.val = UInt32($8B5F) then Result := 'SAMPLER_3D' else
      if self.val = UInt32($8B60) then Result := 'SAMPLER_CUBE' else
      if self.val = UInt32($8B61) then Result := 'SAMPLER_1D_SHADOW' else
      if self.val = UInt32($8B62) then Result := 'SAMPLER_2D_SHADOW' else
      if self.val = UInt32($8B63) then Result := 'SAMPLER_2D_RECT' else
      if self.val = UInt32($8B64) then Result := 'SAMPLER_2D_RECT_SHADOW' else
      if self.val = UInt32($8B65) then Result := 'FLOAT_MAT2x3' else
      if self.val = UInt32($8B66) then Result := 'FLOAT_MAT2x4' else
      if self.val = UInt32($8B67) then Result := 'FLOAT_MAT3x2' else
      if self.val = UInt32($8B68) then Result := 'FLOAT_MAT3x4' else
      if self.val = UInt32($8B69) then Result := 'FLOAT_MAT4x2' else
      if self.val = UInt32($8B6A) then Result := 'FLOAT_MAT4x3' else
      if self.val = UInt32($8DC2) then Result := 'SAMPLER_BUFFER' else
      if self.val = UInt32($8DC3) then Result := 'SAMPLER_1D_ARRAY_SHADOW' else
      if self.val = UInt32($8DC4) then Result := 'SAMPLER_2D_ARRAY_SHADOW' else
      if self.val = UInt32($8DC5) then Result := 'SAMPLER_CUBE_SHADOW' else
      if self.val = UInt32($8DC6) then Result := 'UNSIGNED_INT_VEC2' else
      if self.val = UInt32($8DC7) then Result := 'UNSIGNED_INT_VEC3' else
      if self.val = UInt32($8DC8) then Result := 'UNSIGNED_INT_VEC4' else
      if self.val = UInt32($8DC9) then Result := 'INT_SAMPLER_1D' else
      if self.val = UInt32($8DCA) then Result := 'INT_SAMPLER_2D' else
      if self.val = UInt32($8DCB) then Result := 'INT_SAMPLER_3D' else
      if self.val = UInt32($8DCC) then Result := 'INT_SAMPLER_CUBE' else
      if self.val = UInt32($8DCD) then Result := 'INT_SAMPLER_2D_RECT' else
      if self.val = UInt32($8DCE) then Result := 'INT_SAMPLER_1D_ARRAY' else
      if self.val = UInt32($8DCF) then Result := 'INT_SAMPLER_2D_ARRAY' else
      if self.val = UInt32($8DD0) then Result := 'INT_SAMPLER_BUFFER' else
      if self.val = UInt32($8DD1) then Result := 'UNSIGNED_INT_SAMPLER_1D' else
      if self.val = UInt32($8DD2) then Result := 'UNSIGNED_INT_SAMPLER_2D' else
      if self.val = UInt32($8DD3) then Result := 'UNSIGNED_INT_SAMPLER_3D' else
      if self.val = UInt32($8DD4) then Result := 'UNSIGNED_INT_SAMPLER_CUBE' else
      if self.val = UInt32($8DD5) then Result := 'UNSIGNED_INT_SAMPLER_2D_RECT' else
      if self.val = UInt32($8DD6) then Result := 'UNSIGNED_INT_SAMPLER_1D_ARRAY' else
      if self.val = UInt32($8DD7) then Result := 'UNSIGNED_INT_SAMPLER_2D_ARRAY' else
      if self.val = UInt32($8DD8) then Result := 'UNSIGNED_INT_SAMPLER_BUFFER' else
      if self.val = UInt32($8F46) then Result := 'DOUBLE_MAT2' else
      if self.val = UInt32($8F47) then Result := 'DOUBLE_MAT3' else
      if self.val = UInt32($8F48) then Result := 'DOUBLE_MAT4' else
      if self.val = UInt32($8F49) then Result := 'DOUBLE_MAT2x3' else
      if self.val = UInt32($8F4A) then Result := 'DOUBLE_MAT2x4' else
      if self.val = UInt32($8F4B) then Result := 'DOUBLE_MAT3x2' else
      if self.val = UInt32($8F4C) then Result := 'DOUBLE_MAT3x4' else
      if self.val = UInt32($8F4D) then Result := 'DOUBLE_MAT4x2' else
      if self.val = UInt32($8F4E) then Result := 'DOUBLE_MAT4x3' else
      if self.val = UInt32($8FE9) then Result := 'INT64_VEC2' else
      if self.val = UInt32($8FEA) then Result := 'INT64_VEC3' else
      if self.val = UInt32($8FEB) then Result := 'INT64_VEC4' else
      if self.val = UInt32($8FF5) then Result := 'UNSIGNED_INT64_VEC2' else
      if self.val = UInt32($8FF6) then Result := 'UNSIGNED_INT64_VEC3' else
      if self.val = UInt32($8FF7) then Result := 'UNSIGNED_INT64_VEC4' else
      if self.val = UInt32($8FFC) then Result := 'DOUBLE_VEC2' else
      if self.val = UInt32($8FFD) then Result := 'DOUBLE_VEC3' else
      if self.val = UInt32($8FFE) then Result := 'DOUBLE_VEC4' else
      if self.val = UInt32($900C) then Result := 'SAMPLER_CUBE_MAP_ARRAY' else
      if self.val = UInt32($900D) then Result := 'SAMPLER_CUBE_MAP_ARRAY_SHADOW' else
      if self.val = UInt32($900E) then Result := 'INT_SAMPLER_CUBE_MAP_ARRAY' else
      if self.val = UInt32($900F) then Result := 'UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY' else
      if self.val = UInt32($904C) then Result := 'IMAGE_1D' else
      if self.val = UInt32($904D) then Result := 'IMAGE_2D' else
      if self.val = UInt32($904E) then Result := 'IMAGE_3D' else
      if self.val = UInt32($904F) then Result := 'IMAGE_2D_RECT' else
      if self.val = UInt32($9050) then Result := 'IMAGE_CUBE' else
      if self.val = UInt32($9051) then Result := 'IMAGE_BUFFER' else
      if self.val = UInt32($9052) then Result := 'IMAGE_1D_ARRAY' else
      if self.val = UInt32($9053) then Result := 'IMAGE_2D_ARRAY' else
      if self.val = UInt32($9054) then Result := 'IMAGE_CUBE_MAP_ARRAY' else
      if self.val = UInt32($9055) then Result := 'IMAGE_2D_MULTISAMPLE' else
      if self.val = UInt32($9056) then Result := 'IMAGE_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($9057) then Result := 'INT_IMAGE_1D' else
      if self.val = UInt32($9058) then Result := 'INT_IMAGE_2D' else
      if self.val = UInt32($9059) then Result := 'INT_IMAGE_3D' else
      if self.val = UInt32($905A) then Result := 'INT_IMAGE_2D_RECT' else
      if self.val = UInt32($905B) then Result := 'INT_IMAGE_CUBE' else
      if self.val = UInt32($905C) then Result := 'INT_IMAGE_BUFFER' else
      if self.val = UInt32($905D) then Result := 'INT_IMAGE_1D_ARRAY' else
      if self.val = UInt32($905E) then Result := 'INT_IMAGE_2D_ARRAY' else
      if self.val = UInt32($905F) then Result := 'INT_IMAGE_CUBE_MAP_ARRAY' else
      if self.val = UInt32($9060) then Result := 'INT_IMAGE_2D_MULTISAMPLE' else
      if self.val = UInt32($9061) then Result := 'INT_IMAGE_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($9062) then Result := 'UNSIGNED_INT_IMAGE_1D' else
      if self.val = UInt32($9063) then Result := 'UNSIGNED_INT_IMAGE_2D' else
      if self.val = UInt32($9064) then Result := 'UNSIGNED_INT_IMAGE_3D' else
      if self.val = UInt32($9065) then Result := 'UNSIGNED_INT_IMAGE_2D_RECT' else
      if self.val = UInt32($9066) then Result := 'UNSIGNED_INT_IMAGE_CUBE' else
      if self.val = UInt32($9067) then Result := 'UNSIGNED_INT_IMAGE_BUFFER' else
      if self.val = UInt32($9068) then Result := 'UNSIGNED_INT_IMAGE_1D_ARRAY' else
      if self.val = UInt32($9069) then Result := 'UNSIGNED_INT_IMAGE_2D_ARRAY' else
      if self.val = UInt32($906A) then Result := 'UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY' else
      if self.val = UInt32($906B) then Result := 'UNSIGNED_INT_IMAGE_2D_MULTISAMPLE' else
      if self.val = UInt32($906C) then Result := 'UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($9108) then Result := 'SAMPLER_2D_MULTISAMPLE' else
      if self.val = UInt32($9109) then Result := 'INT_SAMPLER_2D_MULTISAMPLE' else
      if self.val = UInt32($910A) then Result := 'UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE' else
      if self.val = UInt32($910B) then Result := 'SAMPLER_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($910C) then Result := 'INT_SAMPLER_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($910D) then Result := 'UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY' else
        Result := $'AttributeType[{self.val}]';
    end;
    
  end;
  
  BindTransformFeedbackTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TRANSFORM_FEEDBACK: BindTransformFeedbackTarget read new BindTransformFeedbackTarget($8E22);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8E22) then Result := 'TRANSFORM_FEEDBACK' else
        Result := $'BindTransformFeedbackTarget[{self.val}]';
    end;
    
  end;
  
  BinormalPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:   BinormalPointerType read new BinormalPointerType($1400);
    public static property SHORT:  BinormalPointerType read new BinormalPointerType($1402);
    public static property INT:    BinormalPointerType read new BinormalPointerType($1404);
    public static property FLOAT:  BinormalPointerType read new BinormalPointerType($1406);
    public static property DOUBLE: BinormalPointerType read new BinormalPointerType($140A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := $'BinormalPointerType[{self.val}]';
    end;
    
  end;
  
  BlendEquationMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FUNC_ADD:              BlendEquationMode read new BlendEquationMode($8006);
    public static property MIN:                   BlendEquationMode read new BlendEquationMode($8007);
    public static property MAX:                   BlendEquationMode read new BlendEquationMode($8008);
    public static property FUNC_SUBTRACT:         BlendEquationMode read new BlendEquationMode($800A);
    public static property FUNC_REVERSE_SUBTRACT: BlendEquationMode read new BlendEquationMode($800B);
    public static property ALPHA_MIN:             BlendEquationMode read new BlendEquationMode($8320);
    public static property ALPHA_MAX:             BlendEquationMode read new BlendEquationMode($8321);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8006) then Result := 'FUNC_ADD' else
      if self.val = UInt32($8007) then Result := 'MIN' else
      if self.val = UInt32($8008) then Result := 'MAX' else
      if self.val = UInt32($800A) then Result := 'FUNC_SUBTRACT' else
      if self.val = UInt32($800B) then Result := 'FUNC_REVERSE_SUBTRACT' else
      if self.val = UInt32($8320) then Result := 'ALPHA_MIN' else
      if self.val = UInt32($8321) then Result := 'ALPHA_MAX' else
        Result := $'BlendEquationMode[{self.val}]';
    end;
    
  end;
  
  BlendingFactor = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ZERO:                     BlendingFactor read new BlendingFactor($0000);
    public static property ONE:                      BlendingFactor read new BlendingFactor($0001);
    public static property SRC_COLOR:                BlendingFactor read new BlendingFactor($0300);
    public static property ONE_MINUS_SRC_COLOR:      BlendingFactor read new BlendingFactor($0301);
    public static property SRC_ALPHA:                BlendingFactor read new BlendingFactor($0302);
    public static property ONE_MINUS_SRC_ALPHA:      BlendingFactor read new BlendingFactor($0303);
    public static property DST_ALPHA:                BlendingFactor read new BlendingFactor($0304);
    public static property ONE_MINUS_DST_ALPHA:      BlendingFactor read new BlendingFactor($0305);
    public static property DST_COLOR:                BlendingFactor read new BlendingFactor($0306);
    public static property ONE_MINUS_DST_COLOR:      BlendingFactor read new BlendingFactor($0307);
    public static property SRC_ALPHA_SATURATE:       BlendingFactor read new BlendingFactor($0308);
    public static property CONSTANT_COLOR:           BlendingFactor read new BlendingFactor($8001);
    public static property ONE_MINUS_CONSTANT_COLOR: BlendingFactor read new BlendingFactor($8002);
    public static property CONSTANT_ALPHA:           BlendingFactor read new BlendingFactor($8003);
    public static property ONE_MINUS_CONSTANT_ALPHA: BlendingFactor read new BlendingFactor($8004);
    public static property SRC1_ALPHA:               BlendingFactor read new BlendingFactor($8589);
    public static property SRC1_COLOR:               BlendingFactor read new BlendingFactor($88F9);
    public static property ONE_MINUS_SRC1_COLOR:     BlendingFactor read new BlendingFactor($88FA);
    public static property ONE_MINUS_SRC1_ALPHA:     BlendingFactor read new BlendingFactor($88FB);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'ZERO' else
      if self.val = UInt32($0001) then Result := 'ONE' else
      if self.val = UInt32($0300) then Result := 'SRC_COLOR' else
      if self.val = UInt32($0301) then Result := 'ONE_MINUS_SRC_COLOR' else
      if self.val = UInt32($0302) then Result := 'SRC_ALPHA' else
      if self.val = UInt32($0303) then Result := 'ONE_MINUS_SRC_ALPHA' else
      if self.val = UInt32($0304) then Result := 'DST_ALPHA' else
      if self.val = UInt32($0305) then Result := 'ONE_MINUS_DST_ALPHA' else
      if self.val = UInt32($0306) then Result := 'DST_COLOR' else
      if self.val = UInt32($0307) then Result := 'ONE_MINUS_DST_COLOR' else
      if self.val = UInt32($0308) then Result := 'SRC_ALPHA_SATURATE' else
      if self.val = UInt32($8001) then Result := 'CONSTANT_COLOR' else
      if self.val = UInt32($8002) then Result := 'ONE_MINUS_CONSTANT_COLOR' else
      if self.val = UInt32($8003) then Result := 'CONSTANT_ALPHA' else
      if self.val = UInt32($8004) then Result := 'ONE_MINUS_CONSTANT_ALPHA' else
      if self.val = UInt32($8589) then Result := 'SRC1_ALPHA' else
      if self.val = UInt32($88F9) then Result := 'SRC1_COLOR' else
      if self.val = UInt32($88FA) then Result := 'ONE_MINUS_SRC1_COLOR' else
      if self.val = UInt32($88FB) then Result := 'ONE_MINUS_SRC1_ALPHA' else
        Result := $'BlendingFactor[{self.val}]';
    end;
    
  end;
  
  BlitFramebufferFilter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEAREST: BlitFramebufferFilter read new BlitFramebufferFilter($2600);
    public static property LINEAR:  BlitFramebufferFilter read new BlitFramebufferFilter($2601);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2600) then Result := 'NEAREST' else
      if self.val = UInt32($2601) then Result := 'LINEAR' else
        Result := $'BlitFramebufferFilter[{self.val}]';
    end;
    
  end;
  
  Bool = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FALSE: Bool read new Bool($0000);
    public static property TRUE:  Bool read new Bool($0001);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'FALSE' else
      if self.val = UInt32($0001) then Result := 'TRUE' else
        Result := $'Bool[{self.val}]';
    end;
    
    public static function operator implicit(b: Bool): boolean := b.val<>Bool.FALSE.val;
    public static function operator implicit(b: boolean): Bool := new Bool(UInt32(b));
    
    public static function operator not(b: Bool): Bool := b.val=Bool.FALSE.val ? Bool.TRUE : Bool.FALSE;
    
  end;
  
  Buffer = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COLOR:   Buffer read new Buffer($1800);
    public static property DEPTH:   Buffer read new Buffer($1801);
    public static property STENCIL: Buffer read new Buffer($1802);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1800) then Result := 'COLOR' else
      if self.val = UInt32($1801) then Result := 'DEPTH' else
      if self.val = UInt32($1802) then Result := 'STENCIL' else
        Result := $'Buffer[{self.val}]';
    end;
    
  end;
  
  BufferAccess = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property READ_ONLY:  BufferAccess read new BufferAccess($88B8);
    public static property WRITE_ONLY: BufferAccess read new BufferAccess($88B9);
    public static property READ_WRITE: BufferAccess read new BufferAccess($88BA);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($88B8) then Result := 'READ_ONLY' else
      if self.val = UInt32($88B9) then Result := 'WRITE_ONLY' else
      if self.val = UInt32($88BA) then Result := 'READ_WRITE' else
        Result := $'BufferAccess[{self.val}]';
    end;
    
  end;
  
  BufferPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BUFFER_IMMUTABLE_STORAGE: BufferPName read new BufferPName($821F);
    public static property BUFFER_STORAGE_FLAGS:     BufferPName read new BufferPName($8220);
    public static property BUFFER_SIZE:              BufferPName read new BufferPName($8764);
    public static property BUFFER_USAGE:             BufferPName read new BufferPName($8765);
    public static property BUFFER_ACCESS:            BufferPName read new BufferPName($88BB);
    public static property BUFFER_MAPPED:            BufferPName read new BufferPName($88BC);
    public static property BUFFER_ACCESS_FLAGS:      BufferPName read new BufferPName($911F);
    public static property BUFFER_MAP_LENGTH:        BufferPName read new BufferPName($9120);
    public static property BUFFER_MAP_OFFSET:        BufferPName read new BufferPName($9121);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($821F) then Result := 'BUFFER_IMMUTABLE_STORAGE' else
      if self.val = UInt32($8220) then Result := 'BUFFER_STORAGE_FLAGS' else
      if self.val = UInt32($8764) then Result := 'BUFFER_SIZE' else
      if self.val = UInt32($8765) then Result := 'BUFFER_USAGE' else
      if self.val = UInt32($88BB) then Result := 'BUFFER_ACCESS' else
      if self.val = UInt32($88BC) then Result := 'BUFFER_MAPPED' else
      if self.val = UInt32($911F) then Result := 'BUFFER_ACCESS_FLAGS' else
      if self.val = UInt32($9120) then Result := 'BUFFER_MAP_LENGTH' else
      if self.val = UInt32($9121) then Result := 'BUFFER_MAP_OFFSET' else
        Result := $'BufferPName[{self.val}]';
    end;
    
  end;
  
  BufferPointerName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BUFFER_MAP_POINTER: BufferPointerName read new BufferPointerName($88BD);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($88BD) then Result := 'BUFFER_MAP_POINTER' else
        Result := $'BufferPointerName[{self.val}]';
    end;
    
  end;
  
  BufferStorageMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MAP_READ_BIT:              BufferStorageMask read new BufferStorageMask($0001);
    public static property MAP_WRITE_BIT:             BufferStorageMask read new BufferStorageMask($0002);
    public static property MAP_PERSISTENT_BIT:        BufferStorageMask read new BufferStorageMask($0040);
    public static property MAP_COHERENT_BIT:          BufferStorageMask read new BufferStorageMask($0080);
    public static property DYNAMIC_STORAGE_BIT:       BufferStorageMask read new BufferStorageMask($0100);
    public static property CLIENT_STORAGE_BIT:        BufferStorageMask read new BufferStorageMask($0200);
    public static property SPARSE_STORAGE_BIT:        BufferStorageMask read new BufferStorageMask($0400);
    public static property LGPU_SEPARATE_STORAGE_BIT: BufferStorageMask read new BufferStorageMask($0800);
    public static property PER_GPU_STORAGE_BIT:       BufferStorageMask read new BufferStorageMask($0800);
    public static property EXTERNAL_STORAGE_BIT:      BufferStorageMask read new BufferStorageMask($2000);
    
    public static function operator+(f1,f2: BufferStorageMask) := new BufferStorageMask(f1.val or f2.val);
    public static function operator or(f1,f2: BufferStorageMask) := f1+f2;
    
    public static procedure operator+=(var f1: BufferStorageMask; f2: BufferStorageMask) := f1 := f1+f2;
    
    public property HAS_FLAG_MAP_READ_BIT:              boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_MAP_WRITE_BIT:             boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_MAP_PERSISTENT_BIT:        boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_MAP_COHERENT_BIT:          boolean read self.val and $0080 <> 0;
    public property HAS_FLAG_DYNAMIC_STORAGE_BIT:       boolean read self.val and $0100 <> 0;
    public property HAS_FLAG_CLIENT_STORAGE_BIT:        boolean read self.val and $0200 <> 0;
    public property HAS_FLAG_SPARSE_STORAGE_BIT:        boolean read self.val and $0400 <> 0;
    public property HAS_FLAG_LGPU_SEPARATE_STORAGE_BIT: boolean read self.val and $0800 <> 0;
    public property HAS_FLAG_PER_GPU_STORAGE_BIT:       boolean read self.val and $0800 <> 0;
    public property HAS_FLAG_EXTERNAL_STORAGE_BIT:      boolean read self.val and $2000 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'MAP_READ_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'MAP_WRITE_BIT+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'MAP_PERSISTENT_BIT+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'MAP_COHERENT_BIT+';
      if self.val and UInt32($0100) = UInt32($0100) then res += 'DYNAMIC_STORAGE_BIT+';
      if self.val and UInt32($0200) = UInt32($0200) then res += 'CLIENT_STORAGE_BIT+';
      if self.val and UInt32($0400) = UInt32($0400) then res += 'SPARSE_STORAGE_BIT+';
      if self.val and UInt32($0800) = UInt32($0800) then res += 'LGPU_SEPARATE_STORAGE_BIT+';
      if self.val and UInt32($0800) = UInt32($0800) then res += 'PER_GPU_STORAGE_BIT+';
      if self.val and UInt32($2000) = UInt32($2000) then res += 'EXTERNAL_STORAGE_BIT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'BufferStorageMask[{self.val}]';
    end;
    
  end;
  
  BufferStorageTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ARRAY_BUFFER:              BufferStorageTarget read new BufferStorageTarget($8892);
    public static property ELEMENT_ARRAY_BUFFER:      BufferStorageTarget read new BufferStorageTarget($8893);
    public static property PIXEL_PACK_BUFFER:         BufferStorageTarget read new BufferStorageTarget($88EB);
    public static property PIXEL_UNPACK_BUFFER:       BufferStorageTarget read new BufferStorageTarget($88EC);
    public static property UNIFORM_BUFFER:            BufferStorageTarget read new BufferStorageTarget($8A11);
    public static property TEXTURE_BUFFER:            BufferStorageTarget read new BufferStorageTarget($8C2A);
    public static property TRANSFORM_FEEDBACK_BUFFER: BufferStorageTarget read new BufferStorageTarget($8C8E);
    public static property COPY_READ_BUFFER:          BufferStorageTarget read new BufferStorageTarget($8F36);
    public static property COPY_WRITE_BUFFER:         BufferStorageTarget read new BufferStorageTarget($8F37);
    public static property DRAW_INDIRECT_BUFFER:      BufferStorageTarget read new BufferStorageTarget($8F3F);
    public static property SHADER_STORAGE_BUFFER:     BufferStorageTarget read new BufferStorageTarget($90D2);
    public static property DISPATCH_INDIRECT_BUFFER:  BufferStorageTarget read new BufferStorageTarget($90EE);
    public static property QUERY_BUFFER:              BufferStorageTarget read new BufferStorageTarget($9192);
    public static property ATOMIC_COUNTER_BUFFER:     BufferStorageTarget read new BufferStorageTarget($92C0);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8892) then Result := 'ARRAY_BUFFER' else
      if self.val = UInt32($8893) then Result := 'ELEMENT_ARRAY_BUFFER' else
      if self.val = UInt32($88EB) then Result := 'PIXEL_PACK_BUFFER' else
      if self.val = UInt32($88EC) then Result := 'PIXEL_UNPACK_BUFFER' else
      if self.val = UInt32($8A11) then Result := 'UNIFORM_BUFFER' else
      if self.val = UInt32($8C2A) then Result := 'TEXTURE_BUFFER' else
      if self.val = UInt32($8C8E) then Result := 'TRANSFORM_FEEDBACK_BUFFER' else
      if self.val = UInt32($8F36) then Result := 'COPY_READ_BUFFER' else
      if self.val = UInt32($8F37) then Result := 'COPY_WRITE_BUFFER' else
      if self.val = UInt32($8F3F) then Result := 'DRAW_INDIRECT_BUFFER' else
      if self.val = UInt32($90D2) then Result := 'SHADER_STORAGE_BUFFER' else
      if self.val = UInt32($90EE) then Result := 'DISPATCH_INDIRECT_BUFFER' else
      if self.val = UInt32($9192) then Result := 'QUERY_BUFFER' else
      if self.val = UInt32($92C0) then Result := 'ATOMIC_COUNTER_BUFFER' else
        Result := $'BufferStorageTarget[{self.val}]';
    end;
    
  end;
  
  BufferTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PARAMETER_BUFFER:          BufferTarget read new BufferTarget($80EE);
    public static property ARRAY_BUFFER:              BufferTarget read new BufferTarget($8892);
    public static property ELEMENT_ARRAY_BUFFER:      BufferTarget read new BufferTarget($8893);
    public static property PIXEL_PACK_BUFFER:         BufferTarget read new BufferTarget($88EB);
    public static property PIXEL_UNPACK_BUFFER:       BufferTarget read new BufferTarget($88EC);
    public static property UNIFORM_BUFFER:            BufferTarget read new BufferTarget($8A11);
    public static property TEXTURE_BUFFER:            BufferTarget read new BufferTarget($8C2A);
    public static property TRANSFORM_FEEDBACK_BUFFER: BufferTarget read new BufferTarget($8C8E);
    public static property COPY_READ_BUFFER:          BufferTarget read new BufferTarget($8F36);
    public static property COPY_WRITE_BUFFER:         BufferTarget read new BufferTarget($8F37);
    public static property DRAW_INDIRECT_BUFFER:      BufferTarget read new BufferTarget($8F3F);
    public static property SHADER_STORAGE_BUFFER:     BufferTarget read new BufferTarget($90D2);
    public static property DISPATCH_INDIRECT_BUFFER:  BufferTarget read new BufferTarget($90EE);
    public static property QUERY_BUFFER:              BufferTarget read new BufferTarget($9192);
    public static property ATOMIC_COUNTER_BUFFER:     BufferTarget read new BufferTarget($92C0);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($80EE) then Result := 'PARAMETER_BUFFER' else
      if self.val = UInt32($8892) then Result := 'ARRAY_BUFFER' else
      if self.val = UInt32($8893) then Result := 'ELEMENT_ARRAY_BUFFER' else
      if self.val = UInt32($88EB) then Result := 'PIXEL_PACK_BUFFER' else
      if self.val = UInt32($88EC) then Result := 'PIXEL_UNPACK_BUFFER' else
      if self.val = UInt32($8A11) then Result := 'UNIFORM_BUFFER' else
      if self.val = UInt32($8C2A) then Result := 'TEXTURE_BUFFER' else
      if self.val = UInt32($8C8E) then Result := 'TRANSFORM_FEEDBACK_BUFFER' else
      if self.val = UInt32($8F36) then Result := 'COPY_READ_BUFFER' else
      if self.val = UInt32($8F37) then Result := 'COPY_WRITE_BUFFER' else
      if self.val = UInt32($8F3F) then Result := 'DRAW_INDIRECT_BUFFER' else
      if self.val = UInt32($90D2) then Result := 'SHADER_STORAGE_BUFFER' else
      if self.val = UInt32($90EE) then Result := 'DISPATCH_INDIRECT_BUFFER' else
      if self.val = UInt32($9192) then Result := 'QUERY_BUFFER' else
      if self.val = UInt32($92C0) then Result := 'ATOMIC_COUNTER_BUFFER' else
        Result := $'BufferTarget[{self.val}]';
    end;
    
  end;
  
  BufferUsage = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property STREAM_DRAW:  BufferUsage read new BufferUsage($88E0);
    public static property STREAM_READ:  BufferUsage read new BufferUsage($88E1);
    public static property STREAM_COPY:  BufferUsage read new BufferUsage($88E2);
    public static property STATIC_DRAW:  BufferUsage read new BufferUsage($88E4);
    public static property STATIC_READ:  BufferUsage read new BufferUsage($88E5);
    public static property STATIC_COPY:  BufferUsage read new BufferUsage($88E6);
    public static property DYNAMIC_DRAW: BufferUsage read new BufferUsage($88E8);
    public static property DYNAMIC_READ: BufferUsage read new BufferUsage($88E9);
    public static property DYNAMIC_COPY: BufferUsage read new BufferUsage($88EA);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($88E0) then Result := 'STREAM_DRAW' else
      if self.val = UInt32($88E1) then Result := 'STREAM_READ' else
      if self.val = UInt32($88E2) then Result := 'STREAM_COPY' else
      if self.val = UInt32($88E4) then Result := 'STATIC_DRAW' else
      if self.val = UInt32($88E5) then Result := 'STATIC_READ' else
      if self.val = UInt32($88E6) then Result := 'STATIC_COPY' else
      if self.val = UInt32($88E8) then Result := 'DYNAMIC_DRAW' else
      if self.val = UInt32($88E9) then Result := 'DYNAMIC_READ' else
      if self.val = UInt32($88EA) then Result := 'DYNAMIC_COPY' else
        Result := $'BufferUsage[{self.val}]';
    end;
    
  end;
  
  ClampColorMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FALSE:      ClampColorMode read new ClampColorMode($0000);
    public static property TRUE:       ClampColorMode read new ClampColorMode($0001);
    public static property FIXED_ONLY: ClampColorMode read new ClampColorMode($891D);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'FALSE' else
      if self.val = UInt32($0001) then Result := 'TRUE' else
      if self.val = UInt32($891D) then Result := 'FIXED_ONLY' else
        Result := $'ClampColorMode[{self.val}]';
    end;
    
  end;
  
  ClampColorTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CLAMP_VERTEX_COLOR:   ClampColorTarget read new ClampColorTarget($891A);
    public static property CLAMP_FRAGMENT_COLOR: ClampColorTarget read new ClampColorTarget($891B);
    public static property CLAMP_READ_COLOR:     ClampColorTarget read new ClampColorTarget($891C);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($891A) then Result := 'CLAMP_VERTEX_COLOR' else
      if self.val = UInt32($891B) then Result := 'CLAMP_FRAGMENT_COLOR' else
      if self.val = UInt32($891C) then Result := 'CLAMP_READ_COLOR' else
        Result := $'ClampColorTarget[{self.val}]';
    end;
    
  end;
  
  ClearBufferMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DEPTH_BUFFER_BIT:    ClearBufferMask read new ClearBufferMask($0100);
    public static property ACCUM_BUFFER_BIT:    ClearBufferMask read new ClearBufferMask($0200);
    public static property STENCIL_BUFFER_BIT:  ClearBufferMask read new ClearBufferMask($0400);
    public static property COLOR_BUFFER_BIT:    ClearBufferMask read new ClearBufferMask($4000);
    public static property COVERAGE_BUFFER_BIT: ClearBufferMask read new ClearBufferMask($8000);
    
    public static function operator+(f1,f2: ClearBufferMask) := new ClearBufferMask(f1.val or f2.val);
    public static function operator or(f1,f2: ClearBufferMask) := f1+f2;
    
    public static procedure operator+=(var f1: ClearBufferMask; f2: ClearBufferMask) := f1 := f1+f2;
    
    public property HAS_FLAG_DEPTH_BUFFER_BIT:    boolean read self.val and $0100 <> 0;
    public property HAS_FLAG_ACCUM_BUFFER_BIT:    boolean read self.val and $0200 <> 0;
    public property HAS_FLAG_STENCIL_BUFFER_BIT:  boolean read self.val and $0400 <> 0;
    public property HAS_FLAG_COLOR_BUFFER_BIT:    boolean read self.val and $4000 <> 0;
    public property HAS_FLAG_COVERAGE_BUFFER_BIT: boolean read self.val and $8000 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0100) = UInt32($0100) then res += 'DEPTH_BUFFER_BIT+';
      if self.val and UInt32($0200) = UInt32($0200) then res += 'ACCUM_BUFFER_BIT+';
      if self.val and UInt32($0400) = UInt32($0400) then res += 'STENCIL_BUFFER_BIT+';
      if self.val and UInt32($4000) = UInt32($4000) then res += 'COLOR_BUFFER_BIT+';
      if self.val and UInt32($8000) = UInt32($8000) then res += 'COVERAGE_BUFFER_BIT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'ClearBufferMask[{self.val}]';
    end;
    
  end;
  
  ClientAttribMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CLIENT_PIXEL_STORE_BIT:  ClientAttribMask read new ClientAttribMask($0001);
    public static property CLIENT_VERTEX_ARRAY_BIT: ClientAttribMask read new ClientAttribMask($0002);
    public static property CLIENT_ALL_ATTRIB_BITS:  ClientAttribMask read new ClientAttribMask($FFFFFFFF);
    
    public static function operator+(f1,f2: ClientAttribMask) := new ClientAttribMask(f1.val or f2.val);
    public static function operator or(f1,f2: ClientAttribMask) := f1+f2;
    
    public static procedure operator+=(var f1: ClientAttribMask; f2: ClientAttribMask) := f1 := f1+f2;
    
    public property HAS_FLAG_CLIENT_PIXEL_STORE_BIT:  boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_CLIENT_VERTEX_ARRAY_BIT: boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_CLIENT_ALL_ATTRIB_BITS:  boolean read self.val and $FFFFFFFF <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'CLIENT_PIXEL_STORE_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'CLIENT_VERTEX_ARRAY_BIT+';
      if self.val and UInt32($FFFFFFFF) = UInt32($FFFFFFFF) then res += 'CLIENT_ALL_ATTRIB_BITS+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'ClientAttribMask[{self.val}]';
    end;
    
  end;
  
  ClipControlDepth = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEGATIVE_ONE_TO_ONE: ClipControlDepth read new ClipControlDepth($935E);
    public static property ZERO_TO_ONE:         ClipControlDepth read new ClipControlDepth($935F);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($935E) then Result := 'NEGATIVE_ONE_TO_ONE' else
      if self.val = UInt32($935F) then Result := 'ZERO_TO_ONE' else
        Result := $'ClipControlDepth[{self.val}]';
    end;
    
  end;
  
  ClipControlOrigin = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LOWER_LEFT: ClipControlOrigin read new ClipControlOrigin($8CA1);
    public static property UPPER_LEFT: ClipControlOrigin read new ClipControlOrigin($8CA2);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8CA1) then Result := 'LOWER_LEFT' else
      if self.val = UInt32($8CA2) then Result := 'UPPER_LEFT' else
        Result := $'ClipControlOrigin[{self.val}]';
    end;
    
  end;
  
  ClipPlaneName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CLIP_PLANE0:    ClipPlaneName read new ClipPlaneName($3000);
    public static property CLIP_DISTANCE0: ClipPlaneName read new ClipPlaneName($3000);
    public static property CLIP_PLANE1:    ClipPlaneName read new ClipPlaneName($3001);
    public static property CLIP_DISTANCE1: ClipPlaneName read new ClipPlaneName($3001);
    public static property CLIP_PLANE2:    ClipPlaneName read new ClipPlaneName($3002);
    public static property CLIP_DISTANCE2: ClipPlaneName read new ClipPlaneName($3002);
    public static property CLIP_PLANE3:    ClipPlaneName read new ClipPlaneName($3003);
    public static property CLIP_DISTANCE3: ClipPlaneName read new ClipPlaneName($3003);
    public static property CLIP_PLANE4:    ClipPlaneName read new ClipPlaneName($3004);
    public static property CLIP_DISTANCE4: ClipPlaneName read new ClipPlaneName($3004);
    public static property CLIP_PLANE5:    ClipPlaneName read new ClipPlaneName($3005);
    public static property CLIP_DISTANCE5: ClipPlaneName read new ClipPlaneName($3005);
    public static property CLIP_DISTANCE6: ClipPlaneName read new ClipPlaneName($3006);
    public static property CLIP_DISTANCE7: ClipPlaneName read new ClipPlaneName($3007);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($3000) then Result := 'CLIP_PLANE0' else
      if self.val = UInt32($3000) then Result := 'CLIP_DISTANCE0' else
      if self.val = UInt32($3001) then Result := 'CLIP_PLANE1' else
      if self.val = UInt32($3001) then Result := 'CLIP_DISTANCE1' else
      if self.val = UInt32($3002) then Result := 'CLIP_PLANE2' else
      if self.val = UInt32($3002) then Result := 'CLIP_DISTANCE2' else
      if self.val = UInt32($3003) then Result := 'CLIP_PLANE3' else
      if self.val = UInt32($3003) then Result := 'CLIP_DISTANCE3' else
      if self.val = UInt32($3004) then Result := 'CLIP_PLANE4' else
      if self.val = UInt32($3004) then Result := 'CLIP_DISTANCE4' else
      if self.val = UInt32($3005) then Result := 'CLIP_PLANE5' else
      if self.val = UInt32($3005) then Result := 'CLIP_DISTANCE5' else
      if self.val = UInt32($3006) then Result := 'CLIP_DISTANCE6' else
      if self.val = UInt32($3007) then Result := 'CLIP_DISTANCE7' else
        Result := $'ClipPlaneName[{self.val}]';
    end;
    
  end;
  
  ColorBuffer = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:               ColorBuffer read new ColorBuffer($0000);
    public static property FRONT_LEFT:         ColorBuffer read new ColorBuffer($0400);
    public static property FRONT_RIGHT:        ColorBuffer read new ColorBuffer($0401);
    public static property BACK_LEFT:          ColorBuffer read new ColorBuffer($0402);
    public static property BACK_RIGHT:         ColorBuffer read new ColorBuffer($0403);
    public static property FRONT:              ColorBuffer read new ColorBuffer($0404);
    public static property BACK:               ColorBuffer read new ColorBuffer($0405);
    public static property LEFT:               ColorBuffer read new ColorBuffer($0406);
    public static property RIGHT:              ColorBuffer read new ColorBuffer($0407);
    public static property FRONT_AND_BACK:     ColorBuffer read new ColorBuffer($0408);
    public static property COLOR_ATTACHMENT0:  ColorBuffer read new ColorBuffer($8CE0);
    public static property COLOR_ATTACHMENT1:  ColorBuffer read new ColorBuffer($8CE1);
    public static property COLOR_ATTACHMENT2:  ColorBuffer read new ColorBuffer($8CE2);
    public static property COLOR_ATTACHMENT3:  ColorBuffer read new ColorBuffer($8CE3);
    public static property COLOR_ATTACHMENT4:  ColorBuffer read new ColorBuffer($8CE4);
    public static property COLOR_ATTACHMENT5:  ColorBuffer read new ColorBuffer($8CE5);
    public static property COLOR_ATTACHMENT6:  ColorBuffer read new ColorBuffer($8CE6);
    public static property COLOR_ATTACHMENT7:  ColorBuffer read new ColorBuffer($8CE7);
    public static property COLOR_ATTACHMENT8:  ColorBuffer read new ColorBuffer($8CE8);
    public static property COLOR_ATTACHMENT9:  ColorBuffer read new ColorBuffer($8CE9);
    public static property COLOR_ATTACHMENT10: ColorBuffer read new ColorBuffer($8CEA);
    public static property COLOR_ATTACHMENT11: ColorBuffer read new ColorBuffer($8CEB);
    public static property COLOR_ATTACHMENT12: ColorBuffer read new ColorBuffer($8CEC);
    public static property COLOR_ATTACHMENT13: ColorBuffer read new ColorBuffer($8CED);
    public static property COLOR_ATTACHMENT14: ColorBuffer read new ColorBuffer($8CEE);
    public static property COLOR_ATTACHMENT15: ColorBuffer read new ColorBuffer($8CEF);
    public static property COLOR_ATTACHMENT16: ColorBuffer read new ColorBuffer($8CF0);
    public static property COLOR_ATTACHMENT17: ColorBuffer read new ColorBuffer($8CF1);
    public static property COLOR_ATTACHMENT18: ColorBuffer read new ColorBuffer($8CF2);
    public static property COLOR_ATTACHMENT19: ColorBuffer read new ColorBuffer($8CF3);
    public static property COLOR_ATTACHMENT20: ColorBuffer read new ColorBuffer($8CF4);
    public static property COLOR_ATTACHMENT21: ColorBuffer read new ColorBuffer($8CF5);
    public static property COLOR_ATTACHMENT22: ColorBuffer read new ColorBuffer($8CF6);
    public static property COLOR_ATTACHMENT23: ColorBuffer read new ColorBuffer($8CF7);
    public static property COLOR_ATTACHMENT24: ColorBuffer read new ColorBuffer($8CF8);
    public static property COLOR_ATTACHMENT25: ColorBuffer read new ColorBuffer($8CF9);
    public static property COLOR_ATTACHMENT26: ColorBuffer read new ColorBuffer($8CFA);
    public static property COLOR_ATTACHMENT27: ColorBuffer read new ColorBuffer($8CFB);
    public static property COLOR_ATTACHMENT28: ColorBuffer read new ColorBuffer($8CFC);
    public static property COLOR_ATTACHMENT29: ColorBuffer read new ColorBuffer($8CFD);
    public static property COLOR_ATTACHMENT30: ColorBuffer read new ColorBuffer($8CFE);
    public static property COLOR_ATTACHMENT31: ColorBuffer read new ColorBuffer($8CFF);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($0400) then Result := 'FRONT_LEFT' else
      if self.val = UInt32($0401) then Result := 'FRONT_RIGHT' else
      if self.val = UInt32($0402) then Result := 'BACK_LEFT' else
      if self.val = UInt32($0403) then Result := 'BACK_RIGHT' else
      if self.val = UInt32($0404) then Result := 'FRONT' else
      if self.val = UInt32($0405) then Result := 'BACK' else
      if self.val = UInt32($0406) then Result := 'LEFT' else
      if self.val = UInt32($0407) then Result := 'RIGHT' else
      if self.val = UInt32($0408) then Result := 'FRONT_AND_BACK' else
      if self.val = UInt32($8CE0) then Result := 'COLOR_ATTACHMENT0' else
      if self.val = UInt32($8CE1) then Result := 'COLOR_ATTACHMENT1' else
      if self.val = UInt32($8CE2) then Result := 'COLOR_ATTACHMENT2' else
      if self.val = UInt32($8CE3) then Result := 'COLOR_ATTACHMENT3' else
      if self.val = UInt32($8CE4) then Result := 'COLOR_ATTACHMENT4' else
      if self.val = UInt32($8CE5) then Result := 'COLOR_ATTACHMENT5' else
      if self.val = UInt32($8CE6) then Result := 'COLOR_ATTACHMENT6' else
      if self.val = UInt32($8CE7) then Result := 'COLOR_ATTACHMENT7' else
      if self.val = UInt32($8CE8) then Result := 'COLOR_ATTACHMENT8' else
      if self.val = UInt32($8CE9) then Result := 'COLOR_ATTACHMENT9' else
      if self.val = UInt32($8CEA) then Result := 'COLOR_ATTACHMENT10' else
      if self.val = UInt32($8CEB) then Result := 'COLOR_ATTACHMENT11' else
      if self.val = UInt32($8CEC) then Result := 'COLOR_ATTACHMENT12' else
      if self.val = UInt32($8CED) then Result := 'COLOR_ATTACHMENT13' else
      if self.val = UInt32($8CEE) then Result := 'COLOR_ATTACHMENT14' else
      if self.val = UInt32($8CEF) then Result := 'COLOR_ATTACHMENT15' else
      if self.val = UInt32($8CF0) then Result := 'COLOR_ATTACHMENT16' else
      if self.val = UInt32($8CF1) then Result := 'COLOR_ATTACHMENT17' else
      if self.val = UInt32($8CF2) then Result := 'COLOR_ATTACHMENT18' else
      if self.val = UInt32($8CF3) then Result := 'COLOR_ATTACHMENT19' else
      if self.val = UInt32($8CF4) then Result := 'COLOR_ATTACHMENT20' else
      if self.val = UInt32($8CF5) then Result := 'COLOR_ATTACHMENT21' else
      if self.val = UInt32($8CF6) then Result := 'COLOR_ATTACHMENT22' else
      if self.val = UInt32($8CF7) then Result := 'COLOR_ATTACHMENT23' else
      if self.val = UInt32($8CF8) then Result := 'COLOR_ATTACHMENT24' else
      if self.val = UInt32($8CF9) then Result := 'COLOR_ATTACHMENT25' else
      if self.val = UInt32($8CFA) then Result := 'COLOR_ATTACHMENT26' else
      if self.val = UInt32($8CFB) then Result := 'COLOR_ATTACHMENT27' else
      if self.val = UInt32($8CFC) then Result := 'COLOR_ATTACHMENT28' else
      if self.val = UInt32($8CFD) then Result := 'COLOR_ATTACHMENT29' else
      if self.val = UInt32($8CFE) then Result := 'COLOR_ATTACHMENT30' else
      if self.val = UInt32($8CFF) then Result := 'COLOR_ATTACHMENT31' else
        Result := $'ColorBuffer[{self.val}]';
    end;
    
  end;
  
  ColorMaterialParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property AMBIENT:             ColorMaterialParameter read new ColorMaterialParameter($1200);
    public static property DIFFUSE:             ColorMaterialParameter read new ColorMaterialParameter($1201);
    public static property SPECULAR:            ColorMaterialParameter read new ColorMaterialParameter($1202);
    public static property EMISSION:            ColorMaterialParameter read new ColorMaterialParameter($1600);
    public static property AMBIENT_AND_DIFFUSE: ColorMaterialParameter read new ColorMaterialParameter($1602);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1200) then Result := 'AMBIENT' else
      if self.val = UInt32($1201) then Result := 'DIFFUSE' else
      if self.val = UInt32($1202) then Result := 'SPECULAR' else
      if self.val = UInt32($1600) then Result := 'EMISSION' else
      if self.val = UInt32($1602) then Result := 'AMBIENT_AND_DIFFUSE' else
        Result := $'ColorMaterialParameter[{self.val}]';
    end;
    
  end;
  
  ColorPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:           ColorPointerType read new ColorPointerType($1400);
    public static property UNSIGNED_BYTE:  ColorPointerType read new ColorPointerType($1401);
    public static property UNSIGNED_SHORT: ColorPointerType read new ColorPointerType($1403);
    public static property UNSIGNED_INT:   ColorPointerType read new ColorPointerType($1405);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
        Result := $'ColorPointerType[{self.val}]';
    end;
    
  end;
  
  ColorTableParameterPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COLOR_TABLE_SCALE:          ColorTableParameterPName read new ColorTableParameterPName($80D6);
    public static property COLOR_TABLE_BIAS:           ColorTableParameterPName read new ColorTableParameterPName($80D7);
    public static property COLOR_TABLE_FORMAT:         ColorTableParameterPName read new ColorTableParameterPName($80D8);
    public static property COLOR_TABLE_WIDTH:          ColorTableParameterPName read new ColorTableParameterPName($80D9);
    public static property COLOR_TABLE_RED_SIZE:       ColorTableParameterPName read new ColorTableParameterPName($80DA);
    public static property COLOR_TABLE_GREEN_SIZE:     ColorTableParameterPName read new ColorTableParameterPName($80DB);
    public static property COLOR_TABLE_BLUE_SIZE:      ColorTableParameterPName read new ColorTableParameterPName($80DC);
    public static property COLOR_TABLE_ALPHA_SIZE:     ColorTableParameterPName read new ColorTableParameterPName($80DD);
    public static property COLOR_TABLE_LUMINANCE_SIZE: ColorTableParameterPName read new ColorTableParameterPName($80DE);
    public static property COLOR_TABLE_INTENSITY_SIZE: ColorTableParameterPName read new ColorTableParameterPName($80DF);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($80D6) then Result := 'COLOR_TABLE_SCALE' else
      if self.val = UInt32($80D7) then Result := 'COLOR_TABLE_BIAS' else
      if self.val = UInt32($80D8) then Result := 'COLOR_TABLE_FORMAT' else
      if self.val = UInt32($80D9) then Result := 'COLOR_TABLE_WIDTH' else
      if self.val = UInt32($80DA) then Result := 'COLOR_TABLE_RED_SIZE' else
      if self.val = UInt32($80DB) then Result := 'COLOR_TABLE_GREEN_SIZE' else
      if self.val = UInt32($80DC) then Result := 'COLOR_TABLE_BLUE_SIZE' else
      if self.val = UInt32($80DD) then Result := 'COLOR_TABLE_ALPHA_SIZE' else
      if self.val = UInt32($80DE) then Result := 'COLOR_TABLE_LUMINANCE_SIZE' else
      if self.val = UInt32($80DF) then Result := 'COLOR_TABLE_INTENSITY_SIZE' else
        Result := $'ColorTableParameterPName[{self.val}]';
    end;
    
  end;
  
  ColorTableTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_COLOR_TABLE:                 ColorTableTarget read new ColorTableTarget($80BC);
    public static property PROXY_TEXTURE_COLOR_TABLE:           ColorTableTarget read new ColorTableTarget($80BD);
    public static property COLOR_TABLE:                         ColorTableTarget read new ColorTableTarget($80D0);
    public static property POST_CONVOLUTION_COLOR_TABLE:        ColorTableTarget read new ColorTableTarget($80D1);
    public static property POST_COLOR_MATRIX_COLOR_TABLE:       ColorTableTarget read new ColorTableTarget($80D2);
    public static property PROXY_COLOR_TABLE:                   ColorTableTarget read new ColorTableTarget($80D3);
    public static property PROXY_POST_CONVOLUTION_COLOR_TABLE:  ColorTableTarget read new ColorTableTarget($80D4);
    public static property PROXY_POST_COLOR_MATRIX_COLOR_TABLE: ColorTableTarget read new ColorTableTarget($80D5);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($80BC) then Result := 'TEXTURE_COLOR_TABLE' else
      if self.val = UInt32($80BD) then Result := 'PROXY_TEXTURE_COLOR_TABLE' else
      if self.val = UInt32($80D0) then Result := 'COLOR_TABLE' else
      if self.val = UInt32($80D1) then Result := 'POST_CONVOLUTION_COLOR_TABLE' else
      if self.val = UInt32($80D2) then Result := 'POST_COLOR_MATRIX_COLOR_TABLE' else
      if self.val = UInt32($80D3) then Result := 'PROXY_COLOR_TABLE' else
      if self.val = UInt32($80D4) then Result := 'PROXY_POST_CONVOLUTION_COLOR_TABLE' else
      if self.val = UInt32($80D5) then Result := 'PROXY_POST_COLOR_MATRIX_COLOR_TABLE' else
        Result := $'ColorTableTarget[{self.val}]';
    end;
    
  end;
  
  CombinerBias = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:                      CombinerBias read new CombinerBias($0000);
    public static property BIAS_BY_NEGATIVE_ONE_HALF: CombinerBias read new CombinerBias($8541);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($8541) then Result := 'BIAS_BY_NEGATIVE_ONE_HALF' else
        Result := $'CombinerBias[{self.val}]';
    end;
    
  end;
  
  CombinerComponentUsage = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BLUE:  CombinerComponentUsage read new CombinerComponentUsage($1905);
    public static property ALPHA: CombinerComponentUsage read new CombinerComponentUsage($1906);
    public static property RGB:   CombinerComponentUsage read new CombinerComponentUsage($1907);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1905) then Result := 'BLUE' else
      if self.val = UInt32($1906) then Result := 'ALPHA' else
      if self.val = UInt32($1907) then Result := 'RGB' else
        Result := $'CombinerComponentUsage[{self.val}]';
    end;
    
  end;
  
  CombinerMapping = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNSIGNED_IDENTITY: CombinerMapping read new CombinerMapping($8536);
    public static property UNSIGNED_INVERT:   CombinerMapping read new CombinerMapping($8537);
    public static property EXPAND_NORMAL:     CombinerMapping read new CombinerMapping($8538);
    public static property EXPAND_NEGATE:     CombinerMapping read new CombinerMapping($8539);
    public static property HALF_BIAS_NORMAL:  CombinerMapping read new CombinerMapping($853A);
    public static property HALF_BIAS_NEGATE:  CombinerMapping read new CombinerMapping($853B);
    public static property SIGNED_IDENTITY:   CombinerMapping read new CombinerMapping($853C);
    public static property SIGNED_NEGATE:     CombinerMapping read new CombinerMapping($853D);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8536) then Result := 'UNSIGNED_IDENTITY' else
      if self.val = UInt32($8537) then Result := 'UNSIGNED_INVERT' else
      if self.val = UInt32($8538) then Result := 'EXPAND_NORMAL' else
      if self.val = UInt32($8539) then Result := 'EXPAND_NEGATE' else
      if self.val = UInt32($853A) then Result := 'HALF_BIAS_NORMAL' else
      if self.val = UInt32($853B) then Result := 'HALF_BIAS_NEGATE' else
      if self.val = UInt32($853C) then Result := 'SIGNED_IDENTITY' else
      if self.val = UInt32($853D) then Result := 'SIGNED_NEGATE' else
        Result := $'CombinerMapping[{self.val}]';
    end;
    
  end;
  
  CombinerParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMBINER_INPUT:           CombinerParameter read new CombinerParameter($8542);
    public static property COMBINER_MAPPING:         CombinerParameter read new CombinerParameter($8543);
    public static property COMBINER_COMPONENT_USAGE: CombinerParameter read new CombinerParameter($8544);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8542) then Result := 'COMBINER_INPUT' else
      if self.val = UInt32($8543) then Result := 'COMBINER_MAPPING' else
      if self.val = UInt32($8544) then Result := 'COMBINER_COMPONENT_USAGE' else
        Result := $'CombinerParameter[{self.val}]';
    end;
    
  end;
  
  CombinerPortion = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ALPHA: CombinerPortion read new CombinerPortion($1906);
    public static property RGB:   CombinerPortion read new CombinerPortion($1907);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1906) then Result := 'ALPHA' else
      if self.val = UInt32($1907) then Result := 'RGB' else
        Result := $'CombinerPortion[{self.val}]';
    end;
    
  end;
  
  CombinerRegister = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE0:         CombinerRegister read new CombinerRegister($84C0);
    public static property TEXTURE1:         CombinerRegister read new CombinerRegister($84C1);
    public static property PRIMARY_COLOR_NV: CombinerRegister read new CombinerRegister($852C);
    public static property SECONDARY_COLOR:  CombinerRegister read new CombinerRegister($852D);
    public static property SPARE0:           CombinerRegister read new CombinerRegister($852E);
    public static property SPARE1:           CombinerRegister read new CombinerRegister($852F);
    public static property DISCARD_NV:       CombinerRegister read new CombinerRegister($8530);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($84C0) then Result := 'TEXTURE0' else
      if self.val = UInt32($84C1) then Result := 'TEXTURE1' else
      if self.val = UInt32($852C) then Result := 'PRIMARY_COLOR_NV' else
      if self.val = UInt32($852D) then Result := 'SECONDARY_COLOR' else
      if self.val = UInt32($852E) then Result := 'SPARE0' else
      if self.val = UInt32($852F) then Result := 'SPARE1' else
      if self.val = UInt32($8530) then Result := 'DISCARD_NV' else
        Result := $'CombinerRegister[{self.val}]';
    end;
    
  end;
  
  CombinerScale = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:              CombinerScale read new CombinerScale($0000);
    public static property SCALE_BY_TWO:      CombinerScale read new CombinerScale($853E);
    public static property SCALE_BY_FOUR:     CombinerScale read new CombinerScale($853F);
    public static property SCALE_BY_ONE_HALF: CombinerScale read new CombinerScale($8540);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($853E) then Result := 'SCALE_BY_TWO' else
      if self.val = UInt32($853F) then Result := 'SCALE_BY_FOUR' else
      if self.val = UInt32($8540) then Result := 'SCALE_BY_ONE_HALF' else
        Result := $'CombinerScale[{self.val}]';
    end;
    
  end;
  
  CombinerStage = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMBINER0: CombinerStage read new CombinerStage($8550);
    public static property COMBINER1: CombinerStage read new CombinerStage($8551);
    public static property COMBINER2: CombinerStage read new CombinerStage($8552);
    public static property COMBINER3: CombinerStage read new CombinerStage($8553);
    public static property COMBINER4: CombinerStage read new CombinerStage($8554);
    public static property COMBINER5: CombinerStage read new CombinerStage($8555);
    public static property COMBINER6: CombinerStage read new CombinerStage($8556);
    public static property COMBINER7: CombinerStage read new CombinerStage($8557);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8550) then Result := 'COMBINER0' else
      if self.val = UInt32($8551) then Result := 'COMBINER1' else
      if self.val = UInt32($8552) then Result := 'COMBINER2' else
      if self.val = UInt32($8553) then Result := 'COMBINER3' else
      if self.val = UInt32($8554) then Result := 'COMBINER4' else
      if self.val = UInt32($8555) then Result := 'COMBINER5' else
      if self.val = UInt32($8556) then Result := 'COMBINER6' else
      if self.val = UInt32($8557) then Result := 'COMBINER7' else
        Result := $'CombinerStage[{self.val}]';
    end;
    
  end;
  
  CombinerVariable = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VARIABLE_A: CombinerVariable read new CombinerVariable($8523);
    public static property VARIABLE_B: CombinerVariable read new CombinerVariable($8524);
    public static property VARIABLE_C: CombinerVariable read new CombinerVariable($8525);
    public static property VARIABLE_D: CombinerVariable read new CombinerVariable($8526);
    public static property VARIABLE_E: CombinerVariable read new CombinerVariable($8527);
    public static property VARIABLE_F: CombinerVariable read new CombinerVariable($8528);
    public static property VARIABLE_G: CombinerVariable read new CombinerVariable($8529);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8523) then Result := 'VARIABLE_A' else
      if self.val = UInt32($8524) then Result := 'VARIABLE_B' else
      if self.val = UInt32($8525) then Result := 'VARIABLE_C' else
      if self.val = UInt32($8526) then Result := 'VARIABLE_D' else
      if self.val = UInt32($8527) then Result := 'VARIABLE_E' else
      if self.val = UInt32($8528) then Result := 'VARIABLE_F' else
      if self.val = UInt32($8529) then Result := 'VARIABLE_G' else
        Result := $'CombinerVariable[{self.val}]';
    end;
    
  end;
  
  CommandOpcodes = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TERMINATE_SEQUENCE_COMMAND:      CommandOpcodes read new CommandOpcodes($0000);
    public static property NOP_COMMAND:                     CommandOpcodes read new CommandOpcodes($0001);
    public static property DRAW_ELEMENTS_COMMAND:           CommandOpcodes read new CommandOpcodes($0002);
    public static property DRAW_ARRAYS_COMMAND:             CommandOpcodes read new CommandOpcodes($0003);
    public static property DRAW_ELEMENTS_STRIP_COMMAND:     CommandOpcodes read new CommandOpcodes($0004);
    public static property DRAW_ARRAYS_STRIP_COMMAND:       CommandOpcodes read new CommandOpcodes($0005);
    public static property DRAW_ELEMENTS_INSTANCED_COMMAND: CommandOpcodes read new CommandOpcodes($0006);
    public static property DRAW_ARRAYS_INSTANCED_COMMAND:   CommandOpcodes read new CommandOpcodes($0007);
    public static property ELEMENT_ADDRESS_COMMAND:         CommandOpcodes read new CommandOpcodes($0008);
    public static property ATTRIBUTE_ADDRESS_COMMAND:       CommandOpcodes read new CommandOpcodes($0009);
    public static property UNIFORM_ADDRESS_COMMAND:         CommandOpcodes read new CommandOpcodes($000A);
    public static property BLEND_COLOR_COMMAND:             CommandOpcodes read new CommandOpcodes($000B);
    public static property STENCIL_REF_COMMAND:             CommandOpcodes read new CommandOpcodes($000C);
    public static property LINE_WIDTH_COMMAND:              CommandOpcodes read new CommandOpcodes($000D);
    public static property POLYGON_OFFSET_COMMAND:          CommandOpcodes read new CommandOpcodes($000E);
    public static property ALPHA_REF_COMMAND:               CommandOpcodes read new CommandOpcodes($000F);
    public static property VIEWPORT_COMMAND:                CommandOpcodes read new CommandOpcodes($0010);
    public static property SCISSOR_COMMAND:                 CommandOpcodes read new CommandOpcodes($0011);
    public static property FRONT_FACE_COMMAND:              CommandOpcodes read new CommandOpcodes($0012);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'TERMINATE_SEQUENCE_COMMAND' else
      if self.val = UInt32($0001) then Result := 'NOP_COMMAND' else
      if self.val = UInt32($0002) then Result := 'DRAW_ELEMENTS_COMMAND' else
      if self.val = UInt32($0003) then Result := 'DRAW_ARRAYS_COMMAND' else
      if self.val = UInt32($0004) then Result := 'DRAW_ELEMENTS_STRIP_COMMAND' else
      if self.val = UInt32($0005) then Result := 'DRAW_ARRAYS_STRIP_COMMAND' else
      if self.val = UInt32($0006) then Result := 'DRAW_ELEMENTS_INSTANCED_COMMAND' else
      if self.val = UInt32($0007) then Result := 'DRAW_ARRAYS_INSTANCED_COMMAND' else
      if self.val = UInt32($0008) then Result := 'ELEMENT_ADDRESS_COMMAND' else
      if self.val = UInt32($0009) then Result := 'ATTRIBUTE_ADDRESS_COMMAND' else
      if self.val = UInt32($000A) then Result := 'UNIFORM_ADDRESS_COMMAND' else
      if self.val = UInt32($000B) then Result := 'BLEND_COLOR_COMMAND' else
      if self.val = UInt32($000C) then Result := 'STENCIL_REF_COMMAND' else
      if self.val = UInt32($000D) then Result := 'LINE_WIDTH_COMMAND' else
      if self.val = UInt32($000E) then Result := 'POLYGON_OFFSET_COMMAND' else
      if self.val = UInt32($000F) then Result := 'ALPHA_REF_COMMAND' else
      if self.val = UInt32($0010) then Result := 'VIEWPORT_COMMAND' else
      if self.val = UInt32($0011) then Result := 'SCISSOR_COMMAND' else
      if self.val = UInt32($0012) then Result := 'FRONT_FACE_COMMAND' else
        Result := $'CommandOpcodes[{self.val}]';
    end;
    
  end;
  
  ConditionalRenderMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property QUERY_WAIT:                       ConditionalRenderMode read new ConditionalRenderMode($8E13);
    public static property QUERY_NO_WAIT:                    ConditionalRenderMode read new ConditionalRenderMode($8E14);
    public static property QUERY_BY_REGION_WAIT:             ConditionalRenderMode read new ConditionalRenderMode($8E15);
    public static property QUERY_BY_REGION_NO_WAIT:          ConditionalRenderMode read new ConditionalRenderMode($8E16);
    public static property QUERY_WAIT_INVERTED:              ConditionalRenderMode read new ConditionalRenderMode($8E17);
    public static property QUERY_NO_WAIT_INVERTED:           ConditionalRenderMode read new ConditionalRenderMode($8E18);
    public static property QUERY_BY_REGION_WAIT_INVERTED:    ConditionalRenderMode read new ConditionalRenderMode($8E19);
    public static property QUERY_BY_REGION_NO_WAIT_INVERTED: ConditionalRenderMode read new ConditionalRenderMode($8E1A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8E13) then Result := 'QUERY_WAIT' else
      if self.val = UInt32($8E14) then Result := 'QUERY_NO_WAIT' else
      if self.val = UInt32($8E15) then Result := 'QUERY_BY_REGION_WAIT' else
      if self.val = UInt32($8E16) then Result := 'QUERY_BY_REGION_NO_WAIT' else
      if self.val = UInt32($8E17) then Result := 'QUERY_WAIT_INVERTED' else
      if self.val = UInt32($8E18) then Result := 'QUERY_NO_WAIT_INVERTED' else
      if self.val = UInt32($8E19) then Result := 'QUERY_BY_REGION_WAIT_INVERTED' else
      if self.val = UInt32($8E1A) then Result := 'QUERY_BY_REGION_NO_WAIT_INVERTED' else
        Result := $'ConditionalRenderMode[{self.val}]';
    end;
    
  end;
  
  ContainerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROGRAM_OBJECT: ContainerType read new ContainerType($8B40);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8B40) then Result := 'PROGRAM_OBJECT' else
        Result := $'ContainerType[{self.val}]';
    end;
    
  end;
  
  ContextFlagMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: ContextFlagMask read new ContextFlagMask($0001);
    public static property CONTEXT_FLAG_DEBUG_BIT:              ContextFlagMask read new ContextFlagMask($0002);
    public static property CONTEXT_FLAG_ROBUST_ACCESS_BIT:      ContextFlagMask read new ContextFlagMask($0004);
    public static property CONTEXT_FLAG_NO_ERROR_BIT:           ContextFlagMask read new ContextFlagMask($0008);
    public static property CONTEXT_FLAG_PROTECTED_CONTENT_BIT:  ContextFlagMask read new ContextFlagMask($0010);
    
    public static function operator+(f1,f2: ContextFlagMask) := new ContextFlagMask(f1.val or f2.val);
    public static function operator or(f1,f2: ContextFlagMask) := f1+f2;
    
    public static procedure operator+=(var f1: ContextFlagMask; f2: ContextFlagMask) := f1 := f1+f2;
    
    public property HAS_FLAG_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_CONTEXT_FLAG_DEBUG_BIT:              boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_CONTEXT_FLAG_ROBUST_ACCESS_BIT:      boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_CONTEXT_FLAG_NO_ERROR_BIT:           boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_CONTEXT_FLAG_PROTECTED_CONTENT_BIT:  boolean read self.val and $0010 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'CONTEXT_FLAG_DEBUG_BIT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'CONTEXT_FLAG_ROBUST_ACCESS_BIT+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'CONTEXT_FLAG_NO_ERROR_BIT+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'CONTEXT_FLAG_PROTECTED_CONTENT_BIT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'ContextFlagMask[{self.val}]';
    end;
    
  end;
  
  ContextProfileMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CONTEXT_CORE_PROFILE_BIT:          ContextProfileMask read new ContextProfileMask($0001);
    public static property CONTEXT_COMPATIBILITY_PROFILE_BIT: ContextProfileMask read new ContextProfileMask($0002);
    
    public static function operator+(f1,f2: ContextProfileMask) := new ContextProfileMask(f1.val or f2.val);
    public static function operator or(f1,f2: ContextProfileMask) := f1+f2;
    
    public static procedure operator+=(var f1: ContextProfileMask; f2: ContextProfileMask) := f1 := f1+f2;
    
    public property HAS_FLAG_CONTEXT_CORE_PROFILE_BIT:          boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_CONTEXT_COMPATIBILITY_PROFILE_BIT: boolean read self.val and $0002 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'CONTEXT_CORE_PROFILE_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'CONTEXT_COMPATIBILITY_PROFILE_BIT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'ContextProfileMask[{self.val}]';
    end;
    
  end;
  
  ConvolutionBorderMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property REDUCE: ConvolutionBorderMode read new ConvolutionBorderMode($8016);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8016) then Result := 'REDUCE' else
        Result := $'ConvolutionBorderMode[{self.val}]';
    end;
    
  end;
  
  ConvolutionParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CONVOLUTION_BORDER_MODE:  ConvolutionParameter read new ConvolutionParameter($8013);
    public static property CONVOLUTION_FILTER_SCALE: ConvolutionParameter read new ConvolutionParameter($8014);
    public static property CONVOLUTION_FILTER_BIAS:  ConvolutionParameter read new ConvolutionParameter($8015);
    public static property CONVOLUTION_FORMAT:       ConvolutionParameter read new ConvolutionParameter($8017);
    public static property CONVOLUTION_WIDTH:        ConvolutionParameter read new ConvolutionParameter($8018);
    public static property CONVOLUTION_HEIGHT:       ConvolutionParameter read new ConvolutionParameter($8019);
    public static property MAX_CONVOLUTION_WIDTH:    ConvolutionParameter read new ConvolutionParameter($801A);
    public static property MAX_CONVOLUTION_HEIGHT:   ConvolutionParameter read new ConvolutionParameter($801B);
    public static property CONVOLUTION_BORDER_COLOR: ConvolutionParameter read new ConvolutionParameter($8154);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8013) then Result := 'CONVOLUTION_BORDER_MODE' else
      if self.val = UInt32($8014) then Result := 'CONVOLUTION_FILTER_SCALE' else
      if self.val = UInt32($8015) then Result := 'CONVOLUTION_FILTER_BIAS' else
      if self.val = UInt32($8017) then Result := 'CONVOLUTION_FORMAT' else
      if self.val = UInt32($8018) then Result := 'CONVOLUTION_WIDTH' else
      if self.val = UInt32($8019) then Result := 'CONVOLUTION_HEIGHT' else
      if self.val = UInt32($801A) then Result := 'MAX_CONVOLUTION_WIDTH' else
      if self.val = UInt32($801B) then Result := 'MAX_CONVOLUTION_HEIGHT' else
      if self.val = UInt32($8154) then Result := 'CONVOLUTION_BORDER_COLOR' else
        Result := $'ConvolutionParameter[{self.val}]';
    end;
    
  end;
  
  ConvolutionTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CONVOLUTION_1D: ConvolutionTarget read new ConvolutionTarget($8010);
    public static property CONVOLUTION_2D: ConvolutionTarget read new ConvolutionTarget($8011);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8010) then Result := 'CONVOLUTION_1D' else
      if self.val = UInt32($8011) then Result := 'CONVOLUTION_2D' else
        Result := $'ConvolutionTarget[{self.val}]';
    end;
    
  end;
  
  CopyBufferSubDataTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ARRAY_BUFFER:              CopyBufferSubDataTarget read new CopyBufferSubDataTarget($8892);
    public static property ELEMENT_ARRAY_BUFFER:      CopyBufferSubDataTarget read new CopyBufferSubDataTarget($8893);
    public static property PIXEL_PACK_BUFFER:         CopyBufferSubDataTarget read new CopyBufferSubDataTarget($88EB);
    public static property PIXEL_UNPACK_BUFFER:       CopyBufferSubDataTarget read new CopyBufferSubDataTarget($88EC);
    public static property UNIFORM_BUFFER:            CopyBufferSubDataTarget read new CopyBufferSubDataTarget($8A11);
    public static property TEXTURE_BUFFER:            CopyBufferSubDataTarget read new CopyBufferSubDataTarget($8C2A);
    public static property TRANSFORM_FEEDBACK_BUFFER: CopyBufferSubDataTarget read new CopyBufferSubDataTarget($8C8E);
    public static property COPY_READ_BUFFER:          CopyBufferSubDataTarget read new CopyBufferSubDataTarget($8F36);
    public static property COPY_WRITE_BUFFER:         CopyBufferSubDataTarget read new CopyBufferSubDataTarget($8F37);
    public static property DRAW_INDIRECT_BUFFER:      CopyBufferSubDataTarget read new CopyBufferSubDataTarget($8F3F);
    public static property SHADER_STORAGE_BUFFER:     CopyBufferSubDataTarget read new CopyBufferSubDataTarget($90D2);
    public static property DISPATCH_INDIRECT_BUFFER:  CopyBufferSubDataTarget read new CopyBufferSubDataTarget($90EE);
    public static property QUERY_BUFFER:              CopyBufferSubDataTarget read new CopyBufferSubDataTarget($9192);
    public static property ATOMIC_COUNTER_BUFFER:     CopyBufferSubDataTarget read new CopyBufferSubDataTarget($92C0);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8892) then Result := 'ARRAY_BUFFER' else
      if self.val = UInt32($8893) then Result := 'ELEMENT_ARRAY_BUFFER' else
      if self.val = UInt32($88EB) then Result := 'PIXEL_PACK_BUFFER' else
      if self.val = UInt32($88EC) then Result := 'PIXEL_UNPACK_BUFFER' else
      if self.val = UInt32($8A11) then Result := 'UNIFORM_BUFFER' else
      if self.val = UInt32($8C2A) then Result := 'TEXTURE_BUFFER' else
      if self.val = UInt32($8C8E) then Result := 'TRANSFORM_FEEDBACK_BUFFER' else
      if self.val = UInt32($8F36) then Result := 'COPY_READ_BUFFER' else
      if self.val = UInt32($8F37) then Result := 'COPY_WRITE_BUFFER' else
      if self.val = UInt32($8F3F) then Result := 'DRAW_INDIRECT_BUFFER' else
      if self.val = UInt32($90D2) then Result := 'SHADER_STORAGE_BUFFER' else
      if self.val = UInt32($90EE) then Result := 'DISPATCH_INDIRECT_BUFFER' else
      if self.val = UInt32($9192) then Result := 'QUERY_BUFFER' else
      if self.val = UInt32($92C0) then Result := 'ATOMIC_COUNTER_BUFFER' else
        Result := $'CopyBufferSubDataTarget[{self.val}]';
    end;
    
  end;
  
  CopyImageSubDataTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_1D:                   CopyImageSubDataTarget read new CopyImageSubDataTarget($0DE0);
    public static property TEXTURE_2D:                   CopyImageSubDataTarget read new CopyImageSubDataTarget($0DE1);
    public static property TEXTURE_3D:                   CopyImageSubDataTarget read new CopyImageSubDataTarget($806F);
    public static property TEXTURE_RECTANGLE:            CopyImageSubDataTarget read new CopyImageSubDataTarget($84F5);
    public static property TEXTURE_CUBE_MAP:             CopyImageSubDataTarget read new CopyImageSubDataTarget($8513);
    public static property TEXTURE_1D_ARRAY:             CopyImageSubDataTarget read new CopyImageSubDataTarget($8C18);
    public static property TEXTURE_2D_ARRAY:             CopyImageSubDataTarget read new CopyImageSubDataTarget($8C1A);
    public static property RENDERBUFFER:                 CopyImageSubDataTarget read new CopyImageSubDataTarget($8D41);
    public static property TEXTURE_CUBE_MAP_ARRAY:       CopyImageSubDataTarget read new CopyImageSubDataTarget($9009);
    public static property TEXTURE_2D_MULTISAMPLE:       CopyImageSubDataTarget read new CopyImageSubDataTarget($9100);
    public static property TEXTURE_2D_MULTISAMPLE_ARRAY: CopyImageSubDataTarget read new CopyImageSubDataTarget($9102);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0DE0) then Result := 'TEXTURE_1D' else
      if self.val = UInt32($0DE1) then Result := 'TEXTURE_2D' else
      if self.val = UInt32($806F) then Result := 'TEXTURE_3D' else
      if self.val = UInt32($84F5) then Result := 'TEXTURE_RECTANGLE' else
      if self.val = UInt32($8513) then Result := 'TEXTURE_CUBE_MAP' else
      if self.val = UInt32($8C18) then Result := 'TEXTURE_1D_ARRAY' else
      if self.val = UInt32($8C1A) then Result := 'TEXTURE_2D_ARRAY' else
      if self.val = UInt32($8D41) then Result := 'RENDERBUFFER' else
      if self.val = UInt32($9009) then Result := 'TEXTURE_CUBE_MAP_ARRAY' else
      if self.val = UInt32($9100) then Result := 'TEXTURE_2D_MULTISAMPLE' else
      if self.val = UInt32($9102) then Result := 'TEXTURE_2D_MULTISAMPLE_ARRAY' else
        Result := $'CopyImageSubDataTarget[{self.val}]';
    end;
    
  end;
  
  CullParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CULL_VERTEX_EYE_POSITION:    CullParameter read new CullParameter($81AB);
    public static property CULL_VERTEX_OBJECT_POSITION: CullParameter read new CullParameter($81AC);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($81AB) then Result := 'CULL_VERTEX_EYE_POSITION' else
      if self.val = UInt32($81AC) then Result := 'CULL_VERTEX_OBJECT_POSITION' else
        Result := $'CullParameter[{self.val}]';
    end;
    
  end;
  
  DataType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SCALAR: DataType read new DataType($87BE);
    public static property VECTOR: DataType read new DataType($87BF);
    public static property MATRIX: DataType read new DataType($87C0);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($87BE) then Result := 'SCALAR' else
      if self.val = UInt32($87BF) then Result := 'VECTOR' else
      if self.val = UInt32($87C0) then Result := 'MATRIX' else
        Result := $'DataType[{self.val}]';
    end;
    
  end;
  
  DebugSeverity = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DONT_CARE:                   DebugSeverity read new DebugSeverity($1100);
    public static property DEBUG_SEVERITY_NOTIFICATION: DebugSeverity read new DebugSeverity($826B);
    public static property DEBUG_SEVERITY_HIGH:         DebugSeverity read new DebugSeverity($9146);
    public static property DEBUG_SEVERITY_MEDIUM:       DebugSeverity read new DebugSeverity($9147);
    public static property DEBUG_SEVERITY_LOW:          DebugSeverity read new DebugSeverity($9148);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1100) then Result := 'DONT_CARE' else
      if self.val = UInt32($826B) then Result := 'DEBUG_SEVERITY_NOTIFICATION' else
      if self.val = UInt32($9146) then Result := 'DEBUG_SEVERITY_HIGH' else
      if self.val = UInt32($9147) then Result := 'DEBUG_SEVERITY_MEDIUM' else
      if self.val = UInt32($9148) then Result := 'DEBUG_SEVERITY_LOW' else
        Result := $'DebugSeverity[{self.val}]';
    end;
    
  end;
  
  DebugSource = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DONT_CARE:                    DebugSource read new DebugSource($1100);
    public static property DEBUG_SOURCE_API:             DebugSource read new DebugSource($8246);
    public static property DEBUG_SOURCE_WINDOW_SYSTEM:   DebugSource read new DebugSource($8247);
    public static property DEBUG_SOURCE_SHADER_COMPILER: DebugSource read new DebugSource($8248);
    public static property DEBUG_SOURCE_THIRD_PARTY:     DebugSource read new DebugSource($8249);
    public static property DEBUG_SOURCE_APPLICATION:     DebugSource read new DebugSource($824A);
    public static property DEBUG_SOURCE_OTHER:           DebugSource read new DebugSource($824B);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1100) then Result := 'DONT_CARE' else
      if self.val = UInt32($8246) then Result := 'DEBUG_SOURCE_API' else
      if self.val = UInt32($8247) then Result := 'DEBUG_SOURCE_WINDOW_SYSTEM' else
      if self.val = UInt32($8248) then Result := 'DEBUG_SOURCE_SHADER_COMPILER' else
      if self.val = UInt32($8249) then Result := 'DEBUG_SOURCE_THIRD_PARTY' else
      if self.val = UInt32($824A) then Result := 'DEBUG_SOURCE_APPLICATION' else
      if self.val = UInt32($824B) then Result := 'DEBUG_SOURCE_OTHER' else
        Result := $'DebugSource[{self.val}]';
    end;
    
  end;
  
  DebugType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DONT_CARE:                      DebugType read new DebugType($1100);
    public static property DEBUG_TYPE_ERROR:               DebugType read new DebugType($824C);
    public static property DEBUG_TYPE_DEPRECATED_BEHAVIOR: DebugType read new DebugType($824D);
    public static property DEBUG_TYPE_UNDEFINED_BEHAVIOR:  DebugType read new DebugType($824E);
    public static property DEBUG_TYPE_PORTABILITY:         DebugType read new DebugType($824F);
    public static property DEBUG_TYPE_PERFORMANCE:         DebugType read new DebugType($8250);
    public static property DEBUG_TYPE_OTHER:               DebugType read new DebugType($8251);
    public static property DEBUG_TYPE_MARKER:              DebugType read new DebugType($8268);
    public static property DEBUG_TYPE_PUSH_GROUP:          DebugType read new DebugType($8269);
    public static property DEBUG_TYPE_POP_GROUP:           DebugType read new DebugType($826A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1100) then Result := 'DONT_CARE' else
      if self.val = UInt32($824C) then Result := 'DEBUG_TYPE_ERROR' else
      if self.val = UInt32($824D) then Result := 'DEBUG_TYPE_DEPRECATED_BEHAVIOR' else
      if self.val = UInt32($824E) then Result := 'DEBUG_TYPE_UNDEFINED_BEHAVIOR' else
      if self.val = UInt32($824F) then Result := 'DEBUG_TYPE_PORTABILITY' else
      if self.val = UInt32($8250) then Result := 'DEBUG_TYPE_PERFORMANCE' else
      if self.val = UInt32($8251) then Result := 'DEBUG_TYPE_OTHER' else
      if self.val = UInt32($8268) then Result := 'DEBUG_TYPE_MARKER' else
      if self.val = UInt32($8269) then Result := 'DEBUG_TYPE_PUSH_GROUP' else
      if self.val = UInt32($826A) then Result := 'DEBUG_TYPE_POP_GROUP' else
        Result := $'DebugType[{self.val}]';
    end;
    
  end;
  
  DepthFunction = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEVER:    DepthFunction read new DepthFunction($0200);
    public static property LESS:     DepthFunction read new DepthFunction($0201);
    public static property EQUAL:    DepthFunction read new DepthFunction($0202);
    public static property LEQUAL:   DepthFunction read new DepthFunction($0203);
    public static property GREATER:  DepthFunction read new DepthFunction($0204);
    public static property NOTEQUAL: DepthFunction read new DepthFunction($0205);
    public static property GEQUAL:   DepthFunction read new DepthFunction($0206);
    public static property ALWAYS:   DepthFunction read new DepthFunction($0207);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0200) then Result := 'NEVER' else
      if self.val = UInt32($0201) then Result := 'LESS' else
      if self.val = UInt32($0202) then Result := 'EQUAL' else
      if self.val = UInt32($0203) then Result := 'LEQUAL' else
      if self.val = UInt32($0204) then Result := 'GREATER' else
      if self.val = UInt32($0205) then Result := 'NOTEQUAL' else
      if self.val = UInt32($0206) then Result := 'GEQUAL' else
      if self.val = UInt32($0207) then Result := 'ALWAYS' else
        Result := $'DepthFunction[{self.val}]';
    end;
    
  end;
  
  DepthStencilTextureMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property STENCIL_INDEX:   DepthStencilTextureMode read new DepthStencilTextureMode($1901);
    public static property DEPTH_COMPONENT: DepthStencilTextureMode read new DepthStencilTextureMode($1902);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1901) then Result := 'STENCIL_INDEX' else
      if self.val = UInt32($1902) then Result := 'DEPTH_COMPONENT' else
        Result := $'DepthStencilTextureMode[{self.val}]';
    end;
    
  end;
  
  DrawBufferMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:               DrawBufferMode read new DrawBufferMode($0000);
    public static property FRONT_LEFT:         DrawBufferMode read new DrawBufferMode($0400);
    public static property FRONT_RIGHT:        DrawBufferMode read new DrawBufferMode($0401);
    public static property BACK_LEFT:          DrawBufferMode read new DrawBufferMode($0402);
    public static property BACK_RIGHT:         DrawBufferMode read new DrawBufferMode($0403);
    public static property FRONT:              DrawBufferMode read new DrawBufferMode($0404);
    public static property BACK:               DrawBufferMode read new DrawBufferMode($0405);
    public static property LEFT:               DrawBufferMode read new DrawBufferMode($0406);
    public static property RIGHT:              DrawBufferMode read new DrawBufferMode($0407);
    public static property FRONT_AND_BACK:     DrawBufferMode read new DrawBufferMode($0408);
    public static property AUX0:               DrawBufferMode read new DrawBufferMode($0409);
    public static property AUX1:               DrawBufferMode read new DrawBufferMode($040A);
    public static property AUX2:               DrawBufferMode read new DrawBufferMode($040B);
    public static property AUX3:               DrawBufferMode read new DrawBufferMode($040C);
    public static property COLOR_ATTACHMENT0:  DrawBufferMode read new DrawBufferMode($8CE0);
    public static property COLOR_ATTACHMENT1:  DrawBufferMode read new DrawBufferMode($8CE1);
    public static property COLOR_ATTACHMENT2:  DrawBufferMode read new DrawBufferMode($8CE2);
    public static property COLOR_ATTACHMENT3:  DrawBufferMode read new DrawBufferMode($8CE3);
    public static property COLOR_ATTACHMENT4:  DrawBufferMode read new DrawBufferMode($8CE4);
    public static property COLOR_ATTACHMENT5:  DrawBufferMode read new DrawBufferMode($8CE5);
    public static property COLOR_ATTACHMENT6:  DrawBufferMode read new DrawBufferMode($8CE6);
    public static property COLOR_ATTACHMENT7:  DrawBufferMode read new DrawBufferMode($8CE7);
    public static property COLOR_ATTACHMENT8:  DrawBufferMode read new DrawBufferMode($8CE8);
    public static property COLOR_ATTACHMENT9:  DrawBufferMode read new DrawBufferMode($8CE9);
    public static property COLOR_ATTACHMENT10: DrawBufferMode read new DrawBufferMode($8CEA);
    public static property COLOR_ATTACHMENT11: DrawBufferMode read new DrawBufferMode($8CEB);
    public static property COLOR_ATTACHMENT12: DrawBufferMode read new DrawBufferMode($8CEC);
    public static property COLOR_ATTACHMENT13: DrawBufferMode read new DrawBufferMode($8CED);
    public static property COLOR_ATTACHMENT14: DrawBufferMode read new DrawBufferMode($8CEE);
    public static property COLOR_ATTACHMENT15: DrawBufferMode read new DrawBufferMode($8CEF);
    public static property COLOR_ATTACHMENT16: DrawBufferMode read new DrawBufferMode($8CF0);
    public static property COLOR_ATTACHMENT17: DrawBufferMode read new DrawBufferMode($8CF1);
    public static property COLOR_ATTACHMENT18: DrawBufferMode read new DrawBufferMode($8CF2);
    public static property COLOR_ATTACHMENT19: DrawBufferMode read new DrawBufferMode($8CF3);
    public static property COLOR_ATTACHMENT20: DrawBufferMode read new DrawBufferMode($8CF4);
    public static property COLOR_ATTACHMENT21: DrawBufferMode read new DrawBufferMode($8CF5);
    public static property COLOR_ATTACHMENT22: DrawBufferMode read new DrawBufferMode($8CF6);
    public static property COLOR_ATTACHMENT23: DrawBufferMode read new DrawBufferMode($8CF7);
    public static property COLOR_ATTACHMENT24: DrawBufferMode read new DrawBufferMode($8CF8);
    public static property COLOR_ATTACHMENT25: DrawBufferMode read new DrawBufferMode($8CF9);
    public static property COLOR_ATTACHMENT26: DrawBufferMode read new DrawBufferMode($8CFA);
    public static property COLOR_ATTACHMENT27: DrawBufferMode read new DrawBufferMode($8CFB);
    public static property COLOR_ATTACHMENT28: DrawBufferMode read new DrawBufferMode($8CFC);
    public static property COLOR_ATTACHMENT29: DrawBufferMode read new DrawBufferMode($8CFD);
    public static property COLOR_ATTACHMENT30: DrawBufferMode read new DrawBufferMode($8CFE);
    public static property COLOR_ATTACHMENT31: DrawBufferMode read new DrawBufferMode($8CFF);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($0400) then Result := 'FRONT_LEFT' else
      if self.val = UInt32($0401) then Result := 'FRONT_RIGHT' else
      if self.val = UInt32($0402) then Result := 'BACK_LEFT' else
      if self.val = UInt32($0403) then Result := 'BACK_RIGHT' else
      if self.val = UInt32($0404) then Result := 'FRONT' else
      if self.val = UInt32($0405) then Result := 'BACK' else
      if self.val = UInt32($0406) then Result := 'LEFT' else
      if self.val = UInt32($0407) then Result := 'RIGHT' else
      if self.val = UInt32($0408) then Result := 'FRONT_AND_BACK' else
      if self.val = UInt32($0409) then Result := 'AUX0' else
      if self.val = UInt32($040A) then Result := 'AUX1' else
      if self.val = UInt32($040B) then Result := 'AUX2' else
      if self.val = UInt32($040C) then Result := 'AUX3' else
      if self.val = UInt32($8CE0) then Result := 'COLOR_ATTACHMENT0' else
      if self.val = UInt32($8CE1) then Result := 'COLOR_ATTACHMENT1' else
      if self.val = UInt32($8CE2) then Result := 'COLOR_ATTACHMENT2' else
      if self.val = UInt32($8CE3) then Result := 'COLOR_ATTACHMENT3' else
      if self.val = UInt32($8CE4) then Result := 'COLOR_ATTACHMENT4' else
      if self.val = UInt32($8CE5) then Result := 'COLOR_ATTACHMENT5' else
      if self.val = UInt32($8CE6) then Result := 'COLOR_ATTACHMENT6' else
      if self.val = UInt32($8CE7) then Result := 'COLOR_ATTACHMENT7' else
      if self.val = UInt32($8CE8) then Result := 'COLOR_ATTACHMENT8' else
      if self.val = UInt32($8CE9) then Result := 'COLOR_ATTACHMENT9' else
      if self.val = UInt32($8CEA) then Result := 'COLOR_ATTACHMENT10' else
      if self.val = UInt32($8CEB) then Result := 'COLOR_ATTACHMENT11' else
      if self.val = UInt32($8CEC) then Result := 'COLOR_ATTACHMENT12' else
      if self.val = UInt32($8CED) then Result := 'COLOR_ATTACHMENT13' else
      if self.val = UInt32($8CEE) then Result := 'COLOR_ATTACHMENT14' else
      if self.val = UInt32($8CEF) then Result := 'COLOR_ATTACHMENT15' else
      if self.val = UInt32($8CF0) then Result := 'COLOR_ATTACHMENT16' else
      if self.val = UInt32($8CF1) then Result := 'COLOR_ATTACHMENT17' else
      if self.val = UInt32($8CF2) then Result := 'COLOR_ATTACHMENT18' else
      if self.val = UInt32($8CF3) then Result := 'COLOR_ATTACHMENT19' else
      if self.val = UInt32($8CF4) then Result := 'COLOR_ATTACHMENT20' else
      if self.val = UInt32($8CF5) then Result := 'COLOR_ATTACHMENT21' else
      if self.val = UInt32($8CF6) then Result := 'COLOR_ATTACHMENT22' else
      if self.val = UInt32($8CF7) then Result := 'COLOR_ATTACHMENT23' else
      if self.val = UInt32($8CF8) then Result := 'COLOR_ATTACHMENT24' else
      if self.val = UInt32($8CF9) then Result := 'COLOR_ATTACHMENT25' else
      if self.val = UInt32($8CFA) then Result := 'COLOR_ATTACHMENT26' else
      if self.val = UInt32($8CFB) then Result := 'COLOR_ATTACHMENT27' else
      if self.val = UInt32($8CFC) then Result := 'COLOR_ATTACHMENT28' else
      if self.val = UInt32($8CFD) then Result := 'COLOR_ATTACHMENT29' else
      if self.val = UInt32($8CFE) then Result := 'COLOR_ATTACHMENT30' else
      if self.val = UInt32($8CFF) then Result := 'COLOR_ATTACHMENT31' else
        Result := $'DrawBufferMode[{self.val}]';
    end;
    
  end;
  
  DrawElementsType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNSIGNED_BYTE:  DrawElementsType read new DrawElementsType($1401);
    public static property UNSIGNED_SHORT: DrawElementsType read new DrawElementsType($1403);
    public static property UNSIGNED_INT:   DrawElementsType read new DrawElementsType($1405);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
        Result := $'DrawElementsType[{self.val}]';
    end;
    
  end;
  
  ElementPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNSIGNED_BYTE:  ElementPointerType read new ElementPointerType($1401);
    public static property UNSIGNED_SHORT: ElementPointerType read new ElementPointerType($1403);
    public static property UNSIGNED_INT:   ElementPointerType read new ElementPointerType($1405);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
        Result := $'ElementPointerType[{self.val}]';
    end;
    
  end;
  
  EnableCap = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINT_SMOOTH:                       EnableCap read new EnableCap($0B10);
    public static property LINE_SMOOTH:                        EnableCap read new EnableCap($0B20);
    public static property LINE_STIPPLE:                       EnableCap read new EnableCap($0B24);
    public static property POLYGON_SMOOTH:                     EnableCap read new EnableCap($0B41);
    public static property POLYGON_STIPPLE:                    EnableCap read new EnableCap($0B42);
    public static property CULL_FACE:                          EnableCap read new EnableCap($0B44);
    public static property LIGHTING:                           EnableCap read new EnableCap($0B50);
    public static property COLOR_MATERIAL:                     EnableCap read new EnableCap($0B57);
    public static property FOG:                                EnableCap read new EnableCap($0B60);
    public static property DEPTH_TEST:                         EnableCap read new EnableCap($0B71);
    public static property STENCIL_TEST:                       EnableCap read new EnableCap($0B90);
    public static property NORMALIZE:                          EnableCap read new EnableCap($0BA1);
    public static property ALPHA_TEST:                         EnableCap read new EnableCap($0BC0);
    public static property DITHER:                             EnableCap read new EnableCap($0BD0);
    public static property BLEND:                              EnableCap read new EnableCap($0BE2);
    public static property INDEX_LOGIC_OP:                     EnableCap read new EnableCap($0BF1);
    public static property COLOR_LOGIC_OP:                     EnableCap read new EnableCap($0BF2);
    public static property SCISSOR_TEST:                       EnableCap read new EnableCap($0C11);
    public static property TEXTURE_GEN_S:                      EnableCap read new EnableCap($0C60);
    public static property TEXTURE_GEN_T:                      EnableCap read new EnableCap($0C61);
    public static property TEXTURE_GEN_R:                      EnableCap read new EnableCap($0C62);
    public static property TEXTURE_GEN_Q:                      EnableCap read new EnableCap($0C63);
    public static property AUTO_NORMAL:                        EnableCap read new EnableCap($0D80);
    public static property MAP1_COLOR_4:                       EnableCap read new EnableCap($0D90);
    public static property MAP1_INDEX:                         EnableCap read new EnableCap($0D91);
    public static property MAP1_NORMAL:                        EnableCap read new EnableCap($0D92);
    public static property MAP1_TEXTURE_COORD_1:               EnableCap read new EnableCap($0D93);
    public static property MAP1_TEXTURE_COORD_2:               EnableCap read new EnableCap($0D94);
    public static property MAP1_TEXTURE_COORD_3:               EnableCap read new EnableCap($0D95);
    public static property MAP1_TEXTURE_COORD_4:               EnableCap read new EnableCap($0D96);
    public static property MAP1_VERTEX_3:                      EnableCap read new EnableCap($0D97);
    public static property MAP1_VERTEX_4:                      EnableCap read new EnableCap($0D98);
    public static property MAP2_COLOR_4:                       EnableCap read new EnableCap($0DB0);
    public static property MAP2_INDEX:                         EnableCap read new EnableCap($0DB1);
    public static property MAP2_NORMAL:                        EnableCap read new EnableCap($0DB2);
    public static property MAP2_TEXTURE_COORD_1:               EnableCap read new EnableCap($0DB3);
    public static property MAP2_TEXTURE_COORD_2:               EnableCap read new EnableCap($0DB4);
    public static property MAP2_TEXTURE_COORD_3:               EnableCap read new EnableCap($0DB5);
    public static property MAP2_TEXTURE_COORD_4:               EnableCap read new EnableCap($0DB6);
    public static property MAP2_VERTEX_3:                      EnableCap read new EnableCap($0DB7);
    public static property MAP2_VERTEX_4:                      EnableCap read new EnableCap($0DB8);
    public static property TEXTURE_1D:                         EnableCap read new EnableCap($0DE0);
    public static property TEXTURE_2D:                         EnableCap read new EnableCap($0DE1);
    public static property POLYGON_OFFSET_POINT:               EnableCap read new EnableCap($2A01);
    public static property POLYGON_OFFSET_LINE:                EnableCap read new EnableCap($2A02);
    public static property CLIP_PLANE0:                        EnableCap read new EnableCap($3000);
    public static property CLIP_DISTANCE0:                     EnableCap read new EnableCap($3000);
    public static property CLIP_PLANE1:                        EnableCap read new EnableCap($3001);
    public static property CLIP_DISTANCE1:                     EnableCap read new EnableCap($3001);
    public static property CLIP_PLANE2:                        EnableCap read new EnableCap($3002);
    public static property CLIP_DISTANCE2:                     EnableCap read new EnableCap($3002);
    public static property CLIP_PLANE3:                        EnableCap read new EnableCap($3003);
    public static property CLIP_DISTANCE3:                     EnableCap read new EnableCap($3003);
    public static property CLIP_PLANE4:                        EnableCap read new EnableCap($3004);
    public static property CLIP_DISTANCE4:                     EnableCap read new EnableCap($3004);
    public static property CLIP_PLANE5:                        EnableCap read new EnableCap($3005);
    public static property CLIP_DISTANCE5:                     EnableCap read new EnableCap($3005);
    public static property CLIP_DISTANCE6:                     EnableCap read new EnableCap($3006);
    public static property CLIP_DISTANCE7:                     EnableCap read new EnableCap($3007);
    public static property LIGHT0:                             EnableCap read new EnableCap($4000);
    public static property LIGHT1:                             EnableCap read new EnableCap($4001);
    public static property LIGHT2:                             EnableCap read new EnableCap($4002);
    public static property LIGHT3:                             EnableCap read new EnableCap($4003);
    public static property LIGHT4:                             EnableCap read new EnableCap($4004);
    public static property LIGHT5:                             EnableCap read new EnableCap($4005);
    public static property LIGHT6:                             EnableCap read new EnableCap($4006);
    public static property LIGHT7:                             EnableCap read new EnableCap($4007);
    public static property CONVOLUTION_1D:                     EnableCap read new EnableCap($8010);
    public static property CONVOLUTION_2D:                     EnableCap read new EnableCap($8011);
    public static property SEPARABLE_2D:                       EnableCap read new EnableCap($8012);
    public static property HISTOGRAM:                          EnableCap read new EnableCap($8024);
    public static property MINMAX:                             EnableCap read new EnableCap($802E);
    public static property POLYGON_OFFSET_FILL:                EnableCap read new EnableCap($8037);
    public static property RESCALE_NORMAL:                     EnableCap read new EnableCap($803A);
    public static property TEXTURE_3D:                         EnableCap read new EnableCap($806F);
    public static property VERTEX_ARRAY:                       EnableCap read new EnableCap($8074);
    public static property NORMAL_ARRAY:                       EnableCap read new EnableCap($8075);
    public static property COLOR_ARRAY:                        EnableCap read new EnableCap($8076);
    public static property INDEX_ARRAY:                        EnableCap read new EnableCap($8077);
    public static property TEXTURE_COORD_ARRAY:                EnableCap read new EnableCap($8078);
    public static property EDGE_FLAG_ARRAY:                    EnableCap read new EnableCap($8079);
    public static property INTERLACE:                          EnableCap read new EnableCap($8094);
    public static property MULTISAMPLE:                        EnableCap read new EnableCap($809D);
    public static property SAMPLE_ALPHA_TO_MASK:               EnableCap read new EnableCap($809E);
    public static property SAMPLE_ALPHA_TO_COVERAGE:           EnableCap read new EnableCap($809E);
    public static property SAMPLE_ALPHA_TO_ONE:                EnableCap read new EnableCap($809F);
    public static property SAMPLE_COVERAGE:                    EnableCap read new EnableCap($80A0);
    public static property SAMPLE_MASK_SGIS:                   EnableCap read new EnableCap($80A0);
    public static property TEXTURE_COLOR_TABLE:                EnableCap read new EnableCap($80BC);
    public static property COLOR_TABLE:                        EnableCap read new EnableCap($80D0);
    public static property POST_CONVOLUTION_COLOR_TABLE:       EnableCap read new EnableCap($80D1);
    public static property POST_COLOR_MATRIX_COLOR_TABLE:      EnableCap read new EnableCap($80D2);
    public static property TEXTURE_4D:                         EnableCap read new EnableCap($8134);
    public static property PIXEL_TEX_GEN:                      EnableCap read new EnableCap($8139);
    public static property SPRITE:                             EnableCap read new EnableCap($8148);
    public static property REFERENCE_PLANE:                    EnableCap read new EnableCap($817D);
    public static property IR_INSTRUMENT1:                     EnableCap read new EnableCap($817F);
    public static property CALLIGRAPHIC_FRAGMENT:              EnableCap read new EnableCap($8183);
    public static property FRAMEZOOM:                          EnableCap read new EnableCap($818B);
    public static property FOG_OFFSET:                         EnableCap read new EnableCap($8198);
    public static property SHARED_TEXTURE_PALETTE:             EnableCap read new EnableCap($81FB);
    public static property DEBUG_OUTPUT_SYNCHRONOUS:           EnableCap read new EnableCap($8242);
    public static property ASYNC_HISTOGRAM:                    EnableCap read new EnableCap($832C);
    public static property PIXEL_TEXTURE:                      EnableCap read new EnableCap($8353);
    public static property ASYNC_TEX_IMAGE:                    EnableCap read new EnableCap($835C);
    public static property ASYNC_DRAW_PIXELS:                  EnableCap read new EnableCap($835D);
    public static property ASYNC_READ_PIXELS:                  EnableCap read new EnableCap($835E);
    public static property FRAGMENT_LIGHTING:                  EnableCap read new EnableCap($8400);
    public static property FRAGMENT_COLOR_MATERIAL:            EnableCap read new EnableCap($8401);
    public static property FRAGMENT_LIGHT0:                    EnableCap read new EnableCap($840C);
    public static property FRAGMENT_LIGHT1:                    EnableCap read new EnableCap($840D);
    public static property FRAGMENT_LIGHT2:                    EnableCap read new EnableCap($840E);
    public static property FRAGMENT_LIGHT3:                    EnableCap read new EnableCap($840F);
    public static property FRAGMENT_LIGHT4:                    EnableCap read new EnableCap($8410);
    public static property FRAGMENT_LIGHT5:                    EnableCap read new EnableCap($8411);
    public static property FRAGMENT_LIGHT6:                    EnableCap read new EnableCap($8412);
    public static property FRAGMENT_LIGHT7:                    EnableCap read new EnableCap($8413);
    public static property TEXTURE_RECTANGLE:                  EnableCap read new EnableCap($84F5);
    public static property TEXTURE_CUBE_MAP:                   EnableCap read new EnableCap($8513);
    public static property PROGRAM_POINT_SIZE:                 EnableCap read new EnableCap($8642);
    public static property DEPTH_CLAMP:                        EnableCap read new EnableCap($864F);
    public static property TEXTURE_CUBE_MAP_SEAMLESS:          EnableCap read new EnableCap($884F);
    public static property SAMPLE_SHADING:                     EnableCap read new EnableCap($8C36);
    public static property RASTERIZER_DISCARD:                 EnableCap read new EnableCap($8C89);
    public static property TEXTURE_GEN_STR:                    EnableCap read new EnableCap($8D60);
    public static property PRIMITIVE_RESTART_FIXED_INDEX:      EnableCap read new EnableCap($8D69);
    public static property FRAMEBUFFER_SRGB:                   EnableCap read new EnableCap($8DB9);
    public static property SAMPLE_MASK:                        EnableCap read new EnableCap($8E51);
    public static property FETCH_PER_SAMPLE_ARM:               EnableCap read new EnableCap($8F65);
    public static property PRIMITIVE_RESTART:                  EnableCap read new EnableCap($8F9D);
    public static property DEBUG_OUTPUT:                       EnableCap read new EnableCap($92E0);
    public static property SHADING_RATE_IMAGE_PER_PRIMITIVE:   EnableCap read new EnableCap($95B1);
    public static property FRAMEBUFFER_FETCH_NONCOHERENT:      EnableCap read new EnableCap($96A2);
    public static property SHADING_RATE_PRESERVE_ASPECT_RATIO: EnableCap read new EnableCap($96A5);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0B10) then Result := 'POINT_SMOOTH' else
      if self.val = UInt32($0B20) then Result := 'LINE_SMOOTH' else
      if self.val = UInt32($0B24) then Result := 'LINE_STIPPLE' else
      if self.val = UInt32($0B41) then Result := 'POLYGON_SMOOTH' else
      if self.val = UInt32($0B42) then Result := 'POLYGON_STIPPLE' else
      if self.val = UInt32($0B44) then Result := 'CULL_FACE' else
      if self.val = UInt32($0B50) then Result := 'LIGHTING' else
      if self.val = UInt32($0B57) then Result := 'COLOR_MATERIAL' else
      if self.val = UInt32($0B60) then Result := 'FOG' else
      if self.val = UInt32($0B71) then Result := 'DEPTH_TEST' else
      if self.val = UInt32($0B90) then Result := 'STENCIL_TEST' else
      if self.val = UInt32($0BA1) then Result := 'NORMALIZE' else
      if self.val = UInt32($0BC0) then Result := 'ALPHA_TEST' else
      if self.val = UInt32($0BD0) then Result := 'DITHER' else
      if self.val = UInt32($0BE2) then Result := 'BLEND' else
      if self.val = UInt32($0BF1) then Result := 'INDEX_LOGIC_OP' else
      if self.val = UInt32($0BF2) then Result := 'COLOR_LOGIC_OP' else
      if self.val = UInt32($0C11) then Result := 'SCISSOR_TEST' else
      if self.val = UInt32($0C60) then Result := 'TEXTURE_GEN_S' else
      if self.val = UInt32($0C61) then Result := 'TEXTURE_GEN_T' else
      if self.val = UInt32($0C62) then Result := 'TEXTURE_GEN_R' else
      if self.val = UInt32($0C63) then Result := 'TEXTURE_GEN_Q' else
      if self.val = UInt32($0D80) then Result := 'AUTO_NORMAL' else
      if self.val = UInt32($0D90) then Result := 'MAP1_COLOR_4' else
      if self.val = UInt32($0D91) then Result := 'MAP1_INDEX' else
      if self.val = UInt32($0D92) then Result := 'MAP1_NORMAL' else
      if self.val = UInt32($0D93) then Result := 'MAP1_TEXTURE_COORD_1' else
      if self.val = UInt32($0D94) then Result := 'MAP1_TEXTURE_COORD_2' else
      if self.val = UInt32($0D95) then Result := 'MAP1_TEXTURE_COORD_3' else
      if self.val = UInt32($0D96) then Result := 'MAP1_TEXTURE_COORD_4' else
      if self.val = UInt32($0D97) then Result := 'MAP1_VERTEX_3' else
      if self.val = UInt32($0D98) then Result := 'MAP1_VERTEX_4' else
      if self.val = UInt32($0DB0) then Result := 'MAP2_COLOR_4' else
      if self.val = UInt32($0DB1) then Result := 'MAP2_INDEX' else
      if self.val = UInt32($0DB2) then Result := 'MAP2_NORMAL' else
      if self.val = UInt32($0DB3) then Result := 'MAP2_TEXTURE_COORD_1' else
      if self.val = UInt32($0DB4) then Result := 'MAP2_TEXTURE_COORD_2' else
      if self.val = UInt32($0DB5) then Result := 'MAP2_TEXTURE_COORD_3' else
      if self.val = UInt32($0DB6) then Result := 'MAP2_TEXTURE_COORD_4' else
      if self.val = UInt32($0DB7) then Result := 'MAP2_VERTEX_3' else
      if self.val = UInt32($0DB8) then Result := 'MAP2_VERTEX_4' else
      if self.val = UInt32($0DE0) then Result := 'TEXTURE_1D' else
      if self.val = UInt32($0DE1) then Result := 'TEXTURE_2D' else
      if self.val = UInt32($2A01) then Result := 'POLYGON_OFFSET_POINT' else
      if self.val = UInt32($2A02) then Result := 'POLYGON_OFFSET_LINE' else
      if self.val = UInt32($3000) then Result := 'CLIP_PLANE0' else
      if self.val = UInt32($3000) then Result := 'CLIP_DISTANCE0' else
      if self.val = UInt32($3001) then Result := 'CLIP_PLANE1' else
      if self.val = UInt32($3001) then Result := 'CLIP_DISTANCE1' else
      if self.val = UInt32($3002) then Result := 'CLIP_PLANE2' else
      if self.val = UInt32($3002) then Result := 'CLIP_DISTANCE2' else
      if self.val = UInt32($3003) then Result := 'CLIP_PLANE3' else
      if self.val = UInt32($3003) then Result := 'CLIP_DISTANCE3' else
      if self.val = UInt32($3004) then Result := 'CLIP_PLANE4' else
      if self.val = UInt32($3004) then Result := 'CLIP_DISTANCE4' else
      if self.val = UInt32($3005) then Result := 'CLIP_PLANE5' else
      if self.val = UInt32($3005) then Result := 'CLIP_DISTANCE5' else
      if self.val = UInt32($3006) then Result := 'CLIP_DISTANCE6' else
      if self.val = UInt32($3007) then Result := 'CLIP_DISTANCE7' else
      if self.val = UInt32($4000) then Result := 'LIGHT0' else
      if self.val = UInt32($4001) then Result := 'LIGHT1' else
      if self.val = UInt32($4002) then Result := 'LIGHT2' else
      if self.val = UInt32($4003) then Result := 'LIGHT3' else
      if self.val = UInt32($4004) then Result := 'LIGHT4' else
      if self.val = UInt32($4005) then Result := 'LIGHT5' else
      if self.val = UInt32($4006) then Result := 'LIGHT6' else
      if self.val = UInt32($4007) then Result := 'LIGHT7' else
      if self.val = UInt32($8010) then Result := 'CONVOLUTION_1D' else
      if self.val = UInt32($8011) then Result := 'CONVOLUTION_2D' else
      if self.val = UInt32($8012) then Result := 'SEPARABLE_2D' else
      if self.val = UInt32($8024) then Result := 'HISTOGRAM' else
      if self.val = UInt32($802E) then Result := 'MINMAX' else
      if self.val = UInt32($8037) then Result := 'POLYGON_OFFSET_FILL' else
      if self.val = UInt32($803A) then Result := 'RESCALE_NORMAL' else
      if self.val = UInt32($806F) then Result := 'TEXTURE_3D' else
      if self.val = UInt32($8074) then Result := 'VERTEX_ARRAY' else
      if self.val = UInt32($8075) then Result := 'NORMAL_ARRAY' else
      if self.val = UInt32($8076) then Result := 'COLOR_ARRAY' else
      if self.val = UInt32($8077) then Result := 'INDEX_ARRAY' else
      if self.val = UInt32($8078) then Result := 'TEXTURE_COORD_ARRAY' else
      if self.val = UInt32($8079) then Result := 'EDGE_FLAG_ARRAY' else
      if self.val = UInt32($8094) then Result := 'INTERLACE' else
      if self.val = UInt32($809D) then Result := 'MULTISAMPLE' else
      if self.val = UInt32($809E) then Result := 'SAMPLE_ALPHA_TO_MASK' else
      if self.val = UInt32($809E) then Result := 'SAMPLE_ALPHA_TO_COVERAGE' else
      if self.val = UInt32($809F) then Result := 'SAMPLE_ALPHA_TO_ONE' else
      if self.val = UInt32($80A0) then Result := 'SAMPLE_COVERAGE' else
      if self.val = UInt32($80A0) then Result := 'SAMPLE_MASK_SGIS' else
      if self.val = UInt32($80BC) then Result := 'TEXTURE_COLOR_TABLE' else
      if self.val = UInt32($80D0) then Result := 'COLOR_TABLE' else
      if self.val = UInt32($80D1) then Result := 'POST_CONVOLUTION_COLOR_TABLE' else
      if self.val = UInt32($80D2) then Result := 'POST_COLOR_MATRIX_COLOR_TABLE' else
      if self.val = UInt32($8134) then Result := 'TEXTURE_4D' else
      if self.val = UInt32($8139) then Result := 'PIXEL_TEX_GEN' else
      if self.val = UInt32($8148) then Result := 'SPRITE' else
      if self.val = UInt32($817D) then Result := 'REFERENCE_PLANE' else
      if self.val = UInt32($817F) then Result := 'IR_INSTRUMENT1' else
      if self.val = UInt32($8183) then Result := 'CALLIGRAPHIC_FRAGMENT' else
      if self.val = UInt32($818B) then Result := 'FRAMEZOOM' else
      if self.val = UInt32($8198) then Result := 'FOG_OFFSET' else
      if self.val = UInt32($81FB) then Result := 'SHARED_TEXTURE_PALETTE' else
      if self.val = UInt32($8242) then Result := 'DEBUG_OUTPUT_SYNCHRONOUS' else
      if self.val = UInt32($832C) then Result := 'ASYNC_HISTOGRAM' else
      if self.val = UInt32($8353) then Result := 'PIXEL_TEXTURE' else
      if self.val = UInt32($835C) then Result := 'ASYNC_TEX_IMAGE' else
      if self.val = UInt32($835D) then Result := 'ASYNC_DRAW_PIXELS' else
      if self.val = UInt32($835E) then Result := 'ASYNC_READ_PIXELS' else
      if self.val = UInt32($8400) then Result := 'FRAGMENT_LIGHTING' else
      if self.val = UInt32($8401) then Result := 'FRAGMENT_COLOR_MATERIAL' else
      if self.val = UInt32($840C) then Result := 'FRAGMENT_LIGHT0' else
      if self.val = UInt32($840D) then Result := 'FRAGMENT_LIGHT1' else
      if self.val = UInt32($840E) then Result := 'FRAGMENT_LIGHT2' else
      if self.val = UInt32($840F) then Result := 'FRAGMENT_LIGHT3' else
      if self.val = UInt32($8410) then Result := 'FRAGMENT_LIGHT4' else
      if self.val = UInt32($8411) then Result := 'FRAGMENT_LIGHT5' else
      if self.val = UInt32($8412) then Result := 'FRAGMENT_LIGHT6' else
      if self.val = UInt32($8413) then Result := 'FRAGMENT_LIGHT7' else
      if self.val = UInt32($84F5) then Result := 'TEXTURE_RECTANGLE' else
      if self.val = UInt32($8513) then Result := 'TEXTURE_CUBE_MAP' else
      if self.val = UInt32($8642) then Result := 'PROGRAM_POINT_SIZE' else
      if self.val = UInt32($864F) then Result := 'DEPTH_CLAMP' else
      if self.val = UInt32($884F) then Result := 'TEXTURE_CUBE_MAP_SEAMLESS' else
      if self.val = UInt32($8C36) then Result := 'SAMPLE_SHADING' else
      if self.val = UInt32($8C89) then Result := 'RASTERIZER_DISCARD' else
      if self.val = UInt32($8D60) then Result := 'TEXTURE_GEN_STR' else
      if self.val = UInt32($8D69) then Result := 'PRIMITIVE_RESTART_FIXED_INDEX' else
      if self.val = UInt32($8DB9) then Result := 'FRAMEBUFFER_SRGB' else
      if self.val = UInt32($8E51) then Result := 'SAMPLE_MASK' else
      if self.val = UInt32($8F65) then Result := 'FETCH_PER_SAMPLE_ARM' else
      if self.val = UInt32($8F9D) then Result := 'PRIMITIVE_RESTART' else
      if self.val = UInt32($92E0) then Result := 'DEBUG_OUTPUT' else
      if self.val = UInt32($95B1) then Result := 'SHADING_RATE_IMAGE_PER_PRIMITIVE' else
      if self.val = UInt32($96A2) then Result := 'FRAMEBUFFER_FETCH_NONCOHERENT' else
      if self.val = UInt32($96A5) then Result := 'SHADING_RATE_PRESERVE_ASPECT_RATIO' else
        Result := $'EnableCap[{self.val}]';
    end;
    
  end;
  
  ErrorCode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NO_ERROR:                      ErrorCode read new ErrorCode($0000);
    public static property INVALID_ENUM:                  ErrorCode read new ErrorCode($0500);
    public static property INVALID_VALUE:                 ErrorCode read new ErrorCode($0501);
    public static property INVALID_OPERATION:             ErrorCode read new ErrorCode($0502);
    public static property STACK_OVERFLOW:                ErrorCode read new ErrorCode($0503);
    public static property STACK_UNDERFLOW:               ErrorCode read new ErrorCode($0504);
    public static property OUT_OF_MEMORY:                 ErrorCode read new ErrorCode($0505);
    public static property INVALID_FRAMEBUFFER_OPERATION: ErrorCode read new ErrorCode($0506);
    public static property TABLE_TOO_LARGE:               ErrorCode read new ErrorCode($8031);
    public static property TEXTURE_TOO_LARGE:             ErrorCode read new ErrorCode($8065);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NO_ERROR' else
      if self.val = UInt32($0500) then Result := 'INVALID_ENUM' else
      if self.val = UInt32($0501) then Result := 'INVALID_VALUE' else
      if self.val = UInt32($0502) then Result := 'INVALID_OPERATION' else
      if self.val = UInt32($0503) then Result := 'STACK_OVERFLOW' else
      if self.val = UInt32($0504) then Result := 'STACK_UNDERFLOW' else
      if self.val = UInt32($0505) then Result := 'OUT_OF_MEMORY' else
      if self.val = UInt32($0506) then Result := 'INVALID_FRAMEBUFFER_OPERATION' else
      if self.val = UInt32($8031) then Result := 'TABLE_TOO_LARGE' else
      if self.val = UInt32($8065) then Result := 'TEXTURE_TOO_LARGE' else
        Result := $'ErrorCode[{self.val}]';
    end;
    
  end;
  
  EvalMapsMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FILL: EvalMapsMode read new EvalMapsMode($1B02);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1B02) then Result := 'FILL' else
        Result := $'EvalMapsMode[{self.val}]';
    end;
    
  end;
  
  EvalTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property EVAL_2D:            EvalTarget read new EvalTarget($86C0);
    public static property EVAL_TRIANGULAR_2D: EvalTarget read new EvalTarget($86C1);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($86C0) then Result := 'EVAL_2D' else
      if self.val = UInt32($86C1) then Result := 'EVAL_TRIANGULAR_2D' else
        Result := $'EvalTarget[{self.val}]';
    end;
    
  end;
  
  ExternalHandleType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property HANDLE_TYPE_OPAQUE_FD:        ExternalHandleType read new ExternalHandleType($9586);
    public static property HANDLE_TYPE_OPAQUE_WIN32:     ExternalHandleType read new ExternalHandleType($9587);
    public static property HANDLE_TYPE_OPAQUE_WIN32_KMT: ExternalHandleType read new ExternalHandleType($9588);
    public static property HANDLE_TYPE_D3D12_TILEPOOL:   ExternalHandleType read new ExternalHandleType($9589);
    public static property HANDLE_TYPE_D3D12_RESOURCE:   ExternalHandleType read new ExternalHandleType($958A);
    public static property HANDLE_TYPE_D3D11_IMAGE:      ExternalHandleType read new ExternalHandleType($958B);
    public static property HANDLE_TYPE_D3D11_IMAGE_KMT:  ExternalHandleType read new ExternalHandleType($958C);
    public static property HANDLE_TYPE_D3D12_FENCE:      ExternalHandleType read new ExternalHandleType($9594);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9586) then Result := 'HANDLE_TYPE_OPAQUE_FD' else
      if self.val = UInt32($9587) then Result := 'HANDLE_TYPE_OPAQUE_WIN32' else
      if self.val = UInt32($9588) then Result := 'HANDLE_TYPE_OPAQUE_WIN32_KMT' else
      if self.val = UInt32($9589) then Result := 'HANDLE_TYPE_D3D12_TILEPOOL' else
      if self.val = UInt32($958A) then Result := 'HANDLE_TYPE_D3D12_RESOURCE' else
      if self.val = UInt32($958B) then Result := 'HANDLE_TYPE_D3D11_IMAGE' else
      if self.val = UInt32($958C) then Result := 'HANDLE_TYPE_D3D11_IMAGE_KMT' else
      if self.val = UInt32($9594) then Result := 'HANDLE_TYPE_D3D12_FENCE' else
        Result := $'ExternalHandleType[{self.val}]';
    end;
    
  end;
  
  FeedBackToken = record
    public val: single;
    public constructor(val: single) := self.val := val;
    
    public static property PASS_THROUGH_TOKEN: FeedBackToken read new FeedBackToken($0700);
    public static property POINT_TOKEN:        FeedBackToken read new FeedBackToken($0701);
    public static property LINE_TOKEN:         FeedBackToken read new FeedBackToken($0702);
    public static property POLYGON_TOKEN:      FeedBackToken read new FeedBackToken($0703);
    public static property BITMAP_TOKEN:       FeedBackToken read new FeedBackToken($0704);
    public static property DRAW_PIXEL_TOKEN:   FeedBackToken read new FeedBackToken($0705);
    public static property COPY_PIXEL_TOKEN:   FeedBackToken read new FeedBackToken($0706);
    public static property LINE_RESET_TOKEN:   FeedBackToken read new FeedBackToken($0707);
    
    public function ToString: string; override;
    begin
      if self.val = single($0700) then Result := 'PASS_THROUGH_TOKEN' else
      if self.val = single($0701) then Result := 'POINT_TOKEN' else
      if self.val = single($0702) then Result := 'LINE_TOKEN' else
      if self.val = single($0703) then Result := 'POLYGON_TOKEN' else
      if self.val = single($0704) then Result := 'BITMAP_TOKEN' else
      if self.val = single($0705) then Result := 'DRAW_PIXEL_TOKEN' else
      if self.val = single($0706) then Result := 'COPY_PIXEL_TOKEN' else
      if self.val = single($0707) then Result := 'LINE_RESET_TOKEN' else
        Result := $'FeedBackToken[{self.val}]';
    end;
    
  end;
  
  FeedbackType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property _2D:               FeedbackType read new FeedbackType($0600);
    public static property _3D:               FeedbackType read new FeedbackType($0601);
    public static property _3D_COLOR:         FeedbackType read new FeedbackType($0602);
    public static property _3D_COLOR_TEXTURE: FeedbackType read new FeedbackType($0603);
    public static property _4D_COLOR_TEXTURE: FeedbackType read new FeedbackType($0604);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0600) then Result := '_2D' else
      if self.val = UInt32($0601) then Result := '_3D' else
      if self.val = UInt32($0602) then Result := '_3D_COLOR' else
      if self.val = UInt32($0603) then Result := '_3D_COLOR_TEXTURE' else
      if self.val = UInt32($0604) then Result := '_4D_COLOR_TEXTURE' else
        Result := $'FeedbackType[{self.val}]';
    end;
    
  end;
  
  FenceCondition = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ALL_COMPLETED: FenceCondition read new FenceCondition($84F2);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($84F2) then Result := 'ALL_COMPLETED' else
        Result := $'FenceCondition[{self.val}]';
    end;
    
  end;
  
  FenceParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FENCE_STATUS:    FenceParameterName read new FenceParameterName($84F3);
    public static property FENCE_CONDITION: FenceParameterName read new FenceParameterName($84F4);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($84F3) then Result := 'FENCE_STATUS' else
      if self.val = UInt32($84F4) then Result := 'FENCE_CONDITION' else
        Result := $'FenceParameterName[{self.val}]';
    end;
    
  end;
  
  FfdMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_DEFORMATION_BIT:  FfdMask read new FfdMask($0001);
    public static property GEOMETRY_DEFORMATION_BIT: FfdMask read new FfdMask($0002);
    
    public static function operator+(f1,f2: FfdMask) := new FfdMask(f1.val or f2.val);
    public static function operator or(f1,f2: FfdMask) := f1+f2;
    
    public static procedure operator+=(var f1: FfdMask; f2: FfdMask) := f1 := f1+f2;
    
    public property HAS_FLAG_TEXTURE_DEFORMATION_BIT:  boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_GEOMETRY_DEFORMATION_BIT: boolean read self.val and $0002 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'TEXTURE_DEFORMATION_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'GEOMETRY_DEFORMATION_BIT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'FfdMask[{self.val}]';
    end;
    
  end;
  
  FfdTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GEOMETRY_DEFORMATION: FfdTarget read new FfdTarget($8194);
    public static property TEXTURE_DEFORMATION:  FfdTarget read new FfdTarget($8195);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8194) then Result := 'GEOMETRY_DEFORMATION' else
      if self.val = UInt32($8195) then Result := 'TEXTURE_DEFORMATION' else
        Result := $'FfdTarget[{self.val}]';
    end;
    
  end;
  
  FogCoordinatePointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FLOAT:  FogCoordinatePointerType read new FogCoordinatePointerType($1406);
    public static property DOUBLE: FogCoordinatePointerType read new FogCoordinatePointerType($140A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := $'FogCoordinatePointerType[{self.val}]';
    end;
    
  end;
  
  FogCoordSrc = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FOG_COORDINATE: FogCoordSrc read new FogCoordSrc($8451);
    public static property FOG_COORD:      FogCoordSrc read new FogCoordSrc($8451);
    public static property FRAGMENT_DEPTH: FogCoordSrc read new FogCoordSrc($8452);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8451) then Result := 'FOG_COORDINATE' else
      if self.val = UInt32($8451) then Result := 'FOG_COORD' else
      if self.val = UInt32($8452) then Result := 'FRAGMENT_DEPTH' else
        Result := $'FogCoordSrc[{self.val}]';
    end;
    
  end;
  
  FogMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property EXP:      FogMode read new FogMode($0800);
    public static property EXP2:     FogMode read new FogMode($0801);
    public static property LINEAR:   FogMode read new FogMode($2601);
    public static property FOG_FUNC: FogMode read new FogMode($812A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0800) then Result := 'EXP' else
      if self.val = UInt32($0801) then Result := 'EXP2' else
      if self.val = UInt32($2601) then Result := 'LINEAR' else
      if self.val = UInt32($812A) then Result := 'FOG_FUNC' else
        Result := $'FogMode[{self.val}]';
    end;
    
  end;
  
  FogParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FOG_INDEX:        FogParameter read new FogParameter($0B61);
    public static property FOG_DENSITY:      FogParameter read new FogParameter($0B62);
    public static property FOG_START:        FogParameter read new FogParameter($0B63);
    public static property FOG_END:          FogParameter read new FogParameter($0B64);
    public static property FOG_MODE:         FogParameter read new FogParameter($0B65);
    public static property FOG_COLOR:        FogParameter read new FogParameter($0B66);
    public static property FOG_OFFSET_VALUE: FogParameter read new FogParameter($8199);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0B61) then Result := 'FOG_INDEX' else
      if self.val = UInt32($0B62) then Result := 'FOG_DENSITY' else
      if self.val = UInt32($0B63) then Result := 'FOG_START' else
      if self.val = UInt32($0B64) then Result := 'FOG_END' else
      if self.val = UInt32($0B65) then Result := 'FOG_MODE' else
      if self.val = UInt32($0B66) then Result := 'FOG_COLOR' else
      if self.val = UInt32($8199) then Result := 'FOG_OFFSET_VALUE' else
        Result := $'FogParameter[{self.val}]';
    end;
    
  end;
  
  FogPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FOG_INDEX:     FogPName read new FogPName($0B61);
    public static property FOG_DENSITY:   FogPName read new FogPName($0B62);
    public static property FOG_START:     FogPName read new FogPName($0B63);
    public static property FOG_END:       FogPName read new FogPName($0B64);
    public static property FOG_MODE:      FogPName read new FogPName($0B65);
    public static property FOG_COORD_SRC: FogPName read new FogPName($8450);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0B61) then Result := 'FOG_INDEX' else
      if self.val = UInt32($0B62) then Result := 'FOG_DENSITY' else
      if self.val = UInt32($0B63) then Result := 'FOG_START' else
      if self.val = UInt32($0B64) then Result := 'FOG_END' else
      if self.val = UInt32($0B65) then Result := 'FOG_MODE' else
      if self.val = UInt32($8450) then Result := 'FOG_COORD_SRC' else
        Result := $'FogPName[{self.val}]';
    end;
    
  end;
  
  FogPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FLOAT:  FogPointerType read new FogPointerType($1406);
    public static property DOUBLE: FogPointerType read new FogPointerType($140A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := $'FogPointerType[{self.val}]';
    end;
    
  end;
  
  FoveationConfigBit = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FOVEATION_ENABLE_BIT:                   FoveationConfigBit read new FoveationConfigBit($0001);
    public static property FOVEATION_SCALED_BIN_METHOD_BIT:        FoveationConfigBit read new FoveationConfigBit($0002);
    public static property FOVEATION_SUBSAMPLED_LAYOUT_METHOD_BIT: FoveationConfigBit read new FoveationConfigBit($0004);
    
    public static function operator+(f1,f2: FoveationConfigBit) := new FoveationConfigBit(f1.val or f2.val);
    public static function operator or(f1,f2: FoveationConfigBit) := f1+f2;
    
    public static procedure operator+=(var f1: FoveationConfigBit; f2: FoveationConfigBit) := f1 := f1+f2;
    
    public property HAS_FLAG_FOVEATION_ENABLE_BIT:                   boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_FOVEATION_SCALED_BIN_METHOD_BIT:        boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_FOVEATION_SUBSAMPLED_LAYOUT_METHOD_BIT: boolean read self.val and $0004 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'FOVEATION_ENABLE_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'FOVEATION_SCALED_BIN_METHOD_BIT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'FOVEATION_SUBSAMPLED_LAYOUT_METHOD_BIT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'FoveationConfigBit[{self.val}]';
    end;
    
  end;
  
  FragmentLightModelParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER:         FragmentLightModelParameter read new FragmentLightModelParameter($8408);
    public static property FRAGMENT_LIGHT_MODEL_TWO_SIDE:             FragmentLightModelParameter read new FragmentLightModelParameter($8409);
    public static property FRAGMENT_LIGHT_MODEL_AMBIENT:              FragmentLightModelParameter read new FragmentLightModelParameter($840A);
    public static property FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION: FragmentLightModelParameter read new FragmentLightModelParameter($840B);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8408) then Result := 'FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER' else
      if self.val = UInt32($8409) then Result := 'FRAGMENT_LIGHT_MODEL_TWO_SIDE' else
      if self.val = UInt32($840A) then Result := 'FRAGMENT_LIGHT_MODEL_AMBIENT' else
      if self.val = UInt32($840B) then Result := 'FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION' else
        Result := $'FragmentLightModelParameter[{self.val}]';
    end;
    
  end;
  
  FragmentLightName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRAGMENT_LIGHT0: FragmentLightName read new FragmentLightName($840C);
    public static property FRAGMENT_LIGHT1: FragmentLightName read new FragmentLightName($840D);
    public static property FRAGMENT_LIGHT2: FragmentLightName read new FragmentLightName($840E);
    public static property FRAGMENT_LIGHT3: FragmentLightName read new FragmentLightName($840F);
    public static property FRAGMENT_LIGHT4: FragmentLightName read new FragmentLightName($8410);
    public static property FRAGMENT_LIGHT5: FragmentLightName read new FragmentLightName($8411);
    public static property FRAGMENT_LIGHT6: FragmentLightName read new FragmentLightName($8412);
    public static property FRAGMENT_LIGHT7: FragmentLightName read new FragmentLightName($8413);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($840C) then Result := 'FRAGMENT_LIGHT0' else
      if self.val = UInt32($840D) then Result := 'FRAGMENT_LIGHT1' else
      if self.val = UInt32($840E) then Result := 'FRAGMENT_LIGHT2' else
      if self.val = UInt32($840F) then Result := 'FRAGMENT_LIGHT3' else
      if self.val = UInt32($8410) then Result := 'FRAGMENT_LIGHT4' else
      if self.val = UInt32($8411) then Result := 'FRAGMENT_LIGHT5' else
      if self.val = UInt32($8412) then Result := 'FRAGMENT_LIGHT6' else
      if self.val = UInt32($8413) then Result := 'FRAGMENT_LIGHT7' else
        Result := $'FragmentLightName[{self.val}]';
    end;
    
  end;
  
  FragmentLightParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property AMBIENT:               FragmentLightParameter read new FragmentLightParameter($1200);
    public static property DIFFUSE:               FragmentLightParameter read new FragmentLightParameter($1201);
    public static property SPECULAR:              FragmentLightParameter read new FragmentLightParameter($1202);
    public static property POSITION:              FragmentLightParameter read new FragmentLightParameter($1203);
    public static property SPOT_DIRECTION:        FragmentLightParameter read new FragmentLightParameter($1204);
    public static property SPOT_EXPONENT:         FragmentLightParameter read new FragmentLightParameter($1205);
    public static property SPOT_CUTOFF:           FragmentLightParameter read new FragmentLightParameter($1206);
    public static property CONSTANT_ATTENUATION:  FragmentLightParameter read new FragmentLightParameter($1207);
    public static property LINEAR_ATTENUATION:    FragmentLightParameter read new FragmentLightParameter($1208);
    public static property QUADRATIC_ATTENUATION: FragmentLightParameter read new FragmentLightParameter($1209);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1200) then Result := 'AMBIENT' else
      if self.val = UInt32($1201) then Result := 'DIFFUSE' else
      if self.val = UInt32($1202) then Result := 'SPECULAR' else
      if self.val = UInt32($1203) then Result := 'POSITION' else
      if self.val = UInt32($1204) then Result := 'SPOT_DIRECTION' else
      if self.val = UInt32($1205) then Result := 'SPOT_EXPONENT' else
      if self.val = UInt32($1206) then Result := 'SPOT_CUTOFF' else
      if self.val = UInt32($1207) then Result := 'CONSTANT_ATTENUATION' else
      if self.val = UInt32($1208) then Result := 'LINEAR_ATTENUATION' else
      if self.val = UInt32($1209) then Result := 'QUADRATIC_ATTENUATION' else
        Result := $'FragmentLightParameter[{self.val}]';
    end;
    
  end;
  
  FragmentOp1 = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MOV: FragmentOp1 read new FragmentOp1($8961);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8961) then Result := 'MOV' else
        Result := $'FragmentOp1[{self.val}]';
    end;
    
  end;
  
  FragmentOp2 = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ADD_ATI: FragmentOp2 read new FragmentOp2($8963);
    public static property MUL:     FragmentOp2 read new FragmentOp2($8964);
    public static property SUB:     FragmentOp2 read new FragmentOp2($8965);
    public static property DOT3:    FragmentOp2 read new FragmentOp2($8966);
    public static property DOT4:    FragmentOp2 read new FragmentOp2($8967);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8963) then Result := 'ADD_ATI' else
      if self.val = UInt32($8964) then Result := 'MUL' else
      if self.val = UInt32($8965) then Result := 'SUB' else
      if self.val = UInt32($8966) then Result := 'DOT3' else
      if self.val = UInt32($8967) then Result := 'DOT4' else
        Result := $'FragmentOp2[{self.val}]';
    end;
    
  end;
  
  FragmentOp3 = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MAD:      FragmentOp3 read new FragmentOp3($8968);
    public static property LERP:     FragmentOp3 read new FragmentOp3($8969);
    public static property CND:      FragmentOp3 read new FragmentOp3($896A);
    public static property CND0:     FragmentOp3 read new FragmentOp3($896B);
    public static property DOT2_ADD: FragmentOp3 read new FragmentOp3($896C);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8968) then Result := 'MAD' else
      if self.val = UInt32($8969) then Result := 'LERP' else
      if self.val = UInt32($896A) then Result := 'CND' else
      if self.val = UInt32($896B) then Result := 'CND0' else
      if self.val = UInt32($896C) then Result := 'DOT2_ADD' else
        Result := $'FragmentOp3[{self.val}]';
    end;
    
  end;
  
  FragmentShaderColorModMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property _2X_BIT:    FragmentShaderColorModMask read new FragmentShaderColorModMask($0001);
    public static property COMP_BIT:   FragmentShaderColorModMask read new FragmentShaderColorModMask($0002);
    public static property NEGATE_BIT: FragmentShaderColorModMask read new FragmentShaderColorModMask($0004);
    public static property BIAS_BIT:   FragmentShaderColorModMask read new FragmentShaderColorModMask($0008);
    
    public static function operator+(f1,f2: FragmentShaderColorModMask) := new FragmentShaderColorModMask(f1.val or f2.val);
    public static function operator or(f1,f2: FragmentShaderColorModMask) := f1+f2;
    
    public static procedure operator+=(var f1: FragmentShaderColorModMask; f2: FragmentShaderColorModMask) := f1 := f1+f2;
    
    public property HAS_FLAG__2X_BIT:    boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_COMP_BIT:   boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_NEGATE_BIT: boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_BIAS_BIT:   boolean read self.val and $0008 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += '_2X_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'COMP_BIT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'NEGATE_BIT+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'BIAS_BIT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'FragmentShaderColorModMask[{self.val}]';
    end;
    
  end;
  
  FragmentShaderCon = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CON_0:  FragmentShaderCon read new FragmentShaderCon($8941);
    public static property CON_1:  FragmentShaderCon read new FragmentShaderCon($8942);
    public static property CON_2:  FragmentShaderCon read new FragmentShaderCon($8943);
    public static property CON_3:  FragmentShaderCon read new FragmentShaderCon($8944);
    public static property CON_4:  FragmentShaderCon read new FragmentShaderCon($8945);
    public static property CON_5:  FragmentShaderCon read new FragmentShaderCon($8946);
    public static property CON_6:  FragmentShaderCon read new FragmentShaderCon($8947);
    public static property CON_7:  FragmentShaderCon read new FragmentShaderCon($8948);
    public static property CON_8:  FragmentShaderCon read new FragmentShaderCon($8949);
    public static property CON_9:  FragmentShaderCon read new FragmentShaderCon($894A);
    public static property CON_10: FragmentShaderCon read new FragmentShaderCon($894B);
    public static property CON_11: FragmentShaderCon read new FragmentShaderCon($894C);
    public static property CON_12: FragmentShaderCon read new FragmentShaderCon($894D);
    public static property CON_13: FragmentShaderCon read new FragmentShaderCon($894E);
    public static property CON_14: FragmentShaderCon read new FragmentShaderCon($894F);
    public static property CON_15: FragmentShaderCon read new FragmentShaderCon($8950);
    public static property CON_16: FragmentShaderCon read new FragmentShaderCon($8951);
    public static property CON_17: FragmentShaderCon read new FragmentShaderCon($8952);
    public static property CON_18: FragmentShaderCon read new FragmentShaderCon($8953);
    public static property CON_19: FragmentShaderCon read new FragmentShaderCon($8954);
    public static property CON_20: FragmentShaderCon read new FragmentShaderCon($8955);
    public static property CON_21: FragmentShaderCon read new FragmentShaderCon($8956);
    public static property CON_22: FragmentShaderCon read new FragmentShaderCon($8957);
    public static property CON_23: FragmentShaderCon read new FragmentShaderCon($8958);
    public static property CON_24: FragmentShaderCon read new FragmentShaderCon($8959);
    public static property CON_25: FragmentShaderCon read new FragmentShaderCon($895A);
    public static property CON_26: FragmentShaderCon read new FragmentShaderCon($895B);
    public static property CON_27: FragmentShaderCon read new FragmentShaderCon($895C);
    public static property CON_28: FragmentShaderCon read new FragmentShaderCon($895D);
    public static property CON_29: FragmentShaderCon read new FragmentShaderCon($895E);
    public static property CON_30: FragmentShaderCon read new FragmentShaderCon($895F);
    public static property CON_31: FragmentShaderCon read new FragmentShaderCon($8960);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8941) then Result := 'CON_0' else
      if self.val = UInt32($8942) then Result := 'CON_1' else
      if self.val = UInt32($8943) then Result := 'CON_2' else
      if self.val = UInt32($8944) then Result := 'CON_3' else
      if self.val = UInt32($8945) then Result := 'CON_4' else
      if self.val = UInt32($8946) then Result := 'CON_5' else
      if self.val = UInt32($8947) then Result := 'CON_6' else
      if self.val = UInt32($8948) then Result := 'CON_7' else
      if self.val = UInt32($8949) then Result := 'CON_8' else
      if self.val = UInt32($894A) then Result := 'CON_9' else
      if self.val = UInt32($894B) then Result := 'CON_10' else
      if self.val = UInt32($894C) then Result := 'CON_11' else
      if self.val = UInt32($894D) then Result := 'CON_12' else
      if self.val = UInt32($894E) then Result := 'CON_13' else
      if self.val = UInt32($894F) then Result := 'CON_14' else
      if self.val = UInt32($8950) then Result := 'CON_15' else
      if self.val = UInt32($8951) then Result := 'CON_16' else
      if self.val = UInt32($8952) then Result := 'CON_17' else
      if self.val = UInt32($8953) then Result := 'CON_18' else
      if self.val = UInt32($8954) then Result := 'CON_19' else
      if self.val = UInt32($8955) then Result := 'CON_20' else
      if self.val = UInt32($8956) then Result := 'CON_21' else
      if self.val = UInt32($8957) then Result := 'CON_22' else
      if self.val = UInt32($8958) then Result := 'CON_23' else
      if self.val = UInt32($8959) then Result := 'CON_24' else
      if self.val = UInt32($895A) then Result := 'CON_25' else
      if self.val = UInt32($895B) then Result := 'CON_26' else
      if self.val = UInt32($895C) then Result := 'CON_27' else
      if self.val = UInt32($895D) then Result := 'CON_28' else
      if self.val = UInt32($895E) then Result := 'CON_29' else
      if self.val = UInt32($895F) then Result := 'CON_30' else
      if self.val = UInt32($8960) then Result := 'CON_31' else
        Result := $'FragmentShaderCon[{self.val}]';
    end;
    
  end;
  
  FragmentShaderDestMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:      FragmentShaderDestMask read new FragmentShaderDestMask($0000);
    public static property RED_BIT:   FragmentShaderDestMask read new FragmentShaderDestMask($0001);
    public static property GREEN_BIT: FragmentShaderDestMask read new FragmentShaderDestMask($0002);
    public static property BLUE_BIT:  FragmentShaderDestMask read new FragmentShaderDestMask($0004);
    
    public static function operator+(f1,f2: FragmentShaderDestMask) := new FragmentShaderDestMask(f1.val or f2.val);
    public static function operator or(f1,f2: FragmentShaderDestMask) := f1+f2;
    
    public static procedure operator+=(var f1: FragmentShaderDestMask; f2: FragmentShaderDestMask) := f1 := f1+f2;
    
    public property ANY_FLAGS: boolean read self.val<>0;
    public property HAS_FLAG_RED_BIT:   boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_GREEN_BIT: boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_BLUE_BIT:  boolean read self.val and $0004 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'RED_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'GREEN_BIT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'BLUE_BIT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'FragmentShaderDestMask[{self.val}]';
    end;
    
  end;
  
  FragmentShaderDestModMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:         FragmentShaderDestModMask read new FragmentShaderDestModMask($0000);
    public static property _2X_BIT:      FragmentShaderDestModMask read new FragmentShaderDestModMask($0001);
    public static property _4X_BIT:      FragmentShaderDestModMask read new FragmentShaderDestModMask($0002);
    public static property _8X_BIT:      FragmentShaderDestModMask read new FragmentShaderDestModMask($0004);
    public static property HALF_BIT:     FragmentShaderDestModMask read new FragmentShaderDestModMask($0008);
    public static property QUARTER_BIT:  FragmentShaderDestModMask read new FragmentShaderDestModMask($0010);
    public static property EIGHTH_BIT:   FragmentShaderDestModMask read new FragmentShaderDestModMask($0020);
    public static property SATURATE_BIT: FragmentShaderDestModMask read new FragmentShaderDestModMask($0040);
    
    public static function operator+(f1,f2: FragmentShaderDestModMask) := new FragmentShaderDestModMask(f1.val or f2.val);
    public static function operator or(f1,f2: FragmentShaderDestModMask) := f1+f2;
    
    public static procedure operator+=(var f1: FragmentShaderDestModMask; f2: FragmentShaderDestModMask) := f1 := f1+f2;
    
    public property ANY_FLAGS: boolean read self.val<>0;
    public property HAS_FLAG__2X_BIT:      boolean read self.val and $0001 <> 0;
    public property HAS_FLAG__4X_BIT:      boolean read self.val and $0002 <> 0;
    public property HAS_FLAG__8X_BIT:      boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_HALF_BIT:     boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_QUARTER_BIT:  boolean read self.val and $0010 <> 0;
    public property HAS_FLAG_EIGHTH_BIT:   boolean read self.val and $0020 <> 0;
    public property HAS_FLAG_SATURATE_BIT: boolean read self.val and $0040 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += '_2X_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += '_4X_BIT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += '_8X_BIT+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'HALF_BIT+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'QUARTER_BIT+';
      if self.val and UInt32($0020) = UInt32($0020) then res += 'EIGHTH_BIT+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'SATURATE_BIT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'FragmentShaderDestModMask[{self.val}]';
    end;
    
  end;
  
  FragmentShaderGenericSource = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ZERO:                   FragmentShaderGenericSource read new FragmentShaderGenericSource($0000);
    public static property ONE:                    FragmentShaderGenericSource read new FragmentShaderGenericSource($0001);
    public static property PRIMARY_COLOR:          FragmentShaderGenericSource read new FragmentShaderGenericSource($8577);
    public static property REG_0:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8921);
    public static property REG_1:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8922);
    public static property REG_2:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8923);
    public static property REG_3:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8924);
    public static property REG_4:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8925);
    public static property REG_5:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8926);
    public static property REG_6:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8927);
    public static property REG_7:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8928);
    public static property REG_8:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8929);
    public static property REG_9:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($892A);
    public static property REG_10:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($892B);
    public static property REG_11:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($892C);
    public static property REG_12:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($892D);
    public static property REG_13:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($892E);
    public static property REG_14:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($892F);
    public static property REG_15:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8930);
    public static property REG_16:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8931);
    public static property REG_17:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8932);
    public static property REG_18:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8933);
    public static property REG_19:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8934);
    public static property REG_20:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8935);
    public static property REG_21:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8936);
    public static property REG_22:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8937);
    public static property REG_23:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8938);
    public static property REG_24:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8939);
    public static property REG_25:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($893A);
    public static property REG_26:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($893B);
    public static property REG_27:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($893C);
    public static property REG_28:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($893D);
    public static property REG_29:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($893E);
    public static property REG_30:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($893F);
    public static property REG_31:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8940);
    public static property CON_0:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8941);
    public static property CON_1:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8942);
    public static property CON_2:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8943);
    public static property CON_3:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8944);
    public static property CON_4:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8945);
    public static property CON_5:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8946);
    public static property CON_6:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8947);
    public static property CON_7:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8948);
    public static property CON_8:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($8949);
    public static property CON_9:                  FragmentShaderGenericSource read new FragmentShaderGenericSource($894A);
    public static property CON_10:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($894B);
    public static property CON_11:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($894C);
    public static property CON_12:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($894D);
    public static property CON_13:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($894E);
    public static property CON_14:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($894F);
    public static property CON_15:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8950);
    public static property CON_16:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8951);
    public static property CON_17:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8952);
    public static property CON_18:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8953);
    public static property CON_19:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8954);
    public static property CON_20:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8955);
    public static property CON_21:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8956);
    public static property CON_22:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8957);
    public static property CON_23:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8958);
    public static property CON_24:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8959);
    public static property CON_25:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($895A);
    public static property CON_26:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($895B);
    public static property CON_27:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($895C);
    public static property CON_28:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($895D);
    public static property CON_29:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($895E);
    public static property CON_30:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($895F);
    public static property CON_31:                 FragmentShaderGenericSource read new FragmentShaderGenericSource($8960);
    public static property SECONDARY_INTERPOLATOR: FragmentShaderGenericSource read new FragmentShaderGenericSource($896D);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'ZERO' else
      if self.val = UInt32($0001) then Result := 'ONE' else
      if self.val = UInt32($8577) then Result := 'PRIMARY_COLOR' else
      if self.val = UInt32($8921) then Result := 'REG_0' else
      if self.val = UInt32($8922) then Result := 'REG_1' else
      if self.val = UInt32($8923) then Result := 'REG_2' else
      if self.val = UInt32($8924) then Result := 'REG_3' else
      if self.val = UInt32($8925) then Result := 'REG_4' else
      if self.val = UInt32($8926) then Result := 'REG_5' else
      if self.val = UInt32($8927) then Result := 'REG_6' else
      if self.val = UInt32($8928) then Result := 'REG_7' else
      if self.val = UInt32($8929) then Result := 'REG_8' else
      if self.val = UInt32($892A) then Result := 'REG_9' else
      if self.val = UInt32($892B) then Result := 'REG_10' else
      if self.val = UInt32($892C) then Result := 'REG_11' else
      if self.val = UInt32($892D) then Result := 'REG_12' else
      if self.val = UInt32($892E) then Result := 'REG_13' else
      if self.val = UInt32($892F) then Result := 'REG_14' else
      if self.val = UInt32($8930) then Result := 'REG_15' else
      if self.val = UInt32($8931) then Result := 'REG_16' else
      if self.val = UInt32($8932) then Result := 'REG_17' else
      if self.val = UInt32($8933) then Result := 'REG_18' else
      if self.val = UInt32($8934) then Result := 'REG_19' else
      if self.val = UInt32($8935) then Result := 'REG_20' else
      if self.val = UInt32($8936) then Result := 'REG_21' else
      if self.val = UInt32($8937) then Result := 'REG_22' else
      if self.val = UInt32($8938) then Result := 'REG_23' else
      if self.val = UInt32($8939) then Result := 'REG_24' else
      if self.val = UInt32($893A) then Result := 'REG_25' else
      if self.val = UInt32($893B) then Result := 'REG_26' else
      if self.val = UInt32($893C) then Result := 'REG_27' else
      if self.val = UInt32($893D) then Result := 'REG_28' else
      if self.val = UInt32($893E) then Result := 'REG_29' else
      if self.val = UInt32($893F) then Result := 'REG_30' else
      if self.val = UInt32($8940) then Result := 'REG_31' else
      if self.val = UInt32($8941) then Result := 'CON_0' else
      if self.val = UInt32($8942) then Result := 'CON_1' else
      if self.val = UInt32($8943) then Result := 'CON_2' else
      if self.val = UInt32($8944) then Result := 'CON_3' else
      if self.val = UInt32($8945) then Result := 'CON_4' else
      if self.val = UInt32($8946) then Result := 'CON_5' else
      if self.val = UInt32($8947) then Result := 'CON_6' else
      if self.val = UInt32($8948) then Result := 'CON_7' else
      if self.val = UInt32($8949) then Result := 'CON_8' else
      if self.val = UInt32($894A) then Result := 'CON_9' else
      if self.val = UInt32($894B) then Result := 'CON_10' else
      if self.val = UInt32($894C) then Result := 'CON_11' else
      if self.val = UInt32($894D) then Result := 'CON_12' else
      if self.val = UInt32($894E) then Result := 'CON_13' else
      if self.val = UInt32($894F) then Result := 'CON_14' else
      if self.val = UInt32($8950) then Result := 'CON_15' else
      if self.val = UInt32($8951) then Result := 'CON_16' else
      if self.val = UInt32($8952) then Result := 'CON_17' else
      if self.val = UInt32($8953) then Result := 'CON_18' else
      if self.val = UInt32($8954) then Result := 'CON_19' else
      if self.val = UInt32($8955) then Result := 'CON_20' else
      if self.val = UInt32($8956) then Result := 'CON_21' else
      if self.val = UInt32($8957) then Result := 'CON_22' else
      if self.val = UInt32($8958) then Result := 'CON_23' else
      if self.val = UInt32($8959) then Result := 'CON_24' else
      if self.val = UInt32($895A) then Result := 'CON_25' else
      if self.val = UInt32($895B) then Result := 'CON_26' else
      if self.val = UInt32($895C) then Result := 'CON_27' else
      if self.val = UInt32($895D) then Result := 'CON_28' else
      if self.val = UInt32($895E) then Result := 'CON_29' else
      if self.val = UInt32($895F) then Result := 'CON_30' else
      if self.val = UInt32($8960) then Result := 'CON_31' else
      if self.val = UInt32($896D) then Result := 'SECONDARY_INTERPOLATOR' else
        Result := $'FragmentShaderGenericSource[{self.val}]';
    end;
    
  end;
  
  FragmentShaderReg = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property REG_0:  FragmentShaderReg read new FragmentShaderReg($8921);
    public static property REG_1:  FragmentShaderReg read new FragmentShaderReg($8922);
    public static property REG_2:  FragmentShaderReg read new FragmentShaderReg($8923);
    public static property REG_3:  FragmentShaderReg read new FragmentShaderReg($8924);
    public static property REG_4:  FragmentShaderReg read new FragmentShaderReg($8925);
    public static property REG_5:  FragmentShaderReg read new FragmentShaderReg($8926);
    public static property REG_6:  FragmentShaderReg read new FragmentShaderReg($8927);
    public static property REG_7:  FragmentShaderReg read new FragmentShaderReg($8928);
    public static property REG_8:  FragmentShaderReg read new FragmentShaderReg($8929);
    public static property REG_9:  FragmentShaderReg read new FragmentShaderReg($892A);
    public static property REG_10: FragmentShaderReg read new FragmentShaderReg($892B);
    public static property REG_11: FragmentShaderReg read new FragmentShaderReg($892C);
    public static property REG_12: FragmentShaderReg read new FragmentShaderReg($892D);
    public static property REG_13: FragmentShaderReg read new FragmentShaderReg($892E);
    public static property REG_14: FragmentShaderReg read new FragmentShaderReg($892F);
    public static property REG_15: FragmentShaderReg read new FragmentShaderReg($8930);
    public static property REG_16: FragmentShaderReg read new FragmentShaderReg($8931);
    public static property REG_17: FragmentShaderReg read new FragmentShaderReg($8932);
    public static property REG_18: FragmentShaderReg read new FragmentShaderReg($8933);
    public static property REG_19: FragmentShaderReg read new FragmentShaderReg($8934);
    public static property REG_20: FragmentShaderReg read new FragmentShaderReg($8935);
    public static property REG_21: FragmentShaderReg read new FragmentShaderReg($8936);
    public static property REG_22: FragmentShaderReg read new FragmentShaderReg($8937);
    public static property REG_23: FragmentShaderReg read new FragmentShaderReg($8938);
    public static property REG_24: FragmentShaderReg read new FragmentShaderReg($8939);
    public static property REG_25: FragmentShaderReg read new FragmentShaderReg($893A);
    public static property REG_26: FragmentShaderReg read new FragmentShaderReg($893B);
    public static property REG_27: FragmentShaderReg read new FragmentShaderReg($893C);
    public static property REG_28: FragmentShaderReg read new FragmentShaderReg($893D);
    public static property REG_29: FragmentShaderReg read new FragmentShaderReg($893E);
    public static property REG_30: FragmentShaderReg read new FragmentShaderReg($893F);
    public static property REG_31: FragmentShaderReg read new FragmentShaderReg($8940);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8921) then Result := 'REG_0' else
      if self.val = UInt32($8922) then Result := 'REG_1' else
      if self.val = UInt32($8923) then Result := 'REG_2' else
      if self.val = UInt32($8924) then Result := 'REG_3' else
      if self.val = UInt32($8925) then Result := 'REG_4' else
      if self.val = UInt32($8926) then Result := 'REG_5' else
      if self.val = UInt32($8927) then Result := 'REG_6' else
      if self.val = UInt32($8928) then Result := 'REG_7' else
      if self.val = UInt32($8929) then Result := 'REG_8' else
      if self.val = UInt32($892A) then Result := 'REG_9' else
      if self.val = UInt32($892B) then Result := 'REG_10' else
      if self.val = UInt32($892C) then Result := 'REG_11' else
      if self.val = UInt32($892D) then Result := 'REG_12' else
      if self.val = UInt32($892E) then Result := 'REG_13' else
      if self.val = UInt32($892F) then Result := 'REG_14' else
      if self.val = UInt32($8930) then Result := 'REG_15' else
      if self.val = UInt32($8931) then Result := 'REG_16' else
      if self.val = UInt32($8932) then Result := 'REG_17' else
      if self.val = UInt32($8933) then Result := 'REG_18' else
      if self.val = UInt32($8934) then Result := 'REG_19' else
      if self.val = UInt32($8935) then Result := 'REG_20' else
      if self.val = UInt32($8936) then Result := 'REG_21' else
      if self.val = UInt32($8937) then Result := 'REG_22' else
      if self.val = UInt32($8938) then Result := 'REG_23' else
      if self.val = UInt32($8939) then Result := 'REG_24' else
      if self.val = UInt32($893A) then Result := 'REG_25' else
      if self.val = UInt32($893B) then Result := 'REG_26' else
      if self.val = UInt32($893C) then Result := 'REG_27' else
      if self.val = UInt32($893D) then Result := 'REG_28' else
      if self.val = UInt32($893E) then Result := 'REG_29' else
      if self.val = UInt32($893F) then Result := 'REG_30' else
      if self.val = UInt32($8940) then Result := 'REG_31' else
        Result := $'FragmentShaderReg[{self.val}]';
    end;
    
  end;
  
  FragmentShaderTextureSource = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE0:  FragmentShaderTextureSource read new FragmentShaderTextureSource($84C0);
    public static property TEXTURE1:  FragmentShaderTextureSource read new FragmentShaderTextureSource($84C1);
    public static property TEXTURE2:  FragmentShaderTextureSource read new FragmentShaderTextureSource($84C2);
    public static property TEXTURE3:  FragmentShaderTextureSource read new FragmentShaderTextureSource($84C3);
    public static property TEXTURE4:  FragmentShaderTextureSource read new FragmentShaderTextureSource($84C4);
    public static property TEXTURE5:  FragmentShaderTextureSource read new FragmentShaderTextureSource($84C5);
    public static property TEXTURE6:  FragmentShaderTextureSource read new FragmentShaderTextureSource($84C6);
    public static property TEXTURE7:  FragmentShaderTextureSource read new FragmentShaderTextureSource($84C7);
    public static property TEXTURE8:  FragmentShaderTextureSource read new FragmentShaderTextureSource($84C8);
    public static property TEXTURE9:  FragmentShaderTextureSource read new FragmentShaderTextureSource($84C9);
    public static property TEXTURE10: FragmentShaderTextureSource read new FragmentShaderTextureSource($84CA);
    public static property TEXTURE11: FragmentShaderTextureSource read new FragmentShaderTextureSource($84CB);
    public static property TEXTURE12: FragmentShaderTextureSource read new FragmentShaderTextureSource($84CC);
    public static property TEXTURE13: FragmentShaderTextureSource read new FragmentShaderTextureSource($84CD);
    public static property TEXTURE14: FragmentShaderTextureSource read new FragmentShaderTextureSource($84CE);
    public static property TEXTURE15: FragmentShaderTextureSource read new FragmentShaderTextureSource($84CF);
    public static property TEXTURE16: FragmentShaderTextureSource read new FragmentShaderTextureSource($84D0);
    public static property TEXTURE17: FragmentShaderTextureSource read new FragmentShaderTextureSource($84D1);
    public static property TEXTURE18: FragmentShaderTextureSource read new FragmentShaderTextureSource($84D2);
    public static property TEXTURE19: FragmentShaderTextureSource read new FragmentShaderTextureSource($84D3);
    public static property TEXTURE20: FragmentShaderTextureSource read new FragmentShaderTextureSource($84D4);
    public static property TEXTURE21: FragmentShaderTextureSource read new FragmentShaderTextureSource($84D5);
    public static property TEXTURE22: FragmentShaderTextureSource read new FragmentShaderTextureSource($84D6);
    public static property TEXTURE23: FragmentShaderTextureSource read new FragmentShaderTextureSource($84D7);
    public static property TEXTURE24: FragmentShaderTextureSource read new FragmentShaderTextureSource($84D8);
    public static property TEXTURE25: FragmentShaderTextureSource read new FragmentShaderTextureSource($84D9);
    public static property TEXTURE26: FragmentShaderTextureSource read new FragmentShaderTextureSource($84DA);
    public static property TEXTURE27: FragmentShaderTextureSource read new FragmentShaderTextureSource($84DB);
    public static property TEXTURE28: FragmentShaderTextureSource read new FragmentShaderTextureSource($84DC);
    public static property TEXTURE29: FragmentShaderTextureSource read new FragmentShaderTextureSource($84DD);
    public static property TEXTURE30: FragmentShaderTextureSource read new FragmentShaderTextureSource($84DE);
    public static property TEXTURE31: FragmentShaderTextureSource read new FragmentShaderTextureSource($84DF);
    public static property REG_0:     FragmentShaderTextureSource read new FragmentShaderTextureSource($8921);
    public static property REG_1:     FragmentShaderTextureSource read new FragmentShaderTextureSource($8922);
    public static property REG_2:     FragmentShaderTextureSource read new FragmentShaderTextureSource($8923);
    public static property REG_3:     FragmentShaderTextureSource read new FragmentShaderTextureSource($8924);
    public static property REG_4:     FragmentShaderTextureSource read new FragmentShaderTextureSource($8925);
    public static property REG_5:     FragmentShaderTextureSource read new FragmentShaderTextureSource($8926);
    public static property REG_6:     FragmentShaderTextureSource read new FragmentShaderTextureSource($8927);
    public static property REG_7:     FragmentShaderTextureSource read new FragmentShaderTextureSource($8928);
    public static property REG_8:     FragmentShaderTextureSource read new FragmentShaderTextureSource($8929);
    public static property REG_9:     FragmentShaderTextureSource read new FragmentShaderTextureSource($892A);
    public static property REG_10:    FragmentShaderTextureSource read new FragmentShaderTextureSource($892B);
    public static property REG_11:    FragmentShaderTextureSource read new FragmentShaderTextureSource($892C);
    public static property REG_12:    FragmentShaderTextureSource read new FragmentShaderTextureSource($892D);
    public static property REG_13:    FragmentShaderTextureSource read new FragmentShaderTextureSource($892E);
    public static property REG_14:    FragmentShaderTextureSource read new FragmentShaderTextureSource($892F);
    public static property REG_15:    FragmentShaderTextureSource read new FragmentShaderTextureSource($8930);
    public static property REG_16:    FragmentShaderTextureSource read new FragmentShaderTextureSource($8931);
    public static property REG_17:    FragmentShaderTextureSource read new FragmentShaderTextureSource($8932);
    public static property REG_18:    FragmentShaderTextureSource read new FragmentShaderTextureSource($8933);
    public static property REG_19:    FragmentShaderTextureSource read new FragmentShaderTextureSource($8934);
    public static property REG_20:    FragmentShaderTextureSource read new FragmentShaderTextureSource($8935);
    public static property REG_21:    FragmentShaderTextureSource read new FragmentShaderTextureSource($8936);
    public static property REG_22:    FragmentShaderTextureSource read new FragmentShaderTextureSource($8937);
    public static property REG_23:    FragmentShaderTextureSource read new FragmentShaderTextureSource($8938);
    public static property REG_24:    FragmentShaderTextureSource read new FragmentShaderTextureSource($8939);
    public static property REG_25:    FragmentShaderTextureSource read new FragmentShaderTextureSource($893A);
    public static property REG_26:    FragmentShaderTextureSource read new FragmentShaderTextureSource($893B);
    public static property REG_27:    FragmentShaderTextureSource read new FragmentShaderTextureSource($893C);
    public static property REG_28:    FragmentShaderTextureSource read new FragmentShaderTextureSource($893D);
    public static property REG_29:    FragmentShaderTextureSource read new FragmentShaderTextureSource($893E);
    public static property REG_30:    FragmentShaderTextureSource read new FragmentShaderTextureSource($893F);
    public static property REG_31:    FragmentShaderTextureSource read new FragmentShaderTextureSource($8940);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($84C0) then Result := 'TEXTURE0' else
      if self.val = UInt32($84C1) then Result := 'TEXTURE1' else
      if self.val = UInt32($84C2) then Result := 'TEXTURE2' else
      if self.val = UInt32($84C3) then Result := 'TEXTURE3' else
      if self.val = UInt32($84C4) then Result := 'TEXTURE4' else
      if self.val = UInt32($84C5) then Result := 'TEXTURE5' else
      if self.val = UInt32($84C6) then Result := 'TEXTURE6' else
      if self.val = UInt32($84C7) then Result := 'TEXTURE7' else
      if self.val = UInt32($84C8) then Result := 'TEXTURE8' else
      if self.val = UInt32($84C9) then Result := 'TEXTURE9' else
      if self.val = UInt32($84CA) then Result := 'TEXTURE10' else
      if self.val = UInt32($84CB) then Result := 'TEXTURE11' else
      if self.val = UInt32($84CC) then Result := 'TEXTURE12' else
      if self.val = UInt32($84CD) then Result := 'TEXTURE13' else
      if self.val = UInt32($84CE) then Result := 'TEXTURE14' else
      if self.val = UInt32($84CF) then Result := 'TEXTURE15' else
      if self.val = UInt32($84D0) then Result := 'TEXTURE16' else
      if self.val = UInt32($84D1) then Result := 'TEXTURE17' else
      if self.val = UInt32($84D2) then Result := 'TEXTURE18' else
      if self.val = UInt32($84D3) then Result := 'TEXTURE19' else
      if self.val = UInt32($84D4) then Result := 'TEXTURE20' else
      if self.val = UInt32($84D5) then Result := 'TEXTURE21' else
      if self.val = UInt32($84D6) then Result := 'TEXTURE22' else
      if self.val = UInt32($84D7) then Result := 'TEXTURE23' else
      if self.val = UInt32($84D8) then Result := 'TEXTURE24' else
      if self.val = UInt32($84D9) then Result := 'TEXTURE25' else
      if self.val = UInt32($84DA) then Result := 'TEXTURE26' else
      if self.val = UInt32($84DB) then Result := 'TEXTURE27' else
      if self.val = UInt32($84DC) then Result := 'TEXTURE28' else
      if self.val = UInt32($84DD) then Result := 'TEXTURE29' else
      if self.val = UInt32($84DE) then Result := 'TEXTURE30' else
      if self.val = UInt32($84DF) then Result := 'TEXTURE31' else
      if self.val = UInt32($8921) then Result := 'REG_0' else
      if self.val = UInt32($8922) then Result := 'REG_1' else
      if self.val = UInt32($8923) then Result := 'REG_2' else
      if self.val = UInt32($8924) then Result := 'REG_3' else
      if self.val = UInt32($8925) then Result := 'REG_4' else
      if self.val = UInt32($8926) then Result := 'REG_5' else
      if self.val = UInt32($8927) then Result := 'REG_6' else
      if self.val = UInt32($8928) then Result := 'REG_7' else
      if self.val = UInt32($8929) then Result := 'REG_8' else
      if self.val = UInt32($892A) then Result := 'REG_9' else
      if self.val = UInt32($892B) then Result := 'REG_10' else
      if self.val = UInt32($892C) then Result := 'REG_11' else
      if self.val = UInt32($892D) then Result := 'REG_12' else
      if self.val = UInt32($892E) then Result := 'REG_13' else
      if self.val = UInt32($892F) then Result := 'REG_14' else
      if self.val = UInt32($8930) then Result := 'REG_15' else
      if self.val = UInt32($8931) then Result := 'REG_16' else
      if self.val = UInt32($8932) then Result := 'REG_17' else
      if self.val = UInt32($8933) then Result := 'REG_18' else
      if self.val = UInt32($8934) then Result := 'REG_19' else
      if self.val = UInt32($8935) then Result := 'REG_20' else
      if self.val = UInt32($8936) then Result := 'REG_21' else
      if self.val = UInt32($8937) then Result := 'REG_22' else
      if self.val = UInt32($8938) then Result := 'REG_23' else
      if self.val = UInt32($8939) then Result := 'REG_24' else
      if self.val = UInt32($893A) then Result := 'REG_25' else
      if self.val = UInt32($893B) then Result := 'REG_26' else
      if self.val = UInt32($893C) then Result := 'REG_27' else
      if self.val = UInt32($893D) then Result := 'REG_28' else
      if self.val = UInt32($893E) then Result := 'REG_29' else
      if self.val = UInt32($893F) then Result := 'REG_30' else
      if self.val = UInt32($8940) then Result := 'REG_31' else
        Result := $'FragmentShaderTextureSource[{self.val}]';
    end;
    
  end;
  
  FragmentShaderValueRep = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:  FragmentShaderValueRep read new FragmentShaderValueRep($0000);
    public static property RED:   FragmentShaderValueRep read new FragmentShaderValueRep($1903);
    public static property GREEN: FragmentShaderValueRep read new FragmentShaderValueRep($1904);
    public static property BLUE:  FragmentShaderValueRep read new FragmentShaderValueRep($1905);
    public static property ALPHA: FragmentShaderValueRep read new FragmentShaderValueRep($1906);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($1903) then Result := 'RED' else
      if self.val = UInt32($1904) then Result := 'GREEN' else
      if self.val = UInt32($1905) then Result := 'BLUE' else
      if self.val = UInt32($1906) then Result := 'ALPHA' else
        Result := $'FragmentShaderValueRep[{self.val}]';
    end;
    
  end;
  
  FramebufferAttachment = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DEPTH_STENCIL_ATTACHMENT: FramebufferAttachment read new FramebufferAttachment($821A);
    public static property COLOR_ATTACHMENT0:        FramebufferAttachment read new FramebufferAttachment($8CE0);
    public static property COLOR_ATTACHMENT1:        FramebufferAttachment read new FramebufferAttachment($8CE1);
    public static property COLOR_ATTACHMENT2:        FramebufferAttachment read new FramebufferAttachment($8CE2);
    public static property COLOR_ATTACHMENT3:        FramebufferAttachment read new FramebufferAttachment($8CE3);
    public static property COLOR_ATTACHMENT4:        FramebufferAttachment read new FramebufferAttachment($8CE4);
    public static property COLOR_ATTACHMENT5:        FramebufferAttachment read new FramebufferAttachment($8CE5);
    public static property COLOR_ATTACHMENT6:        FramebufferAttachment read new FramebufferAttachment($8CE6);
    public static property COLOR_ATTACHMENT7:        FramebufferAttachment read new FramebufferAttachment($8CE7);
    public static property COLOR_ATTACHMENT8:        FramebufferAttachment read new FramebufferAttachment($8CE8);
    public static property COLOR_ATTACHMENT9:        FramebufferAttachment read new FramebufferAttachment($8CE9);
    public static property COLOR_ATTACHMENT10:       FramebufferAttachment read new FramebufferAttachment($8CEA);
    public static property COLOR_ATTACHMENT11:       FramebufferAttachment read new FramebufferAttachment($8CEB);
    public static property COLOR_ATTACHMENT12:       FramebufferAttachment read new FramebufferAttachment($8CEC);
    public static property COLOR_ATTACHMENT13:       FramebufferAttachment read new FramebufferAttachment($8CED);
    public static property COLOR_ATTACHMENT14:       FramebufferAttachment read new FramebufferAttachment($8CEE);
    public static property COLOR_ATTACHMENT15:       FramebufferAttachment read new FramebufferAttachment($8CEF);
    public static property COLOR_ATTACHMENT16:       FramebufferAttachment read new FramebufferAttachment($8CF0);
    public static property COLOR_ATTACHMENT17:       FramebufferAttachment read new FramebufferAttachment($8CF1);
    public static property COLOR_ATTACHMENT18:       FramebufferAttachment read new FramebufferAttachment($8CF2);
    public static property COLOR_ATTACHMENT19:       FramebufferAttachment read new FramebufferAttachment($8CF3);
    public static property COLOR_ATTACHMENT20:       FramebufferAttachment read new FramebufferAttachment($8CF4);
    public static property COLOR_ATTACHMENT21:       FramebufferAttachment read new FramebufferAttachment($8CF5);
    public static property COLOR_ATTACHMENT22:       FramebufferAttachment read new FramebufferAttachment($8CF6);
    public static property COLOR_ATTACHMENT23:       FramebufferAttachment read new FramebufferAttachment($8CF7);
    public static property COLOR_ATTACHMENT24:       FramebufferAttachment read new FramebufferAttachment($8CF8);
    public static property COLOR_ATTACHMENT25:       FramebufferAttachment read new FramebufferAttachment($8CF9);
    public static property COLOR_ATTACHMENT26:       FramebufferAttachment read new FramebufferAttachment($8CFA);
    public static property COLOR_ATTACHMENT27:       FramebufferAttachment read new FramebufferAttachment($8CFB);
    public static property COLOR_ATTACHMENT28:       FramebufferAttachment read new FramebufferAttachment($8CFC);
    public static property COLOR_ATTACHMENT29:       FramebufferAttachment read new FramebufferAttachment($8CFD);
    public static property COLOR_ATTACHMENT30:       FramebufferAttachment read new FramebufferAttachment($8CFE);
    public static property COLOR_ATTACHMENT31:       FramebufferAttachment read new FramebufferAttachment($8CFF);
    public static property DEPTH_ATTACHMENT:         FramebufferAttachment read new FramebufferAttachment($8D00);
    public static property STENCIL_ATTACHMENT:       FramebufferAttachment read new FramebufferAttachment($8D20);
    public static property SHADING_RATE_ATTACHMENT:  FramebufferAttachment read new FramebufferAttachment($96D1);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($821A) then Result := 'DEPTH_STENCIL_ATTACHMENT' else
      if self.val = UInt32($8CE0) then Result := 'COLOR_ATTACHMENT0' else
      if self.val = UInt32($8CE1) then Result := 'COLOR_ATTACHMENT1' else
      if self.val = UInt32($8CE2) then Result := 'COLOR_ATTACHMENT2' else
      if self.val = UInt32($8CE3) then Result := 'COLOR_ATTACHMENT3' else
      if self.val = UInt32($8CE4) then Result := 'COLOR_ATTACHMENT4' else
      if self.val = UInt32($8CE5) then Result := 'COLOR_ATTACHMENT5' else
      if self.val = UInt32($8CE6) then Result := 'COLOR_ATTACHMENT6' else
      if self.val = UInt32($8CE7) then Result := 'COLOR_ATTACHMENT7' else
      if self.val = UInt32($8CE8) then Result := 'COLOR_ATTACHMENT8' else
      if self.val = UInt32($8CE9) then Result := 'COLOR_ATTACHMENT9' else
      if self.val = UInt32($8CEA) then Result := 'COLOR_ATTACHMENT10' else
      if self.val = UInt32($8CEB) then Result := 'COLOR_ATTACHMENT11' else
      if self.val = UInt32($8CEC) then Result := 'COLOR_ATTACHMENT12' else
      if self.val = UInt32($8CED) then Result := 'COLOR_ATTACHMENT13' else
      if self.val = UInt32($8CEE) then Result := 'COLOR_ATTACHMENT14' else
      if self.val = UInt32($8CEF) then Result := 'COLOR_ATTACHMENT15' else
      if self.val = UInt32($8CF0) then Result := 'COLOR_ATTACHMENT16' else
      if self.val = UInt32($8CF1) then Result := 'COLOR_ATTACHMENT17' else
      if self.val = UInt32($8CF2) then Result := 'COLOR_ATTACHMENT18' else
      if self.val = UInt32($8CF3) then Result := 'COLOR_ATTACHMENT19' else
      if self.val = UInt32($8CF4) then Result := 'COLOR_ATTACHMENT20' else
      if self.val = UInt32($8CF5) then Result := 'COLOR_ATTACHMENT21' else
      if self.val = UInt32($8CF6) then Result := 'COLOR_ATTACHMENT22' else
      if self.val = UInt32($8CF7) then Result := 'COLOR_ATTACHMENT23' else
      if self.val = UInt32($8CF8) then Result := 'COLOR_ATTACHMENT24' else
      if self.val = UInt32($8CF9) then Result := 'COLOR_ATTACHMENT25' else
      if self.val = UInt32($8CFA) then Result := 'COLOR_ATTACHMENT26' else
      if self.val = UInt32($8CFB) then Result := 'COLOR_ATTACHMENT27' else
      if self.val = UInt32($8CFC) then Result := 'COLOR_ATTACHMENT28' else
      if self.val = UInt32($8CFD) then Result := 'COLOR_ATTACHMENT29' else
      if self.val = UInt32($8CFE) then Result := 'COLOR_ATTACHMENT30' else
      if self.val = UInt32($8CFF) then Result := 'COLOR_ATTACHMENT31' else
      if self.val = UInt32($8D00) then Result := 'DEPTH_ATTACHMENT' else
      if self.val = UInt32($8D20) then Result := 'STENCIL_ATTACHMENT' else
      if self.val = UInt32($96D1) then Result := 'SHADING_RATE_ATTACHMENT' else
        Result := $'FramebufferAttachment[{self.val}]';
    end;
    
  end;
  
  FramebufferAttachmentParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:          FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($8210);
    public static property FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:          FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($8211);
    public static property FRAMEBUFFER_ATTACHMENT_RED_SIZE:                FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($8212);
    public static property FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:              FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($8213);
    public static property FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:               FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($8214);
    public static property FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:              FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($8215);
    public static property FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:              FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($8216);
    public static property FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:            FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($8217);
    public static property FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:             FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($8CD0);
    public static property FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:             FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($8CD1);
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:           FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($8CD2);
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:   FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($8CD3);
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET:      FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($8CD4);
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER:           FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($8CD4);
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES:         FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($8D6C);
    public static property FRAMEBUFFER_ATTACHMENT_LAYERED:                 FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($8DA7);
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_SCALE:           FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($913F);
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS:       FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($9630);
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX: FramebufferAttachmentParameterName read new FramebufferAttachmentParameterName($9632);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8210) then Result := 'FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING' else
      if self.val = UInt32($8211) then Result := 'FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE' else
      if self.val = UInt32($8212) then Result := 'FRAMEBUFFER_ATTACHMENT_RED_SIZE' else
      if self.val = UInt32($8213) then Result := 'FRAMEBUFFER_ATTACHMENT_GREEN_SIZE' else
      if self.val = UInt32($8214) then Result := 'FRAMEBUFFER_ATTACHMENT_BLUE_SIZE' else
      if self.val = UInt32($8215) then Result := 'FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE' else
      if self.val = UInt32($8216) then Result := 'FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE' else
      if self.val = UInt32($8217) then Result := 'FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE' else
      if self.val = UInt32($8CD0) then Result := 'FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE' else
      if self.val = UInt32($8CD1) then Result := 'FRAMEBUFFER_ATTACHMENT_OBJECT_NAME' else
      if self.val = UInt32($8CD2) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL' else
      if self.val = UInt32($8CD3) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE' else
      if self.val = UInt32($8CD4) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET' else
      if self.val = UInt32($8CD4) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER' else
      if self.val = UInt32($8D6C) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES' else
      if self.val = UInt32($8DA7) then Result := 'FRAMEBUFFER_ATTACHMENT_LAYERED' else
      if self.val = UInt32($913F) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_SCALE' else
      if self.val = UInt32($9630) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS' else
      if self.val = UInt32($9632) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX' else
        Result := $'FramebufferAttachmentParameterName[{self.val}]';
    end;
    
  end;
  
  FramebufferParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRAMEBUFFER_DEFAULT_WIDTH:                  FramebufferParameterName read new FramebufferParameterName($9310);
    public static property FRAMEBUFFER_DEFAULT_HEIGHT:                 FramebufferParameterName read new FramebufferParameterName($9311);
    public static property FRAMEBUFFER_DEFAULT_LAYERS:                 FramebufferParameterName read new FramebufferParameterName($9312);
    public static property FRAMEBUFFER_DEFAULT_SAMPLES:                FramebufferParameterName read new FramebufferParameterName($9313);
    public static property FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS: FramebufferParameterName read new FramebufferParameterName($9314);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9310) then Result := 'FRAMEBUFFER_DEFAULT_WIDTH' else
      if self.val = UInt32($9311) then Result := 'FRAMEBUFFER_DEFAULT_HEIGHT' else
      if self.val = UInt32($9312) then Result := 'FRAMEBUFFER_DEFAULT_LAYERS' else
      if self.val = UInt32($9313) then Result := 'FRAMEBUFFER_DEFAULT_SAMPLES' else
      if self.val = UInt32($9314) then Result := 'FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS' else
        Result := $'FramebufferParameterName[{self.val}]';
    end;
    
  end;
  
  FramebufferStatus = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRAMEBUFFER_UNDEFINED:                     FramebufferStatus read new FramebufferStatus($8219);
    public static property FRAMEBUFFER_COMPLETE:                      FramebufferStatus read new FramebufferStatus($8CD5);
    public static property FRAMEBUFFER_INCOMPLETE_ATTACHMENT:         FramebufferStatus read new FramebufferStatus($8CD6);
    public static property FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: FramebufferStatus read new FramebufferStatus($8CD7);
    public static property FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER:        FramebufferStatus read new FramebufferStatus($8CDB);
    public static property FRAMEBUFFER_INCOMPLETE_READ_BUFFER:        FramebufferStatus read new FramebufferStatus($8CDC);
    public static property FRAMEBUFFER_UNSUPPORTED:                   FramebufferStatus read new FramebufferStatus($8CDD);
    public static property FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:        FramebufferStatus read new FramebufferStatus($8D56);
    public static property FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS:      FramebufferStatus read new FramebufferStatus($8DA8);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8219) then Result := 'FRAMEBUFFER_UNDEFINED' else
      if self.val = UInt32($8CD5) then Result := 'FRAMEBUFFER_COMPLETE' else
      if self.val = UInt32($8CD6) then Result := 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT' else
      if self.val = UInt32($8CD7) then Result := 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT' else
      if self.val = UInt32($8CDB) then Result := 'FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER' else
      if self.val = UInt32($8CDC) then Result := 'FRAMEBUFFER_INCOMPLETE_READ_BUFFER' else
      if self.val = UInt32($8CDD) then Result := 'FRAMEBUFFER_UNSUPPORTED' else
      if self.val = UInt32($8D56) then Result := 'FRAMEBUFFER_INCOMPLETE_MULTISAMPLE' else
      if self.val = UInt32($8DA8) then Result := 'FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS' else
        Result := $'FramebufferStatus[{self.val}]';
    end;
    
  end;
  
  FramebufferTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property READ_FRAMEBUFFER: FramebufferTarget read new FramebufferTarget($8CA8);
    public static property DRAW_FRAMEBUFFER: FramebufferTarget read new FramebufferTarget($8CA9);
    public static property FRAMEBUFFER:      FramebufferTarget read new FramebufferTarget($8D40);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8CA8) then Result := 'READ_FRAMEBUFFER' else
      if self.val = UInt32($8CA9) then Result := 'DRAW_FRAMEBUFFER' else
      if self.val = UInt32($8D40) then Result := 'FRAMEBUFFER' else
        Result := $'FramebufferTarget[{self.val}]';
    end;
    
  end;
  
  FrontFaceDirection = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CW:  FrontFaceDirection read new FrontFaceDirection($0900);
    public static property CCW: FrontFaceDirection read new FrontFaceDirection($0901);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0900) then Result := 'CW' else
      if self.val = UInt32($0901) then Result := 'CCW' else
        Result := $'FrontFaceDirection[{self.val}]';
    end;
    
  end;
  
  GDI_LayerPlaneFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LPD_DOUBLEBUFFER:   GDI_LayerPlaneFlags read new GDI_LayerPlaneFlags($0001);
    public static property LPD_STEREO:         GDI_LayerPlaneFlags read new GDI_LayerPlaneFlags($0002);
    public static property LPD_SUPPORT:        GDI_LayerPlaneFlags read new GDI_LayerPlaneFlags($0010);
    public static property LPD_SUPPORT_OPENGL: GDI_LayerPlaneFlags read new GDI_LayerPlaneFlags($0020);
    public static property LPD_SHARE_DEPTH:    GDI_LayerPlaneFlags read new GDI_LayerPlaneFlags($0040);
    public static property LPD_SHARE_STENCIL:  GDI_LayerPlaneFlags read new GDI_LayerPlaneFlags($0080);
    public static property LPD_SHARE_ACCUM:    GDI_LayerPlaneFlags read new GDI_LayerPlaneFlags($0100);
    public static property LPD_SWAP_EXCHANGE:  GDI_LayerPlaneFlags read new GDI_LayerPlaneFlags($0200);
    public static property LPD_SWAP_COPY:      GDI_LayerPlaneFlags read new GDI_LayerPlaneFlags($0400);
    public static property LPD_TRANSPARENT:    GDI_LayerPlaneFlags read new GDI_LayerPlaneFlags($1000);
    
    public static function operator+(f1,f2: GDI_LayerPlaneFlags) := new GDI_LayerPlaneFlags(f1.val or f2.val);
    public static function operator or(f1,f2: GDI_LayerPlaneFlags) := f1+f2;
    
    public static procedure operator+=(var f1: GDI_LayerPlaneFlags; f2: GDI_LayerPlaneFlags) := f1 := f1+f2;
    
    public property HAS_FLAG_LPD_DOUBLEBUFFER:   boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_LPD_STEREO:         boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_LPD_SUPPORT:        boolean read self.val and $0010 <> 0;
    public property HAS_FLAG_LPD_SUPPORT_OPENGL: boolean read self.val and $0020 <> 0;
    public property HAS_FLAG_LPD_SHARE_DEPTH:    boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_LPD_SHARE_STENCIL:  boolean read self.val and $0080 <> 0;
    public property HAS_FLAG_LPD_SHARE_ACCUM:    boolean read self.val and $0100 <> 0;
    public property HAS_FLAG_LPD_SWAP_EXCHANGE:  boolean read self.val and $0200 <> 0;
    public property HAS_FLAG_LPD_SWAP_COPY:      boolean read self.val and $0400 <> 0;
    public property HAS_FLAG_LPD_TRANSPARENT:    boolean read self.val and $1000 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'LPD_DOUBLEBUFFER+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'LPD_STEREO+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'LPD_SUPPORT+';
      if self.val and UInt32($0020) = UInt32($0020) then res += 'LPD_SUPPORT_OPENGL+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'LPD_SHARE_DEPTH+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'LPD_SHARE_STENCIL+';
      if self.val and UInt32($0100) = UInt32($0100) then res += 'LPD_SHARE_ACCUM+';
      if self.val and UInt32($0200) = UInt32($0200) then res += 'LPD_SWAP_EXCHANGE+';
      if self.val and UInt32($0400) = UInt32($0400) then res += 'LPD_SWAP_COPY+';
      if self.val and UInt32($1000) = UInt32($1000) then res += 'LPD_TRANSPARENT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'GDI_LayerPlaneFlags[{self.val}]';
    end;
    
  end;
  
  GDI_PixelDataType = record
    public val: Byte;
    public constructor(val: Byte) := self.val := val;
    
    public static property LPD_TYPE_RGBA:       GDI_PixelDataType read new GDI_PixelDataType($0000);
    public static property LPD_TYPE_COLORINDEX: GDI_PixelDataType read new GDI_PixelDataType($0001);
    
    public function ToString: string; override;
    begin
      if self.val = Byte($0000) then Result := 'LPD_TYPE_RGBA' else
      if self.val = Byte($0001) then Result := 'LPD_TYPE_COLORINDEX' else
        Result := $'GDI_PixelDataType[{self.val}]';
    end;
    
  end;
  
  GDI_PixelFormatFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PFD_DOUBLEBUFFER:          GDI_PixelFormatFlags read new GDI_PixelFormatFlags($0001);
    public static property PFD_STEREO:                GDI_PixelFormatFlags read new GDI_PixelFormatFlags($0002);
    public static property PFD_DRAW_TO_WINDOW:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($0004);
    public static property PFD_DRAW_TO_BITMAP:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($0008);
    public static property PFD_SUPPORT:               GDI_PixelFormatFlags read new GDI_PixelFormatFlags($0010);
    public static property PFD_SUPPORT_OPENGL:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($0020);
    public static property PFD_GENERIC_FORMAT:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($0040);
    public static property PFD_NEED_PALETTE:          GDI_PixelFormatFlags read new GDI_PixelFormatFlags($0080);
    public static property PFD_NEED_SYSTEM_PALETTE:   GDI_PixelFormatFlags read new GDI_PixelFormatFlags($0100);
    public static property PFD_SWAP_EXCHANGE:         GDI_PixelFormatFlags read new GDI_PixelFormatFlags($0200);
    public static property PFD_SWAP_COPY:             GDI_PixelFormatFlags read new GDI_PixelFormatFlags($0400);
    public static property PFD_SWAP_LAYER_BUFFERS:    GDI_PixelFormatFlags read new GDI_PixelFormatFlags($0800);
    public static property PFD_GENERIC_ACCELERATED:   GDI_PixelFormatFlags read new GDI_PixelFormatFlags($1000);
    public static property PFD_DEPTH_DONTCARE:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($20000000);
    public static property PFD_DOUBLEBUFFER_DONTCARE: GDI_PixelFormatFlags read new GDI_PixelFormatFlags($40000000);
    public static property PFD_STEREO_DONTCARE:       GDI_PixelFormatFlags read new GDI_PixelFormatFlags($80000000);
    
    public static function operator+(f1,f2: GDI_PixelFormatFlags) := new GDI_PixelFormatFlags(f1.val or f2.val);
    public static function operator or(f1,f2: GDI_PixelFormatFlags) := f1+f2;
    
    public static procedure operator+=(var f1: GDI_PixelFormatFlags; f2: GDI_PixelFormatFlags) := f1 := f1+f2;
    
    public property HAS_FLAG_PFD_DOUBLEBUFFER:          boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_PFD_STEREO:                boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_PFD_DRAW_TO_WINDOW:        boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_PFD_DRAW_TO_BITMAP:        boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_PFD_SUPPORT:               boolean read self.val and $0010 <> 0;
    public property HAS_FLAG_PFD_SUPPORT_OPENGL:        boolean read self.val and $0020 <> 0;
    public property HAS_FLAG_PFD_GENERIC_FORMAT:        boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_PFD_NEED_PALETTE:          boolean read self.val and $0080 <> 0;
    public property HAS_FLAG_PFD_NEED_SYSTEM_PALETTE:   boolean read self.val and $0100 <> 0;
    public property HAS_FLAG_PFD_SWAP_EXCHANGE:         boolean read self.val and $0200 <> 0;
    public property HAS_FLAG_PFD_SWAP_COPY:             boolean read self.val and $0400 <> 0;
    public property HAS_FLAG_PFD_SWAP_LAYER_BUFFERS:    boolean read self.val and $0800 <> 0;
    public property HAS_FLAG_PFD_GENERIC_ACCELERATED:   boolean read self.val and $1000 <> 0;
    public property HAS_FLAG_PFD_DEPTH_DONTCARE:        boolean read self.val and $20000000 <> 0;
    public property HAS_FLAG_PFD_DOUBLEBUFFER_DONTCARE: boolean read self.val and $40000000 <> 0;
    public property HAS_FLAG_PFD_STEREO_DONTCARE:       boolean read self.val and $80000000 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'PFD_DOUBLEBUFFER+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'PFD_STEREO+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'PFD_DRAW_TO_WINDOW+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'PFD_DRAW_TO_BITMAP+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'PFD_SUPPORT+';
      if self.val and UInt32($0020) = UInt32($0020) then res += 'PFD_SUPPORT_OPENGL+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'PFD_GENERIC_FORMAT+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'PFD_NEED_PALETTE+';
      if self.val and UInt32($0100) = UInt32($0100) then res += 'PFD_NEED_SYSTEM_PALETTE+';
      if self.val and UInt32($0200) = UInt32($0200) then res += 'PFD_SWAP_EXCHANGE+';
      if self.val and UInt32($0400) = UInt32($0400) then res += 'PFD_SWAP_COPY+';
      if self.val and UInt32($0800) = UInt32($0800) then res += 'PFD_SWAP_LAYER_BUFFERS+';
      if self.val and UInt32($1000) = UInt32($1000) then res += 'PFD_GENERIC_ACCELERATED+';
      if self.val and UInt32($20000000) = UInt32($20000000) then res += 'PFD_DEPTH_DONTCARE+';
      if self.val and UInt32($40000000) = UInt32($40000000) then res += 'PFD_DOUBLEBUFFER_DONTCARE+';
      if self.val and UInt32($80000000) = UInt32($80000000) then res += 'PFD_STEREO_DONTCARE+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'GDI_PixelFormatFlags[{self.val}]';
    end;
    
  end;
  
  GetFramebufferParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DOUBLEBUFFER:                               GetFramebufferParameter read new GetFramebufferParameter($0C32);
    public static property STEREO:                                     GetFramebufferParameter read new GetFramebufferParameter($0C33);
    public static property SAMPLE_BUFFERS:                             GetFramebufferParameter read new GetFramebufferParameter($80A8);
    public static property SAMPLES:                                    GetFramebufferParameter read new GetFramebufferParameter($80A9);
    public static property IMPLEMENTATION_COLOR_READ_TYPE:             GetFramebufferParameter read new GetFramebufferParameter($8B9A);
    public static property IMPLEMENTATION_COLOR_READ_FORMAT:           GetFramebufferParameter read new GetFramebufferParameter($8B9B);
    public static property FRAMEBUFFER_DEFAULT_WIDTH:                  GetFramebufferParameter read new GetFramebufferParameter($9310);
    public static property FRAMEBUFFER_DEFAULT_HEIGHT:                 GetFramebufferParameter read new GetFramebufferParameter($9311);
    public static property FRAMEBUFFER_DEFAULT_LAYERS:                 GetFramebufferParameter read new GetFramebufferParameter($9312);
    public static property FRAMEBUFFER_DEFAULT_SAMPLES:                GetFramebufferParameter read new GetFramebufferParameter($9313);
    public static property FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS: GetFramebufferParameter read new GetFramebufferParameter($9314);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0C32) then Result := 'DOUBLEBUFFER' else
      if self.val = UInt32($0C33) then Result := 'STEREO' else
      if self.val = UInt32($80A8) then Result := 'SAMPLE_BUFFERS' else
      if self.val = UInt32($80A9) then Result := 'SAMPLES' else
      if self.val = UInt32($8B9A) then Result := 'IMPLEMENTATION_COLOR_READ_TYPE' else
      if self.val = UInt32($8B9B) then Result := 'IMPLEMENTATION_COLOR_READ_FORMAT' else
      if self.val = UInt32($9310) then Result := 'FRAMEBUFFER_DEFAULT_WIDTH' else
      if self.val = UInt32($9311) then Result := 'FRAMEBUFFER_DEFAULT_HEIGHT' else
      if self.val = UInt32($9312) then Result := 'FRAMEBUFFER_DEFAULT_LAYERS' else
      if self.val = UInt32($9313) then Result := 'FRAMEBUFFER_DEFAULT_SAMPLES' else
      if self.val = UInt32($9314) then Result := 'FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS' else
        Result := $'GetFramebufferParameter[{self.val}]';
    end;
    
  end;
  
  GetHistogramParameterPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property HISTOGRAM_WIDTH:          GetHistogramParameterPName read new GetHistogramParameterPName($8026);
    public static property HISTOGRAM_FORMAT:         GetHistogramParameterPName read new GetHistogramParameterPName($8027);
    public static property HISTOGRAM_RED_SIZE:       GetHistogramParameterPName read new GetHistogramParameterPName($8028);
    public static property HISTOGRAM_GREEN_SIZE:     GetHistogramParameterPName read new GetHistogramParameterPName($8029);
    public static property HISTOGRAM_BLUE_SIZE:      GetHistogramParameterPName read new GetHistogramParameterPName($802A);
    public static property HISTOGRAM_ALPHA_SIZE:     GetHistogramParameterPName read new GetHistogramParameterPName($802B);
    public static property HISTOGRAM_LUMINANCE_SIZE: GetHistogramParameterPName read new GetHistogramParameterPName($802C);
    public static property HISTOGRAM_SINK:           GetHistogramParameterPName read new GetHistogramParameterPName($802D);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8026) then Result := 'HISTOGRAM_WIDTH' else
      if self.val = UInt32($8027) then Result := 'HISTOGRAM_FORMAT' else
      if self.val = UInt32($8028) then Result := 'HISTOGRAM_RED_SIZE' else
      if self.val = UInt32($8029) then Result := 'HISTOGRAM_GREEN_SIZE' else
      if self.val = UInt32($802A) then Result := 'HISTOGRAM_BLUE_SIZE' else
      if self.val = UInt32($802B) then Result := 'HISTOGRAM_ALPHA_SIZE' else
      if self.val = UInt32($802C) then Result := 'HISTOGRAM_LUMINANCE_SIZE' else
      if self.val = UInt32($802D) then Result := 'HISTOGRAM_SINK' else
        Result := $'GetHistogramParameterPName[{self.val}]';
    end;
    
  end;
  
  GetMapQuery = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COEFF:  GetMapQuery read new GetMapQuery($0A00);
    public static property ORDER:  GetMapQuery read new GetMapQuery($0A01);
    public static property DOMAIN: GetMapQuery read new GetMapQuery($0A02);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0A00) then Result := 'COEFF' else
      if self.val = UInt32($0A01) then Result := 'ORDER' else
      if self.val = UInt32($0A02) then Result := 'DOMAIN' else
        Result := $'GetMapQuery[{self.val}]';
    end;
    
  end;
  
  GetMinmaxParameterPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MINMAX_FORMAT: GetMinmaxParameterPName read new GetMinmaxParameterPName($802F);
    public static property MINMAX_SINK:   GetMinmaxParameterPName read new GetMinmaxParameterPName($8030);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($802F) then Result := 'MINMAX_FORMAT' else
      if self.val = UInt32($8030) then Result := 'MINMAX_SINK' else
        Result := $'GetMinmaxParameterPName[{self.val}]';
    end;
    
  end;
  
  GetMultisamplePName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SAMPLE_POSITION:              GetMultisamplePName read new GetMultisamplePName($8E50);
    public static property SAMPLE_LOCATION:              GetMultisamplePName read new GetMultisamplePName($8E50);
    public static property PROGRAMMABLE_SAMPLE_LOCATION: GetMultisamplePName read new GetMultisamplePName($9341);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8E50) then Result := 'SAMPLE_POSITION' else
      if self.val = UInt32($8E50) then Result := 'SAMPLE_LOCATION' else
      if self.val = UInt32($9341) then Result := 'PROGRAMMABLE_SAMPLE_LOCATION' else
        Result := $'GetMultisamplePName[{self.val}]';
    end;
    
  end;
  
  GetPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CURRENT_COLOR:                                                       GetPName read new GetPName($0B00);
    public static property CURRENT_INDEX:                                                       GetPName read new GetPName($0B01);
    public static property CURRENT_NORMAL:                                                      GetPName read new GetPName($0B02);
    public static property CURRENT_TEXTURE_COORDS:                                              GetPName read new GetPName($0B03);
    public static property CURRENT_RASTER_COLOR:                                                GetPName read new GetPName($0B04);
    public static property CURRENT_RASTER_INDEX:                                                GetPName read new GetPName($0B05);
    public static property CURRENT_RASTER_TEXTURE_COORDS:                                       GetPName read new GetPName($0B06);
    public static property CURRENT_RASTER_POSITION:                                             GetPName read new GetPName($0B07);
    public static property CURRENT_RASTER_POSITION_VALID:                                       GetPName read new GetPName($0B08);
    public static property CURRENT_RASTER_DISTANCE:                                             GetPName read new GetPName($0B09);
    public static property POINT_SMOOTH:                                                        GetPName read new GetPName($0B10);
    public static property POINT_SIZE:                                                          GetPName read new GetPName($0B11);
    public static property POINT_SIZE_RANGE:                                                    GetPName read new GetPName($0B12);
    public static property SMOOTH_POINT_SIZE_RANGE:                                             GetPName read new GetPName($0B12);
    public static property POINT_SIZE_GRANULARITY:                                              GetPName read new GetPName($0B13);
    public static property SMOOTH_POINT_SIZE_GRANULARITY:                                       GetPName read new GetPName($0B13);
    public static property LINE_SMOOTH:                                                         GetPName read new GetPName($0B20);
    public static property LINE_WIDTH:                                                          GetPName read new GetPName($0B21);
    public static property LINE_WIDTH_RANGE:                                                    GetPName read new GetPName($0B22);
    public static property SMOOTH_LINE_WIDTH_RANGE:                                             GetPName read new GetPName($0B22);
    public static property LINE_WIDTH_GRANULARITY:                                              GetPName read new GetPName($0B23);
    public static property SMOOTH_LINE_WIDTH_GRANULARITY:                                       GetPName read new GetPName($0B23);
    public static property LINE_STIPPLE:                                                        GetPName read new GetPName($0B24);
    public static property LINE_STIPPLE_PATTERN:                                                GetPName read new GetPName($0B25);
    public static property LINE_STIPPLE_REPEAT:                                                 GetPName read new GetPName($0B26);
    public static property LIST_MODE:                                                           GetPName read new GetPName($0B30);
    public static property MAX_LIST_NESTING:                                                    GetPName read new GetPName($0B31);
    public static property LIST_BASE:                                                           GetPName read new GetPName($0B32);
    public static property LIST_INDEX:                                                          GetPName read new GetPName($0B33);
    public static property POLYGON_MODE:                                                        GetPName read new GetPName($0B40);
    public static property POLYGON_SMOOTH:                                                      GetPName read new GetPName($0B41);
    public static property POLYGON_STIPPLE:                                                     GetPName read new GetPName($0B42);
    public static property EDGE_FLAG:                                                           GetPName read new GetPName($0B43);
    public static property CULL_FACE:                                                           GetPName read new GetPName($0B44);
    public static property CULL_FACE_MODE:                                                      GetPName read new GetPName($0B45);
    public static property FRONT_FACE:                                                          GetPName read new GetPName($0B46);
    public static property LIGHTING:                                                            GetPName read new GetPName($0B50);
    public static property LIGHT_MODEL_LOCAL_VIEWER:                                            GetPName read new GetPName($0B51);
    public static property LIGHT_MODEL_TWO_SIDE:                                                GetPName read new GetPName($0B52);
    public static property LIGHT_MODEL_AMBIENT:                                                 GetPName read new GetPName($0B53);
    public static property SHADE_MODEL:                                                         GetPName read new GetPName($0B54);
    public static property COLOR_MATERIAL_FACE:                                                 GetPName read new GetPName($0B55);
    public static property COLOR_MATERIAL_PARAMETER:                                            GetPName read new GetPName($0B56);
    public static property COLOR_MATERIAL:                                                      GetPName read new GetPName($0B57);
    public static property FOG:                                                                 GetPName read new GetPName($0B60);
    public static property FOG_INDEX:                                                           GetPName read new GetPName($0B61);
    public static property FOG_DENSITY:                                                         GetPName read new GetPName($0B62);
    public static property FOG_START:                                                           GetPName read new GetPName($0B63);
    public static property FOG_END:                                                             GetPName read new GetPName($0B64);
    public static property FOG_MODE:                                                            GetPName read new GetPName($0B65);
    public static property FOG_COLOR:                                                           GetPName read new GetPName($0B66);
    public static property DEPTH_RANGE:                                                         GetPName read new GetPName($0B70);
    public static property DEPTH_TEST:                                                          GetPName read new GetPName($0B71);
    public static property DEPTH_WRITEMASK:                                                     GetPName read new GetPName($0B72);
    public static property DEPTH_CLEAR_VALUE:                                                   GetPName read new GetPName($0B73);
    public static property DEPTH_FUNC:                                                          GetPName read new GetPName($0B74);
    public static property ACCUM_CLEAR_VALUE:                                                   GetPName read new GetPName($0B80);
    public static property STENCIL_TEST:                                                        GetPName read new GetPName($0B90);
    public static property STENCIL_CLEAR_VALUE:                                                 GetPName read new GetPName($0B91);
    public static property STENCIL_FUNC:                                                        GetPName read new GetPName($0B92);
    public static property STENCIL_VALUE_MASK:                                                  GetPName read new GetPName($0B93);
    public static property STENCIL_FAIL:                                                        GetPName read new GetPName($0B94);
    public static property STENCIL_PASS_DEPTH_FAIL:                                             GetPName read new GetPName($0B95);
    public static property STENCIL_PASS_DEPTH_PASS:                                             GetPName read new GetPName($0B96);
    public static property STENCIL_REF:                                                         GetPName read new GetPName($0B97);
    public static property STENCIL_WRITEMASK:                                                   GetPName read new GetPName($0B98);
    public static property MATRIX_MODE:                                                         GetPName read new GetPName($0BA0);
    public static property NORMALIZE:                                                           GetPName read new GetPName($0BA1);
    public static property VIEWPORT:                                                            GetPName read new GetPName($0BA2);
    public static property MODELVIEW_STACK_DEPTH:                                               GetPName read new GetPName($0BA3);
    public static property MODELVIEW0_STACK_DEPTH:                                              GetPName read new GetPName($0BA3);
    public static property PROJECTION_STACK_DEPTH:                                              GetPName read new GetPName($0BA4);
    public static property TEXTURE_STACK_DEPTH:                                                 GetPName read new GetPName($0BA5);
    public static property MODELVIEW0_MATRIX:                                                   GetPName read new GetPName($0BA6);
    public static property MODELVIEW_MATRIX:                                                    GetPName read new GetPName($0BA6);
    public static property PROJECTION_MATRIX:                                                   GetPName read new GetPName($0BA7);
    public static property TEXTURE_MATRIX:                                                      GetPName read new GetPName($0BA8);
    public static property ATTRIB_STACK_DEPTH:                                                  GetPName read new GetPName($0BB0);
    public static property CLIENT_ATTRIB_STACK_DEPTH:                                           GetPName read new GetPName($0BB1);
    public static property ALPHA_TEST:                                                          GetPName read new GetPName($0BC0);
    public static property ALPHA_TEST_FUNC:                                                     GetPName read new GetPName($0BC1);
    public static property ALPHA_TEST_REF:                                                      GetPName read new GetPName($0BC2);
    public static property DITHER:                                                              GetPName read new GetPName($0BD0);
    public static property BLEND_DST:                                                           GetPName read new GetPName($0BE0);
    public static property BLEND_SRC:                                                           GetPName read new GetPName($0BE1);
    public static property BLEND:                                                               GetPName read new GetPName($0BE2);
    public static property LOGIC_OP_MODE:                                                       GetPName read new GetPName($0BF0);
    public static property INDEX_LOGIC_OP:                                                      GetPName read new GetPName($0BF1);
    public static property LOGIC_OP:                                                            GetPName read new GetPName($0BF1);
    public static property COLOR_LOGIC_OP:                                                      GetPName read new GetPName($0BF2);
    public static property AUX_BUFFERS:                                                         GetPName read new GetPName($0C00);
    public static property DRAW_BUFFER:                                                         GetPName read new GetPName($0C01);
    public static property READ_BUFFER:                                                         GetPName read new GetPName($0C02);
    public static property SCISSOR_BOX:                                                         GetPName read new GetPName($0C10);
    public static property SCISSOR_TEST:                                                        GetPName read new GetPName($0C11);
    public static property INDEX_CLEAR_VALUE:                                                   GetPName read new GetPName($0C20);
    public static property INDEX_WRITEMASK:                                                     GetPName read new GetPName($0C21);
    public static property COLOR_CLEAR_VALUE:                                                   GetPName read new GetPName($0C22);
    public static property COLOR_WRITEMASK:                                                     GetPName read new GetPName($0C23);
    public static property INDEX_MODE:                                                          GetPName read new GetPName($0C30);
    public static property RGBA_MODE:                                                           GetPName read new GetPName($0C31);
    public static property DOUBLEBUFFER:                                                        GetPName read new GetPName($0C32);
    public static property STEREO:                                                              GetPName read new GetPName($0C33);
    public static property RENDER_MODE:                                                         GetPName read new GetPName($0C40);
    public static property PERSPECTIVE_CORRECTION_HINT:                                         GetPName read new GetPName($0C50);
    public static property POINT_SMOOTH_HINT:                                                   GetPName read new GetPName($0C51);
    public static property LINE_SMOOTH_HINT:                                                    GetPName read new GetPName($0C52);
    public static property POLYGON_SMOOTH_HINT:                                                 GetPName read new GetPName($0C53);
    public static property FOG_HINT:                                                            GetPName read new GetPName($0C54);
    public static property TEXTURE_GEN_S:                                                       GetPName read new GetPName($0C60);
    public static property TEXTURE_GEN_T:                                                       GetPName read new GetPName($0C61);
    public static property TEXTURE_GEN_R:                                                       GetPName read new GetPName($0C62);
    public static property TEXTURE_GEN_Q:                                                       GetPName read new GetPName($0C63);
    public static property PIXEL_MAP_I_TO_I_SIZE:                                               GetPName read new GetPName($0CB0);
    public static property PIXEL_MAP_S_TO_S_SIZE:                                               GetPName read new GetPName($0CB1);
    public static property PIXEL_MAP_I_TO_R_SIZE:                                               GetPName read new GetPName($0CB2);
    public static property PIXEL_MAP_I_TO_G_SIZE:                                               GetPName read new GetPName($0CB3);
    public static property PIXEL_MAP_I_TO_B_SIZE:                                               GetPName read new GetPName($0CB4);
    public static property PIXEL_MAP_I_TO_A_SIZE:                                               GetPName read new GetPName($0CB5);
    public static property PIXEL_MAP_R_TO_R_SIZE:                                               GetPName read new GetPName($0CB6);
    public static property PIXEL_MAP_G_TO_G_SIZE:                                               GetPName read new GetPName($0CB7);
    public static property PIXEL_MAP_B_TO_B_SIZE:                                               GetPName read new GetPName($0CB8);
    public static property PIXEL_MAP_A_TO_A_SIZE:                                               GetPName read new GetPName($0CB9);
    public static property UNPACK_SWAP_BYTES:                                                   GetPName read new GetPName($0CF0);
    public static property UNPACK_LSB_FIRST:                                                    GetPName read new GetPName($0CF1);
    public static property UNPACK_ROW_LENGTH:                                                   GetPName read new GetPName($0CF2);
    public static property UNPACK_SKIP_ROWS:                                                    GetPName read new GetPName($0CF3);
    public static property UNPACK_SKIP_PIXELS:                                                  GetPName read new GetPName($0CF4);
    public static property UNPACK_ALIGNMENT:                                                    GetPName read new GetPName($0CF5);
    public static property PACK_SWAP_BYTES:                                                     GetPName read new GetPName($0D00);
    public static property PACK_LSB_FIRST:                                                      GetPName read new GetPName($0D01);
    public static property PACK_ROW_LENGTH:                                                     GetPName read new GetPName($0D02);
    public static property PACK_SKIP_ROWS:                                                      GetPName read new GetPName($0D03);
    public static property PACK_SKIP_PIXELS:                                                    GetPName read new GetPName($0D04);
    public static property PACK_ALIGNMENT:                                                      GetPName read new GetPName($0D05);
    public static property MAP_COLOR:                                                           GetPName read new GetPName($0D10);
    public static property MAP_STENCIL:                                                         GetPName read new GetPName($0D11);
    public static property INDEX_SHIFT:                                                         GetPName read new GetPName($0D12);
    public static property INDEX_OFFSET:                                                        GetPName read new GetPName($0D13);
    public static property RED_SCALE:                                                           GetPName read new GetPName($0D14);
    public static property RED_BIAS:                                                            GetPName read new GetPName($0D15);
    public static property ZOOM_X:                                                              GetPName read new GetPName($0D16);
    public static property ZOOM_Y:                                                              GetPName read new GetPName($0D17);
    public static property GREEN_SCALE:                                                         GetPName read new GetPName($0D18);
    public static property GREEN_BIAS:                                                          GetPName read new GetPName($0D19);
    public static property BLUE_SCALE:                                                          GetPName read new GetPName($0D1A);
    public static property BLUE_BIAS:                                                           GetPName read new GetPName($0D1B);
    public static property ALPHA_SCALE:                                                         GetPName read new GetPName($0D1C);
    public static property ALPHA_BIAS:                                                          GetPName read new GetPName($0D1D);
    public static property DEPTH_SCALE:                                                         GetPName read new GetPName($0D1E);
    public static property DEPTH_BIAS:                                                          GetPName read new GetPName($0D1F);
    public static property MAX_EVAL_ORDER:                                                      GetPName read new GetPName($0D30);
    public static property MAX_LIGHTS:                                                          GetPName read new GetPName($0D31);
    public static property MAX_CLIP_PLANES:                                                     GetPName read new GetPName($0D32);
    public static property MAX_CLIP_DISTANCES:                                                  GetPName read new GetPName($0D32);
    public static property MAX_TEXTURE_SIZE:                                                    GetPName read new GetPName($0D33);
    public static property MAX_PIXEL_MAP_TABLE:                                                 GetPName read new GetPName($0D34);
    public static property MAX_ATTRIB_STACK_DEPTH:                                              GetPName read new GetPName($0D35);
    public static property MAX_MODELVIEW_STACK_DEPTH:                                           GetPName read new GetPName($0D36);
    public static property MAX_NAME_STACK_DEPTH:                                                GetPName read new GetPName($0D37);
    public static property MAX_PROJECTION_STACK_DEPTH:                                          GetPName read new GetPName($0D38);
    public static property MAX_TEXTURE_STACK_DEPTH:                                             GetPName read new GetPName($0D39);
    public static property MAX_VIEWPORT_DIMS:                                                   GetPName read new GetPName($0D3A);
    public static property MAX_CLIENT_ATTRIB_STACK_DEPTH:                                       GetPName read new GetPName($0D3B);
    public static property SUBPIXEL_BITS:                                                       GetPName read new GetPName($0D50);
    public static property INDEX_BITS:                                                          GetPName read new GetPName($0D51);
    public static property RED_BITS:                                                            GetPName read new GetPName($0D52);
    public static property GREEN_BITS:                                                          GetPName read new GetPName($0D53);
    public static property BLUE_BITS:                                                           GetPName read new GetPName($0D54);
    public static property ALPHA_BITS:                                                          GetPName read new GetPName($0D55);
    public static property DEPTH_BITS:                                                          GetPName read new GetPName($0D56);
    public static property STENCIL_BITS:                                                        GetPName read new GetPName($0D57);
    public static property ACCUM_RED_BITS:                                                      GetPName read new GetPName($0D58);
    public static property ACCUM_GREEN_BITS:                                                    GetPName read new GetPName($0D59);
    public static property ACCUM_BLUE_BITS:                                                     GetPName read new GetPName($0D5A);
    public static property ACCUM_ALPHA_BITS:                                                    GetPName read new GetPName($0D5B);
    public static property NAME_STACK_DEPTH:                                                    GetPName read new GetPName($0D70);
    public static property AUTO_NORMAL:                                                         GetPName read new GetPName($0D80);
    public static property MAP1_COLOR_4:                                                        GetPName read new GetPName($0D90);
    public static property MAP1_INDEX:                                                          GetPName read new GetPName($0D91);
    public static property MAP1_NORMAL:                                                         GetPName read new GetPName($0D92);
    public static property MAP1_TEXTURE_COORD_1:                                                GetPName read new GetPName($0D93);
    public static property MAP1_TEXTURE_COORD_2:                                                GetPName read new GetPName($0D94);
    public static property MAP1_TEXTURE_COORD_3:                                                GetPName read new GetPName($0D95);
    public static property MAP1_TEXTURE_COORD_4:                                                GetPName read new GetPName($0D96);
    public static property MAP1_VERTEX_3:                                                       GetPName read new GetPName($0D97);
    public static property MAP1_VERTEX_4:                                                       GetPName read new GetPName($0D98);
    public static property MAP2_COLOR_4:                                                        GetPName read new GetPName($0DB0);
    public static property MAP2_INDEX:                                                          GetPName read new GetPName($0DB1);
    public static property MAP2_NORMAL:                                                         GetPName read new GetPName($0DB2);
    public static property MAP2_TEXTURE_COORD_1:                                                GetPName read new GetPName($0DB3);
    public static property MAP2_TEXTURE_COORD_2:                                                GetPName read new GetPName($0DB4);
    public static property MAP2_TEXTURE_COORD_3:                                                GetPName read new GetPName($0DB5);
    public static property MAP2_TEXTURE_COORD_4:                                                GetPName read new GetPName($0DB6);
    public static property MAP2_VERTEX_3:                                                       GetPName read new GetPName($0DB7);
    public static property MAP2_VERTEX_4:                                                       GetPName read new GetPName($0DB8);
    public static property MAP1_GRID_DOMAIN:                                                    GetPName read new GetPName($0DD0);
    public static property MAP1_GRID_SEGMENTS:                                                  GetPName read new GetPName($0DD1);
    public static property MAP2_GRID_DOMAIN:                                                    GetPName read new GetPName($0DD2);
    public static property MAP2_GRID_SEGMENTS:                                                  GetPName read new GetPName($0DD3);
    public static property TEXTURE_1D:                                                          GetPName read new GetPName($0DE0);
    public static property TEXTURE_2D:                                                          GetPName read new GetPName($0DE1);
    public static property FEEDBACK_BUFFER_SIZE:                                                GetPName read new GetPName($0DF1);
    public static property FEEDBACK_BUFFER_TYPE:                                                GetPName read new GetPName($0DF2);
    public static property SELECTION_BUFFER_SIZE:                                               GetPName read new GetPName($0DF4);
    public static property POLYGON_OFFSET_UNITS:                                                GetPName read new GetPName($2A00);
    public static property POLYGON_OFFSET_POINT:                                                GetPName read new GetPName($2A01);
    public static property POLYGON_OFFSET_LINE:                                                 GetPName read new GetPName($2A02);
    public static property CLIP_PLANE0:                                                         GetPName read new GetPName($3000);
    public static property CLIP_PLANE1:                                                         GetPName read new GetPName($3001);
    public static property CLIP_PLANE2:                                                         GetPName read new GetPName($3002);
    public static property CLIP_PLANE3:                                                         GetPName read new GetPName($3003);
    public static property CLIP_PLANE4:                                                         GetPName read new GetPName($3004);
    public static property CLIP_PLANE5:                                                         GetPName read new GetPName($3005);
    public static property LIGHT0:                                                              GetPName read new GetPName($4000);
    public static property LIGHT1:                                                              GetPName read new GetPName($4001);
    public static property LIGHT2:                                                              GetPName read new GetPName($4002);
    public static property LIGHT3:                                                              GetPName read new GetPName($4003);
    public static property LIGHT4:                                                              GetPName read new GetPName($4004);
    public static property LIGHT5:                                                              GetPName read new GetPName($4005);
    public static property LIGHT6:                                                              GetPName read new GetPName($4006);
    public static property LIGHT7:                                                              GetPName read new GetPName($4007);
    public static property BLEND_COLOR:                                                         GetPName read new GetPName($8005);
    public static property BLEND_EQUATION:                                                      GetPName read new GetPName($8009);
    public static property BLEND_EQUATION_RGB:                                                  GetPName read new GetPName($8009);
    public static property PACK_CMYK_HINT:                                                      GetPName read new GetPName($800E);
    public static property UNPACK_CMYK_HINT:                                                    GetPName read new GetPName($800F);
    public static property CONVOLUTION_1D:                                                      GetPName read new GetPName($8010);
    public static property CONVOLUTION_2D:                                                      GetPName read new GetPName($8011);
    public static property SEPARABLE_2D:                                                        GetPName read new GetPName($8012);
    public static property POST_CONVOLUTION_RED_SCALE:                                          GetPName read new GetPName($801C);
    public static property POST_CONVOLUTION_GREEN_SCALE:                                        GetPName read new GetPName($801D);
    public static property POST_CONVOLUTION_BLUE_SCALE:                                         GetPName read new GetPName($801E);
    public static property POST_CONVOLUTION_ALPHA_SCALE:                                        GetPName read new GetPName($801F);
    public static property POST_CONVOLUTION_RED_BIAS:                                           GetPName read new GetPName($8020);
    public static property POST_CONVOLUTION_GREEN_BIAS:                                         GetPName read new GetPName($8021);
    public static property POST_CONVOLUTION_BLUE_BIAS:                                          GetPName read new GetPName($8022);
    public static property POST_CONVOLUTION_ALPHA_BIAS:                                         GetPName read new GetPName($8023);
    public static property HISTOGRAM:                                                           GetPName read new GetPName($8024);
    public static property MINMAX:                                                              GetPName read new GetPName($802E);
    public static property POLYGON_OFFSET_FILL:                                                 GetPName read new GetPName($8037);
    public static property POLYGON_OFFSET_FACTOR:                                               GetPName read new GetPName($8038);
    public static property POLYGON_OFFSET_BIAS:                                                 GetPName read new GetPName($8039);
    public static property RESCALE_NORMAL:                                                      GetPName read new GetPName($803A);
    public static property TEXTURE_BINDING_1D:                                                  GetPName read new GetPName($8068);
    public static property TEXTURE_BINDING_2D:                                                  GetPName read new GetPName($8069);
    public static property TEXTURE_3D_BINDING:                                                  GetPName read new GetPName($806A);
    public static property TEXTURE_BINDING_3D:                                                  GetPName read new GetPName($806A);
    public static property PACK_SKIP_IMAGES:                                                    GetPName read new GetPName($806B);
    public static property PACK_IMAGE_HEIGHT:                                                   GetPName read new GetPName($806C);
    public static property UNPACK_SKIP_IMAGES:                                                  GetPName read new GetPName($806D);
    public static property UNPACK_IMAGE_HEIGHT:                                                 GetPName read new GetPName($806E);
    public static property TEXTURE_3D:                                                          GetPName read new GetPName($806F);
    public static property MAX_3D_TEXTURE_SIZE:                                                 GetPName read new GetPName($8073);
    public static property VERTEX_ARRAY:                                                        GetPName read new GetPName($8074);
    public static property NORMAL_ARRAY:                                                        GetPName read new GetPName($8075);
    public static property COLOR_ARRAY:                                                         GetPName read new GetPName($8076);
    public static property INDEX_ARRAY:                                                         GetPName read new GetPName($8077);
    public static property TEXTURE_COORD_ARRAY:                                                 GetPName read new GetPName($8078);
    public static property EDGE_FLAG_ARRAY:                                                     GetPName read new GetPName($8079);
    public static property VERTEX_ARRAY_SIZE:                                                   GetPName read new GetPName($807A);
    public static property VERTEX_ARRAY_TYPE:                                                   GetPName read new GetPName($807B);
    public static property VERTEX_ARRAY_STRIDE:                                                 GetPName read new GetPName($807C);
    public static property VERTEX_ARRAY_COUNT:                                                  GetPName read new GetPName($807D);
    public static property NORMAL_ARRAY_TYPE:                                                   GetPName read new GetPName($807E);
    public static property NORMAL_ARRAY_STRIDE:                                                 GetPName read new GetPName($807F);
    public static property NORMAL_ARRAY_COUNT:                                                  GetPName read new GetPName($8080);
    public static property COLOR_ARRAY_SIZE:                                                    GetPName read new GetPName($8081);
    public static property COLOR_ARRAY_TYPE:                                                    GetPName read new GetPName($8082);
    public static property COLOR_ARRAY_STRIDE:                                                  GetPName read new GetPName($8083);
    public static property COLOR_ARRAY_COUNT:                                                   GetPName read new GetPName($8084);
    public static property INDEX_ARRAY_TYPE:                                                    GetPName read new GetPName($8085);
    public static property INDEX_ARRAY_STRIDE:                                                  GetPName read new GetPName($8086);
    public static property INDEX_ARRAY_COUNT:                                                   GetPName read new GetPName($8087);
    public static property TEXTURE_COORD_ARRAY_SIZE:                                            GetPName read new GetPName($8088);
    public static property TEXTURE_COORD_ARRAY_TYPE:                                            GetPName read new GetPName($8089);
    public static property TEXTURE_COORD_ARRAY_STRIDE:                                          GetPName read new GetPName($808A);
    public static property TEXTURE_COORD_ARRAY_COUNT:                                           GetPName read new GetPName($808B);
    public static property EDGE_FLAG_ARRAY_STRIDE:                                              GetPName read new GetPName($808C);
    public static property EDGE_FLAG_ARRAY_COUNT:                                               GetPName read new GetPName($808D);
    public static property INTERLACE:                                                           GetPName read new GetPName($8094);
    public static property DETAIL_TEXTURE_2D_BINDING:                                           GetPName read new GetPName($8096);
    public static property MULTISAMPLE:                                                         GetPName read new GetPName($809D);
    public static property SAMPLE_ALPHA_TO_MASK:                                                GetPName read new GetPName($809E);
    public static property SAMPLE_ALPHA_TO_ONE:                                                 GetPName read new GetPName($809F);
    public static property SAMPLE_MASK_SGIS:                                                    GetPName read new GetPName($80A0);
    public static property SAMPLE_BUFFERS:                                                      GetPName read new GetPName($80A8);
    public static property SAMPLES:                                                             GetPName read new GetPName($80A9);
    public static property SAMPLE_MASK_VALUE:                                                   GetPName read new GetPName($80AA);
    public static property SAMPLE_COVERAGE_VALUE:                                               GetPName read new GetPName($80AA);
    public static property SAMPLE_MASK_INVERT:                                                  GetPName read new GetPName($80AB);
    public static property SAMPLE_COVERAGE_INVERT:                                              GetPName read new GetPName($80AB);
    public static property SAMPLE_PATTERN:                                                      GetPName read new GetPName($80AC);
    public static property COLOR_MATRIX:                                                        GetPName read new GetPName($80B1);
    public static property COLOR_MATRIX_STACK_DEPTH:                                            GetPName read new GetPName($80B2);
    public static property MAX_COLOR_MATRIX_STACK_DEPTH:                                        GetPName read new GetPName($80B3);
    public static property POST_COLOR_MATRIX_RED_SCALE:                                         GetPName read new GetPName($80B4);
    public static property POST_COLOR_MATRIX_GREEN_SCALE:                                       GetPName read new GetPName($80B5);
    public static property POST_COLOR_MATRIX_BLUE_SCALE:                                        GetPName read new GetPName($80B6);
    public static property POST_COLOR_MATRIX_ALPHA_SCALE:                                       GetPName read new GetPName($80B7);
    public static property POST_COLOR_MATRIX_RED_BIAS:                                          GetPName read new GetPName($80B8);
    public static property POST_COLOR_MATRIX_GREEN_BIAS:                                        GetPName read new GetPName($80B9);
    public static property POST_COLOR_MATRIX_BLUE_BIAS:                                         GetPName read new GetPName($80BA);
    public static property POST_COLOR_MATRIX_ALPHA_BIAS:                                        GetPName read new GetPName($80BB);
    public static property TEXTURE_COLOR_TABLE:                                                 GetPName read new GetPName($80BC);
    public static property BLEND_DST_RGB:                                                       GetPName read new GetPName($80C8);
    public static property BLEND_SRC_RGB:                                                       GetPName read new GetPName($80C9);
    public static property BLEND_DST_ALPHA:                                                     GetPName read new GetPName($80CA);
    public static property BLEND_SRC_ALPHA:                                                     GetPName read new GetPName($80CB);
    public static property COLOR_TABLE:                                                         GetPName read new GetPName($80D0);
    public static property POST_CONVOLUTION_COLOR_TABLE:                                        GetPName read new GetPName($80D1);
    public static property POST_COLOR_MATRIX_COLOR_TABLE:                                       GetPName read new GetPName($80D2);
    public static property MAX_ELEMENTS_VERTICES:                                               GetPName read new GetPName($80E8);
    public static property MAX_ELEMENTS_INDICES:                                                GetPName read new GetPName($80E9);
    public static property POINT_SIZE_MIN:                                                      GetPName read new GetPName($8126);
    public static property POINT_SIZE_MAX:                                                      GetPName read new GetPName($8127);
    public static property POINT_FADE_THRESHOLD_SIZE:                                           GetPName read new GetPName($8128);
    public static property DISTANCE_ATTENUATION:                                                GetPName read new GetPName($8129);
    public static property POINT_DISTANCE_ATTENUATION:                                          GetPName read new GetPName($8129);
    public static property FOG_FUNC_POINTS:                                                     GetPName read new GetPName($812B);
    public static property MAX_FOG_FUNC_POINTS:                                                 GetPName read new GetPName($812C);
    public static property PACK_SKIP_VOLUMES:                                                   GetPName read new GetPName($8130);
    public static property PACK_IMAGE_DEPTH:                                                    GetPName read new GetPName($8131);
    public static property UNPACK_SKIP_VOLUMES:                                                 GetPName read new GetPName($8132);
    public static property UNPACK_IMAGE_DEPTH:                                                  GetPName read new GetPName($8133);
    public static property TEXTURE_4D:                                                          GetPName read new GetPName($8134);
    public static property MAX_4D_TEXTURE_SIZE:                                                 GetPName read new GetPName($8138);
    public static property PIXEL_TEX_GEN:                                                       GetPName read new GetPName($8139);
    public static property PIXEL_TILE_BEST_ALIGNMENT:                                           GetPName read new GetPName($813E);
    public static property PIXEL_TILE_CACHE_INCREMENT:                                          GetPName read new GetPName($813F);
    public static property PIXEL_TILE_WIDTH:                                                    GetPName read new GetPName($8140);
    public static property PIXEL_TILE_HEIGHT:                                                   GetPName read new GetPName($8141);
    public static property PIXEL_TILE_GRID_WIDTH:                                               GetPName read new GetPName($8142);
    public static property PIXEL_TILE_GRID_HEIGHT:                                              GetPName read new GetPName($8143);
    public static property PIXEL_TILE_GRID_DEPTH:                                               GetPName read new GetPName($8144);
    public static property PIXEL_TILE_CACHE_SIZE:                                               GetPName read new GetPName($8145);
    public static property SPRITE:                                                              GetPName read new GetPName($8148);
    public static property SPRITE_MODE:                                                         GetPName read new GetPName($8149);
    public static property SPRITE_AXIS:                                                         GetPName read new GetPName($814A);
    public static property SPRITE_TRANSLATION:                                                  GetPName read new GetPName($814B);
    public static property TEXTURE_4D_BINDING:                                                  GetPName read new GetPName($814F);
    public static property MAX_CLIPMAP_DEPTH:                                                   GetPName read new GetPName($8177);
    public static property MAX_CLIPMAP_VIRTUAL_DEPTH:                                           GetPName read new GetPName($8178);
    public static property POST_TEXTURE_FILTER_BIAS_RANGE:                                      GetPName read new GetPName($817B);
    public static property POST_TEXTURE_FILTER_SCALE_RANGE:                                     GetPName read new GetPName($817C);
    public static property REFERENCE_PLANE:                                                     GetPName read new GetPName($817D);
    public static property REFERENCE_PLANE_EQUATION:                                            GetPName read new GetPName($817E);
    public static property IR_INSTRUMENT1:                                                      GetPName read new GetPName($817F);
    public static property INSTRUMENT_MEASUREMENTS:                                             GetPName read new GetPName($8181);
    public static property CALLIGRAPHIC_FRAGMENT:                                               GetPName read new GetPName($8183);
    public static property FRAMEZOOM:                                                           GetPName read new GetPName($818B);
    public static property FRAMEZOOM_FACTOR:                                                    GetPName read new GetPName($818C);
    public static property MAX_FRAMEZOOM_FACTOR:                                                GetPName read new GetPName($818D);
    public static property GENERATE_MIPMAP_HINT:                                                GetPName read new GetPName($8192);
    public static property DEFORMATIONS_MASK:                                                   GetPName read new GetPName($8196);
    public static property FOG_OFFSET:                                                          GetPName read new GetPName($8198);
    public static property FOG_OFFSET_VALUE:                                                    GetPName read new GetPName($8199);
    public static property LIGHT_MODEL_COLOR_CONTROL:                                           GetPName read new GetPName($81F8);
    public static property SHARED_TEXTURE_PALETTE:                                              GetPName read new GetPName($81FB);
    public static property MAJOR_VERSION:                                                       GetPName read new GetPName($821B);
    public static property MINOR_VERSION:                                                       GetPName read new GetPName($821C);
    public static property NUM_EXTENSIONS:                                                      GetPName read new GetPName($821D);
    public static property CONTEXT_FLAGS:                                                       GetPName read new GetPName($821E);
    public static property PROGRAM_PIPELINE_BINDING:                                            GetPName read new GetPName($825A);
    public static property MAX_VIEWPORTS:                                                       GetPName read new GetPName($825B);
    public static property VIEWPORT_SUBPIXEL_BITS:                                              GetPName read new GetPName($825C);
    public static property VIEWPORT_BOUNDS_RANGE:                                               GetPName read new GetPName($825D);
    public static property LAYER_PROVOKING_VERTEX:                                              GetPName read new GetPName($825E);
    public static property VIEWPORT_INDEX_PROVOKING_VERTEX:                                     GetPName read new GetPName($825F);
    public static property MAX_COMPUTE_UNIFORM_COMPONENTS:                                      GetPName read new GetPName($8263);
    public static property MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS:                                  GetPName read new GetPName($8264);
    public static property MAX_COMPUTE_ATOMIC_COUNTERS:                                         GetPName read new GetPName($8265);
    public static property MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS:                             GetPName read new GetPName($8266);
    public static property MAX_DEBUG_GROUP_STACK_DEPTH:                                         GetPName read new GetPName($826C);
    public static property DEBUG_GROUP_STACK_DEPTH:                                             GetPName read new GetPName($826D);
    public static property MAX_UNIFORM_LOCATIONS:                                               GetPName read new GetPName($826E);
    public static property VERTEX_BINDING_DIVISOR:                                              GetPName read new GetPName($82D6);
    public static property VERTEX_BINDING_OFFSET:                                               GetPName read new GetPName($82D7);
    public static property VERTEX_BINDING_STRIDE:                                               GetPName read new GetPName($82D8);
    public static property MAX_VERTEX_ATTRIB_RELATIVE_OFFSET:                                   GetPName read new GetPName($82D9);
    public static property MAX_VERTEX_ATTRIB_BINDINGS:                                          GetPName read new GetPName($82DA);
    public static property MAX_LABEL_LENGTH:                                                    GetPName read new GetPName($82E8);
    public static property CONVOLUTION_HINT:                                                    GetPName read new GetPName($8316);
    public static property ASYNC_MARKER:                                                        GetPName read new GetPName($8329);
    public static property PIXEL_TEX_GEN_MODE:                                                  GetPName read new GetPName($832B);
    public static property ASYNC_HISTOGRAM:                                                     GetPName read new GetPName($832C);
    public static property MAX_ASYNC_HISTOGRAM:                                                 GetPName read new GetPName($832D);
    public static property PIXEL_TEXTURE:                                                       GetPName read new GetPName($8353);
    public static property ASYNC_TEX_IMAGE:                                                     GetPName read new GetPName($835C);
    public static property ASYNC_DRAW_PIXELS:                                                   GetPName read new GetPName($835D);
    public static property ASYNC_READ_PIXELS:                                                   GetPName read new GetPName($835E);
    public static property MAX_ASYNC_TEX_IMAGE:                                                 GetPName read new GetPName($835F);
    public static property MAX_ASYNC_DRAW_PIXELS:                                               GetPName read new GetPName($8360);
    public static property MAX_ASYNC_READ_PIXELS:                                               GetPName read new GetPName($8361);
    public static property VERTEX_PRECLIP:                                                      GetPName read new GetPName($83EE);
    public static property VERTEX_PRECLIP_HINT:                                                 GetPName read new GetPName($83EF);
    public static property FRAGMENT_LIGHTING:                                                   GetPName read new GetPName($8400);
    public static property FRAGMENT_COLOR_MATERIAL:                                             GetPName read new GetPName($8401);
    public static property FRAGMENT_COLOR_MATERIAL_FACE:                                        GetPName read new GetPName($8402);
    public static property FRAGMENT_COLOR_MATERIAL_PARAMETER:                                   GetPName read new GetPName($8403);
    public static property MAX_FRAGMENT_LIGHTS:                                                 GetPName read new GetPName($8404);
    public static property MAX_ACTIVE_LIGHTS:                                                   GetPName read new GetPName($8405);
    public static property LIGHT_ENV_MODE:                                                      GetPName read new GetPName($8407);
    public static property FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER:                                   GetPName read new GetPName($8408);
    public static property FRAGMENT_LIGHT_MODEL_TWO_SIDE:                                       GetPName read new GetPName($8409);
    public static property FRAGMENT_LIGHT_MODEL_AMBIENT:                                        GetPName read new GetPName($840A);
    public static property FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION:                           GetPName read new GetPName($840B);
    public static property FRAGMENT_LIGHT0:                                                     GetPName read new GetPName($840C);
    public static property PACK_RESAMPLE_SGIX:                                                  GetPName read new GetPName($842E);
    public static property UNPACK_RESAMPLE_SGIX:                                                GetPName read new GetPName($842F);
    public static property ALIASED_POINT_SIZE_RANGE:                                            GetPName read new GetPName($846D);
    public static property ALIASED_LINE_WIDTH_RANGE:                                            GetPName read new GetPName($846E);
    public static property ACTIVE_TEXTURE:                                                      GetPName read new GetPName($84E0);
    public static property MAX_RENDERBUFFER_SIZE:                                               GetPName read new GetPName($84E8);
    public static property TEXTURE_COMPRESSION_HINT:                                            GetPName read new GetPName($84EF);
    public static property TEXTURE_BINDING_RECTANGLE:                                           GetPName read new GetPName($84F6);
    public static property MAX_RECTANGLE_TEXTURE_SIZE:                                          GetPName read new GetPName($84F8);
    public static property MAX_TEXTURE_LOD_BIAS:                                                GetPName read new GetPName($84FD);
    public static property TEXTURE_BINDING_CUBE_MAP:                                            GetPName read new GetPName($8514);
    public static property MAX_CUBE_MAP_TEXTURE_SIZE:                                           GetPName read new GetPName($851C);
    public static property PACK_SUBSAMPLE_RATE:                                                 GetPName read new GetPName($85A0);
    public static property UNPACK_SUBSAMPLE_RATE:                                               GetPName read new GetPName($85A1);
    public static property VERTEX_ARRAY_BINDING:                                                GetPName read new GetPName($85B5);
    public static property PROGRAM_POINT_SIZE:                                                  GetPName read new GetPName($8642);
    public static property NUM_COMPRESSED_TEXTURE_FORMATS:                                      GetPName read new GetPName($86A2);
    public static property COMPRESSED_TEXTURE_FORMATS:                                          GetPName read new GetPName($86A3);
    public static property NUM_PROGRAM_BINARY_FORMATS:                                          GetPName read new GetPName($87FE);
    public static property PROGRAM_BINARY_FORMATS:                                              GetPName read new GetPName($87FF);
    public static property STENCIL_BACK_FUNC:                                                   GetPName read new GetPName($8800);
    public static property STENCIL_BACK_FAIL:                                                   GetPName read new GetPName($8801);
    public static property STENCIL_BACK_PASS_DEPTH_FAIL:                                        GetPName read new GetPName($8802);
    public static property STENCIL_BACK_PASS_DEPTH_PASS:                                        GetPName read new GetPName($8803);
    public static property MAX_DRAW_BUFFERS:                                                    GetPName read new GetPName($8824);
    public static property BLEND_EQUATION_ALPHA:                                                GetPName read new GetPName($883D);
    public static property MAX_VERTEX_ATTRIBS:                                                  GetPName read new GetPName($8869);
    public static property MAX_TEXTURE_IMAGE_UNITS:                                             GetPName read new GetPName($8872);
    public static property ARRAY_BUFFER_BINDING:                                                GetPName read new GetPName($8894);
    public static property ELEMENT_ARRAY_BUFFER_BINDING:                                        GetPName read new GetPName($8895);
    public static property PIXEL_PACK_BUFFER_BINDING:                                           GetPName read new GetPName($88ED);
    public static property PIXEL_UNPACK_BUFFER_BINDING:                                         GetPName read new GetPName($88EF);
    public static property MAX_DUAL_SOURCE_DRAW_BUFFERS:                                        GetPName read new GetPName($88FC);
    public static property MAX_ARRAY_TEXTURE_LAYERS:                                            GetPName read new GetPName($88FF);
    public static property MIN_PROGRAM_TEXEL_OFFSET:                                            GetPName read new GetPName($8904);
    public static property MAX_PROGRAM_TEXEL_OFFSET:                                            GetPName read new GetPName($8905);
    public static property SAMPLER_BINDING:                                                     GetPName read new GetPName($8919);
    public static property FRAGMENT_SHADER_ATI:                                                 GetPName read new GetPName($8920);
    public static property UNIFORM_BUFFER_BINDING:                                              GetPName read new GetPName($8A28);
    public static property UNIFORM_BUFFER_START:                                                GetPName read new GetPName($8A29);
    public static property UNIFORM_BUFFER_SIZE:                                                 GetPName read new GetPName($8A2A);
    public static property MAX_VERTEX_UNIFORM_BLOCKS:                                           GetPName read new GetPName($8A2B);
    public static property MAX_GEOMETRY_UNIFORM_BLOCKS:                                         GetPName read new GetPName($8A2C);
    public static property MAX_FRAGMENT_UNIFORM_BLOCKS:                                         GetPName read new GetPName($8A2D);
    public static property MAX_COMBINED_UNIFORM_BLOCKS:                                         GetPName read new GetPName($8A2E);
    public static property MAX_UNIFORM_BUFFER_BINDINGS:                                         GetPName read new GetPName($8A2F);
    public static property MAX_UNIFORM_BLOCK_SIZE:                                              GetPName read new GetPName($8A30);
    public static property MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:                              GetPName read new GetPName($8A31);
    public static property MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS:                            GetPName read new GetPName($8A32);
    public static property MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:                            GetPName read new GetPName($8A33);
    public static property UNIFORM_BUFFER_OFFSET_ALIGNMENT:                                     GetPName read new GetPName($8A34);
    public static property MAX_FRAGMENT_UNIFORM_COMPONENTS:                                     GetPName read new GetPName($8B49);
    public static property MAX_VERTEX_UNIFORM_COMPONENTS:                                       GetPName read new GetPName($8B4A);
    public static property MAX_VARYING_FLOATS:                                                  GetPName read new GetPName($8B4B);
    public static property MAX_VARYING_COMPONENTS:                                              GetPName read new GetPName($8B4B);
    public static property MAX_VERTEX_TEXTURE_IMAGE_UNITS:                                      GetPName read new GetPName($8B4C);
    public static property MAX_COMBINED_TEXTURE_IMAGE_UNITS:                                    GetPName read new GetPName($8B4D);
    public static property FRAGMENT_SHADER_DERIVATIVE_HINT:                                     GetPName read new GetPName($8B8B);
    public static property CURRENT_PROGRAM:                                                     GetPName read new GetPName($8B8D);
    public static property IMPLEMENTATION_COLOR_READ_TYPE:                                      GetPName read new GetPName($8B9A);
    public static property IMPLEMENTATION_COLOR_READ_FORMAT:                                    GetPName read new GetPName($8B9B);
    public static property TEXTURE_BINDING_1D_ARRAY:                                            GetPName read new GetPName($8C1C);
    public static property TEXTURE_BINDING_2D_ARRAY:                                            GetPName read new GetPName($8C1D);
    public static property MAX_GEOMETRY_TEXTURE_IMAGE_UNITS:                                    GetPName read new GetPName($8C29);
    public static property MAX_TEXTURE_BUFFER_SIZE:                                             GetPName read new GetPName($8C2B);
    public static property TEXTURE_BINDING_BUFFER:                                              GetPName read new GetPName($8C2C);
    public static property TRANSFORM_FEEDBACK_BUFFER_START:                                     GetPName read new GetPName($8C84);
    public static property TRANSFORM_FEEDBACK_BUFFER_SIZE:                                      GetPName read new GetPName($8C85);
    public static property TRANSFORM_FEEDBACK_BUFFER_BINDING:                                   GetPName read new GetPName($8C8F);
    public static property MOTION_ESTIMATION_SEARCH_BLOCK_X:                                    GetPName read new GetPName($8C90);
    public static property MOTION_ESTIMATION_SEARCH_BLOCK_Y:                                    GetPName read new GetPName($8C91);
    public static property STENCIL_BACK_REF:                                                    GetPName read new GetPName($8CA3);
    public static property STENCIL_BACK_VALUE_MASK:                                             GetPName read new GetPName($8CA4);
    public static property STENCIL_BACK_WRITEMASK:                                              GetPName read new GetPName($8CA5);
    public static property DRAW_FRAMEBUFFER_BINDING:                                            GetPName read new GetPName($8CA6);
    public static property RENDERBUFFER_BINDING:                                                GetPName read new GetPName($8CA7);
    public static property READ_FRAMEBUFFER_BINDING:                                            GetPName read new GetPName($8CAA);
    public static property MAX_COLOR_ATTACHMENTS:                                               GetPName read new GetPName($8CDF);
    public static property TEXTURE_GEN_STR:                                                     GetPName read new GetPName($8D60);
    public static property MAX_ELEMENT_INDEX:                                                   GetPName read new GetPName($8D6B);
    public static property MAX_GEOMETRY_UNIFORM_COMPONENTS:                                     GetPName read new GetPName($8DDF);
    public static property SHADER_BINARY_FORMATS:                                               GetPName read new GetPName($8DF8);
    public static property NUM_SHADER_BINARY_FORMATS:                                           GetPName read new GetPName($8DF9);
    public static property SHADER_COMPILER:                                                     GetPName read new GetPName($8DFA);
    public static property MAX_VERTEX_UNIFORM_VECTORS:                                          GetPName read new GetPName($8DFB);
    public static property MAX_VARYING_VECTORS:                                                 GetPName read new GetPName($8DFC);
    public static property MAX_FRAGMENT_UNIFORM_VECTORS:                                        GetPName read new GetPName($8DFD);
    public static property TIMESTAMP:                                                           GetPName read new GetPName($8E28);
    public static property PROVOKING_VERTEX:                                                    GetPName read new GetPName($8E4F);
    public static property MAX_SAMPLE_MASK_WORDS:                                               GetPName read new GetPName($8E59);
    public static property MAX_TESS_CONTROL_UNIFORM_BLOCKS:                                     GetPName read new GetPName($8E89);
    public static property MAX_TESS_EVALUATION_UNIFORM_BLOCKS:                                  GetPName read new GetPName($8E8A);
    public static property FETCH_PER_SAMPLE_ARM:                                                GetPName read new GetPName($8F65);
    public static property FRAGMENT_SHADER_FRAMEBUFFER_FETCH_MRT_ARM:                           GetPName read new GetPName($8F66);
    public static property FRAGMENT_SHADING_RATE_NON_TRIVIAL_COMBINERS_SUPPORTED:               GetPName read new GetPName($8F6F);
    public static property PRIMITIVE_RESTART_INDEX:                                             GetPName read new GetPName($8F9E);
    public static property MIN_MAP_BUFFER_ALIGNMENT:                                            GetPName read new GetPName($90BC);
    public static property SHADER_STORAGE_BUFFER_BINDING:                                       GetPName read new GetPName($90D3);
    public static property SHADER_STORAGE_BUFFER_START:                                         GetPName read new GetPName($90D4);
    public static property SHADER_STORAGE_BUFFER_SIZE:                                          GetPName read new GetPName($90D5);
    public static property MAX_VERTEX_SHADER_STORAGE_BLOCKS:                                    GetPName read new GetPName($90D6);
    public static property MAX_GEOMETRY_SHADER_STORAGE_BLOCKS:                                  GetPName read new GetPName($90D7);
    public static property MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS:                              GetPName read new GetPName($90D8);
    public static property MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS:                           GetPName read new GetPName($90D9);
    public static property MAX_FRAGMENT_SHADER_STORAGE_BLOCKS:                                  GetPName read new GetPName($90DA);
    public static property MAX_COMPUTE_SHADER_STORAGE_BLOCKS:                                   GetPName read new GetPName($90DB);
    public static property MAX_COMBINED_SHADER_STORAGE_BLOCKS:                                  GetPName read new GetPName($90DC);
    public static property MAX_SHADER_STORAGE_BUFFER_BINDINGS:                                  GetPName read new GetPName($90DD);
    public static property SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT:                              GetPName read new GetPName($90DF);
    public static property MAX_COMPUTE_WORK_GROUP_INVOCATIONS:                                  GetPName read new GetPName($90EB);
    public static property DISPATCH_INDIRECT_BUFFER_BINDING:                                    GetPName read new GetPName($90EF);
    public static property TEXTURE_BINDING_2D_MULTISAMPLE:                                      GetPName read new GetPName($9104);
    public static property TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY:                                GetPName read new GetPName($9105);
    public static property MAX_COLOR_TEXTURE_SAMPLES:                                           GetPName read new GetPName($910E);
    public static property MAX_DEPTH_TEXTURE_SAMPLES:                                           GetPName read new GetPName($910F);
    public static property MAX_INTEGER_SAMPLES:                                                 GetPName read new GetPName($9110);
    public static property MAX_SERVER_WAIT_TIMEOUT:                                             GetPName read new GetPName($9111);
    public static property MAX_VERTEX_OUTPUT_COMPONENTS:                                        GetPName read new GetPName($9122);
    public static property MAX_GEOMETRY_INPUT_COMPONENTS:                                       GetPName read new GetPName($9123);
    public static property MAX_GEOMETRY_OUTPUT_COMPONENTS:                                      GetPName read new GetPName($9124);
    public static property MAX_FRAGMENT_INPUT_COMPONENTS:                                       GetPName read new GetPName($9125);
    public static property CONTEXT_PROFILE_MASK:                                                GetPName read new GetPName($9126);
    public static property TEXTURE_BUFFER_OFFSET_ALIGNMENT:                                     GetPName read new GetPName($919F);
    public static property MAX_COMPUTE_UNIFORM_BLOCKS:                                          GetPName read new GetPName($91BB);
    public static property MAX_COMPUTE_TEXTURE_IMAGE_UNITS:                                     GetPName read new GetPName($91BC);
    public static property MAX_COMPUTE_WORK_GROUP_COUNT:                                        GetPName read new GetPName($91BE);
    public static property MAX_COMPUTE_WORK_GROUP_SIZE:                                         GetPName read new GetPName($91BF);
    public static property MAX_VERTEX_ATOMIC_COUNTERS:                                          GetPName read new GetPName($92D2);
    public static property MAX_TESS_CONTROL_ATOMIC_COUNTERS:                                    GetPName read new GetPName($92D3);
    public static property MAX_TESS_EVALUATION_ATOMIC_COUNTERS:                                 GetPName read new GetPName($92D4);
    public static property MAX_GEOMETRY_ATOMIC_COUNTERS:                                        GetPName read new GetPName($92D5);
    public static property MAX_FRAGMENT_ATOMIC_COUNTERS:                                        GetPName read new GetPName($92D6);
    public static property MAX_COMBINED_ATOMIC_COUNTERS:                                        GetPName read new GetPName($92D7);
    public static property MAX_FRAMEBUFFER_WIDTH:                                               GetPName read new GetPName($9315);
    public static property MAX_FRAMEBUFFER_HEIGHT:                                              GetPName read new GetPName($9316);
    public static property MAX_FRAMEBUFFER_LAYERS:                                              GetPName read new GetPName($9317);
    public static property MAX_FRAMEBUFFER_SAMPLES:                                             GetPName read new GetPName($9318);
    public static property NUM_DEVICE_UUIDS:                                                    GetPName read new GetPName($9596);
    public static property DEVICE_UUID:                                                         GetPName read new GetPName($9597);
    public static property DRIVER_UUID:                                                         GetPName read new GetPName($9598);
    public static property DEVICE_LUID:                                                         GetPName read new GetPName($9599);
    public static property DEVICE_NODE_MASK:                                                    GetPName read new GetPName($959A);
    public static property SHADING_RATE_IMAGE_PER_PRIMITIVE:                                    GetPName read new GetPName($95B1);
    public static property SHADING_RATE_IMAGE_PALETTE_COUNT:                                    GetPName read new GetPName($95B2);
    public static property MAX_TIMELINE_SEMAPHORE_VALUE_DIFFERENCE:                             GetPName read new GetPName($95B6);
    public static property FRAMEBUFFER_FETCH_NONCOHERENT:                                       GetPName read new GetPName($96A2);
    public static property SHADING_RATE_QCOM:                                                   GetPName read new GetPName($96A4);
    public static property SHADING_RATE_EXT:                                                    GetPName read new GetPName($96D0);
    public static property MIN_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_WIDTH:                    GetPName read new GetPName($96D7);
    public static property MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_WIDTH:                    GetPName read new GetPName($96D8);
    public static property MIN_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_HEIGHT:                   GetPName read new GetPName($96D9);
    public static property MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_HEIGHT:                   GetPName read new GetPName($96DA);
    public static property MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_ASPECT_RATIO:             GetPName read new GetPName($96DB);
    public static property MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_LAYERS:                         GetPName read new GetPName($96DC);
    public static property FRAGMENT_SHADING_RATE_WITH_SHADER_DEPTH_STENCIL_WRITES_SUPPORTED:    GetPName read new GetPName($96DD);
    public static property FRAGMENT_SHADING_RATE_WITH_SAMPLE_MASK_SUPPORTED:                    GetPName read new GetPName($96DE);
    public static property FRAGMENT_SHADING_RATE_ATTACHMENT_WITH_DEFAULT_FRAMEBUFFER_SUPPORTED: GetPName read new GetPName($96DF);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0B00) then Result := 'CURRENT_COLOR' else
      if self.val = UInt32($0B01) then Result := 'CURRENT_INDEX' else
      if self.val = UInt32($0B02) then Result := 'CURRENT_NORMAL' else
      if self.val = UInt32($0B03) then Result := 'CURRENT_TEXTURE_COORDS' else
      if self.val = UInt32($0B04) then Result := 'CURRENT_RASTER_COLOR' else
      if self.val = UInt32($0B05) then Result := 'CURRENT_RASTER_INDEX' else
      if self.val = UInt32($0B06) then Result := 'CURRENT_RASTER_TEXTURE_COORDS' else
      if self.val = UInt32($0B07) then Result := 'CURRENT_RASTER_POSITION' else
      if self.val = UInt32($0B08) then Result := 'CURRENT_RASTER_POSITION_VALID' else
      if self.val = UInt32($0B09) then Result := 'CURRENT_RASTER_DISTANCE' else
      if self.val = UInt32($0B10) then Result := 'POINT_SMOOTH' else
      if self.val = UInt32($0B11) then Result := 'POINT_SIZE' else
      if self.val = UInt32($0B12) then Result := 'POINT_SIZE_RANGE' else
      if self.val = UInt32($0B12) then Result := 'SMOOTH_POINT_SIZE_RANGE' else
      if self.val = UInt32($0B13) then Result := 'POINT_SIZE_GRANULARITY' else
      if self.val = UInt32($0B13) then Result := 'SMOOTH_POINT_SIZE_GRANULARITY' else
      if self.val = UInt32($0B20) then Result := 'LINE_SMOOTH' else
      if self.val = UInt32($0B21) then Result := 'LINE_WIDTH' else
      if self.val = UInt32($0B22) then Result := 'LINE_WIDTH_RANGE' else
      if self.val = UInt32($0B22) then Result := 'SMOOTH_LINE_WIDTH_RANGE' else
      if self.val = UInt32($0B23) then Result := 'LINE_WIDTH_GRANULARITY' else
      if self.val = UInt32($0B23) then Result := 'SMOOTH_LINE_WIDTH_GRANULARITY' else
      if self.val = UInt32($0B24) then Result := 'LINE_STIPPLE' else
      if self.val = UInt32($0B25) then Result := 'LINE_STIPPLE_PATTERN' else
      if self.val = UInt32($0B26) then Result := 'LINE_STIPPLE_REPEAT' else
      if self.val = UInt32($0B30) then Result := 'LIST_MODE' else
      if self.val = UInt32($0B31) then Result := 'MAX_LIST_NESTING' else
      if self.val = UInt32($0B32) then Result := 'LIST_BASE' else
      if self.val = UInt32($0B33) then Result := 'LIST_INDEX' else
      if self.val = UInt32($0B40) then Result := 'POLYGON_MODE' else
      if self.val = UInt32($0B41) then Result := 'POLYGON_SMOOTH' else
      if self.val = UInt32($0B42) then Result := 'POLYGON_STIPPLE' else
      if self.val = UInt32($0B43) then Result := 'EDGE_FLAG' else
      if self.val = UInt32($0B44) then Result := 'CULL_FACE' else
      if self.val = UInt32($0B45) then Result := 'CULL_FACE_MODE' else
      if self.val = UInt32($0B46) then Result := 'FRONT_FACE' else
      if self.val = UInt32($0B50) then Result := 'LIGHTING' else
      if self.val = UInt32($0B51) then Result := 'LIGHT_MODEL_LOCAL_VIEWER' else
      if self.val = UInt32($0B52) then Result := 'LIGHT_MODEL_TWO_SIDE' else
      if self.val = UInt32($0B53) then Result := 'LIGHT_MODEL_AMBIENT' else
      if self.val = UInt32($0B54) then Result := 'SHADE_MODEL' else
      if self.val = UInt32($0B55) then Result := 'COLOR_MATERIAL_FACE' else
      if self.val = UInt32($0B56) then Result := 'COLOR_MATERIAL_PARAMETER' else
      if self.val = UInt32($0B57) then Result := 'COLOR_MATERIAL' else
      if self.val = UInt32($0B60) then Result := 'FOG' else
      if self.val = UInt32($0B61) then Result := 'FOG_INDEX' else
      if self.val = UInt32($0B62) then Result := 'FOG_DENSITY' else
      if self.val = UInt32($0B63) then Result := 'FOG_START' else
      if self.val = UInt32($0B64) then Result := 'FOG_END' else
      if self.val = UInt32($0B65) then Result := 'FOG_MODE' else
      if self.val = UInt32($0B66) then Result := 'FOG_COLOR' else
      if self.val = UInt32($0B70) then Result := 'DEPTH_RANGE' else
      if self.val = UInt32($0B71) then Result := 'DEPTH_TEST' else
      if self.val = UInt32($0B72) then Result := 'DEPTH_WRITEMASK' else
      if self.val = UInt32($0B73) then Result := 'DEPTH_CLEAR_VALUE' else
      if self.val = UInt32($0B74) then Result := 'DEPTH_FUNC' else
      if self.val = UInt32($0B80) then Result := 'ACCUM_CLEAR_VALUE' else
      if self.val = UInt32($0B90) then Result := 'STENCIL_TEST' else
      if self.val = UInt32($0B91) then Result := 'STENCIL_CLEAR_VALUE' else
      if self.val = UInt32($0B92) then Result := 'STENCIL_FUNC' else
      if self.val = UInt32($0B93) then Result := 'STENCIL_VALUE_MASK' else
      if self.val = UInt32($0B94) then Result := 'STENCIL_FAIL' else
      if self.val = UInt32($0B95) then Result := 'STENCIL_PASS_DEPTH_FAIL' else
      if self.val = UInt32($0B96) then Result := 'STENCIL_PASS_DEPTH_PASS' else
      if self.val = UInt32($0B97) then Result := 'STENCIL_REF' else
      if self.val = UInt32($0B98) then Result := 'STENCIL_WRITEMASK' else
      if self.val = UInt32($0BA0) then Result := 'MATRIX_MODE' else
      if self.val = UInt32($0BA1) then Result := 'NORMALIZE' else
      if self.val = UInt32($0BA2) then Result := 'VIEWPORT' else
      if self.val = UInt32($0BA3) then Result := 'MODELVIEW_STACK_DEPTH' else
      if self.val = UInt32($0BA3) then Result := 'MODELVIEW0_STACK_DEPTH' else
      if self.val = UInt32($0BA4) then Result := 'PROJECTION_STACK_DEPTH' else
      if self.val = UInt32($0BA5) then Result := 'TEXTURE_STACK_DEPTH' else
      if self.val = UInt32($0BA6) then Result := 'MODELVIEW0_MATRIX' else
      if self.val = UInt32($0BA6) then Result := 'MODELVIEW_MATRIX' else
      if self.val = UInt32($0BA7) then Result := 'PROJECTION_MATRIX' else
      if self.val = UInt32($0BA8) then Result := 'TEXTURE_MATRIX' else
      if self.val = UInt32($0BB0) then Result := 'ATTRIB_STACK_DEPTH' else
      if self.val = UInt32($0BB1) then Result := 'CLIENT_ATTRIB_STACK_DEPTH' else
      if self.val = UInt32($0BC0) then Result := 'ALPHA_TEST' else
      if self.val = UInt32($0BC1) then Result := 'ALPHA_TEST_FUNC' else
      if self.val = UInt32($0BC2) then Result := 'ALPHA_TEST_REF' else
      if self.val = UInt32($0BD0) then Result := 'DITHER' else
      if self.val = UInt32($0BE0) then Result := 'BLEND_DST' else
      if self.val = UInt32($0BE1) then Result := 'BLEND_SRC' else
      if self.val = UInt32($0BE2) then Result := 'BLEND' else
      if self.val = UInt32($0BF0) then Result := 'LOGIC_OP_MODE' else
      if self.val = UInt32($0BF1) then Result := 'INDEX_LOGIC_OP' else
      if self.val = UInt32($0BF1) then Result := 'LOGIC_OP' else
      if self.val = UInt32($0BF2) then Result := 'COLOR_LOGIC_OP' else
      if self.val = UInt32($0C00) then Result := 'AUX_BUFFERS' else
      if self.val = UInt32($0C01) then Result := 'DRAW_BUFFER' else
      if self.val = UInt32($0C02) then Result := 'READ_BUFFER' else
      if self.val = UInt32($0C10) then Result := 'SCISSOR_BOX' else
      if self.val = UInt32($0C11) then Result := 'SCISSOR_TEST' else
      if self.val = UInt32($0C20) then Result := 'INDEX_CLEAR_VALUE' else
      if self.val = UInt32($0C21) then Result := 'INDEX_WRITEMASK' else
      if self.val = UInt32($0C22) then Result := 'COLOR_CLEAR_VALUE' else
      if self.val = UInt32($0C23) then Result := 'COLOR_WRITEMASK' else
      if self.val = UInt32($0C30) then Result := 'INDEX_MODE' else
      if self.val = UInt32($0C31) then Result := 'RGBA_MODE' else
      if self.val = UInt32($0C32) then Result := 'DOUBLEBUFFER' else
      if self.val = UInt32($0C33) then Result := 'STEREO' else
      if self.val = UInt32($0C40) then Result := 'RENDER_MODE' else
      if self.val = UInt32($0C50) then Result := 'PERSPECTIVE_CORRECTION_HINT' else
      if self.val = UInt32($0C51) then Result := 'POINT_SMOOTH_HINT' else
      if self.val = UInt32($0C52) then Result := 'LINE_SMOOTH_HINT' else
      if self.val = UInt32($0C53) then Result := 'POLYGON_SMOOTH_HINT' else
      if self.val = UInt32($0C54) then Result := 'FOG_HINT' else
      if self.val = UInt32($0C60) then Result := 'TEXTURE_GEN_S' else
      if self.val = UInt32($0C61) then Result := 'TEXTURE_GEN_T' else
      if self.val = UInt32($0C62) then Result := 'TEXTURE_GEN_R' else
      if self.val = UInt32($0C63) then Result := 'TEXTURE_GEN_Q' else
      if self.val = UInt32($0CB0) then Result := 'PIXEL_MAP_I_TO_I_SIZE' else
      if self.val = UInt32($0CB1) then Result := 'PIXEL_MAP_S_TO_S_SIZE' else
      if self.val = UInt32($0CB2) then Result := 'PIXEL_MAP_I_TO_R_SIZE' else
      if self.val = UInt32($0CB3) then Result := 'PIXEL_MAP_I_TO_G_SIZE' else
      if self.val = UInt32($0CB4) then Result := 'PIXEL_MAP_I_TO_B_SIZE' else
      if self.val = UInt32($0CB5) then Result := 'PIXEL_MAP_I_TO_A_SIZE' else
      if self.val = UInt32($0CB6) then Result := 'PIXEL_MAP_R_TO_R_SIZE' else
      if self.val = UInt32($0CB7) then Result := 'PIXEL_MAP_G_TO_G_SIZE' else
      if self.val = UInt32($0CB8) then Result := 'PIXEL_MAP_B_TO_B_SIZE' else
      if self.val = UInt32($0CB9) then Result := 'PIXEL_MAP_A_TO_A_SIZE' else
      if self.val = UInt32($0CF0) then Result := 'UNPACK_SWAP_BYTES' else
      if self.val = UInt32($0CF1) then Result := 'UNPACK_LSB_FIRST' else
      if self.val = UInt32($0CF2) then Result := 'UNPACK_ROW_LENGTH' else
      if self.val = UInt32($0CF3) then Result := 'UNPACK_SKIP_ROWS' else
      if self.val = UInt32($0CF4) then Result := 'UNPACK_SKIP_PIXELS' else
      if self.val = UInt32($0CF5) then Result := 'UNPACK_ALIGNMENT' else
      if self.val = UInt32($0D00) then Result := 'PACK_SWAP_BYTES' else
      if self.val = UInt32($0D01) then Result := 'PACK_LSB_FIRST' else
      if self.val = UInt32($0D02) then Result := 'PACK_ROW_LENGTH' else
      if self.val = UInt32($0D03) then Result := 'PACK_SKIP_ROWS' else
      if self.val = UInt32($0D04) then Result := 'PACK_SKIP_PIXELS' else
      if self.val = UInt32($0D05) then Result := 'PACK_ALIGNMENT' else
      if self.val = UInt32($0D10) then Result := 'MAP_COLOR' else
      if self.val = UInt32($0D11) then Result := 'MAP_STENCIL' else
      if self.val = UInt32($0D12) then Result := 'INDEX_SHIFT' else
      if self.val = UInt32($0D13) then Result := 'INDEX_OFFSET' else
      if self.val = UInt32($0D14) then Result := 'RED_SCALE' else
      if self.val = UInt32($0D15) then Result := 'RED_BIAS' else
      if self.val = UInt32($0D16) then Result := 'ZOOM_X' else
      if self.val = UInt32($0D17) then Result := 'ZOOM_Y' else
      if self.val = UInt32($0D18) then Result := 'GREEN_SCALE' else
      if self.val = UInt32($0D19) then Result := 'GREEN_BIAS' else
      if self.val = UInt32($0D1A) then Result := 'BLUE_SCALE' else
      if self.val = UInt32($0D1B) then Result := 'BLUE_BIAS' else
      if self.val = UInt32($0D1C) then Result := 'ALPHA_SCALE' else
      if self.val = UInt32($0D1D) then Result := 'ALPHA_BIAS' else
      if self.val = UInt32($0D1E) then Result := 'DEPTH_SCALE' else
      if self.val = UInt32($0D1F) then Result := 'DEPTH_BIAS' else
      if self.val = UInt32($0D30) then Result := 'MAX_EVAL_ORDER' else
      if self.val = UInt32($0D31) then Result := 'MAX_LIGHTS' else
      if self.val = UInt32($0D32) then Result := 'MAX_CLIP_PLANES' else
      if self.val = UInt32($0D32) then Result := 'MAX_CLIP_DISTANCES' else
      if self.val = UInt32($0D33) then Result := 'MAX_TEXTURE_SIZE' else
      if self.val = UInt32($0D34) then Result := 'MAX_PIXEL_MAP_TABLE' else
      if self.val = UInt32($0D35) then Result := 'MAX_ATTRIB_STACK_DEPTH' else
      if self.val = UInt32($0D36) then Result := 'MAX_MODELVIEW_STACK_DEPTH' else
      if self.val = UInt32($0D37) then Result := 'MAX_NAME_STACK_DEPTH' else
      if self.val = UInt32($0D38) then Result := 'MAX_PROJECTION_STACK_DEPTH' else
      if self.val = UInt32($0D39) then Result := 'MAX_TEXTURE_STACK_DEPTH' else
      if self.val = UInt32($0D3A) then Result := 'MAX_VIEWPORT_DIMS' else
      if self.val = UInt32($0D3B) then Result := 'MAX_CLIENT_ATTRIB_STACK_DEPTH' else
      if self.val = UInt32($0D50) then Result := 'SUBPIXEL_BITS' else
      if self.val = UInt32($0D51) then Result := 'INDEX_BITS' else
      if self.val = UInt32($0D52) then Result := 'RED_BITS' else
      if self.val = UInt32($0D53) then Result := 'GREEN_BITS' else
      if self.val = UInt32($0D54) then Result := 'BLUE_BITS' else
      if self.val = UInt32($0D55) then Result := 'ALPHA_BITS' else
      if self.val = UInt32($0D56) then Result := 'DEPTH_BITS' else
      if self.val = UInt32($0D57) then Result := 'STENCIL_BITS' else
      if self.val = UInt32($0D58) then Result := 'ACCUM_RED_BITS' else
      if self.val = UInt32($0D59) then Result := 'ACCUM_GREEN_BITS' else
      if self.val = UInt32($0D5A) then Result := 'ACCUM_BLUE_BITS' else
      if self.val = UInt32($0D5B) then Result := 'ACCUM_ALPHA_BITS' else
      if self.val = UInt32($0D70) then Result := 'NAME_STACK_DEPTH' else
      if self.val = UInt32($0D80) then Result := 'AUTO_NORMAL' else
      if self.val = UInt32($0D90) then Result := 'MAP1_COLOR_4' else
      if self.val = UInt32($0D91) then Result := 'MAP1_INDEX' else
      if self.val = UInt32($0D92) then Result := 'MAP1_NORMAL' else
      if self.val = UInt32($0D93) then Result := 'MAP1_TEXTURE_COORD_1' else
      if self.val = UInt32($0D94) then Result := 'MAP1_TEXTURE_COORD_2' else
      if self.val = UInt32($0D95) then Result := 'MAP1_TEXTURE_COORD_3' else
      if self.val = UInt32($0D96) then Result := 'MAP1_TEXTURE_COORD_4' else
      if self.val = UInt32($0D97) then Result := 'MAP1_VERTEX_3' else
      if self.val = UInt32($0D98) then Result := 'MAP1_VERTEX_4' else
      if self.val = UInt32($0DB0) then Result := 'MAP2_COLOR_4' else
      if self.val = UInt32($0DB1) then Result := 'MAP2_INDEX' else
      if self.val = UInt32($0DB2) then Result := 'MAP2_NORMAL' else
      if self.val = UInt32($0DB3) then Result := 'MAP2_TEXTURE_COORD_1' else
      if self.val = UInt32($0DB4) then Result := 'MAP2_TEXTURE_COORD_2' else
      if self.val = UInt32($0DB5) then Result := 'MAP2_TEXTURE_COORD_3' else
      if self.val = UInt32($0DB6) then Result := 'MAP2_TEXTURE_COORD_4' else
      if self.val = UInt32($0DB7) then Result := 'MAP2_VERTEX_3' else
      if self.val = UInt32($0DB8) then Result := 'MAP2_VERTEX_4' else
      if self.val = UInt32($0DD0) then Result := 'MAP1_GRID_DOMAIN' else
      if self.val = UInt32($0DD1) then Result := 'MAP1_GRID_SEGMENTS' else
      if self.val = UInt32($0DD2) then Result := 'MAP2_GRID_DOMAIN' else
      if self.val = UInt32($0DD3) then Result := 'MAP2_GRID_SEGMENTS' else
      if self.val = UInt32($0DE0) then Result := 'TEXTURE_1D' else
      if self.val = UInt32($0DE1) then Result := 'TEXTURE_2D' else
      if self.val = UInt32($0DF1) then Result := 'FEEDBACK_BUFFER_SIZE' else
      if self.val = UInt32($0DF2) then Result := 'FEEDBACK_BUFFER_TYPE' else
      if self.val = UInt32($0DF4) then Result := 'SELECTION_BUFFER_SIZE' else
      if self.val = UInt32($2A00) then Result := 'POLYGON_OFFSET_UNITS' else
      if self.val = UInt32($2A01) then Result := 'POLYGON_OFFSET_POINT' else
      if self.val = UInt32($2A02) then Result := 'POLYGON_OFFSET_LINE' else
      if self.val = UInt32($3000) then Result := 'CLIP_PLANE0' else
      if self.val = UInt32($3001) then Result := 'CLIP_PLANE1' else
      if self.val = UInt32($3002) then Result := 'CLIP_PLANE2' else
      if self.val = UInt32($3003) then Result := 'CLIP_PLANE3' else
      if self.val = UInt32($3004) then Result := 'CLIP_PLANE4' else
      if self.val = UInt32($3005) then Result := 'CLIP_PLANE5' else
      if self.val = UInt32($4000) then Result := 'LIGHT0' else
      if self.val = UInt32($4001) then Result := 'LIGHT1' else
      if self.val = UInt32($4002) then Result := 'LIGHT2' else
      if self.val = UInt32($4003) then Result := 'LIGHT3' else
      if self.val = UInt32($4004) then Result := 'LIGHT4' else
      if self.val = UInt32($4005) then Result := 'LIGHT5' else
      if self.val = UInt32($4006) then Result := 'LIGHT6' else
      if self.val = UInt32($4007) then Result := 'LIGHT7' else
      if self.val = UInt32($8005) then Result := 'BLEND_COLOR' else
      if self.val = UInt32($8009) then Result := 'BLEND_EQUATION' else
      if self.val = UInt32($8009) then Result := 'BLEND_EQUATION_RGB' else
      if self.val = UInt32($800E) then Result := 'PACK_CMYK_HINT' else
      if self.val = UInt32($800F) then Result := 'UNPACK_CMYK_HINT' else
      if self.val = UInt32($8010) then Result := 'CONVOLUTION_1D' else
      if self.val = UInt32($8011) then Result := 'CONVOLUTION_2D' else
      if self.val = UInt32($8012) then Result := 'SEPARABLE_2D' else
      if self.val = UInt32($801C) then Result := 'POST_CONVOLUTION_RED_SCALE' else
      if self.val = UInt32($801D) then Result := 'POST_CONVOLUTION_GREEN_SCALE' else
      if self.val = UInt32($801E) then Result := 'POST_CONVOLUTION_BLUE_SCALE' else
      if self.val = UInt32($801F) then Result := 'POST_CONVOLUTION_ALPHA_SCALE' else
      if self.val = UInt32($8020) then Result := 'POST_CONVOLUTION_RED_BIAS' else
      if self.val = UInt32($8021) then Result := 'POST_CONVOLUTION_GREEN_BIAS' else
      if self.val = UInt32($8022) then Result := 'POST_CONVOLUTION_BLUE_BIAS' else
      if self.val = UInt32($8023) then Result := 'POST_CONVOLUTION_ALPHA_BIAS' else
      if self.val = UInt32($8024) then Result := 'HISTOGRAM' else
      if self.val = UInt32($802E) then Result := 'MINMAX' else
      if self.val = UInt32($8037) then Result := 'POLYGON_OFFSET_FILL' else
      if self.val = UInt32($8038) then Result := 'POLYGON_OFFSET_FACTOR' else
      if self.val = UInt32($8039) then Result := 'POLYGON_OFFSET_BIAS' else
      if self.val = UInt32($803A) then Result := 'RESCALE_NORMAL' else
      if self.val = UInt32($8068) then Result := 'TEXTURE_BINDING_1D' else
      if self.val = UInt32($8069) then Result := 'TEXTURE_BINDING_2D' else
      if self.val = UInt32($806A) then Result := 'TEXTURE_3D_BINDING' else
      if self.val = UInt32($806A) then Result := 'TEXTURE_BINDING_3D' else
      if self.val = UInt32($806B) then Result := 'PACK_SKIP_IMAGES' else
      if self.val = UInt32($806C) then Result := 'PACK_IMAGE_HEIGHT' else
      if self.val = UInt32($806D) then Result := 'UNPACK_SKIP_IMAGES' else
      if self.val = UInt32($806E) then Result := 'UNPACK_IMAGE_HEIGHT' else
      if self.val = UInt32($806F) then Result := 'TEXTURE_3D' else
      if self.val = UInt32($8073) then Result := 'MAX_3D_TEXTURE_SIZE' else
      if self.val = UInt32($8074) then Result := 'VERTEX_ARRAY' else
      if self.val = UInt32($8075) then Result := 'NORMAL_ARRAY' else
      if self.val = UInt32($8076) then Result := 'COLOR_ARRAY' else
      if self.val = UInt32($8077) then Result := 'INDEX_ARRAY' else
      if self.val = UInt32($8078) then Result := 'TEXTURE_COORD_ARRAY' else
      if self.val = UInt32($8079) then Result := 'EDGE_FLAG_ARRAY' else
      if self.val = UInt32($807A) then Result := 'VERTEX_ARRAY_SIZE' else
      if self.val = UInt32($807B) then Result := 'VERTEX_ARRAY_TYPE' else
      if self.val = UInt32($807C) then Result := 'VERTEX_ARRAY_STRIDE' else
      if self.val = UInt32($807D) then Result := 'VERTEX_ARRAY_COUNT' else
      if self.val = UInt32($807E) then Result := 'NORMAL_ARRAY_TYPE' else
      if self.val = UInt32($807F) then Result := 'NORMAL_ARRAY_STRIDE' else
      if self.val = UInt32($8080) then Result := 'NORMAL_ARRAY_COUNT' else
      if self.val = UInt32($8081) then Result := 'COLOR_ARRAY_SIZE' else
      if self.val = UInt32($8082) then Result := 'COLOR_ARRAY_TYPE' else
      if self.val = UInt32($8083) then Result := 'COLOR_ARRAY_STRIDE' else
      if self.val = UInt32($8084) then Result := 'COLOR_ARRAY_COUNT' else
      if self.val = UInt32($8085) then Result := 'INDEX_ARRAY_TYPE' else
      if self.val = UInt32($8086) then Result := 'INDEX_ARRAY_STRIDE' else
      if self.val = UInt32($8087) then Result := 'INDEX_ARRAY_COUNT' else
      if self.val = UInt32($8088) then Result := 'TEXTURE_COORD_ARRAY_SIZE' else
      if self.val = UInt32($8089) then Result := 'TEXTURE_COORD_ARRAY_TYPE' else
      if self.val = UInt32($808A) then Result := 'TEXTURE_COORD_ARRAY_STRIDE' else
      if self.val = UInt32($808B) then Result := 'TEXTURE_COORD_ARRAY_COUNT' else
      if self.val = UInt32($808C) then Result := 'EDGE_FLAG_ARRAY_STRIDE' else
      if self.val = UInt32($808D) then Result := 'EDGE_FLAG_ARRAY_COUNT' else
      if self.val = UInt32($8094) then Result := 'INTERLACE' else
      if self.val = UInt32($8096) then Result := 'DETAIL_TEXTURE_2D_BINDING' else
      if self.val = UInt32($809D) then Result := 'MULTISAMPLE' else
      if self.val = UInt32($809E) then Result := 'SAMPLE_ALPHA_TO_MASK' else
      if self.val = UInt32($809F) then Result := 'SAMPLE_ALPHA_TO_ONE' else
      if self.val = UInt32($80A0) then Result := 'SAMPLE_MASK_SGIS' else
      if self.val = UInt32($80A8) then Result := 'SAMPLE_BUFFERS' else
      if self.val = UInt32($80A9) then Result := 'SAMPLES' else
      if self.val = UInt32($80AA) then Result := 'SAMPLE_MASK_VALUE' else
      if self.val = UInt32($80AA) then Result := 'SAMPLE_COVERAGE_VALUE' else
      if self.val = UInt32($80AB) then Result := 'SAMPLE_MASK_INVERT' else
      if self.val = UInt32($80AB) then Result := 'SAMPLE_COVERAGE_INVERT' else
      if self.val = UInt32($80AC) then Result := 'SAMPLE_PATTERN' else
      if self.val = UInt32($80B1) then Result := 'COLOR_MATRIX' else
      if self.val = UInt32($80B2) then Result := 'COLOR_MATRIX_STACK_DEPTH' else
      if self.val = UInt32($80B3) then Result := 'MAX_COLOR_MATRIX_STACK_DEPTH' else
      if self.val = UInt32($80B4) then Result := 'POST_COLOR_MATRIX_RED_SCALE' else
      if self.val = UInt32($80B5) then Result := 'POST_COLOR_MATRIX_GREEN_SCALE' else
      if self.val = UInt32($80B6) then Result := 'POST_COLOR_MATRIX_BLUE_SCALE' else
      if self.val = UInt32($80B7) then Result := 'POST_COLOR_MATRIX_ALPHA_SCALE' else
      if self.val = UInt32($80B8) then Result := 'POST_COLOR_MATRIX_RED_BIAS' else
      if self.val = UInt32($80B9) then Result := 'POST_COLOR_MATRIX_GREEN_BIAS' else
      if self.val = UInt32($80BA) then Result := 'POST_COLOR_MATRIX_BLUE_BIAS' else
      if self.val = UInt32($80BB) then Result := 'POST_COLOR_MATRIX_ALPHA_BIAS' else
      if self.val = UInt32($80BC) then Result := 'TEXTURE_COLOR_TABLE' else
      if self.val = UInt32($80C8) then Result := 'BLEND_DST_RGB' else
      if self.val = UInt32($80C9) then Result := 'BLEND_SRC_RGB' else
      if self.val = UInt32($80CA) then Result := 'BLEND_DST_ALPHA' else
      if self.val = UInt32($80CB) then Result := 'BLEND_SRC_ALPHA' else
      if self.val = UInt32($80D0) then Result := 'COLOR_TABLE' else
      if self.val = UInt32($80D1) then Result := 'POST_CONVOLUTION_COLOR_TABLE' else
      if self.val = UInt32($80D2) then Result := 'POST_COLOR_MATRIX_COLOR_TABLE' else
      if self.val = UInt32($80E8) then Result := 'MAX_ELEMENTS_VERTICES' else
      if self.val = UInt32($80E9) then Result := 'MAX_ELEMENTS_INDICES' else
      if self.val = UInt32($8126) then Result := 'POINT_SIZE_MIN' else
      if self.val = UInt32($8127) then Result := 'POINT_SIZE_MAX' else
      if self.val = UInt32($8128) then Result := 'POINT_FADE_THRESHOLD_SIZE' else
      if self.val = UInt32($8129) then Result := 'DISTANCE_ATTENUATION' else
      if self.val = UInt32($8129) then Result := 'POINT_DISTANCE_ATTENUATION' else
      if self.val = UInt32($812B) then Result := 'FOG_FUNC_POINTS' else
      if self.val = UInt32($812C) then Result := 'MAX_FOG_FUNC_POINTS' else
      if self.val = UInt32($8130) then Result := 'PACK_SKIP_VOLUMES' else
      if self.val = UInt32($8131) then Result := 'PACK_IMAGE_DEPTH' else
      if self.val = UInt32($8132) then Result := 'UNPACK_SKIP_VOLUMES' else
      if self.val = UInt32($8133) then Result := 'UNPACK_IMAGE_DEPTH' else
      if self.val = UInt32($8134) then Result := 'TEXTURE_4D' else
      if self.val = UInt32($8138) then Result := 'MAX_4D_TEXTURE_SIZE' else
      if self.val = UInt32($8139) then Result := 'PIXEL_TEX_GEN' else
      if self.val = UInt32($813E) then Result := 'PIXEL_TILE_BEST_ALIGNMENT' else
      if self.val = UInt32($813F) then Result := 'PIXEL_TILE_CACHE_INCREMENT' else
      if self.val = UInt32($8140) then Result := 'PIXEL_TILE_WIDTH' else
      if self.val = UInt32($8141) then Result := 'PIXEL_TILE_HEIGHT' else
      if self.val = UInt32($8142) then Result := 'PIXEL_TILE_GRID_WIDTH' else
      if self.val = UInt32($8143) then Result := 'PIXEL_TILE_GRID_HEIGHT' else
      if self.val = UInt32($8144) then Result := 'PIXEL_TILE_GRID_DEPTH' else
      if self.val = UInt32($8145) then Result := 'PIXEL_TILE_CACHE_SIZE' else
      if self.val = UInt32($8148) then Result := 'SPRITE' else
      if self.val = UInt32($8149) then Result := 'SPRITE_MODE' else
      if self.val = UInt32($814A) then Result := 'SPRITE_AXIS' else
      if self.val = UInt32($814B) then Result := 'SPRITE_TRANSLATION' else
      if self.val = UInt32($814F) then Result := 'TEXTURE_4D_BINDING' else
      if self.val = UInt32($8177) then Result := 'MAX_CLIPMAP_DEPTH' else
      if self.val = UInt32($8178) then Result := 'MAX_CLIPMAP_VIRTUAL_DEPTH' else
      if self.val = UInt32($817B) then Result := 'POST_TEXTURE_FILTER_BIAS_RANGE' else
      if self.val = UInt32($817C) then Result := 'POST_TEXTURE_FILTER_SCALE_RANGE' else
      if self.val = UInt32($817D) then Result := 'REFERENCE_PLANE' else
      if self.val = UInt32($817E) then Result := 'REFERENCE_PLANE_EQUATION' else
      if self.val = UInt32($817F) then Result := 'IR_INSTRUMENT1' else
      if self.val = UInt32($8181) then Result := 'INSTRUMENT_MEASUREMENTS' else
      if self.val = UInt32($8183) then Result := 'CALLIGRAPHIC_FRAGMENT' else
      if self.val = UInt32($818B) then Result := 'FRAMEZOOM' else
      if self.val = UInt32($818C) then Result := 'FRAMEZOOM_FACTOR' else
      if self.val = UInt32($818D) then Result := 'MAX_FRAMEZOOM_FACTOR' else
      if self.val = UInt32($8192) then Result := 'GENERATE_MIPMAP_HINT' else
      if self.val = UInt32($8196) then Result := 'DEFORMATIONS_MASK' else
      if self.val = UInt32($8198) then Result := 'FOG_OFFSET' else
      if self.val = UInt32($8199) then Result := 'FOG_OFFSET_VALUE' else
      if self.val = UInt32($81F8) then Result := 'LIGHT_MODEL_COLOR_CONTROL' else
      if self.val = UInt32($81FB) then Result := 'SHARED_TEXTURE_PALETTE' else
      if self.val = UInt32($821B) then Result := 'MAJOR_VERSION' else
      if self.val = UInt32($821C) then Result := 'MINOR_VERSION' else
      if self.val = UInt32($821D) then Result := 'NUM_EXTENSIONS' else
      if self.val = UInt32($821E) then Result := 'CONTEXT_FLAGS' else
      if self.val = UInt32($825A) then Result := 'PROGRAM_PIPELINE_BINDING' else
      if self.val = UInt32($825B) then Result := 'MAX_VIEWPORTS' else
      if self.val = UInt32($825C) then Result := 'VIEWPORT_SUBPIXEL_BITS' else
      if self.val = UInt32($825D) then Result := 'VIEWPORT_BOUNDS_RANGE' else
      if self.val = UInt32($825E) then Result := 'LAYER_PROVOKING_VERTEX' else
      if self.val = UInt32($825F) then Result := 'VIEWPORT_INDEX_PROVOKING_VERTEX' else
      if self.val = UInt32($8263) then Result := 'MAX_COMPUTE_UNIFORM_COMPONENTS' else
      if self.val = UInt32($8264) then Result := 'MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS' else
      if self.val = UInt32($8265) then Result := 'MAX_COMPUTE_ATOMIC_COUNTERS' else
      if self.val = UInt32($8266) then Result := 'MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS' else
      if self.val = UInt32($826C) then Result := 'MAX_DEBUG_GROUP_STACK_DEPTH' else
      if self.val = UInt32($826D) then Result := 'DEBUG_GROUP_STACK_DEPTH' else
      if self.val = UInt32($826E) then Result := 'MAX_UNIFORM_LOCATIONS' else
      if self.val = UInt32($82D6) then Result := 'VERTEX_BINDING_DIVISOR' else
      if self.val = UInt32($82D7) then Result := 'VERTEX_BINDING_OFFSET' else
      if self.val = UInt32($82D8) then Result := 'VERTEX_BINDING_STRIDE' else
      if self.val = UInt32($82D9) then Result := 'MAX_VERTEX_ATTRIB_RELATIVE_OFFSET' else
      if self.val = UInt32($82DA) then Result := 'MAX_VERTEX_ATTRIB_BINDINGS' else
      if self.val = UInt32($82E8) then Result := 'MAX_LABEL_LENGTH' else
      if self.val = UInt32($8316) then Result := 'CONVOLUTION_HINT' else
      if self.val = UInt32($8329) then Result := 'ASYNC_MARKER' else
      if self.val = UInt32($832B) then Result := 'PIXEL_TEX_GEN_MODE' else
      if self.val = UInt32($832C) then Result := 'ASYNC_HISTOGRAM' else
      if self.val = UInt32($832D) then Result := 'MAX_ASYNC_HISTOGRAM' else
      if self.val = UInt32($8353) then Result := 'PIXEL_TEXTURE' else
      if self.val = UInt32($835C) then Result := 'ASYNC_TEX_IMAGE' else
      if self.val = UInt32($835D) then Result := 'ASYNC_DRAW_PIXELS' else
      if self.val = UInt32($835E) then Result := 'ASYNC_READ_PIXELS' else
      if self.val = UInt32($835F) then Result := 'MAX_ASYNC_TEX_IMAGE' else
      if self.val = UInt32($8360) then Result := 'MAX_ASYNC_DRAW_PIXELS' else
      if self.val = UInt32($8361) then Result := 'MAX_ASYNC_READ_PIXELS' else
      if self.val = UInt32($83EE) then Result := 'VERTEX_PRECLIP' else
      if self.val = UInt32($83EF) then Result := 'VERTEX_PRECLIP_HINT' else
      if self.val = UInt32($8400) then Result := 'FRAGMENT_LIGHTING' else
      if self.val = UInt32($8401) then Result := 'FRAGMENT_COLOR_MATERIAL' else
      if self.val = UInt32($8402) then Result := 'FRAGMENT_COLOR_MATERIAL_FACE' else
      if self.val = UInt32($8403) then Result := 'FRAGMENT_COLOR_MATERIAL_PARAMETER' else
      if self.val = UInt32($8404) then Result := 'MAX_FRAGMENT_LIGHTS' else
      if self.val = UInt32($8405) then Result := 'MAX_ACTIVE_LIGHTS' else
      if self.val = UInt32($8407) then Result := 'LIGHT_ENV_MODE' else
      if self.val = UInt32($8408) then Result := 'FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER' else
      if self.val = UInt32($8409) then Result := 'FRAGMENT_LIGHT_MODEL_TWO_SIDE' else
      if self.val = UInt32($840A) then Result := 'FRAGMENT_LIGHT_MODEL_AMBIENT' else
      if self.val = UInt32($840B) then Result := 'FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION' else
      if self.val = UInt32($840C) then Result := 'FRAGMENT_LIGHT0' else
      if self.val = UInt32($842E) then Result := 'PACK_RESAMPLE_SGIX' else
      if self.val = UInt32($842F) then Result := 'UNPACK_RESAMPLE_SGIX' else
      if self.val = UInt32($846D) then Result := 'ALIASED_POINT_SIZE_RANGE' else
      if self.val = UInt32($846E) then Result := 'ALIASED_LINE_WIDTH_RANGE' else
      if self.val = UInt32($84E0) then Result := 'ACTIVE_TEXTURE' else
      if self.val = UInt32($84E8) then Result := 'MAX_RENDERBUFFER_SIZE' else
      if self.val = UInt32($84EF) then Result := 'TEXTURE_COMPRESSION_HINT' else
      if self.val = UInt32($84F6) then Result := 'TEXTURE_BINDING_RECTANGLE' else
      if self.val = UInt32($84F8) then Result := 'MAX_RECTANGLE_TEXTURE_SIZE' else
      if self.val = UInt32($84FD) then Result := 'MAX_TEXTURE_LOD_BIAS' else
      if self.val = UInt32($8514) then Result := 'TEXTURE_BINDING_CUBE_MAP' else
      if self.val = UInt32($851C) then Result := 'MAX_CUBE_MAP_TEXTURE_SIZE' else
      if self.val = UInt32($85A0) then Result := 'PACK_SUBSAMPLE_RATE' else
      if self.val = UInt32($85A1) then Result := 'UNPACK_SUBSAMPLE_RATE' else
      if self.val = UInt32($85B5) then Result := 'VERTEX_ARRAY_BINDING' else
      if self.val = UInt32($8642) then Result := 'PROGRAM_POINT_SIZE' else
      if self.val = UInt32($86A2) then Result := 'NUM_COMPRESSED_TEXTURE_FORMATS' else
      if self.val = UInt32($86A3) then Result := 'COMPRESSED_TEXTURE_FORMATS' else
      if self.val = UInt32($87FE) then Result := 'NUM_PROGRAM_BINARY_FORMATS' else
      if self.val = UInt32($87FF) then Result := 'PROGRAM_BINARY_FORMATS' else
      if self.val = UInt32($8800) then Result := 'STENCIL_BACK_FUNC' else
      if self.val = UInt32($8801) then Result := 'STENCIL_BACK_FAIL' else
      if self.val = UInt32($8802) then Result := 'STENCIL_BACK_PASS_DEPTH_FAIL' else
      if self.val = UInt32($8803) then Result := 'STENCIL_BACK_PASS_DEPTH_PASS' else
      if self.val = UInt32($8824) then Result := 'MAX_DRAW_BUFFERS' else
      if self.val = UInt32($883D) then Result := 'BLEND_EQUATION_ALPHA' else
      if self.val = UInt32($8869) then Result := 'MAX_VERTEX_ATTRIBS' else
      if self.val = UInt32($8872) then Result := 'MAX_TEXTURE_IMAGE_UNITS' else
      if self.val = UInt32($8894) then Result := 'ARRAY_BUFFER_BINDING' else
      if self.val = UInt32($8895) then Result := 'ELEMENT_ARRAY_BUFFER_BINDING' else
      if self.val = UInt32($88ED) then Result := 'PIXEL_PACK_BUFFER_BINDING' else
      if self.val = UInt32($88EF) then Result := 'PIXEL_UNPACK_BUFFER_BINDING' else
      if self.val = UInt32($88FC) then Result := 'MAX_DUAL_SOURCE_DRAW_BUFFERS' else
      if self.val = UInt32($88FF) then Result := 'MAX_ARRAY_TEXTURE_LAYERS' else
      if self.val = UInt32($8904) then Result := 'MIN_PROGRAM_TEXEL_OFFSET' else
      if self.val = UInt32($8905) then Result := 'MAX_PROGRAM_TEXEL_OFFSET' else
      if self.val = UInt32($8919) then Result := 'SAMPLER_BINDING' else
      if self.val = UInt32($8920) then Result := 'FRAGMENT_SHADER_ATI' else
      if self.val = UInt32($8A28) then Result := 'UNIFORM_BUFFER_BINDING' else
      if self.val = UInt32($8A29) then Result := 'UNIFORM_BUFFER_START' else
      if self.val = UInt32($8A2A) then Result := 'UNIFORM_BUFFER_SIZE' else
      if self.val = UInt32($8A2B) then Result := 'MAX_VERTEX_UNIFORM_BLOCKS' else
      if self.val = UInt32($8A2C) then Result := 'MAX_GEOMETRY_UNIFORM_BLOCKS' else
      if self.val = UInt32($8A2D) then Result := 'MAX_FRAGMENT_UNIFORM_BLOCKS' else
      if self.val = UInt32($8A2E) then Result := 'MAX_COMBINED_UNIFORM_BLOCKS' else
      if self.val = UInt32($8A2F) then Result := 'MAX_UNIFORM_BUFFER_BINDINGS' else
      if self.val = UInt32($8A30) then Result := 'MAX_UNIFORM_BLOCK_SIZE' else
      if self.val = UInt32($8A31) then Result := 'MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS' else
      if self.val = UInt32($8A32) then Result := 'MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS' else
      if self.val = UInt32($8A33) then Result := 'MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS' else
      if self.val = UInt32($8A34) then Result := 'UNIFORM_BUFFER_OFFSET_ALIGNMENT' else
      if self.val = UInt32($8B49) then Result := 'MAX_FRAGMENT_UNIFORM_COMPONENTS' else
      if self.val = UInt32($8B4A) then Result := 'MAX_VERTEX_UNIFORM_COMPONENTS' else
      if self.val = UInt32($8B4B) then Result := 'MAX_VARYING_FLOATS' else
      if self.val = UInt32($8B4B) then Result := 'MAX_VARYING_COMPONENTS' else
      if self.val = UInt32($8B4C) then Result := 'MAX_VERTEX_TEXTURE_IMAGE_UNITS' else
      if self.val = UInt32($8B4D) then Result := 'MAX_COMBINED_TEXTURE_IMAGE_UNITS' else
      if self.val = UInt32($8B8B) then Result := 'FRAGMENT_SHADER_DERIVATIVE_HINT' else
      if self.val = UInt32($8B8D) then Result := 'CURRENT_PROGRAM' else
      if self.val = UInt32($8B9A) then Result := 'IMPLEMENTATION_COLOR_READ_TYPE' else
      if self.val = UInt32($8B9B) then Result := 'IMPLEMENTATION_COLOR_READ_FORMAT' else
      if self.val = UInt32($8C1C) then Result := 'TEXTURE_BINDING_1D_ARRAY' else
      if self.val = UInt32($8C1D) then Result := 'TEXTURE_BINDING_2D_ARRAY' else
      if self.val = UInt32($8C29) then Result := 'MAX_GEOMETRY_TEXTURE_IMAGE_UNITS' else
      if self.val = UInt32($8C2B) then Result := 'MAX_TEXTURE_BUFFER_SIZE' else
      if self.val = UInt32($8C2C) then Result := 'TEXTURE_BINDING_BUFFER' else
      if self.val = UInt32($8C84) then Result := 'TRANSFORM_FEEDBACK_BUFFER_START' else
      if self.val = UInt32($8C85) then Result := 'TRANSFORM_FEEDBACK_BUFFER_SIZE' else
      if self.val = UInt32($8C8F) then Result := 'TRANSFORM_FEEDBACK_BUFFER_BINDING' else
      if self.val = UInt32($8C90) then Result := 'MOTION_ESTIMATION_SEARCH_BLOCK_X' else
      if self.val = UInt32($8C91) then Result := 'MOTION_ESTIMATION_SEARCH_BLOCK_Y' else
      if self.val = UInt32($8CA3) then Result := 'STENCIL_BACK_REF' else
      if self.val = UInt32($8CA4) then Result := 'STENCIL_BACK_VALUE_MASK' else
      if self.val = UInt32($8CA5) then Result := 'STENCIL_BACK_WRITEMASK' else
      if self.val = UInt32($8CA6) then Result := 'DRAW_FRAMEBUFFER_BINDING' else
      if self.val = UInt32($8CA7) then Result := 'RENDERBUFFER_BINDING' else
      if self.val = UInt32($8CAA) then Result := 'READ_FRAMEBUFFER_BINDING' else
      if self.val = UInt32($8CDF) then Result := 'MAX_COLOR_ATTACHMENTS' else
      if self.val = UInt32($8D60) then Result := 'TEXTURE_GEN_STR' else
      if self.val = UInt32($8D6B) then Result := 'MAX_ELEMENT_INDEX' else
      if self.val = UInt32($8DDF) then Result := 'MAX_GEOMETRY_UNIFORM_COMPONENTS' else
      if self.val = UInt32($8DF8) then Result := 'SHADER_BINARY_FORMATS' else
      if self.val = UInt32($8DF9) then Result := 'NUM_SHADER_BINARY_FORMATS' else
      if self.val = UInt32($8DFA) then Result := 'SHADER_COMPILER' else
      if self.val = UInt32($8DFB) then Result := 'MAX_VERTEX_UNIFORM_VECTORS' else
      if self.val = UInt32($8DFC) then Result := 'MAX_VARYING_VECTORS' else
      if self.val = UInt32($8DFD) then Result := 'MAX_FRAGMENT_UNIFORM_VECTORS' else
      if self.val = UInt32($8E28) then Result := 'TIMESTAMP' else
      if self.val = UInt32($8E4F) then Result := 'PROVOKING_VERTEX' else
      if self.val = UInt32($8E59) then Result := 'MAX_SAMPLE_MASK_WORDS' else
      if self.val = UInt32($8E89) then Result := 'MAX_TESS_CONTROL_UNIFORM_BLOCKS' else
      if self.val = UInt32($8E8A) then Result := 'MAX_TESS_EVALUATION_UNIFORM_BLOCKS' else
      if self.val = UInt32($8F65) then Result := 'FETCH_PER_SAMPLE_ARM' else
      if self.val = UInt32($8F66) then Result := 'FRAGMENT_SHADER_FRAMEBUFFER_FETCH_MRT_ARM' else
      if self.val = UInt32($8F6F) then Result := 'FRAGMENT_SHADING_RATE_NON_TRIVIAL_COMBINERS_SUPPORTED' else
      if self.val = UInt32($8F9E) then Result := 'PRIMITIVE_RESTART_INDEX' else
      if self.val = UInt32($90BC) then Result := 'MIN_MAP_BUFFER_ALIGNMENT' else
      if self.val = UInt32($90D3) then Result := 'SHADER_STORAGE_BUFFER_BINDING' else
      if self.val = UInt32($90D4) then Result := 'SHADER_STORAGE_BUFFER_START' else
      if self.val = UInt32($90D5) then Result := 'SHADER_STORAGE_BUFFER_SIZE' else
      if self.val = UInt32($90D6) then Result := 'MAX_VERTEX_SHADER_STORAGE_BLOCKS' else
      if self.val = UInt32($90D7) then Result := 'MAX_GEOMETRY_SHADER_STORAGE_BLOCKS' else
      if self.val = UInt32($90D8) then Result := 'MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS' else
      if self.val = UInt32($90D9) then Result := 'MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS' else
      if self.val = UInt32($90DA) then Result := 'MAX_FRAGMENT_SHADER_STORAGE_BLOCKS' else
      if self.val = UInt32($90DB) then Result := 'MAX_COMPUTE_SHADER_STORAGE_BLOCKS' else
      if self.val = UInt32($90DC) then Result := 'MAX_COMBINED_SHADER_STORAGE_BLOCKS' else
      if self.val = UInt32($90DD) then Result := 'MAX_SHADER_STORAGE_BUFFER_BINDINGS' else
      if self.val = UInt32($90DF) then Result := 'SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT' else
      if self.val = UInt32($90EB) then Result := 'MAX_COMPUTE_WORK_GROUP_INVOCATIONS' else
      if self.val = UInt32($90EF) then Result := 'DISPATCH_INDIRECT_BUFFER_BINDING' else
      if self.val = UInt32($9104) then Result := 'TEXTURE_BINDING_2D_MULTISAMPLE' else
      if self.val = UInt32($9105) then Result := 'TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($910E) then Result := 'MAX_COLOR_TEXTURE_SAMPLES' else
      if self.val = UInt32($910F) then Result := 'MAX_DEPTH_TEXTURE_SAMPLES' else
      if self.val = UInt32($9110) then Result := 'MAX_INTEGER_SAMPLES' else
      if self.val = UInt32($9111) then Result := 'MAX_SERVER_WAIT_TIMEOUT' else
      if self.val = UInt32($9122) then Result := 'MAX_VERTEX_OUTPUT_COMPONENTS' else
      if self.val = UInt32($9123) then Result := 'MAX_GEOMETRY_INPUT_COMPONENTS' else
      if self.val = UInt32($9124) then Result := 'MAX_GEOMETRY_OUTPUT_COMPONENTS' else
      if self.val = UInt32($9125) then Result := 'MAX_FRAGMENT_INPUT_COMPONENTS' else
      if self.val = UInt32($9126) then Result := 'CONTEXT_PROFILE_MASK' else
      if self.val = UInt32($919F) then Result := 'TEXTURE_BUFFER_OFFSET_ALIGNMENT' else
      if self.val = UInt32($91BB) then Result := 'MAX_COMPUTE_UNIFORM_BLOCKS' else
      if self.val = UInt32($91BC) then Result := 'MAX_COMPUTE_TEXTURE_IMAGE_UNITS' else
      if self.val = UInt32($91BE) then Result := 'MAX_COMPUTE_WORK_GROUP_COUNT' else
      if self.val = UInt32($91BF) then Result := 'MAX_COMPUTE_WORK_GROUP_SIZE' else
      if self.val = UInt32($92D2) then Result := 'MAX_VERTEX_ATOMIC_COUNTERS' else
      if self.val = UInt32($92D3) then Result := 'MAX_TESS_CONTROL_ATOMIC_COUNTERS' else
      if self.val = UInt32($92D4) then Result := 'MAX_TESS_EVALUATION_ATOMIC_COUNTERS' else
      if self.val = UInt32($92D5) then Result := 'MAX_GEOMETRY_ATOMIC_COUNTERS' else
      if self.val = UInt32($92D6) then Result := 'MAX_FRAGMENT_ATOMIC_COUNTERS' else
      if self.val = UInt32($92D7) then Result := 'MAX_COMBINED_ATOMIC_COUNTERS' else
      if self.val = UInt32($9315) then Result := 'MAX_FRAMEBUFFER_WIDTH' else
      if self.val = UInt32($9316) then Result := 'MAX_FRAMEBUFFER_HEIGHT' else
      if self.val = UInt32($9317) then Result := 'MAX_FRAMEBUFFER_LAYERS' else
      if self.val = UInt32($9318) then Result := 'MAX_FRAMEBUFFER_SAMPLES' else
      if self.val = UInt32($9596) then Result := 'NUM_DEVICE_UUIDS' else
      if self.val = UInt32($9597) then Result := 'DEVICE_UUID' else
      if self.val = UInt32($9598) then Result := 'DRIVER_UUID' else
      if self.val = UInt32($9599) then Result := 'DEVICE_LUID' else
      if self.val = UInt32($959A) then Result := 'DEVICE_NODE_MASK' else
      if self.val = UInt32($95B1) then Result := 'SHADING_RATE_IMAGE_PER_PRIMITIVE' else
      if self.val = UInt32($95B2) then Result := 'SHADING_RATE_IMAGE_PALETTE_COUNT' else
      if self.val = UInt32($95B6) then Result := 'MAX_TIMELINE_SEMAPHORE_VALUE_DIFFERENCE' else
      if self.val = UInt32($96A2) then Result := 'FRAMEBUFFER_FETCH_NONCOHERENT' else
      if self.val = UInt32($96A4) then Result := 'SHADING_RATE_QCOM' else
      if self.val = UInt32($96D0) then Result := 'SHADING_RATE_EXT' else
      if self.val = UInt32($96D7) then Result := 'MIN_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_WIDTH' else
      if self.val = UInt32($96D8) then Result := 'MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_WIDTH' else
      if self.val = UInt32($96D9) then Result := 'MIN_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_HEIGHT' else
      if self.val = UInt32($96DA) then Result := 'MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_HEIGHT' else
      if self.val = UInt32($96DB) then Result := 'MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_ASPECT_RATIO' else
      if self.val = UInt32($96DC) then Result := 'MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_LAYERS' else
      if self.val = UInt32($96DD) then Result := 'FRAGMENT_SHADING_RATE_WITH_SHADER_DEPTH_STENCIL_WRITES_SUPPORTED' else
      if self.val = UInt32($96DE) then Result := 'FRAGMENT_SHADING_RATE_WITH_SAMPLE_MASK_SUPPORTED' else
      if self.val = UInt32($96DF) then Result := 'FRAGMENT_SHADING_RATE_ATTACHMENT_WITH_DEFAULT_FRAMEBUFFER_SUPPORTED' else
        Result := $'GetPName[{self.val}]';
    end;
    
  end;
  
  GetPointervPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FEEDBACK_BUFFER_POINTER:     GetPointervPName read new GetPointervPName($0DF0);
    public static property SELECTION_BUFFER_POINTER:    GetPointervPName read new GetPointervPName($0DF3);
    public static property VERTEX_ARRAY_POINTER:        GetPointervPName read new GetPointervPName($808E);
    public static property NORMAL_ARRAY_POINTER:        GetPointervPName read new GetPointervPName($808F);
    public static property COLOR_ARRAY_POINTER:         GetPointervPName read new GetPointervPName($8090);
    public static property INDEX_ARRAY_POINTER:         GetPointervPName read new GetPointervPName($8091);
    public static property TEXTURE_COORD_ARRAY_POINTER: GetPointervPName read new GetPointervPName($8092);
    public static property EDGE_FLAG_ARRAY_POINTER:     GetPointervPName read new GetPointervPName($8093);
    public static property INSTRUMENT_BUFFER_POINTER:   GetPointervPName read new GetPointervPName($8180);
    public static property DEBUG_CALLBACK_FUNCTION:     GetPointervPName read new GetPointervPName($8244);
    public static property DEBUG_CALLBACK_USER_PARAM:   GetPointervPName read new GetPointervPName($8245);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0DF0) then Result := 'FEEDBACK_BUFFER_POINTER' else
      if self.val = UInt32($0DF3) then Result := 'SELECTION_BUFFER_POINTER' else
      if self.val = UInt32($808E) then Result := 'VERTEX_ARRAY_POINTER' else
      if self.val = UInt32($808F) then Result := 'NORMAL_ARRAY_POINTER' else
      if self.val = UInt32($8090) then Result := 'COLOR_ARRAY_POINTER' else
      if self.val = UInt32($8091) then Result := 'INDEX_ARRAY_POINTER' else
      if self.val = UInt32($8092) then Result := 'TEXTURE_COORD_ARRAY_POINTER' else
      if self.val = UInt32($8093) then Result := 'EDGE_FLAG_ARRAY_POINTER' else
      if self.val = UInt32($8180) then Result := 'INSTRUMENT_BUFFER_POINTER' else
      if self.val = UInt32($8244) then Result := 'DEBUG_CALLBACK_FUNCTION' else
      if self.val = UInt32($8245) then Result := 'DEBUG_CALLBACK_USER_PARAM' else
        Result := $'GetPointervPName[{self.val}]';
    end;
    
  end;
  
  GetTexBumpParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BUMP_ROT_MATRIX:      GetTexBumpParameter read new GetTexBumpParameter($8775);
    public static property BUMP_ROT_MATRIX_SIZE: GetTexBumpParameter read new GetTexBumpParameter($8776);
    public static property BUMP_NUM_TEX_UNITS:   GetTexBumpParameter read new GetTexBumpParameter($8777);
    public static property BUMP_TEX_UNITS:       GetTexBumpParameter read new GetTexBumpParameter($8778);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8775) then Result := 'BUMP_ROT_MATRIX' else
      if self.val = UInt32($8776) then Result := 'BUMP_ROT_MATRIX_SIZE' else
      if self.val = UInt32($8777) then Result := 'BUMP_NUM_TEX_UNITS' else
      if self.val = UInt32($8778) then Result := 'BUMP_TEX_UNITS' else
        Result := $'GetTexBumpParameter[{self.val}]';
    end;
    
  end;
  
  GetTextureParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_WIDTH:                        GetTextureParameter read new GetTextureParameter($1000);
    public static property TEXTURE_HEIGHT:                       GetTextureParameter read new GetTextureParameter($1001);
    public static property TEXTURE_INTERNAL_FORMAT:              GetTextureParameter read new GetTextureParameter($1003);
    public static property TEXTURE_COMPONENTS:                   GetTextureParameter read new GetTextureParameter($1003);
    public static property TEXTURE_BORDER_COLOR:                 GetTextureParameter read new GetTextureParameter($1004);
    public static property TEXTURE_BORDER:                       GetTextureParameter read new GetTextureParameter($1005);
    public static property TEXTURE_MAG_FILTER:                   GetTextureParameter read new GetTextureParameter($2800);
    public static property TEXTURE_MIN_FILTER:                   GetTextureParameter read new GetTextureParameter($2801);
    public static property TEXTURE_WRAP_S:                       GetTextureParameter read new GetTextureParameter($2802);
    public static property TEXTURE_WRAP_T:                       GetTextureParameter read new GetTextureParameter($2803);
    public static property TEXTURE_RED_SIZE:                     GetTextureParameter read new GetTextureParameter($805C);
    public static property TEXTURE_GREEN_SIZE:                   GetTextureParameter read new GetTextureParameter($805D);
    public static property TEXTURE_BLUE_SIZE:                    GetTextureParameter read new GetTextureParameter($805E);
    public static property TEXTURE_ALPHA_SIZE:                   GetTextureParameter read new GetTextureParameter($805F);
    public static property TEXTURE_LUMINANCE_SIZE:               GetTextureParameter read new GetTextureParameter($8060);
    public static property TEXTURE_INTENSITY_SIZE:               GetTextureParameter read new GetTextureParameter($8061);
    public static property TEXTURE_PRIORITY:                     GetTextureParameter read new GetTextureParameter($8066);
    public static property TEXTURE_RESIDENT:                     GetTextureParameter read new GetTextureParameter($8067);
    public static property TEXTURE_DEPTH:                        GetTextureParameter read new GetTextureParameter($8071);
    public static property TEXTURE_WRAP_R:                       GetTextureParameter read new GetTextureParameter($8072);
    public static property DETAIL_TEXTURE_LEVEL:                 GetTextureParameter read new GetTextureParameter($809A);
    public static property DETAIL_TEXTURE_MODE:                  GetTextureParameter read new GetTextureParameter($809B);
    public static property DETAIL_TEXTURE_FUNC_POINTS:           GetTextureParameter read new GetTextureParameter($809C);
    public static property SHARPEN_TEXTURE_FUNC_POINTS:          GetTextureParameter read new GetTextureParameter($80B0);
    public static property SHADOW_AMBIENT:                       GetTextureParameter read new GetTextureParameter($80BF);
    public static property DUAL_TEXTURE_SELECT:                  GetTextureParameter read new GetTextureParameter($8124);
    public static property QUAD_TEXTURE_SELECT:                  GetTextureParameter read new GetTextureParameter($8125);
    public static property TEXTURE_4DSIZE:                       GetTextureParameter read new GetTextureParameter($8136);
    public static property TEXTURE_WRAP_Q:                       GetTextureParameter read new GetTextureParameter($8137);
    public static property TEXTURE_MIN_LOD:                      GetTextureParameter read new GetTextureParameter($813A);
    public static property TEXTURE_MAX_LOD:                      GetTextureParameter read new GetTextureParameter($813B);
    public static property TEXTURE_BASE_LEVEL:                   GetTextureParameter read new GetTextureParameter($813C);
    public static property TEXTURE_MAX_LEVEL:                    GetTextureParameter read new GetTextureParameter($813D);
    public static property TEXTURE_FILTER4_SIZE:                 GetTextureParameter read new GetTextureParameter($8147);
    public static property TEXTURE_CLIPMAP_CENTER:               GetTextureParameter read new GetTextureParameter($8171);
    public static property TEXTURE_CLIPMAP_FRAME:                GetTextureParameter read new GetTextureParameter($8172);
    public static property TEXTURE_CLIPMAP_OFFSET:               GetTextureParameter read new GetTextureParameter($8173);
    public static property TEXTURE_CLIPMAP_VIRTUAL_DEPTH:        GetTextureParameter read new GetTextureParameter($8174);
    public static property TEXTURE_CLIPMAP_LOD_OFFSET:           GetTextureParameter read new GetTextureParameter($8175);
    public static property TEXTURE_CLIPMAP_DEPTH:                GetTextureParameter read new GetTextureParameter($8176);
    public static property POST_TEXTURE_FILTER_BIAS:             GetTextureParameter read new GetTextureParameter($8179);
    public static property POST_TEXTURE_FILTER_SCALE:            GetTextureParameter read new GetTextureParameter($817A);
    public static property TEXTURE_LOD_BIAS_S:                   GetTextureParameter read new GetTextureParameter($818E);
    public static property TEXTURE_LOD_BIAS_T:                   GetTextureParameter read new GetTextureParameter($818F);
    public static property TEXTURE_LOD_BIAS_R:                   GetTextureParameter read new GetTextureParameter($8190);
    public static property GENERATE_MIPMAP:                      GetTextureParameter read new GetTextureParameter($8191);
    public static property TEXTURE_COMPARE:                      GetTextureParameter read new GetTextureParameter($819A);
    public static property TEXTURE_COMPARE_OPERATOR:             GetTextureParameter read new GetTextureParameter($819B);
    public static property TEXTURE_LEQUAL_R:                     GetTextureParameter read new GetTextureParameter($819C);
    public static property TEXTURE_GEQUAL_R:                     GetTextureParameter read new GetTextureParameter($819D);
    public static property TEXTURE_MAX_CLAMP_S:                  GetTextureParameter read new GetTextureParameter($8369);
    public static property TEXTURE_MAX_CLAMP_T:                  GetTextureParameter read new GetTextureParameter($836A);
    public static property TEXTURE_MAX_CLAMP_R:                  GetTextureParameter read new GetTextureParameter($836B);
    public static property NORMAL_MAP:                           GetTextureParameter read new GetTextureParameter($8511);
    public static property REFLECTION_MAP:                       GetTextureParameter read new GetTextureParameter($8512);
    public static property TEXTURE_UNNORMALIZED_COORDINATES_ARM: GetTextureParameter read new GetTextureParameter($8F6A);
    public static property SURFACE_COMPRESSION:                  GetTextureParameter read new GetTextureParameter($96C0);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1000) then Result := 'TEXTURE_WIDTH' else
      if self.val = UInt32($1001) then Result := 'TEXTURE_HEIGHT' else
      if self.val = UInt32($1003) then Result := 'TEXTURE_INTERNAL_FORMAT' else
      if self.val = UInt32($1003) then Result := 'TEXTURE_COMPONENTS' else
      if self.val = UInt32($1004) then Result := 'TEXTURE_BORDER_COLOR' else
      if self.val = UInt32($1005) then Result := 'TEXTURE_BORDER' else
      if self.val = UInt32($2800) then Result := 'TEXTURE_MAG_FILTER' else
      if self.val = UInt32($2801) then Result := 'TEXTURE_MIN_FILTER' else
      if self.val = UInt32($2802) then Result := 'TEXTURE_WRAP_S' else
      if self.val = UInt32($2803) then Result := 'TEXTURE_WRAP_T' else
      if self.val = UInt32($805C) then Result := 'TEXTURE_RED_SIZE' else
      if self.val = UInt32($805D) then Result := 'TEXTURE_GREEN_SIZE' else
      if self.val = UInt32($805E) then Result := 'TEXTURE_BLUE_SIZE' else
      if self.val = UInt32($805F) then Result := 'TEXTURE_ALPHA_SIZE' else
      if self.val = UInt32($8060) then Result := 'TEXTURE_LUMINANCE_SIZE' else
      if self.val = UInt32($8061) then Result := 'TEXTURE_INTENSITY_SIZE' else
      if self.val = UInt32($8066) then Result := 'TEXTURE_PRIORITY' else
      if self.val = UInt32($8067) then Result := 'TEXTURE_RESIDENT' else
      if self.val = UInt32($8071) then Result := 'TEXTURE_DEPTH' else
      if self.val = UInt32($8072) then Result := 'TEXTURE_WRAP_R' else
      if self.val = UInt32($809A) then Result := 'DETAIL_TEXTURE_LEVEL' else
      if self.val = UInt32($809B) then Result := 'DETAIL_TEXTURE_MODE' else
      if self.val = UInt32($809C) then Result := 'DETAIL_TEXTURE_FUNC_POINTS' else
      if self.val = UInt32($80B0) then Result := 'SHARPEN_TEXTURE_FUNC_POINTS' else
      if self.val = UInt32($80BF) then Result := 'SHADOW_AMBIENT' else
      if self.val = UInt32($8124) then Result := 'DUAL_TEXTURE_SELECT' else
      if self.val = UInt32($8125) then Result := 'QUAD_TEXTURE_SELECT' else
      if self.val = UInt32($8136) then Result := 'TEXTURE_4DSIZE' else
      if self.val = UInt32($8137) then Result := 'TEXTURE_WRAP_Q' else
      if self.val = UInt32($813A) then Result := 'TEXTURE_MIN_LOD' else
      if self.val = UInt32($813B) then Result := 'TEXTURE_MAX_LOD' else
      if self.val = UInt32($813C) then Result := 'TEXTURE_BASE_LEVEL' else
      if self.val = UInt32($813D) then Result := 'TEXTURE_MAX_LEVEL' else
      if self.val = UInt32($8147) then Result := 'TEXTURE_FILTER4_SIZE' else
      if self.val = UInt32($8171) then Result := 'TEXTURE_CLIPMAP_CENTER' else
      if self.val = UInt32($8172) then Result := 'TEXTURE_CLIPMAP_FRAME' else
      if self.val = UInt32($8173) then Result := 'TEXTURE_CLIPMAP_OFFSET' else
      if self.val = UInt32($8174) then Result := 'TEXTURE_CLIPMAP_VIRTUAL_DEPTH' else
      if self.val = UInt32($8175) then Result := 'TEXTURE_CLIPMAP_LOD_OFFSET' else
      if self.val = UInt32($8176) then Result := 'TEXTURE_CLIPMAP_DEPTH' else
      if self.val = UInt32($8179) then Result := 'POST_TEXTURE_FILTER_BIAS' else
      if self.val = UInt32($817A) then Result := 'POST_TEXTURE_FILTER_SCALE' else
      if self.val = UInt32($818E) then Result := 'TEXTURE_LOD_BIAS_S' else
      if self.val = UInt32($818F) then Result := 'TEXTURE_LOD_BIAS_T' else
      if self.val = UInt32($8190) then Result := 'TEXTURE_LOD_BIAS_R' else
      if self.val = UInt32($8191) then Result := 'GENERATE_MIPMAP' else
      if self.val = UInt32($819A) then Result := 'TEXTURE_COMPARE' else
      if self.val = UInt32($819B) then Result := 'TEXTURE_COMPARE_OPERATOR' else
      if self.val = UInt32($819C) then Result := 'TEXTURE_LEQUAL_R' else
      if self.val = UInt32($819D) then Result := 'TEXTURE_GEQUAL_R' else
      if self.val = UInt32($8369) then Result := 'TEXTURE_MAX_CLAMP_S' else
      if self.val = UInt32($836A) then Result := 'TEXTURE_MAX_CLAMP_T' else
      if self.val = UInt32($836B) then Result := 'TEXTURE_MAX_CLAMP_R' else
      if self.val = UInt32($8511) then Result := 'NORMAL_MAP' else
      if self.val = UInt32($8512) then Result := 'REFLECTION_MAP' else
      if self.val = UInt32($8F6A) then Result := 'TEXTURE_UNNORMALIZED_COORDINATES_ARM' else
      if self.val = UInt32($96C0) then Result := 'SURFACE_COMPRESSION' else
        Result := $'GetTextureParameter[{self.val}]';
    end;
    
  end;
  
  GetVariantValue = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VARIANT_VALUE:        GetVariantValue read new GetVariantValue($87E4);
    public static property VARIANT_DATATYPE:     GetVariantValue read new GetVariantValue($87E5);
    public static property VARIANT_ARRAY_STRIDE: GetVariantValue read new GetVariantValue($87E6);
    public static property VARIANT_ARRAY_TYPE:   GetVariantValue read new GetVariantValue($87E7);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($87E4) then Result := 'VARIANT_VALUE' else
      if self.val = UInt32($87E5) then Result := 'VARIANT_DATATYPE' else
      if self.val = UInt32($87E6) then Result := 'VARIANT_ARRAY_STRIDE' else
      if self.val = UInt32($87E7) then Result := 'VARIANT_ARRAY_TYPE' else
        Result := $'GetVariantValue[{self.val}]';
    end;
    
  end;
  
  GPUDisplayDeviceFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ATTACHED_TO_DESKTOP: GPUDisplayDeviceFlags read new GPUDisplayDeviceFlags($0001);
    public static property PRIMARY_DEVICE:      GPUDisplayDeviceFlags read new GPUDisplayDeviceFlags($0004);
    
    public static function operator+(f1,f2: GPUDisplayDeviceFlags) := new GPUDisplayDeviceFlags(f1.val or f2.val);
    public static function operator or(f1,f2: GPUDisplayDeviceFlags) := f1+f2;
    
    public static procedure operator+=(var f1: GPUDisplayDeviceFlags; f2: GPUDisplayDeviceFlags) := f1 := f1+f2;
    
    public property HAS_FLAG_ATTACHED_TO_DESKTOP: boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_PRIMARY_DEVICE:      boolean read self.val and $0004 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'ATTACHED_TO_DESKTOP+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'PRIMARY_DEVICE+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'GPUDisplayDeviceFlags[{self.val}]';
    end;
    
  end;
  
  GraphicsResetStatus = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NO_ERROR:               GraphicsResetStatus read new GraphicsResetStatus($0000);
    public static property GUILTY_CONTEXT_RESET:   GraphicsResetStatus read new GraphicsResetStatus($8253);
    public static property INNOCENT_CONTEXT_RESET: GraphicsResetStatus read new GraphicsResetStatus($8254);
    public static property UNKNOWN_CONTEXT_RESET:  GraphicsResetStatus read new GraphicsResetStatus($8255);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NO_ERROR' else
      if self.val = UInt32($8253) then Result := 'GUILTY_CONTEXT_RESET' else
      if self.val = UInt32($8254) then Result := 'INNOCENT_CONTEXT_RESET' else
      if self.val = UInt32($8255) then Result := 'UNKNOWN_CONTEXT_RESET' else
        Result := $'GraphicsResetStatus[{self.val}]';
    end;
    
  end;
  
  HintMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DONT_CARE: HintMode read new HintMode($1100);
    public static property FASTEST:   HintMode read new HintMode($1101);
    public static property NICEST:    HintMode read new HintMode($1102);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1100) then Result := 'DONT_CARE' else
      if self.val = UInt32($1101) then Result := 'FASTEST' else
      if self.val = UInt32($1102) then Result := 'NICEST' else
        Result := $'HintMode[{self.val}]';
    end;
    
  end;
  
  HintTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PERSPECTIVE_CORRECTION_HINT:     HintTarget read new HintTarget($0C50);
    public static property POINT_SMOOTH_HINT:               HintTarget read new HintTarget($0C51);
    public static property LINE_SMOOTH_HINT:                HintTarget read new HintTarget($0C52);
    public static property POLYGON_SMOOTH_HINT:             HintTarget read new HintTarget($0C53);
    public static property FOG_HINT:                        HintTarget read new HintTarget($0C54);
    public static property PACK_CMYK_HINT:                  HintTarget read new HintTarget($800E);
    public static property UNPACK_CMYK_HINT:                HintTarget read new HintTarget($800F);
    public static property PHONG_HINT:                      HintTarget read new HintTarget($80EB);
    public static property CLIP_VOLUME_CLIPPING_HINT:       HintTarget read new HintTarget($80F0);
    public static property TEXTURE_MULTI_BUFFER_HINT:       HintTarget read new HintTarget($812E);
    public static property GENERATE_MIPMAP_HINT:            HintTarget read new HintTarget($8192);
    public static property PROGRAM_BINARY_RETRIEVABLE_HINT: HintTarget read new HintTarget($8257);
    public static property CONVOLUTION_HINT:                HintTarget read new HintTarget($8316);
    public static property SCALEBIAS_HINT:                  HintTarget read new HintTarget($8322);
    public static property LINE_QUALITY_HINT:               HintTarget read new HintTarget($835B);
    public static property VERTEX_PRECLIP:                  HintTarget read new HintTarget($83EE);
    public static property VERTEX_PRECLIP_HINT:             HintTarget read new HintTarget($83EF);
    public static property TEXTURE_COMPRESSION_HINT:        HintTarget read new HintTarget($84EF);
    public static property VERTEX_ARRAY_STORAGE_HINT:       HintTarget read new HintTarget($851F);
    public static property MULTISAMPLE_FILTER_HINT:         HintTarget read new HintTarget($8534);
    public static property TRANSFORM_HINT:                  HintTarget read new HintTarget($85B1);
    public static property TEXTURE_STORAGE_HINT:            HintTarget read new HintTarget($85BC);
    public static property FRAGMENT_SHADER_DERIVATIVE_HINT: HintTarget read new HintTarget($8B8B);
    public static property BINNING_CONTROL_HINT:            HintTarget read new HintTarget($8FB0);
    public static property PREFER_DOUBLEBUFFER_HINT:        HintTarget read new HintTarget($1A1F8);
    public static property CONSERVE_MEMORY_HINT:            HintTarget read new HintTarget($1A1FD);
    public static property RECLAIM_MEMORY_HINT:             HintTarget read new HintTarget($1A1FE);
    public static property NATIVE_GRAPHICS_BEGIN_HINT:      HintTarget read new HintTarget($1A203);
    public static property NATIVE_GRAPHICS_END_HINT:        HintTarget read new HintTarget($1A204);
    public static property ALWAYS_FAST_HINT:                HintTarget read new HintTarget($1A20C);
    public static property ALWAYS_SOFT_HINT:                HintTarget read new HintTarget($1A20D);
    public static property ALLOW_DRAW_OBJ_HINT:             HintTarget read new HintTarget($1A20E);
    public static property ALLOW_DRAW_WIN_HINT:             HintTarget read new HintTarget($1A20F);
    public static property ALLOW_DRAW_FRG_HINT:             HintTarget read new HintTarget($1A210);
    public static property ALLOW_DRAW_MEM_HINT:             HintTarget read new HintTarget($1A211);
    public static property STRICT_DEPTHFUNC_HINT:           HintTarget read new HintTarget($1A216);
    public static property STRICT_LIGHTING_HINT:            HintTarget read new HintTarget($1A217);
    public static property STRICT_SCISSOR_HINT:             HintTarget read new HintTarget($1A218);
    public static property FULL_STIPPLE_HINT:               HintTarget read new HintTarget($1A219);
    public static property CLIP_NEAR_HINT:                  HintTarget read new HintTarget($1A220);
    public static property CLIP_FAR_HINT:                   HintTarget read new HintTarget($1A221);
    public static property WIDE_LINE_HINT:                  HintTarget read new HintTarget($1A222);
    public static property BACK_NORMALS_HINT:               HintTarget read new HintTarget($1A223);
    public static property VERTEX_DATA_HINT:                HintTarget read new HintTarget($1A22A);
    public static property VERTEX_CONSISTENT_HINT:          HintTarget read new HintTarget($1A22B);
    public static property MATERIAL_SIDE_HINT:              HintTarget read new HintTarget($1A22C);
    public static property MAX_VERTEX_HINT:                 HintTarget read new HintTarget($1A22D);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0C50) then Result := 'PERSPECTIVE_CORRECTION_HINT' else
      if self.val = UInt32($0C51) then Result := 'POINT_SMOOTH_HINT' else
      if self.val = UInt32($0C52) then Result := 'LINE_SMOOTH_HINT' else
      if self.val = UInt32($0C53) then Result := 'POLYGON_SMOOTH_HINT' else
      if self.val = UInt32($0C54) then Result := 'FOG_HINT' else
      if self.val = UInt32($800E) then Result := 'PACK_CMYK_HINT' else
      if self.val = UInt32($800F) then Result := 'UNPACK_CMYK_HINT' else
      if self.val = UInt32($80EB) then Result := 'PHONG_HINT' else
      if self.val = UInt32($80F0) then Result := 'CLIP_VOLUME_CLIPPING_HINT' else
      if self.val = UInt32($812E) then Result := 'TEXTURE_MULTI_BUFFER_HINT' else
      if self.val = UInt32($8192) then Result := 'GENERATE_MIPMAP_HINT' else
      if self.val = UInt32($8257) then Result := 'PROGRAM_BINARY_RETRIEVABLE_HINT' else
      if self.val = UInt32($8316) then Result := 'CONVOLUTION_HINT' else
      if self.val = UInt32($8322) then Result := 'SCALEBIAS_HINT' else
      if self.val = UInt32($835B) then Result := 'LINE_QUALITY_HINT' else
      if self.val = UInt32($83EE) then Result := 'VERTEX_PRECLIP' else
      if self.val = UInt32($83EF) then Result := 'VERTEX_PRECLIP_HINT' else
      if self.val = UInt32($84EF) then Result := 'TEXTURE_COMPRESSION_HINT' else
      if self.val = UInt32($851F) then Result := 'VERTEX_ARRAY_STORAGE_HINT' else
      if self.val = UInt32($8534) then Result := 'MULTISAMPLE_FILTER_HINT' else
      if self.val = UInt32($85B1) then Result := 'TRANSFORM_HINT' else
      if self.val = UInt32($85BC) then Result := 'TEXTURE_STORAGE_HINT' else
      if self.val = UInt32($8B8B) then Result := 'FRAGMENT_SHADER_DERIVATIVE_HINT' else
      if self.val = UInt32($8FB0) then Result := 'BINNING_CONTROL_HINT' else
      if self.val = UInt32($1A1F8) then Result := 'PREFER_DOUBLEBUFFER_HINT' else
      if self.val = UInt32($1A1FD) then Result := 'CONSERVE_MEMORY_HINT' else
      if self.val = UInt32($1A1FE) then Result := 'RECLAIM_MEMORY_HINT' else
      if self.val = UInt32($1A203) then Result := 'NATIVE_GRAPHICS_BEGIN_HINT' else
      if self.val = UInt32($1A204) then Result := 'NATIVE_GRAPHICS_END_HINT' else
      if self.val = UInt32($1A20C) then Result := 'ALWAYS_FAST_HINT' else
      if self.val = UInt32($1A20D) then Result := 'ALWAYS_SOFT_HINT' else
      if self.val = UInt32($1A20E) then Result := 'ALLOW_DRAW_OBJ_HINT' else
      if self.val = UInt32($1A20F) then Result := 'ALLOW_DRAW_WIN_HINT' else
      if self.val = UInt32($1A210) then Result := 'ALLOW_DRAW_FRG_HINT' else
      if self.val = UInt32($1A211) then Result := 'ALLOW_DRAW_MEM_HINT' else
      if self.val = UInt32($1A216) then Result := 'STRICT_DEPTHFUNC_HINT' else
      if self.val = UInt32($1A217) then Result := 'STRICT_LIGHTING_HINT' else
      if self.val = UInt32($1A218) then Result := 'STRICT_SCISSOR_HINT' else
      if self.val = UInt32($1A219) then Result := 'FULL_STIPPLE_HINT' else
      if self.val = UInt32($1A220) then Result := 'CLIP_NEAR_HINT' else
      if self.val = UInt32($1A221) then Result := 'CLIP_FAR_HINT' else
      if self.val = UInt32($1A222) then Result := 'WIDE_LINE_HINT' else
      if self.val = UInt32($1A223) then Result := 'BACK_NORMALS_HINT' else
      if self.val = UInt32($1A22A) then Result := 'VERTEX_DATA_HINT' else
      if self.val = UInt32($1A22B) then Result := 'VERTEX_CONSISTENT_HINT' else
      if self.val = UInt32($1A22C) then Result := 'MATERIAL_SIDE_HINT' else
      if self.val = UInt32($1A22D) then Result := 'MAX_VERTEX_HINT' else
        Result := $'HintTarget[{self.val}]';
    end;
    
  end;
  
  HistogramTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property HISTOGRAM:       HistogramTarget read new HistogramTarget($8024);
    public static property PROXY_HISTOGRAM: HistogramTarget read new HistogramTarget($8025);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8024) then Result := 'HISTOGRAM' else
      if self.val = UInt32($8025) then Result := 'PROXY_HISTOGRAM' else
        Result := $'HistogramTarget[{self.val}]';
    end;
    
  end;
  
  ImageTransformPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property IMAGE_SCALE_X:         ImageTransformPName read new ImageTransformPName($8155);
    public static property IMAGE_SCALE_Y:         ImageTransformPName read new ImageTransformPName($8156);
    public static property IMAGE_TRANSLATE_X:     ImageTransformPName read new ImageTransformPName($8157);
    public static property IMAGE_TRANSLATE_Y:     ImageTransformPName read new ImageTransformPName($8158);
    public static property IMAGE_ROTATE_ANGLE:    ImageTransformPName read new ImageTransformPName($8159);
    public static property IMAGE_ROTATE_ORIGIN_X: ImageTransformPName read new ImageTransformPName($815A);
    public static property IMAGE_ROTATE_ORIGIN_Y: ImageTransformPName read new ImageTransformPName($815B);
    public static property IMAGE_MAG_FILTER:      ImageTransformPName read new ImageTransformPName($815C);
    public static property IMAGE_MIN_FILTER:      ImageTransformPName read new ImageTransformPName($815D);
    public static property IMAGE_CUBIC_WEIGHT:    ImageTransformPName read new ImageTransformPName($815E);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8155) then Result := 'IMAGE_SCALE_X' else
      if self.val = UInt32($8156) then Result := 'IMAGE_SCALE_Y' else
      if self.val = UInt32($8157) then Result := 'IMAGE_TRANSLATE_X' else
      if self.val = UInt32($8158) then Result := 'IMAGE_TRANSLATE_Y' else
      if self.val = UInt32($8159) then Result := 'IMAGE_ROTATE_ANGLE' else
      if self.val = UInt32($815A) then Result := 'IMAGE_ROTATE_ORIGIN_X' else
      if self.val = UInt32($815B) then Result := 'IMAGE_ROTATE_ORIGIN_Y' else
      if self.val = UInt32($815C) then Result := 'IMAGE_MAG_FILTER' else
      if self.val = UInt32($815D) then Result := 'IMAGE_MIN_FILTER' else
      if self.val = UInt32($815E) then Result := 'IMAGE_CUBIC_WEIGHT' else
        Result := $'ImageTransformPName[{self.val}]';
    end;
    
  end;
  
  ImageTransformTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property IMAGE_TRANSFORM_2D: ImageTransformTarget read new ImageTransformTarget($8161);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8161) then Result := 'IMAGE_TRANSFORM_2D' else
        Result := $'ImageTransformTarget[{self.val}]';
    end;
    
  end;
  
  IndexFunction = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEVER:    IndexFunction read new IndexFunction($0200);
    public static property LESS:     IndexFunction read new IndexFunction($0201);
    public static property EQUAL:    IndexFunction read new IndexFunction($0202);
    public static property LEQUAL:   IndexFunction read new IndexFunction($0203);
    public static property GREATER:  IndexFunction read new IndexFunction($0204);
    public static property NOTEQUAL: IndexFunction read new IndexFunction($0205);
    public static property GEQUAL:   IndexFunction read new IndexFunction($0206);
    public static property ALWAYS:   IndexFunction read new IndexFunction($0207);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0200) then Result := 'NEVER' else
      if self.val = UInt32($0201) then Result := 'LESS' else
      if self.val = UInt32($0202) then Result := 'EQUAL' else
      if self.val = UInt32($0203) then Result := 'LEQUAL' else
      if self.val = UInt32($0204) then Result := 'GREATER' else
      if self.val = UInt32($0205) then Result := 'NOTEQUAL' else
      if self.val = UInt32($0206) then Result := 'GEQUAL' else
      if self.val = UInt32($0207) then Result := 'ALWAYS' else
        Result := $'IndexFunction[{self.val}]';
    end;
    
  end;
  
  IndexMaterialParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property INDEX_OFFSET: IndexMaterialParameter read new IndexMaterialParameter($0D13);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0D13) then Result := 'INDEX_OFFSET' else
        Result := $'IndexMaterialParameter[{self.val}]';
    end;
    
  end;
  
  IndexPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SHORT:  IndexPointerType read new IndexPointerType($1402);
    public static property INT:    IndexPointerType read new IndexPointerType($1404);
    public static property FLOAT:  IndexPointerType read new IndexPointerType($1406);
    public static property DOUBLE: IndexPointerType read new IndexPointerType($140A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := $'IndexPointerType[{self.val}]';
    end;
    
  end;
  
  InstancedPathCoverMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PATH_FILL_COVER_MODE:           InstancedPathCoverMode read new InstancedPathCoverMode($9082);
    public static property CONVEX_HULL:                    InstancedPathCoverMode read new InstancedPathCoverMode($908B);
    public static property BOUNDING_BOX:                   InstancedPathCoverMode read new InstancedPathCoverMode($908D);
    public static property BOUNDING_BOX_OF_BOUNDING_BOXES: InstancedPathCoverMode read new InstancedPathCoverMode($909C);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9082) then Result := 'PATH_FILL_COVER_MODE' else
      if self.val = UInt32($908B) then Result := 'CONVEX_HULL' else
      if self.val = UInt32($908D) then Result := 'BOUNDING_BOX' else
      if self.val = UInt32($909C) then Result := 'BOUNDING_BOX_OF_BOUNDING_BOXES' else
        Result := $'InstancedPathCoverMode[{self.val}]';
    end;
    
  end;
  
  InterleavedArrayFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property V2F:             InterleavedArrayFormat read new InterleavedArrayFormat($2A20);
    public static property V3F:             InterleavedArrayFormat read new InterleavedArrayFormat($2A21);
    public static property C4UB_V2F:        InterleavedArrayFormat read new InterleavedArrayFormat($2A22);
    public static property C4UB_V3F:        InterleavedArrayFormat read new InterleavedArrayFormat($2A23);
    public static property C3F_V3F:         InterleavedArrayFormat read new InterleavedArrayFormat($2A24);
    public static property N3F_V3F:         InterleavedArrayFormat read new InterleavedArrayFormat($2A25);
    public static property C4F_N3F_V3F:     InterleavedArrayFormat read new InterleavedArrayFormat($2A26);
    public static property T2F_V3F:         InterleavedArrayFormat read new InterleavedArrayFormat($2A27);
    public static property T4F_V4F:         InterleavedArrayFormat read new InterleavedArrayFormat($2A28);
    public static property T2F_C4UB_V3F:    InterleavedArrayFormat read new InterleavedArrayFormat($2A29);
    public static property T2F_C3F_V3F:     InterleavedArrayFormat read new InterleavedArrayFormat($2A2A);
    public static property T2F_N3F_V3F:     InterleavedArrayFormat read new InterleavedArrayFormat($2A2B);
    public static property T2F_C4F_N3F_V3F: InterleavedArrayFormat read new InterleavedArrayFormat($2A2C);
    public static property T4F_C4F_N3F_V4F: InterleavedArrayFormat read new InterleavedArrayFormat($2A2D);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2A20) then Result := 'V2F' else
      if self.val = UInt32($2A21) then Result := 'V3F' else
      if self.val = UInt32($2A22) then Result := 'C4UB_V2F' else
      if self.val = UInt32($2A23) then Result := 'C4UB_V3F' else
      if self.val = UInt32($2A24) then Result := 'C3F_V3F' else
      if self.val = UInt32($2A25) then Result := 'N3F_V3F' else
      if self.val = UInt32($2A26) then Result := 'C4F_N3F_V3F' else
      if self.val = UInt32($2A27) then Result := 'T2F_V3F' else
      if self.val = UInt32($2A28) then Result := 'T4F_V4F' else
      if self.val = UInt32($2A29) then Result := 'T2F_C4UB_V3F' else
      if self.val = UInt32($2A2A) then Result := 'T2F_C3F_V3F' else
      if self.val = UInt32($2A2B) then Result := 'T2F_N3F_V3F' else
      if self.val = UInt32($2A2C) then Result := 'T2F_C4F_N3F_V3F' else
      if self.val = UInt32($2A2D) then Result := 'T4F_C4F_N3F_V4F' else
        Result := $'InterleavedArrayFormat[{self.val}]';
    end;
    
  end;
  
  InternalFormat = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property STENCIL_INDEX:                             InternalFormat read new InternalFormat($1901);
    public static property DEPTH_COMPONENT:                           InternalFormat read new InternalFormat($1902);
    public static property RED:                                       InternalFormat read new InternalFormat($1903);
    public static property RGB:                                       InternalFormat read new InternalFormat($1907);
    public static property RGBA:                                      InternalFormat read new InternalFormat($1908);
    public static property R3_G3_B2:                                  InternalFormat read new InternalFormat($2A10);
    public static property ALPHA4:                                    InternalFormat read new InternalFormat($803B);
    public static property ALPHA8:                                    InternalFormat read new InternalFormat($803C);
    public static property ALPHA12:                                   InternalFormat read new InternalFormat($803D);
    public static property ALPHA16:                                   InternalFormat read new InternalFormat($803E);
    public static property LUMINANCE4:                                InternalFormat read new InternalFormat($803F);
    public static property LUMINANCE8:                                InternalFormat read new InternalFormat($8040);
    public static property LUMINANCE12:                               InternalFormat read new InternalFormat($8041);
    public static property LUMINANCE16:                               InternalFormat read new InternalFormat($8042);
    public static property LUMINANCE4_ALPHA4:                         InternalFormat read new InternalFormat($8043);
    public static property LUMINANCE6_ALPHA2:                         InternalFormat read new InternalFormat($8044);
    public static property LUMINANCE8_ALPHA8:                         InternalFormat read new InternalFormat($8045);
    public static property LUMINANCE12_ALPHA4:                        InternalFormat read new InternalFormat($8046);
    public static property LUMINANCE12_ALPHA12:                       InternalFormat read new InternalFormat($8047);
    public static property LUMINANCE16_ALPHA16:                       InternalFormat read new InternalFormat($8048);
    public static property INTENSITY:                                 InternalFormat read new InternalFormat($8049);
    public static property INTENSITY4:                                InternalFormat read new InternalFormat($804A);
    public static property INTENSITY8:                                InternalFormat read new InternalFormat($804B);
    public static property INTENSITY12:                               InternalFormat read new InternalFormat($804C);
    public static property INTENSITY16:                               InternalFormat read new InternalFormat($804D);
    public static property RGB2:                                      InternalFormat read new InternalFormat($804E);
    public static property RGB4:                                      InternalFormat read new InternalFormat($804F);
    public static property RGB5:                                      InternalFormat read new InternalFormat($8050);
    public static property RGB8:                                      InternalFormat read new InternalFormat($8051);
    public static property RGB10:                                     InternalFormat read new InternalFormat($8052);
    public static property RGB12:                                     InternalFormat read new InternalFormat($8053);
    public static property RGB16:                                     InternalFormat read new InternalFormat($8054);
    public static property RGBA2:                                     InternalFormat read new InternalFormat($8055);
    public static property RGBA4:                                     InternalFormat read new InternalFormat($8056);
    public static property RGB5_A1:                                   InternalFormat read new InternalFormat($8057);
    public static property RGBA8:                                     InternalFormat read new InternalFormat($8058);
    public static property RGB10_A2:                                  InternalFormat read new InternalFormat($8059);
    public static property RGBA12:                                    InternalFormat read new InternalFormat($805A);
    public static property RGBA16:                                    InternalFormat read new InternalFormat($805B);
    public static property DUAL_ALPHA4:                               InternalFormat read new InternalFormat($8110);
    public static property DUAL_ALPHA8:                               InternalFormat read new InternalFormat($8111);
    public static property DUAL_ALPHA12:                              InternalFormat read new InternalFormat($8112);
    public static property DUAL_ALPHA16:                              InternalFormat read new InternalFormat($8113);
    public static property DUAL_LUMINANCE4:                           InternalFormat read new InternalFormat($8114);
    public static property DUAL_LUMINANCE8:                           InternalFormat read new InternalFormat($8115);
    public static property DUAL_LUMINANCE12:                          InternalFormat read new InternalFormat($8116);
    public static property DUAL_LUMINANCE16:                          InternalFormat read new InternalFormat($8117);
    public static property DUAL_INTENSITY4:                           InternalFormat read new InternalFormat($8118);
    public static property DUAL_INTENSITY8:                           InternalFormat read new InternalFormat($8119);
    public static property DUAL_INTENSITY12:                          InternalFormat read new InternalFormat($811A);
    public static property DUAL_INTENSITY16:                          InternalFormat read new InternalFormat($811B);
    public static property DUAL_LUMINANCE_ALPHA4:                     InternalFormat read new InternalFormat($811C);
    public static property DUAL_LUMINANCE_ALPHA8:                     InternalFormat read new InternalFormat($811D);
    public static property QUAD_ALPHA4:                               InternalFormat read new InternalFormat($811E);
    public static property QUAD_ALPHA8:                               InternalFormat read new InternalFormat($811F);
    public static property QUAD_LUMINANCE4:                           InternalFormat read new InternalFormat($8120);
    public static property QUAD_LUMINANCE8:                           InternalFormat read new InternalFormat($8121);
    public static property QUAD_INTENSITY4:                           InternalFormat read new InternalFormat($8122);
    public static property QUAD_INTENSITY8:                           InternalFormat read new InternalFormat($8123);
    public static property DEPTH_COMPONENT16:                         InternalFormat read new InternalFormat($81A5);
    public static property DEPTH_COMPONENT24:                         InternalFormat read new InternalFormat($81A6);
    public static property DEPTH_COMPONENT32:                         InternalFormat read new InternalFormat($81A7);
    public static property COMPRESSED_RED:                            InternalFormat read new InternalFormat($8225);
    public static property COMPRESSED_RG:                             InternalFormat read new InternalFormat($8226);
    public static property RG:                                        InternalFormat read new InternalFormat($8227);
    public static property R8:                                        InternalFormat read new InternalFormat($8229);
    public static property R16:                                       InternalFormat read new InternalFormat($822A);
    public static property RG8:                                       InternalFormat read new InternalFormat($822B);
    public static property RG16:                                      InternalFormat read new InternalFormat($822C);
    public static property R16F:                                      InternalFormat read new InternalFormat($822D);
    public static property R32F:                                      InternalFormat read new InternalFormat($822E);
    public static property RG16F:                                     InternalFormat read new InternalFormat($822F);
    public static property RG32F:                                     InternalFormat read new InternalFormat($8230);
    public static property R8I:                                       InternalFormat read new InternalFormat($8231);
    public static property R8UI:                                      InternalFormat read new InternalFormat($8232);
    public static property R16I:                                      InternalFormat read new InternalFormat($8233);
    public static property R16UI:                                     InternalFormat read new InternalFormat($8234);
    public static property R32I:                                      InternalFormat read new InternalFormat($8235);
    public static property R32UI:                                     InternalFormat read new InternalFormat($8236);
    public static property RG8I:                                      InternalFormat read new InternalFormat($8237);
    public static property RG8UI:                                     InternalFormat read new InternalFormat($8238);
    public static property RG16I:                                     InternalFormat read new InternalFormat($8239);
    public static property RG16UI:                                    InternalFormat read new InternalFormat($823A);
    public static property RG32I:                                     InternalFormat read new InternalFormat($823B);
    public static property RG32UI:                                    InternalFormat read new InternalFormat($823C);
    public static property COMPRESSED_RGB_S3TC_DXT1:                  InternalFormat read new InternalFormat($83F0);
    public static property COMPRESSED_RGBA_S3TC_DXT1:                 InternalFormat read new InternalFormat($83F1);
    public static property COMPRESSED_RGBA_S3TC_DXT3:                 InternalFormat read new InternalFormat($83F2);
    public static property COMPRESSED_RGBA_S3TC_DXT5:                 InternalFormat read new InternalFormat($83F3);
    public static property COMPRESSED_RGB:                            InternalFormat read new InternalFormat($84ED);
    public static property COMPRESSED_RGBA:                           InternalFormat read new InternalFormat($84EE);
    public static property DEPTH_STENCIL:                             InternalFormat read new InternalFormat($84F9);
    public static property DEPTH_STENCIL_MESA:                        InternalFormat read new InternalFormat($8750);
    public static property RGBA32F:                                   InternalFormat read new InternalFormat($8814);
    public static property RGB32F:                                    InternalFormat read new InternalFormat($8815);
    public static property RGBA16F:                                   InternalFormat read new InternalFormat($881A);
    public static property RGB16F:                                    InternalFormat read new InternalFormat($881B);
    public static property DEPTH24_STENCIL8:                          InternalFormat read new InternalFormat($88F0);
    public static property R11F_G11F_B10F:                            InternalFormat read new InternalFormat($8C3A);
    public static property RGB9_E5:                                   InternalFormat read new InternalFormat($8C3D);
    public static property SRGB:                                      InternalFormat read new InternalFormat($8C40);
    public static property SRGB8:                                     InternalFormat read new InternalFormat($8C41);
    public static property SRGB_ALPHA:                                InternalFormat read new InternalFormat($8C42);
    public static property SRGB8_ALPHA8:                              InternalFormat read new InternalFormat($8C43);
    public static property COMPRESSED_SRGB:                           InternalFormat read new InternalFormat($8C48);
    public static property COMPRESSED_SRGB_ALPHA:                     InternalFormat read new InternalFormat($8C49);
    public static property COMPRESSED_SRGB_S3TC_DXT1:                 InternalFormat read new InternalFormat($8C4C);
    public static property COMPRESSED_SRGB_ALPHA_S3TC_DXT1:           InternalFormat read new InternalFormat($8C4D);
    public static property COMPRESSED_SRGB_ALPHA_S3TC_DXT3:           InternalFormat read new InternalFormat($8C4E);
    public static property COMPRESSED_SRGB_ALPHA_S3TC_DXT5:           InternalFormat read new InternalFormat($8C4F);
    public static property DEPTH_COMPONENT32F:                        InternalFormat read new InternalFormat($8CAC);
    public static property DEPTH32F_STENCIL8:                         InternalFormat read new InternalFormat($8CAD);
    public static property STENCIL_INDEX1:                            InternalFormat read new InternalFormat($8D46);
    public static property STENCIL_INDEX4:                            InternalFormat read new InternalFormat($8D47);
    public static property STENCIL_INDEX8:                            InternalFormat read new InternalFormat($8D48);
    public static property STENCIL_INDEX16:                           InternalFormat read new InternalFormat($8D49);
    public static property RGB565:                                    InternalFormat read new InternalFormat($8D62);
    public static property ETC1_RGB8:                                 InternalFormat read new InternalFormat($8D64);
    public static property RGBA32UI:                                  InternalFormat read new InternalFormat($8D70);
    public static property RGB32UI:                                   InternalFormat read new InternalFormat($8D71);
    public static property ALPHA32UI:                                 InternalFormat read new InternalFormat($8D72);
    public static property INTENSITY32UI:                             InternalFormat read new InternalFormat($8D73);
    public static property LUMINANCE32UI:                             InternalFormat read new InternalFormat($8D74);
    public static property LUMINANCE_ALPHA32UI:                       InternalFormat read new InternalFormat($8D75);
    public static property RGBA16UI:                                  InternalFormat read new InternalFormat($8D76);
    public static property RGB16UI:                                   InternalFormat read new InternalFormat($8D77);
    public static property ALPHA16UI:                                 InternalFormat read new InternalFormat($8D78);
    public static property INTENSITY16UI:                             InternalFormat read new InternalFormat($8D79);
    public static property LUMINANCE16UI:                             InternalFormat read new InternalFormat($8D7A);
    public static property LUMINANCE_ALPHA16UI:                       InternalFormat read new InternalFormat($8D7B);
    public static property RGBA8UI:                                   InternalFormat read new InternalFormat($8D7C);
    public static property RGB8UI:                                    InternalFormat read new InternalFormat($8D7D);
    public static property ALPHA8UI:                                  InternalFormat read new InternalFormat($8D7E);
    public static property INTENSITY8UI:                              InternalFormat read new InternalFormat($8D7F);
    public static property LUMINANCE8UI:                              InternalFormat read new InternalFormat($8D80);
    public static property LUMINANCE_ALPHA8UI:                        InternalFormat read new InternalFormat($8D81);
    public static property RGBA32I:                                   InternalFormat read new InternalFormat($8D82);
    public static property RGB32I:                                    InternalFormat read new InternalFormat($8D83);
    public static property ALPHA32I:                                  InternalFormat read new InternalFormat($8D84);
    public static property INTENSITY32I:                              InternalFormat read new InternalFormat($8D85);
    public static property LUMINANCE32I:                              InternalFormat read new InternalFormat($8D86);
    public static property LUMINANCE_ALPHA32I:                        InternalFormat read new InternalFormat($8D87);
    public static property RGBA16I:                                   InternalFormat read new InternalFormat($8D88);
    public static property RGB16I:                                    InternalFormat read new InternalFormat($8D89);
    public static property ALPHA16I:                                  InternalFormat read new InternalFormat($8D8A);
    public static property INTENSITY16I:                              InternalFormat read new InternalFormat($8D8B);
    public static property LUMINANCE16I:                              InternalFormat read new InternalFormat($8D8C);
    public static property LUMINANCE_ALPHA16I:                        InternalFormat read new InternalFormat($8D8D);
    public static property RGBA8I:                                    InternalFormat read new InternalFormat($8D8E);
    public static property RGB8I:                                     InternalFormat read new InternalFormat($8D8F);
    public static property ALPHA8I:                                   InternalFormat read new InternalFormat($8D90);
    public static property INTENSITY8I:                               InternalFormat read new InternalFormat($8D91);
    public static property LUMINANCE8I:                               InternalFormat read new InternalFormat($8D92);
    public static property LUMINANCE_ALPHA8I:                         InternalFormat read new InternalFormat($8D93);
    public static property DEPTH_COMPONENT32F_NV:                     InternalFormat read new InternalFormat($8DAB);
    public static property DEPTH32F_STENCIL8_NV:                      InternalFormat read new InternalFormat($8DAC);
    public static property COMPRESSED_RED_RGTC1:                      InternalFormat read new InternalFormat($8DBB);
    public static property COMPRESSED_SIGNED_RED_RGTC1:               InternalFormat read new InternalFormat($8DBC);
    public static property COMPRESSED_RED_GREEN_RGTC2:                InternalFormat read new InternalFormat($8DBD);
    public static property COMPRESSED_RG_RGTC2:                       InternalFormat read new InternalFormat($8DBD);
    public static property COMPRESSED_SIGNED_RED_GREEN_RGTC2:         InternalFormat read new InternalFormat($8DBE);
    public static property COMPRESSED_SIGNED_RG_RGTC2:                InternalFormat read new InternalFormat($8DBE);
    public static property COMPRESSED_RGBA_BPTC_UNORM:                InternalFormat read new InternalFormat($8E8C);
    public static property COMPRESSED_SRGB_ALPHA_BPTC_UNORM:          InternalFormat read new InternalFormat($8E8D);
    public static property COMPRESSED_RGB_BPTC_SIGNED_FLOAT:          InternalFormat read new InternalFormat($8E8E);
    public static property COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:        InternalFormat read new InternalFormat($8E8F);
    public static property R8_SNORM:                                  InternalFormat read new InternalFormat($8F94);
    public static property RG8_SNORM:                                 InternalFormat read new InternalFormat($8F95);
    public static property RGB8_SNORM:                                InternalFormat read new InternalFormat($8F96);
    public static property RGBA8_SNORM:                               InternalFormat read new InternalFormat($8F97);
    public static property R16_SNORM:                                 InternalFormat read new InternalFormat($8F98);
    public static property RG16_SNORM:                                InternalFormat read new InternalFormat($8F99);
    public static property RGB16_SNORM:                               InternalFormat read new InternalFormat($8F9A);
    public static property RGBA16_SNORM:                              InternalFormat read new InternalFormat($8F9B);
    public static property SR8:                                       InternalFormat read new InternalFormat($8FBD);
    public static property SRG8:                                      InternalFormat read new InternalFormat($8FBE);
    public static property RGB10_A2UI:                                InternalFormat read new InternalFormat($906F);
    public static property COMPRESSED_R11_EAC:                        InternalFormat read new InternalFormat($9270);
    public static property COMPRESSED_SIGNED_R11_EAC:                 InternalFormat read new InternalFormat($9271);
    public static property COMPRESSED_RG11_EAC:                       InternalFormat read new InternalFormat($9272);
    public static property COMPRESSED_SIGNED_RG11_EAC:                InternalFormat read new InternalFormat($9273);
    public static property COMPRESSED_RGB8_ETC2:                      InternalFormat read new InternalFormat($9274);
    public static property COMPRESSED_SRGB8_ETC2:                     InternalFormat read new InternalFormat($9275);
    public static property COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:  InternalFormat read new InternalFormat($9276);
    public static property COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: InternalFormat read new InternalFormat($9277);
    public static property COMPRESSED_RGBA8_ETC2_EAC:                 InternalFormat read new InternalFormat($9278);
    public static property COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:          InternalFormat read new InternalFormat($9279);
    public static property COMPRESSED_RGBA_ASTC_4x4:                  InternalFormat read new InternalFormat($93B0);
    public static property COMPRESSED_RGBA_ASTC_5x4:                  InternalFormat read new InternalFormat($93B1);
    public static property COMPRESSED_RGBA_ASTC_5x5:                  InternalFormat read new InternalFormat($93B2);
    public static property COMPRESSED_RGBA_ASTC_6x5:                  InternalFormat read new InternalFormat($93B3);
    public static property COMPRESSED_RGBA_ASTC_6x6:                  InternalFormat read new InternalFormat($93B4);
    public static property COMPRESSED_RGBA_ASTC_8x5:                  InternalFormat read new InternalFormat($93B5);
    public static property COMPRESSED_RGBA_ASTC_8x6:                  InternalFormat read new InternalFormat($93B6);
    public static property COMPRESSED_RGBA_ASTC_8x8:                  InternalFormat read new InternalFormat($93B7);
    public static property COMPRESSED_RGBA_ASTC_10x5:                 InternalFormat read new InternalFormat($93B8);
    public static property COMPRESSED_RGBA_ASTC_10x6:                 InternalFormat read new InternalFormat($93B9);
    public static property COMPRESSED_RGBA_ASTC_10x8:                 InternalFormat read new InternalFormat($93BA);
    public static property COMPRESSED_RGBA_ASTC_10x10:                InternalFormat read new InternalFormat($93BB);
    public static property COMPRESSED_RGBA_ASTC_12x10:                InternalFormat read new InternalFormat($93BC);
    public static property COMPRESSED_RGBA_ASTC_12x12:                InternalFormat read new InternalFormat($93BD);
    public static property COMPRESSED_RGBA_ASTC_3x3x3:                InternalFormat read new InternalFormat($93C0);
    public static property COMPRESSED_RGBA_ASTC_4x3x3:                InternalFormat read new InternalFormat($93C1);
    public static property COMPRESSED_RGBA_ASTC_4x4x3:                InternalFormat read new InternalFormat($93C2);
    public static property COMPRESSED_RGBA_ASTC_4x4x4:                InternalFormat read new InternalFormat($93C3);
    public static property COMPRESSED_RGBA_ASTC_5x4x4:                InternalFormat read new InternalFormat($93C4);
    public static property COMPRESSED_RGBA_ASTC_5x5x4:                InternalFormat read new InternalFormat($93C5);
    public static property COMPRESSED_RGBA_ASTC_5x5x5:                InternalFormat read new InternalFormat($93C6);
    public static property COMPRESSED_RGBA_ASTC_6x5x5:                InternalFormat read new InternalFormat($93C7);
    public static property COMPRESSED_RGBA_ASTC_6x6x5:                InternalFormat read new InternalFormat($93C8);
    public static property COMPRESSED_RGBA_ASTC_6x6x6:                InternalFormat read new InternalFormat($93C9);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x4:          InternalFormat read new InternalFormat($93D0);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x4:          InternalFormat read new InternalFormat($93D1);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x5:          InternalFormat read new InternalFormat($93D2);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x5:          InternalFormat read new InternalFormat($93D3);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x6:          InternalFormat read new InternalFormat($93D4);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x5:          InternalFormat read new InternalFormat($93D5);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x6:          InternalFormat read new InternalFormat($93D6);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x8:          InternalFormat read new InternalFormat($93D7);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x5:         InternalFormat read new InternalFormat($93D8);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x6:         InternalFormat read new InternalFormat($93D9);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x8:         InternalFormat read new InternalFormat($93DA);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x10:        InternalFormat read new InternalFormat($93DB);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_12x10:        InternalFormat read new InternalFormat($93DC);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_12x12:        InternalFormat read new InternalFormat($93DD);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3:        InternalFormat read new InternalFormat($93E0);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3:        InternalFormat read new InternalFormat($93E1);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3:        InternalFormat read new InternalFormat($93E2);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4:        InternalFormat read new InternalFormat($93E3);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4:        InternalFormat read new InternalFormat($93E4);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4:        InternalFormat read new InternalFormat($93E5);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5:        InternalFormat read new InternalFormat($93E6);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5:        InternalFormat read new InternalFormat($93E7);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5:        InternalFormat read new InternalFormat($93E8);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6:        InternalFormat read new InternalFormat($93E9);
    
    public function ToString: string; override;
    begin
      if self.val = Int32($1901) then Result := 'STENCIL_INDEX' else
      if self.val = Int32($1902) then Result := 'DEPTH_COMPONENT' else
      if self.val = Int32($1903) then Result := 'RED' else
      if self.val = Int32($1907) then Result := 'RGB' else
      if self.val = Int32($1908) then Result := 'RGBA' else
      if self.val = Int32($2A10) then Result := 'R3_G3_B2' else
      if self.val = Int32($803B) then Result := 'ALPHA4' else
      if self.val = Int32($803C) then Result := 'ALPHA8' else
      if self.val = Int32($803D) then Result := 'ALPHA12' else
      if self.val = Int32($803E) then Result := 'ALPHA16' else
      if self.val = Int32($803F) then Result := 'LUMINANCE4' else
      if self.val = Int32($8040) then Result := 'LUMINANCE8' else
      if self.val = Int32($8041) then Result := 'LUMINANCE12' else
      if self.val = Int32($8042) then Result := 'LUMINANCE16' else
      if self.val = Int32($8043) then Result := 'LUMINANCE4_ALPHA4' else
      if self.val = Int32($8044) then Result := 'LUMINANCE6_ALPHA2' else
      if self.val = Int32($8045) then Result := 'LUMINANCE8_ALPHA8' else
      if self.val = Int32($8046) then Result := 'LUMINANCE12_ALPHA4' else
      if self.val = Int32($8047) then Result := 'LUMINANCE12_ALPHA12' else
      if self.val = Int32($8048) then Result := 'LUMINANCE16_ALPHA16' else
      if self.val = Int32($8049) then Result := 'INTENSITY' else
      if self.val = Int32($804A) then Result := 'INTENSITY4' else
      if self.val = Int32($804B) then Result := 'INTENSITY8' else
      if self.val = Int32($804C) then Result := 'INTENSITY12' else
      if self.val = Int32($804D) then Result := 'INTENSITY16' else
      if self.val = Int32($804E) then Result := 'RGB2' else
      if self.val = Int32($804F) then Result := 'RGB4' else
      if self.val = Int32($8050) then Result := 'RGB5' else
      if self.val = Int32($8051) then Result := 'RGB8' else
      if self.val = Int32($8052) then Result := 'RGB10' else
      if self.val = Int32($8053) then Result := 'RGB12' else
      if self.val = Int32($8054) then Result := 'RGB16' else
      if self.val = Int32($8055) then Result := 'RGBA2' else
      if self.val = Int32($8056) then Result := 'RGBA4' else
      if self.val = Int32($8057) then Result := 'RGB5_A1' else
      if self.val = Int32($8058) then Result := 'RGBA8' else
      if self.val = Int32($8059) then Result := 'RGB10_A2' else
      if self.val = Int32($805A) then Result := 'RGBA12' else
      if self.val = Int32($805B) then Result := 'RGBA16' else
      if self.val = Int32($8110) then Result := 'DUAL_ALPHA4' else
      if self.val = Int32($8111) then Result := 'DUAL_ALPHA8' else
      if self.val = Int32($8112) then Result := 'DUAL_ALPHA12' else
      if self.val = Int32($8113) then Result := 'DUAL_ALPHA16' else
      if self.val = Int32($8114) then Result := 'DUAL_LUMINANCE4' else
      if self.val = Int32($8115) then Result := 'DUAL_LUMINANCE8' else
      if self.val = Int32($8116) then Result := 'DUAL_LUMINANCE12' else
      if self.val = Int32($8117) then Result := 'DUAL_LUMINANCE16' else
      if self.val = Int32($8118) then Result := 'DUAL_INTENSITY4' else
      if self.val = Int32($8119) then Result := 'DUAL_INTENSITY8' else
      if self.val = Int32($811A) then Result := 'DUAL_INTENSITY12' else
      if self.val = Int32($811B) then Result := 'DUAL_INTENSITY16' else
      if self.val = Int32($811C) then Result := 'DUAL_LUMINANCE_ALPHA4' else
      if self.val = Int32($811D) then Result := 'DUAL_LUMINANCE_ALPHA8' else
      if self.val = Int32($811E) then Result := 'QUAD_ALPHA4' else
      if self.val = Int32($811F) then Result := 'QUAD_ALPHA8' else
      if self.val = Int32($8120) then Result := 'QUAD_LUMINANCE4' else
      if self.val = Int32($8121) then Result := 'QUAD_LUMINANCE8' else
      if self.val = Int32($8122) then Result := 'QUAD_INTENSITY4' else
      if self.val = Int32($8123) then Result := 'QUAD_INTENSITY8' else
      if self.val = Int32($81A5) then Result := 'DEPTH_COMPONENT16' else
      if self.val = Int32($81A6) then Result := 'DEPTH_COMPONENT24' else
      if self.val = Int32($81A7) then Result := 'DEPTH_COMPONENT32' else
      if self.val = Int32($8225) then Result := 'COMPRESSED_RED' else
      if self.val = Int32($8226) then Result := 'COMPRESSED_RG' else
      if self.val = Int32($8227) then Result := 'RG' else
      if self.val = Int32($8229) then Result := 'R8' else
      if self.val = Int32($822A) then Result := 'R16' else
      if self.val = Int32($822B) then Result := 'RG8' else
      if self.val = Int32($822C) then Result := 'RG16' else
      if self.val = Int32($822D) then Result := 'R16F' else
      if self.val = Int32($822E) then Result := 'R32F' else
      if self.val = Int32($822F) then Result := 'RG16F' else
      if self.val = Int32($8230) then Result := 'RG32F' else
      if self.val = Int32($8231) then Result := 'R8I' else
      if self.val = Int32($8232) then Result := 'R8UI' else
      if self.val = Int32($8233) then Result := 'R16I' else
      if self.val = Int32($8234) then Result := 'R16UI' else
      if self.val = Int32($8235) then Result := 'R32I' else
      if self.val = Int32($8236) then Result := 'R32UI' else
      if self.val = Int32($8237) then Result := 'RG8I' else
      if self.val = Int32($8238) then Result := 'RG8UI' else
      if self.val = Int32($8239) then Result := 'RG16I' else
      if self.val = Int32($823A) then Result := 'RG16UI' else
      if self.val = Int32($823B) then Result := 'RG32I' else
      if self.val = Int32($823C) then Result := 'RG32UI' else
      if self.val = Int32($83F0) then Result := 'COMPRESSED_RGB_S3TC_DXT1' else
      if self.val = Int32($83F1) then Result := 'COMPRESSED_RGBA_S3TC_DXT1' else
      if self.val = Int32($83F2) then Result := 'COMPRESSED_RGBA_S3TC_DXT3' else
      if self.val = Int32($83F3) then Result := 'COMPRESSED_RGBA_S3TC_DXT5' else
      if self.val = Int32($84ED) then Result := 'COMPRESSED_RGB' else
      if self.val = Int32($84EE) then Result := 'COMPRESSED_RGBA' else
      if self.val = Int32($84F9) then Result := 'DEPTH_STENCIL' else
      if self.val = Int32($8750) then Result := 'DEPTH_STENCIL_MESA' else
      if self.val = Int32($8814) then Result := 'RGBA32F' else
      if self.val = Int32($8815) then Result := 'RGB32F' else
      if self.val = Int32($881A) then Result := 'RGBA16F' else
      if self.val = Int32($881B) then Result := 'RGB16F' else
      if self.val = Int32($88F0) then Result := 'DEPTH24_STENCIL8' else
      if self.val = Int32($8C3A) then Result := 'R11F_G11F_B10F' else
      if self.val = Int32($8C3D) then Result := 'RGB9_E5' else
      if self.val = Int32($8C40) then Result := 'SRGB' else
      if self.val = Int32($8C41) then Result := 'SRGB8' else
      if self.val = Int32($8C42) then Result := 'SRGB_ALPHA' else
      if self.val = Int32($8C43) then Result := 'SRGB8_ALPHA8' else
      if self.val = Int32($8C48) then Result := 'COMPRESSED_SRGB' else
      if self.val = Int32($8C49) then Result := 'COMPRESSED_SRGB_ALPHA' else
      if self.val = Int32($8C4C) then Result := 'COMPRESSED_SRGB_S3TC_DXT1' else
      if self.val = Int32($8C4D) then Result := 'COMPRESSED_SRGB_ALPHA_S3TC_DXT1' else
      if self.val = Int32($8C4E) then Result := 'COMPRESSED_SRGB_ALPHA_S3TC_DXT3' else
      if self.val = Int32($8C4F) then Result := 'COMPRESSED_SRGB_ALPHA_S3TC_DXT5' else
      if self.val = Int32($8CAC) then Result := 'DEPTH_COMPONENT32F' else
      if self.val = Int32($8CAD) then Result := 'DEPTH32F_STENCIL8' else
      if self.val = Int32($8D46) then Result := 'STENCIL_INDEX1' else
      if self.val = Int32($8D47) then Result := 'STENCIL_INDEX4' else
      if self.val = Int32($8D48) then Result := 'STENCIL_INDEX8' else
      if self.val = Int32($8D49) then Result := 'STENCIL_INDEX16' else
      if self.val = Int32($8D62) then Result := 'RGB565' else
      if self.val = Int32($8D64) then Result := 'ETC1_RGB8' else
      if self.val = Int32($8D70) then Result := 'RGBA32UI' else
      if self.val = Int32($8D71) then Result := 'RGB32UI' else
      if self.val = Int32($8D72) then Result := 'ALPHA32UI' else
      if self.val = Int32($8D73) then Result := 'INTENSITY32UI' else
      if self.val = Int32($8D74) then Result := 'LUMINANCE32UI' else
      if self.val = Int32($8D75) then Result := 'LUMINANCE_ALPHA32UI' else
      if self.val = Int32($8D76) then Result := 'RGBA16UI' else
      if self.val = Int32($8D77) then Result := 'RGB16UI' else
      if self.val = Int32($8D78) then Result := 'ALPHA16UI' else
      if self.val = Int32($8D79) then Result := 'INTENSITY16UI' else
      if self.val = Int32($8D7A) then Result := 'LUMINANCE16UI' else
      if self.val = Int32($8D7B) then Result := 'LUMINANCE_ALPHA16UI' else
      if self.val = Int32($8D7C) then Result := 'RGBA8UI' else
      if self.val = Int32($8D7D) then Result := 'RGB8UI' else
      if self.val = Int32($8D7E) then Result := 'ALPHA8UI' else
      if self.val = Int32($8D7F) then Result := 'INTENSITY8UI' else
      if self.val = Int32($8D80) then Result := 'LUMINANCE8UI' else
      if self.val = Int32($8D81) then Result := 'LUMINANCE_ALPHA8UI' else
      if self.val = Int32($8D82) then Result := 'RGBA32I' else
      if self.val = Int32($8D83) then Result := 'RGB32I' else
      if self.val = Int32($8D84) then Result := 'ALPHA32I' else
      if self.val = Int32($8D85) then Result := 'INTENSITY32I' else
      if self.val = Int32($8D86) then Result := 'LUMINANCE32I' else
      if self.val = Int32($8D87) then Result := 'LUMINANCE_ALPHA32I' else
      if self.val = Int32($8D88) then Result := 'RGBA16I' else
      if self.val = Int32($8D89) then Result := 'RGB16I' else
      if self.val = Int32($8D8A) then Result := 'ALPHA16I' else
      if self.val = Int32($8D8B) then Result := 'INTENSITY16I' else
      if self.val = Int32($8D8C) then Result := 'LUMINANCE16I' else
      if self.val = Int32($8D8D) then Result := 'LUMINANCE_ALPHA16I' else
      if self.val = Int32($8D8E) then Result := 'RGBA8I' else
      if self.val = Int32($8D8F) then Result := 'RGB8I' else
      if self.val = Int32($8D90) then Result := 'ALPHA8I' else
      if self.val = Int32($8D91) then Result := 'INTENSITY8I' else
      if self.val = Int32($8D92) then Result := 'LUMINANCE8I' else
      if self.val = Int32($8D93) then Result := 'LUMINANCE_ALPHA8I' else
      if self.val = Int32($8DAB) then Result := 'DEPTH_COMPONENT32F_NV' else
      if self.val = Int32($8DAC) then Result := 'DEPTH32F_STENCIL8_NV' else
      if self.val = Int32($8DBB) then Result := 'COMPRESSED_RED_RGTC1' else
      if self.val = Int32($8DBC) then Result := 'COMPRESSED_SIGNED_RED_RGTC1' else
      if self.val = Int32($8DBD) then Result := 'COMPRESSED_RED_GREEN_RGTC2' else
      if self.val = Int32($8DBD) then Result := 'COMPRESSED_RG_RGTC2' else
      if self.val = Int32($8DBE) then Result := 'COMPRESSED_SIGNED_RED_GREEN_RGTC2' else
      if self.val = Int32($8DBE) then Result := 'COMPRESSED_SIGNED_RG_RGTC2' else
      if self.val = Int32($8E8C) then Result := 'COMPRESSED_RGBA_BPTC_UNORM' else
      if self.val = Int32($8E8D) then Result := 'COMPRESSED_SRGB_ALPHA_BPTC_UNORM' else
      if self.val = Int32($8E8E) then Result := 'COMPRESSED_RGB_BPTC_SIGNED_FLOAT' else
      if self.val = Int32($8E8F) then Result := 'COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT' else
      if self.val = Int32($8F94) then Result := 'R8_SNORM' else
      if self.val = Int32($8F95) then Result := 'RG8_SNORM' else
      if self.val = Int32($8F96) then Result := 'RGB8_SNORM' else
      if self.val = Int32($8F97) then Result := 'RGBA8_SNORM' else
      if self.val = Int32($8F98) then Result := 'R16_SNORM' else
      if self.val = Int32($8F99) then Result := 'RG16_SNORM' else
      if self.val = Int32($8F9A) then Result := 'RGB16_SNORM' else
      if self.val = Int32($8F9B) then Result := 'RGBA16_SNORM' else
      if self.val = Int32($8FBD) then Result := 'SR8' else
      if self.val = Int32($8FBE) then Result := 'SRG8' else
      if self.val = Int32($906F) then Result := 'RGB10_A2UI' else
      if self.val = Int32($9270) then Result := 'COMPRESSED_R11_EAC' else
      if self.val = Int32($9271) then Result := 'COMPRESSED_SIGNED_R11_EAC' else
      if self.val = Int32($9272) then Result := 'COMPRESSED_RG11_EAC' else
      if self.val = Int32($9273) then Result := 'COMPRESSED_SIGNED_RG11_EAC' else
      if self.val = Int32($9274) then Result := 'COMPRESSED_RGB8_ETC2' else
      if self.val = Int32($9275) then Result := 'COMPRESSED_SRGB8_ETC2' else
      if self.val = Int32($9276) then Result := 'COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2' else
      if self.val = Int32($9277) then Result := 'COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2' else
      if self.val = Int32($9278) then Result := 'COMPRESSED_RGBA8_ETC2_EAC' else
      if self.val = Int32($9279) then Result := 'COMPRESSED_SRGB8_ALPHA8_ETC2_EAC' else
      if self.val = Int32($93B0) then Result := 'COMPRESSED_RGBA_ASTC_4x4' else
      if self.val = Int32($93B1) then Result := 'COMPRESSED_RGBA_ASTC_5x4' else
      if self.val = Int32($93B2) then Result := 'COMPRESSED_RGBA_ASTC_5x5' else
      if self.val = Int32($93B3) then Result := 'COMPRESSED_RGBA_ASTC_6x5' else
      if self.val = Int32($93B4) then Result := 'COMPRESSED_RGBA_ASTC_6x6' else
      if self.val = Int32($93B5) then Result := 'COMPRESSED_RGBA_ASTC_8x5' else
      if self.val = Int32($93B6) then Result := 'COMPRESSED_RGBA_ASTC_8x6' else
      if self.val = Int32($93B7) then Result := 'COMPRESSED_RGBA_ASTC_8x8' else
      if self.val = Int32($93B8) then Result := 'COMPRESSED_RGBA_ASTC_10x5' else
      if self.val = Int32($93B9) then Result := 'COMPRESSED_RGBA_ASTC_10x6' else
      if self.val = Int32($93BA) then Result := 'COMPRESSED_RGBA_ASTC_10x8' else
      if self.val = Int32($93BB) then Result := 'COMPRESSED_RGBA_ASTC_10x10' else
      if self.val = Int32($93BC) then Result := 'COMPRESSED_RGBA_ASTC_12x10' else
      if self.val = Int32($93BD) then Result := 'COMPRESSED_RGBA_ASTC_12x12' else
      if self.val = Int32($93C0) then Result := 'COMPRESSED_RGBA_ASTC_3x3x3' else
      if self.val = Int32($93C1) then Result := 'COMPRESSED_RGBA_ASTC_4x3x3' else
      if self.val = Int32($93C2) then Result := 'COMPRESSED_RGBA_ASTC_4x4x3' else
      if self.val = Int32($93C3) then Result := 'COMPRESSED_RGBA_ASTC_4x4x4' else
      if self.val = Int32($93C4) then Result := 'COMPRESSED_RGBA_ASTC_5x4x4' else
      if self.val = Int32($93C5) then Result := 'COMPRESSED_RGBA_ASTC_5x5x4' else
      if self.val = Int32($93C6) then Result := 'COMPRESSED_RGBA_ASTC_5x5x5' else
      if self.val = Int32($93C7) then Result := 'COMPRESSED_RGBA_ASTC_6x5x5' else
      if self.val = Int32($93C8) then Result := 'COMPRESSED_RGBA_ASTC_6x6x5' else
      if self.val = Int32($93C9) then Result := 'COMPRESSED_RGBA_ASTC_6x6x6' else
      if self.val = Int32($93D0) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x4' else
      if self.val = Int32($93D1) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x4' else
      if self.val = Int32($93D2) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x5' else
      if self.val = Int32($93D3) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x5' else
      if self.val = Int32($93D4) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x6' else
      if self.val = Int32($93D5) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x5' else
      if self.val = Int32($93D6) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x6' else
      if self.val = Int32($93D7) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x8' else
      if self.val = Int32($93D8) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x5' else
      if self.val = Int32($93D9) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x6' else
      if self.val = Int32($93DA) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x8' else
      if self.val = Int32($93DB) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x10' else
      if self.val = Int32($93DC) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_12x10' else
      if self.val = Int32($93DD) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_12x12' else
      if self.val = Int32($93E0) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3' else
      if self.val = Int32($93E1) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3' else
      if self.val = Int32($93E2) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3' else
      if self.val = Int32($93E3) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4' else
      if self.val = Int32($93E4) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4' else
      if self.val = Int32($93E5) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4' else
      if self.val = Int32($93E6) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5' else
      if self.val = Int32($93E7) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5' else
      if self.val = Int32($93E8) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5' else
      if self.val = Int32($93E9) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6' else
        Result := $'InternalFormat[{self.val}]';
    end;
    
  end;
  
  InternalFormatPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SAMPLES:                                InternalFormatPName read new InternalFormatPName($80A9);
    public static property GENERATE_MIPMAP:                        InternalFormatPName read new InternalFormatPName($8191);
    public static property INTERNALFORMAT_SUPPORTED:               InternalFormatPName read new InternalFormatPName($826F);
    public static property INTERNALFORMAT_PREFERRED:               InternalFormatPName read new InternalFormatPName($8270);
    public static property INTERNALFORMAT_RED_SIZE:                InternalFormatPName read new InternalFormatPName($8271);
    public static property INTERNALFORMAT_GREEN_SIZE:              InternalFormatPName read new InternalFormatPName($8272);
    public static property INTERNALFORMAT_BLUE_SIZE:               InternalFormatPName read new InternalFormatPName($8273);
    public static property INTERNALFORMAT_ALPHA_SIZE:              InternalFormatPName read new InternalFormatPName($8274);
    public static property INTERNALFORMAT_DEPTH_SIZE:              InternalFormatPName read new InternalFormatPName($8275);
    public static property INTERNALFORMAT_STENCIL_SIZE:            InternalFormatPName read new InternalFormatPName($8276);
    public static property INTERNALFORMAT_SHARED_SIZE:             InternalFormatPName read new InternalFormatPName($8277);
    public static property INTERNALFORMAT_RED_TYPE:                InternalFormatPName read new InternalFormatPName($8278);
    public static property INTERNALFORMAT_GREEN_TYPE:              InternalFormatPName read new InternalFormatPName($8279);
    public static property INTERNALFORMAT_BLUE_TYPE:               InternalFormatPName read new InternalFormatPName($827A);
    public static property INTERNALFORMAT_ALPHA_TYPE:              InternalFormatPName read new InternalFormatPName($827B);
    public static property INTERNALFORMAT_DEPTH_TYPE:              InternalFormatPName read new InternalFormatPName($827C);
    public static property INTERNALFORMAT_STENCIL_TYPE:            InternalFormatPName read new InternalFormatPName($827D);
    public static property MAX_WIDTH:                              InternalFormatPName read new InternalFormatPName($827E);
    public static property MAX_HEIGHT:                             InternalFormatPName read new InternalFormatPName($827F);
    public static property MAX_DEPTH:                              InternalFormatPName read new InternalFormatPName($8280);
    public static property MAX_LAYERS:                             InternalFormatPName read new InternalFormatPName($8281);
    public static property COLOR_COMPONENTS:                       InternalFormatPName read new InternalFormatPName($8283);
    public static property COLOR_RENDERABLE:                       InternalFormatPName read new InternalFormatPName($8286);
    public static property DEPTH_RENDERABLE:                       InternalFormatPName read new InternalFormatPName($8287);
    public static property STENCIL_RENDERABLE:                     InternalFormatPName read new InternalFormatPName($8288);
    public static property FRAMEBUFFER_RENDERABLE:                 InternalFormatPName read new InternalFormatPName($8289);
    public static property FRAMEBUFFER_RENDERABLE_LAYERED:         InternalFormatPName read new InternalFormatPName($828A);
    public static property FRAMEBUFFER_BLEND:                      InternalFormatPName read new InternalFormatPName($828B);
    public static property READ_PIXELS:                            InternalFormatPName read new InternalFormatPName($828C);
    public static property READ_PIXELS_FORMAT:                     InternalFormatPName read new InternalFormatPName($828D);
    public static property READ_PIXELS_TYPE:                       InternalFormatPName read new InternalFormatPName($828E);
    public static property TEXTURE_IMAGE_FORMAT:                   InternalFormatPName read new InternalFormatPName($828F);
    public static property TEXTURE_IMAGE_TYPE:                     InternalFormatPName read new InternalFormatPName($8290);
    public static property GET__TEXTURE_IMAGE_FORMAT:              InternalFormatPName read new InternalFormatPName($8291);
    public static property GET__TEXTURE_IMAGE_TYPE:                InternalFormatPName read new InternalFormatPName($8292);
    public static property MIPMAP:                                 InternalFormatPName read new InternalFormatPName($8293);
    public static property AUTO_GENERATE_MIPMAP:                   InternalFormatPName read new InternalFormatPName($8295);
    public static property COLOR_ENCODING:                         InternalFormatPName read new InternalFormatPName($8296);
    public static property SRGB_READ:                              InternalFormatPName read new InternalFormatPName($8297);
    public static property SRGB_WRITE:                             InternalFormatPName read new InternalFormatPName($8298);
    public static property FILTER:                                 InternalFormatPName read new InternalFormatPName($829A);
    public static property VERTEX_TEXTURE:                         InternalFormatPName read new InternalFormatPName($829B);
    public static property TESS_CONTROL_TEXTURE:                   InternalFormatPName read new InternalFormatPName($829C);
    public static property TESS_EVALUATION_TEXTURE:                InternalFormatPName read new InternalFormatPName($829D);
    public static property GEOMETRY_TEXTURE:                       InternalFormatPName read new InternalFormatPName($829E);
    public static property FRAGMENT_TEXTURE:                       InternalFormatPName read new InternalFormatPName($829F);
    public static property COMPUTE_TEXTURE:                        InternalFormatPName read new InternalFormatPName($82A0);
    public static property TEXTURE_SHADOW:                         InternalFormatPName read new InternalFormatPName($82A1);
    public static property TEXTURE_GATHER:                         InternalFormatPName read new InternalFormatPName($82A2);
    public static property TEXTURE_GATHER_SHADOW:                  InternalFormatPName read new InternalFormatPName($82A3);
    public static property SHADER_IMAGE_LOAD:                      InternalFormatPName read new InternalFormatPName($82A4);
    public static property SHADER_IMAGE_STORE:                     InternalFormatPName read new InternalFormatPName($82A5);
    public static property SHADER_IMAGE_ATOMIC:                    InternalFormatPName read new InternalFormatPName($82A6);
    public static property IMAGE_TEXEL_SIZE:                       InternalFormatPName read new InternalFormatPName($82A7);
    public static property IMAGE_COMPATIBILITY_CLASS:              InternalFormatPName read new InternalFormatPName($82A8);
    public static property IMAGE_PIXEL_FORMAT:                     InternalFormatPName read new InternalFormatPName($82A9);
    public static property IMAGE_PIXEL_TYPE:                       InternalFormatPName read new InternalFormatPName($82AA);
    public static property SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST:    InternalFormatPName read new InternalFormatPName($82AC);
    public static property SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST:  InternalFormatPName read new InternalFormatPName($82AD);
    public static property SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE:   InternalFormatPName read new InternalFormatPName($82AE);
    public static property SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE: InternalFormatPName read new InternalFormatPName($82AF);
    public static property TEXTURE_COMPRESSED_BLOCK_WIDTH:         InternalFormatPName read new InternalFormatPName($82B1);
    public static property TEXTURE_COMPRESSED_BLOCK_HEIGHT:        InternalFormatPName read new InternalFormatPName($82B2);
    public static property TEXTURE_COMPRESSED_BLOCK_SIZE:          InternalFormatPName read new InternalFormatPName($82B3);
    public static property CLEAR_BUFFER:                           InternalFormatPName read new InternalFormatPName($82B4);
    public static property TEXTURE_VIEW:                           InternalFormatPName read new InternalFormatPName($82B5);
    public static property VIEW_COMPATIBILITY_CLASS:               InternalFormatPName read new InternalFormatPName($82B6);
    public static property TEXTURE_COMPRESSED:                     InternalFormatPName read new InternalFormatPName($86A1);
    public static property NUM_SURFACE_COMPRESSION_FIXED_RATES:    InternalFormatPName read new InternalFormatPName($8F6E);
    public static property IMAGE_FORMAT_COMPATIBILITY_TYPE:        InternalFormatPName read new InternalFormatPName($90C7);
    public static property CLEAR_TEXTURE:                          InternalFormatPName read new InternalFormatPName($9365);
    public static property NUM_SAMPLE_COUNTS:                      InternalFormatPName read new InternalFormatPName($9380);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($80A9) then Result := 'SAMPLES' else
      if self.val = UInt32($8191) then Result := 'GENERATE_MIPMAP' else
      if self.val = UInt32($826F) then Result := 'INTERNALFORMAT_SUPPORTED' else
      if self.val = UInt32($8270) then Result := 'INTERNALFORMAT_PREFERRED' else
      if self.val = UInt32($8271) then Result := 'INTERNALFORMAT_RED_SIZE' else
      if self.val = UInt32($8272) then Result := 'INTERNALFORMAT_GREEN_SIZE' else
      if self.val = UInt32($8273) then Result := 'INTERNALFORMAT_BLUE_SIZE' else
      if self.val = UInt32($8274) then Result := 'INTERNALFORMAT_ALPHA_SIZE' else
      if self.val = UInt32($8275) then Result := 'INTERNALFORMAT_DEPTH_SIZE' else
      if self.val = UInt32($8276) then Result := 'INTERNALFORMAT_STENCIL_SIZE' else
      if self.val = UInt32($8277) then Result := 'INTERNALFORMAT_SHARED_SIZE' else
      if self.val = UInt32($8278) then Result := 'INTERNALFORMAT_RED_TYPE' else
      if self.val = UInt32($8279) then Result := 'INTERNALFORMAT_GREEN_TYPE' else
      if self.val = UInt32($827A) then Result := 'INTERNALFORMAT_BLUE_TYPE' else
      if self.val = UInt32($827B) then Result := 'INTERNALFORMAT_ALPHA_TYPE' else
      if self.val = UInt32($827C) then Result := 'INTERNALFORMAT_DEPTH_TYPE' else
      if self.val = UInt32($827D) then Result := 'INTERNALFORMAT_STENCIL_TYPE' else
      if self.val = UInt32($827E) then Result := 'MAX_WIDTH' else
      if self.val = UInt32($827F) then Result := 'MAX_HEIGHT' else
      if self.val = UInt32($8280) then Result := 'MAX_DEPTH' else
      if self.val = UInt32($8281) then Result := 'MAX_LAYERS' else
      if self.val = UInt32($8283) then Result := 'COLOR_COMPONENTS' else
      if self.val = UInt32($8286) then Result := 'COLOR_RENDERABLE' else
      if self.val = UInt32($8287) then Result := 'DEPTH_RENDERABLE' else
      if self.val = UInt32($8288) then Result := 'STENCIL_RENDERABLE' else
      if self.val = UInt32($8289) then Result := 'FRAMEBUFFER_RENDERABLE' else
      if self.val = UInt32($828A) then Result := 'FRAMEBUFFER_RENDERABLE_LAYERED' else
      if self.val = UInt32($828B) then Result := 'FRAMEBUFFER_BLEND' else
      if self.val = UInt32($828C) then Result := 'READ_PIXELS' else
      if self.val = UInt32($828D) then Result := 'READ_PIXELS_FORMAT' else
      if self.val = UInt32($828E) then Result := 'READ_PIXELS_TYPE' else
      if self.val = UInt32($828F) then Result := 'TEXTURE_IMAGE_FORMAT' else
      if self.val = UInt32($8290) then Result := 'TEXTURE_IMAGE_TYPE' else
      if self.val = UInt32($8291) then Result := 'GET__TEXTURE_IMAGE_FORMAT' else
      if self.val = UInt32($8292) then Result := 'GET__TEXTURE_IMAGE_TYPE' else
      if self.val = UInt32($8293) then Result := 'MIPMAP' else
      if self.val = UInt32($8295) then Result := 'AUTO_GENERATE_MIPMAP' else
      if self.val = UInt32($8296) then Result := 'COLOR_ENCODING' else
      if self.val = UInt32($8297) then Result := 'SRGB_READ' else
      if self.val = UInt32($8298) then Result := 'SRGB_WRITE' else
      if self.val = UInt32($829A) then Result := 'FILTER' else
      if self.val = UInt32($829B) then Result := 'VERTEX_TEXTURE' else
      if self.val = UInt32($829C) then Result := 'TESS_CONTROL_TEXTURE' else
      if self.val = UInt32($829D) then Result := 'TESS_EVALUATION_TEXTURE' else
      if self.val = UInt32($829E) then Result := 'GEOMETRY_TEXTURE' else
      if self.val = UInt32($829F) then Result := 'FRAGMENT_TEXTURE' else
      if self.val = UInt32($82A0) then Result := 'COMPUTE_TEXTURE' else
      if self.val = UInt32($82A1) then Result := 'TEXTURE_SHADOW' else
      if self.val = UInt32($82A2) then Result := 'TEXTURE_GATHER' else
      if self.val = UInt32($82A3) then Result := 'TEXTURE_GATHER_SHADOW' else
      if self.val = UInt32($82A4) then Result := 'SHADER_IMAGE_LOAD' else
      if self.val = UInt32($82A5) then Result := 'SHADER_IMAGE_STORE' else
      if self.val = UInt32($82A6) then Result := 'SHADER_IMAGE_ATOMIC' else
      if self.val = UInt32($82A7) then Result := 'IMAGE_TEXEL_SIZE' else
      if self.val = UInt32($82A8) then Result := 'IMAGE_COMPATIBILITY_CLASS' else
      if self.val = UInt32($82A9) then Result := 'IMAGE_PIXEL_FORMAT' else
      if self.val = UInt32($82AA) then Result := 'IMAGE_PIXEL_TYPE' else
      if self.val = UInt32($82AC) then Result := 'SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST' else
      if self.val = UInt32($82AD) then Result := 'SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST' else
      if self.val = UInt32($82AE) then Result := 'SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE' else
      if self.val = UInt32($82AF) then Result := 'SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE' else
      if self.val = UInt32($82B1) then Result := 'TEXTURE_COMPRESSED_BLOCK_WIDTH' else
      if self.val = UInt32($82B2) then Result := 'TEXTURE_COMPRESSED_BLOCK_HEIGHT' else
      if self.val = UInt32($82B3) then Result := 'TEXTURE_COMPRESSED_BLOCK_SIZE' else
      if self.val = UInt32($82B4) then Result := 'CLEAR_BUFFER' else
      if self.val = UInt32($82B5) then Result := 'TEXTURE_VIEW' else
      if self.val = UInt32($82B6) then Result := 'VIEW_COMPATIBILITY_CLASS' else
      if self.val = UInt32($86A1) then Result := 'TEXTURE_COMPRESSED' else
      if self.val = UInt32($8F6E) then Result := 'NUM_SURFACE_COMPRESSION_FIXED_RATES' else
      if self.val = UInt32($90C7) then Result := 'IMAGE_FORMAT_COMPATIBILITY_TYPE' else
      if self.val = UInt32($9365) then Result := 'CLEAR_TEXTURE' else
      if self.val = UInt32($9380) then Result := 'NUM_SAMPLE_COUNTS' else
        Result := $'InternalFormatPName[{self.val}]';
    end;
    
  end;
  
  InvalidateFramebufferAttachment = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COLOR:                    InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($1800);
    public static property DEPTH:                    InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($1801);
    public static property STENCIL:                  InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($1802);
    public static property DEPTH_STENCIL_ATTACHMENT: InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($821A);
    public static property COLOR_ATTACHMENT0:        InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CE0);
    public static property COLOR_ATTACHMENT1:        InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CE1);
    public static property COLOR_ATTACHMENT2:        InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CE2);
    public static property COLOR_ATTACHMENT3:        InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CE3);
    public static property COLOR_ATTACHMENT4:        InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CE4);
    public static property COLOR_ATTACHMENT5:        InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CE5);
    public static property COLOR_ATTACHMENT6:        InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CE6);
    public static property COLOR_ATTACHMENT7:        InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CE7);
    public static property COLOR_ATTACHMENT8:        InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CE8);
    public static property COLOR_ATTACHMENT9:        InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CE9);
    public static property COLOR_ATTACHMENT10:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CEA);
    public static property COLOR_ATTACHMENT11:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CEB);
    public static property COLOR_ATTACHMENT12:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CEC);
    public static property COLOR_ATTACHMENT13:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CED);
    public static property COLOR_ATTACHMENT14:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CEE);
    public static property COLOR_ATTACHMENT15:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CEF);
    public static property COLOR_ATTACHMENT16:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CF0);
    public static property COLOR_ATTACHMENT17:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CF1);
    public static property COLOR_ATTACHMENT18:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CF2);
    public static property COLOR_ATTACHMENT19:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CF3);
    public static property COLOR_ATTACHMENT20:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CF4);
    public static property COLOR_ATTACHMENT21:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CF5);
    public static property COLOR_ATTACHMENT22:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CF6);
    public static property COLOR_ATTACHMENT23:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CF7);
    public static property COLOR_ATTACHMENT24:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CF8);
    public static property COLOR_ATTACHMENT25:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CF9);
    public static property COLOR_ATTACHMENT26:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CFA);
    public static property COLOR_ATTACHMENT27:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CFB);
    public static property COLOR_ATTACHMENT28:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CFC);
    public static property COLOR_ATTACHMENT29:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CFD);
    public static property COLOR_ATTACHMENT30:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CFE);
    public static property COLOR_ATTACHMENT31:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8CFF);
    public static property DEPTH_ATTACHMENT:         InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8D00);
    public static property STENCIL_ATTACHMENT:       InvalidateFramebufferAttachment read new InvalidateFramebufferAttachment($8D20);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1800) then Result := 'COLOR' else
      if self.val = UInt32($1801) then Result := 'DEPTH' else
      if self.val = UInt32($1802) then Result := 'STENCIL' else
      if self.val = UInt32($821A) then Result := 'DEPTH_STENCIL_ATTACHMENT' else
      if self.val = UInt32($8CE0) then Result := 'COLOR_ATTACHMENT0' else
      if self.val = UInt32($8CE1) then Result := 'COLOR_ATTACHMENT1' else
      if self.val = UInt32($8CE2) then Result := 'COLOR_ATTACHMENT2' else
      if self.val = UInt32($8CE3) then Result := 'COLOR_ATTACHMENT3' else
      if self.val = UInt32($8CE4) then Result := 'COLOR_ATTACHMENT4' else
      if self.val = UInt32($8CE5) then Result := 'COLOR_ATTACHMENT5' else
      if self.val = UInt32($8CE6) then Result := 'COLOR_ATTACHMENT6' else
      if self.val = UInt32($8CE7) then Result := 'COLOR_ATTACHMENT7' else
      if self.val = UInt32($8CE8) then Result := 'COLOR_ATTACHMENT8' else
      if self.val = UInt32($8CE9) then Result := 'COLOR_ATTACHMENT9' else
      if self.val = UInt32($8CEA) then Result := 'COLOR_ATTACHMENT10' else
      if self.val = UInt32($8CEB) then Result := 'COLOR_ATTACHMENT11' else
      if self.val = UInt32($8CEC) then Result := 'COLOR_ATTACHMENT12' else
      if self.val = UInt32($8CED) then Result := 'COLOR_ATTACHMENT13' else
      if self.val = UInt32($8CEE) then Result := 'COLOR_ATTACHMENT14' else
      if self.val = UInt32($8CEF) then Result := 'COLOR_ATTACHMENT15' else
      if self.val = UInt32($8CF0) then Result := 'COLOR_ATTACHMENT16' else
      if self.val = UInt32($8CF1) then Result := 'COLOR_ATTACHMENT17' else
      if self.val = UInt32($8CF2) then Result := 'COLOR_ATTACHMENT18' else
      if self.val = UInt32($8CF3) then Result := 'COLOR_ATTACHMENT19' else
      if self.val = UInt32($8CF4) then Result := 'COLOR_ATTACHMENT20' else
      if self.val = UInt32($8CF5) then Result := 'COLOR_ATTACHMENT21' else
      if self.val = UInt32($8CF6) then Result := 'COLOR_ATTACHMENT22' else
      if self.val = UInt32($8CF7) then Result := 'COLOR_ATTACHMENT23' else
      if self.val = UInt32($8CF8) then Result := 'COLOR_ATTACHMENT24' else
      if self.val = UInt32($8CF9) then Result := 'COLOR_ATTACHMENT25' else
      if self.val = UInt32($8CFA) then Result := 'COLOR_ATTACHMENT26' else
      if self.val = UInt32($8CFB) then Result := 'COLOR_ATTACHMENT27' else
      if self.val = UInt32($8CFC) then Result := 'COLOR_ATTACHMENT28' else
      if self.val = UInt32($8CFD) then Result := 'COLOR_ATTACHMENT29' else
      if self.val = UInt32($8CFE) then Result := 'COLOR_ATTACHMENT30' else
      if self.val = UInt32($8CFF) then Result := 'COLOR_ATTACHMENT31' else
      if self.val = UInt32($8D00) then Result := 'DEPTH_ATTACHMENT' else
      if self.val = UInt32($8D20) then Result := 'STENCIL_ATTACHMENT' else
        Result := $'InvalidateFramebufferAttachment[{self.val}]';
    end;
    
  end;
  
  LightEnvMode = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property ADD:      LightEnvMode read new LightEnvMode($0104);
    public static property REPLACE:  LightEnvMode read new LightEnvMode($1E01);
    public static property MODULATE: LightEnvMode read new LightEnvMode($2100);
    
    public function ToString: string; override;
    begin
      if self.val = Int32($0104) then Result := 'ADD' else
      if self.val = Int32($1E01) then Result := 'REPLACE' else
      if self.val = Int32($2100) then Result := 'MODULATE' else
        Result := $'LightEnvMode[{self.val}]';
    end;
    
  end;
  
  LightEnvParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LIGHT_ENV_MODE: LightEnvParameter read new LightEnvParameter($8407);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8407) then Result := 'LIGHT_ENV_MODE' else
        Result := $'LightEnvParameter[{self.val}]';
    end;
    
  end;
  
  LightModelColorControl = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SINGLE_COLOR:            LightModelColorControl read new LightModelColorControl($81F9);
    public static property SEPARATE_SPECULAR_COLOR: LightModelColorControl read new LightModelColorControl($81FA);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($81F9) then Result := 'SINGLE_COLOR' else
      if self.val = UInt32($81FA) then Result := 'SEPARATE_SPECULAR_COLOR' else
        Result := $'LightModelColorControl[{self.val}]';
    end;
    
  end;
  
  LightModelParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LIGHT_MODEL_LOCAL_VIEWER:  LightModelParameter read new LightModelParameter($0B51);
    public static property LIGHT_MODEL_TWO_SIDE:      LightModelParameter read new LightModelParameter($0B52);
    public static property LIGHT_MODEL_AMBIENT:       LightModelParameter read new LightModelParameter($0B53);
    public static property LIGHT_MODEL_COLOR_CONTROL: LightModelParameter read new LightModelParameter($81F8);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0B51) then Result := 'LIGHT_MODEL_LOCAL_VIEWER' else
      if self.val = UInt32($0B52) then Result := 'LIGHT_MODEL_TWO_SIDE' else
      if self.val = UInt32($0B53) then Result := 'LIGHT_MODEL_AMBIENT' else
      if self.val = UInt32($81F8) then Result := 'LIGHT_MODEL_COLOR_CONTROL' else
        Result := $'LightModelParameter[{self.val}]';
    end;
    
  end;
  
  LightName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LIGHT0:          LightName read new LightName($4000);
    public static property LIGHT1:          LightName read new LightName($4001);
    public static property LIGHT2:          LightName read new LightName($4002);
    public static property LIGHT3:          LightName read new LightName($4003);
    public static property LIGHT4:          LightName read new LightName($4004);
    public static property LIGHT5:          LightName read new LightName($4005);
    public static property LIGHT6:          LightName read new LightName($4006);
    public static property LIGHT7:          LightName read new LightName($4007);
    public static property FRAGMENT_LIGHT0: LightName read new LightName($840C);
    public static property FRAGMENT_LIGHT1: LightName read new LightName($840D);
    public static property FRAGMENT_LIGHT2: LightName read new LightName($840E);
    public static property FRAGMENT_LIGHT3: LightName read new LightName($840F);
    public static property FRAGMENT_LIGHT4: LightName read new LightName($8410);
    public static property FRAGMENT_LIGHT5: LightName read new LightName($8411);
    public static property FRAGMENT_LIGHT6: LightName read new LightName($8412);
    public static property FRAGMENT_LIGHT7: LightName read new LightName($8413);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($4000) then Result := 'LIGHT0' else
      if self.val = UInt32($4001) then Result := 'LIGHT1' else
      if self.val = UInt32($4002) then Result := 'LIGHT2' else
      if self.val = UInt32($4003) then Result := 'LIGHT3' else
      if self.val = UInt32($4004) then Result := 'LIGHT4' else
      if self.val = UInt32($4005) then Result := 'LIGHT5' else
      if self.val = UInt32($4006) then Result := 'LIGHT6' else
      if self.val = UInt32($4007) then Result := 'LIGHT7' else
      if self.val = UInt32($840C) then Result := 'FRAGMENT_LIGHT0' else
      if self.val = UInt32($840D) then Result := 'FRAGMENT_LIGHT1' else
      if self.val = UInt32($840E) then Result := 'FRAGMENT_LIGHT2' else
      if self.val = UInt32($840F) then Result := 'FRAGMENT_LIGHT3' else
      if self.val = UInt32($8410) then Result := 'FRAGMENT_LIGHT4' else
      if self.val = UInt32($8411) then Result := 'FRAGMENT_LIGHT5' else
      if self.val = UInt32($8412) then Result := 'FRAGMENT_LIGHT6' else
      if self.val = UInt32($8413) then Result := 'FRAGMENT_LIGHT7' else
        Result := $'LightName[{self.val}]';
    end;
    
  end;
  
  LightParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POSITION:              LightParameter read new LightParameter($1203);
    public static property SPOT_DIRECTION:        LightParameter read new LightParameter($1204);
    public static property SPOT_EXPONENT:         LightParameter read new LightParameter($1205);
    public static property SPOT_CUTOFF:           LightParameter read new LightParameter($1206);
    public static property CONSTANT_ATTENUATION:  LightParameter read new LightParameter($1207);
    public static property LINEAR_ATTENUATION:    LightParameter read new LightParameter($1208);
    public static property QUADRATIC_ATTENUATION: LightParameter read new LightParameter($1209);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1203) then Result := 'POSITION' else
      if self.val = UInt32($1204) then Result := 'SPOT_DIRECTION' else
      if self.val = UInt32($1205) then Result := 'SPOT_EXPONENT' else
      if self.val = UInt32($1206) then Result := 'SPOT_CUTOFF' else
      if self.val = UInt32($1207) then Result := 'CONSTANT_ATTENUATION' else
      if self.val = UInt32($1208) then Result := 'LINEAR_ATTENUATION' else
      if self.val = UInt32($1209) then Result := 'QUADRATIC_ATTENUATION' else
        Result := $'LightParameter[{self.val}]';
    end;
    
  end;
  
  LightTextureMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRAGMENT_MATERIAL: LightTextureMode read new LightTextureMode($8349);
    public static property FRAGMENT_NORMAL:   LightTextureMode read new LightTextureMode($834A);
    public static property FRAGMENT_COLOR:    LightTextureMode read new LightTextureMode($834C);
    public static property FRAGMENT_DEPTH:    LightTextureMode read new LightTextureMode($8452);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8349) then Result := 'FRAGMENT_MATERIAL' else
      if self.val = UInt32($834A) then Result := 'FRAGMENT_NORMAL' else
      if self.val = UInt32($834C) then Result := 'FRAGMENT_COLOR' else
      if self.val = UInt32($8452) then Result := 'FRAGMENT_DEPTH' else
        Result := $'LightTextureMode[{self.val}]';
    end;
    
  end;
  
  LightTexturePName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ATTENUATION:        LightTexturePName read new LightTexturePName($834D);
    public static property SHADOW_ATTENUATION: LightTexturePName read new LightTexturePName($834E);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($834D) then Result := 'ATTENUATION' else
      if self.val = UInt32($834E) then Result := 'SHADOW_ATTENUATION' else
        Result := $'LightTexturePName[{self.val}]';
    end;
    
  end;
  
  ListMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMPILE:             ListMode read new ListMode($1300);
    public static property COMPILE_AND_EXECUTE: ListMode read new ListMode($1301);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1300) then Result := 'COMPILE' else
      if self.val = UInt32($1301) then Result := 'COMPILE_AND_EXECUTE' else
        Result := $'ListMode[{self.val}]';
    end;
    
  end;
  
  ListNameType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:           ListNameType read new ListNameType($1400);
    public static property UNSIGNED_BYTE:  ListNameType read new ListNameType($1401);
    public static property SHORT:          ListNameType read new ListNameType($1402);
    public static property UNSIGNED_SHORT: ListNameType read new ListNameType($1403);
    public static property INT:            ListNameType read new ListNameType($1404);
    public static property UNSIGNED_INT:   ListNameType read new ListNameType($1405);
    public static property FLOAT:          ListNameType read new ListNameType($1406);
    public static property _2_BYTES:       ListNameType read new ListNameType($1407);
    public static property _3_BYTES:       ListNameType read new ListNameType($1408);
    public static property _4_BYTES:       ListNameType read new ListNameType($1409);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($1407) then Result := '_2_BYTES' else
      if self.val = UInt32($1408) then Result := '_3_BYTES' else
      if self.val = UInt32($1409) then Result := '_4_BYTES' else
        Result := $'ListNameType[{self.val}]';
    end;
    
  end;
  
  ListParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LIST_PRIORITY: ListParameterName read new ListParameterName($8182);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8182) then Result := 'LIST_PRIORITY' else
        Result := $'ListParameterName[{self.val}]';
    end;
    
  end;
  
  LogicOp = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CLEAR:         LogicOp read new LogicOp($1500);
    public static property &AND:          LogicOp read new LogicOp($1501);
    public static property AND_REVERSE:   LogicOp read new LogicOp($1502);
    public static property COPY:          LogicOp read new LogicOp($1503);
    public static property AND_INVERTED:  LogicOp read new LogicOp($1504);
    public static property NOOP:          LogicOp read new LogicOp($1505);
    public static property &XOR:          LogicOp read new LogicOp($1506);
    public static property &OR:           LogicOp read new LogicOp($1507);
    public static property NOR:           LogicOp read new LogicOp($1508);
    public static property EQUIV:         LogicOp read new LogicOp($1509);
    public static property INVERT:        LogicOp read new LogicOp($150A);
    public static property OR_REVERSE:    LogicOp read new LogicOp($150B);
    public static property COPY_INVERTED: LogicOp read new LogicOp($150C);
    public static property OR_INVERTED:   LogicOp read new LogicOp($150D);
    public static property NAND:          LogicOp read new LogicOp($150E);
    public static property &SET:          LogicOp read new LogicOp($150F);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1500) then Result := 'CLEAR' else
      if self.val = UInt32($1501) then Result := 'AND' else
      if self.val = UInt32($1502) then Result := 'AND_REVERSE' else
      if self.val = UInt32($1503) then Result := 'COPY' else
      if self.val = UInt32($1504) then Result := 'AND_INVERTED' else
      if self.val = UInt32($1505) then Result := 'NOOP' else
      if self.val = UInt32($1506) then Result := 'XOR' else
      if self.val = UInt32($1507) then Result := 'OR' else
      if self.val = UInt32($1508) then Result := 'NOR' else
      if self.val = UInt32($1509) then Result := 'EQUIV' else
      if self.val = UInt32($150A) then Result := 'INVERT' else
      if self.val = UInt32($150B) then Result := 'OR_REVERSE' else
      if self.val = UInt32($150C) then Result := 'COPY_INVERTED' else
      if self.val = UInt32($150D) then Result := 'OR_INVERTED' else
      if self.val = UInt32($150E) then Result := 'NAND' else
      if self.val = UInt32($150F) then Result := 'SET' else
        Result := $'LogicOp[{self.val}]';
    end;
    
  end;
  
  MapAttribParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MAP_ATTRIB_U_ORDER: MapAttribParameter read new MapAttribParameter($86C3);
    public static property MAP_ATTRIB_V_ORDER: MapAttribParameter read new MapAttribParameter($86C4);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($86C3) then Result := 'MAP_ATTRIB_U_ORDER' else
      if self.val = UInt32($86C4) then Result := 'MAP_ATTRIB_V_ORDER' else
        Result := $'MapAttribParameter[{self.val}]';
    end;
    
  end;
  
  MapBufferAccessMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MAP_READ_BIT:              MapBufferAccessMask read new MapBufferAccessMask($0001);
    public static property MAP_WRITE_BIT:             MapBufferAccessMask read new MapBufferAccessMask($0002);
    public static property MAP_INVALIDATE_RANGE_BIT:  MapBufferAccessMask read new MapBufferAccessMask($0004);
    public static property MAP_INVALIDATE_BUFFER_BIT: MapBufferAccessMask read new MapBufferAccessMask($0008);
    public static property MAP_FLUSH_EXPLICIT_BIT:    MapBufferAccessMask read new MapBufferAccessMask($0010);
    public static property MAP_UNSYNCHRONIZED_BIT:    MapBufferAccessMask read new MapBufferAccessMask($0020);
    public static property MAP_PERSISTENT_BIT:        MapBufferAccessMask read new MapBufferAccessMask($0040);
    public static property MAP_COHERENT_BIT:          MapBufferAccessMask read new MapBufferAccessMask($0080);
    
    public static function operator+(f1,f2: MapBufferAccessMask) := new MapBufferAccessMask(f1.val or f2.val);
    public static function operator or(f1,f2: MapBufferAccessMask) := f1+f2;
    
    public static procedure operator+=(var f1: MapBufferAccessMask; f2: MapBufferAccessMask) := f1 := f1+f2;
    
    public property HAS_FLAG_MAP_READ_BIT:              boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_MAP_WRITE_BIT:             boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_MAP_INVALIDATE_RANGE_BIT:  boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_MAP_INVALIDATE_BUFFER_BIT: boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_MAP_FLUSH_EXPLICIT_BIT:    boolean read self.val and $0010 <> 0;
    public property HAS_FLAG_MAP_UNSYNCHRONIZED_BIT:    boolean read self.val and $0020 <> 0;
    public property HAS_FLAG_MAP_PERSISTENT_BIT:        boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_MAP_COHERENT_BIT:          boolean read self.val and $0080 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'MAP_READ_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'MAP_WRITE_BIT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'MAP_INVALIDATE_RANGE_BIT+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'MAP_INVALIDATE_BUFFER_BIT+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'MAP_FLUSH_EXPLICIT_BIT+';
      if self.val and UInt32($0020) = UInt32($0020) then res += 'MAP_UNSYNCHRONIZED_BIT+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'MAP_PERSISTENT_BIT+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'MAP_COHERENT_BIT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'MapBufferAccessMask[{self.val}]';
    end;
    
  end;
  
  MapParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MAP_TESSELLATION: MapParameter read new MapParameter($86C2);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($86C2) then Result := 'MAP_TESSELLATION' else
        Result := $'MapParameter[{self.val}]';
    end;
    
  end;
  
  MapQuery = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COEFF:  MapQuery read new MapQuery($0A00);
    public static property ORDER:  MapQuery read new MapQuery($0A01);
    public static property DOMAIN: MapQuery read new MapQuery($0A02);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0A00) then Result := 'COEFF' else
      if self.val = UInt32($0A01) then Result := 'ORDER' else
      if self.val = UInt32($0A02) then Result := 'DOMAIN' else
        Result := $'MapQuery[{self.val}]';
    end;
    
  end;
  
  MapTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MAP1_COLOR_4:         MapTarget read new MapTarget($0D90);
    public static property MAP1_INDEX:           MapTarget read new MapTarget($0D91);
    public static property MAP1_NORMAL:          MapTarget read new MapTarget($0D92);
    public static property MAP1_TEXTURE_COORD_1: MapTarget read new MapTarget($0D93);
    public static property MAP1_TEXTURE_COORD_2: MapTarget read new MapTarget($0D94);
    public static property MAP1_TEXTURE_COORD_3: MapTarget read new MapTarget($0D95);
    public static property MAP1_TEXTURE_COORD_4: MapTarget read new MapTarget($0D96);
    public static property MAP1_VERTEX_3:        MapTarget read new MapTarget($0D97);
    public static property MAP1_VERTEX_4:        MapTarget read new MapTarget($0D98);
    public static property MAP2_COLOR_4:         MapTarget read new MapTarget($0DB0);
    public static property MAP2_INDEX:           MapTarget read new MapTarget($0DB1);
    public static property MAP2_NORMAL:          MapTarget read new MapTarget($0DB2);
    public static property MAP2_TEXTURE_COORD_1: MapTarget read new MapTarget($0DB3);
    public static property MAP2_TEXTURE_COORD_2: MapTarget read new MapTarget($0DB4);
    public static property MAP2_TEXTURE_COORD_3: MapTarget read new MapTarget($0DB5);
    public static property MAP2_TEXTURE_COORD_4: MapTarget read new MapTarget($0DB6);
    public static property MAP2_VERTEX_3:        MapTarget read new MapTarget($0DB7);
    public static property MAP2_VERTEX_4:        MapTarget read new MapTarget($0DB8);
    public static property GEOMETRY_DEFORMATION: MapTarget read new MapTarget($8194);
    public static property TEXTURE_DEFORMATION:  MapTarget read new MapTarget($8195);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0D90) then Result := 'MAP1_COLOR_4' else
      if self.val = UInt32($0D91) then Result := 'MAP1_INDEX' else
      if self.val = UInt32($0D92) then Result := 'MAP1_NORMAL' else
      if self.val = UInt32($0D93) then Result := 'MAP1_TEXTURE_COORD_1' else
      if self.val = UInt32($0D94) then Result := 'MAP1_TEXTURE_COORD_2' else
      if self.val = UInt32($0D95) then Result := 'MAP1_TEXTURE_COORD_3' else
      if self.val = UInt32($0D96) then Result := 'MAP1_TEXTURE_COORD_4' else
      if self.val = UInt32($0D97) then Result := 'MAP1_VERTEX_3' else
      if self.val = UInt32($0D98) then Result := 'MAP1_VERTEX_4' else
      if self.val = UInt32($0DB0) then Result := 'MAP2_COLOR_4' else
      if self.val = UInt32($0DB1) then Result := 'MAP2_INDEX' else
      if self.val = UInt32($0DB2) then Result := 'MAP2_NORMAL' else
      if self.val = UInt32($0DB3) then Result := 'MAP2_TEXTURE_COORD_1' else
      if self.val = UInt32($0DB4) then Result := 'MAP2_TEXTURE_COORD_2' else
      if self.val = UInt32($0DB5) then Result := 'MAP2_TEXTURE_COORD_3' else
      if self.val = UInt32($0DB6) then Result := 'MAP2_TEXTURE_COORD_4' else
      if self.val = UInt32($0DB7) then Result := 'MAP2_VERTEX_3' else
      if self.val = UInt32($0DB8) then Result := 'MAP2_VERTEX_4' else
      if self.val = UInt32($8194) then Result := 'GEOMETRY_DEFORMATION' else
      if self.val = UInt32($8195) then Result := 'TEXTURE_DEFORMATION' else
        Result := $'MapTarget[{self.val}]';
    end;
    
  end;
  
  MapTextureFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LAYOUT_DEFAULT:           MapTextureFormat read new MapTextureFormat($0000);
    public static property LAYOUT_LINEAR:            MapTextureFormat read new MapTextureFormat($0001);
    public static property LAYOUT_LINEAR_CPU_CACHED: MapTextureFormat read new MapTextureFormat($0002);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'LAYOUT_DEFAULT' else
      if self.val = UInt32($0001) then Result := 'LAYOUT_LINEAR' else
      if self.val = UInt32($0002) then Result := 'LAYOUT_LINEAR_CPU_CACHED' else
        Result := $'MapTextureFormat[{self.val}]';
    end;
    
  end;
  
  MapType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FLOAT:  MapType read new MapType($1406);
    public static property DOUBLE: MapType read new MapType($140A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := $'MapType[{self.val}]';
    end;
    
  end;
  
  MaterialParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property AMBIENT:             MaterialParameter read new MaterialParameter($1200);
    public static property DIFFUSE:             MaterialParameter read new MaterialParameter($1201);
    public static property SPECULAR:            MaterialParameter read new MaterialParameter($1202);
    public static property EMISSION:            MaterialParameter read new MaterialParameter($1600);
    public static property SHININESS:           MaterialParameter read new MaterialParameter($1601);
    public static property AMBIENT_AND_DIFFUSE: MaterialParameter read new MaterialParameter($1602);
    public static property COLOR_INDEXES:       MaterialParameter read new MaterialParameter($1603);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1200) then Result := 'AMBIENT' else
      if self.val = UInt32($1201) then Result := 'DIFFUSE' else
      if self.val = UInt32($1202) then Result := 'SPECULAR' else
      if self.val = UInt32($1600) then Result := 'EMISSION' else
      if self.val = UInt32($1601) then Result := 'SHININESS' else
      if self.val = UInt32($1602) then Result := 'AMBIENT_AND_DIFFUSE' else
      if self.val = UInt32($1603) then Result := 'COLOR_INDEXES' else
        Result := $'MaterialParameter[{self.val}]';
    end;
    
  end;
  
  MatrixIndexPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNSIGNED_BYTE:  MatrixIndexPointerType read new MatrixIndexPointerType($1401);
    public static property UNSIGNED_SHORT: MatrixIndexPointerType read new MatrixIndexPointerType($1403);
    public static property UNSIGNED_INT:   MatrixIndexPointerType read new MatrixIndexPointerType($1405);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
        Result := $'MatrixIndexPointerType[{self.val}]';
    end;
    
  end;
  
  MatrixMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MODELVIEW:  MatrixMode read new MatrixMode($1700);
    public static property MODELVIEW0: MatrixMode read new MatrixMode($1700);
    public static property PROJECTION: MatrixMode read new MatrixMode($1701);
    public static property TEXTURE:    MatrixMode read new MatrixMode($1702);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1700) then Result := 'MODELVIEW' else
      if self.val = UInt32($1700) then Result := 'MODELVIEW0' else
      if self.val = UInt32($1701) then Result := 'PROJECTION' else
      if self.val = UInt32($1702) then Result := 'TEXTURE' else
        Result := $'MatrixMode[{self.val}]';
    end;
    
  end;
  
  MemoryBarrierMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_ATTRIB_ARRAY_BARRIER_BIT:  MemoryBarrierMask read new MemoryBarrierMask($0001);
    public static property ELEMENT_ARRAY_BARRIER_BIT:        MemoryBarrierMask read new MemoryBarrierMask($0002);
    public static property UNIFORM_BARRIER_BIT:              MemoryBarrierMask read new MemoryBarrierMask($0004);
    public static property TEXTURE_FETCH_BARRIER_BIT:        MemoryBarrierMask read new MemoryBarrierMask($0008);
    public static property SHADER_GLOBAL_ACCESS_BARRIER_BIT: MemoryBarrierMask read new MemoryBarrierMask($0010);
    public static property SHADER_IMAGE_ACCESS_BARRIER_BIT:  MemoryBarrierMask read new MemoryBarrierMask($0020);
    public static property COMMAND_BARRIER_BIT:              MemoryBarrierMask read new MemoryBarrierMask($0040);
    public static property PIXEL_BUFFER_BARRIER_BIT:         MemoryBarrierMask read new MemoryBarrierMask($0080);
    public static property TEXTURE_UPDATE_BARRIER_BIT:       MemoryBarrierMask read new MemoryBarrierMask($0100);
    public static property BUFFER_UPDATE_BARRIER_BIT:        MemoryBarrierMask read new MemoryBarrierMask($0200);
    public static property FRAMEBUFFER_BARRIER_BIT:          MemoryBarrierMask read new MemoryBarrierMask($0400);
    public static property TRANSFORM_FEEDBACK_BARRIER_BIT:   MemoryBarrierMask read new MemoryBarrierMask($0800);
    public static property ATOMIC_COUNTER_BARRIER_BIT:       MemoryBarrierMask read new MemoryBarrierMask($1000);
    public static property SHADER_STORAGE_BARRIER_BIT:       MemoryBarrierMask read new MemoryBarrierMask($2000);
    public static property CLIENT_MAPPED_BUFFER_BARRIER_BIT: MemoryBarrierMask read new MemoryBarrierMask($4000);
    public static property QUERY_BUFFER_BARRIER_BIT:         MemoryBarrierMask read new MemoryBarrierMask($8000);
    public static property ALL_BARRIER_BITS:                 MemoryBarrierMask read new MemoryBarrierMask($FFFFFFFF);
    
    public static function operator+(f1,f2: MemoryBarrierMask) := new MemoryBarrierMask(f1.val or f2.val);
    public static function operator or(f1,f2: MemoryBarrierMask) := f1+f2;
    
    public static procedure operator+=(var f1: MemoryBarrierMask; f2: MemoryBarrierMask) := f1 := f1+f2;
    
    public property HAS_FLAG_VERTEX_ATTRIB_ARRAY_BARRIER_BIT:  boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_ELEMENT_ARRAY_BARRIER_BIT:        boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_UNIFORM_BARRIER_BIT:              boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_TEXTURE_FETCH_BARRIER_BIT:        boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_SHADER_GLOBAL_ACCESS_BARRIER_BIT: boolean read self.val and $0010 <> 0;
    public property HAS_FLAG_SHADER_IMAGE_ACCESS_BARRIER_BIT:  boolean read self.val and $0020 <> 0;
    public property HAS_FLAG_COMMAND_BARRIER_BIT:              boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_PIXEL_BUFFER_BARRIER_BIT:         boolean read self.val and $0080 <> 0;
    public property HAS_FLAG_TEXTURE_UPDATE_BARRIER_BIT:       boolean read self.val and $0100 <> 0;
    public property HAS_FLAG_BUFFER_UPDATE_BARRIER_BIT:        boolean read self.val and $0200 <> 0;
    public property HAS_FLAG_FRAMEBUFFER_BARRIER_BIT:          boolean read self.val and $0400 <> 0;
    public property HAS_FLAG_TRANSFORM_FEEDBACK_BARRIER_BIT:   boolean read self.val and $0800 <> 0;
    public property HAS_FLAG_ATOMIC_COUNTER_BARRIER_BIT:       boolean read self.val and $1000 <> 0;
    public property HAS_FLAG_SHADER_STORAGE_BARRIER_BIT:       boolean read self.val and $2000 <> 0;
    public property HAS_FLAG_CLIENT_MAPPED_BUFFER_BARRIER_BIT: boolean read self.val and $4000 <> 0;
    public property HAS_FLAG_QUERY_BUFFER_BARRIER_BIT:         boolean read self.val and $8000 <> 0;
    public property HAS_FLAG_ALL_BARRIER_BITS:                 boolean read self.val and $FFFFFFFF <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'VERTEX_ATTRIB_ARRAY_BARRIER_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'ELEMENT_ARRAY_BARRIER_BIT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'UNIFORM_BARRIER_BIT+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'TEXTURE_FETCH_BARRIER_BIT+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'SHADER_GLOBAL_ACCESS_BARRIER_BIT+';
      if self.val and UInt32($0020) = UInt32($0020) then res += 'SHADER_IMAGE_ACCESS_BARRIER_BIT+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'COMMAND_BARRIER_BIT+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'PIXEL_BUFFER_BARRIER_BIT+';
      if self.val and UInt32($0100) = UInt32($0100) then res += 'TEXTURE_UPDATE_BARRIER_BIT+';
      if self.val and UInt32($0200) = UInt32($0200) then res += 'BUFFER_UPDATE_BARRIER_BIT+';
      if self.val and UInt32($0400) = UInt32($0400) then res += 'FRAMEBUFFER_BARRIER_BIT+';
      if self.val and UInt32($0800) = UInt32($0800) then res += 'TRANSFORM_FEEDBACK_BARRIER_BIT+';
      if self.val and UInt32($1000) = UInt32($1000) then res += 'ATOMIC_COUNTER_BARRIER_BIT+';
      if self.val and UInt32($2000) = UInt32($2000) then res += 'SHADER_STORAGE_BARRIER_BIT+';
      if self.val and UInt32($4000) = UInt32($4000) then res += 'CLIENT_MAPPED_BUFFER_BARRIER_BIT+';
      if self.val and UInt32($8000) = UInt32($8000) then res += 'QUERY_BUFFER_BARRIER_BIT+';
      if self.val and UInt32($FFFFFFFF) = UInt32($FFFFFFFF) then res += 'ALL_BARRIER_BITS+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'MemoryBarrierMask[{self.val}]';
    end;
    
  end;
  
  MemoryObjectParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DEDICATED_MEMORY_OBJECT: MemoryObjectParameterName read new MemoryObjectParameterName($9581);
    public static property PROTECTED_MEMORY_OBJECT: MemoryObjectParameterName read new MemoryObjectParameterName($959B);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9581) then Result := 'DEDICATED_MEMORY_OBJECT' else
      if self.val = UInt32($959B) then Result := 'PROTECTED_MEMORY_OBJECT' else
        Result := $'MemoryObjectParameterName[{self.val}]';
    end;
    
  end;
  
  MeshMode1 = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINT: MeshMode1 read new MeshMode1($1B00);
    public static property LINE:  MeshMode1 read new MeshMode1($1B01);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1B00) then Result := 'POINT' else
      if self.val = UInt32($1B01) then Result := 'LINE' else
        Result := $'MeshMode1[{self.val}]';
    end;
    
  end;
  
  MeshMode2 = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINT: MeshMode2 read new MeshMode2($1B00);
    public static property LINE:  MeshMode2 read new MeshMode2($1B01);
    public static property FILL:  MeshMode2 read new MeshMode2($1B02);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1B00) then Result := 'POINT' else
      if self.val = UInt32($1B01) then Result := 'LINE' else
      if self.val = UInt32($1B02) then Result := 'FILL' else
        Result := $'MeshMode2[{self.val}]';
    end;
    
  end;
  
  MinmaxTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MINMAX: MinmaxTarget read new MinmaxTarget($802E);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($802E) then Result := 'MINMAX' else
        Result := $'MinmaxTarget[{self.val}]';
    end;
    
  end;
  
  NormalPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:   NormalPointerType read new NormalPointerType($1400);
    public static property SHORT:  NormalPointerType read new NormalPointerType($1402);
    public static property INT:    NormalPointerType read new NormalPointerType($1404);
    public static property FLOAT:  NormalPointerType read new NormalPointerType($1406);
    public static property DOUBLE: NormalPointerType read new NormalPointerType($140A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := $'NormalPointerType[{self.val}]';
    end;
    
  end;
  
  ObjectIdentifier = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE:            ObjectIdentifier read new ObjectIdentifier($1702);
    public static property VERTEX_ARRAY:       ObjectIdentifier read new ObjectIdentifier($8074);
    public static property BUFFER:             ObjectIdentifier read new ObjectIdentifier($82E0);
    public static property SHADER:             ObjectIdentifier read new ObjectIdentifier($82E1);
    public static property &PROGRAM:           ObjectIdentifier read new ObjectIdentifier($82E2);
    public static property QUERY:              ObjectIdentifier read new ObjectIdentifier($82E3);
    public static property PROGRAM_PIPELINE:   ObjectIdentifier read new ObjectIdentifier($82E4);
    public static property SAMPLER:            ObjectIdentifier read new ObjectIdentifier($82E6);
    public static property FRAMEBUFFER:        ObjectIdentifier read new ObjectIdentifier($8D40);
    public static property RENDERBUFFER:       ObjectIdentifier read new ObjectIdentifier($8D41);
    public static property TRANSFORM_FEEDBACK: ObjectIdentifier read new ObjectIdentifier($8E22);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1702) then Result := 'TEXTURE' else
      if self.val = UInt32($8074) then Result := 'VERTEX_ARRAY' else
      if self.val = UInt32($82E0) then Result := 'BUFFER' else
      if self.val = UInt32($82E1) then Result := 'SHADER' else
      if self.val = UInt32($82E2) then Result := 'PROGRAM' else
      if self.val = UInt32($82E3) then Result := 'QUERY' else
      if self.val = UInt32($82E4) then Result := 'PROGRAM_PIPELINE' else
      if self.val = UInt32($82E6) then Result := 'SAMPLER' else
      if self.val = UInt32($8D40) then Result := 'FRAMEBUFFER' else
      if self.val = UInt32($8D41) then Result := 'RENDERBUFFER' else
      if self.val = UInt32($8E22) then Result := 'TRANSFORM_FEEDBACK' else
        Result := $'ObjectIdentifier[{self.val}]';
    end;
    
  end;
  
  ObjectType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DRAW_PIXELS: ObjectType read new ObjectType($8A0A);
    public static property FENCE:       ObjectType read new ObjectType($8A0B);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8A0A) then Result := 'DRAW_PIXELS' else
      if self.val = UInt32($8A0B) then Result := 'FENCE' else
        Result := $'ObjectType[{self.val}]';
    end;
    
  end;
  
  OcclusionQueryEventMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property QUERY_DEPTH_PASS_EVENT_BIT:        OcclusionQueryEventMask read new OcclusionQueryEventMask($0001);
    public static property QUERY_DEPTH_FAIL_EVENT_BIT:        OcclusionQueryEventMask read new OcclusionQueryEventMask($0002);
    public static property QUERY_STENCIL_FAIL_EVENT_BIT:      OcclusionQueryEventMask read new OcclusionQueryEventMask($0004);
    public static property QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT: OcclusionQueryEventMask read new OcclusionQueryEventMask($0008);
    public static property QUERY_ALL_EVENT_BITS:              OcclusionQueryEventMask read new OcclusionQueryEventMask($FFFFFFFF);
    
    public static function operator+(f1,f2: OcclusionQueryEventMask) := new OcclusionQueryEventMask(f1.val or f2.val);
    public static function operator or(f1,f2: OcclusionQueryEventMask) := f1+f2;
    
    public static procedure operator+=(var f1: OcclusionQueryEventMask; f2: OcclusionQueryEventMask) := f1 := f1+f2;
    
    public property HAS_FLAG_QUERY_DEPTH_PASS_EVENT_BIT:        boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_QUERY_DEPTH_FAIL_EVENT_BIT:        boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_QUERY_STENCIL_FAIL_EVENT_BIT:      boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT: boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_QUERY_ALL_EVENT_BITS:              boolean read self.val and $FFFFFFFF <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'QUERY_DEPTH_PASS_EVENT_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'QUERY_DEPTH_FAIL_EVENT_BIT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'QUERY_STENCIL_FAIL_EVENT_BIT+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT+';
      if self.val and UInt32($FFFFFFFF) = UInt32($FFFFFFFF) then res += 'QUERY_ALL_EVENT_BITS+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'OcclusionQueryEventMask[{self.val}]';
    end;
    
  end;
  
  OcclusionQueryParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PIXEL_COUNT:           OcclusionQueryParameterName read new OcclusionQueryParameterName($8866);
    public static property PIXEL_COUNT_AVAILABLE: OcclusionQueryParameterName read new OcclusionQueryParameterName($8867);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8866) then Result := 'PIXEL_COUNT' else
      if self.val = UInt32($8867) then Result := 'PIXEL_COUNT_AVAILABLE' else
        Result := $'OcclusionQueryParameterName[{self.val}]';
    end;
    
  end;
  
  ParameterRange = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NORMALIZED_RANGE: ParameterRange read new ParameterRange($87E0);
    public static property FULL_RANGE:       ParameterRange read new ParameterRange($87E1);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($87E0) then Result := 'NORMALIZED_RANGE' else
      if self.val = UInt32($87E1) then Result := 'FULL_RANGE' else
        Result := $'ParameterRange[{self.val}]';
    end;
    
  end;
  
  PatchParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PATCH_VERTICES:            PatchParameterName read new PatchParameterName($8E72);
    public static property PATCH_DEFAULT_INNER_LEVEL: PatchParameterName read new PatchParameterName($8E73);
    public static property PATCH_DEFAULT_OUTER_LEVEL: PatchParameterName read new PatchParameterName($8E74);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8E72) then Result := 'PATCH_VERTICES' else
      if self.val = UInt32($8E73) then Result := 'PATCH_DEFAULT_INNER_LEVEL' else
      if self.val = UInt32($8E74) then Result := 'PATCH_DEFAULT_OUTER_LEVEL' else
        Result := $'PatchParameterName[{self.val}]';
    end;
    
  end;
  
  PathColor = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PRIMARY_COLOR_NV: PathColor read new PathColor($852C);
    public static property SECONDARY_COLOR:  PathColor read new PathColor($852D);
    public static property PRIMARY_COLOR:    PathColor read new PathColor($8577);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($852C) then Result := 'PRIMARY_COLOR_NV' else
      if self.val = UInt32($852D) then Result := 'SECONDARY_COLOR' else
      if self.val = UInt32($8577) then Result := 'PRIMARY_COLOR' else
        Result := $'PathColor[{self.val}]';
    end;
    
  end;
  
  PathColorFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:            PathColorFormat read new PathColorFormat($0000);
    public static property ALPHA:           PathColorFormat read new PathColorFormat($1906);
    public static property RGB:             PathColorFormat read new PathColorFormat($1907);
    public static property RGBA:            PathColorFormat read new PathColorFormat($1908);
    public static property LUMINANCE:       PathColorFormat read new PathColorFormat($1909);
    public static property LUMINANCE_ALPHA: PathColorFormat read new PathColorFormat($190A);
    public static property INTENSITY:       PathColorFormat read new PathColorFormat($8049);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($1906) then Result := 'ALPHA' else
      if self.val = UInt32($1907) then Result := 'RGB' else
      if self.val = UInt32($1908) then Result := 'RGBA' else
      if self.val = UInt32($1909) then Result := 'LUMINANCE' else
      if self.val = UInt32($190A) then Result := 'LUMINANCE_ALPHA' else
      if self.val = UInt32($8049) then Result := 'INTENSITY' else
        Result := $'PathColorFormat[{self.val}]';
    end;
    
  end;
  
  PathCoordType = record
    public val: Byte;
    public constructor(val: Byte) := self.val := val;
    
    public static property CLOSE_PATH:                         PathCoordType read new PathCoordType($0000);
    public static property MOVE_TO:                            PathCoordType read new PathCoordType($0002);
    public static property RELATIVE_MOVE_TO:                   PathCoordType read new PathCoordType($0003);
    public static property LINE_TO:                            PathCoordType read new PathCoordType($0004);
    public static property RELATIVE_LINE_TO:                   PathCoordType read new PathCoordType($0005);
    public static property HORIZONTAL_LINE_TO:                 PathCoordType read new PathCoordType($0006);
    public static property RELATIVE_HORIZONTAL_LINE_TO:        PathCoordType read new PathCoordType($0007);
    public static property VERTICAL_LINE_TO:                   PathCoordType read new PathCoordType($0008);
    public static property RELATIVE_VERTICAL_LINE_TO:          PathCoordType read new PathCoordType($0009);
    public static property QUADRATIC_CURVE_TO:                 PathCoordType read new PathCoordType($000A);
    public static property RELATIVE_QUADRATIC_CURVE_TO:        PathCoordType read new PathCoordType($000B);
    public static property CUBIC_CURVE_TO:                     PathCoordType read new PathCoordType($000C);
    public static property RELATIVE_CUBIC_CURVE_TO:            PathCoordType read new PathCoordType($000D);
    public static property SMOOTH_QUADRATIC_CURVE_TO:          PathCoordType read new PathCoordType($000E);
    public static property RELATIVE_SMOOTH_QUADRATIC_CURVE_TO: PathCoordType read new PathCoordType($000F);
    public static property SMOOTH_CUBIC_CURVE_TO:              PathCoordType read new PathCoordType($0010);
    public static property RELATIVE_SMOOTH_CUBIC_CURVE_TO:     PathCoordType read new PathCoordType($0011);
    public static property SMALL_CCW_ARC_TO:                   PathCoordType read new PathCoordType($0012);
    public static property RELATIVE_SMALL_CCW_ARC_TO:          PathCoordType read new PathCoordType($0013);
    public static property SMALL_CW_ARC_TO:                    PathCoordType read new PathCoordType($0014);
    public static property RELATIVE_SMALL_CW_ARC_TO:           PathCoordType read new PathCoordType($0015);
    public static property LARGE_CCW_ARC_TO:                   PathCoordType read new PathCoordType($0016);
    public static property RELATIVE_LARGE_CCW_ARC_TO:          PathCoordType read new PathCoordType($0017);
    public static property LARGE_CW_ARC_TO:                    PathCoordType read new PathCoordType($0018);
    public static property RELATIVE_LARGE_CW_ARC_TO:           PathCoordType read new PathCoordType($0019);
    public static property CONIC_CURVE_TO:                     PathCoordType read new PathCoordType($001A);
    public static property RELATIVE_CONIC_CURVE_TO:            PathCoordType read new PathCoordType($001B);
    public static property ROUNDED_RECT:                       PathCoordType read new PathCoordType($00E8);
    public static property RELATIVE_ROUNDED_RECT:              PathCoordType read new PathCoordType($00E9);
    public static property ROUNDED_RECT2:                      PathCoordType read new PathCoordType($00EA);
    public static property RELATIVE_ROUNDED_RECT2:             PathCoordType read new PathCoordType($00EB);
    public static property ROUNDED_RECT4:                      PathCoordType read new PathCoordType($00EC);
    public static property RELATIVE_ROUNDED_RECT4:             PathCoordType read new PathCoordType($00ED);
    public static property ROUNDED_RECT8:                      PathCoordType read new PathCoordType($00EE);
    public static property RELATIVE_ROUNDED_RECT8:             PathCoordType read new PathCoordType($00EF);
    public static property RESTART_PATH:                       PathCoordType read new PathCoordType($00F0);
    public static property DUP_FIRST_CUBIC_CURVE_TO:           PathCoordType read new PathCoordType($00F2);
    public static property DUP_LAST_CUBIC_CURVE_TO:            PathCoordType read new PathCoordType($00F4);
    public static property RECT:                               PathCoordType read new PathCoordType($00F6);
    public static property RELATIVE_RECT:                      PathCoordType read new PathCoordType($00F7);
    public static property CIRCULAR_CCW_ARC_TO:                PathCoordType read new PathCoordType($00F8);
    public static property CIRCULAR_CW_ARC_TO:                 PathCoordType read new PathCoordType($00FA);
    public static property CIRCULAR_TANGENT_ARC_TO:            PathCoordType read new PathCoordType($00FC);
    public static property ARC_TO:                             PathCoordType read new PathCoordType($00FE);
    public static property RELATIVE_ARC_TO:                    PathCoordType read new PathCoordType($00FF);
    
    public function ToString: string; override;
    begin
      if self.val = Byte($0000) then Result := 'CLOSE_PATH' else
      if self.val = Byte($0002) then Result := 'MOVE_TO' else
      if self.val = Byte($0003) then Result := 'RELATIVE_MOVE_TO' else
      if self.val = Byte($0004) then Result := 'LINE_TO' else
      if self.val = Byte($0005) then Result := 'RELATIVE_LINE_TO' else
      if self.val = Byte($0006) then Result := 'HORIZONTAL_LINE_TO' else
      if self.val = Byte($0007) then Result := 'RELATIVE_HORIZONTAL_LINE_TO' else
      if self.val = Byte($0008) then Result := 'VERTICAL_LINE_TO' else
      if self.val = Byte($0009) then Result := 'RELATIVE_VERTICAL_LINE_TO' else
      if self.val = Byte($000A) then Result := 'QUADRATIC_CURVE_TO' else
      if self.val = Byte($000B) then Result := 'RELATIVE_QUADRATIC_CURVE_TO' else
      if self.val = Byte($000C) then Result := 'CUBIC_CURVE_TO' else
      if self.val = Byte($000D) then Result := 'RELATIVE_CUBIC_CURVE_TO' else
      if self.val = Byte($000E) then Result := 'SMOOTH_QUADRATIC_CURVE_TO' else
      if self.val = Byte($000F) then Result := 'RELATIVE_SMOOTH_QUADRATIC_CURVE_TO' else
      if self.val = Byte($0010) then Result := 'SMOOTH_CUBIC_CURVE_TO' else
      if self.val = Byte($0011) then Result := 'RELATIVE_SMOOTH_CUBIC_CURVE_TO' else
      if self.val = Byte($0012) then Result := 'SMALL_CCW_ARC_TO' else
      if self.val = Byte($0013) then Result := 'RELATIVE_SMALL_CCW_ARC_TO' else
      if self.val = Byte($0014) then Result := 'SMALL_CW_ARC_TO' else
      if self.val = Byte($0015) then Result := 'RELATIVE_SMALL_CW_ARC_TO' else
      if self.val = Byte($0016) then Result := 'LARGE_CCW_ARC_TO' else
      if self.val = Byte($0017) then Result := 'RELATIVE_LARGE_CCW_ARC_TO' else
      if self.val = Byte($0018) then Result := 'LARGE_CW_ARC_TO' else
      if self.val = Byte($0019) then Result := 'RELATIVE_LARGE_CW_ARC_TO' else
      if self.val = Byte($001A) then Result := 'CONIC_CURVE_TO' else
      if self.val = Byte($001B) then Result := 'RELATIVE_CONIC_CURVE_TO' else
      if self.val = Byte($00E8) then Result := 'ROUNDED_RECT' else
      if self.val = Byte($00E9) then Result := 'RELATIVE_ROUNDED_RECT' else
      if self.val = Byte($00EA) then Result := 'ROUNDED_RECT2' else
      if self.val = Byte($00EB) then Result := 'RELATIVE_ROUNDED_RECT2' else
      if self.val = Byte($00EC) then Result := 'ROUNDED_RECT4' else
      if self.val = Byte($00ED) then Result := 'RELATIVE_ROUNDED_RECT4' else
      if self.val = Byte($00EE) then Result := 'ROUNDED_RECT8' else
      if self.val = Byte($00EF) then Result := 'RELATIVE_ROUNDED_RECT8' else
      if self.val = Byte($00F0) then Result := 'RESTART_PATH' else
      if self.val = Byte($00F2) then Result := 'DUP_FIRST_CUBIC_CURVE_TO' else
      if self.val = Byte($00F4) then Result := 'DUP_LAST_CUBIC_CURVE_TO' else
      if self.val = Byte($00F6) then Result := 'RECT' else
      if self.val = Byte($00F7) then Result := 'RELATIVE_RECT' else
      if self.val = Byte($00F8) then Result := 'CIRCULAR_CCW_ARC_TO' else
      if self.val = Byte($00FA) then Result := 'CIRCULAR_CW_ARC_TO' else
      if self.val = Byte($00FC) then Result := 'CIRCULAR_TANGENT_ARC_TO' else
      if self.val = Byte($00FE) then Result := 'ARC_TO' else
      if self.val = Byte($00FF) then Result := 'RELATIVE_ARC_TO' else
        Result := $'PathCoordType[{self.val}]';
    end;
    
  end;
  
  PathCoordTypeUInt32 = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static function operator implicit(v: PathCoordTypeUInt32): PathCoordType := new PathCoordType(v.val);
    public static function operator implicit(v: PathCoordType): PathCoordTypeUInt32 := new PathCoordTypeUInt32(v.val);
    
    public static property CLOSE_PATH:                         PathCoordTypeUInt32 read new PathCoordTypeUInt32($0000);
    public static property MOVE_TO:                            PathCoordTypeUInt32 read new PathCoordTypeUInt32($0002);
    public static property RELATIVE_MOVE_TO:                   PathCoordTypeUInt32 read new PathCoordTypeUInt32($0003);
    public static property LINE_TO:                            PathCoordTypeUInt32 read new PathCoordTypeUInt32($0004);
    public static property RELATIVE_LINE_TO:                   PathCoordTypeUInt32 read new PathCoordTypeUInt32($0005);
    public static property HORIZONTAL_LINE_TO:                 PathCoordTypeUInt32 read new PathCoordTypeUInt32($0006);
    public static property RELATIVE_HORIZONTAL_LINE_TO:        PathCoordTypeUInt32 read new PathCoordTypeUInt32($0007);
    public static property VERTICAL_LINE_TO:                   PathCoordTypeUInt32 read new PathCoordTypeUInt32($0008);
    public static property RELATIVE_VERTICAL_LINE_TO:          PathCoordTypeUInt32 read new PathCoordTypeUInt32($0009);
    public static property QUADRATIC_CURVE_TO:                 PathCoordTypeUInt32 read new PathCoordTypeUInt32($000A);
    public static property RELATIVE_QUADRATIC_CURVE_TO:        PathCoordTypeUInt32 read new PathCoordTypeUInt32($000B);
    public static property CUBIC_CURVE_TO:                     PathCoordTypeUInt32 read new PathCoordTypeUInt32($000C);
    public static property RELATIVE_CUBIC_CURVE_TO:            PathCoordTypeUInt32 read new PathCoordTypeUInt32($000D);
    public static property SMOOTH_QUADRATIC_CURVE_TO:          PathCoordTypeUInt32 read new PathCoordTypeUInt32($000E);
    public static property RELATIVE_SMOOTH_QUADRATIC_CURVE_TO: PathCoordTypeUInt32 read new PathCoordTypeUInt32($000F);
    public static property SMOOTH_CUBIC_CURVE_TO:              PathCoordTypeUInt32 read new PathCoordTypeUInt32($0010);
    public static property RELATIVE_SMOOTH_CUBIC_CURVE_TO:     PathCoordTypeUInt32 read new PathCoordTypeUInt32($0011);
    public static property SMALL_CCW_ARC_TO:                   PathCoordTypeUInt32 read new PathCoordTypeUInt32($0012);
    public static property RELATIVE_SMALL_CCW_ARC_TO:          PathCoordTypeUInt32 read new PathCoordTypeUInt32($0013);
    public static property SMALL_CW_ARC_TO:                    PathCoordTypeUInt32 read new PathCoordTypeUInt32($0014);
    public static property RELATIVE_SMALL_CW_ARC_TO:           PathCoordTypeUInt32 read new PathCoordTypeUInt32($0015);
    public static property LARGE_CCW_ARC_TO:                   PathCoordTypeUInt32 read new PathCoordTypeUInt32($0016);
    public static property RELATIVE_LARGE_CCW_ARC_TO:          PathCoordTypeUInt32 read new PathCoordTypeUInt32($0017);
    public static property LARGE_CW_ARC_TO:                    PathCoordTypeUInt32 read new PathCoordTypeUInt32($0018);
    public static property RELATIVE_LARGE_CW_ARC_TO:           PathCoordTypeUInt32 read new PathCoordTypeUInt32($0019);
    public static property CONIC_CURVE_TO:                     PathCoordTypeUInt32 read new PathCoordTypeUInt32($001A);
    public static property RELATIVE_CONIC_CURVE_TO:            PathCoordTypeUInt32 read new PathCoordTypeUInt32($001B);
    public static property ROUNDED_RECT:                       PathCoordTypeUInt32 read new PathCoordTypeUInt32($00E8);
    public static property RELATIVE_ROUNDED_RECT:              PathCoordTypeUInt32 read new PathCoordTypeUInt32($00E9);
    public static property ROUNDED_RECT2:                      PathCoordTypeUInt32 read new PathCoordTypeUInt32($00EA);
    public static property RELATIVE_ROUNDED_RECT2:             PathCoordTypeUInt32 read new PathCoordTypeUInt32($00EB);
    public static property ROUNDED_RECT4:                      PathCoordTypeUInt32 read new PathCoordTypeUInt32($00EC);
    public static property RELATIVE_ROUNDED_RECT4:             PathCoordTypeUInt32 read new PathCoordTypeUInt32($00ED);
    public static property ROUNDED_RECT8:                      PathCoordTypeUInt32 read new PathCoordTypeUInt32($00EE);
    public static property RELATIVE_ROUNDED_RECT8:             PathCoordTypeUInt32 read new PathCoordTypeUInt32($00EF);
    public static property RESTART_PATH:                       PathCoordTypeUInt32 read new PathCoordTypeUInt32($00F0);
    public static property DUP_FIRST_CUBIC_CURVE_TO:           PathCoordTypeUInt32 read new PathCoordTypeUInt32($00F2);
    public static property DUP_LAST_CUBIC_CURVE_TO:            PathCoordTypeUInt32 read new PathCoordTypeUInt32($00F4);
    public static property RECT:                               PathCoordTypeUInt32 read new PathCoordTypeUInt32($00F6);
    public static property RELATIVE_RECT:                      PathCoordTypeUInt32 read new PathCoordTypeUInt32($00F7);
    public static property CIRCULAR_CCW_ARC_TO:                PathCoordTypeUInt32 read new PathCoordTypeUInt32($00F8);
    public static property CIRCULAR_CW_ARC_TO:                 PathCoordTypeUInt32 read new PathCoordTypeUInt32($00FA);
    public static property CIRCULAR_TANGENT_ARC_TO:            PathCoordTypeUInt32 read new PathCoordTypeUInt32($00FC);
    public static property ARC_TO:                             PathCoordTypeUInt32 read new PathCoordTypeUInt32($00FE);
    public static property RELATIVE_ARC_TO:                    PathCoordTypeUInt32 read new PathCoordTypeUInt32($00FF);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'CLOSE_PATH' else
      if self.val = UInt32($0002) then Result := 'MOVE_TO' else
      if self.val = UInt32($0003) then Result := 'RELATIVE_MOVE_TO' else
      if self.val = UInt32($0004) then Result := 'LINE_TO' else
      if self.val = UInt32($0005) then Result := 'RELATIVE_LINE_TO' else
      if self.val = UInt32($0006) then Result := 'HORIZONTAL_LINE_TO' else
      if self.val = UInt32($0007) then Result := 'RELATIVE_HORIZONTAL_LINE_TO' else
      if self.val = UInt32($0008) then Result := 'VERTICAL_LINE_TO' else
      if self.val = UInt32($0009) then Result := 'RELATIVE_VERTICAL_LINE_TO' else
      if self.val = UInt32($000A) then Result := 'QUADRATIC_CURVE_TO' else
      if self.val = UInt32($000B) then Result := 'RELATIVE_QUADRATIC_CURVE_TO' else
      if self.val = UInt32($000C) then Result := 'CUBIC_CURVE_TO' else
      if self.val = UInt32($000D) then Result := 'RELATIVE_CUBIC_CURVE_TO' else
      if self.val = UInt32($000E) then Result := 'SMOOTH_QUADRATIC_CURVE_TO' else
      if self.val = UInt32($000F) then Result := 'RELATIVE_SMOOTH_QUADRATIC_CURVE_TO' else
      if self.val = UInt32($0010) then Result := 'SMOOTH_CUBIC_CURVE_TO' else
      if self.val = UInt32($0011) then Result := 'RELATIVE_SMOOTH_CUBIC_CURVE_TO' else
      if self.val = UInt32($0012) then Result := 'SMALL_CCW_ARC_TO' else
      if self.val = UInt32($0013) then Result := 'RELATIVE_SMALL_CCW_ARC_TO' else
      if self.val = UInt32($0014) then Result := 'SMALL_CW_ARC_TO' else
      if self.val = UInt32($0015) then Result := 'RELATIVE_SMALL_CW_ARC_TO' else
      if self.val = UInt32($0016) then Result := 'LARGE_CCW_ARC_TO' else
      if self.val = UInt32($0017) then Result := 'RELATIVE_LARGE_CCW_ARC_TO' else
      if self.val = UInt32($0018) then Result := 'LARGE_CW_ARC_TO' else
      if self.val = UInt32($0019) then Result := 'RELATIVE_LARGE_CW_ARC_TO' else
      if self.val = UInt32($001A) then Result := 'CONIC_CURVE_TO' else
      if self.val = UInt32($001B) then Result := 'RELATIVE_CONIC_CURVE_TO' else
      if self.val = UInt32($00E8) then Result := 'ROUNDED_RECT' else
      if self.val = UInt32($00E9) then Result := 'RELATIVE_ROUNDED_RECT' else
      if self.val = UInt32($00EA) then Result := 'ROUNDED_RECT2' else
      if self.val = UInt32($00EB) then Result := 'RELATIVE_ROUNDED_RECT2' else
      if self.val = UInt32($00EC) then Result := 'ROUNDED_RECT4' else
      if self.val = UInt32($00ED) then Result := 'RELATIVE_ROUNDED_RECT4' else
      if self.val = UInt32($00EE) then Result := 'ROUNDED_RECT8' else
      if self.val = UInt32($00EF) then Result := 'RELATIVE_ROUNDED_RECT8' else
      if self.val = UInt32($00F0) then Result := 'RESTART_PATH' else
      if self.val = UInt32($00F2) then Result := 'DUP_FIRST_CUBIC_CURVE_TO' else
      if self.val = UInt32($00F4) then Result := 'DUP_LAST_CUBIC_CURVE_TO' else
      if self.val = UInt32($00F6) then Result := 'RECT' else
      if self.val = UInt32($00F7) then Result := 'RELATIVE_RECT' else
      if self.val = UInt32($00F8) then Result := 'CIRCULAR_CCW_ARC_TO' else
      if self.val = UInt32($00FA) then Result := 'CIRCULAR_CW_ARC_TO' else
      if self.val = UInt32($00FC) then Result := 'CIRCULAR_TANGENT_ARC_TO' else
      if self.val = UInt32($00FE) then Result := 'ARC_TO' else
      if self.val = UInt32($00FF) then Result := 'RELATIVE_ARC_TO' else
        Result := $'PathCoordTypeUInt32[{self.val}]';
    end;
    
  end;
  
  PathCoverMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PATH_FILL_COVER_MODE: PathCoverMode read new PathCoverMode($9082);
    public static property CONVEX_HULL:          PathCoverMode read new PathCoverMode($908B);
    public static property BOUNDING_BOX:         PathCoverMode read new PathCoverMode($908D);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9082) then Result := 'PATH_FILL_COVER_MODE' else
      if self.val = UInt32($908B) then Result := 'CONVEX_HULL' else
      if self.val = UInt32($908D) then Result := 'BOUNDING_BOX' else
        Result := $'PathCoverMode[{self.val}]';
    end;
    
  end;
  
  PathElementType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UTF8:  PathElementType read new PathElementType($909A);
    public static property UTF16: PathElementType read new PathElementType($909B);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($909A) then Result := 'UTF8' else
      if self.val = UInt32($909B) then Result := 'UTF16' else
        Result := $'PathElementType[{self.val}]';
    end;
    
  end;
  
  PathFillMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property INVERT:         PathFillMode read new PathFillMode($150A);
    public static property PATH_FILL_MODE: PathFillMode read new PathFillMode($9080);
    public static property COUNT_UP:       PathFillMode read new PathFillMode($9088);
    public static property COUNT_DOWN:     PathFillMode read new PathFillMode($9089);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($150A) then Result := 'INVERT' else
      if self.val = UInt32($9080) then Result := 'PATH_FILL_MODE' else
      if self.val = UInt32($9088) then Result := 'COUNT_UP' else
      if self.val = UInt32($9089) then Result := 'COUNT_DOWN' else
        Result := $'PathFillMode[{self.val}]';
    end;
    
  end;
  
  PathFontStyle = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:       PathFontStyle read new PathFontStyle($0000);
    public static property BOLD_BIT:   PathFontStyle read new PathFontStyle($0001);
    public static property ITALIC_BIT: PathFontStyle read new PathFontStyle($0002);
    
    public static function operator+(f1,f2: PathFontStyle) := new PathFontStyle(f1.val or f2.val);
    public static function operator or(f1,f2: PathFontStyle) := f1+f2;
    
    public static procedure operator+=(var f1: PathFontStyle; f2: PathFontStyle) := f1 := f1+f2;
    
    public property ANY_FLAGS: boolean read self.val<>0;
    public property HAS_FLAG_BOLD_BIT:   boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_ITALIC_BIT: boolean read self.val and $0002 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'BOLD_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'ITALIC_BIT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'PathFontStyle[{self.val}]';
    end;
    
  end;
  
  PathFontTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property STANDARD_FONT_NAME: PathFontTarget read new PathFontTarget($9072);
    public static property SYSTEM_FONT_NAME:   PathFontTarget read new PathFontTarget($9073);
    public static property FILE_NAME:          PathFontTarget read new PathFontTarget($9074);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9072) then Result := 'STANDARD_FONT_NAME' else
      if self.val = UInt32($9073) then Result := 'SYSTEM_FONT_NAME' else
      if self.val = UInt32($9074) then Result := 'FILE_NAME' else
        Result := $'PathFontTarget[{self.val}]';
    end;
    
  end;
  
  PathGenMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:                     PathGenMode read new PathGenMode($0000);
    public static property EYE_LINEAR:               PathGenMode read new PathGenMode($2400);
    public static property OBJECT_LINEAR:            PathGenMode read new PathGenMode($2401);
    public static property CONSTANT:                 PathGenMode read new PathGenMode($8576);
    public static property PATH_OBJECT_BOUNDING_BOX: PathGenMode read new PathGenMode($908A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($2400) then Result := 'EYE_LINEAR' else
      if self.val = UInt32($2401) then Result := 'OBJECT_LINEAR' else
      if self.val = UInt32($8576) then Result := 'CONSTANT' else
      if self.val = UInt32($908A) then Result := 'PATH_OBJECT_BOUNDING_BOX' else
        Result := $'PathGenMode[{self.val}]';
    end;
    
  end;
  
  PathHandleMissingGlyphs = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SKIP_MISSING_GLYPH: PathHandleMissingGlyphs read new PathHandleMissingGlyphs($90A9);
    public static property USE_MISSING_GLYPH:  PathHandleMissingGlyphs read new PathHandleMissingGlyphs($90AA);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($90A9) then Result := 'SKIP_MISSING_GLYPH' else
      if self.val = UInt32($90AA) then Result := 'USE_MISSING_GLYPH' else
        Result := $'PathHandleMissingGlyphs[{self.val}]';
    end;
    
  end;
  
  PathListMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACCUM_ADJACENT_PAIRS: PathListMode read new PathListMode($90AD);
    public static property ADJACENT_PAIRS:       PathListMode read new PathListMode($90AE);
    public static property FIRST_TO_REST:        PathListMode read new PathListMode($90AF);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($90AD) then Result := 'ACCUM_ADJACENT_PAIRS' else
      if self.val = UInt32($90AE) then Result := 'ADJACENT_PAIRS' else
      if self.val = UInt32($90AF) then Result := 'FIRST_TO_REST' else
        Result := $'PathListMode[{self.val}]';
    end;
    
  end;
  
  PathMetricMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GLYPH_WIDTH_BIT:                      PathMetricMask read new PathMetricMask($0001);
    public static property GLYPH_HEIGHT_BIT:                     PathMetricMask read new PathMetricMask($0002);
    public static property GLYPH_HORIZONTAL_BEARING_X_BIT:       PathMetricMask read new PathMetricMask($0004);
    public static property GLYPH_HORIZONTAL_BEARING_Y_BIT:       PathMetricMask read new PathMetricMask($0008);
    public static property GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT: PathMetricMask read new PathMetricMask($0010);
    public static property GLYPH_VERTICAL_BEARING_X_BIT:         PathMetricMask read new PathMetricMask($0020);
    public static property GLYPH_VERTICAL_BEARING_Y_BIT:         PathMetricMask read new PathMetricMask($0040);
    public static property GLYPH_VERTICAL_BEARING_ADVANCE_BIT:   PathMetricMask read new PathMetricMask($0080);
    public static property GLYPH_HAS_KERNING_BIT:                PathMetricMask read new PathMetricMask($0100);
    public static property FONT_X_MIN_BOUNDS_BIT:                PathMetricMask read new PathMetricMask($10000);
    public static property FONT_Y_MIN_BOUNDS_BIT:                PathMetricMask read new PathMetricMask($20000);
    public static property FONT_X_MAX_BOUNDS_BIT:                PathMetricMask read new PathMetricMask($40000);
    public static property FONT_Y_MAX_BOUNDS_BIT:                PathMetricMask read new PathMetricMask($80000);
    public static property FONT_UNITS_PER_EM_BIT:                PathMetricMask read new PathMetricMask($100000);
    public static property FONT_ASCENDER_BIT:                    PathMetricMask read new PathMetricMask($200000);
    public static property FONT_DESCENDER_BIT:                   PathMetricMask read new PathMetricMask($400000);
    public static property FONT_HEIGHT_BIT:                      PathMetricMask read new PathMetricMask($800000);
    public static property FONT_MAX_ADVANCE_WIDTH_BIT:           PathMetricMask read new PathMetricMask($1000000);
    public static property FONT_MAX_ADVANCE_HEIGHT_BIT:          PathMetricMask read new PathMetricMask($2000000);
    public static property FONT_UNDERLINE_POSITION_BIT:          PathMetricMask read new PathMetricMask($4000000);
    public static property FONT_UNDERLINE_THICKNESS_BIT:         PathMetricMask read new PathMetricMask($8000000);
    public static property FONT_HAS_KERNING_BIT:                 PathMetricMask read new PathMetricMask($10000000);
    public static property FONT_NUM_GLYPH_INDICES_BIT:           PathMetricMask read new PathMetricMask($20000000);
    
    public static function operator+(f1,f2: PathMetricMask) := new PathMetricMask(f1.val or f2.val);
    public static function operator or(f1,f2: PathMetricMask) := f1+f2;
    
    public static procedure operator+=(var f1: PathMetricMask; f2: PathMetricMask) := f1 := f1+f2;
    
    public property HAS_FLAG_GLYPH_WIDTH_BIT:                      boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_GLYPH_HEIGHT_BIT:                     boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_GLYPH_HORIZONTAL_BEARING_X_BIT:       boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_GLYPH_HORIZONTAL_BEARING_Y_BIT:       boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT: boolean read self.val and $0010 <> 0;
    public property HAS_FLAG_GLYPH_VERTICAL_BEARING_X_BIT:         boolean read self.val and $0020 <> 0;
    public property HAS_FLAG_GLYPH_VERTICAL_BEARING_Y_BIT:         boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_GLYPH_VERTICAL_BEARING_ADVANCE_BIT:   boolean read self.val and $0080 <> 0;
    public property HAS_FLAG_GLYPH_HAS_KERNING_BIT:                boolean read self.val and $0100 <> 0;
    public property HAS_FLAG_FONT_X_MIN_BOUNDS_BIT:                boolean read self.val and $10000 <> 0;
    public property HAS_FLAG_FONT_Y_MIN_BOUNDS_BIT:                boolean read self.val and $20000 <> 0;
    public property HAS_FLAG_FONT_X_MAX_BOUNDS_BIT:                boolean read self.val and $40000 <> 0;
    public property HAS_FLAG_FONT_Y_MAX_BOUNDS_BIT:                boolean read self.val and $80000 <> 0;
    public property HAS_FLAG_FONT_UNITS_PER_EM_BIT:                boolean read self.val and $100000 <> 0;
    public property HAS_FLAG_FONT_ASCENDER_BIT:                    boolean read self.val and $200000 <> 0;
    public property HAS_FLAG_FONT_DESCENDER_BIT:                   boolean read self.val and $400000 <> 0;
    public property HAS_FLAG_FONT_HEIGHT_BIT:                      boolean read self.val and $800000 <> 0;
    public property HAS_FLAG_FONT_MAX_ADVANCE_WIDTH_BIT:           boolean read self.val and $1000000 <> 0;
    public property HAS_FLAG_FONT_MAX_ADVANCE_HEIGHT_BIT:          boolean read self.val and $2000000 <> 0;
    public property HAS_FLAG_FONT_UNDERLINE_POSITION_BIT:          boolean read self.val and $4000000 <> 0;
    public property HAS_FLAG_FONT_UNDERLINE_THICKNESS_BIT:         boolean read self.val and $8000000 <> 0;
    public property HAS_FLAG_FONT_HAS_KERNING_BIT:                 boolean read self.val and $10000000 <> 0;
    public property HAS_FLAG_FONT_NUM_GLYPH_INDICES_BIT:           boolean read self.val and $20000000 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'GLYPH_WIDTH_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'GLYPH_HEIGHT_BIT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'GLYPH_HORIZONTAL_BEARING_X_BIT+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'GLYPH_HORIZONTAL_BEARING_Y_BIT+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT+';
      if self.val and UInt32($0020) = UInt32($0020) then res += 'GLYPH_VERTICAL_BEARING_X_BIT+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'GLYPH_VERTICAL_BEARING_Y_BIT+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'GLYPH_VERTICAL_BEARING_ADVANCE_BIT+';
      if self.val and UInt32($0100) = UInt32($0100) then res += 'GLYPH_HAS_KERNING_BIT+';
      if self.val and UInt32($10000) = UInt32($10000) then res += 'FONT_X_MIN_BOUNDS_BIT+';
      if self.val and UInt32($20000) = UInt32($20000) then res += 'FONT_Y_MIN_BOUNDS_BIT+';
      if self.val and UInt32($40000) = UInt32($40000) then res += 'FONT_X_MAX_BOUNDS_BIT+';
      if self.val and UInt32($80000) = UInt32($80000) then res += 'FONT_Y_MAX_BOUNDS_BIT+';
      if self.val and UInt32($100000) = UInt32($100000) then res += 'FONT_UNITS_PER_EM_BIT+';
      if self.val and UInt32($200000) = UInt32($200000) then res += 'FONT_ASCENDER_BIT+';
      if self.val and UInt32($400000) = UInt32($400000) then res += 'FONT_DESCENDER_BIT+';
      if self.val and UInt32($800000) = UInt32($800000) then res += 'FONT_HEIGHT_BIT+';
      if self.val and UInt32($1000000) = UInt32($1000000) then res += 'FONT_MAX_ADVANCE_WIDTH_BIT+';
      if self.val and UInt32($2000000) = UInt32($2000000) then res += 'FONT_MAX_ADVANCE_HEIGHT_BIT+';
      if self.val and UInt32($4000000) = UInt32($4000000) then res += 'FONT_UNDERLINE_POSITION_BIT+';
      if self.val and UInt32($8000000) = UInt32($8000000) then res += 'FONT_UNDERLINE_THICKNESS_BIT+';
      if self.val and UInt32($10000000) = UInt32($10000000) then res += 'FONT_HAS_KERNING_BIT+';
      if self.val and UInt32($20000000) = UInt32($20000000) then res += 'FONT_NUM_GLYPH_INDICES_BIT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'PathMetricMask[{self.val}]';
    end;
    
  end;
  
  PathParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PATH_STROKE_WIDTH:        PathParameter read new PathParameter($9075);
    public static property PATH_END_CAPS:            PathParameter read new PathParameter($9076);
    public static property PATH_INITIAL_END_CAP:     PathParameter read new PathParameter($9077);
    public static property PATH_TERMINAL_END_CAP:    PathParameter read new PathParameter($9078);
    public static property PATH_JOIN_STYLE:          PathParameter read new PathParameter($9079);
    public static property PATH_MITER_LIMIT:         PathParameter read new PathParameter($907A);
    public static property PATH_DASH_CAPS:           PathParameter read new PathParameter($907B);
    public static property PATH_INITIAL_DASH_CAP:    PathParameter read new PathParameter($907C);
    public static property PATH_TERMINAL_DASH_CAP:   PathParameter read new PathParameter($907D);
    public static property PATH_DASH_OFFSET:         PathParameter read new PathParameter($907E);
    public static property PATH_CLIENT_LENGTH:       PathParameter read new PathParameter($907F);
    public static property PATH_FILL_MODE:           PathParameter read new PathParameter($9080);
    public static property PATH_FILL_MASK:           PathParameter read new PathParameter($9081);
    public static property PATH_FILL_COVER_MODE:     PathParameter read new PathParameter($9082);
    public static property PATH_STROKE_COVER_MODE:   PathParameter read new PathParameter($9083);
    public static property PATH_STROKE_MASK:         PathParameter read new PathParameter($9084);
    public static property PATH_OBJECT_BOUNDING_BOX: PathParameter read new PathParameter($908A);
    public static property PATH_COMMAND_COUNT:       PathParameter read new PathParameter($909D);
    public static property PATH_COORD_COUNT:         PathParameter read new PathParameter($909E);
    public static property PATH_DASH_ARRAY_COUNT:    PathParameter read new PathParameter($909F);
    public static property PATH_COMPUTED_LENGTH:     PathParameter read new PathParameter($90A0);
    public static property PATH_FILL_BOUNDING_BOX:   PathParameter read new PathParameter($90A1);
    public static property PATH_STROKE_BOUNDING_BOX: PathParameter read new PathParameter($90A2);
    public static property PATH_DASH_OFFSET_RESET:   PathParameter read new PathParameter($90B4);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9075) then Result := 'PATH_STROKE_WIDTH' else
      if self.val = UInt32($9076) then Result := 'PATH_END_CAPS' else
      if self.val = UInt32($9077) then Result := 'PATH_INITIAL_END_CAP' else
      if self.val = UInt32($9078) then Result := 'PATH_TERMINAL_END_CAP' else
      if self.val = UInt32($9079) then Result := 'PATH_JOIN_STYLE' else
      if self.val = UInt32($907A) then Result := 'PATH_MITER_LIMIT' else
      if self.val = UInt32($907B) then Result := 'PATH_DASH_CAPS' else
      if self.val = UInt32($907C) then Result := 'PATH_INITIAL_DASH_CAP' else
      if self.val = UInt32($907D) then Result := 'PATH_TERMINAL_DASH_CAP' else
      if self.val = UInt32($907E) then Result := 'PATH_DASH_OFFSET' else
      if self.val = UInt32($907F) then Result := 'PATH_CLIENT_LENGTH' else
      if self.val = UInt32($9080) then Result := 'PATH_FILL_MODE' else
      if self.val = UInt32($9081) then Result := 'PATH_FILL_MASK' else
      if self.val = UInt32($9082) then Result := 'PATH_FILL_COVER_MODE' else
      if self.val = UInt32($9083) then Result := 'PATH_STROKE_COVER_MODE' else
      if self.val = UInt32($9084) then Result := 'PATH_STROKE_MASK' else
      if self.val = UInt32($908A) then Result := 'PATH_OBJECT_BOUNDING_BOX' else
      if self.val = UInt32($909D) then Result := 'PATH_COMMAND_COUNT' else
      if self.val = UInt32($909E) then Result := 'PATH_COORD_COUNT' else
      if self.val = UInt32($909F) then Result := 'PATH_DASH_ARRAY_COUNT' else
      if self.val = UInt32($90A0) then Result := 'PATH_COMPUTED_LENGTH' else
      if self.val = UInt32($90A1) then Result := 'PATH_FILL_BOUNDING_BOX' else
      if self.val = UInt32($90A2) then Result := 'PATH_STROKE_BOUNDING_BOX' else
      if self.val = UInt32($90B4) then Result := 'PATH_DASH_OFFSET_RESET' else
        Result := $'PathParameter[{self.val}]';
    end;
    
  end;
  
  PathStringFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PATH_FORMAT_SVG: PathStringFormat read new PathStringFormat($9070);
    public static property PATH_FORMAT_PS:  PathStringFormat read new PathStringFormat($9071);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9070) then Result := 'PATH_FORMAT_SVG' else
      if self.val = UInt32($9071) then Result := 'PATH_FORMAT_PS' else
        Result := $'PathStringFormat[{self.val}]';
    end;
    
  end;
  
  PathTransformType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:                PathTransformType read new PathTransformType($0000);
    public static property TRANSLATE_X:         PathTransformType read new PathTransformType($908E);
    public static property TRANSLATE_Y:         PathTransformType read new PathTransformType($908F);
    public static property TRANSLATE_2D:        PathTransformType read new PathTransformType($9090);
    public static property TRANSLATE_3D:        PathTransformType read new PathTransformType($9091);
    public static property AFFINE_2D:           PathTransformType read new PathTransformType($9092);
    public static property AFFINE_3D:           PathTransformType read new PathTransformType($9094);
    public static property TRANSPOSE_AFFINE_2D: PathTransformType read new PathTransformType($9096);
    public static property TRANSPOSE_AFFINE_3D: PathTransformType read new PathTransformType($9098);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($908E) then Result := 'TRANSLATE_X' else
      if self.val = UInt32($908F) then Result := 'TRANSLATE_Y' else
      if self.val = UInt32($9090) then Result := 'TRANSLATE_2D' else
      if self.val = UInt32($9091) then Result := 'TRANSLATE_3D' else
      if self.val = UInt32($9092) then Result := 'AFFINE_2D' else
      if self.val = UInt32($9094) then Result := 'AFFINE_3D' else
      if self.val = UInt32($9096) then Result := 'TRANSPOSE_AFFINE_2D' else
      if self.val = UInt32($9098) then Result := 'TRANSPOSE_AFFINE_3D' else
        Result := $'PathTransformType[{self.val}]';
    end;
    
  end;
  
  PerformanceQueryCapsMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PERFQUERY_SINGLE_CONTEXT: PerformanceQueryCapsMask read new PerformanceQueryCapsMask($0000);
    public static property PERFQUERY_GLOBAL_CONTEXT: PerformanceQueryCapsMask read new PerformanceQueryCapsMask($0001);
    
    public static function operator+(f1,f2: PerformanceQueryCapsMask) := new PerformanceQueryCapsMask(f1.val or f2.val);
    public static function operator or(f1,f2: PerformanceQueryCapsMask) := f1+f2;
    
    public static procedure operator+=(var f1: PerformanceQueryCapsMask; f2: PerformanceQueryCapsMask) := f1 := f1+f2;
    
    public property ANY_FLAGS: boolean read self.val<>0;
    public property HAS_FLAG_PERFQUERY_GLOBAL_CONTEXT: boolean read self.val and $0001 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'PERFQUERY_GLOBAL_CONTEXT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'PerformanceQueryCapsMask[{self.val}]';
    end;
    
  end;
  
  PerfQueryDataFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PERFQUERY_DONOT_FLUSH: PerfQueryDataFlags read new PerfQueryDataFlags($83F9);
    public static property PERFQUERY_FLUSH:       PerfQueryDataFlags read new PerfQueryDataFlags($83FA);
    public static property PERFQUERY_WAIT:        PerfQueryDataFlags read new PerfQueryDataFlags($83FB);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($83F9) then Result := 'PERFQUERY_DONOT_FLUSH' else
      if self.val = UInt32($83FA) then Result := 'PERFQUERY_FLUSH' else
      if self.val = UInt32($83FB) then Result := 'PERFQUERY_WAIT' else
        Result := $'PerfQueryDataFlags[{self.val}]';
    end;
    
  end;
  
  PipelineParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_PROGRAM:         PipelineParameterName read new PipelineParameterName($8259);
    public static property FRAGMENT_SHADER:        PipelineParameterName read new PipelineParameterName($8B30);
    public static property VERTEX_SHADER:          PipelineParameterName read new PipelineParameterName($8B31);
    public static property INFO_LOG_LENGTH:        PipelineParameterName read new PipelineParameterName($8B84);
    public static property GEOMETRY_SHADER:        PipelineParameterName read new PipelineParameterName($8DD9);
    public static property TESS_EVALUATION_SHADER: PipelineParameterName read new PipelineParameterName($8E87);
    public static property TESS_CONTROL_SHADER:    PipelineParameterName read new PipelineParameterName($8E88);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8259) then Result := 'ACTIVE_PROGRAM' else
      if self.val = UInt32($8B30) then Result := 'FRAGMENT_SHADER' else
      if self.val = UInt32($8B31) then Result := 'VERTEX_SHADER' else
      if self.val = UInt32($8B84) then Result := 'INFO_LOG_LENGTH' else
      if self.val = UInt32($8DD9) then Result := 'GEOMETRY_SHADER' else
      if self.val = UInt32($8E87) then Result := 'TESS_EVALUATION_SHADER' else
      if self.val = UInt32($8E88) then Result := 'TESS_CONTROL_SHADER' else
        Result := $'PipelineParameterName[{self.val}]';
    end;
    
  end;
  
  PipeParticipationTypeFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DISPLAY_PIPE: PipeParticipationTypeFlags read new PipeParticipationTypeFlags($0001);
    public static property RENDER_PIPE:  PipeParticipationTypeFlags read new PipeParticipationTypeFlags($0002);
    
    public static function operator+(f1,f2: PipeParticipationTypeFlags) := new PipeParticipationTypeFlags(f1.val or f2.val);
    public static function operator or(f1,f2: PipeParticipationTypeFlags) := f1+f2;
    
    public static procedure operator+=(var f1: PipeParticipationTypeFlags; f2: PipeParticipationTypeFlags) := f1 := f1+f2;
    
    public property HAS_FLAG_DISPLAY_PIPE: boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_RENDER_PIPE:  boolean read self.val and $0002 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'DISPLAY_PIPE+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'RENDER_PIPE+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'PipeParticipationTypeFlags[{self.val}]';
    end;
    
  end;
  
  PixelCopyType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COLOR:   PixelCopyType read new PixelCopyType($1800);
    public static property DEPTH:   PixelCopyType read new PixelCopyType($1801);
    public static property STENCIL: PixelCopyType read new PixelCopyType($1802);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1800) then Result := 'COLOR' else
      if self.val = UInt32($1801) then Result := 'DEPTH' else
      if self.val = UInt32($1802) then Result := 'STENCIL' else
        Result := $'PixelCopyType[{self.val}]';
    end;
    
  end;
  
  PixelDataRangeTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property WRITE_PIXEL_DATA_RANGE: PixelDataRangeTarget read new PixelDataRangeTarget($8878);
    public static property READ_PIXEL_DATA_RANGE:  PixelDataRangeTarget read new PixelDataRangeTarget($8879);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8878) then Result := 'WRITE_PIXEL_DATA_RANGE' else
      if self.val = UInt32($8879) then Result := 'READ_PIXEL_DATA_RANGE' else
        Result := $'PixelDataRangeTarget[{self.val}]';
    end;
    
  end;
  
  PixelFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNSIGNED_SHORT:  PixelFormat read new PixelFormat($1403);
    public static property UNSIGNED_INT:    PixelFormat read new PixelFormat($1405);
    public static property COLOR_INDEX:     PixelFormat read new PixelFormat($1900);
    public static property STENCIL_INDEX:   PixelFormat read new PixelFormat($1901);
    public static property DEPTH_COMPONENT: PixelFormat read new PixelFormat($1902);
    public static property RED:             PixelFormat read new PixelFormat($1903);
    public static property GREEN:           PixelFormat read new PixelFormat($1904);
    public static property BLUE:            PixelFormat read new PixelFormat($1905);
    public static property ALPHA:           PixelFormat read new PixelFormat($1906);
    public static property RGB:             PixelFormat read new PixelFormat($1907);
    public static property RGBA:            PixelFormat read new PixelFormat($1908);
    public static property LUMINANCE:       PixelFormat read new PixelFormat($1909);
    public static property LUMINANCE_ALPHA: PixelFormat read new PixelFormat($190A);
    public static property ABGR:            PixelFormat read new PixelFormat($8000);
    public static property CMYK:            PixelFormat read new PixelFormat($800C);
    public static property CMYKA:           PixelFormat read new PixelFormat($800D);
    public static property BGR:             PixelFormat read new PixelFormat($80E0);
    public static property BGRA:            PixelFormat read new PixelFormat($80E1);
    public static property YCRCB_422:       PixelFormat read new PixelFormat($81BB);
    public static property YCRCB_444:       PixelFormat read new PixelFormat($81BC);
    public static property RG:              PixelFormat read new PixelFormat($8227);
    public static property RG_INTEGER:      PixelFormat read new PixelFormat($8228);
    public static property DEPTH_STENCIL:   PixelFormat read new PixelFormat($84F9);
    public static property RED_INTEGER:     PixelFormat read new PixelFormat($8D94);
    public static property GREEN_INTEGER:   PixelFormat read new PixelFormat($8D95);
    public static property BLUE_INTEGER:    PixelFormat read new PixelFormat($8D96);
    public static property RGB_INTEGER:     PixelFormat read new PixelFormat($8D98);
    public static property RGBA_INTEGER:    PixelFormat read new PixelFormat($8D99);
    public static property BGR_INTEGER:     PixelFormat read new PixelFormat($8D9A);
    public static property BGRA_INTEGER:    PixelFormat read new PixelFormat($8D9B);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
      if self.val = UInt32($1900) then Result := 'COLOR_INDEX' else
      if self.val = UInt32($1901) then Result := 'STENCIL_INDEX' else
      if self.val = UInt32($1902) then Result := 'DEPTH_COMPONENT' else
      if self.val = UInt32($1903) then Result := 'RED' else
      if self.val = UInt32($1904) then Result := 'GREEN' else
      if self.val = UInt32($1905) then Result := 'BLUE' else
      if self.val = UInt32($1906) then Result := 'ALPHA' else
      if self.val = UInt32($1907) then Result := 'RGB' else
      if self.val = UInt32($1908) then Result := 'RGBA' else
      if self.val = UInt32($1909) then Result := 'LUMINANCE' else
      if self.val = UInt32($190A) then Result := 'LUMINANCE_ALPHA' else
      if self.val = UInt32($8000) then Result := 'ABGR' else
      if self.val = UInt32($800C) then Result := 'CMYK' else
      if self.val = UInt32($800D) then Result := 'CMYKA' else
      if self.val = UInt32($80E0) then Result := 'BGR' else
      if self.val = UInt32($80E1) then Result := 'BGRA' else
      if self.val = UInt32($81BB) then Result := 'YCRCB_422' else
      if self.val = UInt32($81BC) then Result := 'YCRCB_444' else
      if self.val = UInt32($8227) then Result := 'RG' else
      if self.val = UInt32($8228) then Result := 'RG_INTEGER' else
      if self.val = UInt32($84F9) then Result := 'DEPTH_STENCIL' else
      if self.val = UInt32($8D94) then Result := 'RED_INTEGER' else
      if self.val = UInt32($8D95) then Result := 'GREEN_INTEGER' else
      if self.val = UInt32($8D96) then Result := 'BLUE_INTEGER' else
      if self.val = UInt32($8D98) then Result := 'RGB_INTEGER' else
      if self.val = UInt32($8D99) then Result := 'RGBA_INTEGER' else
      if self.val = UInt32($8D9A) then Result := 'BGR_INTEGER' else
      if self.val = UInt32($8D9B) then Result := 'BGRA_INTEGER' else
        Result := $'PixelFormat[{self.val}]';
    end;
    
  end;
  
  PixelMap = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PIXEL_MAP_I_TO_I: PixelMap read new PixelMap($0C70);
    public static property PIXEL_MAP_S_TO_S: PixelMap read new PixelMap($0C71);
    public static property PIXEL_MAP_I_TO_R: PixelMap read new PixelMap($0C72);
    public static property PIXEL_MAP_I_TO_G: PixelMap read new PixelMap($0C73);
    public static property PIXEL_MAP_I_TO_B: PixelMap read new PixelMap($0C74);
    public static property PIXEL_MAP_I_TO_A: PixelMap read new PixelMap($0C75);
    public static property PIXEL_MAP_R_TO_R: PixelMap read new PixelMap($0C76);
    public static property PIXEL_MAP_G_TO_G: PixelMap read new PixelMap($0C77);
    public static property PIXEL_MAP_B_TO_B: PixelMap read new PixelMap($0C78);
    public static property PIXEL_MAP_A_TO_A: PixelMap read new PixelMap($0C79);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0C70) then Result := 'PIXEL_MAP_I_TO_I' else
      if self.val = UInt32($0C71) then Result := 'PIXEL_MAP_S_TO_S' else
      if self.val = UInt32($0C72) then Result := 'PIXEL_MAP_I_TO_R' else
      if self.val = UInt32($0C73) then Result := 'PIXEL_MAP_I_TO_G' else
      if self.val = UInt32($0C74) then Result := 'PIXEL_MAP_I_TO_B' else
      if self.val = UInt32($0C75) then Result := 'PIXEL_MAP_I_TO_A' else
      if self.val = UInt32($0C76) then Result := 'PIXEL_MAP_R_TO_R' else
      if self.val = UInt32($0C77) then Result := 'PIXEL_MAP_G_TO_G' else
      if self.val = UInt32($0C78) then Result := 'PIXEL_MAP_B_TO_B' else
      if self.val = UInt32($0C79) then Result := 'PIXEL_MAP_A_TO_A' else
        Result := $'PixelMap[{self.val}]';
    end;
    
  end;
  
  PixelStoreParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNPACK_SWAP_BYTES:      PixelStoreParameter read new PixelStoreParameter($0CF0);
    public static property UNPACK_LSB_FIRST:       PixelStoreParameter read new PixelStoreParameter($0CF1);
    public static property UNPACK_ROW_LENGTH:      PixelStoreParameter read new PixelStoreParameter($0CF2);
    public static property UNPACK_SKIP_ROWS:       PixelStoreParameter read new PixelStoreParameter($0CF3);
    public static property UNPACK_SKIP_PIXELS:     PixelStoreParameter read new PixelStoreParameter($0CF4);
    public static property UNPACK_ALIGNMENT:       PixelStoreParameter read new PixelStoreParameter($0CF5);
    public static property PACK_SWAP_BYTES:        PixelStoreParameter read new PixelStoreParameter($0D00);
    public static property PACK_LSB_FIRST:         PixelStoreParameter read new PixelStoreParameter($0D01);
    public static property PACK_ROW_LENGTH:        PixelStoreParameter read new PixelStoreParameter($0D02);
    public static property PACK_SKIP_ROWS:         PixelStoreParameter read new PixelStoreParameter($0D03);
    public static property PACK_SKIP_PIXELS:       PixelStoreParameter read new PixelStoreParameter($0D04);
    public static property PACK_ALIGNMENT:         PixelStoreParameter read new PixelStoreParameter($0D05);
    public static property PACK_SKIP_IMAGES:       PixelStoreParameter read new PixelStoreParameter($806B);
    public static property PACK_IMAGE_HEIGHT:      PixelStoreParameter read new PixelStoreParameter($806C);
    public static property UNPACK_SKIP_IMAGES:     PixelStoreParameter read new PixelStoreParameter($806D);
    public static property UNPACK_IMAGE_HEIGHT:    PixelStoreParameter read new PixelStoreParameter($806E);
    public static property PACK_SKIP_VOLUMES:      PixelStoreParameter read new PixelStoreParameter($8130);
    public static property PACK_IMAGE_DEPTH:       PixelStoreParameter read new PixelStoreParameter($8131);
    public static property UNPACK_SKIP_VOLUMES:    PixelStoreParameter read new PixelStoreParameter($8132);
    public static property UNPACK_IMAGE_DEPTH:     PixelStoreParameter read new PixelStoreParameter($8133);
    public static property PIXEL_TILE_WIDTH:       PixelStoreParameter read new PixelStoreParameter($8140);
    public static property PIXEL_TILE_HEIGHT:      PixelStoreParameter read new PixelStoreParameter($8141);
    public static property PIXEL_TILE_GRID_WIDTH:  PixelStoreParameter read new PixelStoreParameter($8142);
    public static property PIXEL_TILE_GRID_HEIGHT: PixelStoreParameter read new PixelStoreParameter($8143);
    public static property PIXEL_TILE_GRID_DEPTH:  PixelStoreParameter read new PixelStoreParameter($8144);
    public static property PIXEL_TILE_CACHE_SIZE:  PixelStoreParameter read new PixelStoreParameter($8145);
    public static property PACK_RESAMPLE_SGIX:     PixelStoreParameter read new PixelStoreParameter($842E);
    public static property UNPACK_RESAMPLE_SGIX:   PixelStoreParameter read new PixelStoreParameter($842F);
    public static property PACK_SUBSAMPLE_RATE:    PixelStoreParameter read new PixelStoreParameter($85A0);
    public static property UNPACK_SUBSAMPLE_RATE:  PixelStoreParameter read new PixelStoreParameter($85A1);
    public static property PACK_RESAMPLE_OML:      PixelStoreParameter read new PixelStoreParameter($8984);
    public static property UNPACK_RESAMPLE_OML:    PixelStoreParameter read new PixelStoreParameter($8985);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0CF0) then Result := 'UNPACK_SWAP_BYTES' else
      if self.val = UInt32($0CF1) then Result := 'UNPACK_LSB_FIRST' else
      if self.val = UInt32($0CF2) then Result := 'UNPACK_ROW_LENGTH' else
      if self.val = UInt32($0CF3) then Result := 'UNPACK_SKIP_ROWS' else
      if self.val = UInt32($0CF4) then Result := 'UNPACK_SKIP_PIXELS' else
      if self.val = UInt32($0CF5) then Result := 'UNPACK_ALIGNMENT' else
      if self.val = UInt32($0D00) then Result := 'PACK_SWAP_BYTES' else
      if self.val = UInt32($0D01) then Result := 'PACK_LSB_FIRST' else
      if self.val = UInt32($0D02) then Result := 'PACK_ROW_LENGTH' else
      if self.val = UInt32($0D03) then Result := 'PACK_SKIP_ROWS' else
      if self.val = UInt32($0D04) then Result := 'PACK_SKIP_PIXELS' else
      if self.val = UInt32($0D05) then Result := 'PACK_ALIGNMENT' else
      if self.val = UInt32($806B) then Result := 'PACK_SKIP_IMAGES' else
      if self.val = UInt32($806C) then Result := 'PACK_IMAGE_HEIGHT' else
      if self.val = UInt32($806D) then Result := 'UNPACK_SKIP_IMAGES' else
      if self.val = UInt32($806E) then Result := 'UNPACK_IMAGE_HEIGHT' else
      if self.val = UInt32($8130) then Result := 'PACK_SKIP_VOLUMES' else
      if self.val = UInt32($8131) then Result := 'PACK_IMAGE_DEPTH' else
      if self.val = UInt32($8132) then Result := 'UNPACK_SKIP_VOLUMES' else
      if self.val = UInt32($8133) then Result := 'UNPACK_IMAGE_DEPTH' else
      if self.val = UInt32($8140) then Result := 'PIXEL_TILE_WIDTH' else
      if self.val = UInt32($8141) then Result := 'PIXEL_TILE_HEIGHT' else
      if self.val = UInt32($8142) then Result := 'PIXEL_TILE_GRID_WIDTH' else
      if self.val = UInt32($8143) then Result := 'PIXEL_TILE_GRID_HEIGHT' else
      if self.val = UInt32($8144) then Result := 'PIXEL_TILE_GRID_DEPTH' else
      if self.val = UInt32($8145) then Result := 'PIXEL_TILE_CACHE_SIZE' else
      if self.val = UInt32($842E) then Result := 'PACK_RESAMPLE_SGIX' else
      if self.val = UInt32($842F) then Result := 'UNPACK_RESAMPLE_SGIX' else
      if self.val = UInt32($85A0) then Result := 'PACK_SUBSAMPLE_RATE' else
      if self.val = UInt32($85A1) then Result := 'UNPACK_SUBSAMPLE_RATE' else
      if self.val = UInt32($8984) then Result := 'PACK_RESAMPLE_OML' else
      if self.val = UInt32($8985) then Result := 'UNPACK_RESAMPLE_OML' else
        Result := $'PixelStoreParameter[{self.val}]';
    end;
    
  end;
  
  PixelStoreResampleMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RESAMPLE_DECIMATE:  PixelStoreResampleMode read new PixelStoreResampleMode($8430);
    public static property RESAMPLE_REPLICATE: PixelStoreResampleMode read new PixelStoreResampleMode($8433);
    public static property RESAMPLE_ZERO_FILL: PixelStoreResampleMode read new PixelStoreResampleMode($8434);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8430) then Result := 'RESAMPLE_DECIMATE' else
      if self.val = UInt32($8433) then Result := 'RESAMPLE_REPLICATE' else
      if self.val = UInt32($8434) then Result := 'RESAMPLE_ZERO_FILL' else
        Result := $'PixelStoreResampleMode[{self.val}]';
    end;
    
  end;
  
  PixelStoreSubsampleRate = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PIXEL_SUBSAMPLE_4444: PixelStoreSubsampleRate read new PixelStoreSubsampleRate($85A2);
    public static property PIXEL_SUBSAMPLE_2424: PixelStoreSubsampleRate read new PixelStoreSubsampleRate($85A3);
    public static property PIXEL_SUBSAMPLE_4242: PixelStoreSubsampleRate read new PixelStoreSubsampleRate($85A4);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($85A2) then Result := 'PIXEL_SUBSAMPLE_4444' else
      if self.val = UInt32($85A3) then Result := 'PIXEL_SUBSAMPLE_2424' else
      if self.val = UInt32($85A4) then Result := 'PIXEL_SUBSAMPLE_4242' else
        Result := $'PixelStoreSubsampleRate[{self.val}]';
    end;
    
  end;
  
  PixelTexGenMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:                    PixelTexGenMode read new PixelTexGenMode($0000);
    public static property ALPHA:                   PixelTexGenMode read new PixelTexGenMode($1906);
    public static property RGB:                     PixelTexGenMode read new PixelTexGenMode($1907);
    public static property RGBA:                    PixelTexGenMode read new PixelTexGenMode($1908);
    public static property PIXEL_TEX_GEN_Q_CEILING: PixelTexGenMode read new PixelTexGenMode($8184);
    public static property PIXEL_TEX_GEN_Q_ROUND:   PixelTexGenMode read new PixelTexGenMode($8185);
    public static property PIXEL_TEX_GEN_Q_FLOOR:   PixelTexGenMode read new PixelTexGenMode($8186);
    public static property PIXEL_TEX_GEN_ALPHA_LS:  PixelTexGenMode read new PixelTexGenMode($8189);
    public static property PIXEL_TEX_GEN_ALPHA_MS:  PixelTexGenMode read new PixelTexGenMode($818A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($1906) then Result := 'ALPHA' else
      if self.val = UInt32($1907) then Result := 'RGB' else
      if self.val = UInt32($1908) then Result := 'RGBA' else
      if self.val = UInt32($8184) then Result := 'PIXEL_TEX_GEN_Q_CEILING' else
      if self.val = UInt32($8185) then Result := 'PIXEL_TEX_GEN_Q_ROUND' else
      if self.val = UInt32($8186) then Result := 'PIXEL_TEX_GEN_Q_FLOOR' else
      if self.val = UInt32($8189) then Result := 'PIXEL_TEX_GEN_ALPHA_LS' else
      if self.val = UInt32($818A) then Result := 'PIXEL_TEX_GEN_ALPHA_MS' else
        Result := $'PixelTexGenMode[{self.val}]';
    end;
    
  end;
  
  PixelTexGenParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PIXEL_FRAGMENT_RGB_SOURCE:   PixelTexGenParameterName read new PixelTexGenParameterName($8354);
    public static property PIXEL_FRAGMENT_ALPHA_SOURCE: PixelTexGenParameterName read new PixelTexGenParameterName($8355);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8354) then Result := 'PIXEL_FRAGMENT_RGB_SOURCE' else
      if self.val = UInt32($8355) then Result := 'PIXEL_FRAGMENT_ALPHA_SOURCE' else
        Result := $'PixelTexGenParameterName[{self.val}]';
    end;
    
  end;
  
  PixelTransferParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MAP_COLOR:                     PixelTransferParameter read new PixelTransferParameter($0D10);
    public static property MAP_STENCIL:                   PixelTransferParameter read new PixelTransferParameter($0D11);
    public static property INDEX_SHIFT:                   PixelTransferParameter read new PixelTransferParameter($0D12);
    public static property INDEX_OFFSET:                  PixelTransferParameter read new PixelTransferParameter($0D13);
    public static property RED_SCALE:                     PixelTransferParameter read new PixelTransferParameter($0D14);
    public static property RED_BIAS:                      PixelTransferParameter read new PixelTransferParameter($0D15);
    public static property GREEN_SCALE:                   PixelTransferParameter read new PixelTransferParameter($0D18);
    public static property GREEN_BIAS:                    PixelTransferParameter read new PixelTransferParameter($0D19);
    public static property BLUE_SCALE:                    PixelTransferParameter read new PixelTransferParameter($0D1A);
    public static property BLUE_BIAS:                     PixelTransferParameter read new PixelTransferParameter($0D1B);
    public static property ALPHA_SCALE:                   PixelTransferParameter read new PixelTransferParameter($0D1C);
    public static property ALPHA_BIAS:                    PixelTransferParameter read new PixelTransferParameter($0D1D);
    public static property DEPTH_SCALE:                   PixelTransferParameter read new PixelTransferParameter($0D1E);
    public static property DEPTH_BIAS:                    PixelTransferParameter read new PixelTransferParameter($0D1F);
    public static property POST_CONVOLUTION_RED_SCALE:    PixelTransferParameter read new PixelTransferParameter($801C);
    public static property POST_CONVOLUTION_GREEN_SCALE:  PixelTransferParameter read new PixelTransferParameter($801D);
    public static property POST_CONVOLUTION_BLUE_SCALE:   PixelTransferParameter read new PixelTransferParameter($801E);
    public static property POST_CONVOLUTION_ALPHA_SCALE:  PixelTransferParameter read new PixelTransferParameter($801F);
    public static property POST_CONVOLUTION_RED_BIAS:     PixelTransferParameter read new PixelTransferParameter($8020);
    public static property POST_CONVOLUTION_GREEN_BIAS:   PixelTransferParameter read new PixelTransferParameter($8021);
    public static property POST_CONVOLUTION_BLUE_BIAS:    PixelTransferParameter read new PixelTransferParameter($8022);
    public static property POST_CONVOLUTION_ALPHA_BIAS:   PixelTransferParameter read new PixelTransferParameter($8023);
    public static property POST_COLOR_MATRIX_RED_SCALE:   PixelTransferParameter read new PixelTransferParameter($80B4);
    public static property POST_COLOR_MATRIX_GREEN_SCALE: PixelTransferParameter read new PixelTransferParameter($80B5);
    public static property POST_COLOR_MATRIX_BLUE_SCALE:  PixelTransferParameter read new PixelTransferParameter($80B6);
    public static property POST_COLOR_MATRIX_ALPHA_SCALE: PixelTransferParameter read new PixelTransferParameter($80B7);
    public static property POST_COLOR_MATRIX_RED_BIAS:    PixelTransferParameter read new PixelTransferParameter($80B8);
    public static property POST_COLOR_MATRIX_GREEN_BIAS:  PixelTransferParameter read new PixelTransferParameter($80B9);
    public static property POST_COLOR_MATRIX_BLUE_BIAS:   PixelTransferParameter read new PixelTransferParameter($80BA);
    public static property POST_COLOR_MATRIX_ALPHA_BIAS:  PixelTransferParameter read new PixelTransferParameter($80BB);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0D10) then Result := 'MAP_COLOR' else
      if self.val = UInt32($0D11) then Result := 'MAP_STENCIL' else
      if self.val = UInt32($0D12) then Result := 'INDEX_SHIFT' else
      if self.val = UInt32($0D13) then Result := 'INDEX_OFFSET' else
      if self.val = UInt32($0D14) then Result := 'RED_SCALE' else
      if self.val = UInt32($0D15) then Result := 'RED_BIAS' else
      if self.val = UInt32($0D18) then Result := 'GREEN_SCALE' else
      if self.val = UInt32($0D19) then Result := 'GREEN_BIAS' else
      if self.val = UInt32($0D1A) then Result := 'BLUE_SCALE' else
      if self.val = UInt32($0D1B) then Result := 'BLUE_BIAS' else
      if self.val = UInt32($0D1C) then Result := 'ALPHA_SCALE' else
      if self.val = UInt32($0D1D) then Result := 'ALPHA_BIAS' else
      if self.val = UInt32($0D1E) then Result := 'DEPTH_SCALE' else
      if self.val = UInt32($0D1F) then Result := 'DEPTH_BIAS' else
      if self.val = UInt32($801C) then Result := 'POST_CONVOLUTION_RED_SCALE' else
      if self.val = UInt32($801D) then Result := 'POST_CONVOLUTION_GREEN_SCALE' else
      if self.val = UInt32($801E) then Result := 'POST_CONVOLUTION_BLUE_SCALE' else
      if self.val = UInt32($801F) then Result := 'POST_CONVOLUTION_ALPHA_SCALE' else
      if self.val = UInt32($8020) then Result := 'POST_CONVOLUTION_RED_BIAS' else
      if self.val = UInt32($8021) then Result := 'POST_CONVOLUTION_GREEN_BIAS' else
      if self.val = UInt32($8022) then Result := 'POST_CONVOLUTION_BLUE_BIAS' else
      if self.val = UInt32($8023) then Result := 'POST_CONVOLUTION_ALPHA_BIAS' else
      if self.val = UInt32($80B4) then Result := 'POST_COLOR_MATRIX_RED_SCALE' else
      if self.val = UInt32($80B5) then Result := 'POST_COLOR_MATRIX_GREEN_SCALE' else
      if self.val = UInt32($80B6) then Result := 'POST_COLOR_MATRIX_BLUE_SCALE' else
      if self.val = UInt32($80B7) then Result := 'POST_COLOR_MATRIX_ALPHA_SCALE' else
      if self.val = UInt32($80B8) then Result := 'POST_COLOR_MATRIX_RED_BIAS' else
      if self.val = UInt32($80B9) then Result := 'POST_COLOR_MATRIX_GREEN_BIAS' else
      if self.val = UInt32($80BA) then Result := 'POST_COLOR_MATRIX_BLUE_BIAS' else
      if self.val = UInt32($80BB) then Result := 'POST_COLOR_MATRIX_ALPHA_BIAS' else
        Result := $'PixelTransferParameter[{self.val}]';
    end;
    
  end;
  
  PixelTransformPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PIXEL_MAG_FILTER:   PixelTransformPName read new PixelTransformPName($8331);
    public static property PIXEL_MIN_FILTER:   PixelTransformPName read new PixelTransformPName($8332);
    public static property PIXEL_CUBIC_WEIGHT: PixelTransformPName read new PixelTransformPName($8333);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8331) then Result := 'PIXEL_MAG_FILTER' else
      if self.val = UInt32($8332) then Result := 'PIXEL_MIN_FILTER' else
      if self.val = UInt32($8333) then Result := 'PIXEL_CUBIC_WEIGHT' else
        Result := $'PixelTransformPName[{self.val}]';
    end;
    
  end;
  
  PixelTransformTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PIXEL_TRANSFORM_2D: PixelTransformTarget read new PixelTransformTarget($8330);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8330) then Result := 'PIXEL_TRANSFORM_2D' else
        Result := $'PixelTransformTarget[{self.val}]';
    end;
    
  end;
  
  PixelType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:                           PixelType read new PixelType($1400);
    public static property UNSIGNED_BYTE:                  PixelType read new PixelType($1401);
    public static property SHORT:                          PixelType read new PixelType($1402);
    public static property UNSIGNED_SHORT:                 PixelType read new PixelType($1403);
    public static property INT:                            PixelType read new PixelType($1404);
    public static property UNSIGNED_INT:                   PixelType read new PixelType($1405);
    public static property FLOAT:                          PixelType read new PixelType($1406);
    public static property HALF_FLOAT:                     PixelType read new PixelType($140B);
    public static property HALF:                           PixelType read new PixelType($140B);
    public static property BITMAP:                         PixelType read new PixelType($1A00);
    public static property UNSIGNED_BYTE_3_3_2:            PixelType read new PixelType($8032);
    public static property UNSIGNED_SHORT_4_4_4_4:         PixelType read new PixelType($8033);
    public static property UNSIGNED_SHORT_5_5_5_1:         PixelType read new PixelType($8034);
    public static property UNSIGNED_INT_8_8_8_8:           PixelType read new PixelType($8035);
    public static property UNSIGNED_INT_10_10_10_2:        PixelType read new PixelType($8036);
    public static property UNSIGNED_BYTE_2_3_3_REV:        PixelType read new PixelType($8362);
    public static property UNSIGNED_SHORT_5_6_5:           PixelType read new PixelType($8363);
    public static property UNSIGNED_SHORT_5_6_5_REV:       PixelType read new PixelType($8364);
    public static property UNSIGNED_SHORT_4_4_4_4_REV:     PixelType read new PixelType($8365);
    public static property UNSIGNED_SHORT_1_5_5_5_REV:     PixelType read new PixelType($8366);
    public static property UNSIGNED_INT_8_8_8_8_REV:       PixelType read new PixelType($8367);
    public static property UNSIGNED_INT_2_10_10_10_REV:    PixelType read new PixelType($8368);
    public static property UNSIGNED_INT_24_8:              PixelType read new PixelType($84FA);
    public static property UNSIGNED_INT_10F_11F_11F_REV:   PixelType read new PixelType($8C3B);
    public static property UNSIGNED_INT_5_9_9_9_REV:       PixelType read new PixelType($8C3E);
    public static property FLOAT_32_UNSIGNED_INT_24_8_REV: PixelType read new PixelType($8DAD);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140B) then Result := 'HALF_FLOAT' else
      if self.val = UInt32($140B) then Result := 'HALF' else
      if self.val = UInt32($1A00) then Result := 'BITMAP' else
      if self.val = UInt32($8032) then Result := 'UNSIGNED_BYTE_3_3_2' else
      if self.val = UInt32($8033) then Result := 'UNSIGNED_SHORT_4_4_4_4' else
      if self.val = UInt32($8034) then Result := 'UNSIGNED_SHORT_5_5_5_1' else
      if self.val = UInt32($8035) then Result := 'UNSIGNED_INT_8_8_8_8' else
      if self.val = UInt32($8036) then Result := 'UNSIGNED_INT_10_10_10_2' else
      if self.val = UInt32($8362) then Result := 'UNSIGNED_BYTE_2_3_3_REV' else
      if self.val = UInt32($8363) then Result := 'UNSIGNED_SHORT_5_6_5' else
      if self.val = UInt32($8364) then Result := 'UNSIGNED_SHORT_5_6_5_REV' else
      if self.val = UInt32($8365) then Result := 'UNSIGNED_SHORT_4_4_4_4_REV' else
      if self.val = UInt32($8366) then Result := 'UNSIGNED_SHORT_1_5_5_5_REV' else
      if self.val = UInt32($8367) then Result := 'UNSIGNED_INT_8_8_8_8_REV' else
      if self.val = UInt32($8368) then Result := 'UNSIGNED_INT_2_10_10_10_REV' else
      if self.val = UInt32($84FA) then Result := 'UNSIGNED_INT_24_8' else
      if self.val = UInt32($8C3B) then Result := 'UNSIGNED_INT_10F_11F_11F_REV' else
      if self.val = UInt32($8C3E) then Result := 'UNSIGNED_INT_5_9_9_9_REV' else
      if self.val = UInt32($8DAD) then Result := 'FLOAT_32_UNSIGNED_INT_24_8_REV' else
        Result := $'PixelType[{self.val}]';
    end;
    
  end;
  
  PNTrianglesPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PN_TRIANGLES_POINT_MODE:        PNTrianglesPName read new PNTrianglesPName($87F2);
    public static property PN_TRIANGLES_NORMAL_MODE:       PNTrianglesPName read new PNTrianglesPName($87F3);
    public static property PN_TRIANGLES_TESSELATION_LEVEL: PNTrianglesPName read new PNTrianglesPName($87F4);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($87F2) then Result := 'PN_TRIANGLES_POINT_MODE' else
      if self.val = UInt32($87F3) then Result := 'PN_TRIANGLES_NORMAL_MODE' else
      if self.val = UInt32($87F4) then Result := 'PN_TRIANGLES_TESSELATION_LEVEL' else
        Result := $'PNTrianglesPName[{self.val}]';
    end;
    
  end;
  
  PointParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINT_SIZE_MIN:             PointParameterName read new PointParameterName($8126);
    public static property POINT_SIZE_MAX:             PointParameterName read new PointParameterName($8127);
    public static property POINT_FADE_THRESHOLD_SIZE:  PointParameterName read new PointParameterName($8128);
    public static property DISTANCE_ATTENUATION:       PointParameterName read new PointParameterName($8129);
    public static property POINT_DISTANCE_ATTENUATION: PointParameterName read new PointParameterName($8129);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8126) then Result := 'POINT_SIZE_MIN' else
      if self.val = UInt32($8127) then Result := 'POINT_SIZE_MAX' else
      if self.val = UInt32($8128) then Result := 'POINT_FADE_THRESHOLD_SIZE' else
      if self.val = UInt32($8129) then Result := 'DISTANCE_ATTENUATION' else
      if self.val = UInt32($8129) then Result := 'POINT_DISTANCE_ATTENUATION' else
        Result := $'PointParameterName[{self.val}]';
    end;
    
  end;
  
  PolygonMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINT: PolygonMode read new PolygonMode($1B00);
    public static property LINE:  PolygonMode read new PolygonMode($1B01);
    public static property FILL:  PolygonMode read new PolygonMode($1B02);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1B00) then Result := 'POINT' else
      if self.val = UInt32($1B01) then Result := 'LINE' else
      if self.val = UInt32($1B02) then Result := 'FILL' else
        Result := $'PolygonMode[{self.val}]';
    end;
    
  end;
  
  PrecisionType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LOW_FLOAT:    PrecisionType read new PrecisionType($8DF0);
    public static property MEDIUM_FLOAT: PrecisionType read new PrecisionType($8DF1);
    public static property HIGH_FLOAT:   PrecisionType read new PrecisionType($8DF2);
    public static property LOW_INT:      PrecisionType read new PrecisionType($8DF3);
    public static property MEDIUM_INT:   PrecisionType read new PrecisionType($8DF4);
    public static property HIGH_INT:     PrecisionType read new PrecisionType($8DF5);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8DF0) then Result := 'LOW_FLOAT' else
      if self.val = UInt32($8DF1) then Result := 'MEDIUM_FLOAT' else
      if self.val = UInt32($8DF2) then Result := 'HIGH_FLOAT' else
      if self.val = UInt32($8DF3) then Result := 'LOW_INT' else
      if self.val = UInt32($8DF4) then Result := 'MEDIUM_INT' else
      if self.val = UInt32($8DF5) then Result := 'HIGH_INT' else
        Result := $'PrecisionType[{self.val}]';
    end;
    
  end;
  
  PreserveMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PRESERVE:    PreserveMode read new PreserveMode($8762);
    public static property DISCARD_ATI: PreserveMode read new PreserveMode($8763);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8762) then Result := 'PRESERVE' else
      if self.val = UInt32($8763) then Result := 'DISCARD_ATI' else
        Result := $'PreserveMode[{self.val}]';
    end;
    
  end;
  
  PrimitiveType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINTS:                   PrimitiveType read new PrimitiveType($0000);
    public static property LINES:                    PrimitiveType read new PrimitiveType($0001);
    public static property LINE_LOOP:                PrimitiveType read new PrimitiveType($0002);
    public static property LINE_STRIP:               PrimitiveType read new PrimitiveType($0003);
    public static property TRIANGLES:                PrimitiveType read new PrimitiveType($0004);
    public static property TRIANGLE_STRIP:           PrimitiveType read new PrimitiveType($0005);
    public static property TRIANGLE_FAN:             PrimitiveType read new PrimitiveType($0006);
    public static property QUADS:                    PrimitiveType read new PrimitiveType($0007);
    public static property QUAD_STRIP:               PrimitiveType read new PrimitiveType($0008);
    public static property POLYGON:                  PrimitiveType read new PrimitiveType($0009);
    public static property LINES_ADJACENCY:          PrimitiveType read new PrimitiveType($000A);
    public static property LINE_STRIP_ADJACENCY:     PrimitiveType read new PrimitiveType($000B);
    public static property TRIANGLES_ADJACENCY:      PrimitiveType read new PrimitiveType($000C);
    public static property TRIANGLE_STRIP_ADJACENCY: PrimitiveType read new PrimitiveType($000D);
    public static property PATCHES:                  PrimitiveType read new PrimitiveType($000E);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'POINTS' else
      if self.val = UInt32($0001) then Result := 'LINES' else
      if self.val = UInt32($0002) then Result := 'LINE_LOOP' else
      if self.val = UInt32($0003) then Result := 'LINE_STRIP' else
      if self.val = UInt32($0004) then Result := 'TRIANGLES' else
      if self.val = UInt32($0005) then Result := 'TRIANGLE_STRIP' else
      if self.val = UInt32($0006) then Result := 'TRIANGLE_FAN' else
      if self.val = UInt32($0007) then Result := 'QUADS' else
      if self.val = UInt32($0008) then Result := 'QUAD_STRIP' else
      if self.val = UInt32($0009) then Result := 'POLYGON' else
      if self.val = UInt32($000A) then Result := 'LINES_ADJACENCY' else
      if self.val = UInt32($000B) then Result := 'LINE_STRIP_ADJACENCY' else
      if self.val = UInt32($000C) then Result := 'TRIANGLES_ADJACENCY' else
      if self.val = UInt32($000D) then Result := 'TRIANGLE_STRIP_ADJACENCY' else
      if self.val = UInt32($000E) then Result := 'PATCHES' else
        Result := $'PrimitiveType[{self.val}]';
    end;
    
  end;
  
  ProgramFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROGRAM_FORMAT_ASCII: ProgramFormat read new ProgramFormat($8875);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8875) then Result := 'PROGRAM_FORMAT_ASCII' else
        Result := $'ProgramFormat[{self.val}]';
    end;
    
  end;
  
  ProgramInterface = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TRANSFORM_FEEDBACK_BUFFER:          ProgramInterface read new ProgramInterface($8C8E);
    public static property UNIFORM:                            ProgramInterface read new ProgramInterface($92E1);
    public static property UNIFORM_BLOCK:                      ProgramInterface read new ProgramInterface($92E2);
    public static property PROGRAM_INPUT:                      ProgramInterface read new ProgramInterface($92E3);
    public static property PROGRAM_OUTPUT:                     ProgramInterface read new ProgramInterface($92E4);
    public static property BUFFER_VARIABLE:                    ProgramInterface read new ProgramInterface($92E5);
    public static property SHADER_STORAGE_BLOCK:               ProgramInterface read new ProgramInterface($92E6);
    public static property VERTEX_SUBROUTINE:                  ProgramInterface read new ProgramInterface($92E8);
    public static property TESS_CONTROL_SUBROUTINE:            ProgramInterface read new ProgramInterface($92E9);
    public static property TESS_EVALUATION_SUBROUTINE:         ProgramInterface read new ProgramInterface($92EA);
    public static property GEOMETRY_SUBROUTINE:                ProgramInterface read new ProgramInterface($92EB);
    public static property FRAGMENT_SUBROUTINE:                ProgramInterface read new ProgramInterface($92EC);
    public static property COMPUTE_SUBROUTINE:                 ProgramInterface read new ProgramInterface($92ED);
    public static property VERTEX_SUBROUTINE_UNIFORM:          ProgramInterface read new ProgramInterface($92EE);
    public static property TESS_CONTROL_SUBROUTINE_UNIFORM:    ProgramInterface read new ProgramInterface($92EF);
    public static property TESS_EVALUATION_SUBROUTINE_UNIFORM: ProgramInterface read new ProgramInterface($92F0);
    public static property GEOMETRY_SUBROUTINE_UNIFORM:        ProgramInterface read new ProgramInterface($92F1);
    public static property FRAGMENT_SUBROUTINE_UNIFORM:        ProgramInterface read new ProgramInterface($92F2);
    public static property COMPUTE_SUBROUTINE_UNIFORM:         ProgramInterface read new ProgramInterface($92F3);
    public static property TRANSFORM_FEEDBACK_VARYING:         ProgramInterface read new ProgramInterface($92F4);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8C8E) then Result := 'TRANSFORM_FEEDBACK_BUFFER' else
      if self.val = UInt32($92E1) then Result := 'UNIFORM' else
      if self.val = UInt32($92E2) then Result := 'UNIFORM_BLOCK' else
      if self.val = UInt32($92E3) then Result := 'PROGRAM_INPUT' else
      if self.val = UInt32($92E4) then Result := 'PROGRAM_OUTPUT' else
      if self.val = UInt32($92E5) then Result := 'BUFFER_VARIABLE' else
      if self.val = UInt32($92E6) then Result := 'SHADER_STORAGE_BLOCK' else
      if self.val = UInt32($92E8) then Result := 'VERTEX_SUBROUTINE' else
      if self.val = UInt32($92E9) then Result := 'TESS_CONTROL_SUBROUTINE' else
      if self.val = UInt32($92EA) then Result := 'TESS_EVALUATION_SUBROUTINE' else
      if self.val = UInt32($92EB) then Result := 'GEOMETRY_SUBROUTINE' else
      if self.val = UInt32($92EC) then Result := 'FRAGMENT_SUBROUTINE' else
      if self.val = UInt32($92ED) then Result := 'COMPUTE_SUBROUTINE' else
      if self.val = UInt32($92EE) then Result := 'VERTEX_SUBROUTINE_UNIFORM' else
      if self.val = UInt32($92EF) then Result := 'TESS_CONTROL_SUBROUTINE_UNIFORM' else
      if self.val = UInt32($92F0) then Result := 'TESS_EVALUATION_SUBROUTINE_UNIFORM' else
      if self.val = UInt32($92F1) then Result := 'GEOMETRY_SUBROUTINE_UNIFORM' else
      if self.val = UInt32($92F2) then Result := 'FRAGMENT_SUBROUTINE_UNIFORM' else
      if self.val = UInt32($92F3) then Result := 'COMPUTE_SUBROUTINE_UNIFORM' else
      if self.val = UInt32($92F4) then Result := 'TRANSFORM_FEEDBACK_VARYING' else
        Result := $'ProgramInterface[{self.val}]';
    end;
    
  end;
  
  ProgramInterfacePName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_RESOURCES:               ProgramInterfacePName read new ProgramInterfacePName($92F5);
    public static property MAX_NAME_LENGTH:                ProgramInterfacePName read new ProgramInterfacePName($92F6);
    public static property MAX_NUM_ACTIVE_VARIABLES:       ProgramInterfacePName read new ProgramInterfacePName($92F7);
    public static property MAX_NUM_COMPATIBLE_SUBROUTINES: ProgramInterfacePName read new ProgramInterfacePName($92F8);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($92F5) then Result := 'ACTIVE_RESOURCES' else
      if self.val = UInt32($92F6) then Result := 'MAX_NAME_LENGTH' else
      if self.val = UInt32($92F7) then Result := 'MAX_NUM_ACTIVE_VARIABLES' else
      if self.val = UInt32($92F8) then Result := 'MAX_NUM_COMPATIBLE_SUBROUTINES' else
        Result := $'ProgramInterfacePName[{self.val}]';
    end;
    
  end;
  
  ProgramParameterPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROGRAM_BINARY_RETRIEVABLE_HINT: ProgramParameterPName read new ProgramParameterPName($8257);
    public static property PROGRAM_SEPARABLE:               ProgramParameterPName read new ProgramParameterPName($8258);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8257) then Result := 'PROGRAM_BINARY_RETRIEVABLE_HINT' else
      if self.val = UInt32($8258) then Result := 'PROGRAM_SEPARABLE' else
        Result := $'ProgramParameterPName[{self.val}]';
    end;
    
  end;
  
  ProgramProperty = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMPUTE_WORK_GROUP_SIZE:               ProgramProperty read new ProgramProperty($8267);
    public static property PROGRAM_BINARY_LENGTH:                 ProgramProperty read new ProgramProperty($8741);
    public static property GEOMETRY_VERTICES_OUT:                 ProgramProperty read new ProgramProperty($8916);
    public static property GEOMETRY_INPUT_TYPE:                   ProgramProperty read new ProgramProperty($8917);
    public static property GEOMETRY_OUTPUT_TYPE:                  ProgramProperty read new ProgramProperty($8918);
    public static property ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH:  ProgramProperty read new ProgramProperty($8A35);
    public static property ACTIVE_UNIFORM_BLOCKS:                 ProgramProperty read new ProgramProperty($8A36);
    public static property DELETE_STATUS:                         ProgramProperty read new ProgramProperty($8B80);
    public static property LINK_STATUS:                           ProgramProperty read new ProgramProperty($8B82);
    public static property VALIDATE_STATUS:                       ProgramProperty read new ProgramProperty($8B83);
    public static property INFO_LOG_LENGTH:                       ProgramProperty read new ProgramProperty($8B84);
    public static property ATTACHED_SHADERS:                      ProgramProperty read new ProgramProperty($8B85);
    public static property ACTIVE_UNIFORMS:                       ProgramProperty read new ProgramProperty($8B86);
    public static property ACTIVE_UNIFORM_MAX_LENGTH:             ProgramProperty read new ProgramProperty($8B87);
    public static property ACTIVE_ATTRIBUTES:                     ProgramProperty read new ProgramProperty($8B89);
    public static property ACTIVE_ATTRIBUTE_MAX_LENGTH:           ProgramProperty read new ProgramProperty($8B8A);
    public static property TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: ProgramProperty read new ProgramProperty($8C76);
    public static property TRANSFORM_FEEDBACK_BUFFER_MODE:        ProgramProperty read new ProgramProperty($8C7F);
    public static property TRANSFORM_FEEDBACK_VARYINGS:           ProgramProperty read new ProgramProperty($8C83);
    public static property ACTIVE_ATOMIC_COUNTER_BUFFERS:         ProgramProperty read new ProgramProperty($92D9);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8267) then Result := 'COMPUTE_WORK_GROUP_SIZE' else
      if self.val = UInt32($8741) then Result := 'PROGRAM_BINARY_LENGTH' else
      if self.val = UInt32($8916) then Result := 'GEOMETRY_VERTICES_OUT' else
      if self.val = UInt32($8917) then Result := 'GEOMETRY_INPUT_TYPE' else
      if self.val = UInt32($8918) then Result := 'GEOMETRY_OUTPUT_TYPE' else
      if self.val = UInt32($8A35) then Result := 'ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH' else
      if self.val = UInt32($8A36) then Result := 'ACTIVE_UNIFORM_BLOCKS' else
      if self.val = UInt32($8B80) then Result := 'DELETE_STATUS' else
      if self.val = UInt32($8B82) then Result := 'LINK_STATUS' else
      if self.val = UInt32($8B83) then Result := 'VALIDATE_STATUS' else
      if self.val = UInt32($8B84) then Result := 'INFO_LOG_LENGTH' else
      if self.val = UInt32($8B85) then Result := 'ATTACHED_SHADERS' else
      if self.val = UInt32($8B86) then Result := 'ACTIVE_UNIFORMS' else
      if self.val = UInt32($8B87) then Result := 'ACTIVE_UNIFORM_MAX_LENGTH' else
      if self.val = UInt32($8B89) then Result := 'ACTIVE_ATTRIBUTES' else
      if self.val = UInt32($8B8A) then Result := 'ACTIVE_ATTRIBUTE_MAX_LENGTH' else
      if self.val = UInt32($8C76) then Result := 'TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH' else
      if self.val = UInt32($8C7F) then Result := 'TRANSFORM_FEEDBACK_BUFFER_MODE' else
      if self.val = UInt32($8C83) then Result := 'TRANSFORM_FEEDBACK_VARYINGS' else
      if self.val = UInt32($92D9) then Result := 'ACTIVE_ATOMIC_COUNTER_BUFFERS' else
        Result := $'ProgramProperty[{self.val}]';
    end;
    
  end;
  
  ProgramResourceProperty = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NUM_COMPATIBLE_SUBROUTINES:           ProgramResourceProperty read new ProgramResourceProperty($8E4A);
    public static property COMPATIBLE_SUBROUTINES:               ProgramResourceProperty read new ProgramResourceProperty($8E4B);
    public static property UNIFORM:                              ProgramResourceProperty read new ProgramResourceProperty($92E1);
    public static property IS_PER_PATCH:                         ProgramResourceProperty read new ProgramResourceProperty($92E7);
    public static property NAME_LENGTH:                          ProgramResourceProperty read new ProgramResourceProperty($92F9);
    public static property &TYPE:                                ProgramResourceProperty read new ProgramResourceProperty($92FA);
    public static property ARRAY_SIZE:                           ProgramResourceProperty read new ProgramResourceProperty($92FB);
    public static property OFFSET:                               ProgramResourceProperty read new ProgramResourceProperty($92FC);
    public static property BLOCK_INDEX:                          ProgramResourceProperty read new ProgramResourceProperty($92FD);
    public static property ARRAY_STRIDE:                         ProgramResourceProperty read new ProgramResourceProperty($92FE);
    public static property MATRIX_STRIDE:                        ProgramResourceProperty read new ProgramResourceProperty($92FF);
    public static property IS_ROW_MAJOR:                         ProgramResourceProperty read new ProgramResourceProperty($9300);
    public static property ATOMIC_COUNTER_BUFFER_INDEX:          ProgramResourceProperty read new ProgramResourceProperty($9301);
    public static property BUFFER_BINDING:                       ProgramResourceProperty read new ProgramResourceProperty($9302);
    public static property BUFFER_DATA_SIZE:                     ProgramResourceProperty read new ProgramResourceProperty($9303);
    public static property NUM_ACTIVE_VARIABLES:                 ProgramResourceProperty read new ProgramResourceProperty($9304);
    public static property ACTIVE_VARIABLES:                     ProgramResourceProperty read new ProgramResourceProperty($9305);
    public static property REFERENCED_BY_VERTEX_SHADER:          ProgramResourceProperty read new ProgramResourceProperty($9306);
    public static property REFERENCED_BY_TESS_CONTROL_SHADER:    ProgramResourceProperty read new ProgramResourceProperty($9307);
    public static property REFERENCED_BY_TESS_EVALUATION_SHADER: ProgramResourceProperty read new ProgramResourceProperty($9308);
    public static property REFERENCED_BY_GEOMETRY_SHADER:        ProgramResourceProperty read new ProgramResourceProperty($9309);
    public static property REFERENCED_BY_FRAGMENT_SHADER:        ProgramResourceProperty read new ProgramResourceProperty($930A);
    public static property REFERENCED_BY_COMPUTE_SHADER:         ProgramResourceProperty read new ProgramResourceProperty($930B);
    public static property TOP_LEVEL_ARRAY_SIZE:                 ProgramResourceProperty read new ProgramResourceProperty($930C);
    public static property TOP_LEVEL_ARRAY_STRIDE:               ProgramResourceProperty read new ProgramResourceProperty($930D);
    public static property LOCATION:                             ProgramResourceProperty read new ProgramResourceProperty($930E);
    public static property LOCATION_INDEX:                       ProgramResourceProperty read new ProgramResourceProperty($930F);
    public static property LOCATION_COMPONENT:                   ProgramResourceProperty read new ProgramResourceProperty($934A);
    public static property TRANSFORM_FEEDBACK_BUFFER_INDEX:      ProgramResourceProperty read new ProgramResourceProperty($934B);
    public static property TRANSFORM_FEEDBACK_BUFFER_STRIDE:     ProgramResourceProperty read new ProgramResourceProperty($934C);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8E4A) then Result := 'NUM_COMPATIBLE_SUBROUTINES' else
      if self.val = UInt32($8E4B) then Result := 'COMPATIBLE_SUBROUTINES' else
      if self.val = UInt32($92E1) then Result := 'UNIFORM' else
      if self.val = UInt32($92E7) then Result := 'IS_PER_PATCH' else
      if self.val = UInt32($92F9) then Result := 'NAME_LENGTH' else
      if self.val = UInt32($92FA) then Result := 'TYPE' else
      if self.val = UInt32($92FB) then Result := 'ARRAY_SIZE' else
      if self.val = UInt32($92FC) then Result := 'OFFSET' else
      if self.val = UInt32($92FD) then Result := 'BLOCK_INDEX' else
      if self.val = UInt32($92FE) then Result := 'ARRAY_STRIDE' else
      if self.val = UInt32($92FF) then Result := 'MATRIX_STRIDE' else
      if self.val = UInt32($9300) then Result := 'IS_ROW_MAJOR' else
      if self.val = UInt32($9301) then Result := 'ATOMIC_COUNTER_BUFFER_INDEX' else
      if self.val = UInt32($9302) then Result := 'BUFFER_BINDING' else
      if self.val = UInt32($9303) then Result := 'BUFFER_DATA_SIZE' else
      if self.val = UInt32($9304) then Result := 'NUM_ACTIVE_VARIABLES' else
      if self.val = UInt32($9305) then Result := 'ACTIVE_VARIABLES' else
      if self.val = UInt32($9306) then Result := 'REFERENCED_BY_VERTEX_SHADER' else
      if self.val = UInt32($9307) then Result := 'REFERENCED_BY_TESS_CONTROL_SHADER' else
      if self.val = UInt32($9308) then Result := 'REFERENCED_BY_TESS_EVALUATION_SHADER' else
      if self.val = UInt32($9309) then Result := 'REFERENCED_BY_GEOMETRY_SHADER' else
      if self.val = UInt32($930A) then Result := 'REFERENCED_BY_FRAGMENT_SHADER' else
      if self.val = UInt32($930B) then Result := 'REFERENCED_BY_COMPUTE_SHADER' else
      if self.val = UInt32($930C) then Result := 'TOP_LEVEL_ARRAY_SIZE' else
      if self.val = UInt32($930D) then Result := 'TOP_LEVEL_ARRAY_STRIDE' else
      if self.val = UInt32($930E) then Result := 'LOCATION' else
      if self.val = UInt32($930F) then Result := 'LOCATION_INDEX' else
      if self.val = UInt32($934A) then Result := 'LOCATION_COMPONENT' else
      if self.val = UInt32($934B) then Result := 'TRANSFORM_FEEDBACK_BUFFER_INDEX' else
      if self.val = UInt32($934C) then Result := 'TRANSFORM_FEEDBACK_BUFFER_STRIDE' else
        Result := $'ProgramResourceProperty[{self.val}]';
    end;
    
  end;
  
  ProgramStagePName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_SUBROUTINES:                   ProgramStagePName read new ProgramStagePName($8DE5);
    public static property ACTIVE_SUBROUTINE_UNIFORMS:           ProgramStagePName read new ProgramStagePName($8DE6);
    public static property ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS:  ProgramStagePName read new ProgramStagePName($8E47);
    public static property ACTIVE_SUBROUTINE_MAX_LENGTH:         ProgramStagePName read new ProgramStagePName($8E48);
    public static property ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH: ProgramStagePName read new ProgramStagePName($8E49);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8DE5) then Result := 'ACTIVE_SUBROUTINES' else
      if self.val = UInt32($8DE6) then Result := 'ACTIVE_SUBROUTINE_UNIFORMS' else
      if self.val = UInt32($8E47) then Result := 'ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS' else
      if self.val = UInt32($8E48) then Result := 'ACTIVE_SUBROUTINE_MAX_LENGTH' else
      if self.val = UInt32($8E49) then Result := 'ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH' else
        Result := $'ProgramStagePName[{self.val}]';
    end;
    
  end;
  
  ProgramStringProperty = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROGRAM_STRING: ProgramStringProperty read new ProgramStringProperty($8628);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8628) then Result := 'PROGRAM_STRING' else
        Result := $'ProgramStringProperty[{self.val}]';
    end;
    
  end;
  
  ProgramTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXT_FRAGMENT_SHADER:    ProgramTarget read new ProgramTarget($8200);
    public static property VERTEX_PROGRAM:          ProgramTarget read new ProgramTarget($8620);
    public static property FRAGMENT_PROGRAM:        ProgramTarget read new ProgramTarget($8804);
    public static property TESS_CONTROL_PROGRAM:    ProgramTarget read new ProgramTarget($891E);
    public static property TESS_EVALUATION_PROGRAM: ProgramTarget read new ProgramTarget($891F);
    public static property GEOMETRY_PROGRAM:        ProgramTarget read new ProgramTarget($8C26);
    public static property COMPUTE_PROGRAM:         ProgramTarget read new ProgramTarget($90FB);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8200) then Result := 'TEXT_FRAGMENT_SHADER' else
      if self.val = UInt32($8620) then Result := 'VERTEX_PROGRAM' else
      if self.val = UInt32($8804) then Result := 'FRAGMENT_PROGRAM' else
      if self.val = UInt32($891E) then Result := 'TESS_CONTROL_PROGRAM' else
      if self.val = UInt32($891F) then Result := 'TESS_EVALUATION_PROGRAM' else
      if self.val = UInt32($8C26) then Result := 'GEOMETRY_PROGRAM' else
      if self.val = UInt32($90FB) then Result := 'COMPUTE_PROGRAM' else
        Result := $'ProgramTarget[{self.val}]';
    end;
    
  end;
  
  QueryCounterTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TIMESTAMP: QueryCounterTarget read new QueryCounterTarget($8E28);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8E28) then Result := 'TIMESTAMP' else
        Result := $'QueryCounterTarget[{self.val}]';
    end;
    
  end;
  
  QueryObjectParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property QUERY_TARGET:           QueryObjectParameterName read new QueryObjectParameterName($82EA);
    public static property QUERY_RESULT:           QueryObjectParameterName read new QueryObjectParameterName($8866);
    public static property QUERY_RESULT_AVAILABLE: QueryObjectParameterName read new QueryObjectParameterName($8867);
    public static property QUERY_RESULT_NO_WAIT:   QueryObjectParameterName read new QueryObjectParameterName($9194);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($82EA) then Result := 'QUERY_TARGET' else
      if self.val = UInt32($8866) then Result := 'QUERY_RESULT' else
      if self.val = UInt32($8867) then Result := 'QUERY_RESULT_AVAILABLE' else
      if self.val = UInt32($9194) then Result := 'QUERY_RESULT_NO_WAIT' else
        Result := $'QueryObjectParameterName[{self.val}]';
    end;
    
  end;
  
  QueryParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property QUERY_COUNTER_BITS: QueryParameterName read new QueryParameterName($8864);
    public static property CURRENT_QUERY:      QueryParameterName read new QueryParameterName($8865);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8864) then Result := 'QUERY_COUNTER_BITS' else
      if self.val = UInt32($8865) then Result := 'CURRENT_QUERY' else
        Result := $'QueryParameterName[{self.val}]';
    end;
    
  end;
  
  QueryTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TRANSFORM_FEEDBACK_OVERFLOW:           QueryTarget read new QueryTarget($82EC);
    public static property VERTICES_SUBMITTED:                    QueryTarget read new QueryTarget($82EE);
    public static property PRIMITIVES_SUBMITTED:                  QueryTarget read new QueryTarget($82EF);
    public static property VERTEX_SHADER_INVOCATIONS:             QueryTarget read new QueryTarget($82F0);
    public static property TIME_ELAPSED:                          QueryTarget read new QueryTarget($88BF);
    public static property SAMPLES_PASSED:                        QueryTarget read new QueryTarget($8914);
    public static property ANY_SAMPLES_PASSED:                    QueryTarget read new QueryTarget($8C2F);
    public static property PRIMITIVES_GENERATED:                  QueryTarget read new QueryTarget($8C87);
    public static property TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: QueryTarget read new QueryTarget($8C88);
    public static property ANY_SAMPLES_PASSED_CONSERVATIVE:       QueryTarget read new QueryTarget($8D6A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($82EC) then Result := 'TRANSFORM_FEEDBACK_OVERFLOW' else
      if self.val = UInt32($82EE) then Result := 'VERTICES_SUBMITTED' else
      if self.val = UInt32($82EF) then Result := 'PRIMITIVES_SUBMITTED' else
      if self.val = UInt32($82F0) then Result := 'VERTEX_SHADER_INVOCATIONS' else
      if self.val = UInt32($88BF) then Result := 'TIME_ELAPSED' else
      if self.val = UInt32($8914) then Result := 'SAMPLES_PASSED' else
      if self.val = UInt32($8C2F) then Result := 'ANY_SAMPLES_PASSED' else
      if self.val = UInt32($8C87) then Result := 'PRIMITIVES_GENERATED' else
      if self.val = UInt32($8C88) then Result := 'TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN' else
      if self.val = UInt32($8D6A) then Result := 'ANY_SAMPLES_PASSED_CONSERVATIVE' else
        Result := $'QueryTarget[{self.val}]';
    end;
    
  end;
  
  ReadBufferMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:               ReadBufferMode read new ReadBufferMode($0000);
    public static property FRONT_LEFT:         ReadBufferMode read new ReadBufferMode($0400);
    public static property FRONT_RIGHT:        ReadBufferMode read new ReadBufferMode($0401);
    public static property BACK_LEFT:          ReadBufferMode read new ReadBufferMode($0402);
    public static property BACK_RIGHT:         ReadBufferMode read new ReadBufferMode($0403);
    public static property FRONT:              ReadBufferMode read new ReadBufferMode($0404);
    public static property BACK:               ReadBufferMode read new ReadBufferMode($0405);
    public static property LEFT:               ReadBufferMode read new ReadBufferMode($0406);
    public static property RIGHT:              ReadBufferMode read new ReadBufferMode($0407);
    public static property AUX0:               ReadBufferMode read new ReadBufferMode($0409);
    public static property AUX1:               ReadBufferMode read new ReadBufferMode($040A);
    public static property AUX2:               ReadBufferMode read new ReadBufferMode($040B);
    public static property AUX3:               ReadBufferMode read new ReadBufferMode($040C);
    public static property COLOR_ATTACHMENT0:  ReadBufferMode read new ReadBufferMode($8CE0);
    public static property COLOR_ATTACHMENT1:  ReadBufferMode read new ReadBufferMode($8CE1);
    public static property COLOR_ATTACHMENT2:  ReadBufferMode read new ReadBufferMode($8CE2);
    public static property COLOR_ATTACHMENT3:  ReadBufferMode read new ReadBufferMode($8CE3);
    public static property COLOR_ATTACHMENT4:  ReadBufferMode read new ReadBufferMode($8CE4);
    public static property COLOR_ATTACHMENT5:  ReadBufferMode read new ReadBufferMode($8CE5);
    public static property COLOR_ATTACHMENT6:  ReadBufferMode read new ReadBufferMode($8CE6);
    public static property COLOR_ATTACHMENT7:  ReadBufferMode read new ReadBufferMode($8CE7);
    public static property COLOR_ATTACHMENT8:  ReadBufferMode read new ReadBufferMode($8CE8);
    public static property COLOR_ATTACHMENT9:  ReadBufferMode read new ReadBufferMode($8CE9);
    public static property COLOR_ATTACHMENT10: ReadBufferMode read new ReadBufferMode($8CEA);
    public static property COLOR_ATTACHMENT11: ReadBufferMode read new ReadBufferMode($8CEB);
    public static property COLOR_ATTACHMENT12: ReadBufferMode read new ReadBufferMode($8CEC);
    public static property COLOR_ATTACHMENT13: ReadBufferMode read new ReadBufferMode($8CED);
    public static property COLOR_ATTACHMENT14: ReadBufferMode read new ReadBufferMode($8CEE);
    public static property COLOR_ATTACHMENT15: ReadBufferMode read new ReadBufferMode($8CEF);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($0400) then Result := 'FRONT_LEFT' else
      if self.val = UInt32($0401) then Result := 'FRONT_RIGHT' else
      if self.val = UInt32($0402) then Result := 'BACK_LEFT' else
      if self.val = UInt32($0403) then Result := 'BACK_RIGHT' else
      if self.val = UInt32($0404) then Result := 'FRONT' else
      if self.val = UInt32($0405) then Result := 'BACK' else
      if self.val = UInt32($0406) then Result := 'LEFT' else
      if self.val = UInt32($0407) then Result := 'RIGHT' else
      if self.val = UInt32($0409) then Result := 'AUX0' else
      if self.val = UInt32($040A) then Result := 'AUX1' else
      if self.val = UInt32($040B) then Result := 'AUX2' else
      if self.val = UInt32($040C) then Result := 'AUX3' else
      if self.val = UInt32($8CE0) then Result := 'COLOR_ATTACHMENT0' else
      if self.val = UInt32($8CE1) then Result := 'COLOR_ATTACHMENT1' else
      if self.val = UInt32($8CE2) then Result := 'COLOR_ATTACHMENT2' else
      if self.val = UInt32($8CE3) then Result := 'COLOR_ATTACHMENT3' else
      if self.val = UInt32($8CE4) then Result := 'COLOR_ATTACHMENT4' else
      if self.val = UInt32($8CE5) then Result := 'COLOR_ATTACHMENT5' else
      if self.val = UInt32($8CE6) then Result := 'COLOR_ATTACHMENT6' else
      if self.val = UInt32($8CE7) then Result := 'COLOR_ATTACHMENT7' else
      if self.val = UInt32($8CE8) then Result := 'COLOR_ATTACHMENT8' else
      if self.val = UInt32($8CE9) then Result := 'COLOR_ATTACHMENT9' else
      if self.val = UInt32($8CEA) then Result := 'COLOR_ATTACHMENT10' else
      if self.val = UInt32($8CEB) then Result := 'COLOR_ATTACHMENT11' else
      if self.val = UInt32($8CEC) then Result := 'COLOR_ATTACHMENT12' else
      if self.val = UInt32($8CED) then Result := 'COLOR_ATTACHMENT13' else
      if self.val = UInt32($8CEE) then Result := 'COLOR_ATTACHMENT14' else
      if self.val = UInt32($8CEF) then Result := 'COLOR_ATTACHMENT15' else
        Result := $'ReadBufferMode[{self.val}]';
    end;
    
  end;
  
  RenderbufferParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RENDERBUFFER_SAMPLES:          RenderbufferParameterName read new RenderbufferParameterName($8CAB);
    public static property RENDERBUFFER_COVERAGE_SAMPLES: RenderbufferParameterName read new RenderbufferParameterName($8CAB);
    public static property RENDERBUFFER_WIDTH:            RenderbufferParameterName read new RenderbufferParameterName($8D42);
    public static property RENDERBUFFER_HEIGHT:           RenderbufferParameterName read new RenderbufferParameterName($8D43);
    public static property RENDERBUFFER_INTERNAL_FORMAT:  RenderbufferParameterName read new RenderbufferParameterName($8D44);
    public static property RENDERBUFFER_RED_SIZE:         RenderbufferParameterName read new RenderbufferParameterName($8D50);
    public static property RENDERBUFFER_GREEN_SIZE:       RenderbufferParameterName read new RenderbufferParameterName($8D51);
    public static property RENDERBUFFER_BLUE_SIZE:        RenderbufferParameterName read new RenderbufferParameterName($8D52);
    public static property RENDERBUFFER_ALPHA_SIZE:       RenderbufferParameterName read new RenderbufferParameterName($8D53);
    public static property RENDERBUFFER_DEPTH_SIZE:       RenderbufferParameterName read new RenderbufferParameterName($8D54);
    public static property RENDERBUFFER_STENCIL_SIZE:     RenderbufferParameterName read new RenderbufferParameterName($8D55);
    public static property RENDERBUFFER_COLOR_SAMPLES:    RenderbufferParameterName read new RenderbufferParameterName($8E10);
    public static property RENDERBUFFER_SAMPLES_IMG:      RenderbufferParameterName read new RenderbufferParameterName($9133);
    public static property RENDERBUFFER_STORAGE_SAMPLES:  RenderbufferParameterName read new RenderbufferParameterName($91B2);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8CAB) then Result := 'RENDERBUFFER_SAMPLES' else
      if self.val = UInt32($8CAB) then Result := 'RENDERBUFFER_COVERAGE_SAMPLES' else
      if self.val = UInt32($8D42) then Result := 'RENDERBUFFER_WIDTH' else
      if self.val = UInt32($8D43) then Result := 'RENDERBUFFER_HEIGHT' else
      if self.val = UInt32($8D44) then Result := 'RENDERBUFFER_INTERNAL_FORMAT' else
      if self.val = UInt32($8D50) then Result := 'RENDERBUFFER_RED_SIZE' else
      if self.val = UInt32($8D51) then Result := 'RENDERBUFFER_GREEN_SIZE' else
      if self.val = UInt32($8D52) then Result := 'RENDERBUFFER_BLUE_SIZE' else
      if self.val = UInt32($8D53) then Result := 'RENDERBUFFER_ALPHA_SIZE' else
      if self.val = UInt32($8D54) then Result := 'RENDERBUFFER_DEPTH_SIZE' else
      if self.val = UInt32($8D55) then Result := 'RENDERBUFFER_STENCIL_SIZE' else
      if self.val = UInt32($8E10) then Result := 'RENDERBUFFER_COLOR_SAMPLES' else
      if self.val = UInt32($9133) then Result := 'RENDERBUFFER_SAMPLES_IMG' else
      if self.val = UInt32($91B2) then Result := 'RENDERBUFFER_STORAGE_SAMPLES' else
        Result := $'RenderbufferParameterName[{self.val}]';
    end;
    
  end;
  
  RenderbufferTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RENDERBUFFER: RenderbufferTarget read new RenderbufferTarget($8D41);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8D41) then Result := 'RENDERBUFFER' else
        Result := $'RenderbufferTarget[{self.val}]';
    end;
    
  end;
  
  RenderingMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RENDER:   RenderingMode read new RenderingMode($1C00);
    public static property FEEDBACK: RenderingMode read new RenderingMode($1C01);
    public static property SELECT:   RenderingMode read new RenderingMode($1C02);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1C00) then Result := 'RENDER' else
      if self.val = UInt32($1C01) then Result := 'FEEDBACK' else
      if self.val = UInt32($1C02) then Result := 'SELECT' else
        Result := $'RenderingMode[{self.val}]';
    end;
    
  end;
  
  ReplacementCodeType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNSIGNED_BYTE:  ReplacementCodeType read new ReplacementCodeType($1401);
    public static property UNSIGNED_SHORT: ReplacementCodeType read new ReplacementCodeType($1403);
    public static property UNSIGNED_INT:   ReplacementCodeType read new ReplacementCodeType($1405);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
        Result := $'ReplacementCodeType[{self.val}]';
    end;
    
  end;
  
  SamplePattern = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property _1PASS:   SamplePattern read new SamplePattern($80A1);
    public static property _2PASS_0: SamplePattern read new SamplePattern($80A2);
    public static property _2PASS_1: SamplePattern read new SamplePattern($80A3);
    public static property _4PASS_0: SamplePattern read new SamplePattern($80A4);
    public static property _4PASS_1: SamplePattern read new SamplePattern($80A5);
    public static property _4PASS_2: SamplePattern read new SamplePattern($80A6);
    public static property _4PASS_3: SamplePattern read new SamplePattern($80A7);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($80A1) then Result := '_1PASS' else
      if self.val = UInt32($80A2) then Result := '_2PASS_0' else
      if self.val = UInt32($80A3) then Result := '_2PASS_1' else
      if self.val = UInt32($80A4) then Result := '_4PASS_0' else
      if self.val = UInt32($80A5) then Result := '_4PASS_1' else
      if self.val = UInt32($80A6) then Result := '_4PASS_2' else
      if self.val = UInt32($80A7) then Result := '_4PASS_3' else
        Result := $'SamplePattern[{self.val}]';
    end;
    
  end;
  
  SamplerParameterF = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_BORDER_COLOR:                 SamplerParameterF read new SamplerParameterF($1004);
    public static property TEXTURE_MIN_LOD:                      SamplerParameterF read new SamplerParameterF($813A);
    public static property TEXTURE_MAX_LOD:                      SamplerParameterF read new SamplerParameterF($813B);
    public static property TEXTURE_MAX_ANISOTROPY:               SamplerParameterF read new SamplerParameterF($84FE);
    public static property TEXTURE_LOD_BIAS:                     SamplerParameterF read new SamplerParameterF($8501);
    public static property TEXTURE_UNNORMALIZED_COORDINATES_ARM: SamplerParameterF read new SamplerParameterF($8F6A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1004) then Result := 'TEXTURE_BORDER_COLOR' else
      if self.val = UInt32($813A) then Result := 'TEXTURE_MIN_LOD' else
      if self.val = UInt32($813B) then Result := 'TEXTURE_MAX_LOD' else
      if self.val = UInt32($84FE) then Result := 'TEXTURE_MAX_ANISOTROPY' else
      if self.val = UInt32($8501) then Result := 'TEXTURE_LOD_BIAS' else
      if self.val = UInt32($8F6A) then Result := 'TEXTURE_UNNORMALIZED_COORDINATES_ARM' else
        Result := $'SamplerParameterF[{self.val}]';
    end;
    
  end;
  
  SamplerParameterI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_MAG_FILTER:                   SamplerParameterI read new SamplerParameterI($2800);
    public static property TEXTURE_MIN_FILTER:                   SamplerParameterI read new SamplerParameterI($2801);
    public static property TEXTURE_WRAP_S:                       SamplerParameterI read new SamplerParameterI($2802);
    public static property TEXTURE_WRAP_T:                       SamplerParameterI read new SamplerParameterI($2803);
    public static property TEXTURE_WRAP_R:                       SamplerParameterI read new SamplerParameterI($8072);
    public static property TEXTURE_COMPARE_MODE:                 SamplerParameterI read new SamplerParameterI($884C);
    public static property TEXTURE_COMPARE_FUNC:                 SamplerParameterI read new SamplerParameterI($884D);
    public static property TEXTURE_UNNORMALIZED_COORDINATES_ARM: SamplerParameterI read new SamplerParameterI($8F6A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2800) then Result := 'TEXTURE_MAG_FILTER' else
      if self.val = UInt32($2801) then Result := 'TEXTURE_MIN_FILTER' else
      if self.val = UInt32($2802) then Result := 'TEXTURE_WRAP_S' else
      if self.val = UInt32($2803) then Result := 'TEXTURE_WRAP_T' else
      if self.val = UInt32($8072) then Result := 'TEXTURE_WRAP_R' else
      if self.val = UInt32($884C) then Result := 'TEXTURE_COMPARE_MODE' else
      if self.val = UInt32($884D) then Result := 'TEXTURE_COMPARE_FUNC' else
      if self.val = UInt32($8F6A) then Result := 'TEXTURE_UNNORMALIZED_COORDINATES_ARM' else
        Result := $'SamplerParameterI[{self.val}]';
    end;
    
  end;
  
  ScalarType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNSIGNED_BYTE:  ScalarType read new ScalarType($1401);
    public static property UNSIGNED_SHORT: ScalarType read new ScalarType($1403);
    public static property UNSIGNED_INT:   ScalarType read new ScalarType($1405);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
        Result := $'ScalarType[{self.val}]';
    end;
    
  end;
  
  SecondaryColorPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SHORT:  SecondaryColorPointerType read new SecondaryColorPointerType($1402);
    public static property INT:    SecondaryColorPointerType read new SecondaryColorPointerType($1404);
    public static property FLOAT:  SecondaryColorPointerType read new SecondaryColorPointerType($1406);
    public static property DOUBLE: SecondaryColorPointerType read new SecondaryColorPointerType($140A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := $'SecondaryColorPointerType[{self.val}]';
    end;
    
  end;
  
  SemaphoreParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TIMELINE_SEMAPHORE_VALUE: SemaphoreParameterName read new SemaphoreParameterName($9595);
    public static property D3D12_FENCE_VALUE:        SemaphoreParameterName read new SemaphoreParameterName($9595);
    public static property SEMAPHORE_TYPE:           SemaphoreParameterName read new SemaphoreParameterName($95B3);
    public static property SEMAPHORE_TYPE_BINARY:    SemaphoreParameterName read new SemaphoreParameterName($95B4);
    public static property SEMAPHORE_TYPE_TIMELINE:  SemaphoreParameterName read new SemaphoreParameterName($95B5);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9595) then Result := 'TIMELINE_SEMAPHORE_VALUE' else
      if self.val = UInt32($9595) then Result := 'D3D12_FENCE_VALUE' else
      if self.val = UInt32($95B3) then Result := 'SEMAPHORE_TYPE' else
      if self.val = UInt32($95B4) then Result := 'SEMAPHORE_TYPE_BINARY' else
      if self.val = UInt32($95B5) then Result := 'SEMAPHORE_TYPE_TIMELINE' else
        Result := $'SemaphoreParameterName[{self.val}]';
    end;
    
  end;
  
  SeparableTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SEPARABLE_2D: SeparableTarget read new SeparableTarget($8012);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8012) then Result := 'SEPARABLE_2D' else
        Result := $'SeparableTarget[{self.val}]';
    end;
    
  end;
  
  ShaderBinaryFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SGX_BINARY:                  ShaderBinaryFormat read new ShaderBinaryFormat($8C0A);
    public static property MALI_SHADER_BINARY_ARM:      ShaderBinaryFormat read new ShaderBinaryFormat($8F60);
    public static property SHADER_BINARY_VIV:           ShaderBinaryFormat read new ShaderBinaryFormat($8FC4);
    public static property SHADER_BINARY_DMP:           ShaderBinaryFormat read new ShaderBinaryFormat($9250);
    public static property GCCSO_SHADER_BINARY_FJ:      ShaderBinaryFormat read new ShaderBinaryFormat($9260);
    public static property SHADER_BINARY_FORMAT_SPIR_V: ShaderBinaryFormat read new ShaderBinaryFormat($9551);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8C0A) then Result := 'SGX_BINARY' else
      if self.val = UInt32($8F60) then Result := 'MALI_SHADER_BINARY_ARM' else
      if self.val = UInt32($8FC4) then Result := 'SHADER_BINARY_VIV' else
      if self.val = UInt32($9250) then Result := 'SHADER_BINARY_DMP' else
      if self.val = UInt32($9260) then Result := 'GCCSO_SHADER_BINARY_FJ' else
      if self.val = UInt32($9551) then Result := 'SHADER_BINARY_FORMAT_SPIR_V' else
        Result := $'ShaderBinaryFormat[{self.val}]';
    end;
    
  end;
  
  ShaderParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SHADER_TYPE:          ShaderParameterName read new ShaderParameterName($8B4F);
    public static property DELETE_STATUS:        ShaderParameterName read new ShaderParameterName($8B80);
    public static property COMPILE_STATUS:       ShaderParameterName read new ShaderParameterName($8B81);
    public static property INFO_LOG_LENGTH:      ShaderParameterName read new ShaderParameterName($8B84);
    public static property SHADER_SOURCE_LENGTH: ShaderParameterName read new ShaderParameterName($8B88);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8B4F) then Result := 'SHADER_TYPE' else
      if self.val = UInt32($8B80) then Result := 'DELETE_STATUS' else
      if self.val = UInt32($8B81) then Result := 'COMPILE_STATUS' else
      if self.val = UInt32($8B84) then Result := 'INFO_LOG_LENGTH' else
      if self.val = UInt32($8B88) then Result := 'SHADER_SOURCE_LENGTH' else
        Result := $'ShaderParameterName[{self.val}]';
    end;
    
  end;
  
  ShaderType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRAGMENT_SHADER:        ShaderType read new ShaderType($8B30);
    public static property VERTEX_SHADER:          ShaderType read new ShaderType($8B31);
    public static property GEOMETRY_SHADER:        ShaderType read new ShaderType($8DD9);
    public static property TESS_EVALUATION_SHADER: ShaderType read new ShaderType($8E87);
    public static property TESS_CONTROL_SHADER:    ShaderType read new ShaderType($8E88);
    public static property COMPUTE_SHADER:         ShaderType read new ShaderType($91B9);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8B30) then Result := 'FRAGMENT_SHADER' else
      if self.val = UInt32($8B31) then Result := 'VERTEX_SHADER' else
      if self.val = UInt32($8DD9) then Result := 'GEOMETRY_SHADER' else
      if self.val = UInt32($8E87) then Result := 'TESS_EVALUATION_SHADER' else
      if self.val = UInt32($8E88) then Result := 'TESS_CONTROL_SHADER' else
      if self.val = UInt32($91B9) then Result := 'COMPUTE_SHADER' else
        Result := $'ShaderType[{self.val}]';
    end;
    
  end;
  
  ShadingModel = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FLAT:   ShadingModel read new ShadingModel($1D00);
    public static property SMOOTH: ShadingModel read new ShadingModel($1D01);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1D00) then Result := 'FLAT' else
      if self.val = UInt32($1D01) then Result := 'SMOOTH' else
        Result := $'ShadingModel[{self.val}]';
    end;
    
  end;
  
  SizedInternalFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property R3_G3_B2:                                  SizedInternalFormat read new SizedInternalFormat($2A10);
    public static property ALPHA4:                                    SizedInternalFormat read new SizedInternalFormat($803B);
    public static property ALPHA8:                                    SizedInternalFormat read new SizedInternalFormat($803C);
    public static property ALPHA12:                                   SizedInternalFormat read new SizedInternalFormat($803D);
    public static property ALPHA16:                                   SizedInternalFormat read new SizedInternalFormat($803E);
    public static property LUMINANCE4:                                SizedInternalFormat read new SizedInternalFormat($803F);
    public static property LUMINANCE8:                                SizedInternalFormat read new SizedInternalFormat($8040);
    public static property LUMINANCE12:                               SizedInternalFormat read new SizedInternalFormat($8041);
    public static property LUMINANCE16:                               SizedInternalFormat read new SizedInternalFormat($8042);
    public static property LUMINANCE4_ALPHA4:                         SizedInternalFormat read new SizedInternalFormat($8043);
    public static property LUMINANCE6_ALPHA2:                         SizedInternalFormat read new SizedInternalFormat($8044);
    public static property LUMINANCE8_ALPHA8:                         SizedInternalFormat read new SizedInternalFormat($8045);
    public static property LUMINANCE12_ALPHA4:                        SizedInternalFormat read new SizedInternalFormat($8046);
    public static property LUMINANCE12_ALPHA12:                       SizedInternalFormat read new SizedInternalFormat($8047);
    public static property LUMINANCE16_ALPHA16:                       SizedInternalFormat read new SizedInternalFormat($8048);
    public static property INTENSITY4:                                SizedInternalFormat read new SizedInternalFormat($804A);
    public static property INTENSITY8:                                SizedInternalFormat read new SizedInternalFormat($804B);
    public static property INTENSITY12:                               SizedInternalFormat read new SizedInternalFormat($804C);
    public static property INTENSITY16:                               SizedInternalFormat read new SizedInternalFormat($804D);
    public static property RGB2:                                      SizedInternalFormat read new SizedInternalFormat($804E);
    public static property RGB4:                                      SizedInternalFormat read new SizedInternalFormat($804F);
    public static property RGB5:                                      SizedInternalFormat read new SizedInternalFormat($8050);
    public static property RGB8:                                      SizedInternalFormat read new SizedInternalFormat($8051);
    public static property RGB10:                                     SizedInternalFormat read new SizedInternalFormat($8052);
    public static property RGB12:                                     SizedInternalFormat read new SizedInternalFormat($8053);
    public static property RGB16:                                     SizedInternalFormat read new SizedInternalFormat($8054);
    public static property RGBA2:                                     SizedInternalFormat read new SizedInternalFormat($8055);
    public static property RGBA4:                                     SizedInternalFormat read new SizedInternalFormat($8056);
    public static property RGB5_A1:                                   SizedInternalFormat read new SizedInternalFormat($8057);
    public static property RGBA8:                                     SizedInternalFormat read new SizedInternalFormat($8058);
    public static property RGB10_A2:                                  SizedInternalFormat read new SizedInternalFormat($8059);
    public static property RGBA12:                                    SizedInternalFormat read new SizedInternalFormat($805A);
    public static property RGBA16:                                    SizedInternalFormat read new SizedInternalFormat($805B);
    public static property DEPTH_COMPONENT16:                         SizedInternalFormat read new SizedInternalFormat($81A5);
    public static property DEPTH_COMPONENT24:                         SizedInternalFormat read new SizedInternalFormat($81A6);
    public static property DEPTH_COMPONENT32:                         SizedInternalFormat read new SizedInternalFormat($81A7);
    public static property R8:                                        SizedInternalFormat read new SizedInternalFormat($8229);
    public static property R16:                                       SizedInternalFormat read new SizedInternalFormat($822A);
    public static property RG8:                                       SizedInternalFormat read new SizedInternalFormat($822B);
    public static property RG16:                                      SizedInternalFormat read new SizedInternalFormat($822C);
    public static property R16F:                                      SizedInternalFormat read new SizedInternalFormat($822D);
    public static property R32F:                                      SizedInternalFormat read new SizedInternalFormat($822E);
    public static property RG16F:                                     SizedInternalFormat read new SizedInternalFormat($822F);
    public static property RG32F:                                     SizedInternalFormat read new SizedInternalFormat($8230);
    public static property R8I:                                       SizedInternalFormat read new SizedInternalFormat($8231);
    public static property R8UI:                                      SizedInternalFormat read new SizedInternalFormat($8232);
    public static property R16I:                                      SizedInternalFormat read new SizedInternalFormat($8233);
    public static property R16UI:                                     SizedInternalFormat read new SizedInternalFormat($8234);
    public static property R32I:                                      SizedInternalFormat read new SizedInternalFormat($8235);
    public static property R32UI:                                     SizedInternalFormat read new SizedInternalFormat($8236);
    public static property RG8I:                                      SizedInternalFormat read new SizedInternalFormat($8237);
    public static property RG8UI:                                     SizedInternalFormat read new SizedInternalFormat($8238);
    public static property RG16I:                                     SizedInternalFormat read new SizedInternalFormat($8239);
    public static property RG16UI:                                    SizedInternalFormat read new SizedInternalFormat($823A);
    public static property RG32I:                                     SizedInternalFormat read new SizedInternalFormat($823B);
    public static property RG32UI:                                    SizedInternalFormat read new SizedInternalFormat($823C);
    public static property COMPRESSED_RGB_S3TC_DXT1:                  SizedInternalFormat read new SizedInternalFormat($83F0);
    public static property COMPRESSED_RGBA_S3TC_DXT1:                 SizedInternalFormat read new SizedInternalFormat($83F1);
    public static property COMPRESSED_RGBA_S3TC_DXT3:                 SizedInternalFormat read new SizedInternalFormat($83F2);
    public static property COMPRESSED_RGBA_S3TC_DXT5:                 SizedInternalFormat read new SizedInternalFormat($83F3);
    public static property RGBA32F:                                   SizedInternalFormat read new SizedInternalFormat($8814);
    public static property RGB32F:                                    SizedInternalFormat read new SizedInternalFormat($8815);
    public static property RGBA16F:                                   SizedInternalFormat read new SizedInternalFormat($881A);
    public static property RGB16F:                                    SizedInternalFormat read new SizedInternalFormat($881B);
    public static property DEPTH24_STENCIL8:                          SizedInternalFormat read new SizedInternalFormat($88F0);
    public static property R11F_G11F_B10F:                            SizedInternalFormat read new SizedInternalFormat($8C3A);
    public static property RGB9_E5:                                   SizedInternalFormat read new SizedInternalFormat($8C3D);
    public static property SRGB8:                                     SizedInternalFormat read new SizedInternalFormat($8C41);
    public static property SRGB8_ALPHA8:                              SizedInternalFormat read new SizedInternalFormat($8C43);
    public static property COMPRESSED_SRGB_S3TC_DXT1:                 SizedInternalFormat read new SizedInternalFormat($8C4C);
    public static property COMPRESSED_SRGB_ALPHA_S3TC_DXT1:           SizedInternalFormat read new SizedInternalFormat($8C4D);
    public static property COMPRESSED_SRGB_ALPHA_S3TC_DXT3:           SizedInternalFormat read new SizedInternalFormat($8C4E);
    public static property COMPRESSED_SRGB_ALPHA_S3TC_DXT5:           SizedInternalFormat read new SizedInternalFormat($8C4F);
    public static property DEPTH_COMPONENT32F:                        SizedInternalFormat read new SizedInternalFormat($8CAC);
    public static property DEPTH32F_STENCIL8:                         SizedInternalFormat read new SizedInternalFormat($8CAD);
    public static property STENCIL_INDEX1:                            SizedInternalFormat read new SizedInternalFormat($8D46);
    public static property STENCIL_INDEX4:                            SizedInternalFormat read new SizedInternalFormat($8D47);
    public static property STENCIL_INDEX8:                            SizedInternalFormat read new SizedInternalFormat($8D48);
    public static property STENCIL_INDEX16:                           SizedInternalFormat read new SizedInternalFormat($8D49);
    public static property RGB565:                                    SizedInternalFormat read new SizedInternalFormat($8D62);
    public static property ETC1_RGB8:                                 SizedInternalFormat read new SizedInternalFormat($8D64);
    public static property RGBA32UI:                                  SizedInternalFormat read new SizedInternalFormat($8D70);
    public static property RGB32UI:                                   SizedInternalFormat read new SizedInternalFormat($8D71);
    public static property ALPHA32UI:                                 SizedInternalFormat read new SizedInternalFormat($8D72);
    public static property INTENSITY32UI:                             SizedInternalFormat read new SizedInternalFormat($8D73);
    public static property LUMINANCE32UI:                             SizedInternalFormat read new SizedInternalFormat($8D74);
    public static property LUMINANCE_ALPHA32UI:                       SizedInternalFormat read new SizedInternalFormat($8D75);
    public static property RGBA16UI:                                  SizedInternalFormat read new SizedInternalFormat($8D76);
    public static property RGB16UI:                                   SizedInternalFormat read new SizedInternalFormat($8D77);
    public static property ALPHA16UI:                                 SizedInternalFormat read new SizedInternalFormat($8D78);
    public static property INTENSITY16UI:                             SizedInternalFormat read new SizedInternalFormat($8D79);
    public static property LUMINANCE16UI:                             SizedInternalFormat read new SizedInternalFormat($8D7A);
    public static property LUMINANCE_ALPHA16UI:                       SizedInternalFormat read new SizedInternalFormat($8D7B);
    public static property RGBA8UI:                                   SizedInternalFormat read new SizedInternalFormat($8D7C);
    public static property RGB8UI:                                    SizedInternalFormat read new SizedInternalFormat($8D7D);
    public static property ALPHA8UI:                                  SizedInternalFormat read new SizedInternalFormat($8D7E);
    public static property INTENSITY8UI:                              SizedInternalFormat read new SizedInternalFormat($8D7F);
    public static property LUMINANCE8UI:                              SizedInternalFormat read new SizedInternalFormat($8D80);
    public static property LUMINANCE_ALPHA8UI:                        SizedInternalFormat read new SizedInternalFormat($8D81);
    public static property RGBA32I:                                   SizedInternalFormat read new SizedInternalFormat($8D82);
    public static property RGB32I:                                    SizedInternalFormat read new SizedInternalFormat($8D83);
    public static property ALPHA32I:                                  SizedInternalFormat read new SizedInternalFormat($8D84);
    public static property INTENSITY32I:                              SizedInternalFormat read new SizedInternalFormat($8D85);
    public static property LUMINANCE32I:                              SizedInternalFormat read new SizedInternalFormat($8D86);
    public static property LUMINANCE_ALPHA32I:                        SizedInternalFormat read new SizedInternalFormat($8D87);
    public static property RGBA16I:                                   SizedInternalFormat read new SizedInternalFormat($8D88);
    public static property RGB16I:                                    SizedInternalFormat read new SizedInternalFormat($8D89);
    public static property ALPHA16I:                                  SizedInternalFormat read new SizedInternalFormat($8D8A);
    public static property INTENSITY16I:                              SizedInternalFormat read new SizedInternalFormat($8D8B);
    public static property LUMINANCE16I:                              SizedInternalFormat read new SizedInternalFormat($8D8C);
    public static property LUMINANCE_ALPHA16I:                        SizedInternalFormat read new SizedInternalFormat($8D8D);
    public static property RGBA8I:                                    SizedInternalFormat read new SizedInternalFormat($8D8E);
    public static property RGB8I:                                     SizedInternalFormat read new SizedInternalFormat($8D8F);
    public static property ALPHA8I:                                   SizedInternalFormat read new SizedInternalFormat($8D90);
    public static property INTENSITY8I:                               SizedInternalFormat read new SizedInternalFormat($8D91);
    public static property LUMINANCE8I:                               SizedInternalFormat read new SizedInternalFormat($8D92);
    public static property LUMINANCE_ALPHA8I:                         SizedInternalFormat read new SizedInternalFormat($8D93);
    public static property DEPTH_COMPONENT32F_NV:                     SizedInternalFormat read new SizedInternalFormat($8DAB);
    public static property DEPTH32F_STENCIL8_NV:                      SizedInternalFormat read new SizedInternalFormat($8DAC);
    public static property COMPRESSED_RED_RGTC1:                      SizedInternalFormat read new SizedInternalFormat($8DBB);
    public static property COMPRESSED_SIGNED_RED_RGTC1:               SizedInternalFormat read new SizedInternalFormat($8DBC);
    public static property COMPRESSED_RED_GREEN_RGTC2:                SizedInternalFormat read new SizedInternalFormat($8DBD);
    public static property COMPRESSED_RG_RGTC2:                       SizedInternalFormat read new SizedInternalFormat($8DBD);
    public static property COMPRESSED_SIGNED_RED_GREEN_RGTC2:         SizedInternalFormat read new SizedInternalFormat($8DBE);
    public static property COMPRESSED_SIGNED_RG_RGTC2:                SizedInternalFormat read new SizedInternalFormat($8DBE);
    public static property COMPRESSED_RGBA_BPTC_UNORM:                SizedInternalFormat read new SizedInternalFormat($8E8C);
    public static property COMPRESSED_SRGB_ALPHA_BPTC_UNORM:          SizedInternalFormat read new SizedInternalFormat($8E8D);
    public static property COMPRESSED_RGB_BPTC_SIGNED_FLOAT:          SizedInternalFormat read new SizedInternalFormat($8E8E);
    public static property COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:        SizedInternalFormat read new SizedInternalFormat($8E8F);
    public static property R8_SNORM:                                  SizedInternalFormat read new SizedInternalFormat($8F94);
    public static property RG8_SNORM:                                 SizedInternalFormat read new SizedInternalFormat($8F95);
    public static property RGB8_SNORM:                                SizedInternalFormat read new SizedInternalFormat($8F96);
    public static property RGBA8_SNORM:                               SizedInternalFormat read new SizedInternalFormat($8F97);
    public static property R16_SNORM:                                 SizedInternalFormat read new SizedInternalFormat($8F98);
    public static property RG16_SNORM:                                SizedInternalFormat read new SizedInternalFormat($8F99);
    public static property RGB16_SNORM:                               SizedInternalFormat read new SizedInternalFormat($8F9A);
    public static property RGBA16_SNORM:                              SizedInternalFormat read new SizedInternalFormat($8F9B);
    public static property RGB10_A2UI:                                SizedInternalFormat read new SizedInternalFormat($906F);
    public static property COMPRESSED_R11_EAC:                        SizedInternalFormat read new SizedInternalFormat($9270);
    public static property COMPRESSED_SIGNED_R11_EAC:                 SizedInternalFormat read new SizedInternalFormat($9271);
    public static property COMPRESSED_RG11_EAC:                       SizedInternalFormat read new SizedInternalFormat($9272);
    public static property COMPRESSED_SIGNED_RG11_EAC:                SizedInternalFormat read new SizedInternalFormat($9273);
    public static property COMPRESSED_RGB8_ETC2:                      SizedInternalFormat read new SizedInternalFormat($9274);
    public static property COMPRESSED_SRGB8_ETC2:                     SizedInternalFormat read new SizedInternalFormat($9275);
    public static property COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:  SizedInternalFormat read new SizedInternalFormat($9276);
    public static property COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: SizedInternalFormat read new SizedInternalFormat($9277);
    public static property COMPRESSED_RGBA8_ETC2_EAC:                 SizedInternalFormat read new SizedInternalFormat($9278);
    public static property COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:          SizedInternalFormat read new SizedInternalFormat($9279);
    public static property COMPRESSED_RGBA_ASTC_4x4:                  SizedInternalFormat read new SizedInternalFormat($93B0);
    public static property COMPRESSED_RGBA_ASTC_5x4:                  SizedInternalFormat read new SizedInternalFormat($93B1);
    public static property COMPRESSED_RGBA_ASTC_5x5:                  SizedInternalFormat read new SizedInternalFormat($93B2);
    public static property COMPRESSED_RGBA_ASTC_6x5:                  SizedInternalFormat read new SizedInternalFormat($93B3);
    public static property COMPRESSED_RGBA_ASTC_6x6:                  SizedInternalFormat read new SizedInternalFormat($93B4);
    public static property COMPRESSED_RGBA_ASTC_8x5:                  SizedInternalFormat read new SizedInternalFormat($93B5);
    public static property COMPRESSED_RGBA_ASTC_8x6:                  SizedInternalFormat read new SizedInternalFormat($93B6);
    public static property COMPRESSED_RGBA_ASTC_8x8:                  SizedInternalFormat read new SizedInternalFormat($93B7);
    public static property COMPRESSED_RGBA_ASTC_10x5:                 SizedInternalFormat read new SizedInternalFormat($93B8);
    public static property COMPRESSED_RGBA_ASTC_10x6:                 SizedInternalFormat read new SizedInternalFormat($93B9);
    public static property COMPRESSED_RGBA_ASTC_10x8:                 SizedInternalFormat read new SizedInternalFormat($93BA);
    public static property COMPRESSED_RGBA_ASTC_10x10:                SizedInternalFormat read new SizedInternalFormat($93BB);
    public static property COMPRESSED_RGBA_ASTC_12x10:                SizedInternalFormat read new SizedInternalFormat($93BC);
    public static property COMPRESSED_RGBA_ASTC_12x12:                SizedInternalFormat read new SizedInternalFormat($93BD);
    public static property COMPRESSED_RGBA_ASTC_3x3x3:                SizedInternalFormat read new SizedInternalFormat($93C0);
    public static property COMPRESSED_RGBA_ASTC_4x3x3:                SizedInternalFormat read new SizedInternalFormat($93C1);
    public static property COMPRESSED_RGBA_ASTC_4x4x3:                SizedInternalFormat read new SizedInternalFormat($93C2);
    public static property COMPRESSED_RGBA_ASTC_4x4x4:                SizedInternalFormat read new SizedInternalFormat($93C3);
    public static property COMPRESSED_RGBA_ASTC_5x4x4:                SizedInternalFormat read new SizedInternalFormat($93C4);
    public static property COMPRESSED_RGBA_ASTC_5x5x4:                SizedInternalFormat read new SizedInternalFormat($93C5);
    public static property COMPRESSED_RGBA_ASTC_5x5x5:                SizedInternalFormat read new SizedInternalFormat($93C6);
    public static property COMPRESSED_RGBA_ASTC_6x5x5:                SizedInternalFormat read new SizedInternalFormat($93C7);
    public static property COMPRESSED_RGBA_ASTC_6x6x5:                SizedInternalFormat read new SizedInternalFormat($93C8);
    public static property COMPRESSED_RGBA_ASTC_6x6x6:                SizedInternalFormat read new SizedInternalFormat($93C9);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x4:          SizedInternalFormat read new SizedInternalFormat($93D0);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x4:          SizedInternalFormat read new SizedInternalFormat($93D1);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x5:          SizedInternalFormat read new SizedInternalFormat($93D2);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x5:          SizedInternalFormat read new SizedInternalFormat($93D3);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x6:          SizedInternalFormat read new SizedInternalFormat($93D4);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x5:          SizedInternalFormat read new SizedInternalFormat($93D5);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x6:          SizedInternalFormat read new SizedInternalFormat($93D6);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x8:          SizedInternalFormat read new SizedInternalFormat($93D7);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x5:         SizedInternalFormat read new SizedInternalFormat($93D8);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x6:         SizedInternalFormat read new SizedInternalFormat($93D9);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x8:         SizedInternalFormat read new SizedInternalFormat($93DA);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x10:        SizedInternalFormat read new SizedInternalFormat($93DB);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_12x10:        SizedInternalFormat read new SizedInternalFormat($93DC);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_12x12:        SizedInternalFormat read new SizedInternalFormat($93DD);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3:        SizedInternalFormat read new SizedInternalFormat($93E0);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3:        SizedInternalFormat read new SizedInternalFormat($93E1);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3:        SizedInternalFormat read new SizedInternalFormat($93E2);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4:        SizedInternalFormat read new SizedInternalFormat($93E3);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4:        SizedInternalFormat read new SizedInternalFormat($93E4);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4:        SizedInternalFormat read new SizedInternalFormat($93E5);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5:        SizedInternalFormat read new SizedInternalFormat($93E6);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5:        SizedInternalFormat read new SizedInternalFormat($93E7);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5:        SizedInternalFormat read new SizedInternalFormat($93E8);
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6:        SizedInternalFormat read new SizedInternalFormat($93E9);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2A10) then Result := 'R3_G3_B2' else
      if self.val = UInt32($803B) then Result := 'ALPHA4' else
      if self.val = UInt32($803C) then Result := 'ALPHA8' else
      if self.val = UInt32($803D) then Result := 'ALPHA12' else
      if self.val = UInt32($803E) then Result := 'ALPHA16' else
      if self.val = UInt32($803F) then Result := 'LUMINANCE4' else
      if self.val = UInt32($8040) then Result := 'LUMINANCE8' else
      if self.val = UInt32($8041) then Result := 'LUMINANCE12' else
      if self.val = UInt32($8042) then Result := 'LUMINANCE16' else
      if self.val = UInt32($8043) then Result := 'LUMINANCE4_ALPHA4' else
      if self.val = UInt32($8044) then Result := 'LUMINANCE6_ALPHA2' else
      if self.val = UInt32($8045) then Result := 'LUMINANCE8_ALPHA8' else
      if self.val = UInt32($8046) then Result := 'LUMINANCE12_ALPHA4' else
      if self.val = UInt32($8047) then Result := 'LUMINANCE12_ALPHA12' else
      if self.val = UInt32($8048) then Result := 'LUMINANCE16_ALPHA16' else
      if self.val = UInt32($804A) then Result := 'INTENSITY4' else
      if self.val = UInt32($804B) then Result := 'INTENSITY8' else
      if self.val = UInt32($804C) then Result := 'INTENSITY12' else
      if self.val = UInt32($804D) then Result := 'INTENSITY16' else
      if self.val = UInt32($804E) then Result := 'RGB2' else
      if self.val = UInt32($804F) then Result := 'RGB4' else
      if self.val = UInt32($8050) then Result := 'RGB5' else
      if self.val = UInt32($8051) then Result := 'RGB8' else
      if self.val = UInt32($8052) then Result := 'RGB10' else
      if self.val = UInt32($8053) then Result := 'RGB12' else
      if self.val = UInt32($8054) then Result := 'RGB16' else
      if self.val = UInt32($8055) then Result := 'RGBA2' else
      if self.val = UInt32($8056) then Result := 'RGBA4' else
      if self.val = UInt32($8057) then Result := 'RGB5_A1' else
      if self.val = UInt32($8058) then Result := 'RGBA8' else
      if self.val = UInt32($8059) then Result := 'RGB10_A2' else
      if self.val = UInt32($805A) then Result := 'RGBA12' else
      if self.val = UInt32($805B) then Result := 'RGBA16' else
      if self.val = UInt32($81A5) then Result := 'DEPTH_COMPONENT16' else
      if self.val = UInt32($81A6) then Result := 'DEPTH_COMPONENT24' else
      if self.val = UInt32($81A7) then Result := 'DEPTH_COMPONENT32' else
      if self.val = UInt32($8229) then Result := 'R8' else
      if self.val = UInt32($822A) then Result := 'R16' else
      if self.val = UInt32($822B) then Result := 'RG8' else
      if self.val = UInt32($822C) then Result := 'RG16' else
      if self.val = UInt32($822D) then Result := 'R16F' else
      if self.val = UInt32($822E) then Result := 'R32F' else
      if self.val = UInt32($822F) then Result := 'RG16F' else
      if self.val = UInt32($8230) then Result := 'RG32F' else
      if self.val = UInt32($8231) then Result := 'R8I' else
      if self.val = UInt32($8232) then Result := 'R8UI' else
      if self.val = UInt32($8233) then Result := 'R16I' else
      if self.val = UInt32($8234) then Result := 'R16UI' else
      if self.val = UInt32($8235) then Result := 'R32I' else
      if self.val = UInt32($8236) then Result := 'R32UI' else
      if self.val = UInt32($8237) then Result := 'RG8I' else
      if self.val = UInt32($8238) then Result := 'RG8UI' else
      if self.val = UInt32($8239) then Result := 'RG16I' else
      if self.val = UInt32($823A) then Result := 'RG16UI' else
      if self.val = UInt32($823B) then Result := 'RG32I' else
      if self.val = UInt32($823C) then Result := 'RG32UI' else
      if self.val = UInt32($83F0) then Result := 'COMPRESSED_RGB_S3TC_DXT1' else
      if self.val = UInt32($83F1) then Result := 'COMPRESSED_RGBA_S3TC_DXT1' else
      if self.val = UInt32($83F2) then Result := 'COMPRESSED_RGBA_S3TC_DXT3' else
      if self.val = UInt32($83F3) then Result := 'COMPRESSED_RGBA_S3TC_DXT5' else
      if self.val = UInt32($8814) then Result := 'RGBA32F' else
      if self.val = UInt32($8815) then Result := 'RGB32F' else
      if self.val = UInt32($881A) then Result := 'RGBA16F' else
      if self.val = UInt32($881B) then Result := 'RGB16F' else
      if self.val = UInt32($88F0) then Result := 'DEPTH24_STENCIL8' else
      if self.val = UInt32($8C3A) then Result := 'R11F_G11F_B10F' else
      if self.val = UInt32($8C3D) then Result := 'RGB9_E5' else
      if self.val = UInt32($8C41) then Result := 'SRGB8' else
      if self.val = UInt32($8C43) then Result := 'SRGB8_ALPHA8' else
      if self.val = UInt32($8C4C) then Result := 'COMPRESSED_SRGB_S3TC_DXT1' else
      if self.val = UInt32($8C4D) then Result := 'COMPRESSED_SRGB_ALPHA_S3TC_DXT1' else
      if self.val = UInt32($8C4E) then Result := 'COMPRESSED_SRGB_ALPHA_S3TC_DXT3' else
      if self.val = UInt32($8C4F) then Result := 'COMPRESSED_SRGB_ALPHA_S3TC_DXT5' else
      if self.val = UInt32($8CAC) then Result := 'DEPTH_COMPONENT32F' else
      if self.val = UInt32($8CAD) then Result := 'DEPTH32F_STENCIL8' else
      if self.val = UInt32($8D46) then Result := 'STENCIL_INDEX1' else
      if self.val = UInt32($8D47) then Result := 'STENCIL_INDEX4' else
      if self.val = UInt32($8D48) then Result := 'STENCIL_INDEX8' else
      if self.val = UInt32($8D49) then Result := 'STENCIL_INDEX16' else
      if self.val = UInt32($8D62) then Result := 'RGB565' else
      if self.val = UInt32($8D64) then Result := 'ETC1_RGB8' else
      if self.val = UInt32($8D70) then Result := 'RGBA32UI' else
      if self.val = UInt32($8D71) then Result := 'RGB32UI' else
      if self.val = UInt32($8D72) then Result := 'ALPHA32UI' else
      if self.val = UInt32($8D73) then Result := 'INTENSITY32UI' else
      if self.val = UInt32($8D74) then Result := 'LUMINANCE32UI' else
      if self.val = UInt32($8D75) then Result := 'LUMINANCE_ALPHA32UI' else
      if self.val = UInt32($8D76) then Result := 'RGBA16UI' else
      if self.val = UInt32($8D77) then Result := 'RGB16UI' else
      if self.val = UInt32($8D78) then Result := 'ALPHA16UI' else
      if self.val = UInt32($8D79) then Result := 'INTENSITY16UI' else
      if self.val = UInt32($8D7A) then Result := 'LUMINANCE16UI' else
      if self.val = UInt32($8D7B) then Result := 'LUMINANCE_ALPHA16UI' else
      if self.val = UInt32($8D7C) then Result := 'RGBA8UI' else
      if self.val = UInt32($8D7D) then Result := 'RGB8UI' else
      if self.val = UInt32($8D7E) then Result := 'ALPHA8UI' else
      if self.val = UInt32($8D7F) then Result := 'INTENSITY8UI' else
      if self.val = UInt32($8D80) then Result := 'LUMINANCE8UI' else
      if self.val = UInt32($8D81) then Result := 'LUMINANCE_ALPHA8UI' else
      if self.val = UInt32($8D82) then Result := 'RGBA32I' else
      if self.val = UInt32($8D83) then Result := 'RGB32I' else
      if self.val = UInt32($8D84) then Result := 'ALPHA32I' else
      if self.val = UInt32($8D85) then Result := 'INTENSITY32I' else
      if self.val = UInt32($8D86) then Result := 'LUMINANCE32I' else
      if self.val = UInt32($8D87) then Result := 'LUMINANCE_ALPHA32I' else
      if self.val = UInt32($8D88) then Result := 'RGBA16I' else
      if self.val = UInt32($8D89) then Result := 'RGB16I' else
      if self.val = UInt32($8D8A) then Result := 'ALPHA16I' else
      if self.val = UInt32($8D8B) then Result := 'INTENSITY16I' else
      if self.val = UInt32($8D8C) then Result := 'LUMINANCE16I' else
      if self.val = UInt32($8D8D) then Result := 'LUMINANCE_ALPHA16I' else
      if self.val = UInt32($8D8E) then Result := 'RGBA8I' else
      if self.val = UInt32($8D8F) then Result := 'RGB8I' else
      if self.val = UInt32($8D90) then Result := 'ALPHA8I' else
      if self.val = UInt32($8D91) then Result := 'INTENSITY8I' else
      if self.val = UInt32($8D92) then Result := 'LUMINANCE8I' else
      if self.val = UInt32($8D93) then Result := 'LUMINANCE_ALPHA8I' else
      if self.val = UInt32($8DAB) then Result := 'DEPTH_COMPONENT32F_NV' else
      if self.val = UInt32($8DAC) then Result := 'DEPTH32F_STENCIL8_NV' else
      if self.val = UInt32($8DBB) then Result := 'COMPRESSED_RED_RGTC1' else
      if self.val = UInt32($8DBC) then Result := 'COMPRESSED_SIGNED_RED_RGTC1' else
      if self.val = UInt32($8DBD) then Result := 'COMPRESSED_RED_GREEN_RGTC2' else
      if self.val = UInt32($8DBD) then Result := 'COMPRESSED_RG_RGTC2' else
      if self.val = UInt32($8DBE) then Result := 'COMPRESSED_SIGNED_RED_GREEN_RGTC2' else
      if self.val = UInt32($8DBE) then Result := 'COMPRESSED_SIGNED_RG_RGTC2' else
      if self.val = UInt32($8E8C) then Result := 'COMPRESSED_RGBA_BPTC_UNORM' else
      if self.val = UInt32($8E8D) then Result := 'COMPRESSED_SRGB_ALPHA_BPTC_UNORM' else
      if self.val = UInt32($8E8E) then Result := 'COMPRESSED_RGB_BPTC_SIGNED_FLOAT' else
      if self.val = UInt32($8E8F) then Result := 'COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT' else
      if self.val = UInt32($8F94) then Result := 'R8_SNORM' else
      if self.val = UInt32($8F95) then Result := 'RG8_SNORM' else
      if self.val = UInt32($8F96) then Result := 'RGB8_SNORM' else
      if self.val = UInt32($8F97) then Result := 'RGBA8_SNORM' else
      if self.val = UInt32($8F98) then Result := 'R16_SNORM' else
      if self.val = UInt32($8F99) then Result := 'RG16_SNORM' else
      if self.val = UInt32($8F9A) then Result := 'RGB16_SNORM' else
      if self.val = UInt32($8F9B) then Result := 'RGBA16_SNORM' else
      if self.val = UInt32($906F) then Result := 'RGB10_A2UI' else
      if self.val = UInt32($9270) then Result := 'COMPRESSED_R11_EAC' else
      if self.val = UInt32($9271) then Result := 'COMPRESSED_SIGNED_R11_EAC' else
      if self.val = UInt32($9272) then Result := 'COMPRESSED_RG11_EAC' else
      if self.val = UInt32($9273) then Result := 'COMPRESSED_SIGNED_RG11_EAC' else
      if self.val = UInt32($9274) then Result := 'COMPRESSED_RGB8_ETC2' else
      if self.val = UInt32($9275) then Result := 'COMPRESSED_SRGB8_ETC2' else
      if self.val = UInt32($9276) then Result := 'COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2' else
      if self.val = UInt32($9277) then Result := 'COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2' else
      if self.val = UInt32($9278) then Result := 'COMPRESSED_RGBA8_ETC2_EAC' else
      if self.val = UInt32($9279) then Result := 'COMPRESSED_SRGB8_ALPHA8_ETC2_EAC' else
      if self.val = UInt32($93B0) then Result := 'COMPRESSED_RGBA_ASTC_4x4' else
      if self.val = UInt32($93B1) then Result := 'COMPRESSED_RGBA_ASTC_5x4' else
      if self.val = UInt32($93B2) then Result := 'COMPRESSED_RGBA_ASTC_5x5' else
      if self.val = UInt32($93B3) then Result := 'COMPRESSED_RGBA_ASTC_6x5' else
      if self.val = UInt32($93B4) then Result := 'COMPRESSED_RGBA_ASTC_6x6' else
      if self.val = UInt32($93B5) then Result := 'COMPRESSED_RGBA_ASTC_8x5' else
      if self.val = UInt32($93B6) then Result := 'COMPRESSED_RGBA_ASTC_8x6' else
      if self.val = UInt32($93B7) then Result := 'COMPRESSED_RGBA_ASTC_8x8' else
      if self.val = UInt32($93B8) then Result := 'COMPRESSED_RGBA_ASTC_10x5' else
      if self.val = UInt32($93B9) then Result := 'COMPRESSED_RGBA_ASTC_10x6' else
      if self.val = UInt32($93BA) then Result := 'COMPRESSED_RGBA_ASTC_10x8' else
      if self.val = UInt32($93BB) then Result := 'COMPRESSED_RGBA_ASTC_10x10' else
      if self.val = UInt32($93BC) then Result := 'COMPRESSED_RGBA_ASTC_12x10' else
      if self.val = UInt32($93BD) then Result := 'COMPRESSED_RGBA_ASTC_12x12' else
      if self.val = UInt32($93C0) then Result := 'COMPRESSED_RGBA_ASTC_3x3x3' else
      if self.val = UInt32($93C1) then Result := 'COMPRESSED_RGBA_ASTC_4x3x3' else
      if self.val = UInt32($93C2) then Result := 'COMPRESSED_RGBA_ASTC_4x4x3' else
      if self.val = UInt32($93C3) then Result := 'COMPRESSED_RGBA_ASTC_4x4x4' else
      if self.val = UInt32($93C4) then Result := 'COMPRESSED_RGBA_ASTC_5x4x4' else
      if self.val = UInt32($93C5) then Result := 'COMPRESSED_RGBA_ASTC_5x5x4' else
      if self.val = UInt32($93C6) then Result := 'COMPRESSED_RGBA_ASTC_5x5x5' else
      if self.val = UInt32($93C7) then Result := 'COMPRESSED_RGBA_ASTC_6x5x5' else
      if self.val = UInt32($93C8) then Result := 'COMPRESSED_RGBA_ASTC_6x6x5' else
      if self.val = UInt32($93C9) then Result := 'COMPRESSED_RGBA_ASTC_6x6x6' else
      if self.val = UInt32($93D0) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x4' else
      if self.val = UInt32($93D1) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x4' else
      if self.val = UInt32($93D2) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x5' else
      if self.val = UInt32($93D3) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x5' else
      if self.val = UInt32($93D4) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x6' else
      if self.val = UInt32($93D5) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x5' else
      if self.val = UInt32($93D6) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x6' else
      if self.val = UInt32($93D7) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x8' else
      if self.val = UInt32($93D8) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x5' else
      if self.val = UInt32($93D9) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x6' else
      if self.val = UInt32($93DA) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x8' else
      if self.val = UInt32($93DB) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x10' else
      if self.val = UInt32($93DC) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_12x10' else
      if self.val = UInt32($93DD) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_12x12' else
      if self.val = UInt32($93E0) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3' else
      if self.val = UInt32($93E1) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3' else
      if self.val = UInt32($93E2) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3' else
      if self.val = UInt32($93E3) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4' else
      if self.val = UInt32($93E4) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4' else
      if self.val = UInt32($93E5) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4' else
      if self.val = UInt32($93E6) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5' else
      if self.val = UInt32($93E7) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5' else
      if self.val = UInt32($93E8) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5' else
      if self.val = UInt32($93E9) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6' else
        Result := $'SizedInternalFormat[{self.val}]';
    end;
    
  end;
  
  SpriteParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SPRITE_MODE: SpriteParameterName read new SpriteParameterName($8149);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8149) then Result := 'SPRITE_MODE' else
        Result := $'SpriteParameterName[{self.val}]';
    end;
    
  end;
  
  StencilFunction = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEVER:    StencilFunction read new StencilFunction($0200);
    public static property LESS:     StencilFunction read new StencilFunction($0201);
    public static property EQUAL:    StencilFunction read new StencilFunction($0202);
    public static property LEQUAL:   StencilFunction read new StencilFunction($0203);
    public static property GREATER:  StencilFunction read new StencilFunction($0204);
    public static property NOTEQUAL: StencilFunction read new StencilFunction($0205);
    public static property GEQUAL:   StencilFunction read new StencilFunction($0206);
    public static property ALWAYS:   StencilFunction read new StencilFunction($0207);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0200) then Result := 'NEVER' else
      if self.val = UInt32($0201) then Result := 'LESS' else
      if self.val = UInt32($0202) then Result := 'EQUAL' else
      if self.val = UInt32($0203) then Result := 'LEQUAL' else
      if self.val = UInt32($0204) then Result := 'GREATER' else
      if self.val = UInt32($0205) then Result := 'NOTEQUAL' else
      if self.val = UInt32($0206) then Result := 'GEQUAL' else
      if self.val = UInt32($0207) then Result := 'ALWAYS' else
        Result := $'StencilFunction[{self.val}]';
    end;
    
  end;
  
  StencilOp = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ZERO:      StencilOp read new StencilOp($0000);
    public static property INVERT:    StencilOp read new StencilOp($150A);
    public static property KEEP:      StencilOp read new StencilOp($1E00);
    public static property REPLACE:   StencilOp read new StencilOp($1E01);
    public static property INCR:      StencilOp read new StencilOp($1E02);
    public static property DECR:      StencilOp read new StencilOp($1E03);
    public static property INCR_WRAP: StencilOp read new StencilOp($8507);
    public static property DECR_WRAP: StencilOp read new StencilOp($8508);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'ZERO' else
      if self.val = UInt32($150A) then Result := 'INVERT' else
      if self.val = UInt32($1E00) then Result := 'KEEP' else
      if self.val = UInt32($1E01) then Result := 'REPLACE' else
      if self.val = UInt32($1E02) then Result := 'INCR' else
      if self.val = UInt32($1E03) then Result := 'DECR' else
      if self.val = UInt32($8507) then Result := 'INCR_WRAP' else
      if self.val = UInt32($8508) then Result := 'DECR_WRAP' else
        Result := $'StencilOp[{self.val}]';
    end;
    
  end;
  
  StringName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VENDOR:                   StringName read new StringName($1F00);
    public static property RENDERER:                 StringName read new StringName($1F01);
    public static property VERSION:                  StringName read new StringName($1F02);
    public static property EXTENSIONS:               StringName read new StringName($1F03);
    public static property SHADING_LANGUAGE_VERSION: StringName read new StringName($8B8C);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1F00) then Result := 'VENDOR' else
      if self.val = UInt32($1F01) then Result := 'RENDERER' else
      if self.val = UInt32($1F02) then Result := 'VERSION' else
      if self.val = UInt32($1F03) then Result := 'EXTENSIONS' else
      if self.val = UInt32($8B8C) then Result := 'SHADING_LANGUAGE_VERSION' else
        Result := $'StringName[{self.val}]';
    end;
    
  end;
  
  SubgroupSupportedFeatures = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SUBGROUP_FEATURE_BASIC_BIT:            SubgroupSupportedFeatures read new SubgroupSupportedFeatures($0001);
    public static property SUBGROUP_FEATURE_VOTE_BIT:             SubgroupSupportedFeatures read new SubgroupSupportedFeatures($0002);
    public static property SUBGROUP_FEATURE_ARITHMETIC_BIT:       SubgroupSupportedFeatures read new SubgroupSupportedFeatures($0004);
    public static property SUBGROUP_FEATURE_BALLOT_BIT:           SubgroupSupportedFeatures read new SubgroupSupportedFeatures($0008);
    public static property SUBGROUP_FEATURE_SHUFFLE_BIT:          SubgroupSupportedFeatures read new SubgroupSupportedFeatures($0010);
    public static property SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT: SubgroupSupportedFeatures read new SubgroupSupportedFeatures($0020);
    public static property SUBGROUP_FEATURE_CLUSTERED_BIT:        SubgroupSupportedFeatures read new SubgroupSupportedFeatures($0040);
    public static property SUBGROUP_FEATURE_QUAD_BIT:             SubgroupSupportedFeatures read new SubgroupSupportedFeatures($0080);
    public static property SUBGROUP_FEATURE_PARTITIONED_BIT:      SubgroupSupportedFeatures read new SubgroupSupportedFeatures($0100);
    
    public static function operator+(f1,f2: SubgroupSupportedFeatures) := new SubgroupSupportedFeatures(f1.val or f2.val);
    public static function operator or(f1,f2: SubgroupSupportedFeatures) := f1+f2;
    
    public static procedure operator+=(var f1: SubgroupSupportedFeatures; f2: SubgroupSupportedFeatures) := f1 := f1+f2;
    
    public property HAS_FLAG_SUBGROUP_FEATURE_BASIC_BIT:            boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_SUBGROUP_FEATURE_VOTE_BIT:             boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_SUBGROUP_FEATURE_ARITHMETIC_BIT:       boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_SUBGROUP_FEATURE_BALLOT_BIT:           boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_SUBGROUP_FEATURE_SHUFFLE_BIT:          boolean read self.val and $0010 <> 0;
    public property HAS_FLAG_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT: boolean read self.val and $0020 <> 0;
    public property HAS_FLAG_SUBGROUP_FEATURE_CLUSTERED_BIT:        boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_SUBGROUP_FEATURE_QUAD_BIT:             boolean read self.val and $0080 <> 0;
    public property HAS_FLAG_SUBGROUP_FEATURE_PARTITIONED_BIT:      boolean read self.val and $0100 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'SUBGROUP_FEATURE_BASIC_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'SUBGROUP_FEATURE_VOTE_BIT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'SUBGROUP_FEATURE_ARITHMETIC_BIT+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'SUBGROUP_FEATURE_BALLOT_BIT+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'SUBGROUP_FEATURE_SHUFFLE_BIT+';
      if self.val and UInt32($0020) = UInt32($0020) then res += 'SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'SUBGROUP_FEATURE_CLUSTERED_BIT+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'SUBGROUP_FEATURE_QUAD_BIT+';
      if self.val and UInt32($0100) = UInt32($0100) then res += 'SUBGROUP_FEATURE_PARTITIONED_BIT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'SubgroupSupportedFeatures[{self.val}]';
    end;
    
  end;
  
  SubroutineParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNIFORM_SIZE:               SubroutineParameterName read new SubroutineParameterName($8A38);
    public static property UNIFORM_NAME_LENGTH:        SubroutineParameterName read new SubroutineParameterName($8A39);
    public static property NUM_COMPATIBLE_SUBROUTINES: SubroutineParameterName read new SubroutineParameterName($8E4A);
    public static property COMPATIBLE_SUBROUTINES:     SubroutineParameterName read new SubroutineParameterName($8E4B);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8A38) then Result := 'UNIFORM_SIZE' else
      if self.val = UInt32($8A39) then Result := 'UNIFORM_NAME_LENGTH' else
      if self.val = UInt32($8E4A) then Result := 'NUM_COMPATIBLE_SUBROUTINES' else
      if self.val = UInt32($8E4B) then Result := 'COMPATIBLE_SUBROUTINES' else
        Result := $'SubroutineParameterName[{self.val}]';
    end;
    
  end;
  
  SwizzleOp = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SWIZZLE_STR:    SwizzleOp read new SwizzleOp($8976);
    public static property SWIZZLE_STQ:    SwizzleOp read new SwizzleOp($8977);
    public static property SWIZZLE_STR_DR: SwizzleOp read new SwizzleOp($8978);
    public static property SWIZZLE_STQ_DQ: SwizzleOp read new SwizzleOp($8979);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8976) then Result := 'SWIZZLE_STR' else
      if self.val = UInt32($8977) then Result := 'SWIZZLE_STQ' else
      if self.val = UInt32($8978) then Result := 'SWIZZLE_STR_DR' else
      if self.val = UInt32($8979) then Result := 'SWIZZLE_STQ_DQ' else
        Result := $'SwizzleOp[{self.val}]';
    end;
    
  end;
  
  SyncBehaviorFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE: SyncBehaviorFlags read new SyncBehaviorFlags($0000);
    
    public static function operator+(f1,f2: SyncBehaviorFlags) := new SyncBehaviorFlags(f1.val or f2.val);
    public static function operator or(f1,f2: SyncBehaviorFlags) := f1+f2;
    
    public static procedure operator+=(var f1: SyncBehaviorFlags; f2: SyncBehaviorFlags) := f1 := f1+f2;
    
    public property ANY_FLAGS: boolean read self.val<>0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'SyncBehaviorFlags[{self.val}]';
    end;
    
  end;
  
  SyncCondition = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SYNC_GPU_COMMANDS_COMPLETE: SyncCondition read new SyncCondition($9117);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9117) then Result := 'SYNC_GPU_COMMANDS_COMPLETE' else
        Result := $'SyncCondition[{self.val}]';
    end;
    
  end;
  
  SyncObjectMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SYNC_FLUSH_COMMANDS_BIT: SyncObjectMask read new SyncObjectMask($0001);
    
    public static function operator+(f1,f2: SyncObjectMask) := new SyncObjectMask(f1.val or f2.val);
    public static function operator or(f1,f2: SyncObjectMask) := f1+f2;
    
    public static procedure operator+=(var f1: SyncObjectMask; f2: SyncObjectMask) := f1 := f1+f2;
    
    public property HAS_FLAG_SYNC_FLUSH_COMMANDS_BIT: boolean read self.val and $0001 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'SYNC_FLUSH_COMMANDS_BIT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'SyncObjectMask[{self.val}]';
    end;
    
  end;
  
  SyncParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property OBJECT_TYPE:    SyncParameterName read new SyncParameterName($9112);
    public static property SYNC_CONDITION: SyncParameterName read new SyncParameterName($9113);
    public static property SYNC_STATUS:    SyncParameterName read new SyncParameterName($9114);
    public static property SYNC_FLAGS:     SyncParameterName read new SyncParameterName($9115);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9112) then Result := 'OBJECT_TYPE' else
      if self.val = UInt32($9113) then Result := 'SYNC_CONDITION' else
      if self.val = UInt32($9114) then Result := 'SYNC_STATUS' else
      if self.val = UInt32($9115) then Result := 'SYNC_FLAGS' else
        Result := $'SyncParameterName[{self.val}]';
    end;
    
  end;
  
  SyncStatus = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ALREADY_SIGNALED:    SyncStatus read new SyncStatus($911A);
    public static property TIMEOUT_EXPIRED:     SyncStatus read new SyncStatus($911B);
    public static property CONDITION_SATISFIED: SyncStatus read new SyncStatus($911C);
    public static property WAIT_FAILED:         SyncStatus read new SyncStatus($911D);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($911A) then Result := 'ALREADY_SIGNALED' else
      if self.val = UInt32($911B) then Result := 'TIMEOUT_EXPIRED' else
      if self.val = UInt32($911C) then Result := 'CONDITION_SATISFIED' else
      if self.val = UInt32($911D) then Result := 'WAIT_FAILED' else
        Result := $'SyncStatus[{self.val}]';
    end;
    
  end;
  
  TangentPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:   TangentPointerType read new TangentPointerType($1400);
    public static property SHORT:  TangentPointerType read new TangentPointerType($1402);
    public static property INT:    TangentPointerType read new TangentPointerType($1404);
    public static property FLOAT:  TangentPointerType read new TangentPointerType($1406);
    public static property DOUBLE: TangentPointerType read new TangentPointerType($140A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := $'TangentPointerType[{self.val}]';
    end;
    
  end;
  
  TexBumpParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BUMP_ROT_MATRIX: TexBumpParameter read new TexBumpParameter($8775);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8775) then Result := 'BUMP_ROT_MATRIX' else
        Result := $'TexBumpParameter[{self.val}]';
    end;
    
  end;
  
  TexCoordPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SHORT:  TexCoordPointerType read new TexCoordPointerType($1402);
    public static property INT:    TexCoordPointerType read new TexCoordPointerType($1404);
    public static property FLOAT:  TexCoordPointerType read new TexCoordPointerType($1406);
    public static property DOUBLE: TexCoordPointerType read new TexCoordPointerType($140A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := $'TexCoordPointerType[{self.val}]';
    end;
    
  end;
  
  TextureCompareMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:                   TextureCompareMode read new TextureCompareMode($0000);
    public static property COMPARE_R_TO_TEXTURE:   TextureCompareMode read new TextureCompareMode($884E);
    public static property COMPARE_REF_TO_TEXTURE: TextureCompareMode read new TextureCompareMode($884E);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($884E) then Result := 'COMPARE_R_TO_TEXTURE' else
      if self.val = UInt32($884E) then Result := 'COMPARE_REF_TO_TEXTURE' else
        Result := $'TextureCompareMode[{self.val}]';
    end;
    
  end;
  
  TextureCoordName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property S:               TextureCoordName read new TextureCoordName($2000);
    public static property T:               TextureCoordName read new TextureCoordName($2001);
    public static property R:               TextureCoordName read new TextureCoordName($2002);
    public static property Q:               TextureCoordName read new TextureCoordName($2003);
    public static property TEXTURE_GEN_STR: TextureCoordName read new TextureCoordName($8D60);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2000) then Result := 'S' else
      if self.val = UInt32($2001) then Result := 'T' else
      if self.val = UInt32($2002) then Result := 'R' else
      if self.val = UInt32($2003) then Result := 'Q' else
      if self.val = UInt32($8D60) then Result := 'TEXTURE_GEN_STR' else
        Result := $'TextureCoordName[{self.val}]';
    end;
    
  end;
  
  TextureEnvMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ADD:              TextureEnvMode read new TextureEnvMode($0104);
    public static property BLEND:            TextureEnvMode read new TextureEnvMode($0BE2);
    public static property MODULATE:         TextureEnvMode read new TextureEnvMode($2100);
    public static property DECAL:            TextureEnvMode read new TextureEnvMode($2101);
    public static property REPLACE_EXT:      TextureEnvMode read new TextureEnvMode($8062);
    public static property TEXTURE_ENV_BIAS: TextureEnvMode read new TextureEnvMode($80BE);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0104) then Result := 'ADD' else
      if self.val = UInt32($0BE2) then Result := 'BLEND' else
      if self.val = UInt32($2100) then Result := 'MODULATE' else
      if self.val = UInt32($2101) then Result := 'DECAL' else
      if self.val = UInt32($8062) then Result := 'REPLACE_EXT' else
      if self.val = UInt32($80BE) then Result := 'TEXTURE_ENV_BIAS' else
        Result := $'TextureEnvMode[{self.val}]';
    end;
    
  end;
  
  TextureEnvParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_ENV_MODE:  TextureEnvParameter read new TextureEnvParameter($2200);
    public static property TEXTURE_ENV_COLOR: TextureEnvParameter read new TextureEnvParameter($2201);
    public static property COMBINE:           TextureEnvParameter read new TextureEnvParameter($8570);
    public static property COMBINE_RGB:       TextureEnvParameter read new TextureEnvParameter($8571);
    public static property COMBINE_ALPHA:     TextureEnvParameter read new TextureEnvParameter($8572);
    public static property RGB_SCALE:         TextureEnvParameter read new TextureEnvParameter($8573);
    public static property ADD_SIGNED:        TextureEnvParameter read new TextureEnvParameter($8574);
    public static property INTERPOLATE:       TextureEnvParameter read new TextureEnvParameter($8575);
    public static property CONSTANT:          TextureEnvParameter read new TextureEnvParameter($8576);
    public static property PRIMARY_COLOR:     TextureEnvParameter read new TextureEnvParameter($8577);
    public static property PREVIOUS:          TextureEnvParameter read new TextureEnvParameter($8578);
    public static property SOURCE0_RGB:       TextureEnvParameter read new TextureEnvParameter($8580);
    public static property SRC0_RGB:          TextureEnvParameter read new TextureEnvParameter($8580);
    public static property SOURCE1_RGB:       TextureEnvParameter read new TextureEnvParameter($8581);
    public static property SRC1_RGB:          TextureEnvParameter read new TextureEnvParameter($8581);
    public static property SOURCE2_RGB:       TextureEnvParameter read new TextureEnvParameter($8582);
    public static property SRC2_RGB:          TextureEnvParameter read new TextureEnvParameter($8582);
    public static property SOURCE3_RGB:       TextureEnvParameter read new TextureEnvParameter($8583);
    public static property SOURCE0_ALPHA:     TextureEnvParameter read new TextureEnvParameter($8588);
    public static property SRC0_ALPHA:        TextureEnvParameter read new TextureEnvParameter($8588);
    public static property SOURCE1_ALPHA:     TextureEnvParameter read new TextureEnvParameter($8589);
    public static property SRC1_ALPHA:        TextureEnvParameter read new TextureEnvParameter($8589);
    public static property SOURCE2_ALPHA:     TextureEnvParameter read new TextureEnvParameter($858A);
    public static property SRC2_ALPHA:        TextureEnvParameter read new TextureEnvParameter($858A);
    public static property SOURCE3_ALPHA:     TextureEnvParameter read new TextureEnvParameter($858B);
    public static property OPERAND0_RGB:      TextureEnvParameter read new TextureEnvParameter($8590);
    public static property OPERAND1_RGB:      TextureEnvParameter read new TextureEnvParameter($8591);
    public static property OPERAND2_RGB:      TextureEnvParameter read new TextureEnvParameter($8592);
    public static property OPERAND3_RGB:      TextureEnvParameter read new TextureEnvParameter($8593);
    public static property OPERAND0_ALPHA:    TextureEnvParameter read new TextureEnvParameter($8598);
    public static property OPERAND1_ALPHA:    TextureEnvParameter read new TextureEnvParameter($8599);
    public static property OPERAND2_ALPHA:    TextureEnvParameter read new TextureEnvParameter($859A);
    public static property OPERAND3_ALPHA:    TextureEnvParameter read new TextureEnvParameter($859B);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2200) then Result := 'TEXTURE_ENV_MODE' else
      if self.val = UInt32($2201) then Result := 'TEXTURE_ENV_COLOR' else
      if self.val = UInt32($8570) then Result := 'COMBINE' else
      if self.val = UInt32($8571) then Result := 'COMBINE_RGB' else
      if self.val = UInt32($8572) then Result := 'COMBINE_ALPHA' else
      if self.val = UInt32($8573) then Result := 'RGB_SCALE' else
      if self.val = UInt32($8574) then Result := 'ADD_SIGNED' else
      if self.val = UInt32($8575) then Result := 'INTERPOLATE' else
      if self.val = UInt32($8576) then Result := 'CONSTANT' else
      if self.val = UInt32($8577) then Result := 'PRIMARY_COLOR' else
      if self.val = UInt32($8578) then Result := 'PREVIOUS' else
      if self.val = UInt32($8580) then Result := 'SOURCE0_RGB' else
      if self.val = UInt32($8580) then Result := 'SRC0_RGB' else
      if self.val = UInt32($8581) then Result := 'SOURCE1_RGB' else
      if self.val = UInt32($8581) then Result := 'SRC1_RGB' else
      if self.val = UInt32($8582) then Result := 'SOURCE2_RGB' else
      if self.val = UInt32($8582) then Result := 'SRC2_RGB' else
      if self.val = UInt32($8583) then Result := 'SOURCE3_RGB' else
      if self.val = UInt32($8588) then Result := 'SOURCE0_ALPHA' else
      if self.val = UInt32($8588) then Result := 'SRC0_ALPHA' else
      if self.val = UInt32($8589) then Result := 'SOURCE1_ALPHA' else
      if self.val = UInt32($8589) then Result := 'SRC1_ALPHA' else
      if self.val = UInt32($858A) then Result := 'SOURCE2_ALPHA' else
      if self.val = UInt32($858A) then Result := 'SRC2_ALPHA' else
      if self.val = UInt32($858B) then Result := 'SOURCE3_ALPHA' else
      if self.val = UInt32($8590) then Result := 'OPERAND0_RGB' else
      if self.val = UInt32($8591) then Result := 'OPERAND1_RGB' else
      if self.val = UInt32($8592) then Result := 'OPERAND2_RGB' else
      if self.val = UInt32($8593) then Result := 'OPERAND3_RGB' else
      if self.val = UInt32($8598) then Result := 'OPERAND0_ALPHA' else
      if self.val = UInt32($8599) then Result := 'OPERAND1_ALPHA' else
      if self.val = UInt32($859A) then Result := 'OPERAND2_ALPHA' else
      if self.val = UInt32($859B) then Result := 'OPERAND3_ALPHA' else
        Result := $'TextureEnvParameter[{self.val}]';
    end;
    
  end;
  
  TextureEnvTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_ENV: TextureEnvTarget read new TextureEnvTarget($2300);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2300) then Result := 'TEXTURE_ENV' else
        Result := $'TextureEnvTarget[{self.val}]';
    end;
    
  end;
  
  TextureFilter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FILTER4: TextureFilter read new TextureFilter($8146);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8146) then Result := 'FILTER4' else
        Result := $'TextureFilter[{self.val}]';
    end;
    
  end;
  
  TextureGenMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property EYE_LINEAR:               TextureGenMode read new TextureGenMode($2400);
    public static property OBJECT_LINEAR:            TextureGenMode read new TextureGenMode($2401);
    public static property SPHERE_MAP:               TextureGenMode read new TextureGenMode($2402);
    public static property EYE_DISTANCE_TO_POINT:    TextureGenMode read new TextureGenMode($81F0);
    public static property OBJECT_DISTANCE_TO_POINT: TextureGenMode read new TextureGenMode($81F1);
    public static property EYE_DISTANCE_TO_LINE:     TextureGenMode read new TextureGenMode($81F2);
    public static property OBJECT_DISTANCE_TO_LINE:  TextureGenMode read new TextureGenMode($81F3);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2400) then Result := 'EYE_LINEAR' else
      if self.val = UInt32($2401) then Result := 'OBJECT_LINEAR' else
      if self.val = UInt32($2402) then Result := 'SPHERE_MAP' else
      if self.val = UInt32($81F0) then Result := 'EYE_DISTANCE_TO_POINT' else
      if self.val = UInt32($81F1) then Result := 'OBJECT_DISTANCE_TO_POINT' else
      if self.val = UInt32($81F2) then Result := 'EYE_DISTANCE_TO_LINE' else
      if self.val = UInt32($81F3) then Result := 'OBJECT_DISTANCE_TO_LINE' else
        Result := $'TextureGenMode[{self.val}]';
    end;
    
  end;
  
  TextureGenParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_GEN_MODE: TextureGenParameter read new TextureGenParameter($2500);
    public static property OBJECT_PLANE:     TextureGenParameter read new TextureGenParameter($2501);
    public static property EYE_PLANE:        TextureGenParameter read new TextureGenParameter($2502);
    public static property EYE_POINT:        TextureGenParameter read new TextureGenParameter($81F4);
    public static property OBJECT_POINT:     TextureGenParameter read new TextureGenParameter($81F5);
    public static property EYE_LINE:         TextureGenParameter read new TextureGenParameter($81F6);
    public static property OBJECT_LINE:      TextureGenParameter read new TextureGenParameter($81F7);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2500) then Result := 'TEXTURE_GEN_MODE' else
      if self.val = UInt32($2501) then Result := 'OBJECT_PLANE' else
      if self.val = UInt32($2502) then Result := 'EYE_PLANE' else
      if self.val = UInt32($81F4) then Result := 'EYE_POINT' else
      if self.val = UInt32($81F5) then Result := 'OBJECT_POINT' else
      if self.val = UInt32($81F6) then Result := 'EYE_LINE' else
      if self.val = UInt32($81F7) then Result := 'OBJECT_LINE' else
        Result := $'TextureGenParameter[{self.val}]';
    end;
    
  end;
  
  TextureLayout = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT: TextureLayout read new TextureLayout($9530);
    public static property LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY: TextureLayout read new TextureLayout($9531);
    public static property LAYOUT_GENERAL:                            TextureLayout read new TextureLayout($958D);
    public static property LAYOUT_COLOR_ATTACHMENT:                   TextureLayout read new TextureLayout($958E);
    public static property LAYOUT_DEPTH_STENCIL_ATTACHMENT:           TextureLayout read new TextureLayout($958F);
    public static property LAYOUT_DEPTH_STENCIL_READ_ONLY:            TextureLayout read new TextureLayout($9590);
    public static property LAYOUT_SHADER_READ_ONLY:                   TextureLayout read new TextureLayout($9591);
    public static property LAYOUT_TRANSFER_SRC:                       TextureLayout read new TextureLayout($9592);
    public static property LAYOUT_TRANSFER_DST:                       TextureLayout read new TextureLayout($9593);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9530) then Result := 'LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT' else
      if self.val = UInt32($9531) then Result := 'LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY' else
      if self.val = UInt32($958D) then Result := 'LAYOUT_GENERAL' else
      if self.val = UInt32($958E) then Result := 'LAYOUT_COLOR_ATTACHMENT' else
      if self.val = UInt32($958F) then Result := 'LAYOUT_DEPTH_STENCIL_ATTACHMENT' else
      if self.val = UInt32($9590) then Result := 'LAYOUT_DEPTH_STENCIL_READ_ONLY' else
      if self.val = UInt32($9591) then Result := 'LAYOUT_SHADER_READ_ONLY' else
      if self.val = UInt32($9592) then Result := 'LAYOUT_TRANSFER_SRC' else
      if self.val = UInt32($9593) then Result := 'LAYOUT_TRANSFER_DST' else
        Result := $'TextureLayout[{self.val}]';
    end;
    
  end;
  
  TextureMagFilter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEAREST:                 TextureMagFilter read new TextureMagFilter($2600);
    public static property LINEAR:                  TextureMagFilter read new TextureMagFilter($2601);
    public static property LINEAR_DETAIL:           TextureMagFilter read new TextureMagFilter($8097);
    public static property LINEAR_DETAIL_ALPHA:     TextureMagFilter read new TextureMagFilter($8098);
    public static property LINEAR_DETAIL_COLOR:     TextureMagFilter read new TextureMagFilter($8099);
    public static property LINEAR_SHARPEN:          TextureMagFilter read new TextureMagFilter($80AD);
    public static property LINEAR_SHARPEN_ALPHA:    TextureMagFilter read new TextureMagFilter($80AE);
    public static property LINEAR_SHARPEN_COLOR:    TextureMagFilter read new TextureMagFilter($80AF);
    public static property FILTER4:                 TextureMagFilter read new TextureMagFilter($8146);
    public static property PIXEL_TEX_GEN_Q_CEILING: TextureMagFilter read new TextureMagFilter($8184);
    public static property PIXEL_TEX_GEN_Q_ROUND:   TextureMagFilter read new TextureMagFilter($8185);
    public static property PIXEL_TEX_GEN_Q_FLOOR:   TextureMagFilter read new TextureMagFilter($8186);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2600) then Result := 'NEAREST' else
      if self.val = UInt32($2601) then Result := 'LINEAR' else
      if self.val = UInt32($8097) then Result := 'LINEAR_DETAIL' else
      if self.val = UInt32($8098) then Result := 'LINEAR_DETAIL_ALPHA' else
      if self.val = UInt32($8099) then Result := 'LINEAR_DETAIL_COLOR' else
      if self.val = UInt32($80AD) then Result := 'LINEAR_SHARPEN' else
      if self.val = UInt32($80AE) then Result := 'LINEAR_SHARPEN_ALPHA' else
      if self.val = UInt32($80AF) then Result := 'LINEAR_SHARPEN_COLOR' else
      if self.val = UInt32($8146) then Result := 'FILTER4' else
      if self.val = UInt32($8184) then Result := 'PIXEL_TEX_GEN_Q_CEILING' else
      if self.val = UInt32($8185) then Result := 'PIXEL_TEX_GEN_Q_ROUND' else
      if self.val = UInt32($8186) then Result := 'PIXEL_TEX_GEN_Q_FLOOR' else
        Result := $'TextureMagFilter[{self.val}]';
    end;
    
  end;
  
  TextureMinFilter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEAREST:                 TextureMinFilter read new TextureMinFilter($2600);
    public static property LINEAR:                  TextureMinFilter read new TextureMinFilter($2601);
    public static property NEAREST_MIPMAP_NEAREST:  TextureMinFilter read new TextureMinFilter($2700);
    public static property LINEAR_MIPMAP_NEAREST:   TextureMinFilter read new TextureMinFilter($2701);
    public static property NEAREST_MIPMAP_LINEAR:   TextureMinFilter read new TextureMinFilter($2702);
    public static property LINEAR_MIPMAP_LINEAR:    TextureMinFilter read new TextureMinFilter($2703);
    public static property FILTER4:                 TextureMinFilter read new TextureMinFilter($8146);
    public static property LINEAR_CLIPMAP_LINEAR:   TextureMinFilter read new TextureMinFilter($8170);
    public static property PIXEL_TEX_GEN_Q_CEILING: TextureMinFilter read new TextureMinFilter($8184);
    public static property PIXEL_TEX_GEN_Q_ROUND:   TextureMinFilter read new TextureMinFilter($8185);
    public static property PIXEL_TEX_GEN_Q_FLOOR:   TextureMinFilter read new TextureMinFilter($8186);
    public static property NEAREST_CLIPMAP_NEAREST: TextureMinFilter read new TextureMinFilter($844D);
    public static property NEAREST_CLIPMAP_LINEAR:  TextureMinFilter read new TextureMinFilter($844E);
    public static property LINEAR_CLIPMAP_NEAREST:  TextureMinFilter read new TextureMinFilter($844F);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2600) then Result := 'NEAREST' else
      if self.val = UInt32($2601) then Result := 'LINEAR' else
      if self.val = UInt32($2700) then Result := 'NEAREST_MIPMAP_NEAREST' else
      if self.val = UInt32($2701) then Result := 'LINEAR_MIPMAP_NEAREST' else
      if self.val = UInt32($2702) then Result := 'NEAREST_MIPMAP_LINEAR' else
      if self.val = UInt32($2703) then Result := 'LINEAR_MIPMAP_LINEAR' else
      if self.val = UInt32($8146) then Result := 'FILTER4' else
      if self.val = UInt32($8170) then Result := 'LINEAR_CLIPMAP_LINEAR' else
      if self.val = UInt32($8184) then Result := 'PIXEL_TEX_GEN_Q_CEILING' else
      if self.val = UInt32($8185) then Result := 'PIXEL_TEX_GEN_Q_ROUND' else
      if self.val = UInt32($8186) then Result := 'PIXEL_TEX_GEN_Q_FLOOR' else
      if self.val = UInt32($844D) then Result := 'NEAREST_CLIPMAP_NEAREST' else
      if self.val = UInt32($844E) then Result := 'NEAREST_CLIPMAP_LINEAR' else
      if self.val = UInt32($844F) then Result := 'LINEAR_CLIPMAP_NEAREST' else
        Result := $'TextureMinFilter[{self.val}]';
    end;
    
  end;
  
  TextureNormalMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PERTURB: TextureNormalMode read new TextureNormalMode($85AE);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($85AE) then Result := 'PERTURB' else
        Result := $'TextureNormalMode[{self.val}]';
    end;
    
  end;
  
  TextureParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_WIDTH:                        TextureParameterName read new TextureParameterName($1000);
    public static property TEXTURE_HEIGHT:                       TextureParameterName read new TextureParameterName($1001);
    public static property TEXTURE_INTERNAL_FORMAT:              TextureParameterName read new TextureParameterName($1003);
    public static property TEXTURE_COMPONENTS:                   TextureParameterName read new TextureParameterName($1003);
    public static property TEXTURE_BORDER_COLOR:                 TextureParameterName read new TextureParameterName($1004);
    public static property TEXTURE_BORDER:                       TextureParameterName read new TextureParameterName($1005);
    public static property TEXTURE_MAG_FILTER:                   TextureParameterName read new TextureParameterName($2800);
    public static property TEXTURE_MIN_FILTER:                   TextureParameterName read new TextureParameterName($2801);
    public static property TEXTURE_WRAP_S:                       TextureParameterName read new TextureParameterName($2802);
    public static property TEXTURE_WRAP_T:                       TextureParameterName read new TextureParameterName($2803);
    public static property TEXTURE_RED_SIZE:                     TextureParameterName read new TextureParameterName($805C);
    public static property TEXTURE_GREEN_SIZE:                   TextureParameterName read new TextureParameterName($805D);
    public static property TEXTURE_BLUE_SIZE:                    TextureParameterName read new TextureParameterName($805E);
    public static property TEXTURE_ALPHA_SIZE:                   TextureParameterName read new TextureParameterName($805F);
    public static property TEXTURE_LUMINANCE_SIZE:               TextureParameterName read new TextureParameterName($8060);
    public static property TEXTURE_INTENSITY_SIZE:               TextureParameterName read new TextureParameterName($8061);
    public static property TEXTURE_PRIORITY:                     TextureParameterName read new TextureParameterName($8066);
    public static property TEXTURE_RESIDENT:                     TextureParameterName read new TextureParameterName($8067);
    public static property TEXTURE_DEPTH:                        TextureParameterName read new TextureParameterName($8071);
    public static property TEXTURE_WRAP_R:                       TextureParameterName read new TextureParameterName($8072);
    public static property DETAIL_TEXTURE_LEVEL:                 TextureParameterName read new TextureParameterName($809A);
    public static property DETAIL_TEXTURE_MODE:                  TextureParameterName read new TextureParameterName($809B);
    public static property DETAIL_TEXTURE_FUNC_POINTS:           TextureParameterName read new TextureParameterName($809C);
    public static property SHARPEN_TEXTURE_FUNC_POINTS:          TextureParameterName read new TextureParameterName($80B0);
    public static property SHADOW_AMBIENT:                       TextureParameterName read new TextureParameterName($80BF);
    public static property DUAL_TEXTURE_SELECT:                  TextureParameterName read new TextureParameterName($8124);
    public static property QUAD_TEXTURE_SELECT:                  TextureParameterName read new TextureParameterName($8125);
    public static property TEXTURE_4DSIZE:                       TextureParameterName read new TextureParameterName($8136);
    public static property TEXTURE_WRAP_Q:                       TextureParameterName read new TextureParameterName($8137);
    public static property TEXTURE_MIN_LOD:                      TextureParameterName read new TextureParameterName($813A);
    public static property TEXTURE_MAX_LOD:                      TextureParameterName read new TextureParameterName($813B);
    public static property TEXTURE_BASE_LEVEL:                   TextureParameterName read new TextureParameterName($813C);
    public static property TEXTURE_MAX_LEVEL:                    TextureParameterName read new TextureParameterName($813D);
    public static property TEXTURE_FILTER4_SIZE:                 TextureParameterName read new TextureParameterName($8147);
    public static property TEXTURE_CLIPMAP_CENTER:               TextureParameterName read new TextureParameterName($8171);
    public static property TEXTURE_CLIPMAP_FRAME:                TextureParameterName read new TextureParameterName($8172);
    public static property TEXTURE_CLIPMAP_OFFSET:               TextureParameterName read new TextureParameterName($8173);
    public static property TEXTURE_CLIPMAP_VIRTUAL_DEPTH:        TextureParameterName read new TextureParameterName($8174);
    public static property TEXTURE_CLIPMAP_LOD_OFFSET:           TextureParameterName read new TextureParameterName($8175);
    public static property TEXTURE_CLIPMAP_DEPTH:                TextureParameterName read new TextureParameterName($8176);
    public static property POST_TEXTURE_FILTER_BIAS:             TextureParameterName read new TextureParameterName($8179);
    public static property POST_TEXTURE_FILTER_SCALE:            TextureParameterName read new TextureParameterName($817A);
    public static property TEXTURE_LOD_BIAS_S:                   TextureParameterName read new TextureParameterName($818E);
    public static property TEXTURE_LOD_BIAS_T:                   TextureParameterName read new TextureParameterName($818F);
    public static property TEXTURE_LOD_BIAS_R:                   TextureParameterName read new TextureParameterName($8190);
    public static property GENERATE_MIPMAP:                      TextureParameterName read new TextureParameterName($8191);
    public static property TEXTURE_COMPARE:                      TextureParameterName read new TextureParameterName($819A);
    public static property TEXTURE_COMPARE_OPERATOR:             TextureParameterName read new TextureParameterName($819B);
    public static property TEXTURE_LEQUAL_R:                     TextureParameterName read new TextureParameterName($819C);
    public static property TEXTURE_GEQUAL_R:                     TextureParameterName read new TextureParameterName($819D);
    public static property TEXTURE_MAX_CLAMP_S:                  TextureParameterName read new TextureParameterName($8369);
    public static property TEXTURE_MAX_CLAMP_T:                  TextureParameterName read new TextureParameterName($836A);
    public static property TEXTURE_MAX_CLAMP_R:                  TextureParameterName read new TextureParameterName($836B);
    public static property TEXTURE_MEMORY_LAYOUT:                TextureParameterName read new TextureParameterName($83FF);
    public static property TEXTURE_MAX_ANISOTROPY:               TextureParameterName read new TextureParameterName($84FE);
    public static property TEXTURE_LOD_BIAS:                     TextureParameterName read new TextureParameterName($8501);
    public static property TEXTURE_COMPARE_MODE:                 TextureParameterName read new TextureParameterName($884C);
    public static property TEXTURE_COMPARE_FUNC:                 TextureParameterName read new TextureParameterName($884D);
    public static property TEXTURE_SWIZZLE_R:                    TextureParameterName read new TextureParameterName($8E42);
    public static property TEXTURE_SWIZZLE_G:                    TextureParameterName read new TextureParameterName($8E43);
    public static property TEXTURE_SWIZZLE_B:                    TextureParameterName read new TextureParameterName($8E44);
    public static property TEXTURE_SWIZZLE_A:                    TextureParameterName read new TextureParameterName($8E45);
    public static property TEXTURE_SWIZZLE_RGBA:                 TextureParameterName read new TextureParameterName($8E46);
    public static property TEXTURE_UNNORMALIZED_COORDINATES_ARM: TextureParameterName read new TextureParameterName($8F6A);
    public static property DEPTH_STENCIL_TEXTURE_MODE:           TextureParameterName read new TextureParameterName($90EA);
    public static property TEXTURE_TILING:                       TextureParameterName read new TextureParameterName($9580);
    public static property TEXTURE_FOVEATED_CUTOFF_DENSITY:      TextureParameterName read new TextureParameterName($96A0);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1000) then Result := 'TEXTURE_WIDTH' else
      if self.val = UInt32($1001) then Result := 'TEXTURE_HEIGHT' else
      if self.val = UInt32($1003) then Result := 'TEXTURE_INTERNAL_FORMAT' else
      if self.val = UInt32($1003) then Result := 'TEXTURE_COMPONENTS' else
      if self.val = UInt32($1004) then Result := 'TEXTURE_BORDER_COLOR' else
      if self.val = UInt32($1005) then Result := 'TEXTURE_BORDER' else
      if self.val = UInt32($2800) then Result := 'TEXTURE_MAG_FILTER' else
      if self.val = UInt32($2801) then Result := 'TEXTURE_MIN_FILTER' else
      if self.val = UInt32($2802) then Result := 'TEXTURE_WRAP_S' else
      if self.val = UInt32($2803) then Result := 'TEXTURE_WRAP_T' else
      if self.val = UInt32($805C) then Result := 'TEXTURE_RED_SIZE' else
      if self.val = UInt32($805D) then Result := 'TEXTURE_GREEN_SIZE' else
      if self.val = UInt32($805E) then Result := 'TEXTURE_BLUE_SIZE' else
      if self.val = UInt32($805F) then Result := 'TEXTURE_ALPHA_SIZE' else
      if self.val = UInt32($8060) then Result := 'TEXTURE_LUMINANCE_SIZE' else
      if self.val = UInt32($8061) then Result := 'TEXTURE_INTENSITY_SIZE' else
      if self.val = UInt32($8066) then Result := 'TEXTURE_PRIORITY' else
      if self.val = UInt32($8067) then Result := 'TEXTURE_RESIDENT' else
      if self.val = UInt32($8071) then Result := 'TEXTURE_DEPTH' else
      if self.val = UInt32($8072) then Result := 'TEXTURE_WRAP_R' else
      if self.val = UInt32($809A) then Result := 'DETAIL_TEXTURE_LEVEL' else
      if self.val = UInt32($809B) then Result := 'DETAIL_TEXTURE_MODE' else
      if self.val = UInt32($809C) then Result := 'DETAIL_TEXTURE_FUNC_POINTS' else
      if self.val = UInt32($80B0) then Result := 'SHARPEN_TEXTURE_FUNC_POINTS' else
      if self.val = UInt32($80BF) then Result := 'SHADOW_AMBIENT' else
      if self.val = UInt32($8124) then Result := 'DUAL_TEXTURE_SELECT' else
      if self.val = UInt32($8125) then Result := 'QUAD_TEXTURE_SELECT' else
      if self.val = UInt32($8136) then Result := 'TEXTURE_4DSIZE' else
      if self.val = UInt32($8137) then Result := 'TEXTURE_WRAP_Q' else
      if self.val = UInt32($813A) then Result := 'TEXTURE_MIN_LOD' else
      if self.val = UInt32($813B) then Result := 'TEXTURE_MAX_LOD' else
      if self.val = UInt32($813C) then Result := 'TEXTURE_BASE_LEVEL' else
      if self.val = UInt32($813D) then Result := 'TEXTURE_MAX_LEVEL' else
      if self.val = UInt32($8147) then Result := 'TEXTURE_FILTER4_SIZE' else
      if self.val = UInt32($8171) then Result := 'TEXTURE_CLIPMAP_CENTER' else
      if self.val = UInt32($8172) then Result := 'TEXTURE_CLIPMAP_FRAME' else
      if self.val = UInt32($8173) then Result := 'TEXTURE_CLIPMAP_OFFSET' else
      if self.val = UInt32($8174) then Result := 'TEXTURE_CLIPMAP_VIRTUAL_DEPTH' else
      if self.val = UInt32($8175) then Result := 'TEXTURE_CLIPMAP_LOD_OFFSET' else
      if self.val = UInt32($8176) then Result := 'TEXTURE_CLIPMAP_DEPTH' else
      if self.val = UInt32($8179) then Result := 'POST_TEXTURE_FILTER_BIAS' else
      if self.val = UInt32($817A) then Result := 'POST_TEXTURE_FILTER_SCALE' else
      if self.val = UInt32($818E) then Result := 'TEXTURE_LOD_BIAS_S' else
      if self.val = UInt32($818F) then Result := 'TEXTURE_LOD_BIAS_T' else
      if self.val = UInt32($8190) then Result := 'TEXTURE_LOD_BIAS_R' else
      if self.val = UInt32($8191) then Result := 'GENERATE_MIPMAP' else
      if self.val = UInt32($819A) then Result := 'TEXTURE_COMPARE' else
      if self.val = UInt32($819B) then Result := 'TEXTURE_COMPARE_OPERATOR' else
      if self.val = UInt32($819C) then Result := 'TEXTURE_LEQUAL_R' else
      if self.val = UInt32($819D) then Result := 'TEXTURE_GEQUAL_R' else
      if self.val = UInt32($8369) then Result := 'TEXTURE_MAX_CLAMP_S' else
      if self.val = UInt32($836A) then Result := 'TEXTURE_MAX_CLAMP_T' else
      if self.val = UInt32($836B) then Result := 'TEXTURE_MAX_CLAMP_R' else
      if self.val = UInt32($83FF) then Result := 'TEXTURE_MEMORY_LAYOUT' else
      if self.val = UInt32($84FE) then Result := 'TEXTURE_MAX_ANISOTROPY' else
      if self.val = UInt32($8501) then Result := 'TEXTURE_LOD_BIAS' else
      if self.val = UInt32($884C) then Result := 'TEXTURE_COMPARE_MODE' else
      if self.val = UInt32($884D) then Result := 'TEXTURE_COMPARE_FUNC' else
      if self.val = UInt32($8E42) then Result := 'TEXTURE_SWIZZLE_R' else
      if self.val = UInt32($8E43) then Result := 'TEXTURE_SWIZZLE_G' else
      if self.val = UInt32($8E44) then Result := 'TEXTURE_SWIZZLE_B' else
      if self.val = UInt32($8E45) then Result := 'TEXTURE_SWIZZLE_A' else
      if self.val = UInt32($8E46) then Result := 'TEXTURE_SWIZZLE_RGBA' else
      if self.val = UInt32($8F6A) then Result := 'TEXTURE_UNNORMALIZED_COORDINATES_ARM' else
      if self.val = UInt32($90EA) then Result := 'DEPTH_STENCIL_TEXTURE_MODE' else
      if self.val = UInt32($9580) then Result := 'TEXTURE_TILING' else
      if self.val = UInt32($96A0) then Result := 'TEXTURE_FOVEATED_CUTOFF_DENSITY' else
        Result := $'TextureParameterName[{self.val}]';
    end;
    
  end;
  
  TextureStorageMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_STORAGE_SPARSE_BIT: TextureStorageMask read new TextureStorageMask($0001);
    
    public static function operator+(f1,f2: TextureStorageMask) := new TextureStorageMask(f1.val or f2.val);
    public static function operator or(f1,f2: TextureStorageMask) := f1+f2;
    
    public static procedure operator+=(var f1: TextureStorageMask; f2: TextureStorageMask) := f1 := f1+f2;
    
    public property HAS_FLAG_TEXTURE_STORAGE_SPARSE_BIT: boolean read self.val and $0001 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'TEXTURE_STORAGE_SPARSE_BIT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'TextureStorageMask[{self.val}]';
    end;
    
  end;
  
  TextureSwizzle = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ZERO:  TextureSwizzle read new TextureSwizzle($0000);
    public static property ONE:   TextureSwizzle read new TextureSwizzle($0001);
    public static property RED:   TextureSwizzle read new TextureSwizzle($1903);
    public static property GREEN: TextureSwizzle read new TextureSwizzle($1904);
    public static property BLUE:  TextureSwizzle read new TextureSwizzle($1905);
    public static property ALPHA: TextureSwizzle read new TextureSwizzle($1906);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'ZERO' else
      if self.val = UInt32($0001) then Result := 'ONE' else
      if self.val = UInt32($1903) then Result := 'RED' else
      if self.val = UInt32($1904) then Result := 'GREEN' else
      if self.val = UInt32($1905) then Result := 'BLUE' else
      if self.val = UInt32($1906) then Result := 'ALPHA' else
        Result := $'TextureSwizzle[{self.val}]';
    end;
    
  end;
  
  TextureTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE_1D:                         TextureTarget read new TextureTarget($0DE0);
    public static property TEXTURE_2D:                         TextureTarget read new TextureTarget($0DE1);
    public static property PROXY_TEXTURE_1D:                   TextureTarget read new TextureTarget($8063);
    public static property PROXY_TEXTURE_2D:                   TextureTarget read new TextureTarget($8064);
    public static property TEXTURE_3D:                         TextureTarget read new TextureTarget($806F);
    public static property PROXY_TEXTURE_3D:                   TextureTarget read new TextureTarget($8070);
    public static property DETAIL_TEXTURE_2D:                  TextureTarget read new TextureTarget($8095);
    public static property TEXTURE_4D:                         TextureTarget read new TextureTarget($8134);
    public static property PROXY_TEXTURE_4D:                   TextureTarget read new TextureTarget($8135);
    public static property TEXTURE_RECTANGLE:                  TextureTarget read new TextureTarget($84F5);
    public static property PROXY_TEXTURE_RECTANGLE:            TextureTarget read new TextureTarget($84F7);
    public static property TEXTURE_CUBE_MAP:                   TextureTarget read new TextureTarget($8513);
    public static property TEXTURE_CUBE_MAP_POSITIVE_X:        TextureTarget read new TextureTarget($8515);
    public static property TEXTURE_CUBE_MAP_NEGATIVE_X:        TextureTarget read new TextureTarget($8516);
    public static property TEXTURE_CUBE_MAP_POSITIVE_Y:        TextureTarget read new TextureTarget($8517);
    public static property TEXTURE_CUBE_MAP_NEGATIVE_Y:        TextureTarget read new TextureTarget($8518);
    public static property TEXTURE_CUBE_MAP_POSITIVE_Z:        TextureTarget read new TextureTarget($8519);
    public static property TEXTURE_CUBE_MAP_NEGATIVE_Z:        TextureTarget read new TextureTarget($851A);
    public static property PROXY_TEXTURE_CUBE_MAP:             TextureTarget read new TextureTarget($851B);
    public static property TEXTURE_1D_ARRAY:                   TextureTarget read new TextureTarget($8C18);
    public static property PROXY_TEXTURE_1D_ARRAY:             TextureTarget read new TextureTarget($8C19);
    public static property TEXTURE_2D_ARRAY:                   TextureTarget read new TextureTarget($8C1A);
    public static property PROXY_TEXTURE_2D_ARRAY:             TextureTarget read new TextureTarget($8C1B);
    public static property TEXTURE_BUFFER:                     TextureTarget read new TextureTarget($8C2A);
    public static property RENDERBUFFER:                       TextureTarget read new TextureTarget($8D41);
    public static property TEXTURE_CUBE_MAP_ARRAY:             TextureTarget read new TextureTarget($9009);
    public static property PROXY_TEXTURE_CUBE_MAP_ARRAY:       TextureTarget read new TextureTarget($900B);
    public static property TEXTURE_2D_MULTISAMPLE:             TextureTarget read new TextureTarget($9100);
    public static property PROXY_TEXTURE_2D_MULTISAMPLE:       TextureTarget read new TextureTarget($9101);
    public static property TEXTURE_2D_MULTISAMPLE_ARRAY:       TextureTarget read new TextureTarget($9102);
    public static property PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: TextureTarget read new TextureTarget($9103);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0DE0) then Result := 'TEXTURE_1D' else
      if self.val = UInt32($0DE1) then Result := 'TEXTURE_2D' else
      if self.val = UInt32($8063) then Result := 'PROXY_TEXTURE_1D' else
      if self.val = UInt32($8064) then Result := 'PROXY_TEXTURE_2D' else
      if self.val = UInt32($806F) then Result := 'TEXTURE_3D' else
      if self.val = UInt32($8070) then Result := 'PROXY_TEXTURE_3D' else
      if self.val = UInt32($8095) then Result := 'DETAIL_TEXTURE_2D' else
      if self.val = UInt32($8134) then Result := 'TEXTURE_4D' else
      if self.val = UInt32($8135) then Result := 'PROXY_TEXTURE_4D' else
      if self.val = UInt32($84F5) then Result := 'TEXTURE_RECTANGLE' else
      if self.val = UInt32($84F7) then Result := 'PROXY_TEXTURE_RECTANGLE' else
      if self.val = UInt32($8513) then Result := 'TEXTURE_CUBE_MAP' else
      if self.val = UInt32($8515) then Result := 'TEXTURE_CUBE_MAP_POSITIVE_X' else
      if self.val = UInt32($8516) then Result := 'TEXTURE_CUBE_MAP_NEGATIVE_X' else
      if self.val = UInt32($8517) then Result := 'TEXTURE_CUBE_MAP_POSITIVE_Y' else
      if self.val = UInt32($8518) then Result := 'TEXTURE_CUBE_MAP_NEGATIVE_Y' else
      if self.val = UInt32($8519) then Result := 'TEXTURE_CUBE_MAP_POSITIVE_Z' else
      if self.val = UInt32($851A) then Result := 'TEXTURE_CUBE_MAP_NEGATIVE_Z' else
      if self.val = UInt32($851B) then Result := 'PROXY_TEXTURE_CUBE_MAP' else
      if self.val = UInt32($8C18) then Result := 'TEXTURE_1D_ARRAY' else
      if self.val = UInt32($8C19) then Result := 'PROXY_TEXTURE_1D_ARRAY' else
      if self.val = UInt32($8C1A) then Result := 'TEXTURE_2D_ARRAY' else
      if self.val = UInt32($8C1B) then Result := 'PROXY_TEXTURE_2D_ARRAY' else
      if self.val = UInt32($8C2A) then Result := 'TEXTURE_BUFFER' else
      if self.val = UInt32($8D41) then Result := 'RENDERBUFFER' else
      if self.val = UInt32($9009) then Result := 'TEXTURE_CUBE_MAP_ARRAY' else
      if self.val = UInt32($900B) then Result := 'PROXY_TEXTURE_CUBE_MAP_ARRAY' else
      if self.val = UInt32($9100) then Result := 'TEXTURE_2D_MULTISAMPLE' else
      if self.val = UInt32($9101) then Result := 'PROXY_TEXTURE_2D_MULTISAMPLE' else
      if self.val = UInt32($9102) then Result := 'TEXTURE_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($9103) then Result := 'PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY' else
        Result := $'TextureTarget[{self.val}]';
    end;
    
  end;
  
  TextureUnit = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TEXTURE0:  TextureUnit read new TextureUnit($84C0);
    public static property TEXTURE1:  TextureUnit read new TextureUnit($84C1);
    public static property TEXTURE2:  TextureUnit read new TextureUnit($84C2);
    public static property TEXTURE3:  TextureUnit read new TextureUnit($84C3);
    public static property TEXTURE4:  TextureUnit read new TextureUnit($84C4);
    public static property TEXTURE5:  TextureUnit read new TextureUnit($84C5);
    public static property TEXTURE6:  TextureUnit read new TextureUnit($84C6);
    public static property TEXTURE7:  TextureUnit read new TextureUnit($84C7);
    public static property TEXTURE8:  TextureUnit read new TextureUnit($84C8);
    public static property TEXTURE9:  TextureUnit read new TextureUnit($84C9);
    public static property TEXTURE10: TextureUnit read new TextureUnit($84CA);
    public static property TEXTURE11: TextureUnit read new TextureUnit($84CB);
    public static property TEXTURE12: TextureUnit read new TextureUnit($84CC);
    public static property TEXTURE13: TextureUnit read new TextureUnit($84CD);
    public static property TEXTURE14: TextureUnit read new TextureUnit($84CE);
    public static property TEXTURE15: TextureUnit read new TextureUnit($84CF);
    public static property TEXTURE16: TextureUnit read new TextureUnit($84D0);
    public static property TEXTURE17: TextureUnit read new TextureUnit($84D1);
    public static property TEXTURE18: TextureUnit read new TextureUnit($84D2);
    public static property TEXTURE19: TextureUnit read new TextureUnit($84D3);
    public static property TEXTURE20: TextureUnit read new TextureUnit($84D4);
    public static property TEXTURE21: TextureUnit read new TextureUnit($84D5);
    public static property TEXTURE22: TextureUnit read new TextureUnit($84D6);
    public static property TEXTURE23: TextureUnit read new TextureUnit($84D7);
    public static property TEXTURE24: TextureUnit read new TextureUnit($84D8);
    public static property TEXTURE25: TextureUnit read new TextureUnit($84D9);
    public static property TEXTURE26: TextureUnit read new TextureUnit($84DA);
    public static property TEXTURE27: TextureUnit read new TextureUnit($84DB);
    public static property TEXTURE28: TextureUnit read new TextureUnit($84DC);
    public static property TEXTURE29: TextureUnit read new TextureUnit($84DD);
    public static property TEXTURE30: TextureUnit read new TextureUnit($84DE);
    public static property TEXTURE31: TextureUnit read new TextureUnit($84DF);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($84C0) then Result := 'TEXTURE0' else
      if self.val = UInt32($84C1) then Result := 'TEXTURE1' else
      if self.val = UInt32($84C2) then Result := 'TEXTURE2' else
      if self.val = UInt32($84C3) then Result := 'TEXTURE3' else
      if self.val = UInt32($84C4) then Result := 'TEXTURE4' else
      if self.val = UInt32($84C5) then Result := 'TEXTURE5' else
      if self.val = UInt32($84C6) then Result := 'TEXTURE6' else
      if self.val = UInt32($84C7) then Result := 'TEXTURE7' else
      if self.val = UInt32($84C8) then Result := 'TEXTURE8' else
      if self.val = UInt32($84C9) then Result := 'TEXTURE9' else
      if self.val = UInt32($84CA) then Result := 'TEXTURE10' else
      if self.val = UInt32($84CB) then Result := 'TEXTURE11' else
      if self.val = UInt32($84CC) then Result := 'TEXTURE12' else
      if self.val = UInt32($84CD) then Result := 'TEXTURE13' else
      if self.val = UInt32($84CE) then Result := 'TEXTURE14' else
      if self.val = UInt32($84CF) then Result := 'TEXTURE15' else
      if self.val = UInt32($84D0) then Result := 'TEXTURE16' else
      if self.val = UInt32($84D1) then Result := 'TEXTURE17' else
      if self.val = UInt32($84D2) then Result := 'TEXTURE18' else
      if self.val = UInt32($84D3) then Result := 'TEXTURE19' else
      if self.val = UInt32($84D4) then Result := 'TEXTURE20' else
      if self.val = UInt32($84D5) then Result := 'TEXTURE21' else
      if self.val = UInt32($84D6) then Result := 'TEXTURE22' else
      if self.val = UInt32($84D7) then Result := 'TEXTURE23' else
      if self.val = UInt32($84D8) then Result := 'TEXTURE24' else
      if self.val = UInt32($84D9) then Result := 'TEXTURE25' else
      if self.val = UInt32($84DA) then Result := 'TEXTURE26' else
      if self.val = UInt32($84DB) then Result := 'TEXTURE27' else
      if self.val = UInt32($84DC) then Result := 'TEXTURE28' else
      if self.val = UInt32($84DD) then Result := 'TEXTURE29' else
      if self.val = UInt32($84DE) then Result := 'TEXTURE30' else
      if self.val = UInt32($84DF) then Result := 'TEXTURE31' else
        Result := $'TextureUnit[{self.val}]';
    end;
    
  end;
  
  TextureWrapMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LINEAR_MIPMAP_LINEAR: TextureWrapMode read new TextureWrapMode($2703);
    public static property CLAMP:                TextureWrapMode read new TextureWrapMode($2900);
    public static property &REPEAT:              TextureWrapMode read new TextureWrapMode($2901);
    public static property CLAMP_TO_BORDER:      TextureWrapMode read new TextureWrapMode($812D);
    public static property CLAMP_TO_EDGE:        TextureWrapMode read new TextureWrapMode($812F);
    public static property MIRRORED_REPEAT:      TextureWrapMode read new TextureWrapMode($8370);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2703) then Result := 'LINEAR_MIPMAP_LINEAR' else
      if self.val = UInt32($2900) then Result := 'CLAMP' else
      if self.val = UInt32($2901) then Result := 'REPEAT' else
      if self.val = UInt32($812D) then Result := 'CLAMP_TO_BORDER' else
      if self.val = UInt32($812F) then Result := 'CLAMP_TO_EDGE' else
      if self.val = UInt32($8370) then Result := 'MIRRORED_REPEAT' else
        Result := $'TextureWrapMode[{self.val}]';
    end;
    
  end;
  
  TransformFeedbackBufferMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property INTERLEAVED_ATTRIBS: TransformFeedbackBufferMode read new TransformFeedbackBufferMode($8C8C);
    public static property SEPARATE_ATTRIBS:    TransformFeedbackBufferMode read new TransformFeedbackBufferMode($8C8D);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8C8C) then Result := 'INTERLEAVED_ATTRIBS' else
      if self.val = UInt32($8C8D) then Result := 'SEPARATE_ATTRIBS' else
        Result := $'TransformFeedbackBufferMode[{self.val}]';
    end;
    
  end;
  
  TransformFeedbackPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property TRANSFORM_FEEDBACK_BUFFER_START:   TransformFeedbackPName read new TransformFeedbackPName($8C84);
    public static property TRANSFORM_FEEDBACK_BUFFER_SIZE:    TransformFeedbackPName read new TransformFeedbackPName($8C85);
    public static property TRANSFORM_FEEDBACK_BUFFER_BINDING: TransformFeedbackPName read new TransformFeedbackPName($8C8F);
    public static property TRANSFORM_FEEDBACK_PAUSED:         TransformFeedbackPName read new TransformFeedbackPName($8E23);
    public static property TRANSFORM_FEEDBACK_ACTIVE:         TransformFeedbackPName read new TransformFeedbackPName($8E24);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8C84) then Result := 'TRANSFORM_FEEDBACK_BUFFER_START' else
      if self.val = UInt32($8C85) then Result := 'TRANSFORM_FEEDBACK_BUFFER_SIZE' else
      if self.val = UInt32($8C8F) then Result := 'TRANSFORM_FEEDBACK_BUFFER_BINDING' else
      if self.val = UInt32($8E23) then Result := 'TRANSFORM_FEEDBACK_PAUSED' else
      if self.val = UInt32($8E24) then Result := 'TRANSFORM_FEEDBACK_ACTIVE' else
        Result := $'TransformFeedbackPName[{self.val}]';
    end;
    
  end;
  
  TransformFeedbackToken = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property NEXT_BUFFER:      TransformFeedbackToken read new TransformFeedbackToken(-2);
    public static property SKIP_COMPONENTS4: TransformFeedbackToken read new TransformFeedbackToken(-3);
    public static property SKIP_COMPONENTS3: TransformFeedbackToken read new TransformFeedbackToken(-4);
    public static property SKIP_COMPONENTS2: TransformFeedbackToken read new TransformFeedbackToken(-5);
    public static property SKIP_COMPONENTS1: TransformFeedbackToken read new TransformFeedbackToken(-6);
    
    public function ToString: string; override;
    begin
      if self.val = Int32(-2) then Result := 'NEXT_BUFFER' else
      if self.val = Int32(-3) then Result := 'SKIP_COMPONENTS4' else
      if self.val = Int32(-4) then Result := 'SKIP_COMPONENTS3' else
      if self.val = Int32(-5) then Result := 'SKIP_COMPONENTS2' else
      if self.val = Int32(-6) then Result := 'SKIP_COMPONENTS1' else
        Result := $'TransformFeedbackToken[{self.val}]';
    end;
    
  end;
  
  TriangleFace = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRONT:          TriangleFace read new TriangleFace($0404);
    public static property BACK:           TriangleFace read new TriangleFace($0405);
    public static property FRONT_AND_BACK: TriangleFace read new TriangleFace($0408);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0404) then Result := 'FRONT' else
      if self.val = UInt32($0405) then Result := 'BACK' else
      if self.val = UInt32($0408) then Result := 'FRONT_AND_BACK' else
        Result := $'TriangleFace[{self.val}]';
    end;
    
  end;
  
  TriangleList = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RESTART:        TriangleList read new TriangleList($0001);
    public static property REPLACE_MIDDLE: TriangleList read new TriangleList($0002);
    public static property REPLACE_OLDEST: TriangleList read new TriangleList($0003);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0001) then Result := 'RESTART' else
      if self.val = UInt32($0002) then Result := 'REPLACE_MIDDLE' else
      if self.val = UInt32($0003) then Result := 'REPLACE_OLDEST' else
        Result := $'TriangleList[{self.val}]';
    end;
    
  end;
  
  UniformBlockPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER:    UniformBlockPName read new UniformBlockPName($84F0);
    public static property UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER: UniformBlockPName read new UniformBlockPName($84F1);
    public static property UNIFORM_BLOCK_BINDING:                              UniformBlockPName read new UniformBlockPName($8A3F);
    public static property UNIFORM_BLOCK_DATA_SIZE:                            UniformBlockPName read new UniformBlockPName($8A40);
    public static property UNIFORM_BLOCK_NAME_LENGTH:                          UniformBlockPName read new UniformBlockPName($8A41);
    public static property UNIFORM_BLOCK_ACTIVE_UNIFORMS:                      UniformBlockPName read new UniformBlockPName($8A42);
    public static property UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES:               UniformBlockPName read new UniformBlockPName($8A43);
    public static property UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER:          UniformBlockPName read new UniformBlockPName($8A44);
    public static property UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER:        UniformBlockPName read new UniformBlockPName($8A45);
    public static property UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER:        UniformBlockPName read new UniformBlockPName($8A46);
    public static property UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER:         UniformBlockPName read new UniformBlockPName($90EC);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($84F0) then Result := 'UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER' else
      if self.val = UInt32($84F1) then Result := 'UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER' else
      if self.val = UInt32($8A3F) then Result := 'UNIFORM_BLOCK_BINDING' else
      if self.val = UInt32($8A40) then Result := 'UNIFORM_BLOCK_DATA_SIZE' else
      if self.val = UInt32($8A41) then Result := 'UNIFORM_BLOCK_NAME_LENGTH' else
      if self.val = UInt32($8A42) then Result := 'UNIFORM_BLOCK_ACTIVE_UNIFORMS' else
      if self.val = UInt32($8A43) then Result := 'UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES' else
      if self.val = UInt32($8A44) then Result := 'UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER' else
      if self.val = UInt32($8A45) then Result := 'UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER' else
      if self.val = UInt32($8A46) then Result := 'UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER' else
      if self.val = UInt32($90EC) then Result := 'UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER' else
        Result := $'UniformBlockPName[{self.val}]';
    end;
    
  end;
  
  UniformPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNIFORM_TYPE:                        UniformPName read new UniformPName($8A37);
    public static property UNIFORM_SIZE:                        UniformPName read new UniformPName($8A38);
    public static property UNIFORM_NAME_LENGTH:                 UniformPName read new UniformPName($8A39);
    public static property UNIFORM_BLOCK_INDEX:                 UniformPName read new UniformPName($8A3A);
    public static property UNIFORM_OFFSET:                      UniformPName read new UniformPName($8A3B);
    public static property UNIFORM_ARRAY_STRIDE:                UniformPName read new UniformPName($8A3C);
    public static property UNIFORM_MATRIX_STRIDE:               UniformPName read new UniformPName($8A3D);
    public static property UNIFORM_IS_ROW_MAJOR:                UniformPName read new UniformPName($8A3E);
    public static property UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX: UniformPName read new UniformPName($92DA);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8A37) then Result := 'UNIFORM_TYPE' else
      if self.val = UInt32($8A38) then Result := 'UNIFORM_SIZE' else
      if self.val = UInt32($8A39) then Result := 'UNIFORM_NAME_LENGTH' else
      if self.val = UInt32($8A3A) then Result := 'UNIFORM_BLOCK_INDEX' else
      if self.val = UInt32($8A3B) then Result := 'UNIFORM_OFFSET' else
      if self.val = UInt32($8A3C) then Result := 'UNIFORM_ARRAY_STRIDE' else
      if self.val = UInt32($8A3D) then Result := 'UNIFORM_MATRIX_STRIDE' else
      if self.val = UInt32($8A3E) then Result := 'UNIFORM_IS_ROW_MAJOR' else
      if self.val = UInt32($92DA) then Result := 'UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX' else
        Result := $'UniformPName[{self.val}]';
    end;
    
  end;
  
  UniformType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property INT:                                       UniformType read new UniformType($1404);
    public static property UNSIGNED_INT:                              UniformType read new UniformType($1405);
    public static property FLOAT:                                     UniformType read new UniformType($1406);
    public static property DOUBLE:                                    UniformType read new UniformType($140A);
    public static property FLOAT_VEC2:                                UniformType read new UniformType($8B50);
    public static property FLOAT_VEC3:                                UniformType read new UniformType($8B51);
    public static property FLOAT_VEC4:                                UniformType read new UniformType($8B52);
    public static property INT_VEC2:                                  UniformType read new UniformType($8B53);
    public static property INT_VEC3:                                  UniformType read new UniformType($8B54);
    public static property INT_VEC4:                                  UniformType read new UniformType($8B55);
    public static property BOOL:                                      UniformType read new UniformType($8B56);
    public static property BOOL_VEC2:                                 UniformType read new UniformType($8B57);
    public static property BOOL_VEC3:                                 UniformType read new UniformType($8B58);
    public static property BOOL_VEC4:                                 UniformType read new UniformType($8B59);
    public static property FLOAT_MAT2:                                UniformType read new UniformType($8B5A);
    public static property FLOAT_MAT3:                                UniformType read new UniformType($8B5B);
    public static property FLOAT_MAT4:                                UniformType read new UniformType($8B5C);
    public static property SAMPLER_1D:                                UniformType read new UniformType($8B5D);
    public static property SAMPLER_2D:                                UniformType read new UniformType($8B5E);
    public static property SAMPLER_3D:                                UniformType read new UniformType($8B5F);
    public static property SAMPLER_CUBE:                              UniformType read new UniformType($8B60);
    public static property SAMPLER_1D_SHADOW:                         UniformType read new UniformType($8B61);
    public static property SAMPLER_2D_SHADOW:                         UniformType read new UniformType($8B62);
    public static property SAMPLER_2D_RECT:                           UniformType read new UniformType($8B63);
    public static property SAMPLER_2D_RECT_SHADOW:                    UniformType read new UniformType($8B64);
    public static property FLOAT_MAT2x3:                              UniformType read new UniformType($8B65);
    public static property FLOAT_MAT2x4:                              UniformType read new UniformType($8B66);
    public static property FLOAT_MAT3x2:                              UniformType read new UniformType($8B67);
    public static property FLOAT_MAT3x4:                              UniformType read new UniformType($8B68);
    public static property FLOAT_MAT4x2:                              UniformType read new UniformType($8B69);
    public static property FLOAT_MAT4x3:                              UniformType read new UniformType($8B6A);
    public static property SAMPLER_1D_ARRAY:                          UniformType read new UniformType($8DC0);
    public static property SAMPLER_2D_ARRAY:                          UniformType read new UniformType($8DC1);
    public static property SAMPLER_BUFFER:                            UniformType read new UniformType($8DC2);
    public static property SAMPLER_1D_ARRAY_SHADOW:                   UniformType read new UniformType($8DC3);
    public static property SAMPLER_2D_ARRAY_SHADOW:                   UniformType read new UniformType($8DC4);
    public static property SAMPLER_CUBE_SHADOW:                       UniformType read new UniformType($8DC5);
    public static property UNSIGNED_INT_VEC2:                         UniformType read new UniformType($8DC6);
    public static property UNSIGNED_INT_VEC3:                         UniformType read new UniformType($8DC7);
    public static property UNSIGNED_INT_VEC4:                         UniformType read new UniformType($8DC8);
    public static property INT_SAMPLER_1D:                            UniformType read new UniformType($8DC9);
    public static property INT_SAMPLER_2D:                            UniformType read new UniformType($8DCA);
    public static property INT_SAMPLER_3D:                            UniformType read new UniformType($8DCB);
    public static property INT_SAMPLER_CUBE:                          UniformType read new UniformType($8DCC);
    public static property INT_SAMPLER_2D_RECT:                       UniformType read new UniformType($8DCD);
    public static property INT_SAMPLER_1D_ARRAY:                      UniformType read new UniformType($8DCE);
    public static property INT_SAMPLER_2D_ARRAY:                      UniformType read new UniformType($8DCF);
    public static property INT_SAMPLER_BUFFER:                        UniformType read new UniformType($8DD0);
    public static property UNSIGNED_INT_SAMPLER_1D:                   UniformType read new UniformType($8DD1);
    public static property UNSIGNED_INT_SAMPLER_2D:                   UniformType read new UniformType($8DD2);
    public static property UNSIGNED_INT_SAMPLER_3D:                   UniformType read new UniformType($8DD3);
    public static property UNSIGNED_INT_SAMPLER_CUBE:                 UniformType read new UniformType($8DD4);
    public static property UNSIGNED_INT_SAMPLER_2D_RECT:              UniformType read new UniformType($8DD5);
    public static property UNSIGNED_INT_SAMPLER_1D_ARRAY:             UniformType read new UniformType($8DD6);
    public static property UNSIGNED_INT_SAMPLER_2D_ARRAY:             UniformType read new UniformType($8DD7);
    public static property UNSIGNED_INT_SAMPLER_BUFFER:               UniformType read new UniformType($8DD8);
    public static property DOUBLE_MAT2:                               UniformType read new UniformType($8F46);
    public static property DOUBLE_MAT3:                               UniformType read new UniformType($8F47);
    public static property DOUBLE_MAT4:                               UniformType read new UniformType($8F48);
    public static property DOUBLE_MAT2x3:                             UniformType read new UniformType($8F49);
    public static property DOUBLE_MAT2x4:                             UniformType read new UniformType($8F4A);
    public static property DOUBLE_MAT3x2:                             UniformType read new UniformType($8F4B);
    public static property DOUBLE_MAT3x4:                             UniformType read new UniformType($8F4C);
    public static property DOUBLE_MAT4x2:                             UniformType read new UniformType($8F4D);
    public static property DOUBLE_MAT4x3:                             UniformType read new UniformType($8F4E);
    public static property DOUBLE_VEC2:                               UniformType read new UniformType($8FFC);
    public static property DOUBLE_VEC3:                               UniformType read new UniformType($8FFD);
    public static property DOUBLE_VEC4:                               UniformType read new UniformType($8FFE);
    public static property SAMPLER_CUBE_MAP_ARRAY:                    UniformType read new UniformType($900C);
    public static property SAMPLER_CUBE_MAP_ARRAY_SHADOW:             UniformType read new UniformType($900D);
    public static property INT_SAMPLER_CUBE_MAP_ARRAY:                UniformType read new UniformType($900E);
    public static property UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY:       UniformType read new UniformType($900F);
    public static property SAMPLER_2D_MULTISAMPLE:                    UniformType read new UniformType($9108);
    public static property INT_SAMPLER_2D_MULTISAMPLE:                UniformType read new UniformType($9109);
    public static property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE:       UniformType read new UniformType($910A);
    public static property SAMPLER_2D_MULTISAMPLE_ARRAY:              UniformType read new UniformType($910B);
    public static property INT_SAMPLER_2D_MULTISAMPLE_ARRAY:          UniformType read new UniformType($910C);
    public static property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: UniformType read new UniformType($910D);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
      if self.val = UInt32($8B50) then Result := 'FLOAT_VEC2' else
      if self.val = UInt32($8B51) then Result := 'FLOAT_VEC3' else
      if self.val = UInt32($8B52) then Result := 'FLOAT_VEC4' else
      if self.val = UInt32($8B53) then Result := 'INT_VEC2' else
      if self.val = UInt32($8B54) then Result := 'INT_VEC3' else
      if self.val = UInt32($8B55) then Result := 'INT_VEC4' else
      if self.val = UInt32($8B56) then Result := 'BOOL' else
      if self.val = UInt32($8B57) then Result := 'BOOL_VEC2' else
      if self.val = UInt32($8B58) then Result := 'BOOL_VEC3' else
      if self.val = UInt32($8B59) then Result := 'BOOL_VEC4' else
      if self.val = UInt32($8B5A) then Result := 'FLOAT_MAT2' else
      if self.val = UInt32($8B5B) then Result := 'FLOAT_MAT3' else
      if self.val = UInt32($8B5C) then Result := 'FLOAT_MAT4' else
      if self.val = UInt32($8B5D) then Result := 'SAMPLER_1D' else
      if self.val = UInt32($8B5E) then Result := 'SAMPLER_2D' else
      if self.val = UInt32($8B5F) then Result := 'SAMPLER_3D' else
      if self.val = UInt32($8B60) then Result := 'SAMPLER_CUBE' else
      if self.val = UInt32($8B61) then Result := 'SAMPLER_1D_SHADOW' else
      if self.val = UInt32($8B62) then Result := 'SAMPLER_2D_SHADOW' else
      if self.val = UInt32($8B63) then Result := 'SAMPLER_2D_RECT' else
      if self.val = UInt32($8B64) then Result := 'SAMPLER_2D_RECT_SHADOW' else
      if self.val = UInt32($8B65) then Result := 'FLOAT_MAT2x3' else
      if self.val = UInt32($8B66) then Result := 'FLOAT_MAT2x4' else
      if self.val = UInt32($8B67) then Result := 'FLOAT_MAT3x2' else
      if self.val = UInt32($8B68) then Result := 'FLOAT_MAT3x4' else
      if self.val = UInt32($8B69) then Result := 'FLOAT_MAT4x2' else
      if self.val = UInt32($8B6A) then Result := 'FLOAT_MAT4x3' else
      if self.val = UInt32($8DC0) then Result := 'SAMPLER_1D_ARRAY' else
      if self.val = UInt32($8DC1) then Result := 'SAMPLER_2D_ARRAY' else
      if self.val = UInt32($8DC2) then Result := 'SAMPLER_BUFFER' else
      if self.val = UInt32($8DC3) then Result := 'SAMPLER_1D_ARRAY_SHADOW' else
      if self.val = UInt32($8DC4) then Result := 'SAMPLER_2D_ARRAY_SHADOW' else
      if self.val = UInt32($8DC5) then Result := 'SAMPLER_CUBE_SHADOW' else
      if self.val = UInt32($8DC6) then Result := 'UNSIGNED_INT_VEC2' else
      if self.val = UInt32($8DC7) then Result := 'UNSIGNED_INT_VEC3' else
      if self.val = UInt32($8DC8) then Result := 'UNSIGNED_INT_VEC4' else
      if self.val = UInt32($8DC9) then Result := 'INT_SAMPLER_1D' else
      if self.val = UInt32($8DCA) then Result := 'INT_SAMPLER_2D' else
      if self.val = UInt32($8DCB) then Result := 'INT_SAMPLER_3D' else
      if self.val = UInt32($8DCC) then Result := 'INT_SAMPLER_CUBE' else
      if self.val = UInt32($8DCD) then Result := 'INT_SAMPLER_2D_RECT' else
      if self.val = UInt32($8DCE) then Result := 'INT_SAMPLER_1D_ARRAY' else
      if self.val = UInt32($8DCF) then Result := 'INT_SAMPLER_2D_ARRAY' else
      if self.val = UInt32($8DD0) then Result := 'INT_SAMPLER_BUFFER' else
      if self.val = UInt32($8DD1) then Result := 'UNSIGNED_INT_SAMPLER_1D' else
      if self.val = UInt32($8DD2) then Result := 'UNSIGNED_INT_SAMPLER_2D' else
      if self.val = UInt32($8DD3) then Result := 'UNSIGNED_INT_SAMPLER_3D' else
      if self.val = UInt32($8DD4) then Result := 'UNSIGNED_INT_SAMPLER_CUBE' else
      if self.val = UInt32($8DD5) then Result := 'UNSIGNED_INT_SAMPLER_2D_RECT' else
      if self.val = UInt32($8DD6) then Result := 'UNSIGNED_INT_SAMPLER_1D_ARRAY' else
      if self.val = UInt32($8DD7) then Result := 'UNSIGNED_INT_SAMPLER_2D_ARRAY' else
      if self.val = UInt32($8DD8) then Result := 'UNSIGNED_INT_SAMPLER_BUFFER' else
      if self.val = UInt32($8F46) then Result := 'DOUBLE_MAT2' else
      if self.val = UInt32($8F47) then Result := 'DOUBLE_MAT3' else
      if self.val = UInt32($8F48) then Result := 'DOUBLE_MAT4' else
      if self.val = UInt32($8F49) then Result := 'DOUBLE_MAT2x3' else
      if self.val = UInt32($8F4A) then Result := 'DOUBLE_MAT2x4' else
      if self.val = UInt32($8F4B) then Result := 'DOUBLE_MAT3x2' else
      if self.val = UInt32($8F4C) then Result := 'DOUBLE_MAT3x4' else
      if self.val = UInt32($8F4D) then Result := 'DOUBLE_MAT4x2' else
      if self.val = UInt32($8F4E) then Result := 'DOUBLE_MAT4x3' else
      if self.val = UInt32($8FFC) then Result := 'DOUBLE_VEC2' else
      if self.val = UInt32($8FFD) then Result := 'DOUBLE_VEC3' else
      if self.val = UInt32($8FFE) then Result := 'DOUBLE_VEC4' else
      if self.val = UInt32($900C) then Result := 'SAMPLER_CUBE_MAP_ARRAY' else
      if self.val = UInt32($900D) then Result := 'SAMPLER_CUBE_MAP_ARRAY_SHADOW' else
      if self.val = UInt32($900E) then Result := 'INT_SAMPLER_CUBE_MAP_ARRAY' else
      if self.val = UInt32($900F) then Result := 'UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY' else
      if self.val = UInt32($9108) then Result := 'SAMPLER_2D_MULTISAMPLE' else
      if self.val = UInt32($9109) then Result := 'INT_SAMPLER_2D_MULTISAMPLE' else
      if self.val = UInt32($910A) then Result := 'UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE' else
      if self.val = UInt32($910B) then Result := 'SAMPLER_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($910C) then Result := 'INT_SAMPLER_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($910D) then Result := 'UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY' else
        Result := $'UniformType[{self.val}]';
    end;
    
  end;
  
  UseProgramStageMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_SHADER_BIT:          UseProgramStageMask read new UseProgramStageMask($0001);
    public static property FRAGMENT_SHADER_BIT:        UseProgramStageMask read new UseProgramStageMask($0002);
    public static property GEOMETRY_SHADER_BIT:        UseProgramStageMask read new UseProgramStageMask($0004);
    public static property TESS_CONTROL_SHADER_BIT:    UseProgramStageMask read new UseProgramStageMask($0008);
    public static property TESS_EVALUATION_SHADER_BIT: UseProgramStageMask read new UseProgramStageMask($0010);
    public static property COMPUTE_SHADER_BIT:         UseProgramStageMask read new UseProgramStageMask($0020);
    public static property MESH_SHADER_BIT:            UseProgramStageMask read new UseProgramStageMask($0040);
    public static property TASK_SHADER_BIT:            UseProgramStageMask read new UseProgramStageMask($0080);
    public static property ALL_SHADER_BITS:            UseProgramStageMask read new UseProgramStageMask($FFFFFFFF);
    
    public static function operator+(f1,f2: UseProgramStageMask) := new UseProgramStageMask(f1.val or f2.val);
    public static function operator or(f1,f2: UseProgramStageMask) := f1+f2;
    
    public static procedure operator+=(var f1: UseProgramStageMask; f2: UseProgramStageMask) := f1 := f1+f2;
    
    public property HAS_FLAG_VERTEX_SHADER_BIT:          boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_FRAGMENT_SHADER_BIT:        boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_GEOMETRY_SHADER_BIT:        boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_TESS_CONTROL_SHADER_BIT:    boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_TESS_EVALUATION_SHADER_BIT: boolean read self.val and $0010 <> 0;
    public property HAS_FLAG_COMPUTE_SHADER_BIT:         boolean read self.val and $0020 <> 0;
    public property HAS_FLAG_MESH_SHADER_BIT:            boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_TASK_SHADER_BIT:            boolean read self.val and $0080 <> 0;
    public property HAS_FLAG_ALL_SHADER_BITS:            boolean read self.val and $FFFFFFFF <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'VERTEX_SHADER_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'FRAGMENT_SHADER_BIT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'GEOMETRY_SHADER_BIT+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'TESS_CONTROL_SHADER_BIT+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'TESS_EVALUATION_SHADER_BIT+';
      if self.val and UInt32($0020) = UInt32($0020) then res += 'COMPUTE_SHADER_BIT+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'MESH_SHADER_BIT+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'TASK_SHADER_BIT+';
      if self.val and UInt32($FFFFFFFF) = UInt32($FFFFFFFF) then res += 'ALL_SHADER_BITS+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'UseProgramStageMask[{self.val}]';
    end;
    
  end;
  
  VariantCap = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VARIANT_ARRAY: VariantCap read new VariantCap($87E8);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($87E8) then Result := 'VARIANT_ARRAY' else
        Result := $'VariantCap[{self.val}]';
    end;
    
  end;
  
  VertexArrayParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property STORAGE_CLIENT: VertexArrayParameterName read new VertexArrayParameterName($85B4);
    public static property STORAGE_CACHED: VertexArrayParameterName read new VertexArrayParameterName($85BE);
    public static property STORAGE_SHARED: VertexArrayParameterName read new VertexArrayParameterName($85BF);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($85B4) then Result := 'STORAGE_CLIENT' else
      if self.val = UInt32($85BE) then Result := 'STORAGE_CACHED' else
      if self.val = UInt32($85BF) then Result := 'STORAGE_SHARED' else
        Result := $'VertexArrayParameterName[{self.val}]';
    end;
    
  end;
  
  VertexArrayPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_ATTRIB_RELATIVE_OFFSET:  VertexArrayPName read new VertexArrayPName($82D5);
    public static property VERTEX_ATTRIB_ARRAY_ENABLED:    VertexArrayPName read new VertexArrayPName($8622);
    public static property VERTEX_ATTRIB_ARRAY_SIZE:       VertexArrayPName read new VertexArrayPName($8623);
    public static property VERTEX_ATTRIB_ARRAY_STRIDE:     VertexArrayPName read new VertexArrayPName($8624);
    public static property VERTEX_ATTRIB_ARRAY_TYPE:       VertexArrayPName read new VertexArrayPName($8625);
    public static property VERTEX_ATTRIB_ARRAY_LONG:       VertexArrayPName read new VertexArrayPName($874E);
    public static property VERTEX_ATTRIB_ARRAY_NORMALIZED: VertexArrayPName read new VertexArrayPName($886A);
    public static property VERTEX_ATTRIB_ARRAY_INTEGER:    VertexArrayPName read new VertexArrayPName($88FD);
    public static property VERTEX_ATTRIB_ARRAY_DIVISOR:    VertexArrayPName read new VertexArrayPName($88FE);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($82D5) then Result := 'VERTEX_ATTRIB_RELATIVE_OFFSET' else
      if self.val = UInt32($8622) then Result := 'VERTEX_ATTRIB_ARRAY_ENABLED' else
      if self.val = UInt32($8623) then Result := 'VERTEX_ATTRIB_ARRAY_SIZE' else
      if self.val = UInt32($8624) then Result := 'VERTEX_ATTRIB_ARRAY_STRIDE' else
      if self.val = UInt32($8625) then Result := 'VERTEX_ATTRIB_ARRAY_TYPE' else
      if self.val = UInt32($874E) then Result := 'VERTEX_ATTRIB_ARRAY_LONG' else
      if self.val = UInt32($886A) then Result := 'VERTEX_ATTRIB_ARRAY_NORMALIZED' else
      if self.val = UInt32($88FD) then Result := 'VERTEX_ATTRIB_ARRAY_INTEGER' else
      if self.val = UInt32($88FE) then Result := 'VERTEX_ATTRIB_ARRAY_DIVISOR' else
        Result := $'VertexArrayPName[{self.val}]';
    end;
    
  end;
  
  VertexAttribEnum = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_ATTRIB_ARRAY_ENABLED:        VertexAttribEnum read new VertexAttribEnum($8622);
    public static property VERTEX_ATTRIB_ARRAY_SIZE:           VertexAttribEnum read new VertexAttribEnum($8623);
    public static property VERTEX_ATTRIB_ARRAY_STRIDE:         VertexAttribEnum read new VertexAttribEnum($8624);
    public static property VERTEX_ATTRIB_ARRAY_TYPE:           VertexAttribEnum read new VertexAttribEnum($8625);
    public static property CURRENT_VERTEX_ATTRIB:              VertexAttribEnum read new VertexAttribEnum($8626);
    public static property VERTEX_ATTRIB_ARRAY_NORMALIZED:     VertexAttribEnum read new VertexAttribEnum($886A);
    public static property VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: VertexAttribEnum read new VertexAttribEnum($889F);
    public static property VERTEX_ATTRIB_ARRAY_INTEGER:        VertexAttribEnum read new VertexAttribEnum($88FD);
    public static property VERTEX_ATTRIB_ARRAY_DIVISOR:        VertexAttribEnum read new VertexAttribEnum($88FE);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8622) then Result := 'VERTEX_ATTRIB_ARRAY_ENABLED' else
      if self.val = UInt32($8623) then Result := 'VERTEX_ATTRIB_ARRAY_SIZE' else
      if self.val = UInt32($8624) then Result := 'VERTEX_ATTRIB_ARRAY_STRIDE' else
      if self.val = UInt32($8625) then Result := 'VERTEX_ATTRIB_ARRAY_TYPE' else
      if self.val = UInt32($8626) then Result := 'CURRENT_VERTEX_ATTRIB' else
      if self.val = UInt32($886A) then Result := 'VERTEX_ATTRIB_ARRAY_NORMALIZED' else
      if self.val = UInt32($889F) then Result := 'VERTEX_ATTRIB_ARRAY_BUFFER_BINDING' else
      if self.val = UInt32($88FD) then Result := 'VERTEX_ATTRIB_ARRAY_INTEGER' else
      if self.val = UInt32($88FE) then Result := 'VERTEX_ATTRIB_ARRAY_DIVISOR' else
        Result := $'VertexAttribEnum[{self.val}]';
    end;
    
  end;
  
  VertexAttribEnumNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROGRAM_PARAMETER: VertexAttribEnumNV read new VertexAttribEnumNV($8644);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8644) then Result := 'PROGRAM_PARAMETER' else
        Result := $'VertexAttribEnumNV[{self.val}]';
    end;
    
  end;
  
  VertexAttribIType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:           VertexAttribIType read new VertexAttribIType($1400);
    public static property UNSIGNED_BYTE:  VertexAttribIType read new VertexAttribIType($1401);
    public static property SHORT:          VertexAttribIType read new VertexAttribIType($1402);
    public static property UNSIGNED_SHORT: VertexAttribIType read new VertexAttribIType($1403);
    public static property INT:            VertexAttribIType read new VertexAttribIType($1404);
    public static property UNSIGNED_INT:   VertexAttribIType read new VertexAttribIType($1405);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
        Result := $'VertexAttribIType[{self.val}]';
    end;
    
  end;
  
  VertexAttribLType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DOUBLE: VertexAttribLType read new VertexAttribLType($140A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := $'VertexAttribLType[{self.val}]';
    end;
    
  end;
  
  VertexAttribPointerProperty = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_ATTRIB_ARRAY_POINTER: VertexAttribPointerProperty read new VertexAttribPointerProperty($8645);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8645) then Result := 'VERTEX_ATTRIB_ARRAY_POINTER' else
        Result := $'VertexAttribPointerProperty[{self.val}]';
    end;
    
  end;
  
  VertexAttribPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:                         VertexAttribPointerType read new VertexAttribPointerType($1400);
    public static property UNSIGNED_BYTE:                VertexAttribPointerType read new VertexAttribPointerType($1401);
    public static property SHORT:                        VertexAttribPointerType read new VertexAttribPointerType($1402);
    public static property UNSIGNED_SHORT:               VertexAttribPointerType read new VertexAttribPointerType($1403);
    public static property INT:                          VertexAttribPointerType read new VertexAttribPointerType($1404);
    public static property UNSIGNED_INT:                 VertexAttribPointerType read new VertexAttribPointerType($1405);
    public static property FLOAT:                        VertexAttribPointerType read new VertexAttribPointerType($1406);
    public static property DOUBLE:                       VertexAttribPointerType read new VertexAttribPointerType($140A);
    public static property HALF_FLOAT:                   VertexAttribPointerType read new VertexAttribPointerType($140B);
    public static property FIXED:                        VertexAttribPointerType read new VertexAttribPointerType($140C);
    public static property INT64:                        VertexAttribPointerType read new VertexAttribPointerType($140E);
    public static property UNSIGNED_INT64:               VertexAttribPointerType read new VertexAttribPointerType($140F);
    public static property UNSIGNED_INT_2_10_10_10_REV:  VertexAttribPointerType read new VertexAttribPointerType($8368);
    public static property UNSIGNED_INT_10F_11F_11F_REV: VertexAttribPointerType read new VertexAttribPointerType($8C3B);
    public static property INT_2_10_10_10_REV:           VertexAttribPointerType read new VertexAttribPointerType($8D9F);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
      if self.val = UInt32($140B) then Result := 'HALF_FLOAT' else
      if self.val = UInt32($140C) then Result := 'FIXED' else
      if self.val = UInt32($140E) then Result := 'INT64' else
      if self.val = UInt32($140F) then Result := 'UNSIGNED_INT64' else
      if self.val = UInt32($8368) then Result := 'UNSIGNED_INT_2_10_10_10_REV' else
      if self.val = UInt32($8C3B) then Result := 'UNSIGNED_INT_10F_11F_11F_REV' else
      if self.val = UInt32($8D9F) then Result := 'INT_2_10_10_10_REV' else
        Result := $'VertexAttribPointerType[{self.val}]';
    end;
    
  end;
  
  VertexAttribProperty = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_ATTRIB_BINDING:              VertexAttribProperty read new VertexAttribProperty($82D4);
    public static property VERTEX_ATTRIB_RELATIVE_OFFSET:      VertexAttribProperty read new VertexAttribProperty($82D5);
    public static property VERTEX_ATTRIB_ARRAY_ENABLED:        VertexAttribProperty read new VertexAttribProperty($8622);
    public static property VERTEX_ATTRIB_ARRAY_SIZE:           VertexAttribProperty read new VertexAttribProperty($8623);
    public static property VERTEX_ATTRIB_ARRAY_STRIDE:         VertexAttribProperty read new VertexAttribProperty($8624);
    public static property VERTEX_ATTRIB_ARRAY_TYPE:           VertexAttribProperty read new VertexAttribProperty($8625);
    public static property CURRENT_VERTEX_ATTRIB:              VertexAttribProperty read new VertexAttribProperty($8626);
    public static property VERTEX_ATTRIB_ARRAY_LONG:           VertexAttribProperty read new VertexAttribProperty($874E);
    public static property VERTEX_ATTRIB_ARRAY_NORMALIZED:     VertexAttribProperty read new VertexAttribProperty($886A);
    public static property VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: VertexAttribProperty read new VertexAttribProperty($889F);
    public static property VERTEX_ATTRIB_ARRAY_INTEGER:        VertexAttribProperty read new VertexAttribProperty($88FD);
    public static property VERTEX_ATTRIB_ARRAY_DIVISOR:        VertexAttribProperty read new VertexAttribProperty($88FE);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($82D4) then Result := 'VERTEX_ATTRIB_BINDING' else
      if self.val = UInt32($82D5) then Result := 'VERTEX_ATTRIB_RELATIVE_OFFSET' else
      if self.val = UInt32($8622) then Result := 'VERTEX_ATTRIB_ARRAY_ENABLED' else
      if self.val = UInt32($8623) then Result := 'VERTEX_ATTRIB_ARRAY_SIZE' else
      if self.val = UInt32($8624) then Result := 'VERTEX_ATTRIB_ARRAY_STRIDE' else
      if self.val = UInt32($8625) then Result := 'VERTEX_ATTRIB_ARRAY_TYPE' else
      if self.val = UInt32($8626) then Result := 'CURRENT_VERTEX_ATTRIB' else
      if self.val = UInt32($874E) then Result := 'VERTEX_ATTRIB_ARRAY_LONG' else
      if self.val = UInt32($886A) then Result := 'VERTEX_ATTRIB_ARRAY_NORMALIZED' else
      if self.val = UInt32($889F) then Result := 'VERTEX_ATTRIB_ARRAY_BUFFER_BINDING' else
      if self.val = UInt32($88FD) then Result := 'VERTEX_ATTRIB_ARRAY_INTEGER' else
      if self.val = UInt32($88FE) then Result := 'VERTEX_ATTRIB_ARRAY_DIVISOR' else
        Result := $'VertexAttribProperty[{self.val}]';
    end;
    
  end;
  
  VertexAttribType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:                         VertexAttribType read new VertexAttribType($1400);
    public static property UNSIGNED_BYTE:                VertexAttribType read new VertexAttribType($1401);
    public static property SHORT:                        VertexAttribType read new VertexAttribType($1402);
    public static property UNSIGNED_SHORT:               VertexAttribType read new VertexAttribType($1403);
    public static property INT:                          VertexAttribType read new VertexAttribType($1404);
    public static property UNSIGNED_INT:                 VertexAttribType read new VertexAttribType($1405);
    public static property FLOAT:                        VertexAttribType read new VertexAttribType($1406);
    public static property DOUBLE:                       VertexAttribType read new VertexAttribType($140A);
    public static property HALF_FLOAT:                   VertexAttribType read new VertexAttribType($140B);
    public static property FIXED:                        VertexAttribType read new VertexAttribType($140C);
    public static property UNSIGNED_INT_2_10_10_10_REV:  VertexAttribType read new VertexAttribType($8368);
    public static property UNSIGNED_INT_10F_11F_11F_REV: VertexAttribType read new VertexAttribType($8C3B);
    public static property INT_2_10_10_10_REV:           VertexAttribType read new VertexAttribType($8D9F);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
      if self.val = UInt32($140B) then Result := 'HALF_FLOAT' else
      if self.val = UInt32($140C) then Result := 'FIXED' else
      if self.val = UInt32($8368) then Result := 'UNSIGNED_INT_2_10_10_10_REV' else
      if self.val = UInt32($8C3B) then Result := 'UNSIGNED_INT_10F_11F_11F_REV' else
      if self.val = UInt32($8D9F) then Result := 'INT_2_10_10_10_REV' else
        Result := $'VertexAttribType[{self.val}]';
    end;
    
  end;
  
  VertexBufferObjectUsage = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property STREAM_DRAW:  VertexBufferObjectUsage read new VertexBufferObjectUsage($88E0);
    public static property STREAM_READ:  VertexBufferObjectUsage read new VertexBufferObjectUsage($88E1);
    public static property STREAM_COPY:  VertexBufferObjectUsage read new VertexBufferObjectUsage($88E2);
    public static property STATIC_DRAW:  VertexBufferObjectUsage read new VertexBufferObjectUsage($88E4);
    public static property STATIC_READ:  VertexBufferObjectUsage read new VertexBufferObjectUsage($88E5);
    public static property STATIC_COPY:  VertexBufferObjectUsage read new VertexBufferObjectUsage($88E6);
    public static property DYNAMIC_DRAW: VertexBufferObjectUsage read new VertexBufferObjectUsage($88E8);
    public static property DYNAMIC_READ: VertexBufferObjectUsage read new VertexBufferObjectUsage($88E9);
    public static property DYNAMIC_COPY: VertexBufferObjectUsage read new VertexBufferObjectUsage($88EA);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($88E0) then Result := 'STREAM_DRAW' else
      if self.val = UInt32($88E1) then Result := 'STREAM_READ' else
      if self.val = UInt32($88E2) then Result := 'STREAM_COPY' else
      if self.val = UInt32($88E4) then Result := 'STATIC_DRAW' else
      if self.val = UInt32($88E5) then Result := 'STATIC_READ' else
      if self.val = UInt32($88E6) then Result := 'STATIC_COPY' else
      if self.val = UInt32($88E8) then Result := 'DYNAMIC_DRAW' else
      if self.val = UInt32($88E9) then Result := 'DYNAMIC_READ' else
      if self.val = UInt32($88EA) then Result := 'DYNAMIC_COPY' else
        Result := $'VertexBufferObjectUsage[{self.val}]';
    end;
    
  end;
  
  VertexHintsMask = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property VERTEX23_BIT:                VertexHintsMask read new VertexHintsMask($0004);
    public static property VERTEX4_BIT:                 VertexHintsMask read new VertexHintsMask($0008);
    public static property COLOR3_BIT:                  VertexHintsMask read new VertexHintsMask($10000);
    public static property COLOR4_BIT:                  VertexHintsMask read new VertexHintsMask($20000);
    public static property EDGEFLAG_BIT:                VertexHintsMask read new VertexHintsMask($40000);
    public static property INDEX_BIT:                   VertexHintsMask read new VertexHintsMask($80000);
    public static property MAT_AMBIENT_BIT:             VertexHintsMask read new VertexHintsMask($100000);
    public static property MAT_AMBIENT_AND_DIFFUSE_BIT: VertexHintsMask read new VertexHintsMask($200000);
    public static property MAT_DIFFUSE_BIT:             VertexHintsMask read new VertexHintsMask($400000);
    public static property MAT_EMISSION_BIT:            VertexHintsMask read new VertexHintsMask($800000);
    public static property MAT_COLOR_INDEXES_BIT:       VertexHintsMask read new VertexHintsMask($1000000);
    public static property MAT_SHININESS_BIT:           VertexHintsMask read new VertexHintsMask($2000000);
    public static property MAT_SPECULAR_BIT:            VertexHintsMask read new VertexHintsMask($4000000);
    public static property NORMAL_BIT:                  VertexHintsMask read new VertexHintsMask($8000000);
    public static property TEXCOORD1_BIT:               VertexHintsMask read new VertexHintsMask($10000000);
    public static property TEXCOORD2_BIT:               VertexHintsMask read new VertexHintsMask($20000000);
    public static property TEXCOORD3_BIT:               VertexHintsMask read new VertexHintsMask($40000000);
    public static property TEXCOORD4_BIT:               VertexHintsMask read new VertexHintsMask($80000000);
    
    public static function operator+(f1,f2: VertexHintsMask) := new VertexHintsMask(f1.val or f2.val);
    public static function operator or(f1,f2: VertexHintsMask) := f1+f2;
    
    public static procedure operator+=(var f1: VertexHintsMask; f2: VertexHintsMask) := f1 := f1+f2;
    
    public property HAS_FLAG_VERTEX23_BIT:                boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_VERTEX4_BIT:                 boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_COLOR3_BIT:                  boolean read self.val and $10000 <> 0;
    public property HAS_FLAG_COLOR4_BIT:                  boolean read self.val and $20000 <> 0;
    public property HAS_FLAG_EDGEFLAG_BIT:                boolean read self.val and $40000 <> 0;
    public property HAS_FLAG_INDEX_BIT:                   boolean read self.val and $80000 <> 0;
    public property HAS_FLAG_MAT_AMBIENT_BIT:             boolean read self.val and $100000 <> 0;
    public property HAS_FLAG_MAT_AMBIENT_AND_DIFFUSE_BIT: boolean read self.val and $200000 <> 0;
    public property HAS_FLAG_MAT_DIFFUSE_BIT:             boolean read self.val and $400000 <> 0;
    public property HAS_FLAG_MAT_EMISSION_BIT:            boolean read self.val and $800000 <> 0;
    public property HAS_FLAG_MAT_COLOR_INDEXES_BIT:       boolean read self.val and $1000000 <> 0;
    public property HAS_FLAG_MAT_SHININESS_BIT:           boolean read self.val and $2000000 <> 0;
    public property HAS_FLAG_MAT_SPECULAR_BIT:            boolean read self.val and $4000000 <> 0;
    public property HAS_FLAG_NORMAL_BIT:                  boolean read self.val and $8000000 <> 0;
    public property HAS_FLAG_TEXCOORD1_BIT:               boolean read self.val and $10000000 <> 0;
    public property HAS_FLAG_TEXCOORD2_BIT:               boolean read self.val and $20000000 <> 0;
    public property HAS_FLAG_TEXCOORD3_BIT:               boolean read self.val and $40000000 <> 0;
    public property HAS_FLAG_TEXCOORD4_BIT:               boolean read self.val and $80000000 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and Int32($0004) = Int32($0004) then res += 'VERTEX23_BIT+';
      if self.val and Int32($0008) = Int32($0008) then res += 'VERTEX4_BIT+';
      if self.val and Int32($10000) = Int32($10000) then res += 'COLOR3_BIT+';
      if self.val and Int32($20000) = Int32($20000) then res += 'COLOR4_BIT+';
      if self.val and Int32($40000) = Int32($40000) then res += 'EDGEFLAG_BIT+';
      if self.val and Int32($80000) = Int32($80000) then res += 'INDEX_BIT+';
      if self.val and Int32($100000) = Int32($100000) then res += 'MAT_AMBIENT_BIT+';
      if self.val and Int32($200000) = Int32($200000) then res += 'MAT_AMBIENT_AND_DIFFUSE_BIT+';
      if self.val and Int32($400000) = Int32($400000) then res += 'MAT_DIFFUSE_BIT+';
      if self.val and Int32($800000) = Int32($800000) then res += 'MAT_EMISSION_BIT+';
      if self.val and Int32($1000000) = Int32($1000000) then res += 'MAT_COLOR_INDEXES_BIT+';
      if self.val and Int32($2000000) = Int32($2000000) then res += 'MAT_SHININESS_BIT+';
      if self.val and Int32($4000000) = Int32($4000000) then res += 'MAT_SPECULAR_BIT+';
      if self.val and Int32($8000000) = Int32($8000000) then res += 'NORMAL_BIT+';
      if self.val and Int32($10000000) = Int32($10000000) then res += 'TEXCOORD1_BIT+';
      if self.val and Int32($20000000) = Int32($20000000) then res += 'TEXCOORD2_BIT+';
      if self.val and Int32($40000000) = Int32($40000000) then res += 'TEXCOORD3_BIT+';
      if self.val and Int32($80000000) = Int32($80000000) then res += 'TEXCOORD4_BIT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
      if self.val=0 then
        Result := 'NONE' else
        Result := $'VertexHintsMask[{self.val}]';
    end;
    
  end;
  
  VertexPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SHORT:  VertexPointerType read new VertexPointerType($1402);
    public static property INT:    VertexPointerType read new VertexPointerType($1404);
    public static property FLOAT:  VertexPointerType read new VertexPointerType($1406);
    public static property DOUBLE: VertexPointerType read new VertexPointerType($140A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := $'VertexPointerType[{self.val}]';
    end;
    
  end;
  
  VertexProvokingMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FIRST_VERTEX_CONVENTION: VertexProvokingMode read new VertexProvokingMode($8E4D);
    public static property LAST_VERTEX_CONVENTION:  VertexProvokingMode read new VertexProvokingMode($8E4E);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8E4D) then Result := 'FIRST_VERTEX_CONVENTION' else
      if self.val = UInt32($8E4E) then Result := 'LAST_VERTEX_CONVENTION' else
        Result := $'VertexProvokingMode[{self.val}]';
    end;
    
  end;
  
  VertexShaderCoordOut = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property X:            VertexShaderCoordOut read new VertexShaderCoordOut($87D5);
    public static property Y:            VertexShaderCoordOut read new VertexShaderCoordOut($87D6);
    public static property Z:            VertexShaderCoordOut read new VertexShaderCoordOut($87D7);
    public static property W:            VertexShaderCoordOut read new VertexShaderCoordOut($87D8);
    public static property NEGATIVE_X:   VertexShaderCoordOut read new VertexShaderCoordOut($87D9);
    public static property NEGATIVE_Y:   VertexShaderCoordOut read new VertexShaderCoordOut($87DA);
    public static property NEGATIVE_Z:   VertexShaderCoordOut read new VertexShaderCoordOut($87DB);
    public static property NEGATIVE_W:   VertexShaderCoordOut read new VertexShaderCoordOut($87DC);
    public static property ZERO_EXT:     VertexShaderCoordOut read new VertexShaderCoordOut($87DD);
    public static property ONE_EXT:      VertexShaderCoordOut read new VertexShaderCoordOut($87DE);
    public static property NEGATIVE_ONE: VertexShaderCoordOut read new VertexShaderCoordOut($87DF);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($87D5) then Result := 'X' else
      if self.val = UInt32($87D6) then Result := 'Y' else
      if self.val = UInt32($87D7) then Result := 'Z' else
      if self.val = UInt32($87D8) then Result := 'W' else
      if self.val = UInt32($87D9) then Result := 'NEGATIVE_X' else
      if self.val = UInt32($87DA) then Result := 'NEGATIVE_Y' else
      if self.val = UInt32($87DB) then Result := 'NEGATIVE_Z' else
      if self.val = UInt32($87DC) then Result := 'NEGATIVE_W' else
      if self.val = UInt32($87DD) then Result := 'ZERO_EXT' else
      if self.val = UInt32($87DE) then Result := 'ONE_EXT' else
      if self.val = UInt32($87DF) then Result := 'NEGATIVE_ONE' else
        Result := $'VertexShaderCoordOut[{self.val}]';
    end;
    
  end;
  
  VertexShaderOp = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property OP_INDEX:           VertexShaderOp read new VertexShaderOp($8782);
    public static property OP_NEGATE:          VertexShaderOp read new VertexShaderOp($8783);
    public static property OP_DOT3:            VertexShaderOp read new VertexShaderOp($8784);
    public static property OP_DOT4:            VertexShaderOp read new VertexShaderOp($8785);
    public static property OP_MUL:             VertexShaderOp read new VertexShaderOp($8786);
    public static property OP_ADD:             VertexShaderOp read new VertexShaderOp($8787);
    public static property OP_MADD:            VertexShaderOp read new VertexShaderOp($8788);
    public static property OP_FRAC:            VertexShaderOp read new VertexShaderOp($8789);
    public static property OP_MAX:             VertexShaderOp read new VertexShaderOp($878A);
    public static property OP_MIN:             VertexShaderOp read new VertexShaderOp($878B);
    public static property OP_SET_GE:          VertexShaderOp read new VertexShaderOp($878C);
    public static property OP_SET_LT:          VertexShaderOp read new VertexShaderOp($878D);
    public static property OP_CLAMP:           VertexShaderOp read new VertexShaderOp($878E);
    public static property OP_FLOOR:           VertexShaderOp read new VertexShaderOp($878F);
    public static property OP_ROUND:           VertexShaderOp read new VertexShaderOp($8790);
    public static property OP_EXP_BASE_2:      VertexShaderOp read new VertexShaderOp($8791);
    public static property OP_LOG_BASE_2:      VertexShaderOp read new VertexShaderOp($8792);
    public static property OP_POWER:           VertexShaderOp read new VertexShaderOp($8793);
    public static property OP_RECIP:           VertexShaderOp read new VertexShaderOp($8794);
    public static property OP_RECIP_SQRT:      VertexShaderOp read new VertexShaderOp($8795);
    public static property OP_SUB:             VertexShaderOp read new VertexShaderOp($8796);
    public static property OP_CROSS_PRODUCT:   VertexShaderOp read new VertexShaderOp($8797);
    public static property OP_MULTIPLY_MATRIX: VertexShaderOp read new VertexShaderOp($8798);
    public static property OP_MOV:             VertexShaderOp read new VertexShaderOp($8799);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8782) then Result := 'OP_INDEX' else
      if self.val = UInt32($8783) then Result := 'OP_NEGATE' else
      if self.val = UInt32($8784) then Result := 'OP_DOT3' else
      if self.val = UInt32($8785) then Result := 'OP_DOT4' else
      if self.val = UInt32($8786) then Result := 'OP_MUL' else
      if self.val = UInt32($8787) then Result := 'OP_ADD' else
      if self.val = UInt32($8788) then Result := 'OP_MADD' else
      if self.val = UInt32($8789) then Result := 'OP_FRAC' else
      if self.val = UInt32($878A) then Result := 'OP_MAX' else
      if self.val = UInt32($878B) then Result := 'OP_MIN' else
      if self.val = UInt32($878C) then Result := 'OP_SET_GE' else
      if self.val = UInt32($878D) then Result := 'OP_SET_LT' else
      if self.val = UInt32($878E) then Result := 'OP_CLAMP' else
      if self.val = UInt32($878F) then Result := 'OP_FLOOR' else
      if self.val = UInt32($8790) then Result := 'OP_ROUND' else
      if self.val = UInt32($8791) then Result := 'OP_EXP_BASE_2' else
      if self.val = UInt32($8792) then Result := 'OP_LOG_BASE_2' else
      if self.val = UInt32($8793) then Result := 'OP_POWER' else
      if self.val = UInt32($8794) then Result := 'OP_RECIP' else
      if self.val = UInt32($8795) then Result := 'OP_RECIP_SQRT' else
      if self.val = UInt32($8796) then Result := 'OP_SUB' else
      if self.val = UInt32($8797) then Result := 'OP_CROSS_PRODUCT' else
      if self.val = UInt32($8798) then Result := 'OP_MULTIPLY_MATRIX' else
      if self.val = UInt32($8799) then Result := 'OP_MOV' else
        Result := $'VertexShaderOp[{self.val}]';
    end;
    
  end;
  
  VertexShaderParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CURRENT_VERTEX: VertexShaderParameter read new VertexShaderParameter($87E2);
    public static property MVP_MATRIX:     VertexShaderParameter read new VertexShaderParameter($87E3);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($87E2) then Result := 'CURRENT_VERTEX' else
      if self.val = UInt32($87E3) then Result := 'MVP_MATRIX' else
        Result := $'VertexShaderParameter[{self.val}]';
    end;
    
  end;
  
  VertexShaderStorageType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VARIANT:        VertexShaderStorageType read new VertexShaderStorageType($87C1);
    public static property INVARIANT:      VertexShaderStorageType read new VertexShaderStorageType($87C2);
    public static property LOCAL_CONSTANT: VertexShaderStorageType read new VertexShaderStorageType($87C3);
    public static property LOCAL:          VertexShaderStorageType read new VertexShaderStorageType($87C4);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($87C1) then Result := 'VARIANT' else
      if self.val = UInt32($87C2) then Result := 'INVARIANT' else
      if self.val = UInt32($87C3) then Result := 'LOCAL_CONSTANT' else
      if self.val = UInt32($87C4) then Result := 'LOCAL' else
        Result := $'VertexShaderStorageType[{self.val}]';
    end;
    
  end;
  
  VertexShaderTextureUnitParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CURRENT_TEXTURE_COORDS: VertexShaderTextureUnitParameter read new VertexShaderTextureUnitParameter($0B03);
    public static property TEXTURE_MATRIX:         VertexShaderTextureUnitParameter read new VertexShaderTextureUnitParameter($0BA8);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0B03) then Result := 'CURRENT_TEXTURE_COORDS' else
      if self.val = UInt32($0BA8) then Result := 'TEXTURE_MATRIX' else
        Result := $'VertexShaderTextureUnitParameter[{self.val}]';
    end;
    
  end;
  
  VertexShaderWriteMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FALSE: VertexShaderWriteMask read new VertexShaderWriteMask($0000);
    public static property TRUE:  VertexShaderWriteMask read new VertexShaderWriteMask($0001);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'FALSE' else
      if self.val = UInt32($0001) then Result := 'TRUE' else
        Result := $'VertexShaderWriteMask[{self.val}]';
    end;
    
  end;
  
  VertexStream = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_STREAM0: VertexStream read new VertexStream($876C);
    public static property VERTEX_STREAM1: VertexStream read new VertexStream($876D);
    public static property VERTEX_STREAM2: VertexStream read new VertexStream($876E);
    public static property VERTEX_STREAM3: VertexStream read new VertexStream($876F);
    public static property VERTEX_STREAM4: VertexStream read new VertexStream($8770);
    public static property VERTEX_STREAM5: VertexStream read new VertexStream($8771);
    public static property VERTEX_STREAM6: VertexStream read new VertexStream($8772);
    public static property VERTEX_STREAM7: VertexStream read new VertexStream($8773);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($876C) then Result := 'VERTEX_STREAM0' else
      if self.val = UInt32($876D) then Result := 'VERTEX_STREAM1' else
      if self.val = UInt32($876E) then Result := 'VERTEX_STREAM2' else
      if self.val = UInt32($876F) then Result := 'VERTEX_STREAM3' else
      if self.val = UInt32($8770) then Result := 'VERTEX_STREAM4' else
      if self.val = UInt32($8771) then Result := 'VERTEX_STREAM5' else
      if self.val = UInt32($8772) then Result := 'VERTEX_STREAM6' else
      if self.val = UInt32($8773) then Result := 'VERTEX_STREAM7' else
        Result := $'VertexStream[{self.val}]';
    end;
    
  end;
  
  VertexWeightPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FLOAT: VertexWeightPointerType read new VertexWeightPointerType($1406);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1406) then Result := 'FLOAT' else
        Result := $'VertexWeightPointerType[{self.val}]';
    end;
    
  end;
  
  WeightPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:           WeightPointerType read new WeightPointerType($1400);
    public static property UNSIGNED_BYTE:  WeightPointerType read new WeightPointerType($1401);
    public static property SHORT:          WeightPointerType read new WeightPointerType($1402);
    public static property UNSIGNED_SHORT: WeightPointerType read new WeightPointerType($1403);
    public static property INT:            WeightPointerType read new WeightPointerType($1404);
    public static property UNSIGNED_INT:   WeightPointerType read new WeightPointerType($1405);
    public static property FLOAT:          WeightPointerType read new WeightPointerType($1406);
    public static property DOUBLE:         WeightPointerType read new WeightPointerType($140A);
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := $'WeightPointerType[{self.val}]';
    end;
    
  end;
  
  
  